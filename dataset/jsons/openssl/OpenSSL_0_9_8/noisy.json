[
{
"project": "openssl", "commit_id": "OpenSSL_0_9_8_apps_c", "target": 0, "func": "int args_from_file(char *file, int *argc, char **argv[])\\r\\n{\\r\\nFILE *fp;\\r\\nint num,i;\\r\\nunsigned int len;\\r\\nstatic char *buf=NULL;\\r\\nstatic char **arg=NULL;\\r\\nchar *p;\\r\\nstruct stat stbuf;\\r\\nif (stat(file,&stbuf) < 0) return(0);\\r\\nfp=fopen(file,\"r\");\\r\\nif (fp == NULL)\\r\\nreturn(0);\\r\\n*argc=0;\\r\\n*argv=NULL;\\r\\nlen=(unsigned int)stbuf.st_size;\\r\\nif (buf != NULL) OPENSSL_free(buf);\\r\\nbuf=(char *)OPENSSL_malloc(len+1);\\r\\nif (buf == NULL) return(0);\\r\\nlen=fread(buf,1,len,fp);\\r\\nif (len <= 1) return(0);\\r\\nbuf[len]='\\0';\\r\\ni=0;\\r\\nfor (p=buf; *p; p++)\\r\\nif (*p == '\\n') i++;\\r\\nif (arg != NULL) OPENSSL_free(arg);\\r\\narg=(char **)OPENSSL_malloc(sizeof(char *)*(i*2));\\r\\n*argv=arg;\\r\\nnum=0;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (!*p) break;\\r\\nif (*p == '#')\\r\\n{\\r\\nwhile (*p && (*p != '\\n')) p++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++)=p;\\r\\nnum++;\\r\\nwhile (*p && ((*p != ' ') && (*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (*p == '\\n')\\r\\n{\\r\\n*(p++)='\\0';\\r\\ncontinue;\\r\\n}\\r\\np++;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (*p == '\\n')\\r\\n{\\r\\np++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++)=p++;\\r\\nnum++;\\r\\nwhile (*p && (*p != '\\n')) p++;\\r\\nif (!*p) break;\\r\\n*(p++)='\\0';\\r\\n}\\r\\n*argc=num;\\r\\nreturn(1);\\r\\n}\\r\\nint str2fmt(char *s)\\r\\n{\\r\\nif ((*s == 'D') || (*s == 'd'))\\r\\nreturn(FORMAT_ASN1);\\r\\nelse if ((*s == 'T') || (*s == 't'))\\r\\nreturn(FORMAT_TEXT);\\r\\nelse if ((*s == 'P') || (*s == 'p'))\\r\\nreturn(FORMAT_PEM);\\r\\nelse if ((*s == 'N') || (*s == 'n'))\\r\\nreturn(FORMAT_NETSCAPE);\\r\\nelse if ((*s == 'S') || (*s == 's'))\\r\\nreturn(FORMAT_SMIME);\\r\\nelse if ((*s == '1')\\r\\n|| (strcmp(s,\"PKCS12\") == 0) || (strcmp(s,\"pkcs12\") == 0)\\r\\n|| (strcmp(s,\"P12\") == 0) || (strcmp(s,\"p12\") == 0))\\r\\nreturn(FORMAT_PKCS12);\\r\\nelse if ((*s == 'E') || (*s == 'e'))\\r\\nreturn(FORMAT_ENGINE);\\r\\nelse\\r\\nreturn(FORMAT_UNDEF);\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nint i,n;\\r\\nchar *p=NULL;\\r\\nn=strlen(in);\\r\\nfor (i=n-1; i>0; i--)\\r\\n{\\r\\nif ((in[i] == '/') || (in[i] == '\\\\') || (in[i] == ':'))\\r\\n{\\r\\np= &(in[i+1]);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p == NULL)\\r\\np=in;\\r\\nn=strlen(p);\\r\\n#if defined(OPENSSL_SYS_NETWARE)\\r\\nif ((n > 4) && (p[n-4] == '.') &&\\r\\n((p[n-3] == 'n') || (p[n-3] == 'N')) &&\\r\\n((p[n-2] == 'l') || (p[n-2] == 'L')) &&\\r\\n((p[n-1] == 'm') || (p[n-1] == 'M')))\\r\\nn-=4;\\r\\n#else\\r\\nif ((n > 4) && (p[n-4] == '.') &&\\r\\n((p[n-3] == 'e') || (p[n-3] == 'E')) &&\\r\\n((p[n-2] == 'x') || (p[n-2] == 'X')) &&\\r\\n((p[n-1] == 'e') || (p[n-1] == 'E')))\\r\\nn-=4;\\r\\n#endif\\r\\nif (n > size-1)\\r\\nn=size-1;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((p[i] >= 'A') && (p[i] <= 'Z'))\\r\\nout[i]=p[i]-'A'+'a';\\r\\nelse\\r\\nout[i]=p[i];\\r\\n}\\r\\nout[n]='\\0';\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p=in, *q;\\r\\nchar *chars=\":]>\";\\r\\nwhile(*chars != '\\0')\\r\\n{\\r\\nq=strrchr(p,*chars);\\r\\nif (q > p)\\r\\np = q + 1;\\r\\nchars++;\\r\\n}\\r\\nq=strrchr(p,'.');\\r\\nif (q == NULL)\\r\\nq = p + strlen(p);\\r\\nstrncpy(out,p,size-1);\\r\\nif (q-p >= size)\\r\\n{\\r\\nout[size-1]='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nout[q-p]='\\0';\\r\\n}\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p;\\r\\np=strrchr(in,'/');\\r\\nif (p != NULL)\\r\\np++;\\r\\nelse\\r\\np=in;\\r\\nBUF_strlcpy(out,p,size);\\r\\n}\\r\\nint chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])\\r\\n{\\r\\nint num,len,i;\\r\\nchar *p;\\r\\n*argc=0;\\r\\n*argv=NULL;\\r\\nlen=strlen(buf);\\r\\ni=0;\\r\\nif (arg->count == 0)\\r\\n{\\r\\narg->count=20;\\r\\narg->data=(char **)OPENSSL_malloc(sizeof(char *)*arg->count);\\r\\n}\\r\\nfor (i=0; i<arg->count; i++)\\r\\narg->data[i]=NULL;\\r\\nnum=0;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (!*p) break;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (num >= arg->count)\\r\\n{\\r\\nchar **tmp_p;\\r\\nint tlen = arg->count + 20;\\r\\ntmp_p = (char **)OPENSSL_realloc(arg->data,\\r\\nsizeof(char *)*tlen);\\r\\nif (tmp_p == NULL)\\r\\nreturn 0;\\r\\narg->data = tmp_p;\\r\\narg->count = tlen;\\r\\nfor (i = num; i < arg->count; i++)\\r\\narg->data[i] = NULL;\\r\\n}\\r\\narg->data[num++]=p;\\r\\nif ((*p == '\\'') || (*p == '\\\"'))\\r\\n{\\r\\ni= *(p++);\\r\\narg->data[num-1]++;\\r\\nwhile (*p && (*p != i))\\r\\np++;\\r\\n*p='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (*p && ((*p != ' ') &&\\r\\n(*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (*p == '\\0')\\r\\np--;\\r\\nelse\\r\\n*p='\\0';\\r\\n}\\r\\np++;\\r\\n}\\r\\n*argc=num;\\r\\n*argv=arg->data;\\r\\nreturn(1);\\r\\n}\\r\\nint app_init(long mesgwin)\\r\\n{\\r\\nreturn(1);\\r\\n}\\r\\nint dump_cert_text (BIO *out, X509 *x)\\r\\n{\\r\\nchar *p;\\r\\np=X509_NAME_oneline(X509_get_subject_name(x),NULL,0);\\r\\nBIO_puts(out,\"subject=\");\\r\\nBIO_puts(out,p);\\r\\nOPENSSL_free(p);\\r\\np=X509_NAME_oneline(X509_get_issuer_name(x),NULL,0);\\r\\nBIO_puts(out,\"\\nissuer=\");\\r\\nBIO_puts(out,p);\\r\\nBIO_puts(out,\"\\n\");\\r\\nOPENSSL_free(p);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ui_open(UI *ui)\\r\\n{\\r\\nreturn UI_method_get_opener(UI_OpenSSL())(ui);\\r\\n}\\r\\nstatic int ui_read(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nif (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD\\r\\n&& UI_get0_user_data(ui))\\r\\n{\\r\\nswitch(UI_get_string_type(uis))\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nconst char *password =\\r\\n((PW_CB_DATA *)UI_get0_user_data(ui))->password;\\r\\nif (password && password[0] != '\\0')\\r\\n{\\r\\nUI_set_result(ui, uis, password);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn UI_method_get_reader(UI_OpenSSL())(ui, uis);\\r\\n}\\r\\nstatic int ui_write(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nif (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD\\r\\n&& UI_get0_user_data(ui))\\r\\n{\\r\\nswitch(UI_get_string_type(uis))\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nconst char *password =\\r\\n((PW_CB_DATA *)UI_get0_user_data(ui))->password;\\r\\nif (password && password[0] != '\\0')\\r\\nreturn 1;\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn UI_method_get_writer(UI_OpenSSL())(ui, uis);\\r\\n}\\r\\nstatic int ui_close(UI *ui)\\r\\n{\\r\\nreturn UI_method_get_closer(UI_OpenSSL())(ui);\\r\\n}\\r\\nint setup_ui_method(void)\\r\\n{\\r\\nui_method = UI_create_method(\"OpenSSL application user interface\");\\r\\nUI_method_set_opener(ui_method, ui_open);\\r\\nUI_method_set_reader(ui_method, ui_read);\\r\\nUI_method_set_writer(ui_method, ui_write);\\r\\nUI_method_set_closer(ui_method, ui_close);\\r\\nreturn 0;\\r\\n}\\r\\nvoid destroy_ui_method(void)\\r\\n{\\r\\nif(ui_method)\\r\\n{\\r\\nUI_destroy_method(ui_method);\\r\\nui_method = NULL;\\r\\n}\\r\\n}\\r\\nint password_callback(char *buf, int bufsiz, int verify,\\r\\nPW_CB_DATA *cb_tmp)\\r\\n{\\r\\nUI *ui = NULL;\\r\\nint res = 0;\\r\\nconst char *prompt_info = NULL;\\r\\nconst char *password = NULL;\\r\\nPW_CB_DATA *cb_data = (PW_CB_DATA *)cb_tmp;\\r\\nif (cb_data)\\r\\n{\\r\\nif (cb_data->password)\\r\\npassword = cb_data->password;\\r\\nif (cb_data->prompt_info)\\r\\nprompt_info = cb_data->prompt_info;\\r\\n}\\r\\nif (password)\\r\\n{\\r\\nres = strlen(password);\\r\\nif (res > bufsiz)\\r\\nres = bufsiz;\\r\\nmemcpy(buf, password, res);\\r\\nreturn res;\\r\\n}\\r\\nui = UI_new_method(ui_method);\\r\\nif (ui)\\r\\n{\\r\\nint ok = 0;\\r\\nchar *buff = NULL;\\r\\nint ui_flags = 0;\\r\\nchar *prompt = NULL;\\r\\nprompt = UI_construct_prompt(ui, \"pass phrase\",\\r\\nprompt_info);\\r\\nui_flags |= UI_INPUT_FLAG_DEFAULT_PWD;\\r\\nUI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);\\r\\nif (ok >= 0)\\r\\nok = UI_add_input_string(ui,prompt,ui_flags,buf,\\r\\nPW_MIN_LENGTH,BUFSIZ-1);\\r\\nif (ok >= 0 && verify)\\r\\n{\\r\\nbuff = (char *)OPENSSL_malloc(bufsiz);\\r\\nok = UI_add_verify_string(ui,prompt,ui_flags,buff,\\r\\nPW_MIN_LENGTH,BUFSIZ-1, buf);\\r\\n}\\r\\nif (ok >= 0)\\r\\ndo\\r\\n{\\r\\nok = UI_process(ui);\\r\\n}\\r\\nwhile (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));\\r\\nif (buff)\\r\\n{\\r\\nOPENSSL_cleanse(buff,(unsigned int)bufsiz);\\r\\nOPENSSL_free(buff);\\r\\n}\\r\\nif (ok >= 0)\\r\\nres = strlen(buf);\\r\\nif (ok == -1)\\r\\n{\\r\\nBIO_printf(bio_err, \"User interface error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nOPENSSL_cleanse(buf,(unsigned int)bufsiz);\\r\\nres = 0;\\r\\n}\\r\\nif (ok == -2)\\r\\n{\\r\\nBIO_printf(bio_err,\"aborted!\\n\");\\r\\nOPENSSL_cleanse(buf,(unsigned int)bufsiz);\\r\\nres = 0;\\r\\n}\\r\\nUI_free(ui);\\r\\nOPENSSL_free(prompt);\\r\\n}\\r\\nreturn res;\\r\\n}\\r\\nint app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)\\r\\n{\\r\\nint same;\\r\\nif(!arg2 || !arg1 || strcmp(arg1, arg2)) same = 0;\\r\\nelse same = 1;\\r\\nif(arg1) {\\r\\n*pass1 = app_get_pass(err, arg1, same);\\r\\nif(!*pass1) return 0;\\r\\n} else if(pass1) *pass1 = NULL;\\r\\nif(arg2) {\\r\\n*pass2 = app_get_pass(err, arg2, same ? 2 : 0);\\r\\nif(!*pass2) return 0;\\r\\n} else if(pass2) *pass2 = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic char *app_get_pass(BIO *err, char *arg, int keepbio)\\r\\n{\\r\\nchar *tmp, tpass[APP_PASS_LEN];\\r\\nstatic BIO *pwdbio = NULL;\\r\\nint i;\\r\\nif(!strncmp(arg, \"pass:\", 5)) return BUF_strdup(arg + 5);\\r\\nif(!strncmp(arg, \"env:\", 4)) {\\r\\ntmp = getenv(arg + 4);\\r\\nif(!tmp) {\\r\\nBIO_printf(err, \"Can't read environment variable %s\\n\", arg + 4);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn BUF_strdup(tmp);\\r\\n}\\r\\nif(!keepbio || !pwdbio) {\\r\\nif(!strncmp(arg, \"file:\", 5)) {\\r\\npwdbio = BIO_new_file(arg + 5, \"r\");\\r\\nif(!pwdbio) {\\r\\nBIO_printf(err, \"Can't open file %s\\n\", arg + 5);\\r\\nreturn NULL;\\r\\n}\\r\\n} else if(!strncmp(arg, \"fd:\", 3)) {\\r\\nBIO *btmp;\\r\\ni = atoi(arg + 3);\\r\\nif(i >= 0) pwdbio = BIO_new_fd(i, BIO_NOCLOSE);\\r\\nif((i < 0) || !pwdbio) {\\r\\nBIO_printf(err, \"Can't access file descriptor %s\\n\", arg + 3);\\r\\nreturn NULL;\\r\\n}\\r\\nbtmp = BIO_new(BIO_f_buffer());\\r\\npwdbio = BIO_push(btmp, pwdbio);\\r\\n} else if(!strcmp(arg, \"stdin\")) {\\r\\npwdbio = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif(!pwdbio) {\\r\\nBIO_printf(err, \"Can't open BIO for stdin\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\n} else {\\r\\nBIO_printf(err, \"Invalid password argument \\\"%s\\\"\\n\", arg);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\ni = BIO_gets(pwdbio, tpass, APP_PASS_LEN);\\r\\nif(keepbio != 1) {\\r\\nBIO_free_all(pwdbio);\\r\\npwdbio = NULL;\\r\\n}\\r\\nif(i <= 0) {\\r\\nBIO_printf(err, \"Error reading password from BIO\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\ntmp = strchr(tpass, '\\n');\\r\\nif(tmp) *tmp = 0;\\r\\nreturn BUF_strdup(tpass);\\r\\n}\\r\\nint add_oid_section(BIO *err, CONF *conf)\\r\\n{\\r\\nchar *p;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *cnf;\\r\\nint i;\\r\\nif(!(p=NCONF_get_string(conf,NULL,\"oid_section\")))\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nif(!(sktmp = NCONF_get_section(conf, p))) {\\r\\nBIO_printf(err, \"problem loading oid section %s\\n\", p);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\ncnf = sk_CONF_VALUE_value(sktmp, i);\\r\\nif(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {\\r\\nBIO_printf(err, \"problem creating object %s=%s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nX509 *load_cert(BIO *err, const char *file, int format,\\r\\nconst char *pass, ENGINE *e, const char *cert_descrip)\\r\\n{\\r\\nASN1_HEADER *ah=NULL;\\r\\nBUF_MEM *buf=NULL;\\r\\nX509 *x=NULL;\\r\\nBIO *cert;\\r\\nif ((cert=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL)\\r\\n{\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\nBIO_set_fp(cert,stdin,BIO_NOCLOSE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(cert,file) <= 0)\\r\\n{\\r\\nBIO_printf(err, \"Error opening %s %s\\n\",\\r\\ncert_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_X509_bio(cert,NULL);\\r\\nelse if (format == FORMAT_NETSCAPE)\\r\\n{\\r\\nconst unsigned char *p,*op;\\r\\nint size=0,i;\\r\\nbuf=BUF_MEM_new();\\r\\nfor (;;)\\r\\n{\\r\\nif ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))\\r\\ngoto end;\\r\\ni=BIO_read(cert,&(buf->data[size]),1024*10);\\r\\nsize+=i;\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nperror(\"reading certificate\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np=(unsigned char *)buf->data;\\r\\nop=p;\\r\\nif ((ah=d2i_ASN1_HEADER(NULL,&p,(long)size)) == NULL)\\r\\ngoto end;\\r\\nif ((ah->header == NULL) || (ah->header->data == NULL) ||\\r\\n(strncmp(NETSCAPE_CERT_HDR,(char *)ah->header->data,\\r\\nah->header->length) != 0))\\r\\n{\\r\\nBIO_printf(err,\"Error reading header on certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\np=op;\\r\\nah->meth=X509_asn1_meth();\\r\\nif ((ah=d2i_ASN1_HEADER(&ah,&p,(long)size)) == NULL)\\r\\ngoto end;\\r\\nx=(X509 *)ah->data;\\r\\nah->data=NULL;\\r\\n}\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_X509_AUX(cert,NULL,\\r\\n(pem_password_cb *)password_callback, NULL);\\r\\nelse if (format == FORMAT_PKCS12)\\r\\n{\\r\\nif (!load_pkcs12(err, cert,cert_descrip, NULL, NULL,\\r\\nNULL, &x, NULL))\\r\\ngoto end;\\r\\n}\\r\\nelse {\\r\\nBIO_printf(err,\"bad input format specified for %s\\n\",\\r\\ncert_descrip);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(err,\"unable to load certificate\\n\");\\r\\nERR_print_errors(err);\\r\\n}\\r\\nif (ah != NULL) ASN1_HEADER_free(ah);\\r\\nif (cert != NULL) BIO_free(cert);\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(x);\\r\\n}\\r\\nEVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,\\r\\nconst char *pass, ENGINE *e, const char *key_descrip)\\r\\n{\\r\\nBIO *key=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = pass;\\r\\ncb_data.prompt_info = file;\\r\\nif (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))\\r\\n{\\r\\nBIO_printf(err,\"no keyfile specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (format == FORMAT_ENGINE)\\r\\n{\\r\\nif (!e)\\r\\nBIO_printf(bio_err,\"no engine specified\\n\");\\r\\nelse\\r\\npkey = ENGINE_load_private_key(e, file,\\r\\nui_method, &cb_data);\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nkey=BIO_new(BIO_s_file());\\r\\nif (key == NULL)\\r\\n{\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL && maybe_stdin)\\r\\n{\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\nBIO_set_fp(key,stdin,BIO_NOCLOSE);\\r\\n}\\r\\nelse\\r\\nif (BIO_read_filename(key,file) <= 0)\\r\\n{\\r\\nBIO_printf(err, \"Error opening %s %s\\n\",\\r\\nkey_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\n{\\r\\npkey=d2i_PrivateKey_bio(key, NULL);\\r\\n}\\r\\nelse if (format == FORMAT_PEM)\\r\\n{\\r\\npkey=PEM_read_bio_PrivateKey(key,NULL,\\r\\n(pem_password_cb *)password_callback, &cb_data);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)\\r\\nelse if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)\\r\\npkey = load_netscape_key(err, key, file, key_descrip, format);\\r\\n#endif\\r\\nelse if (format == FORMAT_PKCS12)\\r\\n{\\r\\nif (!load_pkcs12(err, key, key_descrip,\\r\\n(pem_password_cb *)password_callback, &cb_data,\\r\\n&pkey, NULL, NULL))\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(err,\"bad input format specified for key file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (key != NULL) BIO_free(key);\\r\\nif (pkey == NULL)\\r\\nBIO_printf(err,\"unable to load %s\\n\", key_descrip);\\r\\nreturn(pkey);\\r\\n}\\r\\nEVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,\\r\\nconst char *pass, ENGINE *e, const char *key_descrip)\\r\\n{\\r\\nBIO *key=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = pass;\\r\\ncb_data.prompt_info = file;\\r\\nif (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE))\\r\\n{\\r\\nBIO_printf(err,\"no keyfile specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (format == FORMAT_ENGINE)\\r\\n{\\r\\nif (!e)\\r\\nBIO_printf(bio_err,\"no engine specified\\n\");\\r\\nelse\\r\\npkey = ENGINE_load_public_key(e, file,\\r\\nui_method, &cb_data);\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nkey=BIO_new(BIO_s_file());\\r\\nif (key == NULL)\\r\\n{\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL && maybe_stdin)\\r\\n{\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\nBIO_set_fp(key,stdin,BIO_NOCLOSE);\\r\\n}\\r\\nelse\\r\\nif (BIO_read_filename(key,file) <= 0)\\r\\n{\\r\\nBIO_printf(err, \"Error opening %s %s\\n\",\\r\\nkey_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\n{\\r\\npkey=d2i_PUBKEY_bio(key, NULL);\\r\\n}\\r\\nelse if (format == FORMAT_PEM)\\r\\n{\\r\\npkey=PEM_read_bio_PUBKEY(key,NULL,\\r\\n(pem_password_cb *)password_callback, &cb_data);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)\\r\\nelse if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)\\r\\npkey = load_netscape_key(err, key, file, key_descrip, format);\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nBIO_printf(err,\"bad input format specified for key file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (key != NULL) BIO_free(key);\\r\\nif (pkey == NULL)\\r\\nBIO_printf(err,\"unable to load %s\\n\", key_descrip);\\r\\nreturn(pkey);\\r\\n}\\r\\nstatic EVP_PKEY *\\r\\nload_netscape_key(BIO *err, BIO *key, const char *file,\\r\\nconst char *key_descrip, int format)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nBUF_MEM *buf;\\r\\nRSA *rsa;\\r\\nconst unsigned char *p;\\r\\nint size, i;\\r\\nbuf=BUF_MEM_new();\\r\\npkey = EVP_PKEY_new();\\r\\nsize = 0;\\r\\nif (buf == NULL || pkey == NULL)\\r\\ngoto error;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BUF_MEM_grow_clean(buf,size+1024*10))\\r\\ngoto error;\\r\\ni = BIO_read(key, &(buf->data[size]), 1024*10);\\r\\nsize += i;\\r\\nif (i == 0)\\r\\nbreak;\\r\\nif (i < 0)\\r\\n{\\r\\nBIO_printf(err, \"Error reading %s %s\",\\r\\nkey_descrip, file);\\r\\ngoto error;\\r\\n}\\r\\n}\\r\\np=(unsigned char *)buf->data;\\r\\nrsa = d2i_RSA_NET(NULL,&p,(long)size,NULL,\\r\\n(format == FORMAT_IISSGC ? 1 : 0));\\r\\nif (rsa == NULL)\\r\\ngoto error;\\r\\nBUF_MEM_free(buf);\\r\\nEVP_PKEY_set1_RSA(pkey, rsa);\\r\\nreturn pkey;\\r\\nerror:\\r\\nBUF_MEM_free(buf);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn NULL;\\r\\n}\\r\\nint set_name_ex(unsigned long *flags, const char *arg)\\r\\n{\\r\\nstatic const NAME_EX_TBL ex_tbl[] = {\\r\\n{ \"esc_2253\", ASN1_STRFLGS_ESC_2253, 0},\\r\\n{ \"esc_ctrl\", ASN1_STRFLGS_ESC_CTRL, 0},\\r\\n{ \"esc_msb\", ASN1_STRFLGS_ESC_MSB, 0},\\r\\n{ \"use_quote\", ASN1_STRFLGS_ESC_QUOTE, 0},\\r\\n{ \"utf8\", ASN1_STRFLGS_UTF8_CONVERT, 0},\\r\\n{ \"ignore_type\", ASN1_STRFLGS_IGNORE_TYPE, 0},\\r\\n{ \"show_type\", ASN1_STRFLGS_SHOW_TYPE, 0},\\r\\n{ \"dump_all\", ASN1_STRFLGS_DUMP_ALL, 0},\\r\\n{ \"dump_nostr\", ASN1_STRFLGS_DUMP_UNKNOWN, 0},\\r\\n{ \"dump_der\", ASN1_STRFLGS_DUMP_DER, 0},\\r\\n{ \"compat\", XN_FLAG_COMPAT, 0xffffffffL},\\r\\n{ \"sep_comma_plus\", XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_MASK},\\r\\n{ \"sep_comma_plus_space\", XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_MASK},\\r\\n{ \"sep_semi_plus_space\", XN_FLAG_SEP_SPLUS_SPC, XN_FLAG_SEP_MASK},\\r\\n{ \"sep_multiline\", XN_FLAG_SEP_MULTILINE, XN_FLAG_SEP_MASK},\\r\\n{ \"dn_rev\", XN_FLAG_DN_REV, 0},\\r\\n{ \"nofname\", XN_FLAG_FN_NONE, XN_FLAG_FN_MASK},\\r\\n{ \"sname\", XN_FLAG_FN_SN, XN_FLAG_FN_MASK},\\r\\n{ \"lname\", XN_FLAG_FN_LN, XN_FLAG_FN_MASK},\\r\\n{ \"align\", XN_FLAG_FN_ALIGN, 0},\\r\\n{ \"oid\", XN_FLAG_FN_OID, XN_FLAG_FN_MASK},\\r\\n{ \"space_eq\", XN_FLAG_SPC_EQ, 0},\\r\\n{ \"dump_unknown\", XN_FLAG_DUMP_UNKNOWN_FIELDS, 0},\\r\\n{ \"RFC2253\", XN_FLAG_RFC2253, 0xffffffffL},\\r\\n{ \"oneline\", XN_FLAG_ONELINE, 0xffffffffL},\\r\\n{ \"multiline\", XN_FLAG_MULTILINE, 0xffffffffL},\\r\\n{ \"ca_default\", XN_FLAG_MULTILINE, 0xffffffffL},\\r\\n{ NULL, 0, 0}\\r\\n};\\r\\nreturn set_multi_opts(flags, arg, ex_tbl);\\r\\n}\\r\\nint set_ext_copy(int *copy_type, const char *arg)\\r\\n{\\r\\nif (!strcasecmp(arg, \"none\"))\\r\\n*copy_type = EXT_COPY_NONE;\\r\\nelse if (!strcasecmp(arg, \"copy\"))\\r\\n*copy_type = EXT_COPY_ADD;\\r\\nelse if (!strcasecmp(arg, \"copyall\"))\\r\\n*copy_type = EXT_COPY_ALL;\\r\\nelse\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint copy_extensions(X509 *x, X509_REQ *req, int copy_type)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) *exts = NULL;\\r\\nX509_EXTENSION *ext, *tmpext;\\r\\nASN1_OBJECT *obj;\\r\\nint i, idx, ret = 0;\\r\\nif (!x || !req || (copy_type == EXT_COPY_NONE))\\r\\nreturn 1;\\r\\nexts = X509_REQ_get_extensions(req);\\r\\nfor(i = 0; i < sk_X509_EXTENSION_num(exts); i++) {\\r\\next = sk_X509_EXTENSION_value(exts, i);\\r\\nobj = X509_EXTENSION_get_object(ext);\\r\\nidx = X509_get_ext_by_OBJ(x, obj, -1);\\r\\nif (idx != -1) {\\r\\nif (copy_type == EXT_COPY_ADD)\\r\\ncontinue;\\r\\ndo {\\r\\ntmpext = X509_get_ext(x, idx);\\r\\nX509_delete_ext(x, idx);\\r\\nX509_EXTENSION_free(tmpext);\\r\\nidx = X509_get_ext_by_OBJ(x, obj, -1);\\r\\n} while (idx != -1);\\r\\n}\\r\\nif (!X509_add_ext(x, ext, -1))\\r\\ngoto end;\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int set_multi_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *vals;\\r\\nCONF_VALUE *val;\\r\\nint i, ret = 1;\\r\\nif(!arg) return 0;\\r\\nvals = X509V3_parse_list(arg);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(vals); i++) {\\r\\nval = sk_CONF_VALUE_value(vals, i);\\r\\nif (!set_table_opts(flags, val->name, in_tbl))\\r\\nret = 0;\\r\\n}\\r\\nsk_CONF_VALUE_pop_free(vals, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int set_table_opts(unsigned long *flags, const char *arg, const NAME_EX_TBL *in_tbl)\\r\\n{\\r\\nchar c;\\r\\nconst NAME_EX_TBL *ptbl;\\r\\nc = arg[0];\\r\\nif(c == '-') {\\r\\nc = 0;\\r\\narg++;\\r\\n} else if (c == '+') {\\r\\nc = 1;\\r\\narg++;\\r\\n} else c = 1;\\r\\nfor(ptbl = in_tbl; ptbl->name; ptbl++) {\\r\\nif(!strcasecmp(arg, ptbl->name)) {\\r\\n*flags &= ~ptbl->mask;\\r\\nif(c) *flags |= ptbl->flag;\\r\\nelse *flags &= ~ptbl->flag;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid print_name(BIO *out, const char *title, X509_NAME *nm, unsigned long lflags)\\r\\n{\\r\\nchar *buf;\\r\\nchar mline = 0;\\r\\nint indent = 0;\\r\\nif(title) BIO_puts(out, title);\\r\\nif((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmline = 1;\\r\\nindent = 4;\\r\\n}\\r\\nif(lflags == XN_FLAG_COMPAT) {\\r\\nbuf = X509_NAME_oneline(nm, 0, 0);\\r\\nBIO_puts(out, buf);\\r\\nBIO_puts(out, \"\\n\");\\r\\nOPENSSL_free(buf);\\r\\n} else {\\r\\nif(mline) BIO_puts(out, \"\\n\");\\r\\nX509_NAME_print_ex(out, nm, indent, lflags);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\n}\\r\\nX509_STORE *setup_verify(BIO *bp, char *CAfile, char *CApath)\\r\\n{\\r\\nX509_STORE *store;\\r\\nX509_LOOKUP *lookup;\\r\\nif(!(store = X509_STORE_new())) goto end;\\r\\nlookup=X509_STORE_add_lookup(store,X509_LOOKUP_file());\\r\\nif (lookup == NULL) goto end;\\r\\nif (CAfile) {\\r\\nif(!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM)) {\\r\\nBIO_printf(bp, \"Error loading file %s\\n\", CAfile);\\r\\ngoto end;\\r\\n}\\r\\n} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(store,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) goto end;\\r\\nif (CApath) {\\r\\nif(!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM)) {\\r\\nBIO_printf(bp, \"Error loading directory %s\\n\", CApath);\\r\\ngoto end;\\r\\n}\\r\\n} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nreturn store;\\r\\nend:\\r\\nX509_STORE_free(store);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic ENGINE *try_load_engine(BIO *err, const char *engine, int debug)\\r\\n{\\r\\nENGINE *e = ENGINE_by_id(\"dynamic\");\\r\\nif (e)\\r\\n{\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"SO_PATH\", engine, 0)\\r\\n|| !ENGINE_ctrl_cmd_string(e, \"LOAD\", NULL, 0))\\r\\n{\\r\\nENGINE_free(e);\\r\\ne = NULL;\\r\\n}\\r\\n}\\r\\nreturn e;\\r\\n}\\r\\nENGINE *setup_engine(BIO *err, const char *engine, int debug)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nif (engine)\\r\\n{\\r\\nif(strcmp(engine, \"auto\") == 0)\\r\\n{\\r\\nBIO_printf(err,\"enabling auto ENGINE support\\n\");\\r\\nENGINE_register_all_complete();\\r\\nreturn NULL;\\r\\n}\\r\\nif((e = ENGINE_by_id(engine)) == NULL\\r\\n&& (e = try_load_engine(err, engine, debug)) == NULL)\\r\\n{\\r\\nBIO_printf(err,\"invalid engine \\\"%s\\\"\\n\", engine);\\r\\nERR_print_errors(err);\\r\\nreturn NULL;\\r\\n}\\r\\nif (debug)\\r\\n{\\r\\nENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM,\\r\\n0, err, 0);\\r\\n}\\r\\nENGINE_ctrl_cmd(e, \"SET_USER_INTERFACE\", 0, ui_method, 0, 1);\\r\\nif(!ENGINE_set_default(e, ENGINE_METHOD_ALL))\\r\\n{\\r\\nBIO_printf(err,\"can't use that engine\\n\");\\r\\nERR_print_errors(err);\\r\\nENGINE_free(e);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_printf(err,\"engine \\\"%s\\\" set.\\n\", ENGINE_get_id(e));\\r\\nENGINE_free(e);\\r\\n}\\r\\nreturn e;\\r\\n}\\r\\nint load_config(BIO *err, CONF *cnf)\\r\\n{\\r\\nif (!cnf)\\r\\ncnf = config;\\r\\nif (!cnf)\\r\\nreturn 1;\\r\\nOPENSSL_load_builtin_modules();\\r\\nif (CONF_modules_load(cnf, NULL, 0) <= 0)\\r\\n{\\r\\nBIO_printf(err, \"Error configuring OpenSSL\\n\");\\r\\nERR_print_errors(err);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *make_config_name()\\r\\n{\\r\\nconst char *t=X509_get_default_cert_area();\\r\\nsize_t len;\\r\\nchar *p;\\r\\nlen=strlen(t)+strlen(OPENSSL_CONF)+2;\\r\\np=OPENSSL_malloc(len);\\r\\nBUF_strlcpy(p,t,len);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(p,\"/\",len);\\r\\n#endif\\r\\nBUF_strlcat(p,OPENSSL_CONF,len);\\r\\nreturn p;\\r\\n}\\r\\nstatic unsigned long index_serial_hash(const char **a)\\r\\n{\\r\\nconst char *n;\\r\\nn=a[DB_serial];\\r\\nwhile (*n == '0') n++;\\r\\nreturn(lh_strhash(n));\\r\\n}\\r\\nstatic int index_serial_cmp(const char **a, const char **b)\\r\\n{\\r\\nconst char *aa,*bb;\\r\\nfor (aa=a[DB_serial]; *aa == '0'; aa++);\\r\\nfor (bb=b[DB_serial]; *bb == '0'; bb++);\\r\\nreturn(strcmp(aa,bb));\\r\\n}\\r\\nstatic int index_name_qual(char **a)\\r\\n{ return(a[0][0] == 'V'); }\\r\\nstatic unsigned long index_name_hash(const char **a)\\r\\n{ return(lh_strhash(a[DB_name])); }\\r\\nint index_name_cmp(const char **a, const char **b)\\r\\n{ return(strcmp(a[DB_name],\\r\\nb[DB_name])); }\\r\\nint rotate_serial(char *serialfile, char *new_suffix, char *old_suffix)\\r\\n{\\r\\nchar buf[5][BSIZE];\\r\\nint i,j;\\r\\nstruct stat sb;\\r\\ni = strlen(serialfile) + strlen(old_suffix);\\r\\nj = strlen(serialfile) + strlen(new_suffix);\\r\\nif (i > j) j = i;\\r\\nif (j + 1 >= BSIZE)\\r\\n{\\r\\nBIO_printf(bio_err,\"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\",\\r\\nserialfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\",\\r\\nserialfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.%s\",\\r\\nserialfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-%s\",\\r\\nserialfile, old_suffix);\\r\\n#endif\\r\\nif (stat(serialfile,&sb) < 0)\\r\\n{\\r\\nif (errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nserialfile, buf[1]);\\r\\n#endif\\r\\nif (rename(serialfile,buf[1]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\nserialfile, buf[1]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nbuf[0],serialfile);\\r\\n#endif\\r\\nif (rename(buf[0],serialfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\nbuf[0],serialfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[1],serialfile);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint rand_serial(BIGNUM *b, ASN1_INTEGER *ai)\\r\\n{\\r\\nBIGNUM *btmp;\\r\\nint ret = 0;\\r\\nif (b)\\r\\nbtmp = b;\\r\\nelse\\r\\nbtmp = BN_new();\\r\\nif (!btmp)\\r\\nreturn 0;\\r\\nif (!BN_pseudo_rand(btmp, SERIAL_RAND_BITS, 0, 0))\\r\\ngoto error;\\r\\nif (ai && !BN_to_ASN1_INTEGER(btmp, ai))\\r\\ngoto error;\\r\\nret = 1;\\r\\nerror:\\r\\nif (!b)\\r\\nBN_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nCA_DB *load_index(char *dbfile, DB_ATTR *db_attr)\\r\\n{\\r\\nCA_DB *retdb = NULL;\\r\\nTXT_DB *tmpdb = NULL;\\r\\nBIO *in = BIO_new(BIO_s_file());\\r\\nCONF *dbattr_conf = NULL;\\r\\nchar buf[1][BSIZE];\\r\\nlong errorline= -1;\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in,dbfile) <= 0)\\r\\n{\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\",dbfile);\\r\\ngoto err;\\r\\n}\\r\\nif ((tmpdb = TXT_DB_read(in,DB_NUMBER)) == NULL)\\r\\n{\\r\\nif (tmpdb != NULL) TXT_DB_free(tmpdb);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBIO_snprintf(buf[0], sizeof buf[0], \"%s.attr\", dbfile);\\r\\n#else\\r\\nBIO_snprintf(buf[0], sizeof buf[0], \"%s-attr\", dbfile);\\r\\n#endif\\r\\ndbattr_conf = NCONF_new(NULL);\\r\\nif (NCONF_load(dbattr_conf,buf[0],&errorline) <= 0)\\r\\n{\\r\\nif (errorline > 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"error on line %ld of db attribute file '%s'\\n\"\\r\\n,errorline,buf[0]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nNCONF_free(dbattr_conf);\\r\\ndbattr_conf = NULL;\\r\\n}\\r\\n}\\r\\nif ((retdb = OPENSSL_malloc(sizeof(CA_DB))) == NULL)\\r\\n{\\r\\nfprintf(stderr, \"Out of memory\\n\");\\r\\ngoto err;\\r\\n}\\r\\nretdb->db = tmpdb;\\r\\ntmpdb = NULL;\\r\\nif (db_attr)\\r\\nretdb->attributes = *db_attr;\\r\\nelse\\r\\n{\\r\\nretdb->attributes.unique_subject = 1;\\r\\n}\\r\\nif (dbattr_conf)\\r\\n{\\r\\nchar *p = NCONF_get_string(dbattr_conf,NULL,\"unique_subject\");\\r\\nif (p)\\r\\n{\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG[load_index]: unique_subject = \\\"%s\\\"\\n\", p);\\r\\n#endif\\r\\nretdb->attributes.unique_subject = parse_yesno(p,1);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (dbattr_conf) NCONF_free(dbattr_conf);\\r\\nif (tmpdb) TXT_DB_free(tmpdb);\\r\\nif (in) BIO_free_all(in);\\r\\nreturn retdb;\\r\\n}\\r\\nint index_index(CA_DB *db)\\r\\n{\\r\\nif (!TXT_DB_create_index(db->db, DB_serial, NULL,\\r\\nLHASH_HASH_FN(index_serial_hash),\\r\\nLHASH_COMP_FN(index_serial_cmp)))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"error creating serial number index:(%ld,%ld,%ld)\\n\",\\r\\ndb->db->error,db->db->arg1,db->db->arg2);\\r\\nreturn 0;\\r\\n}\\r\\nif (db->attributes.unique_subject\\r\\n&& !TXT_DB_create_index(db->db, DB_name, index_name_qual,\\r\\nLHASH_HASH_FN(index_name_hash),\\r\\nLHASH_COMP_FN(index_name_cmp)))\\r\\n{\\r\\nBIO_printf(bio_err,\"error creating name index:(%ld,%ld,%ld)\\n\",\\r\\ndb->db->error,db->db->arg1,db->db->arg2);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint save_index(const char *dbfile, const char *suffix, CA_DB *db)\\r\\n{\\r\\nchar buf[3][BSIZE];\\r\\nBIO *out = BIO_new(BIO_s_file());\\r\\nint j;\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nj = strlen(dbfile) + strlen(suffix);\\r\\nif (j + 6 >= BSIZE)\\r\\n{\\r\\nBIO_printf(bio_err,\"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s.attr\", dbfile);\\r\\n#else\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s-attr\", dbfile);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.attr.%s\", dbfile, suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-attr-%s\", dbfile, suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\", dbfile, suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\", dbfile, suffix);\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: writing \\\"%s\\\"\\n\", buf[0]);\\r\\n#endif\\r\\nif (BIO_write_filename(out,buf[0]) <= 0)\\r\\n{\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\", dbfile);\\r\\ngoto err;\\r\\n}\\r\\nj=TXT_DB_write(out,db->db);\\r\\nif (j <= 0) goto err;\\r\\nBIO_free(out);\\r\\nout = BIO_new(BIO_s_file());\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: writing \\\"%s\\\"\\n\", buf[1]);\\r\\n#endif\\r\\nif (BIO_write_filename(out,buf[1]) <= 0)\\r\\n{\\r\\nperror(buf[2]);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\", buf[2]);\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(out,\"unique_subject = %s\\n\",\\r\\ndb->attributes.unique_subject ? \"yes\" : \"no\");\\r\\nBIO_free(out);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint rotate_index(const char *dbfile, const char *new_suffix, const char *old_suffix)\\r\\n{\\r\\nchar buf[5][BSIZE];\\r\\nint i,j;\\r\\nstruct stat sb;\\r\\ni = strlen(dbfile) + strlen(old_suffix);\\r\\nj = strlen(dbfile) + strlen(new_suffix);\\r\\nif (i > j) j = i;\\r\\nif (j + 6 >= BSIZE)\\r\\n{\\r\\nBIO_printf(bio_err,\"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[4], sizeof buf[4], \"%s.attr\", dbfile);\\r\\n#else\\r\\nj = BIO_snprintf(buf[4], sizeof buf[4], \"%s-attr\", dbfile);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s.attr.%s\",\\r\\ndbfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s-attr-%s\",\\r\\ndbfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\",\\r\\ndbfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\",\\r\\ndbfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.%s\",\\r\\ndbfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-%s\",\\r\\ndbfile, old_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[3], sizeof buf[3], \"%s.attr.%s\",\\r\\ndbfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[3], sizeof buf[3], \"%s-attr-%s\",\\r\\ndbfile, old_suffix);\\r\\n#endif\\r\\nif (stat(dbfile,&sb) < 0)\\r\\n{\\r\\nif (errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\ndbfile, buf[1]);\\r\\n#endif\\r\\nif (rename(dbfile,buf[1]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\ndbfile, buf[1]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nbuf[0],dbfile);\\r\\n#endif\\r\\nif (rename(buf[0],dbfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\nbuf[0],dbfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[1],dbfile);\\r\\ngoto err;\\r\\n}\\r\\nif (stat(buf[4],&sb) < 0)\\r\\n{\\r\\nif (errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nbuf[4],buf[3]);\\r\\n#endif\\r\\nif (rename(buf[4],buf[3]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\nbuf[4], buf[3]);\\r\\nperror(\"reason\");\\r\\nrename(dbfile,buf[0]);\\r\\nrename(buf[1],dbfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nbuf[2],buf[4]);\\r\\n#endif\\r\\nif (rename(buf[2],buf[4]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\",\\r\\nbuf[2],buf[4]);\\r\\nperror(\"reason\");\\r\\nrename(buf[3],buf[4]);\\r\\nrename(dbfile,buf[0]);\\r\\nrename(buf[1],dbfile);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nvoid free_index(CA_DB *db)\\r\\n{\\r\\nif (db)\\r\\n{\\r\\nif (db->db) TXT_DB_free(db->db);\\r\\nOPENSSL_free(db);\\r\\n}\\r\\n}\\r\\nint parse_yesno(const char *str, int def)\\r\\n{\\r\\nint ret = def;\\r\\nif (str)\\r\\n{\\r\\nswitch (*str)\\r\\n{\\r\\ncase 'f':\\r\\ncase 'F':\\r\\ncase 'n':\\r\\ncase 'N':\\r\\ncase '0':\\r\\nret = 0;\\r\\nbreak;\\r\\ncase 't':\\r\\ncase 'T':\\r\\ncase 'y':\\r\\ncase 'Y':\\r\\ncase '1':\\r\\nret = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nret = def;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_NAME *parse_name(char *subject, long chtype, int multirdn)\\r\\n{\\r\\nsize_t buflen = strlen(subject)+1;\\r\\nchar *buf = OPENSSL_malloc(buflen);\\r\\nsize_t max_ne = buflen / 2 + 1;\\r\\nchar **ne_types = OPENSSL_malloc(max_ne * sizeof (char *));\\r\\nchar **ne_values = OPENSSL_malloc(max_ne * sizeof (char *));\\r\\nint *mval = OPENSSL_malloc (max_ne * sizeof (int));\\r\\nchar *sp = subject, *bp = buf;\\r\\nint i, ne_num = 0;\\r\\nX509_NAME *n = NULL;\\r\\nint nid;\\r\\nif (!buf || !ne_types || !ne_values)\\r\\n{\\r\\nBIO_printf(bio_err, \"malloc error\\n\");\\r\\ngoto error;\\r\\n}\\r\\nif (*subject != '/')\\r\\n{\\r\\nBIO_printf(bio_err, \"Subject does not start with '/'.\\n\");\\r\\ngoto error;\\r\\n}\\r\\nsp++;\\r\\nmval[ne_num] = 0;\\r\\nwhile (*sp)\\r\\n{\\r\\nne_types[ne_num] = bp;\\r\\nwhile (*sp)\\r\\n{\\r\\nif (*sp == '\\\\')\\r\\n{\\r\\nif (*++sp)\\r\\n*bp++ = *sp++;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"escape character at end of string\\n\");\\r\\ngoto error;\\r\\n}\\r\\n}\\r\\nelse if (*sp == '=')\\r\\n{\\r\\nsp++;\\r\\n*bp++ = '\\0';\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n*bp++ = *sp++;\\r\\n}\\r\\nif (!*sp)\\r\\n{\\r\\nBIO_printf(bio_err, \"end of string encountered while processing type of subject name element #%d\\n\", ne_num);\\r\\ngoto error;\\r\\n}\\r\\nne_values[ne_num] = bp;\\r\\nwhile (*sp)\\r\\n{\\r\\nif (*sp == '\\\\')\\r\\n{\\r\\nif (*++sp)\\r\\n*bp++ = *sp++;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"escape character at end of string\\n\");\\r\\ngoto error;\\r\\n}\\r\\n}\\r\\nelse if (*sp == '/')\\r\\n{\\r\\nsp++;\\r\\nmval[ne_num+1] = 0;\\r\\nbreak;\\r\\n}\\r\\nelse if (*sp == '+' && multirdn)\\r\\n{\\r\\nsp++;\\r\\nmval[ne_num+1] = -1;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n*bp++ = *sp++;\\r\\n}\\r\\n*bp++ = '\\0';\\r\\nne_num++;\\r\\n}\\r\\nif (!(n = X509_NAME_new()))\\r\\ngoto error;\\r\\nfor (i = 0; i < ne_num; i++)\\r\\n{\\r\\nif ((nid=OBJ_txt2nid(ne_types[i])) == NID_undef)\\r\\n{\\r\\nBIO_printf(bio_err, \"Subject Attribute %s has no known NID, skipped\\n\", ne_types[i]);\\r\\ncontinue;\\r\\n}\\r\\nif (!*ne_values[i])\\r\\n{\\r\\nBIO_printf(bio_err, \"No value provided for Subject Attribute %s, skipped\\n\", ne_types[i]);\\r\\ncontinue;\\r\\n}\\r\\nif (!X509_NAME_add_entry_by_NID(n, nid, chtype, (unsigned char*)ne_values[i], -1,-1,mval[i]))\\r\\ngoto error;\\r\\n}\\r\\nOPENSSL_free(ne_values);\\r\\nOPENSSL_free(ne_types);\\r\\nOPENSSL_free(buf);\\r\\nreturn n;\\r\\nerror:\\r\\nX509_NAME_free(n);\\r\\nif (ne_values)\\r\\nOPENSSL_free(ne_values);\\r\\nif (ne_types)\\r\\nOPENSSL_free(ne_types);\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nint WIN32_rename(const char *from, const char *to)\\r\\n{\\r\\n#ifndef OPENSSL_SYS_WINCE\\r\\nif((remove(to) != 0) && (errno != ENOENT))\\r\\nreturn -1;\\r\\n#undef rename\\r\\nreturn rename(from, to);\\r\\n#else\\r\\n{\\r\\nBOOL result = FALSE;\\r\\nWCHAR* wfrom;\\r\\nWCHAR* wto;\\r\\nint i;\\r\\nwfrom = malloc((strlen(from)+1)*2);\\r\\nwto = malloc((strlen(to)+1)*2);\\r\\nif (wfrom != NULL && wto != NULL)\\r\\n{\\r\\nfor (i=0; i<(int)strlen(from)+1; i++)\\r\\nwfrom[i] = (short)from[i];\\r\\nfor (i=0; i<(int)strlen(to)+1; i++)\\r\\nwto[i] = (short)to[i];\\r\\nresult = MoveFile(wfrom, wto);\\r\\n}\\r\\nif (wfrom != NULL)\\r\\nfree(wfrom);\\r\\nif (wto != NULL)\\r\\nfree(wto);\\r\\nreturn result;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint args_verify(char ***pargs, int *pargc,\\r\\nint *badarg, BIO *err, X509_VERIFY_PARAM **pm)\\r\\n{\\r\\nASN1_OBJECT *otmp = NULL;\\r\\nunsigned long flags = 0;\\r\\nint i;\\r\\nint purpose = 0;\\r\\nchar **oldargs = *pargs;\\r\\nchar *arg = **pargs, *argn = (*pargs)[1];\\r\\nif (!strcmp(arg, \"-policy\"))\\r\\n{\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse\\r\\n{\\r\\notmp = OBJ_txt2obj(argn, 0);\\r\\nif (!otmp)\\r\\n{\\r\\nBIO_printf(err, \"Invalid Policy \\\"%s\\\"\\n\",\\r\\nargn);\\r\\n*badarg = 1;\\r\\n}\\r\\n}\\r\\n(*pargs)++;\\r\\n}\\r\\nelse if (strcmp(arg,\"-purpose\") == 0)\\r\\n{\\r\\nX509_PURPOSE *xptmp;\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse\\r\\n{\\r\\ni = X509_PURPOSE_get_by_sname(argn);\\r\\nif(i < 0)\\r\\n{\\r\\nBIO_printf(err, \"unrecognized purpose\\n\");\\r\\n*badarg = 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nxptmp = X509_PURPOSE_get0(i);\\r\\npurpose = X509_PURPOSE_get_id(xptmp);\\r\\n}\\r\\n}\\r\\n(*pargs)++;\\r\\n}\\r\\nelse if (!strcmp(arg, \"-ignore_critical\"))\\r\\nflags |= X509_V_FLAG_IGNORE_CRITICAL;\\r\\nelse if (!strcmp(arg, \"-issuer_checks\"))\\r\\nflags |= X509_V_FLAG_CB_ISSUER_CHECK;\\r\\nelse if (!strcmp(arg, \"-crl_check\"))\\r\\nflags |= X509_V_FLAG_CRL_CHECK;\\r\\nelse if (!strcmp(arg, \"-crl_check_all\"))\\r\\nflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\\r\\nelse if (!strcmp(arg, \"-policy_check\"))\\r\\nflags |= X509_V_FLAG_POLICY_CHECK;\\r\\nelse if (!strcmp(arg, \"-explicit_policy\"))\\r\\nflags |= X509_V_FLAG_EXPLICIT_POLICY;\\r\\nelse if (!strcmp(arg, \"-x509_strict\"))\\r\\nflags |= X509_V_FLAG_X509_STRICT;\\r\\nelse if (!strcmp(arg, \"-policy_print\"))\\r\\nflags |= X509_V_FLAG_NOTIFY_POLICY;\\r\\nelse\\r\\nreturn 0;\\r\\nif (*badarg)\\r\\n{\\r\\nif (*pm)\\r\\nX509_VERIFY_PARAM_free(*pm);\\r\\n*pm = NULL;\\r\\ngoto end;\\r\\n}\\r\\nif (!*pm && !(*pm = X509_VERIFY_PARAM_new()))\\r\\n{\\r\\n*badarg = 1;\\r\\ngoto end;\\r\\n}\\r\\nif (otmp)\\r\\nX509_VERIFY_PARAM_add0_policy(*pm, otmp);\\r\\nif (flags)\\r\\nX509_VERIFY_PARAM_set_flags(*pm, flags);\\r\\nif (purpose)\\r\\nX509_VERIFY_PARAM_set_purpose(*pm, purpose);\\r\\nend:\\r\\n(*pargs)++;\\r\\nif (pargc)\\r\\n*pargc -= *pargs - oldargs;\\r\\nreturn 1;\\r\\n}\\r\\nvoid policies_print(BIO *out, X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_POLICY_TREE *tree;\\r\\nint explicit_policy;\\r\\nint free_out = 0;\\r\\nif (out == NULL)\\r\\n{\\r\\nout = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nfree_out = 1;\\r\\n}\\r\\ntree = X509_STORE_CTX_get0_policy_tree(ctx);\\r\\nexplicit_policy = X509_STORE_CTX_get_explicit_policy(ctx);\\r\\nBIO_printf(out, \"Require explicit Policy: %s\\n\",\\r\\nexplicit_policy ? \"True\" : \"False\");\\r\\nnodes_print(out, \"Authority\", X509_policy_tree_get0_policies(tree));\\r\\nnodes_print(out, \"User\", X509_policy_tree_get0_user_policies(tree));\\r\\nif (free_out)\\r\\nBIO_free(out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_md2_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return MD2_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return MD2_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return MD2_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_md2(void)\\r\\n{\\r\\nreturn(&md2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsagen_c", "target": 0, "func": "int cb(int p, int n)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nprintf(\"%c\",c);\\r\\nfflush(stdout);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nint i;\\r\\nBIGNUM *n;\\r\\nBN_CTX *ctx;\\r\\nunsigned char seed_buf[20];\\r\\nDSA *dsa;\\r\\nint counter,h;\\r\\nBIO *bio_err=NULL;\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nmemcpy(seed_buf,seed,20);\\r\\ndsa=DSA_generate_parameters(1024,seed,20,&counter,&h,cb,bio_err);\\r\\nif (dsa == NULL)\\r\\nDSA_print(bio_err,dsa,0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_ibmca_err_c", "target": 0, "func": "static void ERR_load_IBMCA_strings(void)\\r\\n{\\r\\nif (IBMCA_lib_error_code == 0)\\r\\nIBMCA_lib_error_code=ERR_get_next_error_library();\\r\\nif (IBMCA_error_init)\\r\\n{\\r\\nIBMCA_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(IBMCA_lib_error_code,IBMCA_str_functs);\\r\\nERR_load_strings(IBMCA_lib_error_code,IBMCA_str_reasons);\\r\\n#endif\\r\\n#ifdef IBMCA_LIB_NAME\\r\\nIBMCA_lib_name->error = ERR_PACK(IBMCA_lib_error_code,0,0);\\r\\nERR_load_strings(0,IBMCA_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_IBMCA_strings(void)\\r\\n{\\r\\nif (IBMCA_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(IBMCA_lib_error_code,IBMCA_str_functs);\\r\\nERR_unload_strings(IBMCA_lib_error_code,IBMCA_str_reasons);\\r\\n#endif\\r\\n#ifdef IBMCA_LIB_NAME\\r\\nERR_unload_strings(0,IBMCA_lib_name);\\r\\n#endif\\r\\nIBMCA_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_IBMCA_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (IBMCA_lib_error_code == 0)\\r\\nIBMCA_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(IBMCA_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_cmp_c", "target": 0, "func": "int X509_issuer_and_serial_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nint i;\\r\\nX509_CINF *ai,*bi;\\r\\nai=a->cert_info;\\r\\nbi=b->cert_info;\\r\\ni=M_ASN1_INTEGER_cmp(ai->serialNumber,bi->serialNumber);\\r\\nif (i) return(i);\\r\\nreturn(X509_NAME_cmp(ai->issuer,bi->issuer));\\r\\n}\\r\\nunsigned long X509_issuer_and_serial_hash(X509 *a)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char md[16];\\r\\nchar *f;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nf=X509_NAME_oneline(a->cert_info->issuer,NULL,0);\\r\\nret=strlen(f);\\r\\nEVP_DigestInit_ex(&ctx, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&ctx,(unsigned char *)f,ret);\\r\\nOPENSSL_free(f);\\r\\nEVP_DigestUpdate(&ctx,(unsigned char *)a->cert_info->serialNumber->data,\\r\\n(unsigned long)a->cert_info->serialNumber->length);\\r\\nEVP_DigestFinal_ex(&ctx,&(md[0]),NULL);\\r\\nret=( ((unsigned long)md[0] )|((unsigned long)md[1]<<8L)|\\r\\n((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)\\r\\n)&0xffffffffL;\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_issuer_name_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->cert_info->issuer,b->cert_info->issuer));\\r\\n}\\r\\nint X509_subject_name_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->cert_info->subject,b->cert_info->subject));\\r\\n}\\r\\nint X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->crl->issuer,b->crl->issuer));\\r\\n}\\r\\nX509_NAME *X509_get_issuer_name(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->issuer);\\r\\n}\\r\\nunsigned long X509_issuer_name_hash(X509 *x)\\r\\n{\\r\\nreturn(X509_NAME_hash(x->cert_info->issuer));\\r\\n}\\r\\nX509_NAME *X509_get_subject_name(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->subject);\\r\\n}\\r\\nASN1_INTEGER *X509_get_serialNumber(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->serialNumber);\\r\\n}\\r\\nunsigned long X509_subject_name_hash(X509 *x)\\r\\n{\\r\\nreturn(X509_NAME_hash(x->cert_info->subject));\\r\\n}\\r\\nint X509_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nX509_check_purpose((X509 *)a, -1, 0);\\r\\nX509_check_purpose((X509 *)b, -1, 0);\\r\\nreturn memcmp(a->sha1_hash, b->sha1_hash, SHA_DIGEST_LENGTH);\\r\\n}\\r\\nstatic int nocase_cmp(const ASN1_STRING *a, const ASN1_STRING *b)\\r\\n{\\r\\nint i;\\r\\nif (a->length != b->length)\\r\\nreturn (a->length - b->length);\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nint ca, cb;\\r\\nca = tolower(a->data[i]);\\r\\ncb = tolower(b->data[i]);\\r\\nif (ca != cb)\\r\\nreturn(ca-cb);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int nocase_spacenorm_cmp(const ASN1_STRING *a, const ASN1_STRING *b)\\r\\n{\\r\\nunsigned char *pa = NULL, *pb = NULL;\\r\\nint la, lb;\\r\\nla = a->length;\\r\\nlb = b->length;\\r\\npa = a->data;\\r\\npb = b->data;\\r\\nwhile (la > 0 && isspace(*pa))\\r\\n{\\r\\nla--;\\r\\npa++;\\r\\n}\\r\\nwhile (lb > 0 && isspace(*pb))\\r\\n{\\r\\nlb--;\\r\\npb++;\\r\\n}\\r\\nwhile (la > 0 && isspace(pa[la-1]))\\r\\nla--;\\r\\nwhile (lb > 0 && isspace(pb[lb-1]))\\r\\nlb--;\\r\\nwhile (la > 0 && lb > 0)\\r\\n{\\r\\nint ca, cb;\\r\\nca = tolower(*pa);\\r\\ncb = tolower(*pb);\\r\\nif (ca != cb)\\r\\nreturn (ca - cb);\\r\\npa++; pb++;\\r\\nla--; lb--;\\r\\nif (la <= 0 || lb <= 0)\\r\\nbreak;\\r\\nif (isspace(*pa) && isspace(*pb))\\r\\n{\\r\\nwhile (la > 0 && isspace(*pa))\\r\\n{\\r\\nla--;\\r\\npa++;\\r\\n}\\r\\nwhile (lb > 0 && isspace(*pb))\\r\\n{\\r\\nlb--;\\r\\npb++;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (la > 0 || lb > 0)\\r\\nreturn la - lb;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_string_memcmp(ASN1_STRING *a, ASN1_STRING *b)\\r\\n{\\r\\nint j;\\r\\nj = a->length - b->length;\\r\\nif (j)\\r\\nreturn j;\\r\\nreturn memcmp(a->data, b->data, a->length);\\r\\n}\\r\\nint X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\\r\\n{\\r\\nint i,j;\\r\\nX509_NAME_ENTRY *na,*nb;\\r\\nunsigned long nabit, nbbit;\\r\\nj = sk_X509_NAME_ENTRY_num(a->entries)\\r\\n- sk_X509_NAME_ENTRY_num(b->entries);\\r\\nif (j)\\r\\nreturn j;\\r\\nfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\\r\\n{\\r\\nna=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nnb=sk_X509_NAME_ENTRY_value(b->entries,i);\\r\\nj=na->value->type-nb->value->type;\\r\\nif (j)\\r\\n{\\r\\nnabit = ASN1_tag2bit(na->value->type);\\r\\nnbbit = ASN1_tag2bit(nb->value->type);\\r\\nif (!(nabit & STR_TYPE_CMP) ||\\r\\n!(nbbit & STR_TYPE_CMP))\\r\\nreturn j;\\r\\nj = asn1_string_memcmp(na->value, nb->value);\\r\\n}\\r\\nelse if (na->value->type == V_ASN1_PRINTABLESTRING)\\r\\nj=nocase_spacenorm_cmp(na->value, nb->value);\\r\\nelse if (na->value->type == V_ASN1_IA5STRING\\r\\n&& OBJ_obj2nid(na->object) == NID_pkcs9_emailAddress)\\r\\nj=nocase_cmp(na->value, nb->value);\\r\\nelse\\r\\nj = asn1_string_memcmp(na->value, nb->value);\\r\\nif (j) return(j);\\r\\nj=na->set-nb->set;\\r\\nif (j) return(j);\\r\\n}\\r\\nfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\\r\\n{\\r\\nna=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nnb=sk_X509_NAME_ENTRY_value(b->entries,i);\\r\\nj=OBJ_cmp(na->object,nb->object);\\r\\nif (j) return(j);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nunsigned long X509_NAME_hash(X509_NAME *x)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nunsigned char md[16];\\r\\ni2d_X509_NAME(x,NULL);\\r\\nEVP_Digest(x->bytes->data, x->bytes->length, md, NULL, EVP_md5(), NULL);\\r\\nret=( ((unsigned long)md[0] )|((unsigned long)md[1]<<8L)|\\r\\n((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)\\r\\n)&0xffffffffL;\\r\\nreturn(ret);\\r\\n}\\r\\nEVP_PKEY *X509_get_pubkey(X509 *x)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn(NULL);\\r\\nreturn(X509_PUBKEY_get(x->cert_info->key));\\r\\n}\\r\\nASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x)\\r\\n{\\r\\nif(!x) return NULL;\\r\\nreturn x->cert_info->key->public_key;\\r\\n}\\r\\nint X509_check_private_key(X509 *x, EVP_PKEY *k)\\r\\n{\\r\\nEVP_PKEY *xk=NULL;\\r\\nint ok=0;\\r\\nxk=X509_get_pubkey(x);\\r\\nswitch (EVP_PKEY_cmp(xk, k))\\r\\n{\\r\\ncase 1:\\r\\nok=1;\\r\\nbreak;\\r\\ncase 0:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_KEY_VALUES_MISMATCH);\\r\\nbreak;\\r\\ncase -1:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_KEY_TYPE_MISMATCH);\\r\\nbreak;\\r\\ncase -2:\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (k->type == EVP_PKEY_EC)\\r\\n{\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (k->type == EVP_PKEY_DH)\\r\\n{\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_CANT_CHECK_DH_KEY);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_UNKNOWN_KEY_TYPE);\\r\\n}\\r\\nEVP_PKEY_free(xk);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_dec_c", "target": 0, "func": "unsigned long ASN1_tag2bit(int tag)\\r\\n{\\r\\nif ((tag < 0) || (tag > 30)) return 0;\\r\\nreturn tag2bit[tag];\\r\\n}\\r\\nASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long len, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_TLC c;\\r\\nASN1_VALUE *ptmpval = NULL;\\r\\nif (!pval)\\r\\npval = &ptmpval;\\r\\nasn1_tlc_clear(&c);\\r\\nif (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0)\\r\\nreturn *pval;\\r\\nreturn NULL;\\r\\n}\\r\\nint ASN1_template_d2i(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long len, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nASN1_TLC c;\\r\\nasn1_tlc_clear(&c);\\r\\nreturn asn1_template_ex_d2i(pval, in, len, tt, 0, &c);\\r\\n}\\r\\nint ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\\r\\nconst ASN1_ITEM *it,\\r\\nint tag, int aclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt, *errtt = NULL;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nconst unsigned char *p, *q;\\r\\nunsigned char *wp=NULL;\\r\\nunsigned char imphack = 0, oclass;\\r\\nchar seq_eoc, seq_nolen, cst, isopt;\\r\\nlong tmplen;\\r\\nint i;\\r\\nint otag;\\r\\nint ret = 0;\\r\\nASN1_VALUE *pchval, **pchptr, *ptmpval;\\r\\nif (!pval)\\r\\nreturn 0;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse asn1_cb = 0;\\r\\nswitch(it->itype)\\r\\n{\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\n{\\r\\nif ((tag != -1) || opt)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\\r\\ngoto err;\\r\\n}\\r\\nreturn asn1_template_ex_d2i(pval, in, len,\\r\\nit->templates, opt, ctx);\\r\\n}\\r\\nreturn asn1_d2i_ex_primitive(pval, in, len, it,\\r\\ntag, aclass, opt, ctx);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\np = *in;\\r\\nret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\\r\\n&p, len, -1, 0, 1, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (oclass != V_ASN1_UNIVERSAL)\\r\\n{\\r\\nif (opt) return -1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_MSTRING_NOT_UNIVERSAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ASN1_tag2bit(otag) & it->utype))\\r\\n{\\r\\nif (opt)\\r\\nreturn -1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_MSTRING_WRONG_TAG);\\r\\ngoto err;\\r\\n}\\r\\nreturn asn1_d2i_ex_primitive(pval, in, len,\\r\\nit, otag, 0, 0, ctx);\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nreturn ef->asn1_ex_d2i(pval, in, len,\\r\\nit, tag, aclass, opt, ctx);\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (opt)\\r\\n{\\r\\nint exptag;\\r\\np = *in;\\r\\nif (tag == -1)\\r\\nexptag = it->utype;\\r\\nelse exptag = tag;\\r\\nret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\\r\\n&p, len, exptag, aclass, 1, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (ret == -1)\\r\\nreturn -1;\\r\\n}\\r\\nif (tag != -1)\\r\\n{\\r\\nwp = *(unsigned char **)in;\\r\\nimphack = *wp;\\r\\n*wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\\r\\n| it->utype);\\r\\n}\\r\\nptmpval = cf->asn1_d2i(pval, in, len);\\r\\nif (tag != -1)\\r\\n*wp = imphack;\\r\\nif (ptmpval)\\r\\nreturn 1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))\\r\\ngoto auxerr;\\r\\nif (!*pval && !ASN1_item_ex_new(pval, it))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\npchval = NULL;\\r\\np = *in;\\r\\nfor (i = 0, tt=it->templates; i < it->tcount; i++, tt++)\\r\\n{\\r\\npchptr = asn1_get_field_ptr(pval, tt);\\r\\nret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\\r\\nif (ret == -1)\\r\\ncontinue;\\r\\nif (ret > 0)\\r\\nbreak;\\r\\nerrtt = tt;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (i == it->tcount)\\r\\n{\\r\\nif (opt)\\r\\n{\\r\\nASN1_item_ex_free(pval, it);\\r\\nreturn -1;\\r\\n}\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_NO_MATCHING_CHOICE_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nasn1_set_choice_selector(pval, i, it);\\r\\n*in = p;\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))\\r\\ngoto auxerr;\\r\\nreturn 1;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\np = *in;\\r\\ntmplen = len;\\r\\nif (tag == -1)\\r\\n{\\r\\ntag = V_ASN1_SEQUENCE;\\r\\naclass = V_ASN1_UNIVERSAL;\\r\\n}\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\\r\\n&p, len, tag, aclass, opt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\nif (aux && (aux->flags & ASN1_AFLG_BROKEN))\\r\\n{\\r\\nlen = tmplen - (p - *in);\\r\\nseq_nolen = 1;\\r\\n}\\r\\nelse seq_nolen = seq_eoc;\\r\\nif (!cst)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_SEQUENCE_NOT_CONSTRUCTED);\\r\\ngoto err;\\r\\n}\\r\\nif (!*pval && !ASN1_item_ex_new(pval, it))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it))\\r\\ngoto auxerr;\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; i++, tt++)\\r\\n{\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\ngoto err;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nif (!len)\\r\\nbreak;\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len))\\r\\n{\\r\\nif (!seq_eoc)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_UNEXPECTED_EOC);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nseq_eoc = 0;\\r\\nq = p;\\r\\nbreak;\\r\\n}\\r\\nif (i == (it->tcount - 1))\\r\\nisopt = 0;\\r\\nelse isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\\r\\nret = asn1_template_ex_d2i(pseqval, &p, len,\\r\\nseqtt, isopt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nerrtt = seqtt;\\r\\ngoto err;\\r\\n}\\r\\nelse if (ret == -1)\\r\\n{\\r\\nASN1_template_free(pseqval, seqtt);\\r\\ncontinue;\\r\\n}\\r\\nlen -= p - q;\\r\\n}\\r\\nif (seq_eoc && !asn1_check_eoc(&p, len))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\nif (!seq_nolen && len)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_SEQUENCE_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nfor (; i < it->tcount; tt++, i++)\\r\\n{\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\ngoto err;\\r\\nif (seqtt->flags & ASN1_TFLG_OPTIONAL)\\r\\n{\\r\\nASN1_VALUE **pseqval;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nASN1_template_free(pseqval, seqtt);\\r\\n}\\r\\nelse\\r\\n{\\r\\nerrtt = seqtt;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_FIELD_MISSING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!asn1_enc_save(pval, *in, p - *in, it))\\r\\ngoto auxerr;\\r\\n*in = p;\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it))\\r\\ngoto auxerr;\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nauxerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\\r\\nerr:\\r\\nASN1_item_ex_free(pval, it);\\r\\nif (errtt)\\r\\nERR_add_error_data(4, \"Field=\", errtt->field_name,\\r\\n\", Type=\", it->sname);\\r\\nelse\\r\\nERR_add_error_data(2, \"Type=\", it->sname);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_template_ex_d2i(ASN1_VALUE **val,\\r\\nconst unsigned char **in, long inlen,\\r\\nconst ASN1_TEMPLATE *tt, char opt,\\r\\nASN1_TLC *ctx)\\r\\n{\\r\\nint flags, aclass;\\r\\nint ret;\\r\\nlong len;\\r\\nconst unsigned char *p, *q;\\r\\nchar exp_eoc;\\r\\nif (!val)\\r\\nreturn 0;\\r\\nflags = tt->flags;\\r\\naclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\np = *in;\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\n{\\r\\nchar cst;\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,\\r\\n&p, inlen, tt->tag, aclass, opt, ctx);\\r\\nq = p;\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\nif (!cst)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\\r\\nreturn 0;\\r\\n}\\r\\nret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nlen -= p - q;\\r\\nif (exp_eoc)\\r\\n{\\r\\nif (!asn1_check_eoc(&p, len))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nASN1_R_EXPLICIT_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\nreturn asn1_template_noexp_d2i(val, in, inlen,\\r\\ntt, opt, ctx);\\r\\n*in = p;\\r\\nreturn 1;\\r\\nerr:\\r\\nASN1_template_free(val, tt);\\r\\n*val = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_template_noexp_d2i(ASN1_VALUE **val,\\r\\nconst unsigned char **in, long len,\\r\\nconst ASN1_TEMPLATE *tt, char opt,\\r\\nASN1_TLC *ctx)\\r\\n{\\r\\nint flags, aclass;\\r\\nint ret;\\r\\nconst unsigned char *p, *q;\\r\\nif (!val)\\r\\nreturn 0;\\r\\nflags = tt->flags;\\r\\naclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\np = *in;\\r\\nq = p;\\r\\nif (flags & ASN1_TFLG_SK_MASK)\\r\\n{\\r\\nint sktag, skaclass;\\r\\nchar sk_eoc;\\r\\nif (flags & ASN1_TFLG_IMPTAG)\\r\\n{\\r\\nsktag = tt->tag;\\r\\nskaclass = aclass;\\r\\n}\\r\\nelse\\r\\n{\\r\\nskaclass = V_ASN1_UNIVERSAL;\\r\\nif (flags & ASN1_TFLG_SET_OF)\\r\\nsktag = V_ASN1_SET;\\r\\nelse\\r\\nsktag = V_ASN1_SEQUENCE;\\r\\n}\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL,\\r\\n&p, len, sktag, skaclass, opt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\nif (!*val)\\r\\n*val = (ASN1_VALUE *)sk_new_null();\\r\\nelse\\r\\n{\\r\\nSTACK *sktmp = (STACK *)*val;\\r\\nASN1_VALUE *vtmp;\\r\\nwhile(sk_num(sktmp) > 0)\\r\\n{\\r\\nvtmp = (ASN1_VALUE *)sk_pop(sktmp);\\r\\nASN1_item_ex_free(&vtmp,\\r\\nASN1_ITEM_ptr(tt->item));\\r\\n}\\r\\n}\\r\\nif (!*val)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwhile(len > 0)\\r\\n{\\r\\nASN1_VALUE *skfield;\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len))\\r\\n{\\r\\nif (!sk_eoc)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nASN1_R_UNEXPECTED_EOC);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nsk_eoc = 0;\\r\\nbreak;\\r\\n}\\r\\nskfield = NULL;\\r\\nif (!ASN1_item_ex_d2i(&skfield, &p, len,\\r\\nASN1_ITEM_ptr(tt->item),\\r\\n-1, 0, 0, ctx))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nif (!sk_push((STACK *)*val, (char *)skfield))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (sk_eoc)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if (flags & ASN1_TFLG_IMPTAG)\\r\\n{\\r\\nret = ASN1_item_ex_d2i(val, &p, len,\\r\\nASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),\\r\\n-1, 0, opt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\nerr:\\r\\nASN1_template_free(val, tt);\\r\\n*val = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long inlen,\\r\\nconst ASN1_ITEM *it,\\r\\nint tag, int aclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nint ret = 0, utype;\\r\\nlong plen;\\r\\nchar cst, inf, free_cont = 0;\\r\\nconst unsigned char *p;\\r\\nBUF_MEM buf;\\r\\nconst unsigned char *cont = NULL;\\r\\nlong len;\\r\\nif (!pval)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);\\r\\nreturn 0;\\r\\n}\\r\\nif (it->itype == ASN1_ITYPE_MSTRING)\\r\\n{\\r\\nutype = tag;\\r\\ntag = -1;\\r\\n}\\r\\nelse\\r\\nutype = it->utype;\\r\\nif (utype == V_ASN1_ANY)\\r\\n{\\r\\nunsigned char oclass;\\r\\nif (tag >= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nASN1_R_ILLEGAL_TAGGED_ANY);\\r\\nreturn 0;\\r\\n}\\r\\nif (opt)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nASN1_R_ILLEGAL_OPTIONAL_ANY);\\r\\nreturn 0;\\r\\n}\\r\\np = *in;\\r\\nret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL,\\r\\n&p, inlen, -1, 0, 0, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (oclass != V_ASN1_UNIVERSAL)\\r\\nutype = V_ASN1_OTHER;\\r\\n}\\r\\nif (tag == -1)\\r\\n{\\r\\ntag = utype;\\r\\naclass = V_ASN1_UNIVERSAL;\\r\\n}\\r\\np = *in;\\r\\nret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst,\\r\\n&p, inlen, tag, aclass, opt, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nelse if (ret == -1)\\r\\nreturn -1;\\r\\nif ((utype == V_ASN1_SEQUENCE)\\r\\n|| (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER))\\r\\n{\\r\\nif (utype == V_ASN1_OTHER)\\r\\n{\\r\\nasn1_tlc_clear(ctx);\\r\\n}\\r\\nelse if (!cst)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nASN1_R_TYPE_NOT_CONSTRUCTED);\\r\\nreturn 0;\\r\\n}\\r\\ncont = *in;\\r\\nif (inf)\\r\\n{\\r\\nif (!asn1_find_end(&p, plen, inf))\\r\\ngoto err;\\r\\nlen = p - cont;\\r\\n}\\r\\nelse\\r\\n{\\r\\nlen = p - cont + plen;\\r\\np += plen;\\r\\nbuf.data = NULL;\\r\\n}\\r\\n}\\r\\nelse if (cst)\\r\\n{\\r\\nbuf.length = 0;\\r\\nbuf.max = 0;\\r\\nbuf.data = NULL;\\r\\nif (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL))\\r\\ngoto err;\\r\\nlen = buf.length;\\r\\nif (!BUF_MEM_grow_clean(&buf, len + 1))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nbuf.data[len] = 0;\\r\\ncont = (const unsigned char *)buf.data;\\r\\nfree_cont = 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncont = p;\\r\\nlen = plen;\\r\\np += plen;\\r\\n}\\r\\nif (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it))\\r\\ngoto err;\\r\\n*in = p;\\r\\nret = 1;\\r\\nerr:\\r\\nif (free_cont && buf.data) OPENSSL_free(buf.data);\\r\\nreturn ret;\\r\\n}\\r\\nint asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_VALUE **opval = NULL;\\r\\nASN1_STRING *stmp;\\r\\nASN1_TYPE *typ = NULL;\\r\\nint ret = 0;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\nASN1_INTEGER **tint;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_c2i)\\r\\nreturn pf->prim_c2i(pval, cont, len, utype, free_cont, it);\\r\\nif (it->utype == V_ASN1_ANY)\\r\\n{\\r\\nif (!*pval)\\r\\n{\\r\\ntyp = ASN1_TYPE_new();\\r\\n*pval = (ASN1_VALUE *)typ;\\r\\n}\\r\\nelse\\r\\ntyp = (ASN1_TYPE *)*pval;\\r\\nif (utype != typ->type)\\r\\nASN1_TYPE_set(typ, utype, NULL);\\r\\nopval = pval;\\r\\npval = (ASN1_VALUE **)&typ->value.ptr;\\r\\n}\\r\\nswitch(utype)\\r\\n{\\r\\ncase V_ASN1_OBJECT:\\r\\nif (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_NULL:\\r\\nif (len)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_EX_C2I,\\r\\nASN1_R_NULL_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)1;\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (len != 1)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_EX_C2I,\\r\\nASN1_R_BOOLEAN_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nASN1_BOOLEAN *tbool;\\r\\ntbool = (ASN1_BOOLEAN *)pval;\\r\\n*tbool = *cont;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nif (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\ntint = (ASN1_INTEGER **)pval;\\r\\nif (!c2i_ASN1_INTEGER(tint, &cont, len))\\r\\ngoto err;\\r\\n(*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_OTHER:\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ndefault:\\r\\nif (!*pval)\\r\\n{\\r\\nstmp = ASN1_STRING_type_new(utype);\\r\\nif (!stmp)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_EX_C2I,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)stmp;\\r\\n}\\r\\nelse\\r\\n{\\r\\nstmp = (ASN1_STRING *)*pval;\\r\\nstmp->type = utype;\\r\\n}\\r\\nif (*free_cont)\\r\\n{\\r\\nif (stmp->data)\\r\\nOPENSSL_free(stmp->data);\\r\\nstmp->data = (unsigned char *)cont;\\r\\nstmp->length = len;\\r\\n*free_cont = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!ASN1_STRING_set(stmp, cont, len))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_EX_C2I,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nASN1_STRING_free(stmp);\\r\\n*pval = NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (typ && (utype == V_ASN1_NULL))\\r\\ntyp->value.ptr = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nASN1_TYPE_free(typ);\\r\\nif (opval)\\r\\n*opval = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_find_end(const unsigned char **in, long len, char inf)\\r\\n{\\r\\nint expected_eoc;\\r\\nlong plen;\\r\\nconst unsigned char *p = *in, *q;\\r\\nif (inf == 0)\\r\\n{\\r\\n*in += len;\\r\\nreturn 1;\\r\\n}\\r\\nexpected_eoc = 1;\\r\\nwhile (len > 0)\\r\\n{\\r\\nif(asn1_check_eoc(&p, len))\\r\\n{\\r\\nexpected_eoc--;\\r\\nif (expected_eoc == 0)\\r\\nbreak;\\r\\nlen -= 2;\\r\\ncontinue;\\r\\n}\\r\\nq = p;\\r\\nif(!asn1_check_tlen(&plen, NULL, NULL, &inf, NULL, &p, len,\\r\\n-1, 0, 0, NULL))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (inf)\\r\\nexpected_eoc++;\\r\\nelse\\r\\np += plen;\\r\\nlen -= p - q;\\r\\n}\\r\\nif (expected_eoc)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_FIND_END, ASN1_R_MISSING_EOC);\\r\\nreturn 0;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,\\r\\nchar inf, int tag, int aclass)\\r\\n{\\r\\nconst unsigned char *p, *q;\\r\\nlong plen;\\r\\nchar cst, ininf;\\r\\np = *in;\\r\\ninf &= 1;\\r\\nif (!buf && !inf)\\r\\n{\\r\\n*in += len;\\r\\nreturn 1;\\r\\n}\\r\\nwhile(len > 0)\\r\\n{\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len))\\r\\n{\\r\\nif (!inf)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_COLLECT,\\r\\nASN1_R_UNEXPECTED_EOC);\\r\\nreturn 0;\\r\\n}\\r\\ninf = 0;\\r\\nbreak;\\r\\n}\\r\\nif (!asn1_check_tlen(&plen, NULL, NULL, &ininf, &cst, &p,\\r\\nlen, tag, aclass, 0, NULL))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (cst)\\r\\n{\\r\\n#ifdef OPENSSL_ALLOW_NESTED_ASN1_STRINGS\\r\\nif (!asn1_collect(buf, &p, plen, ininf, tag, aclass))\\r\\nreturn 0;\\r\\n#else\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_NESTED_ASN1_STRING);\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nelse if (!collect_data(buf, &p, plen))\\r\\nreturn 0;\\r\\nlen -= p - q;\\r\\n}\\r\\nif (inf)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_MISSING_EOC);\\r\\nreturn 0;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)\\r\\n{\\r\\nint len;\\r\\nif (buf)\\r\\n{\\r\\nlen = buf->length;\\r\\nif (!BUF_MEM_grow_clean(buf, len + plen))\\r\\n{\\r\\nASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(buf->data + len, *p, plen);\\r\\n}\\r\\n*p += plen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_check_eoc(const unsigned char **in, long len)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nif (len < 2) return 0;\\r\\np = *in;\\r\\nif (!p[0] && !p[1])\\r\\n{\\r\\n*in += 2;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,\\r\\nchar *inf, char *cst,\\r\\nconst unsigned char **in, long len,\\r\\nint exptag, int expclass, char opt,\\r\\nASN1_TLC *ctx)\\r\\n{\\r\\nint i;\\r\\nint ptag, pclass;\\r\\nlong plen;\\r\\nconst unsigned char *p, *q;\\r\\np = *in;\\r\\nq = p;\\r\\nif (ctx && ctx->valid)\\r\\n{\\r\\ni = ctx->ret;\\r\\nplen = ctx->plen;\\r\\npclass = ctx->pclass;\\r\\nptag = ctx->ptag;\\r\\np += ctx->hdrlen;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni = ASN1_get_object(&p, &plen, &ptag, &pclass, len);\\r\\nif (ctx)\\r\\n{\\r\\nctx->ret = i;\\r\\nctx->plen = plen;\\r\\nctx->pclass = pclass;\\r\\nctx->ptag = ptag;\\r\\nctx->hdrlen = p - q;\\r\\nctx->valid = 1;\\r\\nif (!(i & 0x81) && ((plen + ctx->hdrlen) > len))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN,\\r\\nASN1_R_TOO_LONG);\\r\\nasn1_tlc_clear(ctx);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (i & 0x80)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_BAD_OBJECT_HEADER);\\r\\nasn1_tlc_clear(ctx);\\r\\nreturn 0;\\r\\n}\\r\\nif (exptag >= 0)\\r\\n{\\r\\nif ((exptag != ptag) || (expclass != pclass))\\r\\n{\\r\\nif (opt) return -1;\\r\\nasn1_tlc_clear(ctx);\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_WRONG_TAG);\\r\\nreturn 0;\\r\\n}\\r\\nasn1_tlc_clear(ctx);\\r\\n}\\r\\nif (i & 1)\\r\\nplen = len - (p - q);\\r\\nif (inf)\\r\\n*inf = i & 1;\\r\\nif (cst)\\r\\n*cst = i & V_ASN1_CONSTRUCTED;\\r\\nif (olen)\\r\\n*olen = plen;\\r\\nif (oclass)\\r\\n*oclass = pclass;\\r\\nif (otag)\\r\\n*otag = ptag;\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkcs7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nPKCS7 *p7=NULL;\\r\\nint i,badops=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile,*outfile,*prog;\\r\\nint print_certs=0,text=0,noout=0;\\r\\nint ret=1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-print_certs\") == 0)\\r\\nprint_certs=1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -print_certs print any certs or crl in the input\\n\");\\r\\nBIO_printf(bio_err,\" -text print full details of certificates\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't output encoded data\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\nif (in == NULL)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\np7=d2i_PKCS7_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\np7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for pkcs7 object\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (p7 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load PKCS7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (print_certs)\\r\\n{\\r\\nSTACK_OF(X509) *certs=NULL;\\r\\nSTACK_OF(X509_CRL) *crls=NULL;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\ncerts=p7->d.sign->cert;\\r\\ncrls=p7->d.sign->crl;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncerts=p7->d.signed_and_enveloped->cert;\\r\\ncrls=p7->d.signed_and_enveloped->crl;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (certs != NULL)\\r\\n{\\r\\nX509 *x;\\r\\nfor (i=0; i<sk_X509_num(certs); i++)\\r\\n{\\r\\nx=sk_X509_value(certs,i);\\r\\nif(text) X509_print(out, x);\\r\\nelse dump_cert_text(out, x);\\r\\nif(!noout) PEM_write_bio_X509(out,x);\\r\\nBIO_puts(out,\"\\n\");\\r\\n}\\r\\n}\\r\\nif (crls != NULL)\\r\\n{\\r\\nX509_CRL *crl;\\r\\nfor (i=0; i<sk_X509_CRL_num(crls); i++)\\r\\n{\\r\\ncrl=sk_X509_CRL_value(crls,i);\\r\\nX509_CRL_print(out, crl);\\r\\nif(!noout)PEM_write_bio_X509_CRL(out,crl);\\r\\nBIO_puts(out,\"\\n\");\\r\\n}\\r\\n}\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif(!noout) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_PKCS7_bio(out,p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_PKCS7(out,p7);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (p7 != NULL) PKCS7_free(p7);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509spki_c", "target": 0, "func": "int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->spkac == NULL)) return(0);\\r\\nreturn(X509_PUBKEY_set(&(x->spkac->pubkey),pkey));\\r\\n}\\r\\nEVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x)\\r\\n{\\r\\nif ((x == NULL) || (x->spkac == NULL))\\r\\nreturn(NULL);\\r\\nreturn(X509_PUBKEY_get(x->spkac->pubkey));\\r\\n}\\r\\nNETSCAPE_SPKI * NETSCAPE_SPKI_b64_decode(const char *str, int len)\\r\\n{\\r\\nunsigned char *spki_der;\\r\\nconst unsigned char *p;\\r\\nint spki_len;\\r\\nNETSCAPE_SPKI *spki;\\r\\nif(len <= 0) len = strlen(str);\\r\\nif (!(spki_der = OPENSSL_malloc(len + 1))) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_DECODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nspki_len = EVP_DecodeBlock(spki_der, (const unsigned char *)str, len);\\r\\nif(spki_len < 0) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_DECODE,\\r\\nX509_R_BASE64_DECODE_ERROR);\\r\\nOPENSSL_free(spki_der);\\r\\nreturn NULL;\\r\\n}\\r\\np = spki_der;\\r\\nspki = d2i_NETSCAPE_SPKI(NULL, &p, spki_len);\\r\\nOPENSSL_free(spki_der);\\r\\nreturn spki;\\r\\n}\\r\\nchar * NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *spki)\\r\\n{\\r\\nunsigned char *der_spki, *p;\\r\\nchar *b64_str;\\r\\nint der_len;\\r\\nder_len = i2d_NETSCAPE_SPKI(spki, NULL);\\r\\nder_spki = OPENSSL_malloc(der_len);\\r\\nb64_str = OPENSSL_malloc(der_len * 2);\\r\\nif(!der_spki || !b64_str) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np = der_spki;\\r\\ni2d_NETSCAPE_SPKI(spki, &p);\\r\\nEVP_EncodeBlock((unsigned char *)b64_str, der_spki, der_len);\\r\\nOPENSSL_free(der_spki);\\r\\nreturn b64_str;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_lib_c", "target": 0, "func": "static long ssl3_default_timeout(void)\\r\\n{\\r\\nreturn(60*60*2);\\r\\n}\\r\\nSSL_METHOD *sslv3_base_method(void)\\r\\n{\\r\\nreturn(&SSLv3_data);\\r\\n}\\r\\nint ssl3_num_ciphers(void)\\r\\n{\\r\\nreturn(SSL3_NUM_CIPHERS);\\r\\n}\\r\\nSSL_CIPHER *ssl3_get_cipher(unsigned int u)\\r\\n{\\r\\nif (u < SSL3_NUM_CIPHERS)\\r\\nreturn(&(ssl3_ciphers[SSL3_NUM_CIPHERS-1-u]));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl3_pending(const SSL *s)\\r\\n{\\r\\nif (s->rstate == SSL_ST_READ_BODY)\\r\\nreturn 0;\\r\\nreturn (s->s3->rrec.type == SSL3_RT_APPLICATION_DATA) ? s->s3->rrec.length : 0;\\r\\n}\\r\\nint ssl3_new(SSL *s)\\r\\n{\\r\\nSSL3_STATE *s3;\\r\\nif ((s3=OPENSSL_malloc(sizeof *s3)) == NULL) goto err;\\r\\nmemset(s3,0,sizeof *s3);\\r\\nEVP_MD_CTX_init(&s3->finish_dgst1);\\r\\nEVP_MD_CTX_init(&s3->finish_dgst2);\\r\\npq_64bit_init(&(s3->rrec.seq_num));\\r\\npq_64bit_init(&(s3->wrec.seq_num));\\r\\ns->s3=s3;\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl3_free(SSL *s)\\r\\n{\\r\\nif(s == NULL)\\r\\nreturn;\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->rbuf.buf != NULL)\\r\\nOPENSSL_free(s->s3->rbuf.buf);\\r\\nif (s->s3->wbuf.buf != NULL)\\r\\nOPENSSL_free(s->s3->wbuf.buf);\\r\\nif (s->s3->rrec.comp != NULL)\\r\\nOPENSSL_free(s->s3->rrec.comp);\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->s3->tmp.dh != NULL)\\r\\nDH_free(s->s3->tmp.dh);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (s->s3->tmp.ecdh != NULL)\\r\\nEC_KEY_free(s->s3->tmp.ecdh);\\r\\n#endif\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\nEVP_MD_CTX_cleanup(&s->s3->finish_dgst1);\\r\\nEVP_MD_CTX_cleanup(&s->s3->finish_dgst2);\\r\\npq_64bit_free(&(s->s3->rrec.seq_num));\\r\\npq_64bit_free(&(s->s3->wrec.seq_num));\\r\\nOPENSSL_cleanse(s->s3,sizeof *s->s3);\\r\\nOPENSSL_free(s->s3);\\r\\ns->s3=NULL;\\r\\n}\\r\\nvoid ssl3_clear(SSL *s)\\r\\n{\\r\\nunsigned char *rp,*wp;\\r\\nsize_t rlen, wlen;\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\nif (s->s3->rrec.comp != NULL)\\r\\n{\\r\\nOPENSSL_free(s->s3->rrec.comp);\\r\\ns->s3->rrec.comp=NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->s3->tmp.dh != NULL)\\r\\nDH_free(s->s3->tmp.dh);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (s->s3->tmp.ecdh != NULL)\\r\\nEC_KEY_free(s->s3->tmp.ecdh);\\r\\n#endif\\r\\nrp = s->s3->rbuf.buf;\\r\\nwp = s->s3->wbuf.buf;\\r\\nrlen = s->s3->rbuf.len;\\r\\nwlen = s->s3->wbuf.len;\\r\\nEVP_MD_CTX_cleanup(&s->s3->finish_dgst1);\\r\\nEVP_MD_CTX_cleanup(&s->s3->finish_dgst2);\\r\\nmemset(s->s3,0,sizeof *s->s3);\\r\\ns->s3->rbuf.buf = rp;\\r\\ns->s3->wbuf.buf = wp;\\r\\ns->s3->rbuf.len = rlen;\\r\\ns->s3->wbuf.len = wlen;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->packet_length=0;\\r\\ns->s3->renegotiate=0;\\r\\ns->s3->total_renegotiations=0;\\r\\ns->s3->num_renegotiations=0;\\r\\ns->s3->in_read_app_data=0;\\r\\ns->version=SSL3_VERSION;\\r\\n}\\r\\nlong ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\\r\\n{\\r\\nint ret=0;\\r\\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\\r\\nif (\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncmd == SSL_CTRL_SET_TMP_RSA ||\\r\\ncmd == SSL_CTRL_SET_TMP_RSA_CB ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncmd == SSL_CTRL_SET_TMP_DH ||\\r\\ncmd == SSL_CTRL_SET_TMP_DH_CB ||\\r\\n#endif\\r\\n0)\\r\\n{\\r\\nif (!ssl_cert_inst(&s->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_SESSION_REUSED:\\r\\nret=s->hit;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\\r\\nret=s->s3->num_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\\r\\nret=s->s3->num_renegotiations;\\r\\ns->s3->num_renegotiations=0;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\\r\\nret=s->s3->total_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_FLAGS:\\r\\nret=(int)(s->s3->flags);\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\\r\\n((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8))))\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa = (RSA *)parg;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(ret);\\r\\n}\\r\\nif ((rsa = RSAPrivateKey_dup(rsa)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\nif (s->cert->rsa_tmp != NULL)\\r\\nRSA_free(s->cert->rsa_tmp);\\r\\ns->cert->rsa_tmp = rsa;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *dh = (DH *)parg;\\r\\nif (dh == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(ret);\\r\\n}\\r\\nif ((dh = DHparams_dup(dh)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\nif (!(s->options & SSL_OP_SINGLE_DH_USE))\\r\\n{\\r\\nif (!DH_generate_key(dh))\\r\\n{\\r\\nDH_free(dh);\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\n}\\r\\nif (s->cert->dh_tmp != NULL)\\r\\nDH_free(s->cert->dh_tmp);\\r\\ns->cert->dh_tmp = dh;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH:\\r\\n{\\r\\nEC_KEY *ecdh = NULL;\\r\\nif (parg == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(ret);\\r\\n}\\r\\nif (!EC_KEY_up_ref((EC_KEY *)parg))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\necdh = (EC_KEY *)parg;\\r\\nif (!(s->options & SSL_OP_SINGLE_ECDH_USE))\\r\\n{\\r\\nif (!EC_KEY_generate_key(ecdh))\\r\\n{\\r\\nEC_KEY_free(ecdh);\\r\\nSSLerr(SSL_F_SSL3_CTRL,ERR_R_ECDH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\n}\\r\\nif (s->cert->ecdh_tmp != NULL)\\r\\nEC_KEY_free(s->cert->ecdh_tmp);\\r\\ns->cert->ecdh_tmp = ecdh;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong ssl3_callback_ctrl(SSL *s, int cmd, void (*fp)(void))\\r\\n{\\r\\nint ret=0;\\r\\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\\r\\nif (\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncmd == SSL_CTRL_SET_TMP_RSA_CB ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncmd == SSL_CTRL_SET_TMP_DH_CB ||\\r\\n#endif\\r\\n0)\\r\\n{\\r\\nif (!ssl_cert_inst(&s->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CALLBACK_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nswitch (cmd)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\ns->cert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\ns->cert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\ns->cert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\\r\\n{\\r\\nCERT *cert;\\r\\ncert=ctx->cert;\\r\\nswitch (cmd)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ( (cert->rsa_tmp == NULL) &&\\r\\n((cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8)))\\r\\n)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa;\\r\\nint i;\\r\\nrsa=(RSA *)parg;\\r\\ni=1;\\r\\nif (rsa == NULL)\\r\\ni=0;\\r\\nelse\\r\\n{\\r\\nif ((rsa=RSAPrivateKey_dup(rsa)) == NULL)\\r\\ni=0;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_RSA_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (cert->rsa_tmp != NULL)\\r\\nRSA_free(cert->rsa_tmp);\\r\\ncert->rsa_tmp=rsa;\\r\\nreturn(1);\\r\\n}\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *new=NULL,*dh;\\r\\ndh=(DH *)parg;\\r\\nif ((new=DHparams_dup(dh)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(ctx->options & SSL_OP_SINGLE_DH_USE))\\r\\n{\\r\\nif (!DH_generate_key(new))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\\r\\nDH_free(new);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (cert->dh_tmp != NULL)\\r\\nDH_free(cert->dh_tmp);\\r\\ncert->dh_tmp=new;\\r\\nreturn 1;\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH:\\r\\n{\\r\\nEC_KEY *ecdh = NULL;\\r\\nif (parg == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_ECDH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!EC_KEY_up_ref((EC_KEY *)parg))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_ECDH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\necdh = (EC_KEY *)parg;\\r\\nif (!(ctx->options & SSL_OP_SINGLE_ECDH_USE))\\r\\n{\\r\\nif (!EC_KEY_generate_key(ecdh))\\r\\n{\\r\\nEC_KEY_free(ecdh);\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_ECDH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (cert->ecdh_tmp != NULL)\\r\\n{\\r\\nEC_KEY_free(cert->ecdh_tmp);\\r\\n}\\r\\ncert->ecdh_tmp = ecdh;\\r\\nreturn 1;\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ncase SSL_CTRL_EXTRA_CHAIN_CERT:\\r\\nif (ctx->extra_certs == NULL)\\r\\n{\\r\\nif ((ctx->extra_certs=sk_X509_new_null()) == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nsk_X509_push(ctx->extra_certs,(X509 *)parg);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nlong ssl3_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))\\r\\n{\\r\\nCERT *cert;\\r\\ncert=ctx->cert;\\r\\nswitch (cmd)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\ncert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\ncert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\ncert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_CIPHER *sorted[SSL3_NUM_CIPHERS];\\r\\nSSL_CIPHER c,*cp= &c,**cpp;\\r\\nunsigned long id;\\r\\nunsigned int i;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nif (init)\\r\\n{\\r\\nfor (i=0; i<SSL3_NUM_CIPHERS; i++)\\r\\nsorted[i]= &(ssl3_ciphers[i]);\\r\\nqsort(sorted,\\r\\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\n}\\r\\nid=0x03000000L|((unsigned long)p[0]<<8L)|(unsigned long)p[1];\\r\\nc.id=id;\\r\\ncpp=(SSL_CIPHER **)OBJ_bsearch((char *)&cp,\\r\\n(char *)sorted,\\r\\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\nif ((cpp == NULL) || !(*cpp)->valid)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(*cpp);\\r\\n}\\r\\nint ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\nif ((l & 0xff000000) != 0x03000000) return(0);\\r\\np[0]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[1]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(2);\\r\\n}\\r\\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\\r\\n{\\r\\nint ret=0;\\r\\nunsigned long alg;\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (alg & (SSL_kDHr|SSL_kEDH))\\r\\n{\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_FIXED_DH;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_FIXED_DH;\\r\\n# endif\\r\\n}\\r\\nif ((s->version == SSL3_VERSION) &&\\r\\n(alg & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\\r\\n{\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_SIGN;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_SIGN;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif ((alg & SSL_kECDH) && (s->version >= TLS1_VERSION))\\r\\n{\\r\\np[ret++]=TLS_CT_RSA_FIXED_ECDH;\\r\\np[ret++]=TLS_CT_ECDSA_FIXED_ECDH;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (s->version >= TLS1_VERSION)\\r\\n{\\r\\np[ret++]=TLS_CT_ECDSA_SIGN;\\r\\n}\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_shutdown(SSL *s)\\r\\n{\\r\\nif ((s->quiet_shutdown) || (s->state == SSL_ST_BEFORE))\\r\\n{\\r\\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\nreturn(1);\\r\\n}\\r\\nif (!(s->shutdown & SSL_SENT_SHUTDOWN))\\r\\n{\\r\\ns->shutdown|=SSL_SENT_SHUTDOWN;\\r\\n#if 1\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_CLOSE_NOTIFY);\\r\\n#endif\\r\\n}\\r\\nelse if (s->s3->alert_dispatch)\\r\\n{\\r\\n#if 1\\r\\ns->method->ssl_dispatch_alert(s);\\r\\n#endif\\r\\n}\\r\\nelse if (!(s->shutdown & SSL_RECEIVED_SHUTDOWN))\\r\\n{\\r\\ns->method->ssl_read_bytes(s,0,NULL,0,0);\\r\\n}\\r\\nif ((s->shutdown == (SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN)) &&\\r\\n!s->s3->alert_dispatch)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_write(SSL *s, const void *buf, int len)\\r\\n{\\r\\nint ret,n;\\r\\n#if 0\\r\\nif (s->shutdown & SSL_SEND_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\n#endif\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\\r\\nif ((s->s3->flags & SSL3_FLAGS_POP_BUFFER) && (s->wbio == s->bbio))\\r\\n{\\r\\nif (s->s3->delay_buf_pop_ret == 0)\\r\\n{\\r\\nret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\\r\\nbuf,len);\\r\\nif (ret <= 0) return(ret);\\r\\ns->s3->delay_buf_pop_ret=ret;\\r\\n}\\r\\ns->rwstate=SSL_WRITING;\\r\\nn=BIO_flush(s->wbio);\\r\\nif (n <= 0) return(n);\\r\\ns->rwstate=SSL_NOTHING;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\\r\\nret=s->s3->delay_buf_pop_ret;\\r\\ns->s3->delay_buf_pop_ret=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=s->method->ssl_write_bytes(s,SSL3_RT_APPLICATION_DATA,\\r\\nbuf,len);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\\r\\n{\\r\\nint ret;\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\\r\\ns->s3->in_read_app_data=1;\\r\\nret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\\r\\nif ((ret == -1) && (s->s3->in_read_app_data == 2))\\r\\n{\\r\\ns->in_handshake++;\\r\\nret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\\r\\ns->in_handshake--;\\r\\n}\\r\\nelse\\r\\ns->s3->in_read_app_data=0;\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl3_read_internal(s, buf, len, 0);\\r\\n}\\r\\nint ssl3_peek(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl3_read_internal(s, buf, len, 1);\\r\\n}\\r\\nint ssl3_renegotiate(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == NULL)\\r\\nreturn(1);\\r\\nif (s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)\\r\\nreturn(0);\\r\\ns->s3->renegotiate=1;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_renegotiate_check(SSL *s)\\r\\n{\\r\\nint ret=0;\\r\\nif (s->s3->renegotiate)\\r\\n{\\r\\nif ( (s->s3->rbuf.left == 0) &&\\r\\n(s->s3->wbuf.left == 0) &&\\r\\n!SSL_in_init(s))\\r\\n{\\r\\ns->state=SSL_ST_RENEGOTIATE;\\r\\ns->s3->renegotiate=0;\\r\\ns->s3->num_renegotiations++;\\r\\ns->s3->total_renegotiations++;\\r\\nret=1;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_str_lib_c", "target": 0, "func": "STORE *STORE_new_method(const STORE_METHOD *method)\\r\\n{\\r\\nSTORE *ret;\\r\\nif (method == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_METHOD,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nret=(STORE *)OPENSSL_malloc(sizeof(STORE));\\r\\nif (ret == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth=method;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_STORE, ret, &ret->ex_data);\\r\\nif (ret->meth->init && !ret->meth->init(ret))\\r\\n{\\r\\nSTORE_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nSTORE *STORE_new_engine(ENGINE *engine)\\r\\n{\\r\\nSTORE *ret = NULL;\\r\\nENGINE *e = engine;\\r\\nconst STORE_METHOD *meth = 0;\\r\\n#ifdef OPENSSL_NO_ENGINE\\r\\ne = NULL;\\r\\n#else\\r\\nif (engine)\\r\\n{\\r\\nif (!ENGINE_init(engine))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_ENGINE, ERR_R_ENGINE_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\ne = engine;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_ENGINE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif(e)\\r\\n{\\r\\nmeth = ENGINE_get_STORE(e);\\r\\nif(!meth)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_ENGINE,\\r\\nERR_R_ENGINE_LIB);\\r\\nENGINE_finish(e);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret = STORE_new_method(meth);\\r\\nif (ret == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_NEW_ENGINE,ERR_R_STORE_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = e;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid STORE_free(STORE *store)\\r\\n{\\r\\nif (store == NULL)\\r\\nreturn;\\r\\nif (store->meth->clean)\\r\\nstore->meth->clean(store);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_STORE, store, &store->ex_data);\\r\\nOPENSSL_free(store);\\r\\n}\\r\\nint STORE_ctrl(STORE *store, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nif (store == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (store->meth->ctrl)\\r\\nreturn store->meth->ctrl(store, cmd, i, p, f);\\r\\nSTOREerr(STORE_F_STORE_CTRL,STORE_R_NO_CONTROL_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_STORE, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint STORE_set_ex_data(STORE *r, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\\r\\n}\\r\\nvoid *STORE_get_ex_data(STORE *r, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\\r\\n}\\r\\nconst STORE_METHOD *STORE_get_method(STORE *store)\\r\\n{\\r\\nreturn store->meth;\\r\\n}\\r\\nconst STORE_METHOD *STORE_set_method(STORE *store, const STORE_METHOD *meth)\\r\\n{\\r\\nstore->meth=meth;\\r\\nreturn store->meth;\\r\\n}\\r\\nX509 *STORE_get_certificate(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nX509 *x;\\r\\ncheck_store(s,STORE_F_STORE_GET_CERTIFICATE,\\r\\nget_object,STORE_R_NO_GET_OBJECT_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.x509.certificate)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_CERTIFICATE,\\r\\nSTORE_R_FAILED_GETTING_CERTIFICATE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.x509.certificate->references,1,CRYPTO_LOCK_X509);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509\",data);\\r\\n#endif\\r\\nx = object->data.x509.certificate;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn x;\\r\\n}\\r\\nint STORE_store_certificate(STORE *s, X509 *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_CERTIFICATE,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_CERTIFICATE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&data->references,1,CRYPTO_LOCK_X509);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509\",data);\\r\\n#endif\\r\\nobject->data.x509.certificate = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,\\r\\nobject, attributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_CERTIFICATE,\\r\\nSTORE_R_FAILED_STORING_CERTIFICATE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_modify_certificate(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_CERTIFICATE,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_CERTIFICATE,\\r\\nSTORE_R_FAILED_MODIFYING_CERTIFICATE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_revoke_certificate(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_REVOKE_CERTIFICATE,\\r\\nrevoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);\\r\\nif (!s->meth->revoke_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,\\r\\nattributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_REVOKE_CERTIFICATE,\\r\\nSTORE_R_FAILED_REVOKING_CERTIFICATE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_delete_certificate(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_CERTIFICATE,\\r\\ndelete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_X509_CERTIFICATE,\\r\\nattributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_CERTIFICATE,\\r\\nSTORE_R_FAILED_DELETING_CERTIFICATE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid *STORE_list_certificate_start(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nvoid *handle;\\r\\ncheck_store(s,STORE_F_STORE_LIST_CERTIFICATE_START,\\r\\nlist_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);\\r\\nhandle = s->meth->list_object_start(s,\\r\\nSTORE_OBJECT_TYPE_X509_CERTIFICATE, attributes, parameters);\\r\\nif (!handle)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CERTIFICATE_START,\\r\\nSTORE_R_FAILED_LISTING_CERTIFICATES);\\r\\nreturn 0;\\r\\n}\\r\\nreturn handle;\\r\\n}\\r\\nX509 *STORE_list_certificate_next(STORE *s, void *handle)\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nX509 *x;\\r\\ncheck_store(s,STORE_F_STORE_LIST_CERTIFICATE_NEXT,\\r\\nlist_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);\\r\\nobject = s->meth->list_object_next(s, handle);\\r\\nif (!object || !object->data.x509.certificate)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CERTIFICATE_NEXT,\\r\\nSTORE_R_FAILED_LISTING_CERTIFICATES);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.x509.certificate->references,1,CRYPTO_LOCK_X509);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509\",data);\\r\\n#endif\\r\\nx = object->data.x509.certificate;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn x;\\r\\n}\\r\\nint STORE_list_certificate_end(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_CERTIFICATE_END,\\r\\nlist_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);\\r\\nif (!s->meth->list_object_end(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CERTIFICATE_END,\\r\\nSTORE_R_FAILED_LISTING_CERTIFICATES);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_list_certificate_endp(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_CERTIFICATE_ENDP,\\r\\nlist_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);\\r\\nif (!s->meth->list_object_endp(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CERTIFICATE_ENDP,\\r\\nSTORE_R_FAILED_LISTING_CERTIFICATES);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nEVP_PKEY *STORE_generate_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nEVP_PKEY *pkey;\\r\\ncheck_store(s,STORE_F_STORE_GENERATE_KEY,\\r\\ngenerate_object,STORE_R_NO_GENERATE_OBJECT_FUNCTION);\\r\\nobject = s->meth->generate_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GENERATE_KEY,\\r\\nSTORE_R_FAILED_GENERATING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\npkey = object->data.key;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn pkey;\\r\\n}\\r\\nEVP_PKEY *STORE_get_private_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nEVP_PKEY *pkey;\\r\\ncheck_store(s,STORE_F_STORE_GET_PRIVATE_KEY,\\r\\nget_object,STORE_R_NO_GET_OBJECT_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.key || !object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_PRIVATE_KEY,\\r\\nSTORE_R_FAILED_GETTING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\npkey = object->data.key;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn pkey;\\r\\n}\\r\\nint STORE_store_private_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_STORE_PRIVATE_KEY,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobject->data.key = EVP_PKEY_new();\\r\\nif (!object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&data->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\nobject->data.key = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY, object,\\r\\nattributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PRIVATE_KEY,\\r\\nSTORE_R_FAILED_STORING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i;\\r\\n}\\r\\nint STORE_modify_private_key(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_PRIVATE_KEY,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_PRIVATE_KEY,\\r\\nSTORE_R_FAILED_MODIFYING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_revoke_private_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_REVOKE_PRIVATE_KEY,\\r\\nrevoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);\\r\\ni = s->meth->revoke_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nattributes, parameters);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_REVOKE_PRIVATE_KEY,\\r\\nSTORE_R_FAILED_REVOKING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i;\\r\\n}\\r\\nint STORE_delete_private_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_PRIVATE_KEY,\\r\\ndelete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nattributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_PRIVATE_KEY,\\r\\nSTORE_R_FAILED_DELETING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid *STORE_list_private_key_start(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nvoid *handle;\\r\\ncheck_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_START,\\r\\nlist_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);\\r\\nhandle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_PRIVATE_KEY,\\r\\nattributes, parameters);\\r\\nif (!handle)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_START,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn handle;\\r\\n}\\r\\nEVP_PKEY *STORE_list_private_key_next(STORE *s, void *handle)\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nEVP_PKEY *pkey;\\r\\ncheck_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_NEXT,\\r\\nlist_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);\\r\\nobject = s->meth->list_object_next(s, handle);\\r\\nif (!object || !object->data.key || !object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_NEXT,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\npkey = object->data.key;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn pkey;\\r\\n}\\r\\nint STORE_list_private_key_end(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_END,\\r\\nlist_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);\\r\\nif (!s->meth->list_object_end(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_END,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_list_private_key_endp(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_PRIVATE_KEY_ENDP,\\r\\nlist_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);\\r\\nif (!s->meth->list_object_endp(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PRIVATE_KEY_ENDP,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nEVP_PKEY *STORE_get_public_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nEVP_PKEY *pkey;\\r\\ncheck_store(s,STORE_F_STORE_GET_PUBLIC_KEY,\\r\\nget_object,STORE_R_NO_GET_OBJECT_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.key || !object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_PUBLIC_KEY,\\r\\nSTORE_R_FAILED_GETTING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\npkey = object->data.key;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn pkey;\\r\\n}\\r\\nint STORE_store_public_key(STORE *s, EVP_PKEY *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_STORE_PUBLIC_KEY,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobject->data.key = EVP_PKEY_new();\\r\\nif (!object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&data->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\nobject->data.key = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY, object,\\r\\nattributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_PUBLIC_KEY,\\r\\nSTORE_R_FAILED_STORING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i;\\r\\n}\\r\\nint STORE_modify_public_key(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_PUBLIC_KEY,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_PUBLIC_KEY,\\r\\nSTORE_R_FAILED_MODIFYING_PUBLIC_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_revoke_public_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_REVOKE_PUBLIC_KEY,\\r\\nrevoke_object,STORE_R_NO_REVOKE_OBJECT_FUNCTION);\\r\\ni = s->meth->revoke_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,\\r\\nattributes, parameters);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_REVOKE_PUBLIC_KEY,\\r\\nSTORE_R_FAILED_REVOKING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i;\\r\\n}\\r\\nint STORE_delete_public_key(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_PUBLIC_KEY,\\r\\ndelete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_PUBLIC_KEY,\\r\\nattributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_PUBLIC_KEY,\\r\\nSTORE_R_FAILED_DELETING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid *STORE_list_public_key_start(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nvoid *handle;\\r\\ncheck_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_START,\\r\\nlist_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);\\r\\nhandle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_PUBLIC_KEY,\\r\\nattributes, parameters);\\r\\nif (!handle)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_START,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn handle;\\r\\n}\\r\\nEVP_PKEY *STORE_list_public_key_next(STORE *s, void *handle)\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nEVP_PKEY *pkey;\\r\\ncheck_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_NEXT,\\r\\nlist_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);\\r\\nobject = s->meth->list_object_next(s, handle);\\r\\nif (!object || !object->data.key || !object->data.key)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_NEXT,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.key->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",data);\\r\\n#endif\\r\\npkey = object->data.key;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn pkey;\\r\\n}\\r\\nint STORE_list_public_key_end(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_END,\\r\\nlist_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);\\r\\nif (!s->meth->list_object_end(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_END,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_list_public_key_endp(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_PUBLIC_KEY_ENDP,\\r\\nlist_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);\\r\\nif (!s->meth->list_object_endp(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_PUBLIC_KEY_ENDP,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nX509_CRL *STORE_generate_crl(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nX509_CRL *crl;\\r\\ncheck_store(s,STORE_F_STORE_GENERATE_CRL,\\r\\ngenerate_object,STORE_R_NO_GENERATE_CRL_FUNCTION);\\r\\nobject = s->meth->generate_object(s, STORE_OBJECT_TYPE_X509_CRL,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.crl)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GENERATE_CRL,\\r\\nSTORE_R_FAILED_GENERATING_CRL);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_CRL\",data);\\r\\n#endif\\r\\ncrl = object->data.crl;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn crl;\\r\\n}\\r\\nX509_CRL *STORE_get_crl(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nX509_CRL *crl;\\r\\ncheck_store(s,STORE_F_STORE_GET_CRL,\\r\\nget_object,STORE_R_NO_GET_OBJECT_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_X509_CRL,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.crl)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_CRL,\\r\\nSTORE_R_FAILED_GETTING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_CRL\",data);\\r\\n#endif\\r\\ncrl = object->data.crl;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn crl;\\r\\n}\\r\\nint STORE_store_crl(STORE *s, X509_CRL *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_STORE_CRL,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_CRL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&data->references,1,CRYPTO_LOCK_X509_CRL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_CRL\",data);\\r\\n#endif\\r\\nobject->data.crl = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_X509_CRL, object,\\r\\nattributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_CRL,\\r\\nSTORE_R_FAILED_STORING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i;\\r\\n}\\r\\nint STORE_modify_crl(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_CRL,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_X509_CRL,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_CRL,\\r\\nSTORE_R_FAILED_MODIFYING_CRL);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_delete_crl(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_CRL,\\r\\ndelete_object,STORE_R_NO_DELETE_OBJECT_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_X509_CRL,\\r\\nattributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_CRL,\\r\\nSTORE_R_FAILED_DELETING_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid *STORE_list_crl_start(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nvoid *handle;\\r\\ncheck_store(s,STORE_F_STORE_LIST_CRL_START,\\r\\nlist_object_start,STORE_R_NO_LIST_OBJECT_START_FUNCTION);\\r\\nhandle = s->meth->list_object_start(s, STORE_OBJECT_TYPE_X509_CRL,\\r\\nattributes, parameters);\\r\\nif (!handle)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CRL_START,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn handle;\\r\\n}\\r\\nX509_CRL *STORE_list_crl_next(STORE *s, void *handle)\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nX509_CRL *crl;\\r\\ncheck_store(s,STORE_F_STORE_LIST_CRL_NEXT,\\r\\nlist_object_next,STORE_R_NO_LIST_OBJECT_NEXT_FUNCTION);\\r\\nobject = s->meth->list_object_next(s, handle);\\r\\nif (!object || !object->data.crl)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CRL_NEXT,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&object->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_CRL\",data);\\r\\n#endif\\r\\ncrl = object->data.crl;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn crl;\\r\\n}\\r\\nint STORE_list_crl_end(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_CRL_END,\\r\\nlist_object_end,STORE_R_NO_LIST_OBJECT_END_FUNCTION);\\r\\nif (!s->meth->list_object_end(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CRL_END,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_list_crl_endp(STORE *s, void *handle)\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_LIST_CRL_ENDP,\\r\\nlist_object_endp,STORE_R_NO_LIST_OBJECT_ENDP_FUNCTION);\\r\\nif (!s->meth->list_object_endp(s, handle))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_LIST_CRL_ENDP,\\r\\nSTORE_R_FAILED_LISTING_KEYS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_store_number(STORE *s, BIGNUM *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_STORE_NUMBER,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_NUMBER_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_NUMBER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobject->data.number = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_NUMBER, object,\\r\\nattributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_NUMBER,\\r\\nSTORE_R_FAILED_STORING_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_modify_number(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_NUMBER,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_NUMBER,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_NUMBER,\\r\\nSTORE_R_FAILED_MODIFYING_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nBIGNUM *STORE_get_number(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nBIGNUM *n;\\r\\ncheck_store(s,STORE_F_STORE_GET_NUMBER,\\r\\nget_object,STORE_R_NO_GET_OBJECT_NUMBER_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_NUMBER, attributes,\\r\\nparameters);\\r\\nif (!object || !object->data.number)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_NUMBER,\\r\\nSTORE_R_FAILED_GETTING_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nn = object->data.number;\\r\\nobject->data.number = NULL;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn n;\\r\\n}\\r\\nint STORE_delete_number(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_NUMBER,\\r\\ndelete_object,STORE_R_NO_DELETE_NUMBER_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_NUMBER, attributes,\\r\\nparameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_NUMBER,\\r\\nSTORE_R_FAILED_DELETING_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_store_arbitrary(STORE *s, BUF_MEM *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nint i;\\r\\ncheck_store(s,STORE_F_STORE_STORE_ARBITRARY,\\r\\nstore_object,STORE_R_NO_STORE_OBJECT_ARBITRARY_FUNCTION);\\r\\nobject = STORE_OBJECT_new();\\r\\nif (!object)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_ARBITRARY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobject->data.arbitrary = data;\\r\\ni = s->meth->store_object(s, STORE_OBJECT_TYPE_ARBITRARY, object,\\r\\nattributes, parameters);\\r\\nSTORE_OBJECT_free(object);\\r\\nif (!i)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_STORE_ARBITRARY,\\r\\nSTORE_R_FAILED_STORING_ARBITRARY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_modify_arbitrary(STORE *s, OPENSSL_ITEM search_attributes[],\\r\\nOPENSSL_ITEM add_attributes[], OPENSSL_ITEM modify_attributes[],\\r\\nOPENSSL_ITEM delete_attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_MODIFY_ARBITRARY,\\r\\nmodify_object,STORE_R_NO_MODIFY_OBJECT_FUNCTION);\\r\\nif (!s->meth->modify_object(s, STORE_OBJECT_TYPE_ARBITRARY,\\r\\nsearch_attributes, add_attributes, modify_attributes,\\r\\ndelete_attributes, parameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_MODIFY_ARBITRARY,\\r\\nSTORE_R_FAILED_MODIFYING_ARBITRARY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nBUF_MEM *STORE_get_arbitrary(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTORE_OBJECT *object;\\r\\nBUF_MEM *b;\\r\\ncheck_store(s,STORE_F_STORE_GET_ARBITRARY,\\r\\nget_object,STORE_R_NO_GET_OBJECT_ARBITRARY_FUNCTION);\\r\\nobject = s->meth->get_object(s, STORE_OBJECT_TYPE_ARBITRARY,\\r\\nattributes, parameters);\\r\\nif (!object || !object->data.arbitrary)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_GET_ARBITRARY,\\r\\nSTORE_R_FAILED_GETTING_ARBITRARY);\\r\\nreturn 0;\\r\\n}\\r\\nb = object->data.arbitrary;\\r\\nobject->data.arbitrary = NULL;\\r\\nSTORE_OBJECT_free(object);\\r\\nreturn b;\\r\\n}\\r\\nint STORE_delete_arbitrary(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\ncheck_store(s,STORE_F_STORE_DELETE_ARBITRARY,\\r\\ndelete_object,STORE_R_NO_DELETE_ARBITRARY_FUNCTION);\\r\\nif (!s->meth->delete_object(s, STORE_OBJECT_TYPE_ARBITRARY, attributes,\\r\\nparameters))\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_DELETE_ARBITRARY,\\r\\nSTORE_R_FAILED_DELETING_ARBITRARY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nSTORE_OBJECT *STORE_OBJECT_new(void)\\r\\n{\\r\\nSTORE_OBJECT *object = OPENSSL_malloc(sizeof(STORE_OBJECT));\\r\\nif (object) memset(object, 0, sizeof(STORE_OBJECT));\\r\\nreturn object;\\r\\n}\\r\\nvoid STORE_OBJECT_free(STORE_OBJECT *data)\\r\\n{\\r\\nif (!data) return;\\r\\nswitch (data->type)\\r\\n{\\r\\ncase STORE_OBJECT_TYPE_X509_CERTIFICATE:\\r\\nX509_free(data->data.x509.certificate);\\r\\nbreak;\\r\\ncase STORE_OBJECT_TYPE_X509_CRL:\\r\\nX509_CRL_free(data->data.crl);\\r\\nbreak;\\r\\ncase STORE_OBJECT_TYPE_PRIVATE_KEY:\\r\\ncase STORE_OBJECT_TYPE_PUBLIC_KEY:\\r\\nEVP_PKEY_free(data->data.key);\\r\\nbreak;\\r\\ncase STORE_OBJECT_TYPE_NUMBER:\\r\\nBN_free(data->data.number);\\r\\nbreak;\\r\\ncase STORE_OBJECT_TYPE_ARBITRARY:\\r\\nBUF_MEM_free(data->data.arbitrary);\\r\\nbreak;\\r\\n}\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nSTORE_ATTR_INFO *STORE_ATTR_INFO_new(void)\\r\\n{\\r\\nreturn (STORE_ATTR_INFO *)OPENSSL_malloc(sizeof(STORE_ATTR_INFO));\\r\\n}\\r\\nstatic void STORE_ATTR_INFO_attr_free(STORE_ATTR_INFO *attrs,\\r\\nSTORE_ATTR_TYPES code)\\r\\n{\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nswitch(code)\\r\\n{\\r\\ncase STORE_ATTR_FRIENDLYNAME:\\r\\ncase STORE_ATTR_EMAIL:\\r\\ncase STORE_ATTR_FILENAME:\\r\\nSTORE_ATTR_INFO_modify_cstr(attrs, code, NULL, 0);\\r\\nbreak;\\r\\ncase STORE_ATTR_KEYID:\\r\\ncase STORE_ATTR_ISSUERKEYID:\\r\\ncase STORE_ATTR_SUBJECTKEYID:\\r\\ncase STORE_ATTR_ISSUERSERIALHASH:\\r\\ncase STORE_ATTR_CERTHASH:\\r\\nSTORE_ATTR_INFO_modify_sha1str(attrs, code, NULL, 0);\\r\\nbreak;\\r\\ncase STORE_ATTR_ISSUER:\\r\\ncase STORE_ATTR_SUBJECT:\\r\\nSTORE_ATTR_INFO_modify_dn(attrs, code, NULL);\\r\\nbreak;\\r\\ncase STORE_ATTR_SERIAL:\\r\\nSTORE_ATTR_INFO_modify_number(attrs, code, NULL);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nint STORE_ATTR_INFO_free(STORE_ATTR_INFO *attrs)\\r\\n{\\r\\nif (attrs)\\r\\n{\\r\\nSTORE_ATTR_TYPES i;\\r\\nfor(i = 0; i++ < STORE_ATTR_TYPE_NUM;)\\r\\nSTORE_ATTR_INFO_attr_free(attrs, i);\\r\\nOPENSSL_free(attrs);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *STORE_ATTR_INFO_get0_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_CSTR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\nreturn attrs->values[code].cstring;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_CSTR,\\r\\nSTORE_R_NO_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nunsigned char *STORE_ATTR_INFO_get0_sha1str(STORE_ATTR_INFO *attrs,\\r\\nSTORE_ATTR_TYPES code)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_SHA1STR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\nreturn attrs->values[code].sha1string;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_SHA1STR,\\r\\nSTORE_R_NO_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_NAME *STORE_ATTR_INFO_get0_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_DN,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\nreturn attrs->values[code].dn;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_DN,\\r\\nSTORE_R_NO_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nBIGNUM *STORE_ATTR_INFO_get0_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_NUMBER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\nreturn attrs->values[code].number;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_GET0_NUMBER,\\r\\nSTORE_R_NO_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nint STORE_ATTR_INFO_set_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nchar *cstr, size_t cstr_size)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nif ((attrs->values[code].cstring = BUF_strndup(cstr, cstr_size)))\\r\\nreturn 1;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_CSTR, STORE_R_ALREADY_HAS_A_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_ATTR_INFO_set_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nunsigned char *sha1str, size_t sha1str_size)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nif ((attrs->values[code].sha1string =\\r\\n(unsigned char *)BUF_memdup(sha1str,\\r\\nsha1str_size)))\\r\\nreturn 1;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_SHA1STR, STORE_R_ALREADY_HAS_A_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_ATTR_INFO_set_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nX509_NAME *dn)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_DN,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nif ((attrs->values[code].dn = X509_NAME_dup(dn)))\\r\\nreturn 1;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_DN,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_DN, STORE_R_ALREADY_HAS_A_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_ATTR_INFO_set_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nBIGNUM *number)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nif ((attrs->values[code].number = BN_dup(number)))\\r\\nreturn 1;\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_SET_NUMBER, STORE_R_ALREADY_HAS_A_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_ATTR_INFO_modify_cstr(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nchar *cstr, size_t cstr_size)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_CSTR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nOPENSSL_free(attrs->values[code].cstring);\\r\\nattrs->values[code].cstring = NULL;\\r\\nCLEAR_ATTRBIT(attrs, code);\\r\\n}\\r\\nreturn STORE_ATTR_INFO_set_cstr(attrs, code, cstr, cstr_size);\\r\\n}\\r\\nint STORE_ATTR_INFO_modify_sha1str(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nunsigned char *sha1str, size_t sha1str_size)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_SHA1STR,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nOPENSSL_free(attrs->values[code].sha1string);\\r\\nattrs->values[code].sha1string = NULL;\\r\\nCLEAR_ATTRBIT(attrs, code);\\r\\n}\\r\\nreturn STORE_ATTR_INFO_set_sha1str(attrs, code, sha1str, sha1str_size);\\r\\n}\\r\\nint STORE_ATTR_INFO_modify_dn(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nX509_NAME *dn)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_DN,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nOPENSSL_free(attrs->values[code].dn);\\r\\nattrs->values[code].dn = NULL;\\r\\nCLEAR_ATTRBIT(attrs, code);\\r\\n}\\r\\nreturn STORE_ATTR_INFO_set_dn(attrs, code, dn);\\r\\n}\\r\\nint STORE_ATTR_INFO_modify_number(STORE_ATTR_INFO *attrs, STORE_ATTR_TYPES code,\\r\\nBIGNUM *number)\\r\\n{\\r\\nif (!attrs)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_ATTR_INFO_MODIFY_NUMBER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ATTR_IS_SET(attrs,code))\\r\\n{\\r\\nOPENSSL_free(attrs->values[code].number);\\r\\nattrs->values[code].number = NULL;\\r\\nCLEAR_ATTRBIT(attrs, code);\\r\\n}\\r\\nreturn STORE_ATTR_INFO_set_number(attrs, code, number);\\r\\n}\\r\\nvoid *STORE_parse_attrs_start(OPENSSL_ITEM *attributes)\\r\\n{\\r\\nif (attributes)\\r\\n{\\r\\nstruct attr_list_ctx_st *context =\\r\\n(struct attr_list_ctx_st *)OPENSSL_malloc(sizeof(struct attr_list_ctx_st));\\r\\nif (context)\\r\\ncontext->attributes = attributes;\\r\\nelse\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_START,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn context;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_START, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nSTORE_ATTR_INFO *STORE_parse_attrs_next(void *handle)\\r\\n{\\r\\nstruct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;\\r\\nif (context && context->attributes)\\r\\n{\\r\\nSTORE_ATTR_INFO *attrs = NULL;\\r\\nwhile(context->attributes\\r\\n&& context->attributes->code != STORE_ATTR_OR\\r\\n&& context->attributes->code != STORE_ATTR_END)\\r\\n{\\r\\nswitch(context->attributes->code)\\r\\n{\\r\\ncase STORE_ATTR_FRIENDLYNAME:\\r\\ncase STORE_ATTR_EMAIL:\\r\\ncase STORE_ATTR_FILENAME:\\r\\nif (!attrs) attrs = STORE_ATTR_INFO_new();\\r\\nif (attrs == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nSTORE_ATTR_INFO_set_cstr(attrs,\\r\\ncontext->attributes->code,\\r\\ncontext->attributes->value,\\r\\ncontext->attributes->value_size);\\r\\nbreak;\\r\\ncase STORE_ATTR_KEYID:\\r\\ncase STORE_ATTR_ISSUERKEYID:\\r\\ncase STORE_ATTR_SUBJECTKEYID:\\r\\ncase STORE_ATTR_ISSUERSERIALHASH:\\r\\ncase STORE_ATTR_CERTHASH:\\r\\nif (!attrs) attrs = STORE_ATTR_INFO_new();\\r\\nif (attrs == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nSTORE_ATTR_INFO_set_sha1str(attrs,\\r\\ncontext->attributes->code,\\r\\ncontext->attributes->value,\\r\\ncontext->attributes->value_size);\\r\\nbreak;\\r\\ncase STORE_ATTR_ISSUER:\\r\\ncase STORE_ATTR_SUBJECT:\\r\\nif (!attrs) attrs = STORE_ATTR_INFO_new();\\r\\nif (attrs == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nSTORE_ATTR_INFO_modify_dn(attrs,\\r\\ncontext->attributes->code,\\r\\ncontext->attributes->value);\\r\\nbreak;\\r\\ncase STORE_ATTR_SERIAL:\\r\\nif (!attrs) attrs = STORE_ATTR_INFO_new();\\r\\nif (attrs == NULL)\\r\\n{\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nSTORE_ATTR_INFO_modify_number(attrs,\\r\\ncontext->attributes->code,\\r\\ncontext->attributes->value);\\r\\nbreak;\\r\\n}\\r\\ncontext->attributes++;\\r\\n}\\r\\nif (context->attributes->code == STORE_ATTR_OR)\\r\\ncontext->attributes++;\\r\\nreturn attrs;\\r\\nerr:\\r\\nwhile(context->attributes\\r\\n&& context->attributes->code != STORE_ATTR_OR\\r\\n&& context->attributes->code != STORE_ATTR_END)\\r\\ncontext->attributes++;\\r\\nif (context->attributes->code == STORE_ATTR_OR)\\r\\ncontext->attributes++;\\r\\nreturn NULL;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_NEXT, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nint STORE_parse_attrs_end(void *handle)\\r\\n{\\r\\nstruct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;\\r\\nif (context && context->attributes)\\r\\n{\\r\\n#if 0\\r\\nOPENSSL_ITEM *attributes = context->attributes;\\r\\n#endif\\r\\nOPENSSL_free(context);\\r\\nreturn 1;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_END, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_parse_attrs_endp(void *handle)\\r\\n{\\r\\nstruct attr_list_ctx_st *context = (struct attr_list_ctx_st *)handle;\\r\\nif (context && context->attributes)\\r\\n{\\r\\nreturn context->attributes->code == STORE_ATTR_END;\\r\\n}\\r\\nSTOREerr(STORE_F_STORE_PARSE_ATTRS_ENDP, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int attr_info_compare_compute_range(\\r\\nunsigned char *abits, unsigned char *bbits,\\r\\nunsigned int *alowp, unsigned int *ahighp,\\r\\nunsigned int *blowp, unsigned int *bhighp)\\r\\n{\\r\\nunsigned int alow = (unsigned int)-1, ahigh = 0;\\r\\nunsigned int blow = (unsigned int)-1, bhigh = 0;\\r\\nint i, res = 0;\\r\\nfor (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++)\\r\\n{\\r\\nif (res == 0)\\r\\n{\\r\\nif (*abits < *bbits) res = -1;\\r\\nif (*abits > *bbits) res = 1;\\r\\n}\\r\\nif (*abits)\\r\\n{\\r\\nif (alow == (unsigned int)-1)\\r\\n{\\r\\nalow = i * 8;\\r\\nif (!(*abits & 0x01)) alow++;\\r\\nif (!(*abits & 0x02)) alow++;\\r\\nif (!(*abits & 0x04)) alow++;\\r\\nif (!(*abits & 0x08)) alow++;\\r\\nif (!(*abits & 0x10)) alow++;\\r\\nif (!(*abits & 0x20)) alow++;\\r\\nif (!(*abits & 0x40)) alow++;\\r\\n}\\r\\nahigh = i * 8 + 7;\\r\\nif (!(*abits & 0x80)) ahigh++;\\r\\nif (!(*abits & 0x40)) ahigh++;\\r\\nif (!(*abits & 0x20)) ahigh++;\\r\\nif (!(*abits & 0x10)) ahigh++;\\r\\nif (!(*abits & 0x08)) ahigh++;\\r\\nif (!(*abits & 0x04)) ahigh++;\\r\\nif (!(*abits & 0x02)) ahigh++;\\r\\n}\\r\\nif (*bbits)\\r\\n{\\r\\nif (blow == (unsigned int)-1)\\r\\n{\\r\\nblow = i * 8;\\r\\nif (!(*bbits & 0x01)) blow++;\\r\\nif (!(*bbits & 0x02)) blow++;\\r\\nif (!(*bbits & 0x04)) blow++;\\r\\nif (!(*bbits & 0x08)) blow++;\\r\\nif (!(*bbits & 0x10)) blow++;\\r\\nif (!(*bbits & 0x20)) blow++;\\r\\nif (!(*bbits & 0x40)) blow++;\\r\\n}\\r\\nbhigh = i * 8 + 7;\\r\\nif (!(*bbits & 0x80)) bhigh++;\\r\\nif (!(*bbits & 0x40)) bhigh++;\\r\\nif (!(*bbits & 0x20)) bhigh++;\\r\\nif (!(*bbits & 0x10)) bhigh++;\\r\\nif (!(*bbits & 0x08)) bhigh++;\\r\\nif (!(*bbits & 0x04)) bhigh++;\\r\\nif (!(*bbits & 0x02)) bhigh++;\\r\\n}\\r\\n}\\r\\nif (ahigh + alow < bhigh + blow) res = -1;\\r\\nif (ahigh + alow > bhigh + blow) res = 1;\\r\\nif (alowp) *alowp = alow;\\r\\nif (ahighp) *ahighp = ahigh;\\r\\nif (blowp) *blowp = blow;\\r\\nif (bhighp) *bhighp = bhigh;\\r\\nreturn res;\\r\\n}\\r\\nint STORE_ATTR_INFO_compare(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)\\r\\n{\\r\\nif (a == b) return 0;\\r\\nif (!a) return -1;\\r\\nif (!b) return 1;\\r\\nreturn attr_info_compare_compute_range(a->set, b->set, 0, 0, 0, 0);\\r\\n}\\r\\nint STORE_ATTR_INFO_in_range(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)\\r\\n{\\r\\nunsigned int alow, ahigh, blow, bhigh;\\r\\nif (a == b) return 1;\\r\\nif (!a) return 0;\\r\\nif (!b) return 0;\\r\\nattr_info_compare_compute_range(a->set, b->set,\\r\\n&alow, &ahigh, &blow, &bhigh);\\r\\nif (alow >= blow && ahigh <= bhigh)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint STORE_ATTR_INFO_in(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)\\r\\n{\\r\\nunsigned char *abits, *bbits;\\r\\nint i;\\r\\nif (a == b) return 1;\\r\\nif (!a) return 0;\\r\\nif (!b) return 0;\\r\\nabits = a->set;\\r\\nbbits = b->set;\\r\\nfor (i = 0; i < (STORE_ATTR_TYPE_NUM + 8) / 8; i++, abits++, bbits++)\\r\\n{\\r\\nif (*abits && (*bbits & *abits) != *abits)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_ATTR_INFO_in_ex(STORE_ATTR_INFO *a, STORE_ATTR_INFO *b)\\r\\n{\\r\\nSTORE_ATTR_TYPES i;\\r\\nif (a == b) return 1;\\r\\nif (!STORE_ATTR_INFO_in(a, b)) return 0;\\r\\nfor (i = 1; i < STORE_ATTR_TYPE_NUM; i++)\\r\\nif (ATTR_IS_SET(a, i))\\r\\n{\\r\\nswitch(i)\\r\\n{\\r\\ncase STORE_ATTR_FRIENDLYNAME:\\r\\ncase STORE_ATTR_EMAIL:\\r\\ncase STORE_ATTR_FILENAME:\\r\\nif (strcmp(a->values[i].cstring,\\r\\nb->values[i].cstring))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase STORE_ATTR_KEYID:\\r\\ncase STORE_ATTR_ISSUERKEYID:\\r\\ncase STORE_ATTR_SUBJECTKEYID:\\r\\ncase STORE_ATTR_ISSUERSERIALHASH:\\r\\ncase STORE_ATTR_CERTHASH:\\r\\nif (memcmp(a->values[i].sha1string,\\r\\nb->values[i].sha1string,\\r\\na->value_sizes[i]))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase STORE_ATTR_ISSUER:\\r\\ncase STORE_ATTR_SUBJECT:\\r\\nif (X509_NAME_cmp(a->values[i].dn,\\r\\nb->values[i].dn))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase STORE_ATTR_SERIAL:\\r\\nif (BN_cmp(a->values[i].number,\\r\\nb->values[i].number))\\r\\nreturn 0;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_strnid_c", "target": 0, "func": "void ASN1_STRING_set_default_mask(unsigned long mask)\\r\\n{\\r\\nglobal_mask = mask;\\r\\n}\\r\\nunsigned long ASN1_STRING_get_default_mask(void)\\r\\n{\\r\\nreturn global_mask;\\r\\n}\\r\\nint ASN1_STRING_set_default_mask_asc(char *p)\\r\\n{\\r\\nunsigned long mask;\\r\\nchar *end;\\r\\nif(!strncmp(p, \"MASK:\", 5)) {\\r\\nif(!p[5]) return 0;\\r\\nmask = strtoul(p + 5, &end, 0);\\r\\nif(*end) return 0;\\r\\n} else if(!strcmp(p, \"nombstr\"))\\r\\nmask = ~((unsigned long)(B_ASN1_BMPSTRING|B_ASN1_UTF8STRING));\\r\\nelse if(!strcmp(p, \"pkix\"))\\r\\nmask = ~((unsigned long)B_ASN1_T61STRING);\\r\\nelse if(!strcmp(p, \"utf8only\")) mask = B_ASN1_UTF8STRING;\\r\\nelse if(!strcmp(p, \"default\"))\\r\\nmask = 0xFFFFFFFFL;\\r\\nelse return 0;\\r\\nASN1_STRING_set_default_mask(mask);\\r\\nreturn 1;\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out, const unsigned char *in,\\r\\nint inlen, int inform, int nid)\\r\\n{\\r\\nASN1_STRING_TABLE *tbl;\\r\\nASN1_STRING *str = NULL;\\r\\nunsigned long mask;\\r\\nint ret;\\r\\nif(!out) out = &str;\\r\\ntbl = ASN1_STRING_TABLE_get(nid);\\r\\nif(tbl) {\\r\\nmask = tbl->mask;\\r\\nif(!(tbl->flags & STABLE_NO_MASK)) mask &= global_mask;\\r\\nret = ASN1_mbstring_ncopy(out, in, inlen, inform, mask,\\r\\ntbl->minsize, tbl->maxsize);\\r\\n} else ret = ASN1_mbstring_copy(out, in, inlen, inform, DIRSTRING_TYPE & global_mask);\\r\\nif(ret <= 0) return NULL;\\r\\nreturn *out;\\r\\n}\\r\\nstatic int sk_table_cmp(const ASN1_STRING_TABLE * const *a,\\r\\nconst ASN1_STRING_TABLE * const *b)\\r\\n{\\r\\nreturn (*a)->nid - (*b)->nid;\\r\\n}\\r\\nstatic int table_cmp(const void *a, const void *b)\\r\\n{\\r\\nconst ASN1_STRING_TABLE *sa = a, *sb = b;\\r\\nreturn sa->nid - sb->nid;\\r\\n}\\r\\nASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid)\\r\\n{\\r\\nint idx;\\r\\nASN1_STRING_TABLE *ttmp;\\r\\nASN1_STRING_TABLE fnd;\\r\\nfnd.nid = nid;\\r\\nttmp = (ASN1_STRING_TABLE *) OBJ_bsearch((char *)&fnd,\\r\\n(char *)tbl_standard,\\r\\nsizeof(tbl_standard)/sizeof(ASN1_STRING_TABLE),\\r\\nsizeof(ASN1_STRING_TABLE), table_cmp);\\r\\nif(ttmp) return ttmp;\\r\\nif(!stable) return NULL;\\r\\nidx = sk_ASN1_STRING_TABLE_find(stable, &fnd);\\r\\nif(idx < 0) return NULL;\\r\\nreturn sk_ASN1_STRING_TABLE_value(stable, idx);\\r\\n}\\r\\nint ASN1_STRING_TABLE_add(int nid,\\r\\nlong minsize, long maxsize, unsigned long mask,\\r\\nunsigned long flags)\\r\\n{\\r\\nASN1_STRING_TABLE *tmp;\\r\\nchar new_nid = 0;\\r\\nflags &= ~STABLE_FLAGS_MALLOC;\\r\\nif(!stable) stable = sk_ASN1_STRING_TABLE_new(sk_table_cmp);\\r\\nif(!stable) {\\r\\nASN1err(ASN1_F_ASN1_STRING_TABLE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(tmp = ASN1_STRING_TABLE_get(nid))) {\\r\\ntmp = OPENSSL_malloc(sizeof(ASN1_STRING_TABLE));\\r\\nif(!tmp) {\\r\\nASN1err(ASN1_F_ASN1_STRING_TABLE_ADD,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntmp->flags = flags | STABLE_FLAGS_MALLOC;\\r\\ntmp->nid = nid;\\r\\nnew_nid = 1;\\r\\n} else tmp->flags = (tmp->flags & STABLE_FLAGS_MALLOC) | flags;\\r\\nif(minsize != -1) tmp->minsize = minsize;\\r\\nif(maxsize != -1) tmp->maxsize = maxsize;\\r\\ntmp->mask = mask;\\r\\nif(new_nid) sk_ASN1_STRING_TABLE_push(stable, tmp);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ASN1_STRING_TABLE_cleanup(void)\\r\\n{\\r\\nSTACK_OF(ASN1_STRING_TABLE) *tmp;\\r\\ntmp = stable;\\r\\nif(!tmp) return;\\r\\nstable = NULL;\\r\\nsk_ASN1_STRING_TABLE_pop_free(tmp, st_free);\\r\\n}\\r\\nstatic void st_free(ASN1_STRING_TABLE *tbl)\\r\\n{\\r\\nif(tbl->flags & STABLE_FLAGS_MALLOC) OPENSSL_free(tbl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic DES_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nstatic DES_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};\\r\\nstatic DES_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};\\r\\nDES_key_schedule sch,sch2,sch3;\\r\\ndouble a,b,c,d,e;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nDES_set_key_unchecked(&key2,&sch2);\\r\\nDES_set_key_unchecked(&key3,&sch3);\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nDES_set_key_unchecked(&key,&sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nDES_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nDES_encrypt1(data,&sch,DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\nprintf(\"Doing set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count++)\\r\\nDES_set_key_unchecked(&key,&sch);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count++)\\r\\n{\\r\\nDES_LONG data[2];\\r\\nDES_encrypt1(data,&sch,DES_ENCRYPT);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld DES_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nDES_ncbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&key,DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld DES_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_ede_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_ede_cbc_encrypt %ld times on %ld byte blocks\\n\",cd,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cd); count++)\\r\\nDES_ede3_cbc_encrypt(buf,buf,BUFSIZE,\\r\\n&sch,\\r\\n&sch2,\\r\\n&sch3,\\r\\n&key,\\r\\nDES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld DES_ede_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nd=((double)COUNT(cd)*BUFSIZE)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing crypt for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing crypt %ld times\\n\",ce);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ce); count++)\\r\\ncrypt(\"testing1\",\"ef\");\\r\\ne=Time_F(STOP);\\r\\nprintf(\"%ld crypts in %.2f second\\n\",count,e);\\r\\ne=((double)COUNT(ce))/e;\\r\\nprintf(\"set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"DES raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"DES cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nprintf(\"DES ede cbc bytes per sec = %12.2f (%9.3fuS)\\n\",d,8.0e6/d);\\r\\nprintf(\"crypt per sec = %12.2f (%9.3fuS)\\n\",e,1.0e6/e);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_exp2_c", "target": 0, "func": "int BN_mod_exp2_mont(BIGNUM *rr, const BIGNUM *a1, const BIGNUM *p1,\\r\\nconst BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i,j,bits,b,bits1,bits2,ret=0,wpos1,wpos2,window1,window2,wvalue1,wvalue2;\\r\\nint r_is_one=1;\\r\\nBIGNUM *d,*r;\\r\\nconst BIGNUM *a_mod_m;\\r\\nBIGNUM *val1[TABLE_SIZE], *val2[TABLE_SIZE];\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nbn_check_top(a1);\\r\\nbn_check_top(p1);\\r\\nbn_check_top(a2);\\r\\nbn_check_top(p2);\\r\\nbn_check_top(m);\\r\\nif (!(m->d[0] & 1))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP2_MONT,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nbits1=BN_num_bits(p1);\\r\\nbits2=BN_num_bits(p2);\\r\\nif ((bits1 == 0) && (bits2 == 0))\\r\\n{\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nbits=(bits1 > bits2)?bits1:bits2;\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nval1[0] = BN_CTX_get(ctx);\\r\\nval2[0] = BN_CTX_get(ctx);\\r\\nif(!d || !r || !val1[0] || !val2[0]) goto err;\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n{\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,m,ctx)) goto err;\\r\\n}\\r\\nwindow1 = BN_window_bits_for_exponent_size(bits1);\\r\\nwindow2 = BN_window_bits_for_exponent_size(bits2);\\r\\nif (a1->neg || BN_ucmp(a1,m) >= 0)\\r\\n{\\r\\nif (!BN_mod(val1[0],a1,m,ctx))\\r\\ngoto err;\\r\\na_mod_m = val1[0];\\r\\n}\\r\\nelse\\r\\na_mod_m = a1;\\r\\nif (BN_is_zero(a_mod_m))\\r\\n{\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val1[0],a_mod_m,mont,ctx)) goto err;\\r\\nif (window1 > 1)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(d,val1[0],val1[0],mont,ctx)) goto err;\\r\\nj=1<<(window1-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nif(((val1[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val1[i],val1[i-1],\\r\\nd,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (a2->neg || BN_ucmp(a2,m) >= 0)\\r\\n{\\r\\nif (!BN_mod(val2[0],a2,m,ctx))\\r\\ngoto err;\\r\\na_mod_m = val2[0];\\r\\n}\\r\\nelse\\r\\na_mod_m = a2;\\r\\nif (BN_is_zero(a_mod_m))\\r\\n{\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val2[0],a_mod_m,mont,ctx)) goto err;\\r\\nif (window2 > 1)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(d,val2[0],val2[0],mont,ctx)) goto err;\\r\\nj=1<<(window2-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nif(((val2[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val2[i],val2[i-1],\\r\\nd,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr_is_one=1;\\r\\nwvalue1=0;\\r\\nwvalue2=0;\\r\\nwpos1=0;\\r\\nwpos2=0;\\r\\nif (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;\\r\\nfor (b=bits-1; b>=0; b--)\\r\\n{\\r\\nif (!r_is_one)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!wvalue1)\\r\\nif (BN_is_bit_set(p1, b))\\r\\n{\\r\\ni = b-window1+1;\\r\\nwhile (!BN_is_bit_set(p1, i))\\r\\ni++;\\r\\nwpos1 = i;\\r\\nwvalue1 = 1;\\r\\nfor (i = b-1; i >= wpos1; i--)\\r\\n{\\r\\nwvalue1 <<= 1;\\r\\nif (BN_is_bit_set(p1, i))\\r\\nwvalue1++;\\r\\n}\\r\\n}\\r\\nif (!wvalue2)\\r\\nif (BN_is_bit_set(p2, b))\\r\\n{\\r\\ni = b-window2+1;\\r\\nwhile (!BN_is_bit_set(p2, i))\\r\\ni++;\\r\\nwpos2 = i;\\r\\nwvalue2 = 1;\\r\\nfor (i = b-1; i >= wpos2; i--)\\r\\n{\\r\\nwvalue2 <<= 1;\\r\\nif (BN_is_bit_set(p2, i))\\r\\nwvalue2++;\\r\\n}\\r\\n}\\r\\nif (wvalue1 && b == wpos1)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,val1[wvalue1>>1],mont,ctx))\\r\\ngoto err;\\r\\nwvalue1 = 0;\\r\\nr_is_one = 0;\\r\\n}\\r\\nif (wvalue2 && b == wpos2)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,val2[wvalue2>>1],mont,ctx))\\r\\ngoto err;\\r\\nwvalue2 = 0;\\r\\nr_is_one = 0;\\r\\n}\\r\\n}\\r\\nBN_from_montgomery(rr,r,mont,ctx);\\r\\nret=1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_des_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i;\\r\\nstruct stat ins,outs;\\r\\nchar *p;\\r\\nchar *in=NULL,*out=NULL;\\r\\nvflag=cflag=eflag=dflag=kflag=hflag=bflag=fflag=sflag=uflag=flag3=0;\\r\\nerror=0;\\r\\nmemset(key,0,sizeof(key));\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\np=argv[i];\\r\\nif ((p[0] == '-') && (p[1] != '\\0'))\\r\\n{\\r\\np++;\\r\\nwhile (*p)\\r\\n{\\r\\nswitch (*(p++))\\r\\n{\\r\\ncase '3':\\r\\nflag3=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'c':\\r\\ncflag=1;\\r\\nstrncpy(cksumname,p,200);\\r\\ncksumname[sizeof(cksumname)-1]='\\0';\\r\\np+=strlen(cksumname);\\r\\nbreak;\\r\\ncase 'C':\\r\\ncflag=1;\\r\\nlongk=1;\\r\\nstrncpy(cksumname,p,200);\\r\\ncksumname[sizeof(cksumname)-1]='\\0';\\r\\np+=strlen(cksumname);\\r\\nbreak;\\r\\ncase 'e':\\r\\neflag=1;\\r\\nbreak;\\r\\ncase 'v':\\r\\nvflag=1;\\r\\nbreak;\\r\\ncase 'E':\\r\\neflag=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'd':\\r\\ndflag=1;\\r\\nbreak;\\r\\ncase 'D':\\r\\ndflag=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'b':\\r\\nbflag=1;\\r\\nbreak;\\r\\ncase 'f':\\r\\nfflag=1;\\r\\nbreak;\\r\\ncase 's':\\r\\nsflag=1;\\r\\nbreak;\\r\\ncase 'u':\\r\\nuflag=1;\\r\\nstrncpy(uuname,p,200);\\r\\nuuname[sizeof(uuname)-1]='\\0';\\r\\np+=strlen(uuname);\\r\\nbreak;\\r\\ncase 'h':\\r\\nhflag=1;\\r\\nbreak;\\r\\ncase 'k':\\r\\nkflag=1;\\r\\nif ((i+1) == argc)\\r\\n{\\r\\nfputs(\"must have a key with the -k option\\n\",stderr);\\r\\nerror=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nint j;\\r\\ni++;\\r\\nstrncpy(key,argv[i],KEYSIZB);\\r\\nfor (j=strlen(argv[i])-1; j>=0; j--)\\r\\nargv[i][j]='\\0';\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nfprintf(stderr,\"'%c' unknown flag\\n\",p[-1]);\\r\\nerror=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (in == NULL)\\r\\nin=argv[i];\\r\\nelse if (out == NULL)\\r\\nout=argv[i];\\r\\nelse\\r\\nerror=1;\\r\\n}\\r\\n}\\r\\nif (error) usage();\\r\\nif (((eflag+dflag) == 1) || cflag)\\r\\n{\\r\\nif (eflag) do_encrypt=DES_ENCRYPT;\\r\\nif (dflag) do_encrypt=DES_DECRYPT;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (vflag)\\r\\n{\\r\\n#ifndef _Windows\\r\\nfprintf(stderr,\"des(1) built with %s\\n\",libdes_version);\\r\\n#endif\\r\\nEXIT(1);\\r\\n}\\r\\nelse usage();\\r\\n}\\r\\n#ifndef _Windows\\r\\nif (vflag) fprintf(stderr,\"des(1) built with %s\\n\",libdes_version);\\r\\n#endif\\r\\nif ( (in != NULL) &&\\r\\n(out != NULL) &&\\r\\n#ifndef OPENSSL_SYS_MSDOS\\r\\n(stat(in,&ins) != -1) &&\\r\\n(stat(out,&outs) != -1) &&\\r\\n(ins.st_dev == outs.st_dev) &&\\r\\n(ins.st_ino == outs.st_ino))\\r\\n#else\\r\\n(strcmp(in,out) == 0))\\r\\n#endif\\r\\n{\\r\\nfputs(\"input and output file are the same\\n\",stderr);\\r\\nEXIT(3);\\r\\n}\\r\\nif (!kflag\\r\\nvoid doencryption(void)\\r\\n{\\r\\n#ifdef _LIBC\\r\\nextern unsigned long time();\\r\\n#endif\\r\\nregister int i;\\r\\nDES_key_schedule ks,ks2;\\r\\nDES_cblock iv,iv2;\\r\\nchar *p;\\r\\nint num=0,j,k,l,rem,ll,len,last,ex=0;\\r\\nDES_cblock kk,k2;\\r\\nFILE *O;\\r\\nint Exit=0;\\r\\n#ifndef OPENSSL_SYS_MSDOS\\r\\nstatic unsigned char buf[BUFSIZE+8],obuf[BUFSIZE+8];\\r\\n#else\\r\\nstatic unsigned char *buf=NULL,*obuf=NULL;\\r\\nif (buf == NULL)\\r\\n{\\r\\nif ( (( buf=OPENSSL_malloc(BUFSIZE+8)) == NULL) ||\\r\\n((obuf=OPENSSL_malloc(BUFSIZE+8)) == NULL))\\r\\n{\\r\\nfputs(\"Not enough memory\\n\",stderr);\\r\\nExit=10;\\r\\ngoto problems;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (hflag)\\r\\n{\\r\\nj=(flag3?16:8);\\r\\np=key;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nk=0;\\r\\nif ((*p <= '9') && (*p >= '0'))\\r\\nk=(*p-'0')<<4;\\r\\nelse if ((*p <= 'f') && (*p >= 'a'))\\r\\nk=(*p-'a'+10)<<4;\\r\\nelse if ((*p <= 'F') && (*p >= 'A'))\\r\\nk=(*p-'A'+10)<<4;\\r\\nelse\\r\\n{\\r\\nfputs(\"Bad hex key\\n\",stderr);\\r\\nExit=9;\\r\\ngoto problems;\\r\\n}\\r\\np++;\\r\\nif ((*p <= '9') && (*p >= '0'))\\r\\nk|=(*p-'0');\\r\\nelse if ((*p <= 'f') && (*p >= 'a'))\\r\\nk|=(*p-'a'+10);\\r\\nelse if ((*p <= 'F') && (*p >= 'A'))\\r\\nk|=(*p-'A'+10);\\r\\nelse\\r\\n{\\r\\nfputs(\"Bad hex key\\n\",stderr);\\r\\nExit=9;\\r\\ngoto problems;\\r\\n}\\r\\np++;\\r\\nif (i < 8)\\r\\nkk[i]=k;\\r\\nelse\\r\\nk2[i-8]=k;\\r\\n}\\r\\nDES_set_key_unchecked(&k2,&ks2);\\r\\nOPENSSL_cleanse(k2,sizeof(k2));\\r\\n}\\r\\nelse if (longk || flag3)\\r\\n{\\r\\nif (flag3)\\r\\n{\\r\\nDES_string_to_2keys(key,&kk,&k2);\\r\\nDES_set_key_unchecked(&k2,&ks2);\\r\\nOPENSSL_cleanse(k2,sizeof(k2));\\r\\n}\\r\\nelse\\r\\nDES_string_to_key(key,&kk);\\r\\n}\\r\\nelse\\r\\nfor (i=0; i<KEYSIZ; i++)\\r\\n{\\r\\nl=0;\\r\\nk=key[i];\\r\\nfor (j=0; j<8; j++)\\r\\n{\\r\\nif (k&1) l++;\\r\\nk>>=1;\\r\\n}\\r\\nif (l & 1)\\r\\nkk[i]=key[i]&0x7f;\\r\\nelse\\r\\nkk[i]=key[i]|0x80;\\r\\n}\\r\\nDES_set_key_unchecked(&kk,&ks);\\r\\nOPENSSL_cleanse(key,sizeof(key));\\r\\nOPENSSL_cleanse(kk,sizeof(kk));\\r\\nmemset(iv,0,sizeof(iv));\\r\\nmemset(iv2,0,sizeof(iv2));\\r\\nl=1;\\r\\nrem=0;\\r\\nif (eflag || (!dflag && cflag))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nnum=l=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nl+=rem;\\r\\nnum+=rem;\\r\\nif (l < 0)\\r\\n{\\r\\nperror(\"read error\");\\r\\nExit=6;\\r\\ngoto problems;\\r\\n}\\r\\nrem=l%8;\\r\\nlen=l-rem;\\r\\nif (feof(DES_IN))\\r\\n{\\r\\nfor (i=7-rem; i>0; i--)\\r\\nRAND_pseudo_bytes(buf + l++, 1);\\r\\nbuf[l++]=rem;\\r\\nex=1;\\r\\nlen+=rem;\\r\\n}\\r\\nelse\\r\\nl-=rem;\\r\\nif (cflag)\\r\\n{\\r\\nDES_cbc_cksum(buf,&cksum,\\r\\n(long)len,&ks,&cksum);\\r\\nif (!eflag)\\r\\n{\\r\\nif (feof(DES_IN)) break;\\r\\nelse continue;\\r\\n}\\r\\n}\\r\\nif (bflag && !flag3)\\r\\nfor (i=0; i<l; i+=8)\\r\\nDES_ecb_encrypt(\\r\\n(DES_cblock *)&(buf[i]),\\r\\n(DES_cblock *)&(obuf[i]),\\r\\n&ks,do_encrypt);\\r\\nelse if (flag3 && bflag)\\r\\nfor (i=0; i<l; i+=8)\\r\\nDES_ecb2_encrypt(\\r\\n(DES_cblock *)&(buf[i]),\\r\\n(DES_cblock *)&(obuf[i]),\\r\\n&ks,&ks2,do_encrypt);\\r\\nelse if (flag3 && !bflag)\\r\\n{\\r\\nchar tmpbuf[8];\\r\\nif (rem) memcpy(tmpbuf,&(buf[l]),\\r\\n(unsigned int)rem);\\r\\nDES_3cbc_encrypt(\\r\\n(DES_cblock *)buf,(DES_cblock *)obuf,\\r\\n(long)l,ks,ks2,&iv,\\r\\n&iv2,do_encrypt);\\r\\nif (rem) memcpy(&(buf[l]),tmpbuf,\\r\\n(unsigned int)rem);\\r\\n}\\r\\nelse\\r\\n{\\r\\nDES_cbc_encrypt(\\r\\nbuf,obuf,\\r\\n(long)l,&ks,&iv,do_encrypt);\\r\\nif (l >= 8) memcpy(iv,&(obuf[l-8]),8);\\r\\n}\\r\\nif (rem) memcpy(buf,&(buf[l]),(unsigned int)rem);\\r\\ni=0;\\r\\nwhile (i < l)\\r\\n{\\r\\nif (uflag)\\r\\nj=uufwrite(obuf,1,(unsigned int)l-i,\\r\\nDES_OUT);\\r\\nelse\\r\\nj=fwrite(obuf,1,(unsigned int)l-i,\\r\\nDES_OUT);\\r\\nif (j == -1)\\r\\n{\\r\\nperror(\"Write error\");\\r\\nExit=7;\\r\\ngoto problems;\\r\\n}\\r\\ni+=j;\\r\\n}\\r\\nif (feof(DES_IN))\\r\\n{\\r\\nif (uflag) uufwriteEnd(DES_OUT);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nex=1;\\r\\nfor (;;)\\r\\n{\\r\\nif (ex) {\\r\\nif (uflag)\\r\\nl=uufread(buf,1,BUFSIZE,DES_IN);\\r\\nelse\\r\\nl=fread(buf,1,BUFSIZE,DES_IN);\\r\\nex=0;\\r\\nrem=l%8;\\r\\nl-=rem;\\r\\n}\\r\\nif (l < 0)\\r\\n{\\r\\nperror(\"read error\");\\r\\nExit=6;\\r\\ngoto problems;\\r\\n}\\r\\nif (bflag && !flag3)\\r\\nfor (i=0; i<l; i+=8)\\r\\nDES_ecb_encrypt(\\r\\n(DES_cblock *)&(buf[i]),\\r\\n(DES_cblock *)&(obuf[i]),\\r\\n&ks,do_encrypt);\\r\\nelse if (flag3 && bflag)\\r\\nfor (i=0; i<l; i+=8)\\r\\nDES_ecb2_encrypt(\\r\\n(DES_cblock *)&(buf[i]),\\r\\n(DES_cblock *)&(obuf[i]),\\r\\n&ks,&ks2,do_encrypt);\\r\\nelse if (flag3 && !bflag)\\r\\n{\\r\\nDES_3cbc_encrypt(\\r\\n(DES_cblock *)buf,(DES_cblock *)obuf,\\r\\n(long)l,ks,ks2,&iv,\\r\\n&iv2,do_encrypt);\\r\\n}\\r\\nelse\\r\\n{\\r\\nDES_cbc_encrypt(\\r\\nbuf,obuf,\\r\\n(long)l,&ks,&iv,do_encrypt);\\r\\nif (l >= 8) memcpy(iv,&(buf[l-8]),8);\\r\\n}\\r\\nif (uflag)\\r\\nll=uufread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nelse\\r\\nll=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nll+=rem;\\r\\nrem=ll%8;\\r\\nll-=rem;\\r\\nif (feof(DES_IN) && (ll == 0))\\r\\n{\\r\\nlast=obuf[l-1];\\r\\nif ((last > 7) || (last < 0))\\r\\n{\\r\\nfputs(\"The file was not decrypted correctly.\\n\",\\r\\nstderr);\\r\\nExit=8;\\r\\nlast=0;\\r\\n}\\r\\nl=l-8+last;\\r\\n}\\r\\ni=0;\\r\\nif (cflag) DES_cbc_cksum(obuf,\\r\\n(DES_cblock *)cksum,(long)l/8*8,&ks,\\r\\n(DES_cblock *)cksum);\\r\\nwhile (i != l)\\r\\n{\\r\\nj=fwrite(obuf,1,(unsigned int)l-i,DES_OUT);\\r\\nif (j == -1)\\r\\n{\\r\\nperror(\"Write error\");\\r\\nExit=7;\\r\\ngoto problems;\\r\\n}\\r\\ni+=j;\\r\\n}\\r\\nl=ll;\\r\\nif ((l == 0) && feof(DES_IN)) break;\\r\\n}\\r\\n}\\r\\nif (cflag)\\r\\n{\\r\\nl=0;\\r\\nif (cksumname[0] != '\\0')\\r\\n{\\r\\nif ((O=fopen(cksumname,\"w\")) != NULL)\\r\\n{\\r\\nCKSUM_OUT=O;\\r\\nl=1;\\r\\n}\\r\\n}\\r\\nfor (i=0; i<8; i++)\\r\\nfprintf(CKSUM_OUT,\"%02X\",cksum[i]);\\r\\nfprintf(CKSUM_OUT,\"\\n\");\\r\\nif (l) fclose(CKSUM_OUT);\\r\\n}\\r\\nproblems:\\r\\nOPENSSL_cleanse(buf,sizeof(buf));\\r\\nOPENSSL_cleanse(obuf,sizeof(obuf));\\r\\nOPENSSL_cleanse(&ks,sizeof(ks));\\r\\nOPENSSL_cleanse(&ks2,sizeof(ks2));\\r\\nOPENSSL_cleanse(iv,sizeof(iv));\\r\\nOPENSSL_cleanse(iv2,sizeof(iv2));\\r\\nOPENSSL_cleanse(kk,sizeof(kk));\\r\\nOPENSSL_cleanse(k2,sizeof(k2));\\r\\nOPENSSL_cleanse(uubuf,sizeof(uubuf));\\r\\nOPENSSL_cleanse(b,sizeof(b));\\r\\nOPENSSL_cleanse(bb,sizeof(bb));\\r\\nOPENSSL_cleanse(cksum,sizeof(cksum));\\r\\nif (Exit) EXIT(Exit);\\r\\n}\\r\\nint uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp)\\r\\n{\\r\\nint i,j,left,rem,ret=num;\\r\\nstatic int start=1;\\r\\nif (start)\\r\\n{\\r\\nfprintf(fp,\"begin 600 %s\\n\",\\r\\n(uuname[0] == '\\0')?\"text.d\":uuname);\\r\\nstart=0;\\r\\n}\\r\\nif (uubufnum)\\r\\n{\\r\\nif (uubufnum+num < 45)\\r\\n{\\r\\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)num);\\r\\nuubufnum+=num;\\r\\nreturn(num);\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=45-uubufnum;\\r\\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)i);\\r\\nj=uuencode((unsigned char *)uubuf,45,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\nuubufnum=0;\\r\\ndata+=i;\\r\\nnum-=i;\\r\\n}\\r\\n}\\r\\nfor (i=0; i<(((int)num)-INUUBUFN); i+=INUUBUFN)\\r\\n{\\r\\nj=uuencode(&(data[i]),INUUBUFN,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\n}\\r\\nrem=(num-i)%45;\\r\\nleft=(num-i-rem);\\r\\nif (left)\\r\\n{\\r\\nj=uuencode(&(data[i]),left,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\ni+=left;\\r\\n}\\r\\nif (i != num)\\r\\n{\\r\\nmemcpy(uubuf,&(data[i]),(unsigned int)rem);\\r\\nuubufnum=rem;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid uufwriteEnd(FILE *fp)\\r\\n{\\r\\nint j;\\r\\nstatic const char *end=\" \\nend\\n\";\\r\\nif (uubufnum != 0)\\r\\n{\\r\\nuubuf[uubufnum]='\\0';\\r\\nuubuf[uubufnum+1]='\\0';\\r\\nuubuf[uubufnum+2]='\\0';\\r\\nj=uuencode(uubuf,uubufnum,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\n}\\r\\nfwrite(end,1,strlen(end),fp);\\r\\n}\\r\\nint uufread(unsigned char *out, int size, unsigned int num, FILE *fp)\\r\\n{\\r\\nint i,j,tot;\\r\\nstatic int done=0;\\r\\nstatic int valid=0;\\r\\nstatic int start=1;\\r\\nif (start)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nb[0]='\\0';\\r\\nfgets((char *)b,300,fp);\\r\\nif (b[0] == '\\0')\\r\\n{\\r\\nfprintf(stderr,\"no 'begin' found in uuencoded input\\n\");\\r\\nreturn(-1);\\r\\n}\\r\\nif (strncmp((char *)b,\"begin \",6) == 0) break;\\r\\n}\\r\\nstart=0;\\r\\n}\\r\\nif (done) return(0);\\r\\ntot=0;\\r\\nif (valid)\\r\\n{\\r\\nmemcpy(out,bb,(unsigned int)valid);\\r\\ntot=valid;\\r\\nvalid=0;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nb[0]='\\0';\\r\\nfgets((char *)b,300,fp);\\r\\nif (b[0] == '\\0') break;\\r\\ni=strlen((char *)b);\\r\\nif ((b[0] == 'e') && (b[1] == 'n') && (b[2] == 'd'))\\r\\n{\\r\\ndone=1;\\r\\nwhile (!feof(fp))\\r\\n{\\r\\nfgets((char *)b,300,fp);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\ni=uudecode(b,i,bb);\\r\\nif (i < 0) break;\\r\\nif ((i+tot+8) > num)\\r\\n{\\r\\nj=(num/8*8)-tot-8;\\r\\nmemcpy(&(out[tot]),bb,(unsigned int)j);\\r\\ntot+=j;\\r\\nmemcpy(bb,&(bb[j]),(unsigned int)i-j);\\r\\nvalid=i-j;\\r\\nbreak;\\r\\n}\\r\\nmemcpy(&(out[tot]),bb,(unsigned int)i);\\r\\ntot+=i;\\r\\n}\\r\\nreturn(tot);\\r\\n}\\r\\nint uuencode(unsigned char *in, int num, unsigned char *out)\\r\\n{\\r\\nint j,i,n,tot=0;\\r\\nDES_LONG l;\\r\\nregister unsigned char *p;\\r\\np=out;\\r\\nfor (j=0; j<num; j+=45)\\r\\n{\\r\\nif (j+45 > num)\\r\\ni=(num-j);\\r\\nelse i=45;\\r\\n*(p++)=i+' ';\\r\\nfor (n=0; n<i; n+=3)\\r\\n{\\r\\nccc2l(in,l);\\r\\n*(p++)=((l>>18)&0x3f)+' ';\\r\\n*(p++)=((l>>12)&0x3f)+' ';\\r\\n*(p++)=((l>> 6)&0x3f)+' ';\\r\\n*(p++)=((l )&0x3f)+' ';\\r\\ntot+=4;\\r\\n}\\r\\n*(p++)='\\n';\\r\\ntot+=2;\\r\\n}\\r\\n*p='\\0';\\r\\nl=0;\\r\\nreturn(tot);\\r\\n}\\r\\nint uudecode(unsigned char *in, int num, unsigned char *out)\\r\\n{\\r\\nint j,i,k;\\r\\nunsigned int n=0,space=0;\\r\\nDES_LONG l;\\r\\nDES_LONG w,x,y,z;\\r\\nunsigned int blank=(unsigned int)'\\n'-' ';\\r\\nfor (j=0; j<num; )\\r\\n{\\r\\nn= *(in++)-' ';\\r\\nif (n == blank)\\r\\n{\\r\\nn=0;\\r\\nin--;\\r\\n}\\r\\nif (n > 60)\\r\\n{\\r\\nfprintf(stderr,\"uuencoded line length too long\\n\");\\r\\nreturn(-1);\\r\\n}\\r\\nj++;\\r\\nfor (i=0; i<n; j+=4,i+=3)\\r\\n{\\r\\nif (space)\\r\\n{\\r\\nw=x=y=z=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nw= *(in++)-' ';\\r\\nx= *(in++)-' ';\\r\\ny= *(in++)-' ';\\r\\nz= *(in++)-' ';\\r\\n}\\r\\nif ((w > 63) || (x > 63) || (y > 63) || (z > 63))\\r\\n{\\r\\nk=0;\\r\\nif (w == blank) k=1;\\r\\nif (x == blank) k=2;\\r\\nif (y == blank) k=3;\\r\\nif (z == blank) k=4;\\r\\nspace=1;\\r\\nswitch (k) {\\r\\ncase 1: w=0; in--;\\r\\ncase 2: x=0; in--;\\r\\ncase 3: y=0; in--;\\r\\ncase 4: z=0; in--;\\r\\nbreak;\\r\\ncase 0:\\r\\nspace=0;\\r\\nfprintf(stderr,\"bad uuencoded data values\\n\");\\r\\nw=x=y=z=0;\\r\\nreturn(-1);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nl=(w<<18)|(x<<12)|(y<< 6)|(z );\\r\\nl2ccc(l,out);\\r\\n}\\r\\nif (*(in++) != '\\n')\\r\\n{\\r\\nfprintf(stderr,\"missing nl in uuencoded line\\n\");\\r\\nw=x=y=z=0;\\r\\nreturn(-1);\\r\\n}\\r\\nj++;\\r\\n}\\r\\n*out='\\0';\\r\\nw=x=y=z=0;\\r\\nreturn(n);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_sign_c", "target": 0, "func": "int RSA_sign(int type, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, RSA *rsa)\\r\\n{\\r\\nX509_SIG sig;\\r\\nASN1_TYPE parameter;\\r\\nint i,j,ret=1;\\r\\nunsigned char *p, *tmps = NULL;\\r\\nconst unsigned char *s = NULL;\\r\\nX509_ALGOR algor;\\r\\nASN1_OCTET_STRING digest;\\r\\nif((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_sign)\\r\\n{\\r\\nreturn rsa->meth->rsa_sign(type, m, m_len,\\r\\nsigret, siglen, rsa);\\r\\n}\\r\\nif(type == NID_md5_sha1) {\\r\\nif(m_len != SSL_SIG_LENGTH) {\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_INVALID_MESSAGE_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\ni = SSL_SIG_LENGTH;\\r\\ns = m;\\r\\n} else {\\r\\nsig.algor= &algor;\\r\\nsig.algor->algorithm=OBJ_nid2obj(type);\\r\\nif (sig.algor->algorithm == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_UNKNOWN_ALGORITHM_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (sig.algor->algorithm->length == 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\nreturn(0);\\r\\n}\\r\\nparameter.type=V_ASN1_NULL;\\r\\nparameter.value.ptr=NULL;\\r\\nsig.algor->parameter= &parameter;\\r\\nsig.digest= &digest;\\r\\nsig.digest->data=(unsigned char *)m;\\r\\nsig.digest->length=m_len;\\r\\ni=i2d_X509_SIG(&sig,NULL);\\r\\n}\\r\\nj=RSA_size(rsa);\\r\\nif (i > (j-RSA_PKCS1_PADDING_SIZE))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn(0);\\r\\n}\\r\\nif(type != NID_md5_sha1) {\\r\\ntmps=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);\\r\\nif (tmps == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=tmps;\\r\\ni2d_X509_SIG(&sig,&p);\\r\\ns=tmps;\\r\\n}\\r\\ni=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret=0;\\r\\nelse\\r\\n*siglen=i;\\r\\nif(type != NID_md5_sha1) {\\r\\nOPENSSL_cleanse(tmps,(unsigned int)j+1);\\r\\nOPENSSL_free(tmps);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigbuf, unsigned int siglen, RSA *rsa)\\r\\n{\\r\\nint i,ret=0,sigtype;\\r\\nunsigned char *s;\\r\\nX509_SIG *sig=NULL;\\r\\nif (siglen != (unsigned int)RSA_size(rsa))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\nif((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify)\\r\\n{\\r\\nreturn rsa->meth->rsa_verify(dtype, m, m_len,\\r\\nsigbuf, siglen, rsa);\\r\\n}\\r\\ns=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif((dtype == NID_md5_sha1) && (m_len != SSL_SIG_LENGTH) ) {\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_INVALID_MESSAGE_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0) goto err;\\r\\nif(dtype == NID_md5_sha1) {\\r\\nif((i != SSL_SIG_LENGTH) || memcmp(s, m, SSL_SIG_LENGTH))\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);\\r\\nelse ret = 1;\\r\\n} else {\\r\\nconst unsigned char *p=s;\\r\\nsig=d2i_X509_SIG(NULL,&p,(long)i);\\r\\nif (sig == NULL) goto err;\\r\\nsigtype=OBJ_obj2nid(sig->algor->algorithm);\\r\\n#ifdef RSA_DEBUG\\r\\nfprintf(stderr,\"in(%s) expect(%s)\\n\",OBJ_nid2ln(sigtype),\\r\\nOBJ_nid2ln(dtype));\\r\\n#endif\\r\\nif (sigtype != dtype)\\r\\n{\\r\\nif (((dtype == NID_md5) &&\\r\\n(sigtype == NID_md5WithRSAEncryption)) ||\\r\\n((dtype == NID_md2) &&\\r\\n(sigtype == NID_md2WithRSAEncryption)))\\r\\n{\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr,\"signature has problems, re-make with post SSLeay045\\n\");\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,\\r\\nRSA_R_ALGORITHM_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ( ((unsigned int)sig->digest->length != m_len) ||\\r\\n(memcmp(m,sig->digest->data,m_len) != 0))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\n}\\r\\nerr:\\r\\nif (sig != NULL) X509_SIG_free(sig);\\r\\nif (s != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(s,(unsigned int)siglen);\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_smime_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint operation = 0;\\r\\nint ret = 0;\\r\\nchar **args;\\r\\nconst char *inmode = \"r\", *outmode = \"w\";\\r\\nchar *infile = NULL, *outfile = NULL;\\r\\nchar *signerfile = NULL, *recipfile = NULL;\\r\\nchar *certfile = NULL, *keyfile = NULL, *contfile=NULL;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nX509_STORE *store = NULL;\\r\\nX509 *cert = NULL, *recip = NULL, *signer = NULL;\\r\\nEVP_PKEY *key = NULL;\\r\\nSTACK_OF(X509) *encerts = NULL, *other = NULL;\\r\\nBIO *in = NULL, *out = NULL, *indata = NULL;\\r\\nint badarg = 0;\\r\\nint flags = PKCS7_DETACHED;\\r\\nchar *to = NULL, *from = NULL, *subject = NULL;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nchar *inrand = NULL;\\r\\nint need_rand = 0;\\r\\nint informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\\r\\nint keyform = FORMAT_PEM;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nargs = argv + 1;\\r\\nret = 1;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\n{\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);\\r\\n}\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nwhile (!badarg && *args && *args[0] == '-')\\r\\n{\\r\\nif (!strcmp (*args, \"-encrypt\"))\\r\\noperation = SMIME_ENCRYPT;\\r\\nelse if (!strcmp (*args, \"-decrypt\"))\\r\\noperation = SMIME_DECRYPT;\\r\\nelse if (!strcmp (*args, \"-sign\"))\\r\\noperation = SMIME_SIGN;\\r\\nelse if (!strcmp (*args, \"-verify\"))\\r\\noperation = SMIME_VERIFY;\\r\\nelse if (!strcmp (*args, \"-pk7out\"))\\r\\noperation = SMIME_PK7OUT;\\r\\n#ifndef OPENSSL_NO_DES\\r\\nelse if (!strcmp (*args, \"-des3\"))\\r\\ncipher = EVP_des_ede3_cbc();\\r\\nelse if (!strcmp (*args, \"-des\"))\\r\\ncipher = EVP_des_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nelse if (!strcmp (*args, \"-rc2-40\"))\\r\\ncipher = EVP_rc2_40_cbc();\\r\\nelse if (!strcmp (*args, \"-rc2-128\"))\\r\\ncipher = EVP_rc2_cbc();\\r\\nelse if (!strcmp (*args, \"-rc2-64\"))\\r\\ncipher = EVP_rc2_64_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nelse if (!strcmp(*args,\"-aes128\"))\\r\\ncipher = EVP_aes_128_cbc();\\r\\nelse if (!strcmp(*args,\"-aes192\"))\\r\\ncipher = EVP_aes_192_cbc();\\r\\nelse if (!strcmp(*args,\"-aes256\"))\\r\\ncipher = EVP_aes_256_cbc();\\r\\n#endif\\r\\nelse if (!strcmp (*args, \"-text\"))\\r\\nflags |= PKCS7_TEXT;\\r\\nelse if (!strcmp (*args, \"-nointern\"))\\r\\nflags |= PKCS7_NOINTERN;\\r\\nelse if (!strcmp (*args, \"-noverify\"))\\r\\nflags |= PKCS7_NOVERIFY;\\r\\nelse if (!strcmp (*args, \"-nochain\"))\\r\\nflags |= PKCS7_NOCHAIN;\\r\\nelse if (!strcmp (*args, \"-nocerts\"))\\r\\nflags |= PKCS7_NOCERTS;\\r\\nelse if (!strcmp (*args, \"-noattr\"))\\r\\nflags |= PKCS7_NOATTR;\\r\\nelse if (!strcmp (*args, \"-nodetach\"))\\r\\nflags &= ~PKCS7_DETACHED;\\r\\nelse if (!strcmp (*args, \"-nosmimecap\"))\\r\\nflags |= PKCS7_NOSMIMECAP;\\r\\nelse if (!strcmp (*args, \"-binary\"))\\r\\nflags |= PKCS7_BINARY;\\r\\nelse if (!strcmp (*args, \"-nosigs\"))\\r\\nflags |= PKCS7_NOSIGS;\\r\\nelse if (!strcmp (*args, \"-nooldmime\"))\\r\\nflags |= PKCS7_NOOLDMIMETYPE;\\r\\nelse if (!strcmp (*args, \"-crlfeol\"))\\r\\nflags |= PKCS7_CRLFEOL;\\r\\nelse if (!strcmp(*args,\"-rand\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ninrand = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\nneed_rand = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (!strcmp(*args,\"-engine\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nengine = *args;\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*args,\"-passin\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\npassargin = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-to\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nto = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-from\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nfrom = *args;\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-subject\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nsubject = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-signer\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nsignerfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-recip\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nrecipfile = *args;\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-inkey\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nkeyfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-keyform\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nkeyform = str2fmt(*args);\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-certfile\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ncertfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-CAfile\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nCAfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-CApath\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\nCApath = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-in\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ninfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-inform\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ninformat = str2fmt(*args);\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-outform\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\noutformat = str2fmt(*args);\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-out\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\noutfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-content\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ncontfile = *args;\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (args_verify(&args, NULL, &badarg, bio_err, &vpm))\\r\\ncontinue;\\r\\nelse\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (operation == SMIME_SIGN)\\r\\n{\\r\\nif (!signerfile)\\r\\n{\\r\\nBIO_printf(bio_err, \"No signer certificate specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (operation == SMIME_DECRYPT)\\r\\n{\\r\\nif (!recipfile)\\r\\n{\\r\\nBIO_printf(bio_err, \"No recipient certificate and key specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\nelse if (operation == SMIME_ENCRYPT)\\r\\n{\\r\\nif (!*args)\\r\\n{\\r\\nBIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (!operation)\\r\\nbadarg = 1;\\r\\nif (badarg)\\r\\n{\\r\\nBIO_printf (bio_err, \"Usage smime [options] cert.pem ...\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-encrypt encrypt message\\n\");\\r\\nBIO_printf (bio_err, \"-decrypt decrypt encrypted message\\n\");\\r\\nBIO_printf (bio_err, \"-sign sign message\\n\");\\r\\nBIO_printf (bio_err, \"-verify verify signed message\\n\");\\r\\nBIO_printf (bio_err, \"-pk7out output PKCS#7 structure\\n\");\\r\\n#ifndef OPENSSL_NO_DES\\r\\nBIO_printf (bio_err, \"-des3 encrypt with triple DES\\n\");\\r\\nBIO_printf (bio_err, \"-des encrypt with DES\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nBIO_printf (bio_err, \"-rc2-40 encrypt with RC2-40 (default)\\n\");\\r\\nBIO_printf (bio_err, \"-rc2-64 encrypt with RC2-64\\n\");\\r\\nBIO_printf (bio_err, \"-rc2-128 encrypt with RC2-128\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf (bio_err, \"-aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf (bio_err, \" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\nBIO_printf (bio_err, \"-nointern don't search certificates in message for signer\\n\");\\r\\nBIO_printf (bio_err, \"-nosigs don't verify message signature\\n\");\\r\\nBIO_printf (bio_err, \"-noverify don't verify signers certificate\\n\");\\r\\nBIO_printf (bio_err, \"-nocerts don't include signers certificate when signing\\n\");\\r\\nBIO_printf (bio_err, \"-nodetach use opaque signing\\n\");\\r\\nBIO_printf (bio_err, \"-noattr don't include any signed attributes\\n\");\\r\\nBIO_printf (bio_err, \"-binary don't translate message to text\\n\");\\r\\nBIO_printf (bio_err, \"-certfile file other certificates file\\n\");\\r\\nBIO_printf (bio_err, \"-signer file signer certificate file\\n\");\\r\\nBIO_printf (bio_err, \"-recip file recipient certificate file for decryption\\n\");\\r\\nBIO_printf (bio_err, \"-in file input file\\n\");\\r\\nBIO_printf (bio_err, \"-inform arg input format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf (bio_err, \"-inkey file input private key (if not signer or recipient)\\n\");\\r\\nBIO_printf (bio_err, \"-keyform arg input private key format (PEM or ENGINE)\\n\");\\r\\nBIO_printf (bio_err, \"-out file output file\\n\");\\r\\nBIO_printf (bio_err, \"-outform arg output format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf (bio_err, \"-content file supply or override content for detached signature\\n\");\\r\\nBIO_printf (bio_err, \"-to addr to address\\n\");\\r\\nBIO_printf (bio_err, \"-from ad from address\\n\");\\r\\nBIO_printf (bio_err, \"-subject s subject\\n\");\\r\\nBIO_printf (bio_err, \"-text include or delete text MIME headers\\n\");\\r\\nBIO_printf (bio_err, \"-CApath dir trusted certificates directory\\n\");\\r\\nBIO_printf (bio_err, \"-CAfile file trusted certificates file\\n\");\\r\\nBIO_printf (bio_err, \"-crl_check check revocation status of signer's certificate using CRLs\\n\");\\r\\nBIO_printf (bio_err, \"-crl_check_all check revocation status of signer's certificate chain using CRLs\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf (bio_err, \"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf (bio_err, \"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf (bio_err, \"cert.pem recipient certificate(s) for encryption\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (need_rand)\\r\\n{\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nret = 2;\\r\\nif (operation != SMIME_SIGN)\\r\\nflags &= ~PKCS7_DETACHED;\\r\\nif (operation & SMIME_OP)\\r\\n{\\r\\nif (flags & PKCS7_BINARY)\\r\\ninmode = \"rb\";\\r\\nif (outformat == FORMAT_ASN1)\\r\\noutmode = \"wb\";\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (flags & PKCS7_BINARY)\\r\\noutmode = \"wb\";\\r\\nif (informat == FORMAT_ASN1)\\r\\ninmode = \"rb\";\\r\\n}\\r\\nif (operation == SMIME_ENCRYPT)\\r\\n{\\r\\nif (!cipher)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RC2\\r\\ncipher = EVP_rc2_40_cbc();\\r\\n#else\\r\\nBIO_printf(bio_err, \"No cipher selected\\n\");\\r\\ngoto end;\\r\\n#endif\\r\\n}\\r\\nencerts = sk_X509_new_null();\\r\\nwhile (*args)\\r\\n{\\r\\nif (!(cert = load_cert(bio_err,*args,FORMAT_PEM,\\r\\nNULL, e, \"recipient certificate file\")))\\r\\n{\\r\\n#if 0\\r\\nBIO_printf(bio_err, \"Can't read recipient certificate file %s\\n\", *args);\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_push(encerts, cert);\\r\\ncert = NULL;\\r\\nargs++;\\r\\n}\\r\\n}\\r\\nif (signerfile && (operation == SMIME_SIGN))\\r\\n{\\r\\nif (!(signer = load_cert(bio_err,signerfile,FORMAT_PEM, NULL,\\r\\ne, \"signer certificate\")))\\r\\n{\\r\\n#if 0\\r\\nBIO_printf(bio_err, \"Can't read signer certificate file %s\\n\", signerfile);\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (certfile)\\r\\n{\\r\\nif (!(other = load_certs(bio_err,certfile,FORMAT_PEM, NULL,\\r\\ne, \"certificate file\")))\\r\\n{\\r\\n#if 0\\r\\nBIO_printf(bio_err, \"Can't read certificate file %s\\n\", certfile);\\r\\n#endif\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (recipfile && (operation == SMIME_DECRYPT))\\r\\n{\\r\\nif (!(recip = load_cert(bio_err,recipfile,FORMAT_PEM,NULL,\\r\\ne, \"recipient certificate file\")))\\r\\n{\\r\\n#if 0\\r\\nBIO_printf(bio_err, \"Can't read recipient certificate file %s\\n\", recipfile);\\r\\n#endif\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (operation == SMIME_DECRYPT)\\r\\n{\\r\\nif (!keyfile)\\r\\nkeyfile = recipfile;\\r\\n}\\r\\nelse if (operation == SMIME_SIGN)\\r\\n{\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\n}\\r\\nelse keyfile = NULL;\\r\\nif (keyfile)\\r\\n{\\r\\nkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"signing key file\");\\r\\nif (!key)\\r\\ngoto end;\\r\\n}\\r\\nif (infile)\\r\\n{\\r\\nif (!(in = BIO_new_file(infile, inmode)))\\r\\n{\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile)\\r\\n{\\r\\nif (!(out = BIO_new_file(outfile, outmode)))\\r\\n{\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (operation == SMIME_VERIFY)\\r\\n{\\r\\nif (!(store = setup_verify(bio_err, CAfile, CApath)))\\r\\ngoto end;\\r\\nX509_STORE_set_verify_cb_func(store, smime_cb);\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(store, vpm);\\r\\n}\\r\\nret = 3;\\r\\nif (operation == SMIME_ENCRYPT)\\r\\np7 = PKCS7_encrypt(encerts, in, cipher, flags);\\r\\nelse if (operation == SMIME_SIGN)\\r\\n{\\r\\nif ((flags & PKCS7_DETACHED) && (outformat == FORMAT_SMIME))\\r\\nflags |= PKCS7_STREAM;\\r\\np7 = PKCS7_sign(signer, key, other, in, flags);\\r\\nif (!(flags & PKCS7_STREAM) && (BIO_reset(in) != 0))\\r\\n{\\r\\nBIO_printf(bio_err, \"Can't rewind input file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (informat == FORMAT_SMIME)\\r\\np7 = SMIME_read_PKCS7(in, &indata);\\r\\nelse if (informat == FORMAT_PEM)\\r\\np7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np7 = d2i_PKCS7_bio(in, NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad input format for PKCS#7 file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!p7)\\r\\n{\\r\\nBIO_printf(bio_err, \"Error reading S/MIME message\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (contfile)\\r\\n{\\r\\nBIO_free(indata);\\r\\nif (!(indata = BIO_new_file(contfile, \"rb\")))\\r\\n{\\r\\nBIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!p7)\\r\\n{\\r\\nBIO_printf(bio_err, \"Error creating PKCS#7 structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 4;\\r\\nif (operation == SMIME_DECRYPT)\\r\\n{\\r\\nif (!PKCS7_decrypt(p7, key, recip, out, flags))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error decrypting PKCS#7 structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (operation == SMIME_VERIFY)\\r\\n{\\r\\nSTACK_OF(X509) *signers;\\r\\nif (PKCS7_verify(p7, other, store, indata, out, flags))\\r\\nBIO_printf(bio_err, \"Verification successful\\n\");\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Verification failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nsigners = PKCS7_get0_signers(p7, other, flags);\\r\\nif (!save_certs(signerfile, signers))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error writing signers to %s\\n\",\\r\\nsignerfile);\\r\\nret = 5;\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_free(signers);\\r\\n}\\r\\nelse if (operation == SMIME_PK7OUT)\\r\\nPEM_write_bio_PKCS7(out, p7);\\r\\nelse\\r\\n{\\r\\nif (to)\\r\\nBIO_printf(out, \"To: %s\\n\", to);\\r\\nif (from)\\r\\nBIO_printf(out, \"From: %s\\n\", from);\\r\\nif (subject)\\r\\nBIO_printf(out, \"Subject: %s\\n\", subject);\\r\\nif (outformat == FORMAT_SMIME)\\r\\nSMIME_write_PKCS7(out, p7, in, flags);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS7(out,p7);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS7_bio(out,p7);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad output format for PKCS#7 file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (ret) ERR_print_errors(bio_err);\\r\\nsk_X509_pop_free(encerts, X509_free);\\r\\nsk_X509_pop_free(other, X509_free);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nX509_STORE_free(store);\\r\\nX509_free(cert);\\r\\nX509_free(recip);\\r\\nX509_free(signer);\\r\\nEVP_PKEY_free(key);\\r\\nPKCS7_free(p7);\\r\\nBIO_free(in);\\r\\nBIO_free(indata);\\r\\nBIO_free_all(out);\\r\\nif (passin) OPENSSL_free(passin);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int smime_cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint error;\\r\\nerror = X509_STORE_CTX_get_error(ctx);\\r\\nif ((error != X509_V_ERR_NO_EXPLICIT_POLICY)\\r\\n&& ((error != X509_V_OK) || (ok != 2)))\\r\\nreturn ok;\\r\\npolicies_print(NULL, ctx);\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_ossl_c", "target": 0, "func": "const DSA_METHOD *DSA_OpenSSL(void)\\r\\n{\\r\\nreturn &openssl_dsa_meth;\\r\\n}\\r\\nstatic DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nBIGNUM *kinv=NULL,*r=NULL,*s=NULL;\\r\\nBIGNUM m;\\r\\nBIGNUM xr;\\r\\nBN_CTX *ctx=NULL;\\r\\nint i,reason=ERR_R_BN_LIB;\\r\\nDSA_SIG *ret=NULL;\\r\\nBN_init(&m);\\r\\nBN_init(&xr);\\r\\nif (!dsa->p || !dsa->q || !dsa->g)\\r\\n{\\r\\nreason=DSA_R_MISSING_PARAMETERS;\\r\\ngoto err;\\r\\n}\\r\\ns=BN_new();\\r\\nif (s == NULL) goto err;\\r\\ni=BN_num_bytes(dsa->q);\\r\\nif ((dlen > i) || (dlen > 50))\\r\\n{\\r\\nreason=DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;\\r\\ngoto err;\\r\\n}\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nif ((dsa->kinv == NULL) || (dsa->r == NULL))\\r\\n{\\r\\nif (!DSA_sign_setup(dsa,ctx,&kinv,&r)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nkinv=dsa->kinv;\\r\\ndsa->kinv=NULL;\\r\\nr=dsa->r;\\r\\ndsa->r=NULL;\\r\\n}\\r\\nif (BN_bin2bn(dgst,dlen,&m) == NULL) goto err;\\r\\nif (!BN_mod_mul(&xr,dsa->priv_key,r,dsa->q,ctx)) goto err;\\r\\nif (!BN_add(s, &xr, &m)) goto err;\\r\\nif (BN_cmp(s,dsa->q) > 0)\\r\\nBN_sub(s,s,dsa->q);\\r\\nif (!BN_mod_mul(s,s,kinv,dsa->q,ctx)) goto err;\\r\\nret=DSA_SIG_new();\\r\\nif (ret == NULL) goto err;\\r\\nret->r = r;\\r\\nret->s = s;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_DO_SIGN,reason);\\r\\nBN_free(r);\\r\\nBN_free(s);\\r\\n}\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&m);\\r\\nBN_clear_free(&xr);\\r\\nif (kinv != NULL)\\r\\nBN_clear_free(kinv);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM k,kq,*K,*kinv=NULL,*r=NULL;\\r\\nint ret=0;\\r\\nif (!dsa->p || !dsa->q || !dsa->g)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP,DSA_R_MISSING_PARAMETERS);\\r\\nreturn 0;\\r\\n}\\r\\nBN_init(&k);\\r\\nBN_init(&kq);\\r\\nif (ctx_in == NULL)\\r\\n{\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nctx=ctx_in;\\r\\nif ((r=BN_new()) == NULL) goto err;\\r\\ndo\\r\\nif (!BN_rand_range(&k, dsa->q)) goto err;\\r\\nwhile (BN_is_zero(&k));\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)\\r\\n{\\r\\nBN_set_flags(&k, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P)\\r\\n{\\r\\nif (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\\r\\nCRYPTO_LOCK_DSA,\\r\\ndsa->p, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)\\r\\n{\\r\\nif (!BN_copy(&kq, &k)) goto err;\\r\\nif (!BN_add(&kq, &kq, dsa->q)) goto err;\\r\\nif (BN_num_bits(&kq) <= BN_num_bits(dsa->q))\\r\\n{\\r\\nif (!BN_add(&kq, &kq, dsa->q)) goto err;\\r\\n}\\r\\nK = &kq;\\r\\n}\\r\\nelse\\r\\n{\\r\\nK = &k;\\r\\n}\\r\\nDSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\\r\\ndsa->method_mont_p);\\r\\nif (!BN_mod(r,r,dsa->q,ctx)) goto err;\\r\\nif ((kinv=BN_mod_inverse(NULL,&k,dsa->q,ctx)) == NULL) goto err;\\r\\nif (*kinvp != NULL) BN_clear_free(*kinvp);\\r\\n*kinvp=kinv;\\r\\nkinv=NULL;\\r\\nif (*rp != NULL) BN_clear_free(*rp);\\r\\n*rp=r;\\r\\nret=1;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP,ERR_R_BN_LIB);\\r\\nif (kinv != NULL) BN_clear_free(kinv);\\r\\nif (r != NULL) BN_clear_free(r);\\r\\n}\\r\\nif (ctx_in == NULL) BN_CTX_free(ctx);\\r\\nif (kinv != NULL) BN_clear_free(kinv);\\r\\nBN_clear_free(&k);\\r\\nBN_clear_free(&kq);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dsa_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,\\r\\nDSA *dsa)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM u1,u2,t1;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nint ret = -1;\\r\\nif (!dsa->p || !dsa->q || !dsa->g)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY,DSA_R_MISSING_PARAMETERS);\\r\\nreturn -1;\\r\\n}\\r\\nBN_init(&u1);\\r\\nBN_init(&u2);\\r\\nBN_init(&t1);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||\\r\\nBN_ucmp(sig->r, dsa->q) >= 0)\\r\\n{\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||\\r\\nBN_ucmp(sig->s, dsa->q) >= 0)\\r\\n{\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif ((BN_mod_inverse(&u2,sig->s,dsa->q,ctx)) == NULL) goto err;\\r\\nif (BN_bin2bn(dgst,dgst_len,&u1) == NULL) goto err;\\r\\nif (!BN_mod_mul(&u1,&u1,&u2,dsa->q,ctx)) goto err;\\r\\nif (!BN_mod_mul(&u2,sig->r,&u2,dsa->q,ctx)) goto err;\\r\\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P)\\r\\n{\\r\\nmont = BN_MONT_CTX_set_locked(&dsa->method_mont_p,\\r\\nCRYPTO_LOCK_DSA, dsa->p, ctx);\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nDSA_MOD_EXP(goto err, dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p, ctx, mont);\\r\\nif (!BN_mod(&u1,&t1,dsa->q,ctx)) goto err;\\r\\nret=(BN_ucmp(&u1, sig->r) == 0);\\r\\nerr:\\r\\nif (ret != 1) DSAerr(DSA_F_DSA_DO_VERIFY,ERR_R_BN_LIB);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_free(&u1);\\r\\nBN_free(&u2);\\r\\nBN_free(&t1);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dsa_init(DSA *dsa)\\r\\n{\\r\\ndsa->flags|=DSA_FLAG_CACHE_MONT_P;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int dsa_finish(DSA *dsa)\\r\\n{\\r\\nif(dsa->method_mont_p)\\r\\nBN_MONT_CTX_free(dsa->method_mont_p);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_clnt_c", "target": 0, "func": "static SSL_METHOD *ssl3_get_client_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_client_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv3_client_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_client_data.ssl_connect=ssl3_connect;\\r\\nSSLv3_client_data.get_ssl_method=ssl3_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv3_client_data);\\r\\n}\\r\\nint ssl3_connect(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf=NULL;\\r\\nunsigned long Time=time(NULL),l;\\r\\nlong num1;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ns->state=SSL_ST_CONNECT;\\r\\ns->ctx->stats.sess_connect_renegotiate++;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version & 0xff00 ) != 0x0300)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\\r\\nret = -1;\\r\\ngoto end;\\r\\n}\\r\\ns->type=SSL_ST_CONNECT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\nbuf=NULL;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\\r\\nif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A:\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl3_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nif (s->bbio != s->wbio)\\r\\ns->wbio=BIO_push(s->bbio,s->wbio);\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A:\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B:\\r\\nret=ssl3_get_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CR_FINISHED_A;\\r\\nelse\\r\\ns->state=SSL3_ST_CR_CERT_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_A:\\r\\ncase SSL3_ST_CR_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=ssl3_get_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_CR_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A:\\r\\ncase SSL3_ST_CR_KEY_EXCH_B:\\r\\nret=ssl3_get_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nif (!ssl3_check_cert_and_algorithm(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_A:\\r\\ncase SSL3_ST_CR_CERT_REQ_B:\\r\\nret=ssl3_get_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_SRVR_DONE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A:\\r\\ncase SSL3_ST_CR_SRVR_DONE_B:\\r\\nret=ssl3_get_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->s3->tmp.cert_req)\\r\\ns->state=SSL3_ST_CW_CERT_A;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_A:\\r\\ncase SSL3_ST_CW_CERT_B:\\r\\ncase SSL3_ST_CW_CERT_C:\\r\\ncase SSL3_ST_CW_CERT_D:\\r\\nret=ssl3_send_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A:\\r\\ncase SSL3_ST_CW_KEY_EXCH_B:\\r\\nret=ssl3_send_client_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (s->s3->tmp.cert_req == 1)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_VRFY_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->s3->change_cipher_spec=0;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A:\\r\\ncase SSL3_ST_CW_CERT_VRFY_B:\\r\\nret=ssl3_send_client_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->init_num=0;\\r\\ns->s3->change_cipher_spec=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\nret=ssl3_send_change_cipher_spec(s,\\r\\nSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FINISHED_A;\\r\\ns->init_num=0;\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ns->session->compress_meth=0;\\r\\nelse\\r\\ns->session->compress_meth=\\r\\ns->s3->tmp.new_compression->id;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_CLIENT_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\nret=ssl3_send_finished(s,\\r\\nSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\\r\\ns->method->ssl3_enc->client_finished_label,\\r\\ns->method->ssl3_enc->client_finished_label_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FLUSH;\\r\\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\\r\\nif (s->hit)\\r\\n{\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\nif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\\r\\n{\\r\\ns->state=SSL_ST_OK;\\r\\ns->s3->flags|=SSL3_FLAGS_POP_BUFFER;\\r\\ns->s3->delay_buf_pop_ret=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\\r\\nSSL3_ST_CR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\nif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_num=0;\\r\\ns->new_session=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\\r\\nif (s->hit) s->ctx->stats.sess_hit++;\\r\\nret=1;\\r\\ns->handshake_func=ssl3_connect;\\r\\ns->ctx->stats.sess_connect_good++;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,j;\\r\\nunsigned long Time,l;\\r\\nSSL_COMP *comp;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL3_ST_CW_CLNT_HELLO_A)\\r\\n{\\r\\nif ((s->session == NULL) ||\\r\\n(s->session->ssl_version != s->version) ||\\r\\n(s->session->not_resumable))\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\ngoto err;\\r\\n}\\r\\np=s->s3->client_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nif (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)\\r\\ngoto err;\\r\\nd=p= &(buf[4]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\ns->client_version=s->version;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (s->new_session)\\r\\ni=0;\\r\\nelse\\r\\ni=s->session->session_id_length;\\r\\n*(p++)=i;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i > (int)sizeof(s->session->session_id))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(p,s->session->session_id,i);\\r\\np+=i;\\r\\n}\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\np+=i;\\r\\nif (s->ctx->comp_methods == NULL)\\r\\nj=0;\\r\\nelse\\r\\nj=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\n*(p++)=1+j;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,i);\\r\\n*(p++)=comp->id;\\r\\n}\\r\\n*(p++)=0;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\n*(d++)=SSL3_MT_CLIENT_HELLO;\\r\\nl2n3(l,d);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_get_server_hello(SSL *s)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nunsigned char *p,*d;\\r\\nint i,al,ok;\\r\\nunsigned int j;\\r\\nlong n;\\r\\nSSL_COMP *comp;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_CR_SRVR_HELLO_A,\\r\\nSSL3_ST_CR_SRVR_HELLO_B,\\r\\n-1,\\r\\n300,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif ( SSL_version(s) == DTLS1_VERSION)\\r\\n{\\r\\nif ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)\\r\\n{\\r\\nif ( s->d1->send_cookie == 0)\\r\\n{\\r\\ns->s3->tmp.reuse_message = 1;\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nd=p=(unsigned char *)s->init_msg;\\r\\nif ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);\\r\\ns->version=(s->version&0xff00)|p[1];\\r\\nal=SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\np+=2;\\r\\nmemcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nj= *(p++);\\r\\nif ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nif (j != 0 && j == s->session->session_id_length\\r\\n&& memcmp(p,s->session->session_id,j) == 0)\\r\\n{\\r\\nif(s->sid_ctx_length != s->session->sid_ctx_length\\r\\n|| memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\\r\\ngoto f_err;\\r\\n}\\r\\ns->hit=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->hit=0;\\r\\nif (s->session->session_id_length > 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nal=SSL_AD_INTERNAL_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\ns->session->session_id_length=j;\\r\\nmemcpy(s->session->session_id,p,j);\\r\\n}\\r\\np+=j;\\r\\nc=ssl_get_cipher_by_char(s,p);\\r\\nif (c == NULL)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\np+=ssl_put_cipher_by_char(s,NULL,NULL);\\r\\nsk=ssl_get_ciphers_by_id(s);\\r\\ni=sk_SSL_CIPHER_find(sk,c);\\r\\nif (i < 0)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->session->cipher)\\r\\ns->session->cipher_id = s->session->cipher->id;\\r\\nif (s->hit && (s->session->cipher_id != c->id))\\r\\n{\\r\\nif (!(s->options &\\r\\nSSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\ns->s3->tmp.new_cipher=c;\\r\\nj= *(p++);\\r\\nif (j == 0)\\r\\ncomp=NULL;\\r\\nelse\\r\\ncomp=ssl3_comp_find(s->ctx->comp_methods,j);\\r\\nif ((j != 0) && (comp == NULL))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.new_compression=comp;\\r\\n}\\r\\nif (p != (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_get_server_certificate(SSL *s)\\r\\n{\\r\\nint al,i,ok,ret= -1;\\r\\nunsigned long n,nc,llen,l;\\r\\nX509 *x=NULL;\\r\\nconst unsigned char *q,*p;\\r\\nunsigned char *d;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nSESS_CERT *sc;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint need_cert = 1;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_CR_CERT_A,\\r\\nSSL3_ST_CR_CERT_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_BAD_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\np=d=(unsigned char *)s->init_msg;\\r\\nif ((sk=sk_X509_new_null()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2l3(p,llen);\\r\\nif (llen+3 != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2l3(p,l);\\r\\nif ((l+nc+3) > llen)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nq=p;\\r\\nx=d2i_X509(NULL,&q,l);\\r\\nif (x == NULL)\\r\\n{\\r\\nal=SSL_AD_BAD_CERTIFICATE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_ASN1_LIB);\\r\\ngoto f_err;\\r\\n}\\r\\nif (q != (p+l))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!sk_X509_push(sk,x))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nx=NULL;\\r\\nnc+=l+3;\\r\\np=q;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif ((s->verify_mode != SSL_VERIFY_NONE) && (!i)\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\n&& (s->s3->tmp.new_cipher->algorithms & (SSL_MKEY_MASK|SSL_AUTH_MASK))\\r\\n!= (SSL_aKRB5|SSL_kKRB5)\\r\\n#endif\\r\\n)\\r\\n{\\r\\nal=ssl_verify_alarm_type(s->verify_result);\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);\\r\\ngoto f_err;\\r\\n}\\r\\nERR_clear_error();\\r\\nsc=ssl_sess_cert_new();\\r\\nif (sc == NULL) goto err;\\r\\nif (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=sc;\\r\\nsc->cert_chain=sk;\\r\\nx=sk_X509_value(sk,0);\\r\\nsk=NULL;\\r\\npkey=X509_get_pubkey(x);\\r\\nneed_cert = ((s->s3->tmp.new_cipher->algorithms\\r\\n& (SSL_MKEY_MASK|SSL_AUTH_MASK))\\r\\n== (SSL_aKRB5|SSL_kKRB5))? 0: 1;\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"pkey,x = %p, %p\\n\", pkey,x);\\r\\nprintf(\"ssl_cert_type(x,pkey) = %d\\n\", ssl_cert_type(x,pkey));\\r\\nprintf(\"cipher, alg, nc = %s, %lx, %d\\n\", s->s3->tmp.new_cipher->name,\\r\\ns->s3->tmp.new_cipher->algorithms, need_cert);\\r\\n#endif\\r\\nif (need_cert && ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey)))\\r\\n{\\r\\nx=NULL;\\r\\nal=SSL3_AL_FATAL;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\\r\\nSSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\\r\\ngoto f_err;\\r\\n}\\r\\ni=ssl_cert_type(x,pkey);\\r\\nif (need_cert && i < 0)\\r\\n{\\r\\nx=NULL;\\r\\nal=SSL3_AL_FATAL;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\\r\\nSSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (need_cert)\\r\\n{\\r\\nsc->peer_cert_type=i;\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\nif (sc->peer_pkeys[i].x509 != NULL)\\r\\nX509_free(sc->peer_pkeys[i].x509);\\r\\nsc->peer_pkeys[i].x509=x;\\r\\nsc->peer_key= &(sc->peer_pkeys[i]);\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\ns->session->peer=x;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsc->peer_cert_type=i;\\r\\nsc->peer_key= NULL;\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\ns->session->peer=NULL;\\r\\n}\\r\\ns->session->verify_result = s->verify_result;\\r\\nx=NULL;\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nEVP_PKEY_free(pkey);\\r\\nX509_free(x);\\r\\nsk_X509_pop_free(sk,X509_free);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_get_key_exchange(SSL *s)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\\r\\n#endif\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned char *param,*p;\\r\\nint al,i,j,param_len,ok;\\r\\nlong n,alg;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rsa=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nDH *dh=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nEC_KEY *ecdh = NULL;\\r\\nBN_CTX *bn_ctx = NULL;\\r\\nEC_POINT *srvr_ecpoint = NULL;\\r\\nint curve_nid = 0;\\r\\nint encoded_pt_len = 0;\\r\\n#endif\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_CR_KEY_EXCH_A,\\r\\nSSL3_ST_CR_KEY_EXCH_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nparam=p=(unsigned char *)s->init_msg;\\r\\nif (s->session->sess_cert != NULL)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (s->session->sess_cert->peer_rsa_tmp != NULL)\\r\\n{\\r\\nRSA_free(s->session->sess_cert->peer_rsa_tmp);\\r\\ns->session->sess_cert->peer_rsa_tmp=NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->session->sess_cert->peer_dh_tmp)\\r\\n{\\r\\nDH_free(s->session->sess_cert->peer_dh_tmp);\\r\\ns->session->sess_cert->peer_dh_tmp=NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (s->session->sess_cert->peer_ecdh_tmp)\\r\\n{\\r\\nEC_KEY_free(s->session->sess_cert->peer_ecdh_tmp);\\r\\ns->session->sess_cert->peer_ecdh_tmp=NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->session->sess_cert=ssl_sess_cert_new();\\r\\n}\\r\\nparam_len=0;\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (alg & SSL_kRSA)\\r\\n{\\r\\nif ((rsa=RSA_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2s(p,i);\\r\\nparam_len=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn-=param_len;\\r\\nif (alg & SSL_aRSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ns->session->sess_cert->peer_rsa_tmp=rsa;\\r\\nrsa=NULL;\\r\\n}\\r\\n#else\\r\\nif (0)\\r\\n;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nelse if (alg & SSL_kEDH)\\r\\n{\\r\\nif ((dh=DH_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nn2s(p,i);\\r\\nparam_len=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->p=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->g=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn-=param_len;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (alg & SSL_aRSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\n#else\\r\\nif (0)\\r\\n;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nelse if (alg & SSL_aDSS)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\\r\\n#endif\\r\\ns->session->sess_cert->peer_dh_tmp=dh;\\r\\ndh=NULL;\\r\\n}\\r\\nelse if ((alg & SSL_kDHr) || (alg & SSL_kDHd))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nelse if (alg & SSL_kECDHE)\\r\\n{\\r\\nEC_GROUP *ngroup;\\r\\nconst EC_GROUP *group;\\r\\nif ((ecdh=EC_KEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nparam_len=2;\\r\\nif ((param_len > n) ||\\r\\n(*p != NAMED_CURVE_TYPE) ||\\r\\n((curve_nid = curve_id2nid(*(p + 1))) == 0))\\r\\n{\\r\\nal=SSL_AD_INTERNAL_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS);\\r\\ngoto f_err;\\r\\n}\\r\\nngroup = EC_GROUP_new_by_curve_name(curve_nid);\\r\\nif (ngroup == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_KEY_set_group(ecdh, ngroup) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nEC_GROUP_free(ngroup);\\r\\ngroup = EC_KEY_get0_group(ecdh);\\r\\nif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\\r\\n(EC_GROUP_get_degree(group) > 163))\\r\\n{\\r\\nal=SSL_AD_EXPORT_RESTRICTION;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\np+=2;\\r\\nif (((srvr_ecpoint = EC_POINT_new(group)) == NULL) ||\\r\\n((bn_ctx = BN_CTX_new()) == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nencoded_pt_len = *p;\\r\\np+=1;\\r\\nparam_len += (1 + encoded_pt_len);\\r\\nif ((param_len > n) ||\\r\\n(EC_POINT_oct2point(group, srvr_ecpoint,\\r\\np, encoded_pt_len, bn_ctx) == 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_ECPOINT);\\r\\ngoto f_err;\\r\\n}\\r\\nn-=param_len;\\r\\np+=encoded_pt_len;\\r\\nif (0) ;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (alg & SSL_aRSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nelse if (alg & SSL_aECDSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\\r\\n#endif\\r\\nEC_KEY_set_public_key(ecdh, srvr_ecpoint);\\r\\ns->session->sess_cert->peer_ecdh_tmp=ecdh;\\r\\necdh=NULL;\\r\\nBN_CTX_free(bn_ctx);\\r\\nEC_POINT_free(srvr_ecpoint);\\r\\nsrvr_ecpoint = NULL;\\r\\n}\\r\\nelse if (alg & SSL_kECDH)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\nif (alg & SSL_aFZA)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\nif (pkey != NULL)\\r\\n{\\r\\nn2s(p,i);\\r\\nn-=2;\\r\\nj=EVP_PKEY_size(pkey);\\r\\nif ((i != n) || (n > j) || (n <= 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nint num;\\r\\nj=0;\\r\\nq=md_buf;\\r\\nfor (num=2; num > 0; num--)\\r\\n{\\r\\nEVP_DigestInit_ex(&md_ctx,(num == 2)\\r\\n?s->ctx->md5:s->ctx->sha1, NULL);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,param,param_len);\\r\\nEVP_DigestFinal_ex(&md_ctx,q,(unsigned int *)&i);\\r\\nq+=i;\\r\\nj+=i;\\r\\n}\\r\\ni=RSA_verify(NID_md5_sha1, md_buf, j, p, n,\\r\\npkey->pkey.rsa);\\r\\nif (i < 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\\r\\ngoto f_err;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nEVP_VerifyInit_ex(&md_ctx,EVP_dss1(), NULL);\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,param,param_len);\\r\\nif (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nEVP_VerifyInit_ex(&md_ctx,EVP_ecdsa(), NULL);\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,param,param_len);\\r\\nif (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(alg & SSL_aNULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (n != 0)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nEVP_PKEY_free(pkey);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (rsa != NULL)\\r\\nRSA_free(rsa);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (dh != NULL)\\r\\nDH_free(dh);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBN_CTX_free(bn_ctx);\\r\\nEC_POINT_free(srvr_ecpoint);\\r\\nif (ecdh != NULL)\\r\\nEC_KEY_free(ecdh);\\r\\n#endif\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_get_certificate_request(SSL *s)\\r\\n{\\r\\nint ok,ret=0;\\r\\nunsigned long n,nc,l;\\r\\nunsigned int llen,ctype_num,i;\\r\\nX509_NAME *xn=NULL;\\r\\nconst unsigned char *p,*q;\\r\\nunsigned char *d;\\r\\nSTACK_OF(X509_NAME) *ca_sk=NULL;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_CR_CERT_REQ_A,\\r\\nSSL3_ST_CR_CERT_REQ_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\ns->s3->tmp.cert_req=0;\\r\\nif (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_WRONG_MESSAGE_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (l & SSL_aNULL)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\np=d=(unsigned char *)s->init_msg;\\r\\nif ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nctype_num= *(p++);\\r\\nif (ctype_num > SSL3_CT_NUMBER)\\r\\nctype_num=SSL3_CT_NUMBER;\\r\\nfor (i=0; i<ctype_num; i++)\\r\\ns->s3->tmp.ctype[i]= p[i];\\r\\np+=ctype_num;\\r\\nn2s(p,llen);\\r\\n#if 0\\r\\n{\\r\\nFILE *out;\\r\\nout=fopen(\"/tmp/vsign.der\",\"w\");\\r\\nfwrite(p,1,llen,out);\\r\\nfclose(out);\\r\\n}\\r\\n#endif\\r\\nif ((llen+ctype_num+2+1) != n)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2s(p,l);\\r\\nif ((l+nc+2) > llen)\\r\\n{\\r\\nif ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\\r\\ngoto cont;\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nq=p;\\r\\nif ((xn=d2i_X509_NAME(NULL,&q,l)) == NULL)\\r\\n{\\r\\nif (s->options & SSL_OP_NETSCAPE_CA_DN_BUG)\\r\\ngoto cont;\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (q != (p+l))\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_X509_NAME_push(ca_sk,xn))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np+=l;\\r\\nnc+=l+2;\\r\\n}\\r\\nif (0)\\r\\n{\\r\\ncont:\\r\\nERR_clear_error();\\r\\n}\\r\\ns->s3->tmp.cert_req=1;\\r\\ns->s3->tmp.ctype_num=ctype_num;\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\ns->s3->tmp.ca_names=ca_sk;\\r\\nca_sk=NULL;\\r\\nret=1;\\r\\nerr:\\r\\nif (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ca_dn_cmp(const X509_NAME * const *a, const X509_NAME * const *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(*a,*b));\\r\\n}\\r\\nint ssl3_get_server_done(SSL *s)\\r\\n{\\r\\nint ok,ret=0;\\r\\nlong n;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_CR_SRVR_DONE_A,\\r\\nSSL3_ST_CR_SRVR_DONE_B,\\r\\nSSL3_MT_SERVER_DONE,\\r\\n30,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (n > 0)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_DONE,SSL_R_LENGTH_MISMATCH);\\r\\nreturn -1;\\r\\n}\\r\\nret=1;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nif (*outlen < SHA_DIGEST_LENGTH)\\r\\nreturn NULL;\\r\\nelse\\r\\n*outlen = SHA_DIGEST_LENGTH;\\r\\nreturn SHA1(in, inlen, out);\\r\\n#else\\r\\nreturn NULL;\\r\\n#endif\\r\\n}\\r\\nint ssl3_send_client_key_exchange(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint n;\\r\\nunsigned long l;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned char *q;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_ERR kssl_err;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nEC_KEY *clnt_ecdh = NULL;\\r\\nconst EC_POINT *srvr_ecpoint = NULL;\\r\\nEVP_PKEY *srvr_pub_pkey = NULL;\\r\\nunsigned char *encodedPoint = NULL;\\r\\nint encoded_pt_len = 0;\\r\\nBN_CTX * bn_ctx = NULL;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_KEY_EXCH_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (0) {}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (l & SSL_kRSA)\\r\\n{\\r\\nRSA *rsa;\\r\\nunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nif (s->session->sess_cert->peer_rsa_tmp != NULL)\\r\\nrsa=s->session->sess_cert->peer_rsa_tmp;\\r\\nelse\\r\\n{\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nif ((pkey == NULL) ||\\r\\n(pkey->type != EVP_PKEY_RSA) ||\\r\\n(pkey->pkey.rsa == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nrsa=pkey->pkey.rsa;\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\ntmp_buf[0]=s->client_version>>8;\\r\\ntmp_buf[1]=s->client_version&0xff;\\r\\nif (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\\r\\ngoto err;\\r\\ns->session->master_key_length=sizeof tmp_buf;\\r\\nq=p;\\r\\nif (s->version > SSL3_VERSION)\\r\\np+=2;\\r\\nn=RSA_public_encrypt(sizeof tmp_buf,\\r\\ntmp_buf,p,rsa,RSA_PKCS1_PADDING);\\r\\n#ifdef PKCS1_CHECK\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\\r\\n#endif\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\\r\\ngoto err;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\ns2n(n,q);\\r\\nn+=2;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\ntmp_buf,sizeof tmp_buf);\\r\\nOPENSSL_cleanse(tmp_buf,sizeof tmp_buf);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nelse if (l & SSL_kKRB5)\\r\\n{\\r\\nkrb5_error_code krb5rc;\\r\\nKSSL_CTX *kssl_ctx = s->kssl_ctx;\\r\\nkrb5_data *enc_ticket;\\r\\nkrb5_data authenticator, *authp = NULL;\\r\\nEVP_CIPHER_CTX ciph_ctx;\\r\\nEVP_CIPHER *enc = NULL;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nunsigned char epms[SSL_MAX_MASTER_KEY_LENGTH\\r\\n+ EVP_MAX_IV_LENGTH];\\r\\nint padl, outl = sizeof(epms);\\r\\nEVP_CIPHER_CTX_init(&ciph_ctx);\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"ssl3_send_client_key_exchange(%lx & %lx)\\n\",\\r\\nl, SSL_kKRB5);\\r\\n#endif\\r\\nauthp = NULL;\\r\\n#ifdef KRB5SENDAUTH\\r\\nif (KRB5SENDAUTH) authp = &authenticator;\\r\\n#endif\\r\\nkrb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,\\r\\n&kssl_err);\\r\\nenc = kssl_map_enc(kssl_ctx->enctype);\\r\\nif (enc == NULL)\\r\\ngoto err;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nprintf(\"kssl_cget_tkt rtn %d\\n\", krb5rc);\\r\\nif (krb5rc && kssl_err.text)\\r\\nprintf(\"kssl_cget_tkt kssl_err=%s\\n\", kssl_err.text);\\r\\n}\\r\\n#endif\\r\\nif (krb5rc)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,\\r\\nSSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nkssl_err.reason);\\r\\ngoto err;\\r\\n}\\r\\ns2n(enc_ticket->length,p);\\r\\nmemcpy(p, enc_ticket->data, enc_ticket->length);\\r\\np+= enc_ticket->length;\\r\\nn = enc_ticket->length + 2;\\r\\nif (authp && authp->length)\\r\\n{\\r\\ns2n(authp->length,p);\\r\\nmemcpy(p, authp->data, authp->length);\\r\\np+= authp->length;\\r\\nn+= authp->length + 2;\\r\\nfree(authp->data);\\r\\nauthp->data = NULL;\\r\\nauthp->length = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns2n(0,p);\\r\\nn+=2;\\r\\n}\\r\\nif (RAND_bytes(tmp_buf,sizeof tmp_buf) <= 0)\\r\\ngoto err;\\r\\nmemset(iv, 0, sizeof iv);\\r\\nEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,\\r\\nkssl_ctx->key,iv);\\r\\nEVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,\\r\\nsizeof tmp_buf);\\r\\nEVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);\\r\\noutl += padl;\\r\\nif (outl > sizeof epms)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&ciph_ctx);\\r\\ns2n(outl,p);\\r\\nmemcpy(p, epms, outl);\\r\\np+=outl;\\r\\nn+=outl + 2;\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\ntmp_buf, sizeof tmp_buf);\\r\\nOPENSSL_cleanse(tmp_buf, sizeof tmp_buf);\\r\\nOPENSSL_cleanse(epms, outl);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nelse if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nDH *dh_srvr,*dh_clnt;\\r\\nif (s->session->sess_cert->peer_dh_tmp != NULL)\\r\\ndh_srvr=s->session->sess_cert->peer_dh_tmp;\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!DH_generate_key(dh_clnt))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,p,n);\\r\\nmemset(p,0,n);\\r\\nn=BN_num_bytes(dh_clnt->pub_key);\\r\\ns2n(n,p);\\r\\nBN_bn2bin(dh_clnt->pub_key,p);\\r\\nn+=2;\\r\\nDH_free(dh_clnt);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nelse if ((l & SSL_kECDH) || (l & SSL_kECDHE))\\r\\n{\\r\\nconst EC_GROUP *srvr_group = NULL;\\r\\nEC_KEY *tkey;\\r\\nint ecdh_clnt_cert = 0;\\r\\nint field_size = 0;\\r\\nif ((l & SSL_kECDH) && (s->cert != NULL))\\r\\n{\\r\\n}\\r\\nif (s->session->sess_cert->peer_ecdh_tmp != NULL)\\r\\n{\\r\\ntkey = s->session->sess_cert->peer_ecdh_tmp;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsrvr_pub_pkey = X509_get_pubkey(s->session-> \\\\r\\nsess_cert->peer_pkeys[SSL_PKEY_ECC].x509);\\r\\nif ((srvr_pub_pkey == NULL) ||\\r\\n(srvr_pub_pkey->type != EVP_PKEY_EC) ||\\r\\n(srvr_pub_pkey->pkey.ec == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntkey = srvr_pub_pkey->pkey.ec;\\r\\n}\\r\\nsrvr_group = EC_KEY_get0_group(tkey);\\r\\nsrvr_ecpoint = EC_KEY_get0_public_key(tkey);\\r\\nif ((srvr_group == NULL) || (srvr_ecpoint == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((clnt_ecdh=EC_KEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_KEY_set_group(clnt_ecdh, srvr_group))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (ecdh_clnt_cert)\\r\\n{\\r\\nconst BIGNUM *priv_key;\\r\\ntkey = s->cert->key->privatekey->pkey.ec;\\r\\npriv_key = EC_KEY_get0_private_key(tkey);\\r\\nif (priv_key == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_KEY_set_private_key(clnt_ecdh, priv_key))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(EC_KEY_generate_key(clnt_ecdh)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nfield_size = EC_GROUP_get_degree(srvr_group);\\r\\nif (field_size <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (field_size <= 24 * 8)\\r\\nn=ECDH_compute_key(p, KDF1_SHA1_len, srvr_ecpoint, clnt_ecdh, KDF1_SHA1);\\r\\nelse\\r\\nn=ECDH_compute_key(p, (field_size+7)/8, srvr_ecpoint, clnt_ecdh, NULL);\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->session->master_key_length = s->method->ssl3_enc \\\\r\\n-> generate_master_secret(s,\\r\\ns->session->master_key,\\r\\np, n);\\r\\nmemset(p, 0, n);\\r\\nif (ecdh_clnt_cert)\\r\\n{\\r\\nn = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nencoded_pt_len =\\r\\nEC_POINT_point2oct(srvr_group,\\r\\nEC_KEY_get0_public_key(clnt_ecdh),\\r\\nPOINT_CONVERSION_UNCOMPRESSED,\\r\\nNULL, 0, NULL);\\r\\nencodedPoint = (unsigned char *)\\r\\nOPENSSL_malloc(encoded_pt_len *\\r\\nsizeof(unsigned char));\\r\\nbn_ctx = BN_CTX_new();\\r\\nif ((encodedPoint == NULL) ||\\r\\n(bn_ctx == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn = EC_POINT_point2oct(srvr_group,\\r\\nEC_KEY_get0_public_key(clnt_ecdh),\\r\\nPOINT_CONVERSION_UNCOMPRESSED,\\r\\nencodedPoint, encoded_pt_len, bn_ctx);\\r\\n*p = n;\\r\\np += 1;\\r\\nmemcpy((unsigned char *)p, encodedPoint, n);\\r\\nn += 1;\\r\\n}\\r\\nBN_CTX_free(bn_ctx);\\r\\nif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\\r\\nif (clnt_ecdh != NULL)\\r\\nEC_KEY_free(clnt_ecdh);\\r\\nEVP_PKEY_free(srvr_pub_pkey);\\r\\n}\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s, SSL3_AL_FATAL,\\r\\nSSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;\\r\\nl2n3(n,d);\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_B;\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBN_CTX_free(bn_ctx);\\r\\nif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\\r\\nif (clnt_ecdh != NULL)\\r\\nEC_KEY_free(clnt_ecdh);\\r\\nEVP_PKEY_free(srvr_pub_pkey);\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_send_client_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nEVP_PKEY *pkey;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned u=0;\\r\\n#endif\\r\\nunsigned long n;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nint j;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_CERT_VRFY_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\npkey=s->cert->key->privatekey;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),\\r\\n&(data[MD5_DIGEST_LENGTH]));\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),&(data[0]));\\r\\nif (RSA_sign(NID_md5_sha1, data,\\r\\nMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\\r\\n&(p[2]), &u, pkey->pkey.rsa) <= 0 )\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(u,p);\\r\\nn=u+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nif (!DSA_sign(pkey->save_type,\\r\\n&(data[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,&(p[2]),\\r\\n(unsigned int *)&j,pkey->pkey.dsa))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(j,p);\\r\\nn=j+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nif (!ECDSA_sign(pkey->save_type,\\r\\n&(data[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,&(p[2]),\\r\\n(unsigned int *)&j,pkey->pkey.ec))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\\r\\nERR_R_ECDSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(j,p);\\r\\nn=j+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*(d++)=SSL3_MT_CERTIFICATE_VERIFY;\\r\\nl2n3(n,d);\\r\\ns->state=SSL3_ST_CW_CERT_VRFY_B;\\r\\ns->init_num=(int)n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_send_client_certificate(SSL *s)\\r\\n{\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == SSL3_ST_CW_CERT_A)\\r\\n{\\r\\nif ((s->cert == NULL) ||\\r\\n(s->cert->key->x509 == NULL) ||\\r\\n(s->cert->key->privatekey == NULL))\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_B)\\r\\n{\\r\\ni=0;\\r\\nif (s->ctx->client_cert_cb != NULL)\\r\\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\\r\\nif (i < 0)\\r\\n{\\r\\ns->rwstate=SSL_X509_LOOKUP;\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nif ( !SSL_use_certificate(s,x509) ||\\r\\n!SSL_use_PrivateKey(s,pkey))\\r\\ni=0;\\r\\n}\\r\\nelse if (i == 1)\\r\\n{\\r\\ni=0;\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\\r\\n}\\r\\nif (x509 != NULL) X509_free(x509);\\r\\nif (pkey != NULL) EVP_PKEY_free(pkey);\\r\\nif (i == 0)\\r\\n{\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\ns->s3->tmp.cert_req=0;\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_req=2;\\r\\n}\\r\\n}\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_C)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_D;\\r\\nl=ssl3_output_cert_chain(s,\\r\\n(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_check_cert_and_algorithm(SSL *s)\\r\\n{\\r\\nint i,idx;\\r\\nlong algs;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nSESS_CERT *sc;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rsa;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nDH *dh;\\r\\n#endif\\r\\nsc=s->session->sess_cert;\\r\\nif (sc == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nalgs=s->s3->tmp.new_cipher->algorithms;\\r\\nif (algs & (SSL_aDH|SSL_aNULL|SSL_aKRB5))\\r\\nreturn(1);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nrsa=s->session->sess_cert->peer_rsa_tmp;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ndh=s->session->sess_cert->peer_dh_tmp;\\r\\n#endif\\r\\nidx=sc->peer_cert_type;\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (idx == SSL_PKEY_ECC)\\r\\n{\\r\\nif (check_srvr_ecc_cert_and_alg(sc->peer_pkeys[idx].x509,\\r\\ns->s3->tmp.new_cipher) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_BAD_ECC_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\n#endif\\r\\npkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);\\r\\ni=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif ((algs & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_SIGNING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nelse if ((algs & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DSA_SIGNING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((algs & SSL_kRSA) &&\\r\\n!(has_bits(i,EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_ENCRYPTING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif ((algs & SSL_kEDH) &&\\r\\n!(has_bits(i,EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nelse if ((algs & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_RSA_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nelse if ((algs & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_DSA_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\nif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && !has_bits(i,EVP_PKT_EXP))\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (algs & SSL_kRSA)\\r\\n{\\r\\nif (rsa == NULL\\r\\n|| RSA_size(rsa)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (algs & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nif (dh == NULL\\r\\n|| DH_size(dh)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nstatic int curve_id2nid(int curve_id)\\r\\n{\\r\\nstatic int nid_list[26] =\\r\\n{\\r\\n0,\\r\\nNID_sect163k1,\\r\\nNID_sect163r1,\\r\\nNID_sect163r2,\\r\\nNID_sect193r1,\\r\\nNID_sect193r2,\\r\\nNID_sect233k1,\\r\\nNID_sect233r1,\\r\\nNID_sect239k1,\\r\\nNID_sect283k1,\\r\\nNID_sect283r1,\\r\\nNID_sect409k1,\\r\\nNID_sect409r1,\\r\\nNID_sect571k1,\\r\\nNID_sect571r1,\\r\\nNID_secp160k1,\\r\\nNID_secp160r1,\\r\\nNID_secp160r2,\\r\\nNID_secp192k1,\\r\\nNID_X9_62_prime192v1,\\r\\nNID_secp224k1,\\r\\nNID_secp224r1,\\r\\nNID_secp256k1,\\r\\nNID_X9_62_prime256v1,\\r\\nNID_secp384r1,\\r\\nNID_secp521r1\\r\\n};\\r\\nif ((curve_id < 1) || (curve_id > 25)) return 0;\\r\\nreturn nid_list[curve_id];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_des_enc_c", "target": 0, "func": "void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l,r,t,u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr=data[0];\\r\\nl=data[1];\\r\\nIP(r,l);\\r\\nr=ROTATE(r,29)&0xffffffffL;\\r\\nl=ROTATE(l,29)&0xffffffffL;\\r\\ns=ks->ks->deslong;\\r\\nif (enc)\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r, 0);\\r\\nD_ENCRYPT(r,l, 2);\\r\\nD_ENCRYPT(l,r, 4);\\r\\nD_ENCRYPT(r,l, 6);\\r\\nD_ENCRYPT(l,r, 8);\\r\\nD_ENCRYPT(r,l,10);\\r\\nD_ENCRYPT(l,r,12);\\r\\nD_ENCRYPT(r,l,14);\\r\\nD_ENCRYPT(l,r,16);\\r\\nD_ENCRYPT(r,l,18);\\r\\nD_ENCRYPT(l,r,20);\\r\\nD_ENCRYPT(r,l,22);\\r\\nD_ENCRYPT(l,r,24);\\r\\nD_ENCRYPT(r,l,26);\\r\\nD_ENCRYPT(l,r,28);\\r\\nD_ENCRYPT(r,l,30);\\r\\n#else\\r\\nfor (i=0; i<32; i+=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i+0);\\r\\nD_ENCRYPT(r,l,i+2);\\r\\nD_ENCRYPT(l,r,i+4);\\r\\nD_ENCRYPT(r,l,i+6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r,30);\\r\\nD_ENCRYPT(r,l,28);\\r\\nD_ENCRYPT(l,r,26);\\r\\nD_ENCRYPT(r,l,24);\\r\\nD_ENCRYPT(l,r,22);\\r\\nD_ENCRYPT(r,l,20);\\r\\nD_ENCRYPT(l,r,18);\\r\\nD_ENCRYPT(r,l,16);\\r\\nD_ENCRYPT(l,r,14);\\r\\nD_ENCRYPT(r,l,12);\\r\\nD_ENCRYPT(l,r,10);\\r\\nD_ENCRYPT(r,l, 8);\\r\\nD_ENCRYPT(l,r, 6);\\r\\nD_ENCRYPT(r,l, 4);\\r\\nD_ENCRYPT(l,r, 2);\\r\\nD_ENCRYPT(r,l, 0);\\r\\n#else\\r\\nfor (i=30; i>0; i-=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i-0);\\r\\nD_ENCRYPT(r,l,i-2);\\r\\nD_ENCRYPT(l,r,i-4);\\r\\nD_ENCRYPT(r,l,i-6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nl=ROTATE(l,3)&0xffffffffL;\\r\\nr=ROTATE(r,3)&0xffffffffL;\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\nl=r=t=u=0;\\r\\n}\\r\\nvoid DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l,r,t,u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP=(const unsigned char *)DES_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr=data[0];\\r\\nl=data[1];\\r\\nr=ROTATE(r,29)&0xffffffffL;\\r\\nl=ROTATE(l,29)&0xffffffffL;\\r\\ns=ks->ks->deslong;\\r\\nif (enc)\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r, 0);\\r\\nD_ENCRYPT(r,l, 2);\\r\\nD_ENCRYPT(l,r, 4);\\r\\nD_ENCRYPT(r,l, 6);\\r\\nD_ENCRYPT(l,r, 8);\\r\\nD_ENCRYPT(r,l,10);\\r\\nD_ENCRYPT(l,r,12);\\r\\nD_ENCRYPT(r,l,14);\\r\\nD_ENCRYPT(l,r,16);\\r\\nD_ENCRYPT(r,l,18);\\r\\nD_ENCRYPT(l,r,20);\\r\\nD_ENCRYPT(r,l,22);\\r\\nD_ENCRYPT(l,r,24);\\r\\nD_ENCRYPT(r,l,26);\\r\\nD_ENCRYPT(l,r,28);\\r\\nD_ENCRYPT(r,l,30);\\r\\n#else\\r\\nfor (i=0; i<32; i+=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i+0);\\r\\nD_ENCRYPT(r,l,i+2);\\r\\nD_ENCRYPT(l,r,i+4);\\r\\nD_ENCRYPT(r,l,i+6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r,30);\\r\\nD_ENCRYPT(r,l,28);\\r\\nD_ENCRYPT(l,r,26);\\r\\nD_ENCRYPT(r,l,24);\\r\\nD_ENCRYPT(l,r,22);\\r\\nD_ENCRYPT(r,l,20);\\r\\nD_ENCRYPT(l,r,18);\\r\\nD_ENCRYPT(r,l,16);\\r\\nD_ENCRYPT(l,r,14);\\r\\nD_ENCRYPT(r,l,12);\\r\\nD_ENCRYPT(l,r,10);\\r\\nD_ENCRYPT(r,l, 8);\\r\\nD_ENCRYPT(l,r, 6);\\r\\nD_ENCRYPT(r,l, 4);\\r\\nD_ENCRYPT(l,r, 2);\\r\\nD_ENCRYPT(r,l, 0);\\r\\n#else\\r\\nfor (i=30; i>0; i-=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i-0);\\r\\nD_ENCRYPT(r,l,i-2);\\r\\nD_ENCRYPT(l,r,i-4);\\r\\nD_ENCRYPT(r,l,i-6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\ndata[0]=ROTATE(l,3)&0xffffffffL;\\r\\ndata[1]=ROTATE(r,3)&0xffffffffL;\\r\\nl=r=t=u=0;\\r\\n}\\r\\nvoid DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3)\\r\\n{\\r\\nregister DES_LONG l,r;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nIP(l,r);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\nDES_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);\\r\\nDES_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);\\r\\nDES_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\n}\\r\\nvoid DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3)\\r\\n{\\r\\nregister DES_LONG l,r;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nIP(l,r);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\nDES_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);\\r\\nDES_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);\\r\\nDES_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\n}\\r\\nvoid DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1;\\r\\nregister const unsigned char *in;\\r\\nunsigned char *out;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin=input;\\r\\nout=output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nregister DES_LONG t0,t1;\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_print_c", "target": 0, "func": "int ASN1_PRINTABLE_type(const unsigned char *s, int len)\\r\\n{\\r\\nint c;\\r\\nint ia5=0;\\r\\nint t61=0;\\r\\nif (len <= 0) len= -1;\\r\\nif (s == NULL) return(V_ASN1_PRINTABLESTRING);\\r\\nwhile ((*s) && (len-- != 0))\\r\\n{\\r\\nc= *(s++);\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((c >= 'a') && (c <= 'z')) ||\\r\\n((c >= 'A') && (c <= 'Z')) ||\\r\\n(c == ' ') ||\\r\\n((c >= '0') && (c <= '9')) ||\\r\\n(c == ' ') || (c == '\\'') ||\\r\\n(c == '(') || (c == ')') ||\\r\\n(c == '+') || (c == ',') ||\\r\\n(c == '-') || (c == '.') ||\\r\\n(c == '/') || (c == ':') ||\\r\\n(c == '=') || (c == '?')))\\r\\nia5=1;\\r\\nif (c&0x80)\\r\\nt61=1;\\r\\n#else\\r\\nif (!isalnum(c) && (c != ' ') &&\\r\\nstrchr(\"'()+,-./:=?\", c) == NULL)\\r\\nia5=1;\\r\\nif (os_toascii[c] & 0x80)\\r\\nt61=1;\\r\\n#endif\\r\\n}\\r\\nif (t61) return(V_ASN1_T61STRING);\\r\\nif (ia5) return(V_ASN1_IA5STRING);\\r\\nreturn(V_ASN1_PRINTABLESTRING);\\r\\n}\\r\\nint ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s)\\r\\n{\\r\\nint i;\\r\\nunsigned char *p;\\r\\nif (s->type != V_ASN1_UNIVERSALSTRING) return(0);\\r\\nif ((s->length%4) != 0) return(0);\\r\\np=s->data;\\r\\nfor (i=0; i<s->length; i+=4)\\r\\n{\\r\\nif ((p[0] != '\\0') || (p[1] != '\\0') || (p[2] != '\\0'))\\r\\nbreak;\\r\\nelse\\r\\np+=4;\\r\\n}\\r\\nif (i < s->length) return(0);\\r\\np=s->data;\\r\\nfor (i=3; i<s->length; i+=4)\\r\\n{\\r\\n*(p++)=s->data[i];\\r\\n}\\r\\n*(p)='\\0';\\r\\ns->length/=4;\\r\\ns->type=ASN1_PRINTABLE_type(s->data,s->length);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_utl_c", "target": 0, "func": "void X509V3_conf_free(CONF_VALUE *conf)\\r\\n{\\r\\nif(!conf) return;\\r\\nif(conf->name) OPENSSL_free(conf->name);\\r\\nif(conf->value) OPENSSL_free(conf->value);\\r\\nif(conf->section) OPENSSL_free(conf->section);\\r\\nOPENSSL_free(conf);\\r\\n}\\r\\nchar *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif(!a) return NULL;\\r\\nif(!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)) )\\r\\nX509V3err(X509V3_F_I2S_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nchar *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif(!a) return NULL;\\r\\nif(!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)) )\\r\\nX509V3err(X509V3_F_I2S_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)\\r\\n{\\r\\nBIGNUM *bn = NULL;\\r\\nASN1_INTEGER *aint;\\r\\nint isneg, ishex;\\r\\nint ret;\\r\\nif (!value) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_INVALID_NULL_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nbn = BN_new();\\r\\nif (value[0] == '-') {\\r\\nvalue++;\\r\\nisneg = 1;\\r\\n} else isneg = 0;\\r\\nif (value[0] == '0' && ((value[1] == 'x') || (value[1] == 'X'))) {\\r\\nvalue += 2;\\r\\nishex = 1;\\r\\n} else ishex = 0;\\r\\nif (ishex) ret = BN_hex2bn(&bn, value);\\r\\nelse ret = BN_dec2bn(&bn, value);\\r\\nif (!ret || value[ret]) {\\r\\nBN_free(bn);\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_DEC2BN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (isneg && BN_is_zero(bn)) isneg = 0;\\r\\naint = BN_to_ASN1_INTEGER(bn, NULL);\\r\\nBN_free(bn);\\r\\nif (!aint) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_TO_ASN1_INTEGER_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (isneg) aint->type |= V_ASN1_NEG;\\r\\nreturn aint;\\r\\n}\\r\\nint X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)\\r\\n{\\r\\nchar *btmp;\\r\\nif(!(btmp = value->value)) goto err;\\r\\nif(!strcmp(btmp, \"TRUE\") || !strcmp(btmp, \"true\")\\r\\n|| !strcmp(btmp, \"Y\") || !strcmp(btmp, \"y\")\\r\\n|| !strcmp(btmp, \"YES\") || !strcmp(btmp, \"yes\")) {\\r\\n*asn1_bool = 0xff;\\r\\nreturn 1;\\r\\n} else if(!strcmp(btmp, \"FALSE\") || !strcmp(btmp, \"false\")\\r\\n|| !strcmp(btmp, \"N\") || !strcmp(btmp, \"n\")\\r\\n|| !strcmp(btmp, \"NO\") || !strcmp(btmp, \"no\")) {\\r\\n*asn1_bool = 0;\\r\\nreturn 1;\\r\\n}\\r\\nerr:\\r\\nX509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,X509V3_R_INVALID_BOOLEAN_STRING);\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\nint X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)\\r\\n{\\r\\nASN1_INTEGER *itmp;\\r\\nif(!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\n*aint = itmp;\\r\\nreturn 1;\\r\\n}\\r\\nchar *strip_spaces(char *name)\\r\\n{\\r\\nchar *p, *q;\\r\\np = name;\\r\\nwhile(*p && isspace((unsigned char)*p)) p++;\\r\\nif(!*p) return NULL;\\r\\nq = p + strlen(p) - 1;\\r\\nwhile((q != p) && isspace((unsigned char)*q)) q--;\\r\\nif(p != q) q[1] = 0;\\r\\nif(!*p) return NULL;\\r\\nreturn p;\\r\\n}\\r\\nchar *hex_to_string(unsigned char *buffer, long len)\\r\\n{\\r\\nchar *tmp, *q;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nstatic char hexdig[] = \"0123456789ABCDEF\";\\r\\nif(!buffer || !len) return NULL;\\r\\nif(!(tmp = OPENSSL_malloc(len * 3 + 1))) {\\r\\nX509V3err(X509V3_F_HEX_TO_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nq = tmp;\\r\\nfor(i = 0, p = buffer; i < len; i++,p++) {\\r\\n*q++ = hexdig[(*p >> 4) & 0xf];\\r\\n*q++ = hexdig[*p & 0xf];\\r\\n*q++ = ':';\\r\\n}\\r\\nq[-1] = 0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(tmp, tmp, q - tmp - 1);\\r\\n#endif\\r\\nreturn tmp;\\r\\n}\\r\\nunsigned char *string_to_hex(char *str, long *len)\\r\\n{\\r\\nunsigned char *hexbuf, *q;\\r\\nunsigned char ch, cl, *p;\\r\\nif(!str) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(hexbuf = OPENSSL_malloc(strlen(str) >> 1))) goto err;\\r\\nfor(p = (unsigned char *)str, q = hexbuf; *p;) {\\r\\nch = *p++;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nch = os_toebcdic[ch];\\r\\n#endif\\r\\nif(ch == ':') continue;\\r\\ncl = *p++;\\r\\n#ifdef CHARSET_EBCDIC\\r\\ncl = os_toebcdic[cl];\\r\\n#endif\\r\\nif(!cl) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ODD_NUMBER_OF_DIGITS);\\r\\nOPENSSL_free(hexbuf);\\r\\nreturn NULL;\\r\\n}\\r\\nif(isupper(ch)) ch = tolower(ch);\\r\\nif(isupper(cl)) cl = tolower(cl);\\r\\nif((ch >= '0') && (ch <= '9')) ch -= '0';\\r\\nelse if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;\\r\\nelse goto badhex;\\r\\nif((cl >= '0') && (cl <= '9')) cl -= '0';\\r\\nelse if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;\\r\\nelse goto badhex;\\r\\n*q++ = (ch << 4) | cl;\\r\\n}\\r\\nif(len) *len = q - hexbuf;\\r\\nreturn hexbuf;\\r\\nerr:\\r\\nif(hexbuf) OPENSSL_free(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\nbadhex:\\r\\nOPENSSL_free(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ILLEGAL_HEX_DIGIT);\\r\\nreturn NULL;\\r\\n}\\r\\nint name_cmp(const char *name, const char *cmp)\\r\\n{\\r\\nint len, ret;\\r\\nchar c;\\r\\nlen = strlen(cmp);\\r\\nif((ret = strncmp(name, cmp, len))) return ret;\\r\\nc = name[len];\\r\\nif(!c || (c=='.')) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int sk_strcmp(const char * const *a, const char * const *b)\\r\\n{\\r\\nreturn strcmp(*a, *b);\\r\\n}\\r\\nSTACK *X509_get1_email(X509 *x)\\r\\n{\\r\\nGENERAL_NAMES *gens;\\r\\nSTACK *ret;\\r\\ngens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);\\r\\nret = get_email(X509_get_subject_name(x), gens);\\r\\nsk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\\r\\nreturn ret;\\r\\n}\\r\\nSTACK *X509_REQ_get1_email(X509_REQ *x)\\r\\n{\\r\\nGENERAL_NAMES *gens;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nSTACK *ret;\\r\\nexts = X509_REQ_get_extensions(x);\\r\\ngens = X509V3_get_d2i(exts, NID_subject_alt_name, NULL, NULL);\\r\\nret = get_email(X509_REQ_get_subject_name(x), gens);\\r\\nsk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic STACK *get_email(X509_NAME *name, GENERAL_NAMES *gens)\\r\\n{\\r\\nSTACK *ret = NULL;\\r\\nX509_NAME_ENTRY *ne;\\r\\nASN1_IA5STRING *email;\\r\\nGENERAL_NAME *gen;\\r\\nint i;\\r\\ni = -1;\\r\\nwhile((i = X509_NAME_get_index_by_NID(name,\\r\\nNID_pkcs9_emailAddress, i)) >= 0) {\\r\\nne = X509_NAME_get_entry(name, i);\\r\\nemail = X509_NAME_ENTRY_get_data(ne);\\r\\nif(!append_ia5(&ret, email)) return NULL;\\r\\n}\\r\\nfor(i = 0; i < sk_GENERAL_NAME_num(gens); i++)\\r\\n{\\r\\ngen = sk_GENERAL_NAME_value(gens, i);\\r\\nif(gen->type != GEN_EMAIL) continue;\\r\\nif(!append_ia5(&ret, gen->d.ia5)) return NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic void str_free(void *str)\\r\\n{\\r\\nOPENSSL_free(str);\\r\\n}\\r\\nstatic int append_ia5(STACK **sk, ASN1_IA5STRING *email)\\r\\n{\\r\\nchar *emtmp;\\r\\nif(email->type != V_ASN1_IA5STRING) return 1;\\r\\nif(!email->data || !email->length) return 1;\\r\\nif(!*sk) *sk = sk_new(sk_strcmp);\\r\\nif(!*sk) return 0;\\r\\nif(sk_find(*sk, (char *)email->data) != -1) return 1;\\r\\nemtmp = BUF_strdup((char *)email->data);\\r\\nif(!emtmp || !sk_push(*sk, emtmp)) {\\r\\nX509_email_free(*sk);\\r\\n*sk = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid X509_email_free(STACK *sk)\\r\\n{\\r\\nsk_pop_free(sk, str_free);\\r\\n}\\r\\nASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)\\r\\n{\\r\\nunsigned char ipout[16];\\r\\nASN1_OCTET_STRING *ret;\\r\\nint iplen;\\r\\niplen = a2i_ipadd(ipout, ipasc);\\r\\nif (!iplen)\\r\\nreturn NULL;\\r\\nret = ASN1_OCTET_STRING_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen))\\r\\n{\\r\\nASN1_OCTET_STRING_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)\\r\\n{\\r\\nASN1_OCTET_STRING *ret = NULL;\\r\\nunsigned char ipout[32];\\r\\nchar *iptmp = NULL, *p;\\r\\nint iplen1, iplen2;\\r\\np = strchr(ipasc,'/');\\r\\nif (!p)\\r\\nreturn NULL;\\r\\niptmp = BUF_strdup(ipasc);\\r\\nif (!iptmp)\\r\\nreturn NULL;\\r\\np = iptmp + (p - ipasc);\\r\\n*p++ = 0;\\r\\niplen1 = a2i_ipadd(ipout, iptmp);\\r\\nif (!iplen1)\\r\\ngoto err;\\r\\niplen2 = a2i_ipadd(ipout + iplen1, p);\\r\\nOPENSSL_free(iptmp);\\r\\niptmp = NULL;\\r\\nif (!iplen2 || (iplen1 != iplen2))\\r\\ngoto err;\\r\\nret = ASN1_OCTET_STRING_new();\\r\\nif (!ret)\\r\\ngoto err;\\r\\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (iptmp)\\r\\nOPENSSL_free(iptmp);\\r\\nif (ret)\\r\\nASN1_OCTET_STRING_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int a2i_ipadd(unsigned char *ipout, const char *ipasc)\\r\\n{\\r\\nif (strchr(ipasc, ':'))\\r\\n{\\r\\nif (!ipv6_from_asc(ipout, ipasc))\\r\\nreturn 0;\\r\\nreturn 16;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!ipv4_from_asc(ipout, ipasc))\\r\\nreturn 0;\\r\\nreturn 4;\\r\\n}\\r\\n}\\r\\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\\r\\n{\\r\\nint a0, a1, a2, a3;\\r\\nif (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\\r\\nreturn 0;\\r\\nif ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\\r\\n|| (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\\r\\nreturn 0;\\r\\nv4[0] = a0;\\r\\nv4[1] = a1;\\r\\nv4[2] = a2;\\r\\nv4[3] = a3;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_from_asc(unsigned char *v6, const char *in)\\r\\n{\\r\\nIPV6_STAT v6stat;\\r\\nv6stat.total = 0;\\r\\nv6stat.zero_pos = -1;\\r\\nv6stat.zero_cnt = 0;\\r\\nif (!CONF_parse_list(in, ':', 0, ipv6_cb, &v6stat))\\r\\nreturn 0;\\r\\nif (v6stat.zero_pos == -1)\\r\\n{\\r\\nif (v6stat.total != 16)\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (v6stat.total == 16)\\r\\nreturn 0;\\r\\nif (v6stat.zero_cnt > 3)\\r\\nreturn 0;\\r\\nelse if (v6stat.zero_cnt == 3)\\r\\n{\\r\\nif (v6stat.total > 0)\\r\\nreturn 0;\\r\\n}\\r\\nelse if (v6stat.zero_cnt == 2)\\r\\n{\\r\\nif ((v6stat.zero_pos != 0)\\r\\n&& (v6stat.zero_pos != v6stat.total))\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((v6stat.zero_pos == 0)\\r\\n|| (v6stat.zero_pos == v6stat.total))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (v6stat.zero_pos > 0)\\r\\nmemcpy(v6, v6stat.tmp, v6stat.zero_pos);\\r\\nif (v6stat.total != 16)\\r\\nmemset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);\\r\\nif (v6stat.total != v6stat.zero_pos)\\r\\nmemcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,\\r\\nv6stat.tmp + v6stat.zero_pos,\\r\\nv6stat.total - v6stat.zero_pos);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_cb(const char *elem, int len, void *usr)\\r\\n{\\r\\nIPV6_STAT *s = usr;\\r\\nif (s->total == 16)\\r\\nreturn 0;\\r\\nif (len == 0)\\r\\n{\\r\\nif (s->zero_pos == -1)\\r\\ns->zero_pos = s->total;\\r\\nelse if (s->zero_pos != s->total)\\r\\nreturn 0;\\r\\ns->zero_cnt++;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len > 4)\\r\\n{\\r\\nif (s->total > 12)\\r\\nreturn 0;\\r\\nif (elem[len])\\r\\nreturn 0;\\r\\nif (!ipv4_from_asc(s->tmp + s->total, elem))\\r\\nreturn 0;\\r\\ns->total += 4;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!ipv6_hex(s->tmp + s->total, elem, len))\\r\\nreturn 0;\\r\\ns->total += 2;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_hex(unsigned char *out, const char *in, int inlen)\\r\\n{\\r\\nunsigned char c;\\r\\nunsigned int num = 0;\\r\\nif (inlen > 4)\\r\\nreturn 0;\\r\\nwhile(inlen--)\\r\\n{\\r\\nc = *in++;\\r\\nnum <<= 4;\\r\\nif ((c >= '0') && (c <= '9'))\\r\\nnum |= c - '0';\\r\\nelse if ((c >= 'A') && (c <= 'F'))\\r\\nnum |= c - 'A' + 10;\\r\\nelse if ((c >= 'a') && (c <= 'f'))\\r\\nnum |= c - 'a' + 10;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nout[0] = num >> 8;\\r\\nout[1] = num & 0xff;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC2_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC2_set_key(&sch,16,key,128);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC2_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC2_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC2_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC2_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC2_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC2_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC2_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC2_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),RC2_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC2 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC2 raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"RC2 cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_th-lock_c", "target": 0, "func": "void CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\nlock_cs[i]=CreateMutex(NULL,FALSE,NULL);\\r\\n}\\r\\nCRYPTO_set_locking_callback((void (*)(int,int,char *,int))win32_locking_callback);\\r\\nreturn(1);\\r\\n}\\r\\nstatic void CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\nCloseHandle(lock_cs[i]);\\r\\nOPENSSL_free(lock_cs);\\r\\n}\\r\\nvoid win32_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\nWaitForSingleObject(lock_cs[type],INFINITE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nReleaseMutex(lock_cs[type]);\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\n#ifdef USE_MUTEX\\r\\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(mutex_t));\\r\\n#else\\r\\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(rwlock_t));\\r\\n#endif\\r\\nlock_count=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\nlock_count[i]=0;\\r\\n#ifdef USE_MUTEX\\r\\nmutex_init(&(lock_cs[i]),USYNC_THREAD,NULL);\\r\\n#else\\r\\nrwlock_init(&(lock_cs[i]),USYNC_THREAD,NULL);\\r\\n#endif\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())solaris_locking_callback);\\r\\n}\\r\\nvoid CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_destroy(&(lock_cs[i]));\\r\\n#else\\r\\nrwlock_destroy(&(lock_cs[i]));\\r\\n#endif\\r\\n}\\r\\nOPENSSL_free(lock_cs);\\r\\nOPENSSL_free(lock_count);\\r\\n}\\r\\nvoid solaris_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\n#if 0\\r\\nfprintf(stderr,\"thread=%4d mode=%s lock=%s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n(mode&CRYPTO_LOCK)?\"l\":\"u\",\\r\\n(type&CRYPTO_READ)?\"r\":\"w\",file,line);\\r\\n#endif\\r\\n#if 0\\r\\nif (CRYPTO_LOCK_SSL_CERT == type)\\r\\nfprintf(stderr,\"(t,m,f,l) %ld %d %s %d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nmode,file,line);\\r\\n#endif\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_lock(&(lock_cs[type]));\\r\\n#else\\r\\nif (mode & CRYPTO_READ)\\r\\nrw_rdlock(&(lock_cs[type]));\\r\\nelse\\r\\nrw_wrlock(&(lock_cs[type]));\\r\\n#endif\\r\\nlock_count[type]++;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_unlock(&(lock_cs[type]));\\r\\n#else\\r\\nrw_unlock(&(lock_cs[type]));\\r\\n#endif\\r\\n}\\r\\n}\\r\\nunsigned long solaris_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)thr_self();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nchar filename[20];\\r\\nstrcpy(filename,\"/tmp/mttest.XXXXXX\");\\r\\nmktemp(filename);\\r\\nusconfig(CONF_STHREADIOOFF);\\r\\nusconfig(CONF_STHREADMALLOCOFF);\\r\\nusconfig(CONF_INITUSERS,100);\\r\\nusconfig(CONF_LOCKTYPE,US_DEBUGPLUS);\\r\\narena=usinit(filename);\\r\\nunlink(filename);\\r\\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(usema_t *));\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\nlock_cs[i]=usnewsema(arena,1);\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())irix_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())irix_locking_callback);\\r\\n}\\r\\nvoid CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\nchar buf[10];\\r\\nsprintf(buf,\"%2d:\",i);\\r\\nusdumpsema(lock_cs[i],stdout,buf);\\r\\nusfreesema(lock_cs[i],arena);\\r\\n}\\r\\nOPENSSL_free(lock_cs);\\r\\n}\\r\\nvoid irix_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\nuspsema(lock_cs[type]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nusvsema(lock_cs[type]);\\r\\n}\\r\\n}\\r\\nunsigned long irix_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)getpid();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\\r\\nlock_count=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\nlock_count[i]=0;\\r\\npthread_mutex_init(&(lock_cs[i]),NULL);\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())pthreads_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())pthreads_locking_callback);\\r\\n}\\r\\nvoid thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_num_locks(); i++)\\r\\n{\\r\\npthread_mutex_destroy(&(lock_cs[i]));\\r\\n}\\r\\nOPENSSL_free(lock_cs);\\r\\nOPENSSL_free(lock_count);\\r\\n}\\r\\nvoid pthreads_locking_callback(int mode, int type, char *file,\\r\\nint line)\\r\\n{\\r\\n#if 0\\r\\nfprintf(stderr,\"thread=%4d mode=%s lock=%s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n(mode&CRYPTO_LOCK)?\"l\":\"u\",\\r\\n(type&CRYPTO_READ)?\"r\":\"w\",file,line);\\r\\n#endif\\r\\n#if 0\\r\\nif (CRYPTO_LOCK_SSL_CERT == type)\\r\\nfprintf(stderr,\"(t,m,f,l) %ld %d %s %d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nmode,file,line);\\r\\n#endif\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\npthread_mutex_lock(&(lock_cs[type]));\\r\\nlock_count[type]++;\\r\\n}\\r\\nelse\\r\\n{\\r\\npthread_mutex_unlock(&(lock_cs[type]));\\r\\n}\\r\\n}\\r\\nunsigned long pthreads_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)pthread_self();\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5ofb64_c", "target": 0, "func": "void RC5_32_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_key_c", "target": 0, "func": "int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n, unsigned char *out,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *unipass;\\r\\nint uniplen;\\r\\nif(!pass) {\\r\\nunipass = NULL;\\r\\nuniplen = 0;\\r\\n} else if (!asc2uni(pass, passlen, &unipass, &uniplen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_ASC,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nret = PKCS12_key_gen_uni(unipass, uniplen, salt, saltlen,\\r\\nid, iter, n, out, md_type);\\r\\nif(unipass) {\\r\\nOPENSSL_cleanse(unipass, uniplen);\\r\\nOPENSSL_free(unipass);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n, unsigned char *out,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nunsigned char *B, *D, *I, *p, *Ai;\\r\\nint Slen, Plen, Ilen, Ijlen;\\r\\nint i, j, u, v;\\r\\nBIGNUM *Ij, *Bpl1;\\r\\nEVP_MD_CTX ctx;\\r\\n#ifdef DEBUG_KEYGEN\\r\\nunsigned char *tmpout = out;\\r\\nint tmpn = n;\\r\\n#endif\\r\\n#if 0\\r\\nif (!pass) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nEVP_MD_CTX_init(&ctx);\\r\\n#ifdef DEBUG_KEYGEN\\r\\nfprintf(stderr, \"KEYGEN DEBUG\\n\");\\r\\nfprintf(stderr, \"ID %d, ITER %d\\n\", id, iter);\\r\\nfprintf(stderr, \"Password (length %d):\\n\", passlen);\\r\\nh__dump(pass, passlen);\\r\\nfprintf(stderr, \"Salt (length %d):\\n\", saltlen);\\r\\nh__dump(salt, saltlen);\\r\\n#endif\\r\\nv = EVP_MD_block_size (md_type);\\r\\nu = EVP_MD_size (md_type);\\r\\nD = OPENSSL_malloc (v);\\r\\nAi = OPENSSL_malloc (u);\\r\\nB = OPENSSL_malloc (v + 1);\\r\\nSlen = v * ((saltlen+v-1)/v);\\r\\nif(passlen) Plen = v * ((passlen+v-1)/v);\\r\\nelse Plen = 0;\\r\\nIlen = Slen + Plen;\\r\\nI = OPENSSL_malloc (Ilen);\\r\\nIj = BN_new();\\r\\nBpl1 = BN_new();\\r\\nif (!D || !Ai || !B || !I || !Ij || !Bpl1) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < v; i++) D[i] = id;\\r\\np = I;\\r\\nfor (i = 0; i < Slen; i++) *p++ = salt[i % saltlen];\\r\\nfor (i = 0; i < Plen; i++) *p++ = pass[i % passlen];\\r\\nfor (;;) {\\r\\nEVP_DigestInit_ex(&ctx, md_type, NULL);\\r\\nEVP_DigestUpdate(&ctx, D, v);\\r\\nEVP_DigestUpdate(&ctx, I, Ilen);\\r\\nEVP_DigestFinal_ex(&ctx, Ai, NULL);\\r\\nfor (j = 1; j < iter; j++) {\\r\\nEVP_DigestInit_ex(&ctx, md_type, NULL);\\r\\nEVP_DigestUpdate(&ctx, Ai, u);\\r\\nEVP_DigestFinal_ex(&ctx, Ai, NULL);\\r\\n}\\r\\nmemcpy (out, Ai, min (n, u));\\r\\nif (u >= n) {\\r\\nOPENSSL_free (Ai);\\r\\nOPENSSL_free (B);\\r\\nOPENSSL_free (D);\\r\\nOPENSSL_free (I);\\r\\nBN_free (Ij);\\r\\nBN_free (Bpl1);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\n#ifdef DEBUG_KEYGEN\\r\\nfprintf(stderr, \"Output KEY (length %d)\\n\", tmpn);\\r\\nh__dump(tmpout, tmpn);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nn -= u;\\r\\nout += u;\\r\\nfor (j = 0; j < v; j++) B[j] = Ai[j % u];\\r\\nBN_bin2bn (B, v, Bpl1);\\r\\nBN_add_word (Bpl1, 1);\\r\\nfor (j = 0; j < Ilen ; j+=v) {\\r\\nBN_bin2bn (I + j, v, Ij);\\r\\nBN_add (Ij, Ij, Bpl1);\\r\\nBN_bn2bin (Ij, B);\\r\\nIjlen = BN_num_bytes (Ij);\\r\\nif (Ijlen > v) {\\r\\nBN_bn2bin (Ij, B);\\r\\nmemcpy (I + j, B + 1, v);\\r\\n#ifndef PKCS12_BROKEN_KEYGEN\\r\\n} else if (Ijlen < v) {\\r\\nmemset(I + j, 0, v - Ijlen);\\r\\nBN_bn2bin(Ij, I + j + v - Ijlen);\\r\\n#endif\\r\\n} else BN_bn2bin (Ij, I + j);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid h__dump (unsigned char *p, int len)\\r\\n{\\r\\nfor (; len --; p++) fprintf(stderr, \"%02X\", *p);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_rle_c", "target": 0, "func": "COMP_METHOD *COMP_rle(void)\\r\\n{\\r\\nreturn(&rle_method);\\r\\n}\\r\\nstatic int rle_compress_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nif (olen < (ilen+1))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\n*(out++)=0;\\r\\nmemcpy(out,in,ilen);\\r\\nreturn(ilen+1);\\r\\n}\\r\\nstatic int rle_expand_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nint i;\\r\\nif (olen < (ilen-1))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\ni= *(in++);\\r\\nif (i == 0)\\r\\n{\\r\\nmemcpy(out,in,ilen-1);\\r\\n}\\r\\nreturn(ilen-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecb3_enc_c", "target": 0, "func": "void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,\\r\\nDES_key_schedule *ks1, DES_key_schedule *ks2,\\r\\nDES_key_schedule *ks3,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG l0,l1;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in,l0);\\r\\nc2l(in,l1);\\r\\nll[0]=l0;\\r\\nll[1]=l1;\\r\\nif (enc)\\r\\nDES_encrypt3(ll,ks1,ks2,ks3);\\r\\nelse\\r\\nDES_decrypt3(ll,ks1,ks2,ks3);\\r\\nl0=ll[0];\\r\\nl1=ll[1];\\r\\nl2c(l0,out);\\r\\nl2c(l1,out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tunala_c", "target": 0, "func": "static DH *get_dh512(void)\\r\\n{\\r\\nDH *dh=NULL;\\r\\nif ((dh=DH_new()) == NULL) return(NULL);\\r\\ndh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);\\r\\ndh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);\\r\\nif ((dh->p == NULL) || (dh->g == NULL))\\r\\nreturn(NULL);\\r\\nreturn(dh);\\r\\n}\\r\\nstatic int usage(const char *errstr, int isunknownarg)\\r\\n{\\r\\nif(isunknownarg)\\r\\nfprintf(stderr, \"Error: unknown argument '%s'\\n\", errstr);\\r\\nelse\\r\\nfprintf(stderr, \"Error: %s\\n\", errstr);\\r\\nfprintf(stderr, \"%s\\n\", helpstring);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int err_str0(const char *str0)\\r\\n{\\r\\nfprintf(stderr, \"%s\\n\", str0);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int err_str1(const char *fmt, const char *str1)\\r\\n{\\r\\nfprintf(stderr, fmt, str1);\\r\\nfprintf(stderr, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_max_tunnels(const char *s, unsigned int *maxtunnels)\\r\\n{\\r\\nunsigned long l;\\r\\nif(!int_strtoul(s, &l) || (l < 1) || (l > 1024)) {\\r\\nfprintf(stderr, \"Error, '%s' is an invalid value for \"\\r\\n\"maxtunnels\\n\", s);\\r\\nreturn 0;\\r\\n}\\r\\n*maxtunnels = (unsigned int)l;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_server_mode(const char *s, int *servermode)\\r\\n{\\r\\nunsigned long l;\\r\\nif(!int_strtoul(s, &l) || (l > 1)) {\\r\\nfprintf(stderr, \"Error, '%s' is an invalid value for the \"\\r\\n\"server mode\\n\", s);\\r\\nreturn 0;\\r\\n}\\r\\n*servermode = (int)l;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_dh_special(const char *s, const char **dh_special)\\r\\n{\\r\\nif((strcmp(s, \"NULL\") == 0) || (strcmp(s, \"generate\") == 0) ||\\r\\n(strcmp(s, \"standard\") == 0)) {\\r\\n*dh_special = s;\\r\\nreturn 1;\\r\\n}\\r\\nfprintf(stderr, \"Error, '%s' is an invalid value for 'dh_special'\\n\", s);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int parse_verify_level(const char *s, unsigned int *verify_level)\\r\\n{\\r\\nunsigned long l;\\r\\nif(!int_strtoul(s, &l) || (l > 3)) {\\r\\nfprintf(stderr, \"Error, '%s' is an invalid value for \"\\r\\n\"out_verify\\n\", s);\\r\\nreturn 0;\\r\\n}\\r\\n*verify_level = (unsigned int)l;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_verify_depth(const char *s, unsigned int *verify_depth)\\r\\n{\\r\\nunsigned long l;\\r\\nif(!int_strtoul(s, &l) || (l < 1) || (l > 50)) {\\r\\nfprintf(stderr, \"Error, '%s' is an invalid value for \"\\r\\n\"verify_depth\\n\", s);\\r\\nreturn 0;\\r\\n}\\r\\n*verify_depth = (unsigned int)l;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void tunala_world_del_item(tunala_world_t *world, unsigned int idx)\\r\\n{\\r\\ntunala_item_t *item = world->tunnels + idx;\\r\\nif(item->clean_read != -1)\\r\\nclose(item->clean_read);\\r\\nif(item->clean_send != item->clean_read)\\r\\nclose(item->clean_send);\\r\\nitem->clean_read = item->clean_send = -1;\\r\\nif(item->dirty_read != -1)\\r\\nclose(item->dirty_read);\\r\\nif(item->dirty_send != item->dirty_read)\\r\\nclose(item->dirty_send);\\r\\nitem->dirty_read = item->dirty_send = -1;\\r\\nstate_machine_close(&item->sm);\\r\\nif(idx + 1 < world->tunnels_used)\\r\\nmemmove(world->tunnels + idx,\\r\\nworld->tunnels + (idx + 1),\\r\\n(world->tunnels_used - (idx + 1)) *\\r\\nsizeof(tunala_item_t));\\r\\nworld->tunnels_used--;\\r\\n}\\r\\nstatic int tunala_item_io(tunala_selector_t *selector, tunala_item_t *item)\\r\\n{\\r\\nint c_r, c_s, d_r, d_s;\\r\\nif((item->clean_read != -1) && FD_ISSET(item->clean_read,\\r\\n&selector->last_selected.excepts))\\r\\nreturn 0;\\r\\nif((item->clean_send != -1) && FD_ISSET(item->clean_send,\\r\\n&selector->last_selected.excepts))\\r\\nreturn 0;\\r\\nif((item->dirty_read != -1) && FD_ISSET(item->dirty_read,\\r\\n&selector->last_selected.excepts))\\r\\nreturn 0;\\r\\nif((item->dirty_send != -1) && FD_ISSET(item->dirty_send,\\r\\n&selector->last_selected.excepts))\\r\\nreturn 0;\\r\\nc_r = c_s = d_r = d_s = 0;\\r\\nif(item->clean_read != -1)\\r\\nc_r = FD_ISSET(item->clean_read, &selector->last_selected.reads);\\r\\nif(item->clean_send != -1)\\r\\nc_s = FD_ISSET(item->clean_send, &selector->last_selected.sends);\\r\\nif(item->dirty_read != -1)\\r\\nd_r = FD_ISSET(item->dirty_read, &selector->last_selected.reads);\\r\\nif(item->dirty_send != -1)\\r\\nd_s = FD_ISSET(item->dirty_send, &selector->last_selected.sends);\\r\\nif(!c_r && !c_s && !d_r && !d_s)\\r\\nreturn 1;\\r\\nif(c_r)\\r\\nc_r = (buffer_from_fd(state_machine_get_buffer(&item->sm,\\r\\nSM_CLEAN_IN), item->clean_read) <= 0);\\r\\nif(c_s)\\r\\nc_s = (buffer_to_fd(state_machine_get_buffer(&item->sm,\\r\\nSM_CLEAN_OUT), item->clean_send) <= 0);\\r\\nif(d_r)\\r\\nd_r = (buffer_from_fd(state_machine_get_buffer(&item->sm,\\r\\nSM_DIRTY_IN), item->dirty_read) <= 0);\\r\\nif(d_s)\\r\\nd_s = (buffer_to_fd(state_machine_get_buffer(&item->sm,\\r\\nSM_DIRTY_OUT), item->dirty_send) <= 0);\\r\\nif(c_r) {\\r\\nclose(item->clean_read);\\r\\nif(item->clean_send == item->clean_read)\\r\\nitem->clean_send = -1;\\r\\nitem->clean_read = -1;\\r\\n}\\r\\nif(c_s && (item->clean_send != -1)) {\\r\\nclose(item->clean_send);\\r\\nif(item->clean_send == item->clean_read)\\r\\nitem->clean_read = -1;\\r\\nitem->clean_send = -1;\\r\\n}\\r\\nif(d_r) {\\r\\nclose(item->dirty_read);\\r\\nif(item->dirty_send == item->dirty_read)\\r\\nitem->dirty_send = -1;\\r\\nitem->dirty_read = -1;\\r\\n}\\r\\nif(d_s && (item->dirty_send != -1)) {\\r\\nclose(item->dirty_send);\\r\\nif(item->dirty_send == item->dirty_read)\\r\\nitem->dirty_read = -1;\\r\\nitem->dirty_send = -1;\\r\\n}\\r\\nif(!state_machine_churn(&item->sm))\\r\\nreturn 0;\\r\\nif(((item->clean_read == -1) || (item->clean_send == -1)) &&\\r\\n((item->dirty_read == -1) || (item->dirty_send == -1)))\\r\\nreturn 0;\\r\\nif((item->clean_read == -1) || (item->clean_send == -1)) {\\r\\nif(!state_machine_close_clean(&item->sm))\\r\\nreturn 0;\\r\\n}\\r\\nif((item->dirty_read == -1) || (item->dirty_send == -1)) {\\r\\nif(!state_machine_close_dirty(&item->sm))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_task_c", "target": 0, "func": "static int get ( io_channel chan, char *buffer, int maxlen, int *length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = SYS$QIOW ( 0, chan, IO$_READVBLK, &iosb, 0, 0,\\r\\nbuffer, maxlen, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nif ( (status&1) == 1 ) *length = iosb.count;\\r\\nreturn status;\\r\\n}\\r\\nstatic int put ( io_channel chan, char *buffer, int length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = SYS$QIOW ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,\\r\\nbuffer, length, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nreturn status;\\r\\n}\\r\\nstatic int general_request ( io_channel chan, struct rpc_msg *msg, int length )\\r\\n{\\r\\nreturn 48;\\r\\n}\\r\\nint main ( int argc, char **argv )\\r\\n{\\r\\nint status, length;\\r\\nio_channel chan;\\r\\nstruct rpc_msg msg;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nint badop=0;\\r\\nint ret=1;\\r\\nint client_auth=0;\\r\\nint server_auth=0;\\r\\nSSL_CTX *s_ctx=NULL;\\r\\nLIB$INIT_TIMER();\\r\\nstatus = SYS$ASSIGN ( &sysnet, &chan, 0, 0, 0 );\\r\\nprintf(\"status of assign to SYS$NET: %d\\n\", status );\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE);\\r\\nif (bio_stdout == NULL)\\r\\nif ((bio_stdout=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_stdout,stdout,BIO_NOCLOSE);\\r\\nif (cipher == NULL) cipher=getenv(\"SSL_CIPHER\");\\r\\nprintf(\"cipher list: %s\\n\", cipher ? cipher : \"{undefined}\" );\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\ns_ctx=SSL_CTX_new(SSLv2_server_method());\\r\\nif (s_ctx == NULL) goto end;\\r\\nSSL_CTX_use_certificate_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);\\r\\nSSL_CTX_use_RSAPrivateKey_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);\\r\\nprintf(\"Loaded server certificate: '%s'\\n\", TEST_SERVER_CERT );\\r\\nLIB$SHOW_TIMER();\\r\\nstatus = doit ( chan, s_ctx );\\r\\nLIB$SHOW_TIMER();\\r\\nend:\\r\\nif (s_ctx != NULL) SSL_CTX_free(s_ctx);\\r\\nLIB$SHOW_TIMER();\\r\\nreturn 1;\\r\\n}\\r\\nint doit(io_channel chan, SSL_CTX *s_ctx )\\r\\n{\\r\\nint status, length, link_state;\\r\\nstruct rpc_msg msg;\\r\\nSSL *s_ssl=NULL;\\r\\nBIO *c_to_s=NULL;\\r\\nBIO *s_to_c=NULL;\\r\\nBIO *c_bio=NULL;\\r\\nBIO *s_bio=NULL;\\r\\nint i;\\r\\nint done=0;\\r\\ns_ssl=SSL_new(s_ctx);\\r\\nif (s_ssl == NULL) goto err;\\r\\nc_to_s=BIO_new(BIO_s_rtcp());\\r\\ns_to_c=BIO_new(BIO_s_rtcp());\\r\\nif ((s_to_c == NULL) || (c_to_s == NULL)) goto err;\\r\\nBIO_set_fd ( c_to_s, 0, chan );\\r\\nBIO_set_fd ( s_to_c, 0, chan );\\r\\nc_bio=BIO_new(BIO_f_ssl());\\r\\ns_bio=BIO_new(BIO_f_ssl());\\r\\nif ((c_bio == NULL) || (s_bio == NULL)) goto err;\\r\\nSSL_set_accept_state(s_ssl);\\r\\nSSL_set_bio(s_ssl,c_to_s,s_to_c);\\r\\nBIO_set_ssl(s_bio,s_ssl,BIO_CLOSE);\\r\\nprintf(\"Begin doit main loop\\n\");\\r\\nfor (link_state = 0; link_state < 3; ) {\\r\\nwhile ( link_state == 0 ) {\\r\\nstatus = get ( chan, (char *) &msg, sizeof(msg), &length );\\r\\nif ( (status&1) == 0 ) {\\r\\nprintf(\"Error in main loop get: %d\\n\", status );\\r\\nlink_state = 3;\\r\\nbreak;\\r\\n}\\r\\nif ( length < RPC_HDR_SIZE ) {\\r\\nprintf(\"Error in main loop get size: %d\\n\", length );\\r\\nbreak;\\r\\nlink_state = 3;\\r\\n}\\r\\nif ( msg.channel != 'A' ) {\\r\\nprintf(\"Error in main loop, unexpected channel: %c\\n\",\\r\\nmsg.channel );\\r\\nbreak;\\r\\nlink_state = 3;\\r\\n}\\r\\nif ( msg.function == 'G' ) {\\r\\nlink_state = 1;\\r\\n} else if ( msg.function == 'P' ) {\\r\\nlink_state = 2;\\r\\n} else if ( msg.function == 'X' ) {\\r\\nlink_state = 3;\\r\\n} else {\\r\\nlink_state = 3;\\r\\n}\\r\\n}\\r\\nif ( link_state == 1 ) {\\r\\ni = BIO_read ( s_bio, msg.data, msg.length );\\r\\nif ( i < 0 ) link_state = 3;\\r\\nelse {\\r\\nmsg.channel = 'A';\\r\\nmsg.function = 'C';\\r\\nmsg.length = i;\\r\\nstatus = put ( chan, (char *) &msg, i+RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) break;\\r\\nlink_state = 0;\\r\\n}\\r\\n} else if ( link_state == 2 ) {\\r\\ni = BIO_write ( s_bio, msg.data, msg.length );\\r\\nif ( i < 0 ) link_state = 3;\\r\\nelse {\\r\\nmsg.channel = 'A';\\r\\nmsg.function = 'C';\\r\\nmsg.length = 0;\\r\\nstatus = put ( chan, (char *) &msg, RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) break;\\r\\nlink_state = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nfprintf(stdout,\"DONE\\n\");\\r\\nerr:\\r\\ns_ssl->rbio=NULL;\\r\\ns_ssl->wbio=NULL;\\r\\nif (c_to_s != NULL) BIO_free(c_to_s);\\r\\nif (s_to_c != NULL) BIO_free(s_to_c);\\r\\nif (c_bio != NULL) BIO_free(c_bio);\\r\\nif (s_bio != NULL) BIO_free(s_bio);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_expspeed_c", "target": 0, "func": "static double Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret < 1e-3)?1e-3:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret < 0.001)?0.001:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *a,*b,*c,*r;\\r\\n#if 1\\r\\nif (!CRYPTO_set_mem_debug_functions(0,0,0,0,0))\\r\\nabort();\\r\\n#endif\\r\\nctx=BN_CTX_new();\\r\\na=BN_new();\\r\\nb=BN_new();\\r\\nc=BN_new();\\r\\nr=BN_new();\\r\\nwhile (!RAND_status())\\r\\nRAND_SEED(\"I demand a manual recount!\");\\r\\ndo_mul_exp(r,a,b,c,ctx);\\r\\nreturn 0;\\r\\n}\\r\\nvoid do_mul_exp(BIGNUM *r, BIGNUM *a, BIGNUM *b, BIGNUM *c, BN_CTX *ctx)\\r\\n{\\r\\nint i,k;\\r\\ndouble tm;\\r\\nlong num;\\r\\nnum=BASENUM;\\r\\nfor (i=NUM_START; i<NUM_SIZES; i++)\\r\\n{\\r\\n#ifdef C_PRIME\\r\\n# ifdef TEST_SQRT\\r\\nif (!BN_set_word(a, 64)) goto err;\\r\\nif (!BN_set_word(b, P_MOD_64)) goto err;\\r\\n# define ADD a\\r\\n# define REM b\\r\\n# else\\r\\n# define ADD NULL\\r\\n# define REM NULL\\r\\n# endif\\r\\nif (!BN_generate_prime(c,sizes[i],0,ADD,REM,genprime_cb,NULL)) goto err;\\r\\nputc('\\n', stderr);\\r\\nfflush(stderr);\\r\\n#endif\\r\\nfor (k=0; k<num; k++)\\r\\n{\\r\\nif (k%50 == 0)\\r\\n{\\r\\nif (!BN_pseudo_rand(a,sizes[i],1,0)) goto err;\\r\\nif (!BN_pseudo_rand(b,sizes[i],1,0)) goto err;\\r\\n#ifndef C_PRIME\\r\\nif (!BN_pseudo_rand(c,sizes[i],1,1)) goto err;\\r\\n#endif\\r\\n#ifdef TEST_SQRT\\r\\nif (!BN_mod_sqr(a,a,c,ctx)) goto err;\\r\\nif (!BN_mod_sqr(b,b,c,ctx)) goto err;\\r\\n#else\\r\\nif (!BN_nnmod(a,a,c,ctx)) goto err;\\r\\nif (!BN_nnmod(b,b,c,ctx)) goto err;\\r\\n#endif\\r\\nif (k == 0)\\r\\nTime_F(START);\\r\\n}\\r\\n#if defined(TEST_EXP)\\r\\nif (!BN_mod_exp(r,a,b,c,ctx)) goto err;\\r\\n#elif defined(TEST_MUL)\\r\\n{\\r\\nint i = 0;\\r\\nfor (i = 0; i < 50; i++)\\r\\nif (!BN_mod_mul(r,a,b,c,ctx)) goto err;\\r\\n}\\r\\n#elif defined(TEST_SQR)\\r\\n{\\r\\nint i = 0;\\r\\nfor (i = 0; i < 50; i++)\\r\\n{\\r\\nif (!BN_mod_sqr(r,a,c,ctx)) goto err;\\r\\nif (!BN_mod_sqr(r,b,c,ctx)) goto err;\\r\\n}\\r\\n}\\r\\n#elif defined(TEST_GCD)\\r\\nif (!BN_gcd(r,a,b,ctx)) goto err;\\r\\nif (!BN_gcd(r,b,c,ctx)) goto err;\\r\\nif (!BN_gcd(r,c,a,ctx)) goto err;\\r\\n#elif defined(TEST_KRON)\\r\\nif (-2 == BN_kronecker(a,b,ctx)) goto err;\\r\\nif (-2 == BN_kronecker(b,c,ctx)) goto err;\\r\\nif (-2 == BN_kronecker(c,a,ctx)) goto err;\\r\\n#elif defined(TEST_INV)\\r\\nif (!BN_mod_inverse(r,a,c,ctx)) goto err;\\r\\nif (!BN_mod_inverse(r,b,c,ctx)) goto err;\\r\\n#else\\r\\nif (!BN_mod_sqrt(r,a,c,ctx)) goto err;\\r\\nif (!BN_mod_sqrt(r,b,c,ctx)) goto err;\\r\\n#endif\\r\\n}\\r\\ntm=Time_F(STOP);\\r\\nprintf(\\r\\n#if defined(TEST_EXP)\\r\\n\"modexp %4d ^ %4d %% %4d\"\\r\\n#elif defined(TEST_MUL)\\r\\n\"50*modmul %4d %4d %4d\"\\r\\n#elif defined(TEST_SQR)\\r\\n\"100*modsqr %4d %4d %4d\"\\r\\n#elif defined(TEST_GCD)\\r\\n\"3*gcd %4d %4d %4d\"\\r\\n#elif defined(TEST_KRON)\\r\\n\"3*kronecker %4d %4d %4d\"\\r\\n#elif defined(TEST_INV)\\r\\n\"2*inv %4d %4d mod %4d\"\\r\\n#else\\r\\n\"2*sqrt [prime == %d (mod 64)] %4d %4d mod %4d\"\\r\\n#endif\\r\\n\" -> %8.6fms %5.1f (%ld)\\n\",\\r\\n#ifdef TEST_SQRT\\r\\nP_MOD_64,\\r\\n#endif\\r\\nsizes[i],sizes[i],sizes[i],tm*1000.0/num,tm*mul_c[i]/num, num);\\r\\nnum/=7;\\r\\nif (num <= 0) num=1;\\r\\n}\\r\\nreturn;\\r\\nerr:\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nstatic void genprime_cb(int p, int n, void *arg)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nputc(c, stderr);\\r\\nfflush(stderr);\\r\\n(void)n;\\r\\n(void)arg;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha_one_c", "target": 0, "func": "unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA_CTX c;\\r\\nstatic unsigned char m[SHA_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!SHA_Init(&c))\\r\\nreturn NULL;\\r\\nSHA_Update(&c,d,n);\\r\\nSHA_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_o_str_c", "target": 0, "func": "int OPENSSL_strncasecmp(const char *str1, const char *str2, size_t n)\\r\\n{\\r\\n#if defined(OPENSSL_IMPLEMENTS_strncasecmp)\\r\\nwhile (*str1 && *str2 && n)\\r\\n{\\r\\nint res = toupper(*str1) - toupper(*str2);\\r\\nif (res) return res < 0 ? -1 : 1;\\r\\nstr1++;\\r\\nstr2++;\\r\\nn--;\\r\\n}\\r\\nif (n == 0)\\r\\nreturn 0;\\r\\nif (*str1)\\r\\nreturn 1;\\r\\nif (*str2)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n#else\\r\\nreturn strncasecmp(str1, str2, n);\\r\\n#endif\\r\\n}\\r\\nint OPENSSL_strcasecmp(const char *str1, const char *str2)\\r\\n{\\r\\n#if defined(OPENSSL_IMPLEMENTS_strncasecmp)\\r\\nreturn OPENSSL_strncasecmp(str1, str2, (size_t)-1);\\r\\n#else\\r\\nreturn strcasecmp(str1, str2);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_obj_lib_c", "target": 0, "func": "ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o)\\r\\n{\\r\\nASN1_OBJECT *r;\\r\\nint i;\\r\\nchar *ln=NULL;\\r\\nif (o == NULL) return(NULL);\\r\\nif (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC))\\r\\nreturn((ASN1_OBJECT *)o);\\r\\nr=ASN1_OBJECT_new();\\r\\nif (r == NULL)\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_DUP,ERR_R_ASN1_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nr->data=OPENSSL_malloc(o->length);\\r\\nif (r->data == NULL)\\r\\ngoto err;\\r\\nmemcpy(r->data,o->data,o->length);\\r\\nr->length=o->length;\\r\\nr->nid=o->nid;\\r\\nr->ln=r->sn=NULL;\\r\\nif (o->ln != NULL)\\r\\n{\\r\\ni=strlen(o->ln)+1;\\r\\nr->ln=ln=OPENSSL_malloc(i);\\r\\nif (r->ln == NULL) goto err;\\r\\nmemcpy(ln,o->ln,i);\\r\\n}\\r\\nif (o->sn != NULL)\\r\\n{\\r\\nchar *s;\\r\\ni=strlen(o->sn)+1;\\r\\nr->sn=s=OPENSSL_malloc(i);\\r\\nif (r->sn == NULL) goto err;\\r\\nmemcpy(s,o->sn,i);\\r\\n}\\r\\nr->flags=o->flags|(ASN1_OBJECT_FLAG_DYNAMIC|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS|ASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn(r);\\r\\nerr:\\r\\nOBJerr(OBJ_F_OBJ_DUP,ERR_R_MALLOC_FAILURE);\\r\\nif (r != NULL)\\r\\n{\\r\\nif (ln != NULL) OPENSSL_free(ln);\\r\\nif (r->data != NULL) OPENSSL_free(r->data);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nreturn(NULL);\\r\\n}\\r\\nint OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b)\\r\\n{\\r\\nint ret;\\r\\nret=(a->length-b->length);\\r\\nif (ret) return(ret);\\r\\nreturn(memcmp(a->data,b->data,a->length));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_api_c", "target": 0, "func": "CONF_VALUE *_CONF_get_section(const CONF *conf, const char *section)\\r\\n{\\r\\nCONF_VALUE *v,vv;\\r\\nif ((conf == NULL) || (section == NULL)) return(NULL);\\r\\nvv.name=NULL;\\r\\nvv.section=(char *)section;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\\r\\nreturn(v);\\r\\n}\\r\\nint _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)\\r\\n{\\r\\nCONF_VALUE *v = NULL;\\r\\nSTACK_OF(CONF_VALUE) *ts;\\r\\nts = (STACK_OF(CONF_VALUE) *)section->value;\\r\\nvalue->section=section->section;\\r\\nif (!sk_CONF_VALUE_push(ts,value))\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nv = (CONF_VALUE *)lh_insert(conf->data, value);\\r\\nif (v != NULL)\\r\\n{\\r\\nsk_CONF_VALUE_delete_ptr(ts,v);\\r\\nOPENSSL_free(v->name);\\r\\nOPENSSL_free(v->value);\\r\\nOPENSSL_free(v);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *_CONF_get_string(const CONF *conf, const char *section, const char *name)\\r\\n{\\r\\nCONF_VALUE *v,vv;\\r\\nchar *p;\\r\\nif (name == NULL) return(NULL);\\r\\nif (conf != NULL)\\r\\n{\\r\\nif (section != NULL)\\r\\n{\\r\\nvv.name=(char *)name;\\r\\nvv.section=(char *)section;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\\r\\nif (v != NULL) return(v->value);\\r\\nif (strcmp(section,\"ENV\") == 0)\\r\\n{\\r\\np=Getenv(name);\\r\\nif (p != NULL) return(p);\\r\\n}\\r\\n}\\r\\nvv.section=\"default\";\\r\\nvv.name=(char *)name;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\\r\\nif (v != NULL)\\r\\nreturn(v->value);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nreturn(Getenv(name));\\r\\n}\\r\\nint _CONF_new_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nif (conf->data == NULL)\\r\\nif ((conf->data = lh_new(hash, cmp_conf)) == NULL)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid _CONF_free_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL || conf->data == NULL) return;\\r\\nconf->data->down_load=0;\\r\\nlh_doall_arg(conf->data, LHASH_DOALL_ARG_FN(value_free_hash),\\r\\nconf->data);\\r\\nlh_doall_arg(conf->data, LHASH_DOALL_ARG_FN(value_free_stack),\\r\\nconf->data);\\r\\nlh_free(conf->data);\\r\\n}\\r\\nstatic void value_free_hash(CONF_VALUE *a, LHASH *conf)\\r\\n{\\r\\nif (a->name != NULL)\\r\\n{\\r\\na=(CONF_VALUE *)lh_delete(conf,a);\\r\\n}\\r\\n}\\r\\nstatic void value_free_stack(CONF_VALUE *a, LHASH *conf)\\r\\n{\\r\\nCONF_VALUE *vv;\\r\\nSTACK *sk;\\r\\nint i;\\r\\nif (a->name != NULL) return;\\r\\nsk=(STACK *)a->value;\\r\\nfor (i=sk_num(sk)-1; i>=0; i--)\\r\\n{\\r\\nvv=(CONF_VALUE *)sk_value(sk,i);\\r\\nOPENSSL_free(vv->value);\\r\\nOPENSSL_free(vv->name);\\r\\nOPENSSL_free(vv);\\r\\n}\\r\\nif (sk != NULL) sk_free(sk);\\r\\nOPENSSL_free(a->section);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nstatic unsigned long hash(const void *v_void)\\r\\n{\\r\\nCONF_VALUE *v = (CONF_VALUE *)v_void;\\r\\nreturn((lh_strhash(v->section)<<2)^lh_strhash(v->name));\\r\\n}\\r\\nstatic int cmp_conf(const void *a_void,const void *b_void)\\r\\n{\\r\\nint i;\\r\\nCONF_VALUE *a = (CONF_VALUE *)a_void;\\r\\nCONF_VALUE *b = (CONF_VALUE *)b_void;\\r\\nif (a->section != b->section)\\r\\n{\\r\\ni=strcmp(a->section,b->section);\\r\\nif (i) return(i);\\r\\n}\\r\\nif ((a->name != NULL) && (b->name != NULL))\\r\\n{\\r\\ni=strcmp(a->name,b->name);\\r\\nreturn(i);\\r\\n}\\r\\nelse if (a->name == b->name)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((a->name == NULL)?-1:1);\\r\\n}\\r\\nCONF_VALUE *_CONF_new_section(CONF *conf, const char *section)\\r\\n{\\r\\nSTACK *sk=NULL;\\r\\nint ok=0,i;\\r\\nCONF_VALUE *v=NULL,*vv;\\r\\nif ((sk=sk_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE))) == NULL)\\r\\ngoto err;\\r\\ni=strlen(section)+1;\\r\\nif ((v->section=(char *)OPENSSL_malloc(i)) == NULL)\\r\\ngoto err;\\r\\nmemcpy(v->section,section,i);\\r\\nv->name=NULL;\\r\\nv->value=(char *)sk;\\r\\nvv=(CONF_VALUE *)lh_insert(conf->data,v);\\r\\nassert(vv == NULL);\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nif (sk != NULL) sk_free(sk);\\r\\nif (v != NULL) OPENSSL_free(v);\\r\\nv=NULL;\\r\\n}\\r\\nreturn(v);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecp_nist_c", "target": 0, "func": "const EC_METHOD *EC_GFp_nist_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_simple_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_nist_group_copy,\\r\\nec_GFp_nist_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\nec_GFp_simple_set_compressed_coordinates,\\r\\nec_GFp_simple_point2oct,\\r\\nec_GFp_simple_oct2point,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_nist_field_mul,\\r\\nec_GFp_nist_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0 };\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\ndest->field_mod_func = src->field_mod_func;\\r\\nreturn ec_GFp_simple_group_copy(dest, src);\\r\\n}\\r\\nint ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp_bn;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL) return 0;\\r\\nBN_CTX_start(ctx);\\r\\nif ((tmp_bn = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (BN_ucmp(BN_get0_nist_prime_192(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_192;\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_224(), p) == 0)\\r\\n{\\r\\n#ifndef NO_32_BIT_TYPE\\r\\ngroup->field_mod_func = BN_nist_mod_224;\\r\\n#else\\r\\nECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);\\r\\ngoto err;\\r\\n#endif\\r\\n}\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_256(), p) == 0)\\r\\n{\\r\\n#ifndef NO_32_BIT_TYPE\\r\\ngroup->field_mod_func = BN_nist_mod_256;\\r\\n#else\\r\\nECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);\\r\\ngoto err;\\r\\n#endif\\r\\n}\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_384(), p) == 0)\\r\\n{\\r\\n#ifndef NO_32_BIT_TYPE\\r\\ngroup->field_mod_func = BN_nist_mod_384;\\r\\n#else\\r\\nECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_SUPPORTED_NIST_PRIME);\\r\\ngoto err;\\r\\n#endif\\r\\n}\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_521(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_521;\\r\\nelse\\r\\n{\\r\\nECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_NIST_PRIME);\\r\\ngoto err;\\r\\n}\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nBN_CTX *ctx_new=NULL;\\r\\nif (!group || !r || !a || !b)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_NIST_FIELD_MUL, ERR_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif (!ctx)\\r\\nif ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;\\r\\nif (!BN_mul(r, a, b, ctx)) goto err;\\r\\nif (!group->field_mod_func(r, r, &group->field, ctx))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx_new);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nBN_CTX *ctx_new=NULL;\\r\\nif (!group || !r || !a)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_NIST_FIELD_SQR, EC_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif (!ctx)\\r\\nif ((ctx_new = ctx = BN_CTX_new()) == NULL) goto err;\\r\\nif (!BN_sqr(r, a, ctx)) goto err;\\r\\nif (!group->field_mod_func(r, r, &group->field, ctx))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx_new);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_skey_c", "target": 0, "func": "void CAST_set_key(CAST_KEY *key, int len, const unsigned char *data)\\r\\n{\\r\\nCAST_LONG x[16];\\r\\nCAST_LONG z[16];\\r\\nCAST_LONG k[32];\\r\\nCAST_LONG X[4],Z[4];\\r\\nCAST_LONG l,*K;\\r\\nint i;\\r\\nfor (i=0; i<16; i++) x[i]=0;\\r\\nif (len > 16) len=16;\\r\\nfor (i=0; i<len; i++)\\r\\nx[i]=data[i];\\r\\nif(len <= 10)\\r\\nkey->short_key=1;\\r\\nelse\\r\\nkey->short_key=0;\\r\\nK= &k[0];\\r\\nX[0]=((x[ 0]<<24)|(x[ 1]<<16)|(x[ 2]<<8)|x[ 3])&0xffffffffL;\\r\\nX[1]=((x[ 4]<<24)|(x[ 5]<<16)|(x[ 6]<<8)|x[ 7])&0xffffffffL;\\r\\nX[2]=((x[ 8]<<24)|(x[ 9]<<16)|(x[10]<<8)|x[11])&0xffffffffL;\\r\\nX[3]=((x[12]<<24)|(x[13]<<16)|(x[14]<<8)|x[15])&0xffffffffL;\\r\\nfor (;;)\\r\\n{\\r\\nl=X[0]^S4[x[13]]^S5[x[15]]^S6[x[12]]^S7[x[14]]^S6[x[ 8]];\\r\\nCAST_exp(l,Z,z, 0);\\r\\nl=X[2]^S4[z[ 0]]^S5[z[ 2]]^S6[z[ 1]]^S7[z[ 3]]^S7[x[10]];\\r\\nCAST_exp(l,Z,z, 4);\\r\\nl=X[3]^S4[z[ 7]]^S5[z[ 6]]^S6[z[ 5]]^S7[z[ 4]]^S4[x[ 9]];\\r\\nCAST_exp(l,Z,z, 8);\\r\\nl=X[1]^S4[z[10]]^S5[z[ 9]]^S6[z[11]]^S7[z[ 8]]^S5[x[11]];\\r\\nCAST_exp(l,Z,z,12);\\r\\nK[ 0]= S4[z[ 8]]^S5[z[ 9]]^S6[z[ 7]]^S7[z[ 6]]^S4[z[ 2]];\\r\\nK[ 1]= S4[z[10]]^S5[z[11]]^S6[z[ 5]]^S7[z[ 4]]^S5[z[ 6]];\\r\\nK[ 2]= S4[z[12]]^S5[z[13]]^S6[z[ 3]]^S7[z[ 2]]^S6[z[ 9]];\\r\\nK[ 3]= S4[z[14]]^S5[z[15]]^S6[z[ 1]]^S7[z[ 0]]^S7[z[12]];\\r\\nl=Z[2]^S4[z[ 5]]^S5[z[ 7]]^S6[z[ 4]]^S7[z[ 6]]^S6[z[ 0]];\\r\\nCAST_exp(l,X,x, 0);\\r\\nl=Z[0]^S4[x[ 0]]^S5[x[ 2]]^S6[x[ 1]]^S7[x[ 3]]^S7[z[ 2]];\\r\\nCAST_exp(l,X,x, 4);\\r\\nl=Z[1]^S4[x[ 7]]^S5[x[ 6]]^S6[x[ 5]]^S7[x[ 4]]^S4[z[ 1]];\\r\\nCAST_exp(l,X,x, 8);\\r\\nl=Z[3]^S4[x[10]]^S5[x[ 9]]^S6[x[11]]^S7[x[ 8]]^S5[z[ 3]];\\r\\nCAST_exp(l,X,x,12);\\r\\nK[ 4]= S4[x[ 3]]^S5[x[ 2]]^S6[x[12]]^S7[x[13]]^S4[x[ 8]];\\r\\nK[ 5]= S4[x[ 1]]^S5[x[ 0]]^S6[x[14]]^S7[x[15]]^S5[x[13]];\\r\\nK[ 6]= S4[x[ 7]]^S5[x[ 6]]^S6[x[ 8]]^S7[x[ 9]]^S6[x[ 3]];\\r\\nK[ 7]= S4[x[ 5]]^S5[x[ 4]]^S6[x[10]]^S7[x[11]]^S7[x[ 7]];\\r\\nl=X[0]^S4[x[13]]^S5[x[15]]^S6[x[12]]^S7[x[14]]^S6[x[ 8]];\\r\\nCAST_exp(l,Z,z, 0);\\r\\nl=X[2]^S4[z[ 0]]^S5[z[ 2]]^S6[z[ 1]]^S7[z[ 3]]^S7[x[10]];\\r\\nCAST_exp(l,Z,z, 4);\\r\\nl=X[3]^S4[z[ 7]]^S5[z[ 6]]^S6[z[ 5]]^S7[z[ 4]]^S4[x[ 9]];\\r\\nCAST_exp(l,Z,z, 8);\\r\\nl=X[1]^S4[z[10]]^S5[z[ 9]]^S6[z[11]]^S7[z[ 8]]^S5[x[11]];\\r\\nCAST_exp(l,Z,z,12);\\r\\nK[ 8]= S4[z[ 3]]^S5[z[ 2]]^S6[z[12]]^S7[z[13]]^S4[z[ 9]];\\r\\nK[ 9]= S4[z[ 1]]^S5[z[ 0]]^S6[z[14]]^S7[z[15]]^S5[z[12]];\\r\\nK[10]= S4[z[ 7]]^S5[z[ 6]]^S6[z[ 8]]^S7[z[ 9]]^S6[z[ 2]];\\r\\nK[11]= S4[z[ 5]]^S5[z[ 4]]^S6[z[10]]^S7[z[11]]^S7[z[ 6]];\\r\\nl=Z[2]^S4[z[ 5]]^S5[z[ 7]]^S6[z[ 4]]^S7[z[ 6]]^S6[z[ 0]];\\r\\nCAST_exp(l,X,x, 0);\\r\\nl=Z[0]^S4[x[ 0]]^S5[x[ 2]]^S6[x[ 1]]^S7[x[ 3]]^S7[z[ 2]];\\r\\nCAST_exp(l,X,x, 4);\\r\\nl=Z[1]^S4[x[ 7]]^S5[x[ 6]]^S6[x[ 5]]^S7[x[ 4]]^S4[z[ 1]];\\r\\nCAST_exp(l,X,x, 8);\\r\\nl=Z[3]^S4[x[10]]^S5[x[ 9]]^S6[x[11]]^S7[x[ 8]]^S5[z[ 3]];\\r\\nCAST_exp(l,X,x,12);\\r\\nK[12]= S4[x[ 8]]^S5[x[ 9]]^S6[x[ 7]]^S7[x[ 6]]^S4[x[ 3]];\\r\\nK[13]= S4[x[10]]^S5[x[11]]^S6[x[ 5]]^S7[x[ 4]]^S5[x[ 7]];\\r\\nK[14]= S4[x[12]]^S5[x[13]]^S6[x[ 3]]^S7[x[ 2]]^S6[x[ 8]];\\r\\nK[15]= S4[x[14]]^S5[x[15]]^S6[x[ 1]]^S7[x[ 0]]^S7[x[13]];\\r\\nif (K != k) break;\\r\\nK+=16;\\r\\n}\\r\\nfor (i=0; i<16; i++)\\r\\n{\\r\\nkey->data[i*2]=k[i];\\r\\nkey->data[i*2+1]=((k[i+16])+16)&0x1f;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s23_pkt_c", "target": 0, "func": "int ssl23_write_bytes(SSL *s)\\r\\n{\\r\\nint i,num,tot;\\r\\nchar *buf;\\r\\nbuf=s->init_buf->data;\\r\\ntot=s->init_off;\\r\\nnum=s->init_num;\\r\\nfor (;;)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,&(buf[tot]),num);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->init_off=tot;\\r\\ns->init_num=num;\\r\\nreturn(i);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (i == num) return(tot+i);\\r\\nnum-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nint ssl23_read_bytes(SSL *s, int n)\\r\\n{\\r\\nunsigned char *p;\\r\\nint j;\\r\\nif (s->packet_length < (unsigned int)n)\\r\\n{\\r\\np=s->packet;\\r\\nfor (;;)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\nj=BIO_read(s->rbio,(char *)&(p[s->packet_length]),\\r\\nn-s->packet_length);\\r\\nif (j <= 0)\\r\\nreturn(j);\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->packet_length+=j;\\r\\nif (s->packet_length >= (unsigned int)n)\\r\\nreturn(s->packet_length);\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_err_all_c", "target": 0, "func": "void ERR_load_crypto_strings(void)\\r\\n{\\r\\nstatic int done=0;\\r\\nif (done) return;\\r\\ndone=1;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_ERR_strings();\\r\\nERR_load_BN_strings();\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nERR_load_RSA_strings();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nERR_load_DH_strings();\\r\\n#endif\\r\\nERR_load_EVP_strings();\\r\\nERR_load_BUF_strings();\\r\\nERR_load_OBJ_strings();\\r\\nERR_load_PEM_strings();\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nERR_load_DSA_strings();\\r\\n#endif\\r\\nERR_load_X509_strings();\\r\\nERR_load_ASN1_strings();\\r\\nERR_load_CONF_strings();\\r\\nERR_load_CRYPTO_strings();\\r\\n#ifndef OPENSSL_NO_EC\\r\\nERR_load_EC_strings();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nERR_load_ECDSA_strings();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nERR_load_ECDH_strings();\\r\\n#endif\\r\\nERR_load_BIO_strings();\\r\\nERR_load_PKCS7_strings();\\r\\nERR_load_X509V3_strings();\\r\\nERR_load_PKCS12_strings();\\r\\nERR_load_RAND_strings();\\r\\nERR_load_DSO_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nERR_load_ENGINE_strings();\\r\\n#endif\\r\\nERR_load_OCSP_strings();\\r\\nERR_load_UI_strings();\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_lib_c", "target": 0, "func": "static long dtls1_default_timeout(void)\\r\\n{\\r\\nreturn(60*60*2);\\r\\n}\\r\\nSSL_METHOD *dtlsv1_base_method(void)\\r\\n{\\r\\nreturn(&DTLSv1_data);\\r\\n}\\r\\nint dtls1_new(SSL *s)\\r\\n{\\r\\nDTLS1_STATE *d1;\\r\\nif (!ssl3_new(s)) return(0);\\r\\nif ((d1=OPENSSL_malloc(sizeof *d1)) == NULL) return (0);\\r\\nmemset(d1,0, sizeof *d1);\\r\\n#if defined(OPENSSL_SYS_VMS) || defined(VMS_TEST)\\r\\nd1->bitmap.length=64;\\r\\n#else\\r\\nd1->bitmap.length=sizeof(d1->bitmap.map) * 8;\\r\\n#endif\\r\\npq_64bit_init(&(d1->bitmap.map));\\r\\npq_64bit_init(&(d1->bitmap.max_seq_num));\\r\\npq_64bit_init(&(d1->next_bitmap.map));\\r\\npq_64bit_init(&(d1->next_bitmap.max_seq_num));\\r\\nd1->unprocessed_rcds.q=pqueue_new();\\r\\nd1->processed_rcds.q=pqueue_new();\\r\\nd1->buffered_messages = pqueue_new();\\r\\nd1->sent_messages=pqueue_new();\\r\\nif ( s->server)\\r\\n{\\r\\nd1->cookie_len = sizeof(s->d1->cookie);\\r\\n}\\r\\nif( ! d1->unprocessed_rcds.q || ! d1->processed_rcds.q\\r\\n|| ! d1->buffered_messages || ! d1->sent_messages)\\r\\n{\\r\\nif ( d1->unprocessed_rcds.q) pqueue_free(d1->unprocessed_rcds.q);\\r\\nif ( d1->processed_rcds.q) pqueue_free(d1->processed_rcds.q);\\r\\nif ( d1->buffered_messages) pqueue_free(d1->buffered_messages);\\r\\nif ( d1->sent_messages) pqueue_free(d1->sent_messages);\\r\\nOPENSSL_free(d1);\\r\\nreturn (0);\\r\\n}\\r\\ns->d1=d1;\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\n}\\r\\nvoid dtls1_free(SSL *s)\\r\\n{\\r\\npitem *item = NULL;\\r\\nhm_fragment *frag = NULL;\\r\\nssl3_free(s);\\r\\nwhile( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\\r\\n{\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\n}\\r\\npqueue_free(s->d1->unprocessed_rcds.q);\\r\\nwhile( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\\r\\n{\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\n}\\r\\npqueue_free(s->d1->processed_rcds.q);\\r\\nwhile( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\\r\\n{\\r\\nfrag = (hm_fragment *)item->data;\\r\\nOPENSSL_free(frag->fragment);\\r\\nOPENSSL_free(frag);\\r\\npitem_free(item);\\r\\n}\\r\\npqueue_free(s->d1->buffered_messages);\\r\\nwhile ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\\r\\n{\\r\\nfrag = (hm_fragment *)item->data;\\r\\nOPENSSL_free(frag->fragment);\\r\\nOPENSSL_free(frag);\\r\\npitem_free(item);\\r\\n}\\r\\npqueue_free(s->d1->sent_messages);\\r\\npq_64bit_free(&(s->d1->bitmap.map));\\r\\npq_64bit_free(&(s->d1->bitmap.max_seq_num));\\r\\npq_64bit_free(&(s->d1->next_bitmap.map));\\r\\npq_64bit_free(&(s->d1->next_bitmap.max_seq_num));\\r\\nOPENSSL_free(s->d1);\\r\\n}\\r\\nvoid dtls1_clear(SSL *s)\\r\\n{\\r\\nssl3_clear(s);\\r\\ns->version=DTLS1_VERSION;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rpc_enc_c", "target": 0, "func": "int _des_crypt(char *buf, int len, struct desparams *desp)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint enc;\\r\\nDES_set_key_unchecked(&desp->des_key,&ks);\\r\\nenc=(desp->des_dir == ENCRYPT)?DES_ENCRYPT:DES_DECRYPT;\\r\\nif (desp->des_mode == CBC)\\r\\nDES_ecb_encrypt((const_DES_cblock *)desp->UDES.UDES_buf,\\r\\n(DES_cblock *)desp->UDES.UDES_buf,&ks,\\r\\nenc);\\r\\nelse\\r\\n{\\r\\nDES_ncbc_encrypt(desp->UDES.UDES_buf,desp->UDES.UDES_buf,\\r\\nlen,&ks,&desp->des_ivec,enc);\\r\\n#ifdef undef\\r\\na=(char *)&(desp->UDES.UDES_buf[len-8]);\\r\\nb=(char *)&(desp->des_ivec[0]);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n#endif\\r\\n}\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_prime_c", "target": 0, "func": "int BN_GENCB_call(BN_GENCB *cb, int a, int b)\\r\\n{\\r\\nif(!cb) return 1;\\r\\nswitch(cb->ver)\\r\\n{\\r\\ncase 1:\\r\\nif(!cb->cb.cb_1)\\r\\nreturn 1;\\r\\ncb->cb.cb_1(a, b, cb->arg);\\r\\nreturn 1;\\r\\ncase 2:\\r\\nreturn cb->cb.cb_2(a, b, cb);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,\\r\\nconst BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint found=0;\\r\\nint i,j,c1=0;\\r\\nBN_CTX *ctx;\\r\\nint checks = BN_prime_checks_for_size(bits);\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif(!t) goto err;\\r\\nloop:\\r\\nif (add == NULL)\\r\\n{\\r\\nif (!probable_prime(ret,bits)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (safe)\\r\\n{\\r\\nif (!probable_prime_dh_safe(ret,bits,add,rem,ctx))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!probable_prime_dh(ret,bits,add,rem,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 0, c1++))\\r\\ngoto err;\\r\\nif (!safe)\\r\\n{\\r\\ni=BN_is_prime_fasttest_ex(ret,checks,ctx,0,cb);\\r\\nif (i == -1) goto err;\\r\\nif (i == 0) goto loop;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(t,ret)) goto err;\\r\\nfor (i=0; i<checks; i++)\\r\\n{\\r\\nj=BN_is_prime_fasttest_ex(ret,1,ctx,0,cb);\\r\\nif (j == -1) goto err;\\r\\nif (j == 0) goto loop;\\r\\nj=BN_is_prime_fasttest_ex(t,1,ctx,0,cb);\\r\\nif (j == -1) goto err;\\r\\nif (j == 0) goto loop;\\r\\nif(!BN_GENCB_call(cb, 2, c1-1))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nfound = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn found;\\r\\n}\\r\\nint BN_is_prime_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed, BN_GENCB *cb)\\r\\n{\\r\\nreturn BN_is_prime_fasttest_ex(a, checks, ctx_passed, 0, cb);\\r\\n}\\r\\nint BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,\\r\\nint do_trial_division, BN_GENCB *cb)\\r\\n{\\r\\nint i, j, ret = -1;\\r\\nint k;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *A1, *A1_odd, *check;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nconst BIGNUM *A = NULL;\\r\\nif (BN_cmp(a, BN_value_one()) <= 0)\\r\\nreturn 0;\\r\\nif (checks == BN_prime_checks)\\r\\nchecks = BN_prime_checks_for_size(BN_num_bits(a));\\r\\nif (!BN_is_odd(a))\\r\\nreturn 0;\\r\\nif (do_trial_division)\\r\\n{\\r\\nfor (i = 1; i < NUMPRIMES; i++)\\r\\nif (BN_mod_word(a, primes[i]) == 0)\\r\\nreturn 0;\\r\\nif(!BN_GENCB_call(cb, 1, -1))\\r\\ngoto err;\\r\\n}\\r\\nif (ctx_passed != NULL)\\r\\nctx = ctx_passed;\\r\\nelse\\r\\nif ((ctx=BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nif (a->neg)\\r\\n{\\r\\nBIGNUM *t;\\r\\nif ((t = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nBN_copy(t, a);\\r\\nt->neg = 0;\\r\\nA = t;\\r\\n}\\r\\nelse\\r\\nA = a;\\r\\nA1 = BN_CTX_get(ctx);\\r\\nA1_odd = BN_CTX_get(ctx);\\r\\ncheck = BN_CTX_get(ctx);\\r\\nif (check == NULL) goto err;\\r\\nif (!BN_copy(A1, A))\\r\\ngoto err;\\r\\nif (!BN_sub_word(A1, 1))\\r\\ngoto err;\\r\\nif (BN_is_zero(A1))\\r\\n{\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nk = 1;\\r\\nwhile (!BN_is_bit_set(A1, k))\\r\\nk++;\\r\\nif (!BN_rshift(A1_odd, A1, k))\\r\\ngoto err;\\r\\nmont = BN_MONT_CTX_new();\\r\\nif (mont == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, A, ctx))\\r\\ngoto err;\\r\\nfor (i = 0; i < checks; i++)\\r\\n{\\r\\nif (!BN_pseudo_rand_range(check, A1))\\r\\ngoto err;\\r\\nif (!BN_add_word(check, 1))\\r\\ngoto err;\\r\\nj = witness(check, A, A1, A1_odd, k, ctx, mont);\\r\\nif (j == -1) goto err;\\r\\nif (j)\\r\\n{\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 1, i))\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_passed == NULL)\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,\\r\\nconst BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont)\\r\\n{\\r\\nif (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont))\\r\\nreturn -1;\\r\\nif (BN_is_one(w))\\r\\nreturn 0;\\r\\nif (BN_cmp(w, a1) == 0)\\r\\nreturn 0;\\r\\nwhile (--k)\\r\\n{\\r\\nif (!BN_mod_mul(w, w, w, a, ctx))\\r\\nreturn -1;\\r\\nif (BN_is_one(w))\\r\\nreturn 1;\\r\\nif (BN_cmp(w, a1) == 0)\\r\\nreturn 0;\\r\\n}\\r\\nbn_check_top(w);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int probable_prime(BIGNUM *rnd, int bits)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG mods[NUMPRIMES];\\r\\nBN_ULONG delta,d;\\r\\nagain:\\r\\nif (!BN_rand(rnd,bits,1,1)) return(0);\\r\\nfor (i=1; i<NUMPRIMES; i++)\\r\\nmods[i]=BN_mod_word(rnd,(BN_ULONG)primes[i]);\\r\\ndelta=0;\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif (((mods[i]+delta)%primes[i]) <= 1)\\r\\n{\\r\\nd=delta;\\r\\ndelta+=2;\\r\\nif (delta < d) goto again;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nif (!BN_add_word(rnd,delta)) return(0);\\r\\nbn_check_top(rnd);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int probable_prime_dh(BIGNUM *rnd, int bits,\\r\\nconst BIGNUM *add, const BIGNUM *rem, BN_CTX *ctx)\\r\\n{\\r\\nint i,ret=0;\\r\\nBIGNUM *t1;\\r\\nBN_CTX_start(ctx);\\r\\nif ((t1 = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_rand(rnd,bits,0,1)) goto err;\\r\\nif (!BN_mod(t1,rnd,add,ctx)) goto err;\\r\\nif (!BN_sub(rnd,rnd,t1)) goto err;\\r\\nif (rem == NULL)\\r\\n{ if (!BN_add_word(rnd,1)) goto err; }\\r\\nelse\\r\\n{ if (!BN_add(rnd,rnd,rem)) goto err; }\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif (BN_mod_word(rnd,(BN_ULONG)primes[i]) <= 1)\\r\\n{\\r\\nif (!BN_add(rnd,rnd,add)) goto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rnd);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int probable_prime_dh_safe(BIGNUM *p, int bits, const BIGNUM *padd,\\r\\nconst BIGNUM *rem, BN_CTX *ctx)\\r\\n{\\r\\nint i,ret=0;\\r\\nBIGNUM *t1,*qadd,*q;\\r\\nbits--;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nqadd = BN_CTX_get(ctx);\\r\\nif (qadd == NULL) goto err;\\r\\nif (!BN_rshift1(qadd,padd)) goto err;\\r\\nif (!BN_rand(q,bits,0,1)) goto err;\\r\\nif (!BN_mod(t1,q,qadd,ctx)) goto err;\\r\\nif (!BN_sub(q,q,t1)) goto err;\\r\\nif (rem == NULL)\\r\\n{ if (!BN_add_word(q,1)) goto err; }\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(t1,rem)) goto err;\\r\\nif (!BN_add(q,q,t1)) goto err;\\r\\n}\\r\\nif (!BN_lshift1(p,q)) goto err;\\r\\nif (!BN_add_word(p,1)) goto err;\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif ( (BN_mod_word(p,(BN_ULONG)primes[i]) == 0) ||\\r\\n(BN_mod_word(q,(BN_ULONG)primes[i]) == 0))\\r\\n{\\r\\nif (!BN_add(p,p,padd)) goto err;\\r\\nif (!BN_add(q,q,qadd)) goto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(p);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ui_err_c", "target": 0, "func": "void ERR_load_UI_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,UI_str_functs);\\r\\nERR_load_strings(0,UI_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_stack_c", "target": 0, "func": "STACK *sk_new(int (*c)(const char * const *, const char * const *))\\r\\n{\\r\\nSTACK *ret;\\r\\nint i;\\r\\nif ((ret=(STACK *)OPENSSL_malloc(sizeof(STACK))) == NULL)\\r\\ngoto err;\\r\\nif ((ret->data=(char **)OPENSSL_malloc(sizeof(char *)*MIN_NODES)) == NULL)\\r\\ngoto err;\\r\\nfor (i=0; i<MIN_NODES; i++)\\r\\nret->data[i]=NULL;\\r\\nret->comp=c;\\r\\nret->num_alloc=MIN_NODES;\\r\\nret->num=0;\\r\\nret->sorted=0;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif(ret)\\r\\nOPENSSL_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint sk_insert(STACK *st, char *data, int loc)\\r\\n{\\r\\nchar **s;\\r\\nif(st == NULL) return 0;\\r\\nif (st->num_alloc <= st->num+1)\\r\\n{\\r\\ns=(char **)OPENSSL_realloc((char *)st->data,\\r\\n(unsigned int)sizeof(char *)*st->num_alloc*2);\\r\\nif (s == NULL)\\r\\nreturn(0);\\r\\nst->data=s;\\r\\nst->num_alloc*=2;\\r\\n}\\r\\nif ((loc >= (int)st->num) || (loc < 0))\\r\\nst->data[st->num]=data;\\r\\nelse\\r\\n{\\r\\nint i;\\r\\nchar **f,**t;\\r\\nf=(char **)st->data;\\r\\nt=(char **)&(st->data[1]);\\r\\nfor (i=st->num; i>=loc; i--)\\r\\nt[i]=f[i];\\r\\n#ifdef undef\\r\\nmemmove( (char *)&(st->data[loc+1]),\\r\\n(char *)&(st->data[loc]),\\r\\nsizeof(char *)*(st->num-loc));\\r\\n#endif\\r\\nst->data[loc]=data;\\r\\n}\\r\\nst->num++;\\r\\nst->sorted=0;\\r\\nreturn(st->num);\\r\\n}\\r\\nchar *sk_delete_ptr(STACK *st, char *p)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] == p)\\r\\nreturn(sk_delete(st,i));\\r\\nreturn(NULL);\\r\\n}\\r\\nchar *sk_delete(STACK *st, int loc)\\r\\n{\\r\\nchar *ret;\\r\\nint i,j;\\r\\nif(!st || (loc < 0) || (loc >= st->num)) return NULL;\\r\\nret=st->data[loc];\\r\\nif (loc != st->num-1)\\r\\n{\\r\\nj=st->num-1;\\r\\nfor (i=loc; i<j; i++)\\r\\nst->data[i]=st->data[i+1];\\r\\n}\\r\\nst->num--;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int internal_find(STACK *st, char *data, int ret_val_options)\\r\\n{\\r\\nchar **r;\\r\\nint i;\\r\\nint (*comp_func)(const void *,const void *);\\r\\nif(st == NULL) return -1;\\r\\nif (st->comp == NULL)\\r\\n{\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] == data)\\r\\nreturn(i);\\r\\nreturn(-1);\\r\\n}\\r\\nsk_sort(st);\\r\\nif (data == NULL) return(-1);\\r\\ncomp_func=(int (*)(const void *,const void *))(st->comp);\\r\\nr=(char **)OBJ_bsearch_ex((char *)&data,(char *)st->data,\\r\\nst->num,sizeof(char *),comp_func,ret_val_options);\\r\\nif (r == NULL) return(-1);\\r\\nreturn((int)(r-st->data));\\r\\n}\\r\\nint sk_find(STACK *st, char *data)\\r\\n{\\r\\nreturn internal_find(st, data, OBJ_BSEARCH_FIRST_VALUE_ON_MATCH);\\r\\n}\\r\\nint sk_find_ex(STACK *st, char *data)\\r\\n{\\r\\nreturn internal_find(st, data, OBJ_BSEARCH_VALUE_ON_NOMATCH);\\r\\n}\\r\\nint sk_push(STACK *st, char *data)\\r\\n{\\r\\nreturn(sk_insert(st,data,st->num));\\r\\n}\\r\\nint sk_unshift(STACK *st, char *data)\\r\\n{\\r\\nreturn(sk_insert(st,data,0));\\r\\n}\\r\\nchar *sk_shift(STACK *st)\\r\\n{\\r\\nif (st == NULL) return(NULL);\\r\\nif (st->num <= 0) return(NULL);\\r\\nreturn(sk_delete(st,0));\\r\\n}\\r\\nchar *sk_pop(STACK *st)\\r\\n{\\r\\nif (st == NULL) return(NULL);\\r\\nif (st->num <= 0) return(NULL);\\r\\nreturn(sk_delete(st,st->num-1));\\r\\n}\\r\\nvoid sk_zero(STACK *st)\\r\\n{\\r\\nif (st == NULL) return;\\r\\nif (st->num <= 0) return;\\r\\nmemset((char *)st->data,0,sizeof(st->data)*st->num);\\r\\nst->num=0;\\r\\n}\\r\\nvoid sk_pop_free(STACK *st, void (*func)(void *))\\r\\n{\\r\\nint i;\\r\\nif (st == NULL) return;\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] != NULL)\\r\\nfunc(st->data[i]);\\r\\nsk_free(st);\\r\\n}\\r\\nvoid sk_free(STACK *st)\\r\\n{\\r\\nif (st == NULL) return;\\r\\nif (st->data != NULL) OPENSSL_free(st->data);\\r\\nOPENSSL_free(st);\\r\\n}\\r\\nint sk_num(const STACK *st)\\r\\n{\\r\\nif(st == NULL) return -1;\\r\\nreturn st->num;\\r\\n}\\r\\nchar *sk_value(const STACK *st, int i)\\r\\n{\\r\\nif(!st || (i < 0) || (i >= st->num)) return NULL;\\r\\nreturn st->data[i];\\r\\n}\\r\\nchar *sk_set(STACK *st, int i, char *value)\\r\\n{\\r\\nif(!st || (i < 0) || (i >= st->num)) return NULL;\\r\\nreturn (st->data[i] = value);\\r\\n}\\r\\nvoid sk_sort(STACK *st)\\r\\n{\\r\\nif (st && !st->sorted)\\r\\n{\\r\\nint (*comp_func)(const void *,const void *);\\r\\ncomp_func=(int (*)(const void *,const void *))(st->comp);\\r\\nqsort(st->data,st->num,sizeof(char *), comp_func);\\r\\nst->sorted=1;\\r\\n}\\r\\n}\\r\\nint sk_is_sorted(const STACK *st)\\r\\n{\\r\\nif (!st)\\r\\nreturn 1;\\r\\nreturn st->sorted;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_map_c", "target": 0, "func": "static int ref_cmp(const X509_POLICY_REF * const *a,\\r\\nconst X509_POLICY_REF * const *b)\\r\\n{\\r\\nreturn OBJ_cmp((*a)->subjectDomainPolicy, (*b)->subjectDomainPolicy);\\r\\n}\\r\\nstatic void policy_map_free(X509_POLICY_REF *map)\\r\\n{\\r\\nif (map->subjectDomainPolicy)\\r\\nASN1_OBJECT_free(map->subjectDomainPolicy);\\r\\nOPENSSL_free(map);\\r\\n}\\r\\nstatic X509_POLICY_REF *policy_map_find(X509_POLICY_CACHE *cache, ASN1_OBJECT *id)\\r\\n{\\r\\nX509_POLICY_REF tmp;\\r\\nint idx;\\r\\ntmp.subjectDomainPolicy = id;\\r\\nidx = sk_X509_POLICY_REF_find(cache->maps, &tmp);\\r\\nif (idx == -1)\\r\\nreturn NULL;\\r\\nreturn sk_X509_POLICY_REF_value(cache->maps, idx);\\r\\n}\\r\\nint policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\\r\\n{\\r\\nPOLICY_MAPPING *map;\\r\\nX509_POLICY_REF *ref = NULL;\\r\\nX509_POLICY_DATA *data;\\r\\nX509_POLICY_CACHE *cache = x->policy_cache;\\r\\nint i;\\r\\nint ret = 0;\\r\\nif (sk_POLICY_MAPPING_num(maps) == 0)\\r\\n{\\r\\nret = -1;\\r\\ngoto bad_mapping;\\r\\n}\\r\\ncache->maps = sk_X509_POLICY_REF_new(ref_cmp);\\r\\nfor (i = 0; i < sk_POLICY_MAPPING_num(maps); i++)\\r\\n{\\r\\nmap = sk_POLICY_MAPPING_value(maps, i);\\r\\nif ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\\r\\n|| (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy))\\r\\n{\\r\\nret = -1;\\r\\ngoto bad_mapping;\\r\\n}\\r\\nif (policy_map_find(cache, map->subjectDomainPolicy) != NULL)\\r\\n{\\r\\nret = -1;\\r\\ngoto bad_mapping;\\r\\n}\\r\\ndata = policy_cache_find_data(cache, map->issuerDomainPolicy);\\r\\nif (!data && !cache->anyPolicy)\\r\\ncontinue;\\r\\nif (!data)\\r\\n{\\r\\ndata = policy_data_new(NULL, map->issuerDomainPolicy,\\r\\ncache->anyPolicy->flags\\r\\n& POLICY_DATA_FLAG_CRITICAL);\\r\\nif (!data)\\r\\ngoto bad_mapping;\\r\\ndata->qualifier_set = cache->anyPolicy->qualifier_set;\\r\\nmap->issuerDomainPolicy = NULL;\\r\\ndata->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\\r\\ndata->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\\r\\nif (!sk_X509_POLICY_DATA_push(cache->data, data))\\r\\n{\\r\\npolicy_data_free(data);\\r\\ngoto bad_mapping;\\r\\n}\\r\\n}\\r\\nelse\\r\\ndata->flags |= POLICY_DATA_FLAG_MAPPED;\\r\\nif (!sk_ASN1_OBJECT_push(data->expected_policy_set,\\r\\nmap->subjectDomainPolicy))\\r\\ngoto bad_mapping;\\r\\nref = OPENSSL_malloc(sizeof(X509_POLICY_REF));\\r\\nif (!ref)\\r\\ngoto bad_mapping;\\r\\nref->subjectDomainPolicy = map->subjectDomainPolicy;\\r\\nmap->subjectDomainPolicy = NULL;\\r\\nref->data = data;\\r\\nif (!sk_X509_POLICY_REF_push(cache->maps, ref))\\r\\ngoto bad_mapping;\\r\\nref = NULL;\\r\\n}\\r\\nret = 1;\\r\\nbad_mapping:\\r\\nif (ret == -1)\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\nif (ref)\\r\\npolicy_map_free(ref);\\r\\nif (ret <= 0)\\r\\n{\\r\\nsk_X509_POLICY_REF_pop_free(cache->maps, policy_map_free);\\r\\ncache->maps = NULL;\\r\\n}\\r\\nsk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_purp_c", "target": 0, "func": "static int xp_cmp(const X509_PURPOSE * const *a,\\r\\nconst X509_PURPOSE * const *b)\\r\\n{\\r\\nreturn (*a)->purpose - (*b)->purpose;\\r\\n}\\r\\nint X509_check_purpose(X509 *x, int id, int ca)\\r\\n{\\r\\nint idx;\\r\\nconst X509_PURPOSE *pt;\\r\\nif(!(x->ex_flags & EXFLAG_SET)) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\nx509v3_cache_extensions(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nif(id == -1) return 1;\\r\\nidx = X509_PURPOSE_get_by_id(id);\\r\\nif(idx == -1) return -1;\\r\\npt = X509_PURPOSE_get0(idx);\\r\\nreturn pt->check_purpose(pt, x, ca);\\r\\n}\\r\\nint X509_PURPOSE_set(int *p, int purpose)\\r\\n{\\r\\nif(X509_PURPOSE_get_by_id(purpose) == -1) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);\\r\\nreturn 0;\\r\\n}\\r\\n*p = purpose;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_PURPOSE_get_count(void)\\r\\n{\\r\\nif(!xptable) return X509_PURPOSE_COUNT;\\r\\nreturn sk_X509_PURPOSE_num(xptable) + X509_PURPOSE_COUNT;\\r\\n}\\r\\nX509_PURPOSE * X509_PURPOSE_get0(int idx)\\r\\n{\\r\\nif(idx < 0) return NULL;\\r\\nif(idx < (int)X509_PURPOSE_COUNT) return xstandard + idx;\\r\\nreturn sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);\\r\\n}\\r\\nint X509_PURPOSE_get_by_sname(char *sname)\\r\\n{\\r\\nint i;\\r\\nX509_PURPOSE *xptmp;\\r\\nfor(i = 0; i < X509_PURPOSE_get_count(); i++) {\\r\\nxptmp = X509_PURPOSE_get0(i);\\r\\nif(!strcmp(xptmp->sname, sname)) return i;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nint X509_PURPOSE_get_by_id(int purpose)\\r\\n{\\r\\nX509_PURPOSE tmp;\\r\\nint idx;\\r\\nif((purpose >= X509_PURPOSE_MIN) && (purpose <= X509_PURPOSE_MAX))\\r\\nreturn purpose - X509_PURPOSE_MIN;\\r\\ntmp.purpose = purpose;\\r\\nif(!xptable) return -1;\\r\\nidx = sk_X509_PURPOSE_find(xptable, &tmp);\\r\\nif(idx == -1) return -1;\\r\\nreturn idx + X509_PURPOSE_COUNT;\\r\\n}\\r\\nint X509_PURPOSE_add(int id, int trust, int flags,\\r\\nint (*ck)(const X509_PURPOSE *, const X509 *, int),\\r\\nchar *name, char *sname, void *arg)\\r\\n{\\r\\nint idx;\\r\\nX509_PURPOSE *ptmp;\\r\\nflags &= ~X509_PURPOSE_DYNAMIC;\\r\\nflags |= X509_PURPOSE_DYNAMIC_NAME;\\r\\nidx = X509_PURPOSE_get_by_id(id);\\r\\nif(idx == -1) {\\r\\nif(!(ptmp = OPENSSL_malloc(sizeof(X509_PURPOSE)))) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nptmp->flags = X509_PURPOSE_DYNAMIC;\\r\\n} else ptmp = X509_PURPOSE_get0(idx);\\r\\nif(ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {\\r\\nOPENSSL_free(ptmp->name);\\r\\nOPENSSL_free(ptmp->sname);\\r\\n}\\r\\nptmp->name = BUF_strdup(name);\\r\\nptmp->sname = BUF_strdup(sname);\\r\\nif(!ptmp->name || !ptmp->sname) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nptmp->flags &= X509_PURPOSE_DYNAMIC;\\r\\nptmp->flags |= flags;\\r\\nptmp->purpose = id;\\r\\nptmp->trust = trust;\\r\\nptmp->check_purpose = ck;\\r\\nptmp->usr_data = arg;\\r\\nif(idx == -1) {\\r\\nif(!xptable && !(xptable = sk_X509_PURPOSE_new(xp_cmp))) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_X509_PURPOSE_push(xptable, ptmp)) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void xptable_free(X509_PURPOSE *p)\\r\\n{\\r\\nif(!p) return;\\r\\nif (p->flags & X509_PURPOSE_DYNAMIC)\\r\\n{\\r\\nif (p->flags & X509_PURPOSE_DYNAMIC_NAME) {\\r\\nOPENSSL_free(p->name);\\r\\nOPENSSL_free(p->sname);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\n}\\r\\n}\\r\\nvoid X509_PURPOSE_cleanup(void)\\r\\n{\\r\\nunsigned int i;\\r\\nsk_X509_PURPOSE_pop_free(xptable, xptable_free);\\r\\nfor(i = 0; i < X509_PURPOSE_COUNT; i++) xptable_free(xstandard + i);\\r\\nxptable = NULL;\\r\\n}\\r\\nint X509_PURPOSE_get_id(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->purpose;\\r\\n}\\r\\nchar *X509_PURPOSE_get0_name(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->name;\\r\\n}\\r\\nchar *X509_PURPOSE_get0_sname(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->sname;\\r\\n}\\r\\nint X509_PURPOSE_get_trust(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->trust;\\r\\n}\\r\\nstatic int nid_cmp(int *a, int *b)\\r\\n{\\r\\nreturn *a - *b;\\r\\n}\\r\\nint X509_supported_extension(X509_EXTENSION *ex)\\r\\n{\\r\\nstatic int supported_nids[] = {\\r\\nNID_netscape_cert_type,\\r\\nNID_key_usage,\\r\\nNID_subject_alt_name,\\r\\nNID_basic_constraints,\\r\\nNID_ext_key_usage,\\r\\nNID_proxyCertInfo\\r\\n};\\r\\nint ex_nid;\\r\\nex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));\\r\\nif (ex_nid == NID_undef)\\r\\nreturn 0;\\r\\nif (OBJ_bsearch((char *)&ex_nid, (char *)supported_nids,\\r\\nsizeof(supported_nids)/sizeof(int), sizeof(int),\\r\\n(int (*)(const void *, const void *))nid_cmp))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void x509v3_cache_extensions(X509 *x)\\r\\n{\\r\\nBASIC_CONSTRAINTS *bs;\\r\\nPROXY_CERT_INFO_EXTENSION *pci;\\r\\nASN1_BIT_STRING *usage;\\r\\nASN1_BIT_STRING *ns;\\r\\nEXTENDED_KEY_USAGE *extusage;\\r\\nX509_EXTENSION *ex;\\r\\nint i;\\r\\nif(x->ex_flags & EXFLAG_SET) return;\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nX509_digest(x, EVP_sha1(), x->sha1_hash, NULL);\\r\\n#endif\\r\\nif(!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))\\r\\nx->ex_flags |= EXFLAG_SS;\\r\\nif(!X509_get_version(x)) x->ex_flags |= EXFLAG_V1;\\r\\nif((bs=X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {\\r\\nif(bs->ca) x->ex_flags |= EXFLAG_CA;\\r\\nif(bs->pathlen) {\\r\\nif((bs->pathlen->type == V_ASN1_NEG_INTEGER)\\r\\n|| !bs->ca) {\\r\\nx->ex_flags |= EXFLAG_INVALID;\\r\\nx->ex_pathlen = 0;\\r\\n} else x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\\r\\n} else x->ex_pathlen = -1;\\r\\nBASIC_CONSTRAINTS_free(bs);\\r\\nx->ex_flags |= EXFLAG_BCONS;\\r\\n}\\r\\nif((pci=X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {\\r\\nif (x->ex_flags & EXFLAG_CA\\r\\n|| X509_get_ext_by_NID(x, NID_subject_alt_name, 0) >= 0\\r\\n|| X509_get_ext_by_NID(x, NID_issuer_alt_name, 0) >= 0) {\\r\\nx->ex_flags |= EXFLAG_INVALID;\\r\\n}\\r\\nif (pci->pcPathLengthConstraint) {\\r\\nx->ex_pcpathlen =\\r\\nASN1_INTEGER_get(pci->pcPathLengthConstraint);\\r\\n} else x->ex_pcpathlen = -1;\\r\\nPROXY_CERT_INFO_EXTENSION_free(pci);\\r\\nx->ex_flags |= EXFLAG_PROXY;\\r\\n}\\r\\nif((usage=X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {\\r\\nif(usage->length > 0) {\\r\\nx->ex_kusage = usage->data[0];\\r\\nif(usage->length > 1)\\r\\nx->ex_kusage |= usage->data[1] << 8;\\r\\n} else x->ex_kusage = 0;\\r\\nx->ex_flags |= EXFLAG_KUSAGE;\\r\\nASN1_BIT_STRING_free(usage);\\r\\n}\\r\\nx->ex_xkusage = 0;\\r\\nif((extusage=X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {\\r\\nx->ex_flags |= EXFLAG_XKUSAGE;\\r\\nfor(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\\r\\nswitch(OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage,i))) {\\r\\ncase NID_server_auth:\\r\\nx->ex_xkusage |= XKU_SSL_SERVER;\\r\\nbreak;\\r\\ncase NID_client_auth:\\r\\nx->ex_xkusage |= XKU_SSL_CLIENT;\\r\\nbreak;\\r\\ncase NID_email_protect:\\r\\nx->ex_xkusage |= XKU_SMIME;\\r\\nbreak;\\r\\ncase NID_code_sign:\\r\\nx->ex_xkusage |= XKU_CODE_SIGN;\\r\\nbreak;\\r\\ncase NID_ms_sgc:\\r\\ncase NID_ns_sgc:\\r\\nx->ex_xkusage |= XKU_SGC;\\r\\nbreak;\\r\\ncase NID_OCSP_sign:\\r\\nx->ex_xkusage |= XKU_OCSP_SIGN;\\r\\nbreak;\\r\\ncase NID_time_stamp:\\r\\nx->ex_xkusage |= XKU_TIMESTAMP;\\r\\nbreak;\\r\\ncase NID_dvcs:\\r\\nx->ex_xkusage |= XKU_DVCS;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nsk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\\r\\n}\\r\\nif((ns=X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {\\r\\nif(ns->length > 0) x->ex_nscert = ns->data[0];\\r\\nelse x->ex_nscert = 0;\\r\\nx->ex_flags |= EXFLAG_NSCERT;\\r\\nASN1_BIT_STRING_free(ns);\\r\\n}\\r\\nx->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);\\r\\nx->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);\\r\\nfor (i = 0; i < X509_get_ext_count(x); i++)\\r\\n{\\r\\nex = X509_get_ext(x, i);\\r\\nif (!X509_EXTENSION_get_critical(ex))\\r\\ncontinue;\\r\\nif (!X509_supported_extension(ex))\\r\\n{\\r\\nx->ex_flags |= EXFLAG_CRITICAL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nx->ex_flags |= EXFLAG_SET;\\r\\n}\\r\\nstatic int check_ca(const X509 *x)\\r\\n{\\r\\nif(ku_reject(x, KU_KEY_CERT_SIGN)) return 0;\\r\\nif(x->ex_flags & EXFLAG_BCONS) {\\r\\nif(x->ex_flags & EXFLAG_CA) return 1;\\r\\nelse return 0;\\r\\n} else {\\r\\nif((x->ex_flags & V1_ROOT) == V1_ROOT) return 3;\\r\\nelse if (x->ex_flags & EXFLAG_KUSAGE) return 4;\\r\\nelse if (x->ex_flags & EXFLAG_NSCERT\\r\\n&& x->ex_nscert & NS_ANY_CA) return 5;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint X509_check_ca(X509 *x)\\r\\n{\\r\\nif(!(x->ex_flags & EXFLAG_SET)) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\nx509v3_cache_extensions(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nreturn check_ca(x);\\r\\n}\\r\\nstatic int check_ssl_ca(const X509 *x)\\r\\n{\\r\\nint ca_ret;\\r\\nca_ret = check_ca(x);\\r\\nif(!ca_ret) return 0;\\r\\nif(ca_ret != 5 || x->ex_nscert & NS_SSL_CA) return ca_ret;\\r\\nelse return 0;\\r\\n}\\r\\nstatic int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nif(xku_reject(x,XKU_SSL_CLIENT)) return 0;\\r\\nif(ca) return check_ssl_ca(x);\\r\\nif(ku_reject(x,KU_DIGITAL_SIGNATURE)) return 0;\\r\\nif(ns_reject(x, NS_SSL_CLIENT)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nif(xku_reject(x,XKU_SSL_SERVER|XKU_SGC)) return 0;\\r\\nif(ca) return check_ssl_ca(x);\\r\\nif(ns_reject(x, NS_SSL_SERVER)) return 0;\\r\\nif(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_KEY_ENCIPHERMENT)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nint ret;\\r\\nret = check_purpose_ssl_server(xp, x, ca);\\r\\nif(!ret || ca) return ret;\\r\\nif(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int purpose_smime(const X509 *x, int ca)\\r\\n{\\r\\nif(xku_reject(x,XKU_SMIME)) return 0;\\r\\nif(ca) {\\r\\nint ca_ret;\\r\\nca_ret = check_ca(x);\\r\\nif(!ca_ret) return 0;\\r\\nif(ca_ret != 5 || x->ex_nscert & NS_SMIME_CA) return ca_ret;\\r\\nelse return 0;\\r\\n}\\r\\nif(x->ex_flags & EXFLAG_NSCERT) {\\r\\nif(x->ex_nscert & NS_SMIME) return 1;\\r\\nif(x->ex_nscert & NS_SSL_CLIENT) return 2;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nint ret;\\r\\nret = purpose_smime(x, ca);\\r\\nif(!ret || ca) return ret;\\r\\nif(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_NON_REPUDIATION)) return 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nint ret;\\r\\nret = purpose_smime(x, ca);\\r\\nif(!ret || ca) return ret;\\r\\nif(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nif(ca) {\\r\\nint ca_ret;\\r\\nif((ca_ret = check_ca(x)) != 2) return ca_ret;\\r\\nelse return 0;\\r\\n}\\r\\nif(ku_reject(x, KU_CRL_SIGN)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nif(ca) return check_ca(x);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int no_check(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nint X509_check_issued(X509 *issuer, X509 *subject)\\r\\n{\\r\\nif(X509_NAME_cmp(X509_get_subject_name(issuer),\\r\\nX509_get_issuer_name(subject)))\\r\\nreturn X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\\r\\nx509v3_cache_extensions(issuer);\\r\\nx509v3_cache_extensions(subject);\\r\\nif(subject->akid) {\\r\\nif(subject->akid->keyid && issuer->skid &&\\r\\nASN1_OCTET_STRING_cmp(subject->akid->keyid, issuer->skid) )\\r\\nreturn X509_V_ERR_AKID_SKID_MISMATCH;\\r\\nif(subject->akid->serial &&\\r\\nASN1_INTEGER_cmp(X509_get_serialNumber(issuer),\\r\\nsubject->akid->serial))\\r\\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\\r\\nif(subject->akid->issuer) {\\r\\nGENERAL_NAMES *gens;\\r\\nGENERAL_NAME *gen;\\r\\nX509_NAME *nm = NULL;\\r\\nint i;\\r\\ngens = subject->akid->issuer;\\r\\nfor(i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\\r\\ngen = sk_GENERAL_NAME_value(gens, i);\\r\\nif(gen->type == GEN_DIRNAME) {\\r\\nnm = gen->d.dirn;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))\\r\\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\\r\\n}\\r\\n}\\r\\nif(subject->ex_flags & EXFLAG_PROXY)\\r\\n{\\r\\nif(ku_reject(issuer, KU_DIGITAL_SIGNATURE))\\r\\nreturn X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;\\r\\n}\\r\\nelse if(ku_reject(issuer, KU_KEY_CERT_SIGN))\\r\\nreturn X509_V_ERR_KEYUSAGE_NO_CERTSIGN;\\r\\nreturn X509_V_OK;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_utctm_c", "target": 0, "func": "int ASN1_UTCTIME_check(ASN1_UTCTIME *d)\\r\\n{\\r\\nstatic int min[8]={ 0, 1, 1, 0, 0, 0, 0, 0};\\r\\nstatic int max[8]={99,12,31,23,59,59,12,59};\\r\\nchar *a;\\r\\nint n,i,l,o;\\r\\nif (d->type != V_ASN1_UTCTIME) return(0);\\r\\nl=d->length;\\r\\na=(char *)d->data;\\r\\no=0;\\r\\nif (l < 11) goto err;\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nif ((i == 5) && ((a[o] == 'Z') ||\\r\\n(a[o] == '+') || (a[o] == '-')))\\r\\n{ i++; break; }\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-'))\\r\\n{\\r\\no++;\\r\\nif (o+4 > l) goto err;\\r\\nfor (i=6; i<8; i++)\\r\\n{\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\no++;\\r\\n}\\r\\n}\\r\\nreturn(o == l);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)\\r\\n{\\r\\nASN1_UTCTIME t;\\r\\nt.type=V_ASN1_UTCTIME;\\r\\nt.length=strlen(str);\\r\\nt.data=(unsigned char *)str;\\r\\nif (ASN1_UTCTIME_check(&t))\\r\\n{\\r\\nif (s != NULL)\\r\\n{\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str,t.length))\\r\\nreturn 0;\\r\\ns->type = V_ASN1_UTCTIME;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nsize_t len = 20;\\r\\nif (s == NULL)\\r\\ns=M_ASN1_UTCTIME_new();\\r\\nif (s == NULL)\\r\\nreturn(NULL);\\r\\nts=OPENSSL_gmtime(&t, &data);\\r\\nif (ts == NULL)\\r\\nreturn(NULL);\\r\\np=(char *)s->data;\\r\\nif ((p == NULL) || ((size_t)s->length < len))\\r\\n{\\r\\np=OPENSSL_malloc(len);\\r\\nif (p == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_UTCTIME_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (s->data != NULL)\\r\\nOPENSSL_free(s->data);\\r\\ns->data=(unsigned char *)p;\\r\\n}\\r\\nBIO_snprintf(p,len,\"%02d%02d%02d%02d%02d%02dZ\",ts->tm_year%100,\\r\\nts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);\\r\\ns->length=strlen(p);\\r\\ns->type=V_ASN1_UTCTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn(s);\\r\\n}\\r\\nint ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)\\r\\n{\\r\\nstruct tm *tm;\\r\\nstruct tm data;\\r\\nint offset;\\r\\nint year;\\r\\n#define g2(p) (((p)[0]-'0')*10+(p)[1]-'0')\\r\\nif (s->data[12] == 'Z')\\r\\noffset=0;\\r\\nelse\\r\\n{\\r\\noffset = g2(s->data+13)*60+g2(s->data+15);\\r\\nif (s->data[12] == '-')\\r\\noffset = -offset;\\r\\n}\\r\\nt -= offset*60;\\r\\ntm = OPENSSL_gmtime(&t, &data);\\r\\n#define return_cmp(a,b) if ((a)<(b)) return -1; else if ((a)>(b)) return 1\\r\\nyear = g2(s->data);\\r\\nif (year < 50)\\r\\nyear += 100;\\r\\nreturn_cmp(year, tm->tm_year);\\r\\nreturn_cmp(g2(s->data+2) - 1, tm->tm_mon);\\r\\nreturn_cmp(g2(s->data+4), tm->tm_mday);\\r\\nreturn_cmp(g2(s->data+6), tm->tm_hour);\\r\\nreturn_cmp(g2(s->data+8), tm->tm_min);\\r\\nreturn_cmp(g2(s->data+10), tm->tm_sec);\\r\\n#undef g2\\r\\n#undef return_cmp\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_ecdh_c", "target": 0, "func": "void ENGINE_unregister_ECDH(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&ecdh_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_ECDH(void)\\r\\n{\\r\\nengine_table_cleanup(&ecdh_table);\\r\\n}\\r\\nint ENGINE_register_ECDH(ENGINE *e)\\r\\n{\\r\\nif(e->ecdh_meth)\\r\\nreturn engine_table_register(&ecdh_table,\\r\\nengine_unregister_all_ECDH, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_ECDH()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_ECDH(e);\\r\\n}\\r\\nint ENGINE_set_default_ECDH(ENGINE *e)\\r\\n{\\r\\nif(e->ecdh_meth)\\r\\nreturn engine_table_register(&ecdh_table,\\r\\nengine_unregister_all_ECDH, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_ECDH(void)\\r\\n{\\r\\nreturn engine_table_select(&ecdh_table, dummy_nid);\\r\\n}\\r\\nconst ECDH_METHOD *ENGINE_get_ECDH(const ENGINE *e)\\r\\n{\\r\\nreturn e->ecdh_meth;\\r\\n}\\r\\nint ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth)\\r\\n{\\r\\ne->ecdh_meth = ecdh_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_crl2p7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,badops=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile,*outfile,*prog,*certfile;\\r\\nPKCS7 *p7 = NULL;\\r\\nPKCS7_SIGNED *p7s = NULL;\\r\\nX509_CRL *crl=NULL;\\r\\nSTACK *certflst=NULL;\\r\\nSTACK_OF(X509_CRL) *crl_stack=NULL;\\r\\nSTACK_OF(X509) *cert_stack=NULL;\\r\\nint ret=1,nocrl=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-nocrl\") == 0)\\r\\n{\\r\\nnocrl=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-certfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif(!certflst) certflst = sk_new_null();\\r\\nsk_push(certflst,*(++argv));\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -certfile arg certificates file of chain to a trusted CA\\n\");\\r\\nBIO_printf(bio_err,\" (can be used more than once)\\n\");\\r\\nBIO_printf(bio_err,\" -nocrl no crl to load, just certs from '-certfile'\\n\");\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!nocrl)\\r\\n{\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\ncrl=d2i_X509_CRL_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ncrl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (crl == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((p7=PKCS7_new()) == NULL) goto end;\\r\\nif ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;\\r\\np7->type=OBJ_nid2obj(NID_pkcs7_signed);\\r\\np7->d.sign=p7s;\\r\\np7s->contents->type=OBJ_nid2obj(NID_pkcs7_data);\\r\\nif (!ASN1_INTEGER_set(p7s->version,1)) goto end;\\r\\nif ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end;\\r\\np7s->crl=crl_stack;\\r\\nif (crl != NULL)\\r\\n{\\r\\nsk_X509_CRL_push(crl_stack,crl);\\r\\ncrl=NULL;\\r\\n}\\r\\nif ((cert_stack=sk_X509_new_null()) == NULL) goto end;\\r\\np7s->cert=cert_stack;\\r\\nif(certflst) for(i = 0; i < sk_num(certflst); i++) {\\r\\ncertfile = sk_value(certflst, i);\\r\\nif (add_certs_from_file(cert_stack,certfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"error loading certificates\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nsk_free(certflst);\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_PKCS7_bio(out,p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_PKCS7(out,p7);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (p7 != NULL) PKCS7_free(p7);\\r\\nif (crl != NULL) X509_CRL_free(crl);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_info_c", "target": 0, "func": "X509_INFO *X509_INFO_new(void)\\r\\n{\\r\\nX509_INFO *ret=NULL;\\r\\nret=(X509_INFO *)OPENSSL_malloc(sizeof(X509_INFO));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_X509_INFO_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->enc_cipher.cipher=NULL;\\r\\nret->enc_len=0;\\r\\nret->enc_data=NULL;\\r\\nret->references=1;\\r\\nret->x509=NULL;\\r\\nret->crl=NULL;\\r\\nret->x_pkey=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid X509_INFO_free(X509_INFO *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_INFO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_INFO\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_INFO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->x509 != NULL) X509_free(x->x509);\\r\\nif (x->crl != NULL) X509_CRL_free(x->crl);\\r\\nif (x->x_pkey != NULL) X509_PKEY_free(x->x_pkey);\\r\\nif (x->enc_data != NULL) OPENSSL_free(x->enc_data);\\r\\nOPENSSL_free(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_bool_c", "target": 0, "func": "int i2d_ASN1_BOOLEAN(int a, unsigned char **pp)\\r\\n{\\r\\nint r;\\r\\nunsigned char *p;\\r\\nr=ASN1_object_size(0,1,V_ASN1_BOOLEAN);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,1,V_ASN1_BOOLEAN,V_ASN1_UNIVERSAL);\\r\\n*(p++)= (unsigned char)a;\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\nint d2i_ASN1_BOOLEAN(int *a, const unsigned char **pp, long length)\\r\\n{\\r\\nint ret= -1;\\r\\nconst unsigned char *p;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_BOOLEAN)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_A_BOOLEAN;\\r\\ngoto err;\\r\\n}\\r\\nif (len != 1)\\r\\n{\\r\\ni=ASN1_R_BOOLEAN_IS_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nret= (int)*(p++);\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_BOOLEAN,i);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cbc3_enc_c", "target": 0, "func": "void DES_3cbc_encrypt(DES_cblock *input, DES_cblock *output, long length,\\r\\nDES_key_schedule ks1, DES_key_schedule ks2, DES_cblock *iv1,\\r\\nDES_cblock *iv2, int enc)\\r\\n{\\r\\nint off=((int)length-1)/8;\\r\\nlong l8=((length+7)/8)*8;\\r\\nDES_cblock niv1,niv2;\\r\\nif (enc == DES_ENCRYPT)\\r\\n{\\r\\nDES_cbc_encrypt((unsigned char*)input,\\r\\n(unsigned char*)output,length,&ks1,iv1,enc);\\r\\nif (length >= sizeof(DES_cblock))\\r\\nmemcpy(niv1,output[off],sizeof(DES_cblock));\\r\\nDES_cbc_encrypt((unsigned char*)output,\\r\\n(unsigned char*)output,l8,&ks2,iv1,!enc);\\r\\nDES_cbc_encrypt((unsigned char*)output,\\r\\n(unsigned char*)output,l8,&ks1,iv2,enc);\\r\\nif (length >= sizeof(DES_cblock))\\r\\nmemcpy(niv2,output[off],sizeof(DES_cblock));\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (length >= sizeof(DES_cblock))\\r\\nmemcpy(niv2,input[off],sizeof(DES_cblock));\\r\\nDES_cbc_encrypt((unsigned char*)input,\\r\\n(unsigned char*)output,l8,&ks1,iv2,enc);\\r\\nDES_cbc_encrypt((unsigned char*)output,\\r\\n(unsigned char*)output,l8,&ks2,iv1,!enc);\\r\\nif (length >= sizeof(DES_cblock))\\r\\nmemcpy(niv1,output[off],sizeof(DES_cblock));\\r\\nDES_cbc_encrypt((unsigned char*)output,\\r\\n(unsigned char*)output,length,&ks1,iv1,enc);\\r\\n}\\r\\nmemcpy(*iv1,niv1,sizeof(DES_cblock));\\r\\nmemcpy(*iv2,niv2,sizeof(DES_cblock));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_qud_cksm_c", "target": 0, "func": "DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[],\\r\\nlong length, int out_count, DES_cblock *seed)\\r\\n{\\r\\nDES_LONG z0,z1,t0,t1;\\r\\nint i;\\r\\nlong l;\\r\\nconst unsigned char *cp;\\r\\n#ifdef _CRAY\\r\\nstruct lp_st { int a:32; int b:32; } *lp;\\r\\n#else\\r\\nDES_LONG *lp;\\r\\n#endif\\r\\nif (out_count < 1) out_count=1;\\r\\n#ifdef _CRAY\\r\\nlp = (struct lp_st *) &(output[0])[0];\\r\\n#else\\r\\nlp = (DES_LONG *) &(output[0])[0];\\r\\n#endif\\r\\nz0=Q_B0((*seed)[0])|Q_B1((*seed)[1])|Q_B2((*seed)[2])|Q_B3((*seed)[3]);\\r\\nz1=Q_B0((*seed)[4])|Q_B1((*seed)[5])|Q_B2((*seed)[6])|Q_B3((*seed)[7]);\\r\\nfor (i=0; ((i<4)&&(i<out_count)); i++)\\r\\n{\\r\\ncp=input;\\r\\nl=length;\\r\\nwhile (l > 0)\\r\\n{\\r\\nif (l > 1)\\r\\n{\\r\\nt0= (DES_LONG)(*(cp++));\\r\\nt0|=(DES_LONG)Q_B1(*(cp++));\\r\\nl--;\\r\\n}\\r\\nelse\\r\\nt0= (DES_LONG)(*(cp++));\\r\\nl--;\\r\\nt0+=z0;\\r\\nt0&=0xffffffffL;\\r\\nt1=z1;\\r\\nz0=((((t0*t0)&0xffffffffL)+((t1*t1)&0xffffffffL))\\r\\n&0xffffffffL)%0x7fffffffL;\\r\\nz1=((t0*((t1+NOISE)&0xffffffffL))&0xffffffffL)%0x7fffffffL;\\r\\n}\\r\\nif (lp != NULL)\\r\\n{\\r\\n#ifdef _CRAY\\r\\n(*lp).a = z0;\\r\\n(*lp).b = z1;\\r\\nlp++;\\r\\n#else\\r\\n*lp++ = z0;\\r\\n*lp++ = z1;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn(z0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_trs_c", "target": 0, "func": "static int tr_cmp(const X509_TRUST * const *a,\\r\\nconst X509_TRUST * const *b)\\r\\n{\\r\\nreturn (*a)->trust - (*b)->trust;\\r\\n}\\r\\nint X509_check_trust(X509 *x, int id, int flags)\\r\\n{\\r\\nX509_TRUST *pt;\\r\\nint idx;\\r\\nif(id == -1) return 1;\\r\\nidx = X509_TRUST_get_by_id(id);\\r\\nif(idx == -1) return default_trust(id, x, flags);\\r\\npt = X509_TRUST_get0(idx);\\r\\nreturn pt->check_trust(pt, x, flags);\\r\\n}\\r\\nint X509_TRUST_get_count(void)\\r\\n{\\r\\nif(!trtable) return X509_TRUST_COUNT;\\r\\nreturn sk_X509_TRUST_num(trtable) + X509_TRUST_COUNT;\\r\\n}\\r\\nX509_TRUST * X509_TRUST_get0(int idx)\\r\\n{\\r\\nif(idx < 0) return NULL;\\r\\nif(idx < (int)X509_TRUST_COUNT) return trstandard + idx;\\r\\nreturn sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);\\r\\n}\\r\\nint X509_TRUST_get_by_id(int id)\\r\\n{\\r\\nX509_TRUST tmp;\\r\\nint idx;\\r\\nif((id >= X509_TRUST_MIN) && (id <= X509_TRUST_MAX))\\r\\nreturn id - X509_TRUST_MIN;\\r\\ntmp.trust = id;\\r\\nif(!trtable) return -1;\\r\\nidx = sk_X509_TRUST_find(trtable, &tmp);\\r\\nif(idx == -1) return -1;\\r\\nreturn idx + X509_TRUST_COUNT;\\r\\n}\\r\\nint X509_TRUST_set(int *t, int trust)\\r\\n{\\r\\nif(X509_TRUST_get_by_id(trust) == -1) {\\r\\nX509err(X509_F_X509_TRUST_SET, X509_R_INVALID_TRUST);\\r\\nreturn 0;\\r\\n}\\r\\n*t = trust;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),\\r\\nchar *name, int arg1, void *arg2)\\r\\n{\\r\\nint idx;\\r\\nX509_TRUST *trtmp;\\r\\nflags &= ~X509_TRUST_DYNAMIC;\\r\\nflags |= X509_TRUST_DYNAMIC_NAME;\\r\\nidx = X509_TRUST_get_by_id(id);\\r\\nif(idx == -1) {\\r\\nif(!(trtmp = OPENSSL_malloc(sizeof(X509_TRUST)))) {\\r\\nX509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntrtmp->flags = X509_TRUST_DYNAMIC;\\r\\n} else trtmp = X509_TRUST_get0(idx);\\r\\nif(trtmp->flags & X509_TRUST_DYNAMIC_NAME) OPENSSL_free(trtmp->name);\\r\\nif(!(trtmp->name = BUF_strdup(name))) {\\r\\nX509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntrtmp->flags &= X509_TRUST_DYNAMIC;\\r\\ntrtmp->flags |= flags;\\r\\ntrtmp->trust = id;\\r\\ntrtmp->check_trust = ck;\\r\\ntrtmp->arg1 = arg1;\\r\\ntrtmp->arg2 = arg2;\\r\\nif(idx == -1) {\\r\\nif(!trtable && !(trtable = sk_X509_TRUST_new(tr_cmp))) {\\r\\nX509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_X509_TRUST_push(trtable, trtmp)) {\\r\\nX509err(X509_F_X509_TRUST_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void trtable_free(X509_TRUST *p)\\r\\n{\\r\\nif(!p) return;\\r\\nif (p->flags & X509_TRUST_DYNAMIC)\\r\\n{\\r\\nif (p->flags & X509_TRUST_DYNAMIC_NAME)\\r\\nOPENSSL_free(p->name);\\r\\nOPENSSL_free(p);\\r\\n}\\r\\n}\\r\\nvoid X509_TRUST_cleanup(void)\\r\\n{\\r\\nunsigned int i;\\r\\nfor(i = 0; i < X509_TRUST_COUNT; i++) trtable_free(trstandard + i);\\r\\nsk_X509_TRUST_pop_free(trtable, trtable_free);\\r\\ntrtable = NULL;\\r\\n}\\r\\nint X509_TRUST_get_flags(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->flags;\\r\\n}\\r\\nchar *X509_TRUST_get0_name(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->name;\\r\\n}\\r\\nint X509_TRUST_get_trust(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->trust;\\r\\n}\\r\\nstatic int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nif(x->aux && (x->aux->trust || x->aux->reject))\\r\\nreturn obj_trust(trust->arg1, x, flags);\\r\\nreturn trust_compat(trust, x, flags);\\r\\n}\\r\\nstatic int trust_1oid(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nif(x->aux) return obj_trust(trust->arg1, x, flags);\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}\\r\\nstatic int trust_compat(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif(x->ex_flags & EXFLAG_SS) return X509_TRUST_TRUSTED;\\r\\nelse return X509_TRUST_UNTRUSTED;\\r\\n}\\r\\nstatic int obj_trust(int id, X509 *x, int flags)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint i;\\r\\nX509_CERT_AUX *ax;\\r\\nax = x->aux;\\r\\nif(!ax) return X509_TRUST_UNTRUSTED;\\r\\nif(ax->reject) {\\r\\nfor(i = 0; i < sk_ASN1_OBJECT_num(ax->reject); i++) {\\r\\nobj = sk_ASN1_OBJECT_value(ax->reject, i);\\r\\nif(OBJ_obj2nid(obj) == id) return X509_TRUST_REJECTED;\\r\\n}\\r\\n}\\r\\nif(ax->trust) {\\r\\nfor(i = 0; i < sk_ASN1_OBJECT_num(ax->trust); i++) {\\r\\nobj = sk_ASN1_OBJECT_value(ax->trust, i);\\r\\nif(OBJ_obj2nid(obj) == id) return X509_TRUST_TRUSTED;\\r\\n}\\r\\n}\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_key_c", "target": 0, "func": "EC_KEY *EC_KEY_new(void)\\r\\n{\\r\\nEC_KEY *ret;\\r\\nret=(EC_KEY *)OPENSSL_malloc(sizeof(EC_KEY));\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->version = 1;\\r\\nret->group = NULL;\\r\\nret->pub_key = NULL;\\r\\nret->priv_key= NULL;\\r\\nret->enc_flag= 0;\\r\\nret->conv_form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nret->references= 1;\\r\\nret->method_data = NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nEC_KEY *EC_KEY_new_by_curve_name(int nid)\\r\\n{\\r\\nEC_KEY *ret = EC_KEY_new();\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nret->group = EC_GROUP_new_by_curve_name(nid);\\r\\nif (ret->group == NULL)\\r\\n{\\r\\nEC_KEY_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_KEY_free(EC_KEY *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL) return;\\r\\ni=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_EC);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EC_KEY\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"EC_KEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->group != NULL)\\r\\nEC_GROUP_free(r->group);\\r\\nif (r->pub_key != NULL)\\r\\nEC_POINT_free(r->pub_key);\\r\\nif (r->priv_key != NULL)\\r\\nBN_clear_free(r->priv_key);\\r\\nEC_EX_DATA_free_all_data(&r->method_data);\\r\\nOPENSSL_cleanse((void *)r, sizeof(EC_KEY));\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nEC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (dest == NULL || src == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_COPY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->group)\\r\\n{\\r\\nconst EC_METHOD *meth = EC_GROUP_method_of(src->group);\\r\\nif (dest->group)\\r\\nEC_GROUP_free(dest->group);\\r\\ndest->group = EC_GROUP_new(meth);\\r\\nif (dest->group == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_copy(dest->group, src->group))\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->pub_key && src->group)\\r\\n{\\r\\nif (dest->pub_key)\\r\\nEC_POINT_free(dest->pub_key);\\r\\ndest->pub_key = EC_POINT_new(src->group);\\r\\nif (dest->pub_key == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_copy(dest->pub_key, src->pub_key))\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->priv_key)\\r\\n{\\r\\nif (dest->priv_key == NULL)\\r\\n{\\r\\ndest->priv_key = BN_new();\\r\\nif (dest->priv_key == NULL)\\r\\nreturn NULL;\\r\\n}\\r\\nif (!BN_copy(dest->priv_key, src->priv_key))\\r\\nreturn NULL;\\r\\n}\\r\\nEC_EX_DATA_free_all_data(&dest->method_data);\\r\\nfor (d = src->method_data; d != NULL; d = d->next)\\r\\n{\\r\\nvoid *t = d->dup_func(d->data);\\r\\nif (t == NULL)\\r\\nreturn 0;\\r\\nif (!EC_EX_DATA_set_data(&dest->method_data, t, d->dup_func, d->free_func, d->clear_free_func))\\r\\nreturn 0;\\r\\n}\\r\\ndest->enc_flag = src->enc_flag;\\r\\ndest->conv_form = src->conv_form;\\r\\ndest->version = src->version;\\r\\nreturn dest;\\r\\n}\\r\\nEC_KEY *EC_KEY_dup(const EC_KEY *ec_key)\\r\\n{\\r\\nEC_KEY *ret = EC_KEY_new();\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (EC_KEY_copy(ret, ec_key) == NULL)\\r\\n{\\r\\nEC_KEY_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint EC_KEY_up_ref(EC_KEY *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_EC);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EC_KEY\",r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2)\\r\\n{\\r\\nfprintf(stderr, \"EC_KEY_up, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint EC_KEY_generate_key(EC_KEY *eckey)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *priv_key = NULL, *order = NULL;\\r\\nEC_POINT *pub_key = NULL;\\r\\nif (!eckey || !eckey->group)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((order = BN_new()) == NULL) goto err;\\r\\nif ((ctx = BN_CTX_new()) == NULL) goto err;\\r\\nif (eckey->priv_key == NULL)\\r\\n{\\r\\npriv_key = BN_new();\\r\\nif (priv_key == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\npriv_key = eckey->priv_key;\\r\\nif (!EC_GROUP_get_order(eckey->group, order, ctx))\\r\\ngoto err;\\r\\ndo\\r\\nif (!BN_rand_range(priv_key, order))\\r\\ngoto err;\\r\\nwhile (BN_is_zero(priv_key));\\r\\nif (eckey->pub_key == NULL)\\r\\n{\\r\\npub_key = EC_POINT_new(eckey->group);\\r\\nif (pub_key == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\npub_key = eckey->pub_key;\\r\\nif (!EC_POINT_mul(eckey->group, pub_key, priv_key, NULL, NULL, ctx))\\r\\ngoto err;\\r\\neckey->priv_key = priv_key;\\r\\neckey->pub_key = pub_key;\\r\\nok=1;\\r\\nerr:\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (pub_key != NULL && eckey->pub_key == NULL)\\r\\nEC_POINT_free(pub_key);\\r\\nif (priv_key != NULL && eckey->priv_key == NULL)\\r\\nBN_free(priv_key);\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nreturn(ok);\\r\\n}\\r\\nint EC_KEY_check_key(const EC_KEY *eckey)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *order = NULL;\\r\\nEC_POINT *point = NULL;\\r\\nif (!eckey || !eckey->group || !eckey->pub_key)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif ((order = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif ((point = EC_POINT_new(eckey->group)) == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_is_on_curve(eckey->group, eckey->pub_key, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(eckey->group, order, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_copy(point, eckey->pub_key))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(eckey->group, point, order, NULL, NULL, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_at_infinity(eckey->group, point))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_WRONG_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (eckey->priv_key)\\r\\n{\\r\\nif (BN_cmp(eckey->priv_key, order) >= 0)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_WRONG_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(eckey->group, point, eckey->priv_key,\\r\\nNULL, NULL, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_cmp(eckey->group, point, eckey->pub_key,\\r\\nctx) != 0)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nif (order != NULL)\\r\\nBN_free(order);\\r\\nif (point != NULL)\\r\\nEC_POINT_free(point);\\r\\nreturn(ok);\\r\\n}\\r\\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key)\\r\\n{\\r\\nreturn key->group;\\r\\n}\\r\\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group)\\r\\n{\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_free(key->group);\\r\\nkey->group = EC_GROUP_dup(group);\\r\\nreturn (key->group == NULL) ? 0 : 1;\\r\\n}\\r\\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key)\\r\\n{\\r\\nreturn key->priv_key;\\r\\n}\\r\\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *priv_key)\\r\\n{\\r\\nif (key->priv_key)\\r\\nBN_clear_free(key->priv_key);\\r\\nkey->priv_key = BN_dup(priv_key);\\r\\nreturn (key->priv_key == NULL) ? 0 : 1;\\r\\n}\\r\\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key)\\r\\n{\\r\\nreturn key->pub_key;\\r\\n}\\r\\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub_key)\\r\\n{\\r\\nif (key->pub_key != NULL)\\r\\nEC_POINT_free(key->pub_key);\\r\\nkey->pub_key = EC_POINT_dup(pub_key, key->group);\\r\\nreturn (key->pub_key == NULL) ? 0 : 1;\\r\\n}\\r\\nunsigned int EC_KEY_get_enc_flags(const EC_KEY *key)\\r\\n{\\r\\nreturn key->enc_flag;\\r\\n}\\r\\nvoid EC_KEY_set_enc_flags(EC_KEY *key, unsigned int flags)\\r\\n{\\r\\nkey->enc_flag = flags;\\r\\n}\\r\\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key)\\r\\n{\\r\\nreturn key->conv_form;\\r\\n}\\r\\nvoid EC_KEY_set_conv_form(EC_KEY *key, point_conversion_form_t cform)\\r\\n{\\r\\nkey->conv_form = cform;\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_set_point_conversion_form(key->group, cform);\\r\\n}\\r\\nvoid *EC_KEY_get_key_method_data(EC_KEY *key,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nreturn EC_EX_DATA_get_data(key->method_data, dup_func, free_func, clear_free_func);\\r\\n}\\r\\nvoid EC_KEY_insert_key_method_data(EC_KEY *key, void *data,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nEC_EXTRA_DATA *ex_data;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EC);\\r\\nex_data = EC_EX_DATA_get_data(key->method_data, dup_func, free_func, clear_free_func);\\r\\nif (ex_data == NULL)\\r\\nEC_EX_DATA_set_data(&key->method_data, data, dup_func, free_func, clear_free_func);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EC);\\r\\n}\\r\\nvoid EC_KEY_set_asn1_flag(EC_KEY *key, int flag)\\r\\n{\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_set_asn1_flag(key->group, flag);\\r\\n}\\r\\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx)\\r\\n{\\r\\nif (key->group == NULL)\\r\\nreturn 0;\\r\\nreturn EC_GROUP_precompute_mult(key->group, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_mult_c", "target": 0, "func": "static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)\\r\\n{\\r\\nEC_PRE_COMP *ret = NULL;\\r\\nif (!group)\\r\\nreturn NULL;\\r\\nret = (EC_PRE_COMP *)OPENSSL_malloc(sizeof(EC_PRE_COMP));\\r\\nif (!ret)\\r\\nreturn ret;\\r\\nret->group = group;\\r\\nret->blocksize = 8;\\r\\nret->numblocks = 0;\\r\\nret->w = 4;\\r\\nret->points = NULL;\\r\\nret->num = 0;\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *ec_pre_comp_dup(void *src_)\\r\\n{\\r\\nEC_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void ec_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->points)\\r\\n{\\r\\nEC_POINT **p;\\r\\nfor (p = pre->points; *p != NULL; p++)\\r\\nEC_POINT_free(*p);\\r\\nOPENSSL_free(pre->points);\\r\\n}\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void ec_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->points)\\r\\n{\\r\\nEC_POINT **p;\\r\\nfor (p = pre->points; *p != NULL; p++)\\r\\nEC_POINT_clear_free(*p);\\r\\nOPENSSL_cleanse(pre->points, sizeof pre->points);\\r\\nOPENSSL_free(pre->points);\\r\\n}\\r\\nOPENSSL_cleanse(pre, sizeof pre);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic signed char *compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)\\r\\n{\\r\\nint window_val;\\r\\nint ok = 0;\\r\\nsigned char *r = NULL;\\r\\nint sign = 1;\\r\\nint bit, next_bit, mask;\\r\\nsize_t len = 0, j;\\r\\nif (w <= 0 || w > 7)\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nbit = 1 << w;\\r\\nnext_bit = bit << 1;\\r\\nmask = next_bit - 1;\\r\\nif (BN_is_negative(scalar))\\r\\n{\\r\\nsign = -1;\\r\\n}\\r\\nlen = BN_num_bits(scalar);\\r\\nr = OPENSSL_malloc(len + 1);\\r\\nif (r == NULL) goto err;\\r\\nif (scalar->d == NULL || scalar->top == 0)\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwindow_val = scalar->d[0] & mask;\\r\\nj = 0;\\r\\nwhile ((window_val != 0) || (j + w + 1 < len))\\r\\n{\\r\\nint digit = 0;\\r\\nif (window_val & 1)\\r\\n{\\r\\nif (window_val & bit)\\r\\n{\\r\\ndigit = window_val - next_bit;\\r\\n#if 1\\r\\nif (j + w + 1 >= len)\\r\\n{\\r\\ndigit = window_val & (mask >> 1);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\ndigit = window_val;\\r\\n}\\r\\nif (digit <= -bit || digit >= bit || !(digit & 1))\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwindow_val -= digit;\\r\\nif (window_val != 0 && window_val != next_bit && window_val != bit)\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr[j++] = sign * digit;\\r\\nwindow_val >>= 1;\\r\\nwindow_val += bit * BN_is_bit_set(scalar, j + w);\\r\\nif (window_val > next_bit)\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (j > len + 1)\\r\\n{\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nlen = j;\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nOPENSSL_free(r);\\r\\nr = NULL;\\r\\n}\\r\\nif (ok)\\r\\n*ret_len = len;\\r\\nreturn r;\\r\\n}\\r\\nint ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nsize_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nconst EC_POINT *generator = NULL;\\r\\nEC_POINT *tmp = NULL;\\r\\nsize_t totalnum;\\r\\nsize_t blocksize = 0, numblocks = 0;\\r\\nsize_t pre_points_per_block = 0;\\r\\nsize_t i, j;\\r\\nint k;\\r\\nint r_is_inverted = 0;\\r\\nint r_is_at_infinity = 1;\\r\\nsize_t *wsize = NULL;\\r\\nsigned char **wNAF = NULL;\\r\\nsize_t *wNAF_len = NULL;\\r\\nsize_t max_len = 0;\\r\\nsize_t num_val;\\r\\nEC_POINT **val = NULL;\\r\\nEC_POINT **v;\\r\\nEC_POINT ***val_sub = NULL;\\r\\nconst EC_PRE_COMP *pre_comp = NULL;\\r\\nint num_scalar = 0;\\r\\nint ret = 0;\\r\\nif (group->meth != r->meth)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar == NULL) && (num == 0))\\r\\n{\\r\\nreturn EC_POINT_set_to_infinity(group, r);\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif (group->meth != points[i]->meth)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (scalar != NULL)\\r\\n{\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\npre_comp = EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);\\r\\nif (pre_comp && pre_comp->numblocks && (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) == 0))\\r\\n{\\r\\nblocksize = pre_comp->blocksize;\\r\\nnumblocks = (BN_num_bits(scalar) / blocksize) + 1;\\r\\nif (numblocks > pre_comp->numblocks)\\r\\nnumblocks = pre_comp->numblocks;\\r\\npre_points_per_block = 1u << (pre_comp->w - 1);\\r\\nif (pre_comp->num != (pre_comp->numblocks * pre_points_per_block))\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\npre_comp = NULL;\\r\\nnumblocks = 1;\\r\\nnum_scalar = 1;\\r\\n}\\r\\n}\\r\\ntotalnum = num + numblocks;\\r\\nwsize = OPENSSL_malloc(totalnum * sizeof wsize[0]);\\r\\nwNAF_len = OPENSSL_malloc(totalnum * sizeof wNAF_len[0]);\\r\\nwNAF = OPENSSL_malloc((totalnum + 1) * sizeof wNAF[0]);\\r\\nval_sub = OPENSSL_malloc(totalnum * sizeof val_sub[0]);\\r\\nif (!wsize || !wNAF_len || !wNAF || !val_sub)\\r\\ngoto err;\\r\\nwNAF[0] = NULL;\\r\\nnum_val = 0;\\r\\nfor (i = 0; i < num + num_scalar; i++)\\r\\n{\\r\\nsize_t bits;\\r\\nbits = i < num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);\\r\\nwsize[i] = EC_window_bits_for_scalar_size(bits);\\r\\nnum_val += 1u << (wsize[i] - 1);\\r\\nwNAF[i + 1] = NULL;\\r\\nwNAF[i] = compute_wNAF((i < num ? scalars[i] : scalar), wsize[i], &wNAF_len[i]);\\r\\nif (wNAF[i] == NULL)\\r\\ngoto err;\\r\\nif (wNAF_len[i] > max_len)\\r\\nmax_len = wNAF_len[i];\\r\\n}\\r\\nif (numblocks)\\r\\n{\\r\\nif (pre_comp == NULL)\\r\\n{\\r\\nif (num_scalar != 1)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nsigned char *tmp_wNAF = NULL;\\r\\nsize_t tmp_len = 0;\\r\\nif (num_scalar != 0)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwsize[num] = pre_comp->w;\\r\\ntmp_wNAF = compute_wNAF(scalar, wsize[num], &tmp_len);\\r\\nif (!tmp_wNAF)\\r\\ngoto err;\\r\\nif (tmp_len <= max_len)\\r\\n{\\r\\nnumblocks = 1;\\r\\ntotalnum = num + 1;\\r\\nwNAF[num] = tmp_wNAF;\\r\\nwNAF[num + 1] = NULL;\\r\\nwNAF_len[num] = tmp_len;\\r\\nif (tmp_len > max_len)\\r\\nmax_len = tmp_len;\\r\\nval_sub[num] = pre_comp->points;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsigned char *pp;\\r\\nEC_POINT **tmp_points;\\r\\nif (tmp_len < numblocks * blocksize)\\r\\n{\\r\\nnumblocks = (tmp_len + blocksize - 1) / blocksize;\\r\\nif (numblocks > pre_comp->numblocks)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntotalnum = num + numblocks;\\r\\n}\\r\\npp = tmp_wNAF;\\r\\ntmp_points = pre_comp->points;\\r\\nfor (i = num; i < totalnum; i++)\\r\\n{\\r\\nif (i < totalnum - 1)\\r\\n{\\r\\nwNAF_len[i] = blocksize;\\r\\nif (tmp_len < blocksize)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntmp_len -= blocksize;\\r\\n}\\r\\nelse\\r\\nwNAF_len[i] = tmp_len;\\r\\nwNAF[i + 1] = NULL;\\r\\nwNAF[i] = OPENSSL_malloc(wNAF_len[i]);\\r\\nif (wNAF[i] == NULL)\\r\\n{\\r\\nOPENSSL_free(tmp_wNAF);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(wNAF[i], pp, wNAF_len[i]);\\r\\nif (wNAF_len[i] > max_len)\\r\\nmax_len = wNAF_len[i];\\r\\nif (*tmp_points == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\nOPENSSL_free(tmp_wNAF);\\r\\ngoto err;\\r\\n}\\r\\nval_sub[i] = tmp_points;\\r\\ntmp_points += pre_points_per_block;\\r\\npp += blocksize;\\r\\n}\\r\\nOPENSSL_free(tmp_wNAF);\\r\\n}\\r\\n}\\r\\n}\\r\\nval = OPENSSL_malloc((num_val + 1) * sizeof val[0]);\\r\\nif (val == NULL) goto err;\\r\\nval[num_val] = NULL;\\r\\nv = val;\\r\\nfor (i = 0; i < num + num_scalar; i++)\\r\\n{\\r\\nval_sub[i] = v;\\r\\nfor (j = 0; j < (1u << (wsize[i] - 1)); j++)\\r\\n{\\r\\n*v = EC_POINT_new(group);\\r\\nif (*v == NULL) goto err;\\r\\nv++;\\r\\n}\\r\\n}\\r\\nif (!(v == val + num_val))\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(tmp = EC_POINT_new(group)))\\r\\ngoto err;\\r\\nfor (i = 0; i < num + num_scalar; i++)\\r\\n{\\r\\nif (i < num)\\r\\n{\\r\\nif (!EC_POINT_copy(val_sub[i][0], points[i])) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_copy(val_sub[i][0], generator)) goto err;\\r\\n}\\r\\nif (wsize[i] > 1)\\r\\n{\\r\\nif (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx)) goto err;\\r\\nfor (j = 1; j < (1u << (wsize[i] - 1)); j++)\\r\\n{\\r\\nif (!EC_POINT_add(group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n#if 1\\r\\nif (!EC_POINTs_make_affine(group, num_val, val, ctx))\\r\\ngoto err;\\r\\n#endif\\r\\nr_is_at_infinity = 1;\\r\\nfor (k = max_len - 1; k >= 0; k--)\\r\\n{\\r\\nif (!r_is_at_infinity)\\r\\n{\\r\\nif (!EC_POINT_dbl(group, r, r, ctx)) goto err;\\r\\n}\\r\\nfor (i = 0; i < totalnum; i++)\\r\\n{\\r\\nif (wNAF_len[i] > (size_t)k)\\r\\n{\\r\\nint digit = wNAF[i][k];\\r\\nint is_neg;\\r\\nif (digit)\\r\\n{\\r\\nis_neg = digit < 0;\\r\\nif (is_neg)\\r\\ndigit = -digit;\\r\\nif (is_neg != r_is_inverted)\\r\\n{\\r\\nif (!r_is_at_infinity)\\r\\n{\\r\\nif (!EC_POINT_invert(group, r, ctx)) goto err;\\r\\n}\\r\\nr_is_inverted = !r_is_inverted;\\r\\n}\\r\\nif (r_is_at_infinity)\\r\\n{\\r\\nif (!EC_POINT_copy(r, val_sub[i][digit >> 1])) goto err;\\r\\nr_is_at_infinity = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_add(group, r, r, val_sub[i][digit >> 1], ctx)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (r_is_at_infinity)\\r\\n{\\r\\nif (!EC_POINT_set_to_infinity(group, r)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (r_is_inverted)\\r\\nif (!EC_POINT_invert(group, r, ctx)) goto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (tmp != NULL)\\r\\nEC_POINT_free(tmp);\\r\\nif (wsize != NULL)\\r\\nOPENSSL_free(wsize);\\r\\nif (wNAF_len != NULL)\\r\\nOPENSSL_free(wNAF_len);\\r\\nif (wNAF != NULL)\\r\\n{\\r\\nsigned char **w;\\r\\nfor (w = wNAF; *w != NULL; w++)\\r\\nOPENSSL_free(*w);\\r\\nOPENSSL_free(wNAF);\\r\\n}\\r\\nif (val != NULL)\\r\\n{\\r\\nfor (v = val; *v != NULL; v++)\\r\\nEC_POINT_clear_free(*v);\\r\\nOPENSSL_free(val);\\r\\n}\\r\\nif (val_sub != NULL)\\r\\n{\\r\\nOPENSSL_free(val_sub);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_POINT *generator;\\r\\nEC_POINT *tmp_point = NULL, *base = NULL, **var;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *order;\\r\\nsize_t i, bits, w, pre_points_per_block, blocksize, numblocks, num;\\r\\nEC_POINT **points = NULL;\\r\\nEC_PRE_COMP *pre_comp;\\r\\nint ret = 0;\\r\\nEC_EX_DATA_free_data(&group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free);\\r\\nif ((pre_comp = ec_pre_comp_new(group)) == NULL)\\r\\nreturn 0;\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nif (order == NULL) goto err;\\r\\nif (!EC_GROUP_get_order(group, order, ctx)) goto err;\\r\\nif (BN_is_zero(order))\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nbits = BN_num_bits(order);\\r\\nblocksize = 8;\\r\\nw = 4;\\r\\nif (EC_window_bits_for_scalar_size(bits) > w)\\r\\n{\\r\\nw = EC_window_bits_for_scalar_size(bits);\\r\\n}\\r\\nnumblocks = (bits + blocksize - 1) / blocksize;\\r\\npre_points_per_block = 1u << (w - 1);\\r\\nnum = pre_points_per_block * numblocks;\\r\\npoints = OPENSSL_malloc(sizeof (EC_POINT*)*(num + 1));\\r\\nif (!points)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nvar = points;\\r\\nvar[num] = NULL;\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif ((var[i] = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(tmp_point = EC_POINT_new(group)) || !(base = EC_POINT_new(group)))\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_copy(base, generator))\\r\\ngoto err;\\r\\nfor (i = 0; i < numblocks; i++)\\r\\n{\\r\\nsize_t j;\\r\\nif (!EC_POINT_dbl(group, tmp_point, base, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_copy(*var++, base))\\r\\ngoto err;\\r\\nfor (j = 1; j < pre_points_per_block; j++, var++)\\r\\n{\\r\\nif (!EC_POINT_add(group, *var, tmp_point, *(var - 1), ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (i < numblocks - 1)\\r\\n{\\r\\nsize_t k;\\r\\nif (blocksize <= 2)\\r\\n{\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_dbl(group, base, tmp_point, ctx))\\r\\ngoto err;\\r\\nfor (k = 2; k < blocksize; k++)\\r\\n{\\r\\nif (!EC_POINT_dbl(group,base,base,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!EC_POINTs_make_affine(group, num, points, ctx))\\r\\ngoto err;\\r\\npre_comp->group = group;\\r\\npre_comp->blocksize = blocksize;\\r\\npre_comp->numblocks = numblocks;\\r\\npre_comp->w = w;\\r\\npre_comp->points = points;\\r\\npoints = NULL;\\r\\npre_comp->num = num;\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre_comp,\\r\\nec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free))\\r\\ngoto err;\\r\\npre_comp = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (pre_comp)\\r\\nec_pre_comp_free(pre_comp);\\r\\nif (points)\\r\\n{\\r\\nEC_POINT **p;\\r\\nfor (p = points; *p != NULL; p++)\\r\\nEC_POINT_free(*p);\\r\\nOPENSSL_free(points);\\r\\n}\\r\\nif (tmp_point)\\r\\nEC_POINT_free(tmp_point);\\r\\nif (base)\\r\\nEC_POINT_free(base);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_wNAF_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (EC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free, ec_pre_comp_clear_free) != NULL)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s23_meth_c", "target": 0, "func": "static SSL_METHOD *ssl23_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_method());\\r\\nelse if (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_data,(char *)sslv23_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv23_data.ssl_connect=ssl23_connect;\\r\\nSSLv23_data.ssl_accept=ssl23_accept;\\r\\nSSLv23_data.get_ssl_method=ssl23_get_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv23_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_null_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_null(void)\\r\\n{\\r\\nreturn(&dso_meth_null);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkread_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nFILE *fp;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *cert;\\r\\nSTACK_OF(X509) *ca = NULL;\\r\\nPKCS12 *p12;\\r\\nint i;\\r\\nif (argc != 4) {\\r\\nfprintf(stderr, \"Usage: pkread p12file password opfile\\n\");\\r\\nexit (1);\\r\\n}\\r\\nSSLeay_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nif (!(fp = fopen(argv[1], \"rb\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\np12 = d2i_PKCS12_fp(fp, NULL);\\r\\nfclose (fp);\\r\\nif (!p12) {\\r\\nfprintf(stderr, \"Error reading PKCS#12 file\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit (1);\\r\\n}\\r\\nif (!PKCS12_parse(p12, argv[2], &pkey, &cert, &ca)) {\\r\\nfprintf(stderr, \"Error parsing PKCS#12 file\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit (1);\\r\\n}\\r\\nPKCS12_free(p12);\\r\\nif (!(fp = fopen(argv[3], \"w\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nif (pkey) {\\r\\nfprintf(fp, \"***Private Key***\\n\");\\r\\nPEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, NULL, NULL);\\r\\n}\\r\\nif (cert) {\\r\\nfprintf(fp, \"***User Certificate***\\n\");\\r\\nPEM_write_X509_AUX(fp, cert);\\r\\n}\\r\\nif (ca && sk_num(ca)) {\\r\\nfprintf(fp, \"***Other Certificates***\\n\");\\r\\nfor (i = 0; i < sk_X509_num(ca); i++)\\r\\nPEM_write_X509_AUX(fp, sk_X509_value(ca, i));\\r\\n}\\r\\nfclose(fp);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_vpm_c", "target": 0, "func": "static void x509_verify_param_zero(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nif (!param)\\r\\nreturn;\\r\\nparam->name = NULL;\\r\\nparam->purpose = 0;\\r\\nparam->trust = 0;\\r\\nparam->inh_flags = X509_VP_FLAG_DEFAULT;\\r\\nparam->flags = 0;\\r\\nparam->depth = -1;\\r\\nif (param->policies)\\r\\n{\\r\\nsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\\r\\nparam->policies = NULL;\\r\\n}\\r\\n}\\r\\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)\\r\\n{\\r\\nX509_VERIFY_PARAM *param;\\r\\nparam = OPENSSL_malloc(sizeof(X509_VERIFY_PARAM));\\r\\nmemset(param, 0, sizeof(X509_VERIFY_PARAM));\\r\\nx509_verify_param_zero(param);\\r\\nreturn param;\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nx509_verify_param_zero(param);\\r\\nOPENSSL_free(param);\\r\\n}\\r\\nint X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest,\\r\\nconst X509_VERIFY_PARAM *src)\\r\\n{\\r\\nunsigned long inh_flags;\\r\\nint to_default, to_overwrite;\\r\\nif (!src)\\r\\nreturn 1;\\r\\ninh_flags = dest->inh_flags | src->inh_flags;\\r\\nif (inh_flags & X509_VP_FLAG_ONCE)\\r\\ndest->inh_flags = 0;\\r\\nif (inh_flags & X509_VP_FLAG_LOCKED)\\r\\nreturn 1;\\r\\nif (inh_flags & X509_VP_FLAG_DEFAULT)\\r\\nto_default = 1;\\r\\nelse\\r\\nto_default = 0;\\r\\nif (inh_flags & X509_VP_FLAG_OVERWRITE)\\r\\nto_overwrite = 1;\\r\\nelse\\r\\nto_overwrite = 0;\\r\\nx509_verify_param_copy(purpose, 0);\\r\\nx509_verify_param_copy(trust, 0);\\r\\nx509_verify_param_copy(depth, -1);\\r\\nif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\\r\\ndest->flags = 0;\\r\\ndest->flags |= src->flags;\\r\\nif (test_x509_verify_param_copy(policies, NULL))\\r\\n{\\r\\nif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to,\\r\\nconst X509_VERIFY_PARAM *from)\\r\\n{\\r\\nto->inh_flags |= X509_VP_FLAG_DEFAULT;\\r\\nreturn X509_VERIFY_PARAM_inherit(to, from);\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)\\r\\n{\\r\\nif (param->name)\\r\\nOPENSSL_free(param->name);\\r\\nparam->name = BUF_strdup(name);\\r\\nif (param->name)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags)\\r\\n{\\r\\nparam->flags |= flags;\\r\\nif (flags & X509_V_FLAG_POLICY_MASK)\\r\\nparam->flags |= X509_V_FLAG_POLICY_CHECK;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)\\r\\n{\\r\\nreturn X509_PURPOSE_set(&param->purpose, purpose);\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)\\r\\n{\\r\\nreturn X509_TRUST_set(&param->trust, trust);\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)\\r\\n{\\r\\nparam->depth = depth;\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)\\r\\n{\\r\\nparam->check_time = t;\\r\\nparam->flags |= X509_V_FLAG_USE_CHECK_TIME;\\r\\n}\\r\\nint X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param, ASN1_OBJECT *policy)\\r\\n{\\r\\nif (!param->policies)\\r\\n{\\r\\nparam->policies = sk_ASN1_OBJECT_new_null();\\r\\nif (!param->policies)\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_ASN1_OBJECT_push(param->policies, policy))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn param->depth;\\r\\n}\\r\\nstatic int table_cmp(const void *pa, const void *pb)\\r\\n{\\r\\nconst X509_VERIFY_PARAM *a = pa, *b = pb;\\r\\nreturn strcmp(a->name, b->name);\\r\\n}\\r\\nstatic int param_cmp(const X509_VERIFY_PARAM * const *a,\\r\\nconst X509_VERIFY_PARAM * const *b)\\r\\n{\\r\\nreturn strcmp((*a)->name, (*b)->name);\\r\\n}\\r\\nint X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nint idx;\\r\\nX509_VERIFY_PARAM *ptmp;\\r\\nif (!param_table)\\r\\n{\\r\\nparam_table = sk_X509_VERIFY_PARAM_new(param_cmp);\\r\\nif (!param_table)\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nidx = sk_X509_VERIFY_PARAM_find(param_table, param);\\r\\nif (idx != -1)\\r\\n{\\r\\nptmp = sk_X509_VERIFY_PARAM_value(param_table, idx);\\r\\nX509_VERIFY_PARAM_free(ptmp);\\r\\nsk_X509_VERIFY_PARAM_delete(param_table, idx);\\r\\n}\\r\\n}\\r\\nif (!sk_X509_VERIFY_PARAM_push(param_table, param))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nconst X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name)\\r\\n{\\r\\nint idx;\\r\\nX509_VERIFY_PARAM pm;\\r\\npm.name = (char *)name;\\r\\nif (param_table)\\r\\n{\\r\\nidx = sk_X509_VERIFY_PARAM_find(param_table, &pm);\\r\\nif (idx != -1)\\r\\nreturn sk_X509_VERIFY_PARAM_value(param_table, idx);\\r\\n}\\r\\nreturn (const X509_VERIFY_PARAM *) OBJ_bsearch((char *)&pm,\\r\\n(char *)&default_table,\\r\\nsizeof(default_table)/sizeof(X509_VERIFY_PARAM),\\r\\nsizeof(X509_VERIFY_PARAM),\\r\\ntable_cmp);\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_table_cleanup(void)\\r\\n{\\r\\nif (param_table)\\r\\nsk_X509_VERIFY_PARAM_pop_free(param_table,\\r\\nX509_VERIFY_PARAM_free);\\r\\nparam_table = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_mutl_c", "target": 0, "func": "int PKCS12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *mac, unsigned int *maclen)\\r\\n{\\r\\nconst EVP_MD *md_type;\\r\\nHMAC_CTX hmac;\\r\\nunsigned char key[PKCS12_MAC_KEY_LENGTH], *salt;\\r\\nint saltlen, iter;\\r\\nif (!PKCS7_type_is_data(p12->authsafes))\\r\\n{\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_CONTENT_TYPE_NOT_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nsalt = p12->mac->salt->data;\\r\\nsaltlen = p12->mac->salt->length;\\r\\nif (!p12->mac->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (p12->mac->iter);\\r\\nif(!(md_type =\\r\\nEVP_get_digestbyobj (p12->mac->dinfo->algor->algorithm))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nif(!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_MAC_ID, iter,\\r\\nPKCS12_MAC_KEY_LENGTH, key, md_type)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_KEY_GEN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_CTX_init(&hmac);\\r\\nHMAC_Init_ex(&hmac, key, PKCS12_MAC_KEY_LENGTH, md_type, NULL);\\r\\nHMAC_Update(&hmac, p12->authsafes->d.data->data,\\r\\np12->authsafes->d.data->length);\\r\\nHMAC_Final(&hmac, mac, maclen);\\r\\nHMAC_CTX_cleanup(&hmac);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif(p12->mac == NULL) {\\r\\nPKCS12err(PKCS12_F_PKCS12_VERIFY_MAC,PKCS12_R_MAC_ABSENT);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_VERIFY_MAC,PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif ((maclen != (unsigned int)p12->mac->dinfo->digest->length)\\r\\n|| memcmp (mac, p12->mac->dinfo->digest->data, maclen)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter, const EVP_MD *md_type)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (!md_type) md_type = EVP_sha1();\\r\\nif (PKCS12_setup_mac (p12, iter, salt, saltlen, md_type) ==\\r\\nPKCS12_ERROR) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_SETUP_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(M_ASN1_OCTET_STRING_set (p12->mac->dinfo->digest, mac, maclen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_STRING_SET_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nif (!(p12->mac = PKCS12_MAC_DATA_new())) return PKCS12_ERROR;\\r\\nif (iter > 1) {\\r\\nif(!(p12->mac->iter = M_ASN1_INTEGER_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_INTEGER_set(p12->mac->iter, iter)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!saltlen) saltlen = PKCS12_SALT_LEN;\\r\\np12->mac->salt->length = saltlen;\\r\\nif (!(p12->mac->salt->data = OPENSSL_malloc (saltlen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!salt) {\\r\\nif (RAND_pseudo_bytes (p12->mac->salt->data, saltlen) < 0)\\r\\nreturn 0;\\r\\n}\\r\\nelse memcpy (p12->mac->salt->data, salt, saltlen);\\r\\np12->mac->dinfo->algor->algorithm = OBJ_nid2obj(EVP_MD_type(md_type));\\r\\nif (!(p12->mac->dinfo->algor->parameter = ASN1_TYPE_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np12->mac->dinfo->algor->parameter->type = V_ASN1_NULL;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_loadrsa_c", "target": 0, "func": "void callback(stage,count,arg)\\r\\nint stage,count;\\r\\nchar *arg;\\r\\n{\\r\\nFILE *out;\\r\\nout=(FILE *)arg;\\r\\nfprintf(out,\"%d\",stage);\\r\\nif (stage == 3)\\r\\nfprintf(out,\"\\n\");\\r\\nfflush(out);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nRSA *rsa,*pub_rsa,*priv_rsa;\\r\\nint len;\\r\\nunsigned char buf[1024],*p;\\r\\nrsa=RSA_generate_key(512,RSA_F4,callback,(char *)stdout);\\r\\np=buf;\\r\\nlen=i2d_RSAPublicKey(rsa,&p);\\r\\nlen+=i2d_RSAPrivateKey(rsa,&p);\\r\\nprintf(\"The public and private key are now both in a char array\\n\");\\r\\nprintf(\"and are taking up %d bytes\\n\",len);\\r\\nRSA_free(rsa);\\r\\np=buf;\\r\\npub_rsa=d2i_RSAPublicKey(NULL,&p,(long)len);\\r\\nlen-=(p-buf);\\r\\npriv_rsa=d2i_RSAPrivateKey(NULL,&p,(long)len);\\r\\nif ((pub_rsa == NULL) || (priv_rsa == NULL))\\r\\nERR_print_errors_fp(stderr);\\r\\nRSA_free(pub_rsa);\\r\\nRSA_free(priv_rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_enc_c", "target": 0, "func": "int ssl2_enc_init(SSL *s, int client)\\r\\n{\\r\\nEVP_CIPHER_CTX *rs,*ws;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\nint num;\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_SSL2_ENC_INIT,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(0);\\r\\n}\\r\\ns->read_hash=md;\\r\\ns->write_hash=md;\\r\\nif ((s->enc_read_ctx == NULL) &&\\r\\n((s->enc_read_ctx=(EVP_CIPHER_CTX *)\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\nif ((s->enc_write_ctx == NULL) &&\\r\\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\nrs= s->enc_read_ctx;\\r\\nws= s->enc_write_ctx;\\r\\nEVP_CIPHER_CTX_init(rs);\\r\\nEVP_CIPHER_CTX_init(ws);\\r\\nnum=c->key_len;\\r\\ns->s2->key_material_length=num*2;\\r\\nOPENSSL_assert(s->s2->key_material_length <= sizeof s->s2->key_material);\\r\\nif (ssl2_generate_key_material(s) <= 0)\\r\\nreturn 0;\\r\\nOPENSSL_assert(c->iv_len <= (int)sizeof(s->session->key_arg));\\r\\nEVP_EncryptInit_ex(ws,c,NULL,&(s->s2->key_material[(client)?num:0]),\\r\\ns->session->key_arg);\\r\\nEVP_DecryptInit_ex(rs,c,NULL,&(s->s2->key_material[(client)?0:num]),\\r\\ns->session->key_arg);\\r\\ns->s2->read_key= &(s->s2->key_material[(client)?0:num]);\\r\\ns->s2->write_key= &(s->s2->key_material[(client)?num:0]);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL2_ENC_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl2_enc(SSL *s, int send)\\r\\n{\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs;\\r\\nif (send)\\r\\n{\\r\\nds=s->enc_write_ctx;\\r\\nl=s->s2->wlength;\\r\\n}\\r\\nelse\\r\\n{\\r\\nds=s->enc_read_ctx;\\r\\nl=s->s2->rlength;\\r\\n}\\r\\nif (ds == NULL) return;\\r\\nbs=ds->cipher->block_size;\\r\\nif (bs == 8)\\r\\nl=(l+7)/8*8;\\r\\nEVP_Cipher(ds,s->s2->mac_data,s->s2->mac_data,l);\\r\\n}\\r\\nvoid ssl2_mac(SSL *s, unsigned char *md, int send)\\r\\n{\\r\\nEVP_MD_CTX c;\\r\\nunsigned char sequence[4],*p,*sec,*act;\\r\\nunsigned long seq;\\r\\nunsigned int len;\\r\\nif (send)\\r\\n{\\r\\nseq=s->s2->write_sequence;\\r\\nsec=s->s2->write_key;\\r\\nlen=s->s2->wact_data_length;\\r\\nact=s->s2->wact_data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nseq=s->s2->read_sequence;\\r\\nsec=s->s2->read_key;\\r\\nlen=s->s2->ract_data_length;\\r\\nact=s->s2->ract_data;\\r\\n}\\r\\np= &(sequence[0]);\\r\\nl2n(seq,p);\\r\\nEVP_MD_CTX_init(&c);\\r\\nEVP_DigestInit_ex(&c, s->read_hash, NULL);\\r\\nEVP_DigestUpdate(&c,sec,\\r\\nEVP_CIPHER_CTX_key_length(s->enc_read_ctx));\\r\\nEVP_DigestUpdate(&c,act,len);\\r\\nEVP_DigestUpdate(&c,sequence,4);\\r\\nEVP_DigestFinal_ex(&c,md,NULL);\\r\\nEVP_MD_CTX_cleanup(&c);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dhparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nDH *dh=NULL;\\r\\nint i,badops=0,text=0;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nint dsaparam=0;\\r\\n#endif\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,check=0,noout=0,C=0,ret=1;\\r\\nchar *infile,*outfile,*prog;\\r\\nchar *inrand=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nint num = 0, g = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nelse if (strcmp(*argv,\"-dsaparam\") == 0)\\r\\ndsaparam=1;\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-2\") == 0)\\r\\ng=2;\\r\\nelse if (strcmp(*argv,\"-5\") == 0)\\r\\ng=5;\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse if (((sscanf(*argv,\"%d\",&num) == 0) || (num <= 0)))\\r\\ngoto bad;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] [numbits]\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nBIO_printf(bio_err,\" -dsaparam read or generate DSA parameters, convert to DH\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -check check the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -text print a text form of the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\" -2 generate parameters using 2 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\" -5 generate parameters using 5 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\" numbits number of bits in to generate (default 512)\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\" -noout no output\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (g && !num)\\r\\nnum = DEFBITS;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam)\\r\\n{\\r\\nif (g)\\r\\n{\\r\\nBIO_printf(bio_err, \"generator may not be chosen for DSA parameters\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nif (num && !g)\\r\\ng = 2;\\r\\n}\\r\\nif(num) {\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set(&cb, dh_cb, bio_err);\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam)\\r\\n{\\r\\nDSA *dsa = DSA_new();\\r\\nBIO_printf(bio_err,\"Generating DSA parameters, %d bit long prime\\n\",num);\\r\\nif(!dsa || !DSA_generate_parameters_ex(dsa, num,\\r\\nNULL, 0, NULL, NULL, &cb))\\r\\n{\\r\\nif(dsa) DSA_free(dsa);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ndh = DSA_dup_DH(dsa);\\r\\nDSA_free(dsa);\\r\\nif (dh == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\ndh = DH_new();\\r\\nBIO_printf(bio_err,\"Generating DH parameters, %d bit long safe prime, generator %d\\n\",num,g);\\r\\nBIO_printf(bio_err,\"This is going to take a long time\\n\");\\r\\nif(!dh || !DH_generate_parameters_ex(dh, num, g, &cb))\\r\\n{\\r\\nif(dh) DH_free(dh);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\n} else {\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat != FORMAT_ASN1 && informat != FORMAT_PEM)\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam)\\r\\n{\\r\\nDSA *dsa;\\r\\nif (informat == FORMAT_ASN1)\\r\\ndsa=d2i_DSAparams_bio(in,NULL);\\r\\nelse\\r\\ndsa=PEM_read_bio_DSAparams(in,NULL,NULL,NULL);\\r\\nif (dsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ndh = DSA_dup_DH(dsa);\\r\\nDSA_free(dsa);\\r\\nif (dh == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nif (informat == FORMAT_ASN1)\\r\\ndh=d2i_DHparams_bio(in,NULL);\\r\\nelse\\r\\ndh=PEM_read_bio_DHparams(in,NULL,NULL,NULL);\\r\\nif (dh == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nDHparams_print(out,dh);\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nif (!DH_check(dh,&i))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i & DH_CHECK_P_NOT_PRIME)\\r\\nprintf(\"p value is not prime\\n\");\\r\\nif (i & DH_CHECK_P_NOT_SAFE_PRIME)\\r\\nprintf(\"p value is not a safe prime\\n\");\\r\\nif (i & DH_UNABLE_TO_CHECK_GENERATOR)\\r\\nprintf(\"unable to check the generator value\\n\");\\r\\nif (i & DH_NOT_SUITABLE_GENERATOR)\\r\\nprintf(\"the g value is not a generator\\n\");\\r\\nif (i == 0)\\r\\nprintf(\"DH parameters appear to be ok.\\n\");\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nunsigned char *data;\\r\\nint len,l,bits;\\r\\nlen=BN_num_bytes(dh->p);\\r\\nbits=BN_num_bits(dh->p);\\r\\ndata=(unsigned char *)OPENSSL_malloc(len);\\r\\nif (data == NULL)\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nprintf(\"#ifndef HEADER_DH_H\\n\"\\r\\n\"#include <openssl/dh.h>\\n\"\\r\\n\"#endif\\n\");\\r\\nprintf(\"DH *get_dh%d()\\n\\t{\\n\",bits);\\r\\nl=BN_bn2bin(dh->p,data);\\r\\nprintf(\"\\tstatic unsigned char dh%d_p[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t\\t};\\n\");\\r\\nl=BN_bn2bin(dh->g,data);\\r\\nprintf(\"\\tstatic unsigned char dh%d_g[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t\\t};\\n\");\\r\\nprintf(\"\\tDH *dh;\\n\\n\");\\r\\nprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\\r\\nprintf(\"\\t\\t{ DH_free(dh); return(NULL); }\\n\");\\r\\nif (dh->length)\\r\\nprintf(\"\\tdh->length = %ld;\\n\", dh->length);\\r\\nprintf(\"\\treturn(dh);\\n\\t}\\n\");\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DHparams_bio(out,dh);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DHparams(out,dh);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (dh != NULL) DH_free(dh);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK dh_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write(cb->arg,&c,1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_spkac_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint i,badops=0, ret = 1;\\r\\nBIO *in = NULL,*out = NULL;\\r\\nint verify=0,noout=0,pubkey=0;\\r\\nchar *infile = NULL,*outfile = NULL,*prog;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nconst char *spkac = \"SPKAC\", *spksect = \"default\";\\r\\nchar *spkstr = NULL;\\r\\nchar *challenge = NULL, *keyfile = NULL;\\r\\nCONF *conf = NULL;\\r\\nNETSCAPE_SPKI *spki = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (!bio_err) bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-challenge\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nchallenge= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-spkac\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nspkac= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-spksect\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nspksect= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-pubkey\") == 0)\\r\\npubkey=1;\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\nverify=1;\\r\\nelse badops = 1;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options]\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -key arg create SPKAC using private key\\n\");\\r\\nBIO_printf(bio_err,\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -challenge arg challenge string\\n\");\\r\\nBIO_printf(bio_err,\" -spkac arg alternative SPKAC name\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't print SPKAC\\n\");\\r\\nBIO_printf(bio_err,\" -pubkey output public key\\n\");\\r\\nBIO_printf(bio_err,\" -verify verify SPKAC signature\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif(!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(keyfile) {\\r\\npkey = load_key(bio_err,\\r\\nstrcmp(keyfile, \"-\") ? keyfile : NULL,\\r\\nFORMAT_PEM, 1, passin, e, \"private key\");\\r\\nif(!pkey) {\\r\\ngoto end;\\r\\n}\\r\\nspki = NETSCAPE_SPKI_new();\\r\\nif(challenge) ASN1_STRING_set(spki->spkac->challenge,\\r\\nchallenge, (int)strlen(challenge));\\r\\nNETSCAPE_SPKI_set_pubkey(spki, pkey);\\r\\nNETSCAPE_SPKI_sign(spki, pkey, EVP_md5());\\r\\nspkstr = NETSCAPE_SPKI_b64_encode(spki);\\r\\nif (outfile) out = BIO_new_file(outfile, \"w\");\\r\\nelse {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif(!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(out, \"SPKAC=%s\\n\", spkstr);\\r\\nOPENSSL_free(spkstr);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (infile) in = BIO_new_file(infile, \"r\");\\r\\nelse in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif(!in) {\\r\\nBIO_printf(bio_err, \"Error opening input file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nconf = NCONF_new(NULL);\\r\\ni = NCONF_load_bio(conf, in, NULL);\\r\\nif(!i) {\\r\\nBIO_printf(bio_err, \"Error parsing config file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nspkstr = NCONF_get_string(conf, spksect, spkac);\\r\\nif(!spkstr) {\\r\\nBIO_printf(bio_err, \"Can't find SPKAC called \\\"%s\\\"\\n\", spkac);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nspki = NETSCAPE_SPKI_b64_decode(spkstr, -1);\\r\\nif(!spki) {\\r\\nBIO_printf(bio_err, \"Error loading SPKAC\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile) out = BIO_new_file(outfile, \"w\");\\r\\nelse {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif(!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif(!noout) NETSCAPE_SPKI_print(out, spki);\\r\\npkey = NETSCAPE_SPKI_get_pubkey(spki);\\r\\nif(verify) {\\r\\ni = NETSCAPE_SPKI_verify(spki, pkey);\\r\\nif(i) BIO_printf(bio_err, \"Signature OK\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Signature Failure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif(pubkey) PEM_write_bio_PUBKEY(out, pkey);\\r\\nret = 0;\\r\\nend:\\r\\nNCONF_free(conf);\\r\\nNETSCAPE_SPKI_free(spki);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(pkey);\\r\\nif(passin) OPENSSL_free(passin);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec2_smpl_c", "target": 0, "func": "const EC_METHOD *EC_GF2m_simple_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nNID_X9_62_characteristic_two_field,\\r\\nec_GF2m_simple_group_init,\\r\\nec_GF2m_simple_group_finish,\\r\\nec_GF2m_simple_group_clear_finish,\\r\\nec_GF2m_simple_group_copy,\\r\\nec_GF2m_simple_group_set_curve,\\r\\nec_GF2m_simple_group_get_curve,\\r\\nec_GF2m_simple_group_get_degree,\\r\\nec_GF2m_simple_group_check_discriminant,\\r\\nec_GF2m_simple_point_init,\\r\\nec_GF2m_simple_point_finish,\\r\\nec_GF2m_simple_point_clear_finish,\\r\\nec_GF2m_simple_point_copy,\\r\\nec_GF2m_simple_point_set_to_infinity,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GF2m_simple_point_set_affine_coordinates,\\r\\nec_GF2m_simple_point_get_affine_coordinates,\\r\\nec_GF2m_simple_set_compressed_coordinates,\\r\\nec_GF2m_simple_point2oct,\\r\\nec_GF2m_simple_oct2point,\\r\\nec_GF2m_simple_add,\\r\\nec_GF2m_simple_dbl,\\r\\nec_GF2m_simple_invert,\\r\\nec_GF2m_simple_is_at_infinity,\\r\\nec_GF2m_simple_is_on_curve,\\r\\nec_GF2m_simple_cmp,\\r\\nec_GF2m_simple_make_affine,\\r\\nec_GF2m_simple_points_make_affine,\\r\\nec_GF2m_simple_mul,\\r\\nec_GF2m_precompute_mult,\\r\\nec_GF2m_have_precompute_mult,\\r\\nec_GF2m_simple_field_mul,\\r\\nec_GF2m_simple_field_sqr,\\r\\nec_GF2m_simple_field_div,\\r\\n0 ,\\r\\n0 ,\\r\\n0 };\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_init(EC_GROUP *group)\\r\\n{\\r\\nBN_init(&group->field);\\r\\nBN_init(&group->a);\\r\\nBN_init(&group->b);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GF2m_simple_group_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_free(&group->field);\\r\\nBN_free(&group->a);\\r\\nBN_free(&group->b);\\r\\n}\\r\\nvoid ec_GF2m_simple_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_clear_free(&group->field);\\r\\nBN_clear_free(&group->a);\\r\\nBN_clear_free(&group->b);\\r\\ngroup->poly[0] = 0;\\r\\ngroup->poly[1] = 0;\\r\\ngroup->poly[2] = 0;\\r\\ngroup->poly[3] = 0;\\r\\ngroup->poly[4] = 0;\\r\\n}\\r\\nint ec_GF2m_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nint i;\\r\\nif (!BN_copy(&dest->field, &src->field)) return 0;\\r\\nif (!BN_copy(&dest->a, &src->a)) return 0;\\r\\nif (!BN_copy(&dest->b, &src->b)) return 0;\\r\\ndest->poly[0] = src->poly[0];\\r\\ndest->poly[1] = src->poly[1];\\r\\ndest->poly[2] = src->poly[2];\\r\\ndest->poly[3] = src->poly[3];\\r\\ndest->poly[4] = src->poly[4];\\r\\nbn_wexpand(&dest->a, (int)(dest->poly[0] + BN_BITS2 - 1) / BN_BITS2);\\r\\nbn_wexpand(&dest->b, (int)(dest->poly[0] + BN_BITS2 - 1) / BN_BITS2);\\r\\nfor (i = dest->a.top; i < dest->a.dmax; i++) dest->a.d[i] = 0;\\r\\nfor (i = dest->b.top; i < dest->b.dmax; i++) dest->b.d[i] = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_group_set_curve(EC_GROUP *group,\\r\\nconst BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, i;\\r\\nif (!BN_copy(&group->field, p)) goto err;\\r\\ni = BN_GF2m_poly2arr(&group->field, group->poly, 5);\\r\\nif ((i != 5) && (i != 3))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE, EC_R_UNSUPPORTED_FIELD);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GF2m_mod_arr(&group->a, a, group->poly)) goto err;\\r\\nbn_wexpand(&group->a, (int)(group->poly[0] + BN_BITS2 - 1) / BN_BITS2);\\r\\nfor (i = group->a.top; i < group->a.dmax; i++) group->a.d[i] = 0;\\r\\nif (!BN_GF2m_mod_arr(&group->b, b, group->poly)) goto err;\\r\\nbn_wexpand(&group->b, (int)(group->poly[0] + BN_BITS2 - 1) / BN_BITS2);\\r\\nfor (i = group->b.top; i < group->b.dmax; i++) group->b.d[i] = 0;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (p != NULL)\\r\\n{\\r\\nif (!BN_copy(p, &group->field)) return 0;\\r\\n}\\r\\nif (a != NULL)\\r\\n{\\r\\nif (!BN_copy(a, &group->a)) goto err;\\r\\n}\\r\\nif (b != NULL)\\r\\n{\\r\\nif (!BN_copy(b, &group->b)) goto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nreturn BN_num_bits(&group->field)-1;\\r\\n}\\r\\nint ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *b;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nif (b == NULL) goto err;\\r\\nif (!BN_GF2m_mod_arr(b, &group->b, group->poly)) goto err;\\r\\nif (BN_is_zero(b)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_point_init(EC_POINT *point)\\r\\n{\\r\\nBN_init(&point->X);\\r\\nBN_init(&point->Y);\\r\\nBN_init(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GF2m_simple_point_finish(EC_POINT *point)\\r\\n{\\r\\nBN_free(&point->X);\\r\\nBN_free(&point->Y);\\r\\nBN_free(&point->Z);\\r\\n}\\r\\nvoid ec_GF2m_simple_point_clear_finish(EC_POINT *point)\\r\\n{\\r\\nBN_clear_free(&point->X);\\r\\nBN_clear_free(&point->Y);\\r\\nBN_clear_free(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\n}\\r\\nint ec_GF2m_simple_point_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (!BN_copy(&dest->X, &src->X)) return 0;\\r\\nif (!BN_copy(&dest->Y, &src->Y)) return 0;\\r\\nif (!BN_copy(&dest->Z, &src->Z)) return 0;\\r\\ndest->Z_is_one = src->Z_is_one;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *group, EC_POINT *point)\\r\\n{\\r\\npoint->Z_is_one = 0;\\r\\nBN_zero(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (x == NULL || y == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!BN_copy(&point->X, x)) goto err;\\r\\nBN_set_negative(&point->X, 0);\\r\\nif (!BN_copy(&point->Y, y)) goto err;\\r\\nBN_set_negative(&point->Y, 0);\\r\\nif (!BN_copy(&point->Z, BN_value_one())) goto err;\\r\\nBN_set_negative(&point->Z, 0);\\r\\npoint->Z_is_one = 1;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES, EC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_cmp(&point->Z, BN_value_one()))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!BN_copy(x, &point->X)) goto err;\\r\\nBN_set_negative(x, 0);\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!BN_copy(y, &point->Y)) goto err;\\r\\nBN_set_negative(y, 0);\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nsize_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point, point_conversion_form_t form,\\r\\nunsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nsize_t ret;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint used_ctx = 0;\\r\\nBIGNUM *x, *y, *yxi;\\r\\nsize_t field_len, i, skip;\\r\\n#ifndef OPENSSL_EC_BIN_PT_COMP\\r\\nif ((form == POINT_CONVERSION_COMPRESSED) || (form == POINT_CONVERSION_HYBRID))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_DISABLED);\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nif ((form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nif (buf != NULL)\\r\\n{\\r\\nif (len < 1)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nbuf[0] = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nfield_len = (EC_GROUP_get_degree(group) + 7) / 8;\\r\\nret = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;\\r\\nif (buf != NULL)\\r\\n{\\r\\nif (len < ret)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nused_ctx = 1;\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nyxi = BN_CTX_get(ctx);\\r\\nif (yxi == NULL) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, point, x, y, ctx)) goto err;\\r\\nbuf[0] = form;\\r\\n#ifdef OPENSSL_EC_BIN_PT_COMP\\r\\nif ((form != POINT_CONVERSION_UNCOMPRESSED) && !BN_is_zero(x))\\r\\n{\\r\\nif (!group->meth->field_div(group, yxi, y, x, ctx)) goto err;\\r\\nif (BN_is_odd(yxi)) buf[0]++;\\r\\n}\\r\\n#endif\\r\\ni = 1;\\r\\nskip = field_len - BN_num_bytes(x);\\r\\nif (skip > field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0)\\r\\n{\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(x, buf + i);\\r\\ni += skip;\\r\\nif (i != 1 + field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_UNCOMPRESSED || form == POINT_CONVERSION_HYBRID)\\r\\n{\\r\\nskip = field_len - BN_num_bytes(y);\\r\\nif (skip > field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0)\\r\\n{\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(y, buf + i);\\r\\ni += skip;\\r\\n}\\r\\nif (i != ret)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\nerr:\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\npoint_conversion_form_t form;\\r\\nint y_bit;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y, *yxi;\\r\\nsize_t field_len, enc_len;\\r\\nint ret = 0;\\r\\nif (len == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nform = buf[0];\\r\\ny_bit = form & 1;\\r\\nform = form & ~1U;\\r\\nif ((form != 0) && (form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) && y_bit)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (form == 0)\\r\\n{\\r\\nif (len != 1)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_to_infinity(group, point);\\r\\n}\\r\\nfield_len = (EC_GROUP_get_degree(group) + 7) / 8;\\r\\nenc_len = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;\\r\\nif (len != enc_len)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nyxi = BN_CTX_get(ctx);\\r\\nif (yxi == NULL) goto err;\\r\\nif (!BN_bin2bn(buf + 1, field_len, x)) goto err;\\r\\nif (BN_ucmp(x, &group->field) >= 0)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_COMPRESSED)\\r\\n{\\r\\nif (!EC_POINT_set_compressed_coordinates_GF2m(group, point, x, y_bit, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_bin2bn(buf + 1 + field_len, field_len, y)) goto err;\\r\\nif (BN_ucmp(y, &group->field) >= 0)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_HYBRID)\\r\\n{\\r\\nif (!group->meth->field_div(group, yxi, y, x, ctx)) goto err;\\r\\nif (y_bit != BN_is_odd(yxi))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, point, x, y, ctx)) goto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, point, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x0, *y0, *x1, *y1, *x2, *y2, *s, *t;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\n{\\r\\nif (!EC_POINT_copy(r, b)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, b))\\r\\n{\\r\\nif (!EC_POINT_copy(r, a)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx0 = BN_CTX_get(ctx);\\r\\ny0 = BN_CTX_get(ctx);\\r\\nx1 = BN_CTX_get(ctx);\\r\\ny1 = BN_CTX_get(ctx);\\r\\nx2 = BN_CTX_get(ctx);\\r\\ny2 = BN_CTX_get(ctx);\\r\\ns = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif (t == NULL) goto err;\\r\\nif (a->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(x0, &a->X)) goto err;\\r\\nif (!BN_copy(y0, &a->Y)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, a, x0, y0, ctx)) goto err;\\r\\n}\\r\\nif (b->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(x1, &b->X)) goto err;\\r\\nif (!BN_copy(y1, &b->Y)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, b, x1, y1, ctx)) goto err;\\r\\n}\\r\\nif (BN_GF2m_cmp(x0, x1))\\r\\n{\\r\\nif (!BN_GF2m_add(t, x0, x1)) goto err;\\r\\nif (!BN_GF2m_add(s, y0, y1)) goto err;\\r\\nif (!group->meth->field_div(group, s, s, t, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, x2, s, ctx)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->a)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, s)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, t)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_GF2m_cmp(y0, y1) || BN_is_zero(x1))\\r\\n{\\r\\nif (!EC_POINT_set_to_infinity(group, r)) goto err;\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!group->meth->field_div(group, s, y1, x1, ctx)) goto err;\\r\\nif (!BN_GF2m_add(s, s, x1)) goto err;\\r\\nif (!group->meth->field_sqr(group, x2, s, ctx)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, s)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->a)) goto err;\\r\\n}\\r\\nif (!BN_GF2m_add(y2, x1, x2)) goto err;\\r\\nif (!group->meth->field_mul(group, y2, y2, s, ctx)) goto err;\\r\\nif (!BN_GF2m_add(y2, y2, x2)) goto err;\\r\\nif (!BN_GF2m_add(y2, y2, y1)) goto err;\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, r, x2, y2, ctx)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)\\r\\n{\\r\\nreturn ec_GF2m_simple_add(group, r, a, a, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (EC_POINT_is_at_infinity(group, point) || BN_is_zero(&point->Y))\\r\\nreturn 1;\\r\\nif (!EC_POINT_make_affine(group, point, ctx)) return 0;\\r\\nreturn BN_GF2m_add(&point->Y, &point->X, &point->Y);\\r\\n}\\r\\nint ec_GF2m_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)\\r\\n{\\r\\nreturn BN_is_zero(&point->Z);\\r\\n}\\r\\nint ec_GF2m_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nint ret = -1;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *lh, *y2;\\r\\nint (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\nif (!point->Z_is_one) goto err;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ny2 = BN_CTX_get(ctx);\\r\\nlh = BN_CTX_get(ctx);\\r\\nif (lh == NULL) goto err;\\r\\nif (!BN_GF2m_add(lh, &point->X, &group->a)) goto err;\\r\\nif (!field_mul(group, lh, lh, &point->X, ctx)) goto err;\\r\\nif (!BN_GF2m_add(lh, lh, &point->Y)) goto err;\\r\\nif (!field_mul(group, lh, lh, &point->X, ctx)) goto err;\\r\\nif (!BN_GF2m_add(lh, lh, &group->b)) goto err;\\r\\nif (!field_sqr(group, y2, &point->Y, ctx)) goto err;\\r\\nif (!BN_GF2m_add(lh, lh, y2)) goto err;\\r\\nret = BN_is_zero(lh);\\r\\nerr:\\r\\nif (ctx) BN_CTX_end(ctx);\\r\\nif (new_ctx) BN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *aX, *aY, *bX, *bY;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\n{\\r\\nreturn EC_POINT_is_at_infinity(group, b) ? 0 : 1;\\r\\n}\\r\\nif (a->Z_is_one && b->Z_is_one)\\r\\n{\\r\\nreturn ((BN_cmp(&a->X, &b->X) == 0) && BN_cmp(&a->Y, &b->Y) == 0) ? 0 : 1;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\naX = BN_CTX_get(ctx);\\r\\naY = BN_CTX_get(ctx);\\r\\nbX = BN_CTX_get(ctx);\\r\\nbY = BN_CTX_get(ctx);\\r\\nif (bY == NULL) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, a, aX, aY, ctx)) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, b, bX, bY, ctx)) goto err;\\r\\nret = ((BN_cmp(aX, bX) == 0) && BN_cmp(aY, bY) == 0) ? 0 : 1;\\r\\nerr:\\r\\nif (ctx) BN_CTX_end(ctx);\\r\\nif (new_ctx) BN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nint ret = 0;\\r\\nif (point->Z_is_one || EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, point, x, y, ctx)) goto err;\\r\\nif (!BN_copy(&point->X, x)) goto err;\\r\\nif (!BN_copy(&point->Y, y)) goto err;\\r\\nif (!BN_one(&point->Z)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx) BN_CTX_end(ctx);\\r\\nif (new_ctx) BN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_points_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif (!group->meth->make_affine(group, points[i], ctx)) return 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_mul_arr(r, a, b, group->poly, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_sqr_arr(r, a, group->poly, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_field_div(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_div(r, a, b, &group->field, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_nseq_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint toseq = 0;\\r\\nX509 *x509 = NULL;\\r\\nNETSCAPE_CERT_SEQUENCE *seq = NULL;\\r\\nint i, ret = 1;\\r\\nint badarg = 0;\\r\\nif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\nERR_load_crypto_strings();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp (*args, \"-toseq\")) toseq = 1;\\r\\nelse if (!strcmp (*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf (bio_err, \"Netscape certificate sequence utility\\n\");\\r\\nBIO_printf (bio_err, \"Usage nseq [options]\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-in file input file\\n\");\\r\\nBIO_printf (bio_err, \"-out file output file\\n\");\\r\\nBIO_printf (bio_err, \"-toseq output NS Sequence file\\n\");\\r\\nOPENSSL_EXIT(1);\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file (infile, \"r\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file (outfile, \"w\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (toseq) {\\r\\nseq = NETSCAPE_CERT_SEQUENCE_new();\\r\\nseq->certs = sk_X509_new_null();\\r\\nwhile((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)))\\r\\nsk_X509_push(seq->certs,x509);\\r\\nif(!sk_X509_num(seq->certs))\\r\\n{\\r\\nBIO_printf (bio_err, \"Error reading certs file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) {\\r\\nBIO_printf (bio_err, \"Error reading sequence file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nfor(i = 0; i < sk_X509_num(seq->certs); i++) {\\r\\nx509 = sk_X509_value(seq->certs, i);\\r\\ndump_cert_text(out, x509);\\r\\nPEM_write_bio_X509(out, x509);\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nNETSCAPE_CERT_SEQUENCE_free(seq);\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn1_gen_c", "target": 0, "func": "ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf)\\r\\n{\\r\\nX509V3_CTX cnf;\\r\\nif (!nconf)\\r\\nreturn ASN1_generate_v3(str, NULL);\\r\\nX509V3_set_nconf(&cnf, nconf);\\r\\nreturn ASN1_generate_v3(str, &cnf);\\r\\n}\\r\\nASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf)\\r\\n{\\r\\nASN1_TYPE *ret;\\r\\ntag_exp_arg asn1_tags;\\r\\ntag_exp_type *etmp;\\r\\nint i, len;\\r\\nunsigned char *orig_der = NULL, *new_der = NULL;\\r\\nconst unsigned char *cpy_start;\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nint cpy_len;\\r\\nlong hdr_len;\\r\\nint hdr_constructed = 0, hdr_tag, hdr_class;\\r\\nint r;\\r\\nasn1_tags.imp_tag = -1;\\r\\nasn1_tags.imp_class = -1;\\r\\nasn1_tags.format = ASN1_GEN_FORMAT_ASCII;\\r\\nasn1_tags.exp_count = 0;\\r\\nif (CONF_parse_list(str, ',', 1, asn1_cb, &asn1_tags) != 0)\\r\\nreturn NULL;\\r\\nif ((asn1_tags.utype == V_ASN1_SEQUENCE) || (asn1_tags.utype == V_ASN1_SET))\\r\\n{\\r\\nif (!cnf)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_GENERATE_V3, ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG);\\r\\nreturn NULL;\\r\\n}\\r\\nret = asn1_multi(asn1_tags.utype, asn1_tags.str, cnf);\\r\\n}\\r\\nelse\\r\\nret = asn1_str2type(asn1_tags.str, asn1_tags.format, asn1_tags.utype);\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif ((asn1_tags.imp_tag == -1) && (asn1_tags.exp_count == 0))\\r\\nreturn ret;\\r\\ncpy_len = i2d_ASN1_TYPE(ret, &orig_der);\\r\\nASN1_TYPE_free(ret);\\r\\nret = NULL;\\r\\ncpy_start = orig_der;\\r\\nif (asn1_tags.imp_tag != -1)\\r\\n{\\r\\nr = ASN1_get_object(&cpy_start, &hdr_len, &hdr_tag, &hdr_class, cpy_len);\\r\\nif (r & 0x80)\\r\\ngoto err;\\r\\ncpy_len -= cpy_start - orig_der;\\r\\nif (r & 0x1)\\r\\n{\\r\\nhdr_constructed = 2;\\r\\nhdr_len = 0;\\r\\n}\\r\\nelse\\r\\nhdr_constructed = r & V_ASN1_CONSTRUCTED;\\r\\nlen = ASN1_object_size(0, hdr_len, asn1_tags.imp_tag);\\r\\n}\\r\\nelse\\r\\nlen = cpy_len;\\r\\nfor(i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1; i < asn1_tags.exp_count; i++, etmp--)\\r\\n{\\r\\nlen += etmp->exp_pad;\\r\\netmp->exp_len = len;\\r\\nlen = ASN1_object_size(0, len, etmp->exp_tag);\\r\\n}\\r\\nnew_der = OPENSSL_malloc(len);\\r\\np = new_der;\\r\\nfor (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count; i++, etmp++)\\r\\n{\\r\\nASN1_put_object(&p, etmp->exp_constructed, etmp->exp_len,\\r\\netmp->exp_tag, etmp->exp_class);\\r\\nif (etmp->exp_pad)\\r\\n*p++ = 0;\\r\\n}\\r\\nif (asn1_tags.imp_tag != -1)\\r\\nASN1_put_object(&p, hdr_constructed, hdr_len,\\r\\nasn1_tags.imp_tag, asn1_tags.imp_class);\\r\\nmemcpy(p, cpy_start, cpy_len);\\r\\ncp = new_der;\\r\\nret = d2i_ASN1_TYPE(NULL, &cp, len);\\r\\nerr:\\r\\nif (orig_der)\\r\\nOPENSSL_free(orig_der);\\r\\nif (new_der)\\r\\nOPENSSL_free(new_der);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_cb(const char *elem, int len, void *bitstr)\\r\\n{\\r\\ntag_exp_arg *arg = bitstr;\\r\\nint i;\\r\\nint utype;\\r\\nint vlen = 0;\\r\\nconst char *p, *vstart = NULL;\\r\\nint tmp_tag, tmp_class;\\r\\nfor(i = 0, p = elem; i < len; p++, i++)\\r\\n{\\r\\nif (*p == ':')\\r\\n{\\r\\nvstart = p + 1;\\r\\nvlen = len - (vstart - elem);\\r\\nlen = p - elem;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nutype = asn1_str2tag(elem, len);\\r\\nif (utype == -1)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\\r\\nERR_add_error_data(2, \"tag=\", elem);\\r\\nreturn -1;\\r\\n}\\r\\nif (!(utype & ASN1_GEN_FLAG))\\r\\n{\\r\\narg->utype = utype;\\r\\narg->str = vstart;\\r\\nif (!vstart && elem[len])\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nswitch(utype)\\r\\n{\\r\\ncase ASN1_GEN_FLAG_IMP:\\r\\nif (arg->imp_tag != -1)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\\r\\nreturn -1;\\r\\n}\\r\\nif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_EXP:\\r\\nif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\\r\\nreturn -1;\\r\\nif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_SEQWRAP:\\r\\nif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_SETWRAP:\\r\\nif (!append_exp(arg, V_ASN1_SET, V_ASN1_UNIVERSAL, 1, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_BITWRAP:\\r\\nif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_OCTWRAP:\\r\\nif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_FORMAT:\\r\\nif (!strncmp(vstart, \"ASCII\", 5))\\r\\narg->format = ASN1_GEN_FORMAT_ASCII;\\r\\nelse if (!strncmp(vstart, \"UTF8\", 4))\\r\\narg->format = ASN1_GEN_FORMAT_UTF8;\\r\\nelse if (!strncmp(vstart, \"HEX\", 3))\\r\\narg->format = ASN1_GEN_FORMAT_HEX;\\r\\nelse if (!strncmp(vstart, \"BITLIST\", 3))\\r\\narg->format = ASN1_GEN_FORMAT_BITLIST;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\\r\\nreturn -1;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)\\r\\n{\\r\\nchar erch[2];\\r\\nlong tag_num;\\r\\nchar *eptr;\\r\\nif (!vstart)\\r\\nreturn 0;\\r\\ntag_num = strtoul(vstart, &eptr, 10);\\r\\nif (eptr && *eptr && (eptr > vstart + vlen))\\r\\nreturn 0;\\r\\nif (tag_num < 0)\\r\\n{\\r\\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\n*ptag = tag_num;\\r\\nif (eptr)\\r\\nvlen -= eptr - vstart;\\r\\nelse\\r\\nvlen = 0;\\r\\nif (vlen)\\r\\n{\\r\\nswitch (*eptr)\\r\\n{\\r\\ncase 'U':\\r\\n*pclass = V_ASN1_UNIVERSAL;\\r\\nbreak;\\r\\ncase 'A':\\r\\n*pclass = V_ASN1_APPLICATION;\\r\\nbreak;\\r\\ncase 'P':\\r\\n*pclass = V_ASN1_PRIVATE;\\r\\nbreak;\\r\\ncase 'C':\\r\\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\\r\\nbreak;\\r\\ndefault:\\r\\nerch[0] = *eptr;\\r\\nerch[1] = 0;\\r\\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);\\r\\nERR_add_error_data(2, \"Char=\", erch);\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nelse\\r\\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf)\\r\\n{\\r\\nASN1_TYPE *ret = NULL, *typ = NULL;\\r\\nSTACK_OF(ASN1_TYPE) *sk = NULL;\\r\\nSTACK_OF(CONF_VALUE) *sect = NULL;\\r\\nunsigned char *der = NULL, *p;\\r\\nint derlen;\\r\\nint i, is_set;\\r\\nsk = sk_ASN1_TYPE_new_null();\\r\\nif (section)\\r\\n{\\r\\nif (!cnf)\\r\\ngoto bad;\\r\\nsect = X509V3_get_section(cnf, (char *)section);\\r\\nif (!sect)\\r\\ngoto bad;\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sect); i++)\\r\\n{\\r\\ntyp = ASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);\\r\\nif (!typ)\\r\\ngoto bad;\\r\\nsk_ASN1_TYPE_push(sk, typ);\\r\\ntyp = NULL;\\r\\n}\\r\\n}\\r\\nif (utype == V_ASN1_SET)\\r\\nis_set = 1;\\r\\nelse\\r\\nis_set = 0;\\r\\nderlen = i2d_ASN1_SET_OF_ASN1_TYPE(sk, NULL, i2d_ASN1_TYPE, utype,\\r\\nV_ASN1_UNIVERSAL, is_set);\\r\\nder = OPENSSL_malloc(derlen);\\r\\np = der;\\r\\ni2d_ASN1_SET_OF_ASN1_TYPE(sk, &p, i2d_ASN1_TYPE, utype,\\r\\nV_ASN1_UNIVERSAL, is_set);\\r\\nif (!(ret = ASN1_TYPE_new()))\\r\\ngoto bad;\\r\\nif (!(ret->value.asn1_string = ASN1_STRING_type_new(utype)))\\r\\ngoto bad;\\r\\nret->type = utype;\\r\\nret->value.asn1_string->data = der;\\r\\nret->value.asn1_string->length = derlen;\\r\\nder = NULL;\\r\\nbad:\\r\\nif (der)\\r\\nOPENSSL_free(der);\\r\\nif (sk)\\r\\nsk_ASN1_TYPE_pop_free(sk, ASN1_TYPE_free);\\r\\nif (typ)\\r\\nASN1_TYPE_free(typ);\\r\\nif (sect)\\r\\nX509V3_section_free(cnf, sect);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed, int exp_pad, int imp_ok)\\r\\n{\\r\\ntag_exp_type *exp_tmp;\\r\\nif ((arg->imp_tag != -1) && !imp_ok)\\r\\n{\\r\\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);\\r\\nreturn 0;\\r\\n}\\r\\nif (arg->exp_count == ASN1_FLAG_EXP_MAX)\\r\\n{\\r\\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);\\r\\nreturn 0;\\r\\n}\\r\\nexp_tmp = &arg->exp_list[arg->exp_count++];\\r\\nif (arg->imp_tag != -1)\\r\\n{\\r\\nexp_tmp->exp_tag = arg->imp_tag;\\r\\nexp_tmp->exp_class = arg->imp_class;\\r\\narg->imp_tag = -1;\\r\\narg->imp_class = -1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nexp_tmp->exp_tag = exp_tag;\\r\\nexp_tmp->exp_class = exp_class;\\r\\n}\\r\\nexp_tmp->exp_constructed = exp_constructed;\\r\\nexp_tmp->exp_pad = exp_pad;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_str2tag(const char *tagstr, int len)\\r\\n{\\r\\nunsigned int i;\\r\\nstatic struct tag_name_st *tntmp, tnst [] = {\\r\\nASN1_GEN_STR(\"BOOL\", V_ASN1_BOOLEAN),\\r\\nASN1_GEN_STR(\"BOOLEAN\", V_ASN1_BOOLEAN),\\r\\nASN1_GEN_STR(\"NULL\", V_ASN1_NULL),\\r\\nASN1_GEN_STR(\"INT\", V_ASN1_INTEGER),\\r\\nASN1_GEN_STR(\"INTEGER\", V_ASN1_INTEGER),\\r\\nASN1_GEN_STR(\"ENUM\", V_ASN1_ENUMERATED),\\r\\nASN1_GEN_STR(\"ENUMERATED\", V_ASN1_ENUMERATED),\\r\\nASN1_GEN_STR(\"OID\", V_ASN1_OBJECT),\\r\\nASN1_GEN_STR(\"OBJECT\", V_ASN1_OBJECT),\\r\\nASN1_GEN_STR(\"UTCTIME\", V_ASN1_UTCTIME),\\r\\nASN1_GEN_STR(\"UTC\", V_ASN1_UTCTIME),\\r\\nASN1_GEN_STR(\"GENERALIZEDTIME\", V_ASN1_GENERALIZEDTIME),\\r\\nASN1_GEN_STR(\"GENTIME\", V_ASN1_GENERALIZEDTIME),\\r\\nASN1_GEN_STR(\"OCT\", V_ASN1_OCTET_STRING),\\r\\nASN1_GEN_STR(\"OCTETSTRING\", V_ASN1_OCTET_STRING),\\r\\nASN1_GEN_STR(\"BITSTR\", V_ASN1_BIT_STRING),\\r\\nASN1_GEN_STR(\"BITSTRING\", V_ASN1_BIT_STRING),\\r\\nASN1_GEN_STR(\"UNIVERSALSTRING\", V_ASN1_UNIVERSALSTRING),\\r\\nASN1_GEN_STR(\"UNIV\", V_ASN1_UNIVERSALSTRING),\\r\\nASN1_GEN_STR(\"IA5\", V_ASN1_IA5STRING),\\r\\nASN1_GEN_STR(\"IA5STRING\", V_ASN1_IA5STRING),\\r\\nASN1_GEN_STR(\"UTF8\", V_ASN1_UTF8STRING),\\r\\nASN1_GEN_STR(\"UTF8String\", V_ASN1_UTF8STRING),\\r\\nASN1_GEN_STR(\"BMP\", V_ASN1_BMPSTRING),\\r\\nASN1_GEN_STR(\"BMPSTRING\", V_ASN1_BMPSTRING),\\r\\nASN1_GEN_STR(\"VISIBLESTRING\", V_ASN1_VISIBLESTRING),\\r\\nASN1_GEN_STR(\"VISIBLE\", V_ASN1_VISIBLESTRING),\\r\\nASN1_GEN_STR(\"PRINTABLESTRING\", V_ASN1_PRINTABLESTRING),\\r\\nASN1_GEN_STR(\"PRINTABLE\", V_ASN1_PRINTABLESTRING),\\r\\nASN1_GEN_STR(\"T61\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"T61STRING\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"TELETEXSTRING\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"GeneralString\", V_ASN1_GENERALSTRING),\\r\\nASN1_GEN_STR(\"GENSTR\", V_ASN1_GENERALSTRING),\\r\\nASN1_GEN_STR(\"SEQUENCE\", V_ASN1_SEQUENCE),\\r\\nASN1_GEN_STR(\"SEQ\", V_ASN1_SEQUENCE),\\r\\nASN1_GEN_STR(\"SET\", V_ASN1_SET),\\r\\nASN1_GEN_STR(\"EXP\", ASN1_GEN_FLAG_EXP),\\r\\nASN1_GEN_STR(\"EXPLICIT\", ASN1_GEN_FLAG_EXP),\\r\\nASN1_GEN_STR(\"IMP\", ASN1_GEN_FLAG_IMP),\\r\\nASN1_GEN_STR(\"IMPLICIT\", ASN1_GEN_FLAG_IMP),\\r\\nASN1_GEN_STR(\"OCTWRAP\", ASN1_GEN_FLAG_OCTWRAP),\\r\\nASN1_GEN_STR(\"SEQWRAP\", ASN1_GEN_FLAG_SEQWRAP),\\r\\nASN1_GEN_STR(\"SETWRAP\", ASN1_GEN_FLAG_SETWRAP),\\r\\nASN1_GEN_STR(\"BITWRAP\", ASN1_GEN_FLAG_BITWRAP),\\r\\nASN1_GEN_STR(\"FORM\", ASN1_GEN_FLAG_FORMAT),\\r\\nASN1_GEN_STR(\"FORMAT\", ASN1_GEN_FLAG_FORMAT),\\r\\n};\\r\\nif (len == -1)\\r\\nlen = strlen(tagstr);\\r\\ntntmp = tnst;\\r\\nfor (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st); i++, tntmp++)\\r\\n{\\r\\nif ((len == tntmp->len) && !strncmp(tntmp->strnam, tagstr, len))\\r\\nreturn tntmp->tag;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)\\r\\n{\\r\\nASN1_TYPE *atmp = NULL;\\r\\nCONF_VALUE vtmp;\\r\\nunsigned char *rdata;\\r\\nlong rdlen;\\r\\nint no_unused = 1;\\r\\nif (!(atmp = ASN1_TYPE_new()))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!str)\\r\\nstr = \"\";\\r\\nswitch(utype)\\r\\n{\\r\\ncase V_ASN1_NULL:\\r\\nif (str && *str)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);\\r\\ngoto bad_form;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nvtmp.value = (char *)str;\\r\\nif (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.integer = s2i_ASN1_INTEGER(NULL, (char *)str)))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_OBJECT:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.object = OBJ_txt2obj(str, 0)))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.asn1_string = ASN1_STRING_new()))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\nif (!ASN1_STRING_set(atmp->value.asn1_string, str, -1))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\natmp->value.asn1_string->type = utype;\\r\\nif (!ASN1_TIME_check(atmp->value.asn1_string))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\nif (format == ASN1_GEN_FORMAT_ASCII)\\r\\nformat = MBSTRING_ASC;\\r\\nelse if (format == ASN1_GEN_FORMAT_UTF8)\\r\\nformat = MBSTRING_UTF8;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (ASN1_mbstring_copy(&atmp->value.asn1_string, (unsigned char *)str,\\r\\n-1, format, ASN1_tag2bit(utype)) <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\ncase V_ASN1_OCTET_STRING:\\r\\nif (!(atmp->value.asn1_string = ASN1_STRING_new()))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (format == ASN1_GEN_FORMAT_HEX)\\r\\n{\\r\\nif (!(rdata = string_to_hex((char *)str, &rdlen)))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);\\r\\ngoto bad_str;\\r\\n}\\r\\natmp->value.asn1_string->data = rdata;\\r\\natmp->value.asn1_string->length = rdlen;\\r\\natmp->value.asn1_string->type = utype;\\r\\n}\\r\\nelse if (format == ASN1_GEN_FORMAT_ASCII)\\r\\nASN1_STRING_set(atmp->value.asn1_string, str, -1);\\r\\nelse if ((format == ASN1_GEN_FORMAT_BITLIST) && (utype == V_ASN1_BIT_STRING))\\r\\n{\\r\\nif (!CONF_parse_list(str, ',', 1, bitstr_cb, atmp->value.bit_string))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);\\r\\ngoto bad_str;\\r\\n}\\r\\nno_unused = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif ((utype == V_ASN1_BIT_STRING) && no_unused)\\r\\n{\\r\\natmp->value.asn1_string->flags\\r\\n&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\natmp->value.asn1_string->flags\\r\\n|= ASN1_STRING_FLAG_BITS_LEFT;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);\\r\\ngoto bad_str;\\r\\nbreak;\\r\\n}\\r\\natmp->type = utype;\\r\\nreturn atmp;\\r\\nbad_str:\\r\\nERR_add_error_data(2, \"string=\", str);\\r\\nbad_form:\\r\\nASN1_TYPE_free(atmp);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int bitstr_cb(const char *elem, int len, void *bitstr)\\r\\n{\\r\\nlong bitnum;\\r\\nchar *eptr;\\r\\nif (!elem)\\r\\nreturn 0;\\r\\nbitnum = strtoul(elem, &eptr, 10);\\r\\nif (eptr && *eptr && (eptr != elem + len))\\r\\nreturn 0;\\r\\nif (bitnum < 0)\\r\\n{\\r\\nASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1))\\r\\n{\\r\\nASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t1_lib_c", "target": 0, "func": "static long tls1_default_timeout(void)\\r\\n{\\r\\nreturn(60*60*2);\\r\\n}\\r\\nSSL_METHOD *tlsv1_base_method(void)\\r\\n{\\r\\nreturn(&TLSv1_data);\\r\\n}\\r\\nint tls1_new(SSL *s)\\r\\n{\\r\\nif (!ssl3_new(s)) return(0);\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\n}\\r\\nvoid tls1_free(SSL *s)\\r\\n{\\r\\nssl3_free(s);\\r\\n}\\r\\nvoid tls1_clear(SSL *s)\\r\\n{\\r\\nssl3_clear(s);\\r\\ns->version=TLS1_VERSION;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_lib_c", "target": 0, "func": "BIO *BIO_new(BIO_METHOD *method)\\r\\n{\\r\\nBIO *ret=NULL;\\r\\nret=(BIO *)OPENSSL_malloc(sizeof(BIO));\\r\\nif (ret == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!BIO_set(ret,method))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_set(BIO *bio, BIO_METHOD *method)\\r\\n{\\r\\nbio->method=method;\\r\\nbio->callback=NULL;\\r\\nbio->cb_arg=NULL;\\r\\nbio->init=0;\\r\\nbio->shutdown=1;\\r\\nbio->flags=0;\\r\\nbio->retry_reason=0;\\r\\nbio->num=0;\\r\\nbio->ptr=NULL;\\r\\nbio->prev_bio=NULL;\\r\\nbio->next_bio=NULL;\\r\\nbio->references=1;\\r\\nbio->num_read=0L;\\r\\nbio->num_write=0L;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);\\r\\nif (method->create != NULL)\\r\\nif (!method->create(bio))\\r\\n{\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio,\\r\\n&bio->ex_data);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_free(BIO *a)\\r\\n{\\r\\nint ret=0,i;\\r\\nif (a == NULL) return(0);\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_BIO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"BIO\",a);\\r\\n#endif\\r\\nif (i > 0) return(1);\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"BIO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif ((a->callback != NULL) &&\\r\\n((i=(int)a->callback(a,BIO_CB_FREE,NULL,0,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, &a->ex_data);\\r\\nif ((a->method == NULL) || (a->method->destroy == NULL)) return(1);\\r\\nret=a->method->destroy(a);\\r\\nOPENSSL_free(a);\\r\\nreturn(1);\\r\\n}\\r\\nvoid BIO_vfree(BIO *a)\\r\\n{ BIO_free(a); }\\r\\nint BIO_read(BIO *b, void *out, int outl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bread == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_READ,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_READ,out,outl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_READ,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bread(b,out,outl);\\r\\nif (i > 0) b->num_read+=(unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_READ|BIO_CB_RETURN,out,outl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_write(BIO *b, const void *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif (b == NULL)\\r\\nreturn(0);\\r\\ncb=b->callback;\\r\\nif ((b->method == NULL) || (b->method->bwrite == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_WRITE,in,inl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bwrite(b,in,inl);\\r\\nif (i > 0) b->num_write+=(unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_WRITE|BIO_CB_RETURN,in,inl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_puts(BIO *b, const char *in)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bputs == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_PUTS,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_PUTS,in,0,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_PUTS,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bputs(b,in);\\r\\nif (i > 0) b->num_write+=(unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_PUTS|BIO_CB_RETURN,in,0,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_gets(BIO *b, char *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bgets == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETS,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_GETS,in,inl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETS,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bgets(b,in,inl);\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_GETS|BIO_CB_RETURN,in,inl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_indent(BIO *b,int indent,int max)\\r\\n{\\r\\nif(indent < 0)\\r\\nindent=0;\\r\\nif(indent > max)\\r\\nindent=max;\\r\\nwhile(indent--)\\r\\nif(BIO_puts(b,\" \") != 1)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nlong BIO_int_ctrl(BIO *b, int cmd, long larg, int iarg)\\r\\n{\\r\\nint i;\\r\\ni=iarg;\\r\\nreturn(BIO_ctrl(b,cmd,larg,(char *)&i));\\r\\n}\\r\\nchar *BIO_ptr_ctrl(BIO *b, int cmd, long larg)\\r\\n{\\r\\nchar *p=NULL;\\r\\nif (BIO_ctrl(b,cmd,larg,(char *)&p) <= 0)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(p);\\r\\n}\\r\\nlong BIO_ctrl(BIO *b, int cmd, long larg, void *parg)\\r\\n{\\r\\nlong ret;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif (b == NULL) return(0);\\r\\nif ((b->method == NULL) || (b->method->ctrl == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((ret=cb(b,BIO_CB_CTRL,parg,cmd,larg,1L)) <= 0))\\r\\nreturn(ret);\\r\\nret=b->method->ctrl(b,cmd,larg,parg);\\r\\nif (cb != NULL)\\r\\nret=cb(b,BIO_CB_CTRL|BIO_CB_RETURN,parg,cmd,\\r\\nlarg,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nlong BIO_callback_ctrl(BIO *b, int cmd, void (*fp)(struct bio_st *, int, const char *, int, long, long))\\r\\n{\\r\\nlong ret;\\r\\nlong (*cb)(BIO *,int,const char *,int,long,long);\\r\\nif (b == NULL) return(0);\\r\\nif ((b->method == NULL) || (b->method->callback_ctrl == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CALLBACK_CTRL,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((ret=cb(b,BIO_CB_CTRL,(void *)&fp,cmd,0,1L)) <= 0))\\r\\nreturn(ret);\\r\\nret=b->method->callback_ctrl(b,cmd,fp);\\r\\nif (cb != NULL)\\r\\nret=cb(b,BIO_CB_CTRL|BIO_CB_RETURN,(void *)&fp,cmd,\\r\\n0,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nsize_t BIO_ctrl_pending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_PENDING, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_wpending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_WPENDING, 0, NULL);\\r\\n}\\r\\nBIO *BIO_push(BIO *b, BIO *bio)\\r\\n{\\r\\nBIO *lb;\\r\\nif (b == NULL) return(bio);\\r\\nlb=b;\\r\\nwhile (lb->next_bio != NULL)\\r\\nlb=lb->next_bio;\\r\\nlb->next_bio=bio;\\r\\nif (bio != NULL)\\r\\nbio->prev_bio=lb;\\r\\nBIO_ctrl(b,BIO_CTRL_PUSH,0,NULL);\\r\\nreturn(b);\\r\\n}\\r\\nBIO *BIO_pop(BIO *b)\\r\\n{\\r\\nBIO *ret;\\r\\nif (b == NULL) return(NULL);\\r\\nret=b->next_bio;\\r\\nBIO_ctrl(b,BIO_CTRL_POP,0,NULL);\\r\\nif (b->prev_bio != NULL)\\r\\nb->prev_bio->next_bio=b->next_bio;\\r\\nif (b->next_bio != NULL)\\r\\nb->next_bio->prev_bio=b->prev_bio;\\r\\nb->next_bio=NULL;\\r\\nb->prev_bio=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_get_retry_BIO(BIO *bio, int *reason)\\r\\n{\\r\\nBIO *b,*last;\\r\\nb=last=bio;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BIO_should_retry(b)) break;\\r\\nlast=b;\\r\\nb=b->next_bio;\\r\\nif (b == NULL) break;\\r\\n}\\r\\nif (reason != NULL) *reason=last->retry_reason;\\r\\nreturn(last);\\r\\n}\\r\\nint BIO_get_retry_reason(BIO *bio)\\r\\n{\\r\\nreturn(bio->retry_reason);\\r\\n}\\r\\nBIO *BIO_find_type(BIO *bio, int type)\\r\\n{\\r\\nint mt,mask;\\r\\nif(!bio) return NULL;\\r\\nmask=type&0xff;\\r\\ndo {\\r\\nif (bio->method != NULL)\\r\\n{\\r\\nmt=bio->method->type;\\r\\nif (!mask)\\r\\n{\\r\\nif (mt & type) return(bio);\\r\\n}\\r\\nelse if (mt == type)\\r\\nreturn(bio);\\r\\n}\\r\\nbio=bio->next_bio;\\r\\n} while (bio != NULL);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO *BIO_next(BIO *b)\\r\\n{\\r\\nif(!b) return NULL;\\r\\nreturn b->next_bio;\\r\\n}\\r\\nvoid BIO_free_all(BIO *bio)\\r\\n{\\r\\nBIO *b;\\r\\nint ref;\\r\\nwhile (bio != NULL)\\r\\n{\\r\\nb=bio;\\r\\nref=b->references;\\r\\nbio=bio->next_bio;\\r\\nBIO_free(b);\\r\\nif (ref > 1) break;\\r\\n}\\r\\n}\\r\\nBIO *BIO_dup_chain(BIO *in)\\r\\n{\\r\\nBIO *ret=NULL,*eoc=NULL,*bio,*new;\\r\\nfor (bio=in; bio != NULL; bio=bio->next_bio)\\r\\n{\\r\\nif ((new=BIO_new(bio->method)) == NULL) goto err;\\r\\nnew->callback=bio->callback;\\r\\nnew->cb_arg=bio->cb_arg;\\r\\nnew->init=bio->init;\\r\\nnew->shutdown=bio->shutdown;\\r\\nnew->flags=bio->flags;\\r\\nnew->num=bio->num;\\r\\nif (!BIO_dup_state(bio,(char *)new))\\r\\n{\\r\\nBIO_free(new);\\r\\ngoto err;\\r\\n}\\r\\nif (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_BIO, &new->ex_data,\\r\\n&bio->ex_data))\\r\\ngoto err;\\r\\nif (ret == NULL)\\r\\n{\\r\\neoc=new;\\r\\nret=eoc;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_push(eoc,new);\\r\\neoc=new;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid BIO_copy_next_retry(BIO *b)\\r\\n{\\r\\nBIO_set_flags(b,BIO_get_retry_flags(b->next_bio));\\r\\nb->retry_reason=b->next_bio->retry_reason;\\r\\n}\\r\\nint BIO_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint BIO_set_ex_data(BIO *bio, int idx, void *data)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&(bio->ex_data),idx,data));\\r\\n}\\r\\nvoid *BIO_get_ex_data(BIO *bio, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&(bio->ex_data),idx));\\r\\n}\\r\\nunsigned long BIO_number_read(BIO *bio)\\r\\n{\\r\\nif(bio) return bio->num_read;\\r\\nreturn 0;\\r\\n}\\r\\nunsigned long BIO_number_written(BIO *bio)\\r\\n{\\r\\nif(bio) return bio->num_write;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_uid_c", "target": 0, "func": "int OPENSSL_issetugid(void)\\r\\n{\\r\\nreturn issetugid();\\r\\n}\\r\\nint OPENSSL_issetugid(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nint OPENSSL_issetugid(void)\\r\\n{\\r\\nif (getuid() != geteuid()) return 1;\\r\\nif (getgid() != getegid()) return 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_LPdir_nyi_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_pkey_c", "target": 0, "func": "int RSA_print_fp(FILE *fp, const RSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=RSA_print(b,x,off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_print(BIO *bp, const RSA *x, int off)\\r\\n{\\r\\nchar str[128];\\r\\nconst char *s;\\r\\nunsigned char *m=NULL;\\r\\nint ret=0;\\r\\nsize_t buf_len=0, i;\\r\\nif (x->n)\\r\\nbuf_len = (size_t)BN_num_bytes(x->n);\\r\\nif (x->e)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->e)))\\r\\nbuf_len = i;\\r\\nif (x->d)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->d)))\\r\\nbuf_len = i;\\r\\nif (x->p)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->p)))\\r\\nbuf_len = i;\\r\\nif (x->q)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->q)))\\r\\nbuf_len = i;\\r\\nif (x->dmp1)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->dmp1)))\\r\\nbuf_len = i;\\r\\nif (x->dmq1)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->dmq1)))\\r\\nbuf_len = i;\\r\\nif (x->iqmp)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->iqmp)))\\r\\nbuf_len = i;\\r\\nm=(unsigned char *)OPENSSL_malloc(buf_len+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (x->d != NULL)\\r\\n{\\r\\nif(!BIO_indent(bp,off,128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->n))\\r\\n<= 0) goto err;\\r\\n}\\r\\nif (x->d == NULL)\\r\\nBIO_snprintf(str,sizeof str,\"Modulus (%d bit):\",BN_num_bits(x->n));\\r\\nelse\\r\\nBUF_strlcpy(str,\"modulus:\",sizeof str);\\r\\nif (!print(bp,str,x->n,m,off)) goto err;\\r\\ns=(x->d == NULL)?\"Exponent:\":\"publicExponent:\";\\r\\nif (!print(bp,s,x->e,m,off)) goto err;\\r\\nif (!print(bp,\"privateExponent:\",x->d,m,off)) goto err;\\r\\nif (!print(bp,\"prime1:\",x->p,m,off)) goto err;\\r\\nif (!print(bp,\"prime2:\",x->q,m,off)) goto err;\\r\\nif (!print(bp,\"exponent1:\",x->dmp1,m,off)) goto err;\\r\\nif (!print(bp,\"exponent2:\",x->dmq1,m,off)) goto err;\\r\\nif (!print(bp,\"coefficient:\",x->iqmp,m,off)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_print_fp(FILE *fp, const DSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DSA_print(b,x,off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_print(BIO *bp, const DSA *x, int off)\\r\\n{\\r\\nunsigned char *m=NULL;\\r\\nint ret=0;\\r\\nsize_t buf_len=0,i;\\r\\nif (x->p)\\r\\nbuf_len = (size_t)BN_num_bytes(x->p);\\r\\nif (x->q)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->q)))\\r\\nbuf_len = i;\\r\\nif (x->g)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->g)))\\r\\nbuf_len = i;\\r\\nif (x->priv_key)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->priv_key)))\\r\\nbuf_len = i;\\r\\nif (x->pub_key)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->pub_key)))\\r\\nbuf_len = i;\\r\\nm=(unsigned char *)OPENSSL_malloc(buf_len+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_PRINT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (x->priv_key != NULL)\\r\\n{\\r\\nif(!BIO_indent(bp,off,128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->p))\\r\\n<= 0) goto err;\\r\\n}\\r\\nif ((x->priv_key != NULL) && !print(bp,\"priv:\",x->priv_key,m,off))\\r\\ngoto err;\\r\\nif ((x->pub_key != NULL) && !print(bp,\"pub: \",x->pub_key,m,off))\\r\\ngoto err;\\r\\nif ((x->p != NULL) && !print(bp,\"P: \",x->p,m,off)) goto err;\\r\\nif ((x->q != NULL) && !print(bp,\"Q: \",x->q,m,off)) goto err;\\r\\nif ((x->g != NULL) && !print(bp,\"G: \",x->g,m,off)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nreturn(ret);\\r\\n}\\r\\nint ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nECerr(EC_F_ECPKPARAMETERS_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = ECPKParameters_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint EC_KEY_print_fp(FILE *fp, const EC_KEY *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_KEY_PRINT_FP, ERR_R_BIO_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = EC_KEY_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off)\\r\\n{\\r\\nunsigned char *buffer=NULL;\\r\\nsize_t buf_len=0, i;\\r\\nint ret=0, reason=ERR_R_BIO_LIB;\\r\\nBN_CTX *ctx=NULL;\\r\\nconst EC_POINT *point=NULL;\\r\\nBIGNUM *p=NULL, *a=NULL, *b=NULL, *gen=NULL,\\r\\n*order=NULL, *cofactor=NULL;\\r\\nconst unsigned char *seed;\\r\\nsize_t seed_len=0;\\r\\nstatic const char *gen_compressed = \"Generator (compressed):\";\\r\\nstatic const char *gen_uncompressed = \"Generator (uncompressed):\";\\r\\nstatic const char *gen_hybrid = \"Generator (hybrid):\";\\r\\nif (!x)\\r\\n{\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(x))\\r\\n{\\r\\nint nid;\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nnid = EC_GROUP_get_curve_name(x);\\r\\nif (nid == 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"ASN1 OID: %s\", OBJ_nid2sn(nid)) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nint is_char_two = 0;\\r\\npoint_conversion_form_t form;\\r\\nint tmp_nid = EC_METHOD_get_field_type(EC_GROUP_method_of(x));\\r\\nif (tmp_nid == NID_X9_62_characteristic_two_field)\\r\\nis_char_two = 1;\\r\\nif ((p = BN_new()) == NULL || (a = BN_new()) == NULL ||\\r\\n(b = BN_new()) == NULL || (order = BN_new()) == NULL ||\\r\\n(cofactor = BN_new()) == NULL)\\r\\n{\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (is_char_two)\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GF2m(x, p, a, b, ctx))\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GFp(x, p, a, b, ctx))\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(x)) == NULL)\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(x, order, NULL) ||\\r\\n!EC_GROUP_get_cofactor(x, cofactor, NULL))\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nform = EC_GROUP_get_point_conversion_form(x);\\r\\nif ((gen = EC_POINT_point2bn(x, point,\\r\\nform, NULL, ctx)) == NULL)\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nbuf_len = (size_t)BN_num_bytes(p);\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(a)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(b)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(gen)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(order)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(cofactor)))\\r\\nbuf_len = i;\\r\\nif ((seed = EC_GROUP_get0_seed(x)) != NULL)\\r\\nseed_len = EC_GROUP_get_seed_len(x);\\r\\nbuf_len += 10;\\r\\nif ((buffer = OPENSSL_malloc(buf_len)) == NULL)\\r\\n{\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"Field Type: %s\\n\", OBJ_nid2sn(tmp_nid))\\r\\n<= 0)\\r\\ngoto err;\\r\\nif (is_char_two)\\r\\n{\\r\\nint basis_type = EC_GROUP_get_basis_type(x);\\r\\nif (basis_type == 0)\\r\\ngoto err;\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"Basis Type: %s\\n\",\\r\\nOBJ_nid2sn(basis_type)) <= 0)\\r\\ngoto err;\\r\\nif ((p != NULL) && !print(bp, \"Polynomial:\", p, buffer,\\r\\noff))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((p != NULL) && !print(bp, \"Prime:\", p, buffer,off))\\r\\ngoto err;\\r\\n}\\r\\nif ((a != NULL) && !print(bp, \"A: \", a, buffer, off))\\r\\ngoto err;\\r\\nif ((b != NULL) && !print(bp, \"B: \", b, buffer, off))\\r\\ngoto err;\\r\\nif (form == POINT_CONVERSION_COMPRESSED)\\r\\n{\\r\\nif ((gen != NULL) && !print(bp, gen_compressed, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n}\\r\\nelse if (form == POINT_CONVERSION_UNCOMPRESSED)\\r\\n{\\r\\nif ((gen != NULL) && !print(bp, gen_uncompressed, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((gen != NULL) && !print(bp, gen_hybrid, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n}\\r\\nif ((order != NULL) && !print(bp, \"Order: \", order,\\r\\nbuffer, off)) goto err;\\r\\nif ((cofactor != NULL) && !print(bp, \"Cofactor: \", cofactor,\\r\\nbuffer, off)) goto err;\\r\\nif (seed && !print_bin(bp, \"Seed:\", seed, seed_len, off))\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (!ret)\\r\\nECerr(EC_F_ECPKPARAMETERS_PRINT, reason);\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (gen)\\r\\nBN_free(gen);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (cofactor)\\r\\nBN_free(cofactor);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (buffer != NULL)\\r\\nOPENSSL_free(buffer);\\r\\nreturn(ret);\\r\\n}\\r\\nint EC_KEY_print(BIO *bp, const EC_KEY *x, int off)\\r\\n{\\r\\nunsigned char *buffer=NULL;\\r\\nsize_t buf_len=0, i;\\r\\nint ret=0, reason=ERR_R_BIO_LIB;\\r\\nBIGNUM *pub_key=NULL, *order=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nconst EC_GROUP *group;\\r\\nconst EC_POINT *public_key;\\r\\nconst BIGNUM *priv_key;\\r\\nif (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)\\r\\n{\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\npublic_key = EC_KEY_get0_public_key(x);\\r\\nif ((pub_key = EC_POINT_point2bn(group, public_key,\\r\\nEC_KEY_get_conv_form(x), NULL, ctx)) == NULL)\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nbuf_len = (size_t)BN_num_bytes(pub_key);\\r\\npriv_key = EC_KEY_get0_private_key(x);\\r\\nif (priv_key != NULL)\\r\\n{\\r\\nif ((i = (size_t)BN_num_bytes(priv_key)) > buf_len)\\r\\nbuf_len = i;\\r\\n}\\r\\nbuf_len += 10;\\r\\nif ((buffer = OPENSSL_malloc(buf_len)) == NULL)\\r\\n{\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (priv_key != NULL)\\r\\n{\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif ((order = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_get_order(group, order, NULL))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"Private-Key: (%d bit)\\n\",\\r\\nBN_num_bits(order)) <= 0) goto err;\\r\\n}\\r\\nif ((priv_key != NULL) && !print(bp, \"priv:\", priv_key,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif ((pub_key != NULL) && !print(bp, \"pub: \", pub_key,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif (!ECPKParameters_print(bp, group, off))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (!ret)\\r\\nECerr(EC_F_EC_KEY_PRINT, reason);\\r\\nif (pub_key)\\r\\nBN_free(pub_key);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (buffer != NULL)\\r\\nOPENSSL_free(buffer);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int print(BIO *bp, const char *number, const BIGNUM *num, unsigned char *buf,\\r\\nint off)\\r\\n{\\r\\nint n,i;\\r\\nconst char *neg;\\r\\nif (num == NULL) return(1);\\r\\nneg = (BN_is_negative(num))?\"-\":\"\";\\r\\nif(!BIO_indent(bp,off,128))\\r\\nreturn 0;\\r\\nif (BN_is_zero(num))\\r\\n{\\r\\nif (BIO_printf(bp, \"%s 0\\n\", number) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (BN_num_bytes(num) <= BN_BYTES)\\r\\n{\\r\\nif (BIO_printf(bp,\"%s %s%lu (%s0x%lx)\\n\",number,neg,\\r\\n(unsigned long)num->d[0],neg,(unsigned long)num->d[0])\\r\\n<= 0) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]=0;\\r\\nif (BIO_printf(bp,\"%s%s\",number,\\r\\n(neg[0] == '-')?\" (Negative)\":\"\") <= 0)\\r\\nreturn(0);\\r\\nn=BN_bn2bin(num,&buf[1]);\\r\\nif (buf[1] & 0x80)\\r\\nn++;\\r\\nelse buf++;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%15) == 0)\\r\\n{\\r\\nif(BIO_puts(bp,\"\\n\") <= 0\\r\\n|| !BIO_indent(bp,off+4,128))\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(bp,\"%02x%s\",buf[i],((i+1) == n)?\"\":\":\")\\r\\n<= 0) return(0);\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) return(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int print_bin(BIO *fp, const char *name, const unsigned char *buf,\\r\\nsize_t len, int off)\\r\\n{\\r\\nsize_t i;\\r\\nchar str[128];\\r\\nif (buf == NULL)\\r\\nreturn 1;\\r\\nif (off)\\r\\n{\\r\\nif (off > 128)\\r\\noff=128;\\r\\nmemset(str,' ',off);\\r\\nif (BIO_write(fp, str, off) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(fp,\"%s\", name) <= 0)\\r\\nreturn 0;\\r\\nfor (i=0; i<len; i++)\\r\\n{\\r\\nif ((i%15) == 0)\\r\\n{\\r\\nstr[0]='\\n';\\r\\nmemset(&(str[1]),' ',off+4);\\r\\nif (BIO_write(fp, str, off+1+4) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(fp,\"%02x%s\",buf[i],((i+1) == len)?\"\":\":\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_write(fp,\"\\n\",1) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint DHparams_print_fp(FILE *fp, const DH *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDHerr(DH_F_DHPARAMS_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DHparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DHparams_print(BIO *bp, const DH *x)\\r\\n{\\r\\nunsigned char *m=NULL;\\r\\nint reason=ERR_R_BUF_LIB,ret=0;\\r\\nsize_t buf_len=0, i;\\r\\nif (x->p)\\r\\nbuf_len = (size_t)BN_num_bytes(x->p);\\r\\nif (x->g)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->g)))\\r\\nbuf_len = i;\\r\\nm=(unsigned char *)OPENSSL_malloc(buf_len+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp,\"Diffie-Hellman-Parameters: (%d bit)\\n\",\\r\\nBN_num_bits(x->p)) <= 0)\\r\\ngoto err;\\r\\nif (!print(bp,\"prime:\",x->p,m,4)) goto err;\\r\\nif (!print(bp,\"generator:\",x->g,m,4)) goto err;\\r\\nif (x->length != 0)\\r\\n{\\r\\nif (BIO_printf(bp,\" recommended-private-length: %d bits\\n\",\\r\\n(int)x->length) <= 0) goto err;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nDHerr(DH_F_DHPARAMS_PRINT,reason);\\r\\n}\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSAparams_print_fp(FILE *fp, const DSA *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSAPARAMS_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DSAparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSAparams_print(BIO *bp, const DSA *x)\\r\\n{\\r\\nunsigned char *m=NULL;\\r\\nint reason=ERR_R_BUF_LIB,ret=0;\\r\\nsize_t buf_len=0,i;\\r\\nif (x->p)\\r\\nbuf_len = (size_t)BN_num_bytes(x->p);\\r\\nif (x->q)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->q)))\\r\\nbuf_len = i;\\r\\nif (x->g)\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(x->g)))\\r\\nbuf_len = i;\\r\\nm=(unsigned char *)OPENSSL_malloc(buf_len+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp,\"DSA-Parameters: (%d bit)\\n\",\\r\\nBN_num_bits(x->p)) <= 0)\\r\\ngoto err;\\r\\nif (!print(bp,\"p:\",x->p,m,4)) goto err;\\r\\nif (!print(bp,\"q:\",x->q,m,4)) goto err;\\r\\nif (!print(bp,\"g:\",x->g,m,4)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nDSAerr(DSA_F_DSAPARAMS_PRINT,reason);\\r\\nreturn(ret);\\r\\n}\\r\\nint ECParameters_print_fp(FILE *fp, const EC_KEY *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nECerr(EC_F_ECPARAMETERS_PRINT_FP, ERR_R_BIO_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = ECParameters_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ECParameters_print(BIO *bp, const EC_KEY *x)\\r\\n{\\r\\nint reason=ERR_R_EC_LIB, ret=0;\\r\\nBIGNUM *order=NULL;\\r\\nconst EC_GROUP *group;\\r\\nif (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)\\r\\n{\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;;\\r\\ngoto err;\\r\\n}\\r\\nif ((order = BN_new()) == NULL)\\r\\n{\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, order, NULL))\\r\\n{\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp, \"ECDSA-Parameters: (%d bit)\\n\",\\r\\nBN_num_bits(order)) <= 0)\\r\\ngoto err;\\r\\nif (!ECPKParameters_print(bp, group, 4))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (order)\\r\\nBN_free(order);\\r\\nECerr(EC_F_ECPARAMETERS_PRINT, reason);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_version_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,ret=0;\\r\\nint cflags=0,version=0,date=0,options=0,platform=0,dir=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (argc == 1) version=1;\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nif (strcmp(argv[i],\"-v\") == 0)\\r\\nversion=1;\\r\\nelse if (strcmp(argv[i],\"-b\") == 0)\\r\\ndate=1;\\r\\nelse if (strcmp(argv[i],\"-f\") == 0)\\r\\ncflags=1;\\r\\nelse if (strcmp(argv[i],\"-o\") == 0)\\r\\noptions=1;\\r\\nelse if (strcmp(argv[i],\"-p\") == 0)\\r\\nplatform=1;\\r\\nelse if (strcmp(argv[i],\"-d\") == 0)\\r\\ndir=1;\\r\\nelse if (strcmp(argv[i],\"-a\") == 0)\\r\\ndate=version=cflags=options=platform=dir=1;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"usage:version -[avbofp]\\n\");\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (version)\\r\\n{\\r\\nif (SSLeay() == SSLEAY_VERSION_NUMBER)\\r\\n{\\r\\nprintf(\"%s\\n\",SSLeay_version(SSLEAY_VERSION));\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"%s (Library: %s)\\n\",\\r\\nOPENSSL_VERSION_TEXT,\\r\\nSSLeay_version(SSLEAY_VERSION));\\r\\n}\\r\\n}\\r\\nif (date) printf(\"%s\\n\",SSLeay_version(SSLEAY_BUILT_ON));\\r\\nif (platform) printf(\"%s\\n\",SSLeay_version(SSLEAY_PLATFORM));\\r\\nif (options)\\r\\n{\\r\\nprintf(\"options: \");\\r\\nprintf(\"%s \",BN_options());\\r\\n#ifndef OPENSSL_NO_MD2\\r\\nprintf(\"%s \",MD2_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nprintf(\"%s \",RC4_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DES\\r\\nprintf(\"%s \",DES_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nprintf(\"%s \",idea_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_BF\\r\\nprintf(\"%s \",BF_options());\\r\\n#endif\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (cflags) printf(\"%s\\n\",SSLeay_version(SSLEAY_CFLAGS));\\r\\nif (dir) printf(\"%s\\n\",SSLeay_version(SSLEAY_DIR));\\r\\nend:\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5_skey_c", "target": 0, "func": "void RC5_32_set_key(RC5_32_KEY *key, int len, const unsigned char *data,\\r\\nint rounds)\\r\\n{\\r\\nRC5_32_INT L[64],l,ll,A,B,*S,k;\\r\\nint i,j,m,c,t,ii,jj;\\r\\nif ( (rounds != RC5_16_ROUNDS) &&\\r\\n(rounds != RC5_12_ROUNDS) &&\\r\\n(rounds != RC5_8_ROUNDS))\\r\\nrounds=RC5_16_ROUNDS;\\r\\nkey->rounds=rounds;\\r\\nS= &(key->data[0]);\\r\\nj=0;\\r\\nfor (i=0; i<=(len-8); i+=8)\\r\\n{\\r\\nc2l(data,l);\\r\\nL[j++]=l;\\r\\nc2l(data,l);\\r\\nL[j++]=l;\\r\\n}\\r\\nii=len-i;\\r\\nif (ii)\\r\\n{\\r\\nk=len&0x07;\\r\\nc2ln(data,l,ll,k);\\r\\nL[j+0]=l;\\r\\nL[j+1]=ll;\\r\\n}\\r\\nc=(len+3)/4;\\r\\nt=(rounds+1)*2;\\r\\nS[0]=RC5_32_P;\\r\\nfor (i=1; i<t; i++)\\r\\nS[i]=(S[i-1]+RC5_32_Q)&RC5_32_MASK;\\r\\nj=(t>c)?t:c;\\r\\nj*=3;\\r\\nii=jj=0;\\r\\nA=B=0;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nk=(S[ii]+A+B)&RC5_32_MASK;\\r\\nA=S[ii]=ROTATE_l32(k,3);\\r\\nm=(int)(A+B);\\r\\nk=(L[jj]+A+B)&RC5_32_MASK;\\r\\nB=L[jj]=ROTATE_l32(k,m);\\r\\nif (++ii >= t) ii=0;\\r\\nif (++jj >= c) jj=0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_example_c", "target": 0, "func": "int add_signed_time(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nASN1_UTCTIME *sign_time;\\r\\nsign_time=X509_gmtime_adj(NULL,0);\\r\\nPKCS7_add_signed_attribute(si,NID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,(char *)sign_time);\\r\\nreturn(1);\\r\\n}\\r\\nASN1_UTCTIME *get_signed_time(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nso=PKCS7_get_signed_attribute(si,NID_pkcs9_signingTime);\\r\\nif (so->type == V_ASN1_UTCTIME)\\r\\nreturn so->value.utctime;\\r\\nreturn NULL;\\r\\n}\\r\\nvoid add_signed_string(PKCS7_SIGNER_INFO *si, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nos=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os,(unsigned char*)str,strlen(str));\\r\\nPKCS7_add_signed_attribute(si,signed_string_nid,\\r\\nV_ASN1_OCTET_STRING,(char *)os);\\r\\n}\\r\\nint get_signed_string(PKCS7_SIGNER_INFO *si, char *buf, int len)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nASN1_OCTET_STRING *os;\\r\\nint i;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nso=PKCS7_get_signed_attribute(si,signed_string_nid);\\r\\nif (so != NULL)\\r\\n{\\r\\nif (so->type == V_ASN1_OCTET_STRING)\\r\\n{\\r\\nos=so->value.octet_string;\\r\\ni=os->length;\\r\\nif ((i+1) > len)\\r\\ni=len-1;\\r\\nmemcpy(buf,os->data,i);\\r\\nreturn(i);\\r\\n}\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint add_signed_seq2string(PKCS7_SIGNER_INFO *si, char *str1, char *str2)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\nASN1_STRING *seq;\\r\\nunsigned char *data;\\r\\nint i,total;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nos1=ASN1_OCTET_STRING_new();\\r\\nos2=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os1,(unsigned char*)str1,strlen(str1));\\r\\nASN1_OCTET_STRING_set(os2,(unsigned char*)str1,strlen(str1));\\r\\ni =i2d_ASN1_OCTET_STRING(os1,NULL);\\r\\ni+=i2d_ASN1_OCTET_STRING(os2,NULL);\\r\\ntotal=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\ndata=malloc(total);\\r\\np=data;\\r\\nASN1_put_object(&p,1,i,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_OCTET_STRING(os1,&p);\\r\\ni2d_ASN1_OCTET_STRING(os2,&p);\\r\\nseq=ASN1_STRING_new();\\r\\nASN1_STRING_set(seq,data,total);\\r\\nfree(data);\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nPKCS7_add_signed_attribute(si,signed_seq2string_nid,\\r\\nV_ASN1_SEQUENCE,(char *)seq);\\r\\nreturn(1);\\r\\n}\\r\\nint get_signed_seq2string(PKCS7_SIGNER_INFO *si, char **str1, char **str2)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nso=PKCS7_get_signed_attribute(si,signed_seq2string_nid);\\r\\nif (so && (so->type == V_ASN1_SEQUENCE))\\r\\n{\\r\\nASN1_const_CTX c;\\r\\nASN1_STRING *s;\\r\\nlong length;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\ns=so->value.sequence;\\r\\nc.p=ASN1_STRING_data(s);\\r\\nc.max=c.p+ASN1_STRING_length(s);\\r\\nif (!asn1_GetSequence(&c,&length)) goto err;\\r\\nc.q=c.p;\\r\\nif ((os1=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nc.q=c.p;\\r\\nif ((os2=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nif (!asn1_const_Finish(&c)) goto err;\\r\\n*str1=malloc(os1->length+1);\\r\\n*str2=malloc(os2->length+1);\\r\\nmemcpy(*str1,os1->data,os1->length);\\r\\nmemcpy(*str2,os2->data,os2->length);\\r\\n(*str1)[os1->length]='\\0';\\r\\n(*str2)[os2->length]='\\0';\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nreturn(1);\\r\\n}\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nX509_ATTRIBUTE *create_time(void)\\r\\n{\\r\\nASN1_UTCTIME *sign_time;\\r\\nX509_ATTRIBUTE *ret;\\r\\nsign_time=X509_gmtime_adj(NULL,0);\\r\\nret=X509_ATTRIBUTE_create(NID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,(char *)sign_time);\\r\\nreturn(ret);\\r\\n}\\r\\nX509_ATTRIBUTE *create_string(char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nX509_ATTRIBUTE *ret;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nos=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os,(unsigned char*)str,strlen(str));\\r\\nret=X509_ATTRIBUTE_create(signed_string_nid,\\r\\nV_ASN1_OCTET_STRING,(char *)os);\\r\\nreturn(ret);\\r\\n}\\r\\nX509_ATTRIBUTE *add_seq2string(PKCS7_SIGNER_INFO *si, char *str1, char *str2)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\nASN1_STRING *seq;\\r\\nX509_ATTRIBUTE *ret;\\r\\nunsigned char *data;\\r\\nint i,total;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nos1=ASN1_OCTET_STRING_new();\\r\\nos2=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os1,(unsigned char*)str1,strlen(str1));\\r\\nASN1_OCTET_STRING_set(os2,(unsigned char*)str1,strlen(str1));\\r\\ni =i2d_ASN1_OCTET_STRING(os1,NULL);\\r\\ni+=i2d_ASN1_OCTET_STRING(os2,NULL);\\r\\ntotal=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\ndata=malloc(total);\\r\\np=data;\\r\\nASN1_put_object(&p,1,i,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_OCTET_STRING(os1,&p);\\r\\ni2d_ASN1_OCTET_STRING(os2,&p);\\r\\nseq=ASN1_STRING_new();\\r\\nASN1_STRING_set(seq,data,total);\\r\\nfree(data);\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nret=X509_ATTRIBUTE_create(signed_seq2string_nid,\\r\\nV_ASN1_SEQUENCE,(char *)seq);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_ocsp_c", "target": 0, "func": "static int i2r_ocsp_crlid(X509V3_EXT_METHOD *method, void *in, BIO *bp, int ind)\\r\\n{\\r\\nOCSP_CRLID *a = in;\\r\\nif (a->crlUrl)\\r\\n{\\r\\nif (!BIO_printf(bp, \"%*scrlUrl: \", ind, \"\")) goto err;\\r\\nif (!ASN1_STRING_print(bp, (ASN1_STRING*)a->crlUrl)) goto err;\\r\\nif (!BIO_write(bp, \"\\n\", 1)) goto err;\\r\\n}\\r\\nif (a->crlNum)\\r\\n{\\r\\nif (!BIO_printf(bp, \"%*scrlNum: \", ind, \"\")) goto err;\\r\\nif (!i2a_ASN1_INTEGER(bp, a->crlNum)) goto err;\\r\\nif (!BIO_write(bp, \"\\n\", 1)) goto err;\\r\\n}\\r\\nif (a->crlTime)\\r\\n{\\r\\nif (!BIO_printf(bp, \"%*scrlTime: \", ind, \"\")) goto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, a->crlTime)) goto err;\\r\\nif (!BIO_write(bp, \"\\n\", 1)) goto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nstatic int i2r_ocsp_acutoff(X509V3_EXT_METHOD *method, void *cutoff, BIO *bp, int ind)\\r\\n{\\r\\nif (!BIO_printf(bp, \"%*s\", ind, \"\")) return 0;\\r\\nif(!ASN1_GENERALIZEDTIME_print(bp, cutoff)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_object(X509V3_EXT_METHOD *method, void *oid, BIO *bp, int ind)\\r\\n{\\r\\nif (!BIO_printf(bp, \"%*s\", ind, \"\")) return 0;\\r\\nif(!i2a_ASN1_OBJECT(bp, oid)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void *ocsp_nonce_new(void)\\r\\n{\\r\\nreturn ASN1_OCTET_STRING_new();\\r\\n}\\r\\nstatic int i2d_ocsp_nonce(void *a, unsigned char **pp)\\r\\n{\\r\\nASN1_OCTET_STRING *os = a;\\r\\nif(pp) {\\r\\nmemcpy(*pp, os->data, os->length);\\r\\n*pp += os->length;\\r\\n}\\r\\nreturn os->length;\\r\\n}\\r\\nstatic void *d2i_ocsp_nonce(void *a, const unsigned char **pp, long length)\\r\\n{\\r\\nASN1_OCTET_STRING *os, **pos;\\r\\npos = a;\\r\\nif(!pos || !*pos) os = ASN1_OCTET_STRING_new();\\r\\nelse os = *pos;\\r\\nif(!ASN1_OCTET_STRING_set(os, *pp, length)) goto err;\\r\\n*pp += length;\\r\\nif(pos) *pos = os;\\r\\nreturn os;\\r\\nerr:\\r\\nif(os && (!pos || (*pos != os))) M_ASN1_OCTET_STRING_free(os);\\r\\nOCSPerr(OCSP_F_D2I_OCSP_NONCE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic void ocsp_nonce_free(void *a)\\r\\n{\\r\\nM_ASN1_OCTET_STRING_free(a);\\r\\n}\\r\\nstatic int i2r_ocsp_nonce(X509V3_EXT_METHOD *method, void *nonce, BIO *out, int indent)\\r\\n{\\r\\nif(BIO_printf(out, \"%*s\", indent, \"\") <= 0) return 0;\\r\\nif(i2a_ASN1_STRING(out, nonce, V_ASN1_OCTET_STRING) <= 0) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_ocsp_nocheck(X509V3_EXT_METHOD *method, void *nocheck, BIO *out, int indent)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic void *s2i_ocsp_nocheck(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, const char *str)\\r\\n{\\r\\nreturn ASN1_NULL_new();\\r\\n}\\r\\nstatic int i2r_ocsp_serviceloc(X509V3_EXT_METHOD *method, void *in, BIO *bp, int ind)\\r\\n{\\r\\nint i;\\r\\nOCSP_SERVICELOC *a = in;\\r\\nACCESS_DESCRIPTION *ad;\\r\\nif (BIO_printf(bp, \"%*sIssuer: \", ind, \"\") <= 0) goto err;\\r\\nif (X509_NAME_print_ex(bp, a->issuer, 0, XN_FLAG_ONELINE) <= 0) goto err;\\r\\nfor (i = 0; i < sk_ACCESS_DESCRIPTION_num(a->locator); i++)\\r\\n{\\r\\nad = sk_ACCESS_DESCRIPTION_value(a->locator,i);\\r\\nif (BIO_printf(bp, \"\\n%*s\", (2*ind), \"\") <= 0)\\r\\ngoto err;\\r\\nif(i2a_ASN1_OBJECT(bp, ad->method) <= 0) goto err;\\r\\nif(BIO_puts(bp, \" - \") <= 0) goto err;\\r\\nif(GENERAL_NAME_print(bp, ad->location) <= 0) goto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_sign_c", "target": 0, "func": "void EVP_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit_ex(ctx,type);\\r\\n}\\r\\nvoid EVP_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,\\r\\nunsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,data,count);\\r\\n}\\r\\nint EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\\r\\nEVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i,ok=0,v;\\r\\nMS_STATIC EVP_MD_CTX tmp_ctx;\\r\\n*siglen=0;\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nEVP_MD_CTX_copy_ex(&tmp_ctx,ctx);\\r\\nEVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len);\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nv=ctx->digest->required_pkey_type[i];\\r\\nif (v == 0) break;\\r\\nif (pkey->type == v)\\r\\n{\\r\\nok=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (ctx->digest->sign == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_NO_SIGN_FUNCTION_CONFIGURED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ctx->digest->sign(ctx->digest->type,m,m_len,sigret,siglen,\\r\\npkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_check_c", "target": 0, "func": "int DH_check(const DH *dh, int *ret)\\r\\n{\\r\\nint ok=0;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_ULONG l;\\r\\nBIGNUM *q=NULL;\\r\\n*ret=0;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nq=BN_new();\\r\\nif (q == NULL) goto err;\\r\\nif (BN_is_word(dh->g,DH_GENERATOR_2))\\r\\n{\\r\\nl=BN_mod_word(dh->p,24);\\r\\nif (l != 11) *ret|=DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\n#if 0\\r\\nelse if (BN_is_word(dh->g,DH_GENERATOR_3))\\r\\n{\\r\\nl=BN_mod_word(dh->p,12);\\r\\nif (l != 5) *ret|=DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\n#endif\\r\\nelse if (BN_is_word(dh->g,DH_GENERATOR_5))\\r\\n{\\r\\nl=BN_mod_word(dh->p,10);\\r\\nif ((l != 3) && (l != 7))\\r\\n*ret|=DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\nelse\\r\\n*ret|=DH_UNABLE_TO_CHECK_GENERATOR;\\r\\nif (!BN_is_prime_ex(dh->p,BN_prime_checks,ctx,NULL))\\r\\n*ret|=DH_CHECK_P_NOT_PRIME;\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(q,dh->p)) goto err;\\r\\nif (!BN_is_prime_ex(q,BN_prime_checks,ctx,NULL))\\r\\n*ret|=DH_CHECK_P_NOT_SAFE_PRIME;\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nif (q != NULL) BN_free(q);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i_cfb64_c", "target": 0, "func": "void idea_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, IDEA_KEY_SCHEDULE *schedule,\\r\\nunsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_vfy_c", "target": 0, "func": "static int ocsp_check_delegated(X509 *x, int flags)\\r\\n{\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif ((x->ex_flags & EXFLAG_XKUSAGE) &&\\r\\n(x->ex_xkusage & XKU_OCSP_SIGN))\\r\\nreturn 1;\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_DELEGATED, OCSP_R_MISSING_OCSPSIGNING_USAGE);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mdc2dgst_c", "target": 0, "func": "int MDC2_Init(MDC2_CTX *c)\\r\\n{\\r\\nc->num=0;\\r\\nc->pad_type=1;\\r\\nmemset(&(c->h[0]),0x52,MDC2_BLOCK);\\r\\nmemset(&(c->hh[0]),0x25,MDC2_BLOCK);\\r\\nreturn 1;\\r\\n}\\r\\nint MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)\\r\\n{\\r\\nsize_t i,j;\\r\\ni=c->num;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i+len < MDC2_BLOCK)\\r\\n{\\r\\nmemcpy(&(c->data[i]),in,len);\\r\\nc->num+=(int)len;\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=MDC2_BLOCK-i;\\r\\nmemcpy(&(c->data[i]),in,j);\\r\\nlen-=j;\\r\\nin+=j;\\r\\nc->num=0;\\r\\nmdc2_body(c,&(c->data[0]),MDC2_BLOCK);\\r\\n}\\r\\n}\\r\\ni=len&~((size_t)MDC2_BLOCK-1);\\r\\nif (i > 0) mdc2_body(c,in,i);\\r\\nj=len-i;\\r\\nif (j > 0)\\r\\n{\\r\\nmemcpy(&(c->data[0]),&(in[i]),j);\\r\\nc->num=(int)j;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void mdc2_body(MDC2_CTX *c, const unsigned char *in, size_t len)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG ttin0,ttin1;\\r\\nDES_LONG d[2],dd[2];\\r\\nDES_key_schedule k;\\r\\nunsigned char *p;\\r\\nsize_t i;\\r\\nfor (i=0; i<len; i+=8)\\r\\n{\\r\\nc2l(in,tin0); d[0]=dd[0]=tin0;\\r\\nc2l(in,tin1); d[1]=dd[1]=tin1;\\r\\nc->h[0]=(c->h[0]&0x9f)|0x40;\\r\\nc->hh[0]=(c->hh[0]&0x9f)|0x20;\\r\\nDES_set_odd_parity(&c->h);\\r\\nDES_set_key_unchecked(&c->h,&k);\\r\\nDES_encrypt1(d,&k,1);\\r\\nDES_set_odd_parity(&c->hh);\\r\\nDES_set_key_unchecked(&c->hh,&k);\\r\\nDES_encrypt1(dd,&k,1);\\r\\nttin0=tin0^dd[0];\\r\\nttin1=tin1^dd[1];\\r\\ntin0^=d[0];\\r\\ntin1^=d[1];\\r\\np=c->h;\\r\\nl2c(tin0,p);\\r\\nl2c(ttin1,p);\\r\\np=c->hh;\\r\\nl2c(ttin0,p);\\r\\nl2c(tin1,p);\\r\\n}\\r\\n}\\r\\nint MDC2_Final(unsigned char *md, MDC2_CTX *c)\\r\\n{\\r\\nunsigned int i;\\r\\nint j;\\r\\ni=c->num;\\r\\nj=c->pad_type;\\r\\nif ((i > 0) || (j == 2))\\r\\n{\\r\\nif (j == 2)\\r\\nc->data[i++]=0x80;\\r\\nmemset(&(c->data[i]),0,MDC2_BLOCK-i);\\r\\nmdc2_body(c,c->data,MDC2_BLOCK);\\r\\n}\\r\\nmemcpy(md,(char *)c->h,MDC2_BLOCK);\\r\\nmemcpy(&(md[MDC2_BLOCK]),(char *)c->hh,MDC2_BLOCK);\\r\\nreturn 1;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char md[MDC2_DIGEST_LENGTH];\\r\\nint i;\\r\\nMDC2_CTX c;\\r\\nstatic char *text=\"Now is the time for all \";\\r\\nMDC2_Init(&c);\\r\\nMDC2_Update(&c,text,strlen(text));\\r\\nMDC2_Final(&(md[0]),&c);\\r\\nfor (i=0; i<MDC2_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02X\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_object_c", "target": 0, "func": "int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp)\\r\\n{\\r\\nunsigned char *p;\\r\\nint objsize;\\r\\nif ((a == NULL) || (a->data == NULL)) return(0);\\r\\nobjsize = ASN1_object_size(0,a->length,V_ASN1_OBJECT);\\r\\nif (pp == NULL) return objsize;\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,a->length,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\\r\\nmemcpy(p,a->data,a->length);\\r\\np+=a->length;\\r\\n*pp=p;\\r\\nreturn(objsize);\\r\\n}\\r\\nint a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)\\r\\n{\\r\\nint i,first,len=0,c;\\r\\nchar tmp[24];\\r\\nconst char *p;\\r\\nunsigned long l;\\r\\nif (num == 0)\\r\\nreturn(0);\\r\\nelse if (num == -1)\\r\\nnum=strlen(buf);\\r\\np=buf;\\r\\nc= *(p++);\\r\\nnum--;\\r\\nif ((c >= '0') && (c <= '2'))\\r\\n{\\r\\nfirst=(c-'0')*40;\\r\\n}\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_FIRST_NUM_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (num <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_MISSING_SECOND_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nc= *(p++);\\r\\nnum--;\\r\\nfor (;;)\\r\\n{\\r\\nif (num <= 0) break;\\r\\nif ((c != '.') && (c != ' '))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_INVALID_SEPARATOR);\\r\\ngoto err;\\r\\n}\\r\\nl=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (num <= 0) break;\\r\\nnum--;\\r\\nc= *(p++);\\r\\nif ((c == ' ') || (c == '.'))\\r\\nbreak;\\r\\nif ((c < '0') || (c > '9'))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_INVALID_DIGIT);\\r\\ngoto err;\\r\\n}\\r\\nl=l*10L+(long)(c-'0');\\r\\n}\\r\\nif (len == 0)\\r\\n{\\r\\nif ((first < 2) && (l >= 40))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_SECOND_NUMBER_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nl+=(long)first;\\r\\n}\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\ntmp[i++]=(unsigned char)l&0x7f;\\r\\nl>>=7L;\\r\\nif (l == 0L) break;\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nif (len+i > olen)\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nwhile (--i > 0)\\r\\nout[len++]=tmp[i]|0x80;\\r\\nout[len++]=tmp[0];\\r\\n}\\r\\nelse\\r\\nlen+=i;\\r\\n}\\r\\nreturn(len);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a)\\r\\n{\\r\\nreturn OBJ_obj2txt(buf, buf_len, a, 0);\\r\\n}\\r\\nint i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a)\\r\\n{\\r\\nchar buf[80];\\r\\nint i;\\r\\nif ((a == NULL) || (a->data == NULL))\\r\\nreturn(BIO_write(bp,\"NULL\",4));\\r\\ni=i2t_ASN1_OBJECT(buf,sizeof buf,a);\\r\\nif (i > (int)sizeof(buf)) i=sizeof buf;\\r\\nBIO_write(bp,buf,i);\\r\\nreturn(i);\\r\\n}\\r\\nASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nlong len;\\r\\nint tag,xclass;\\r\\nint inf,i;\\r\\nASN1_OBJECT *ret = NULL;\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_OBJECT)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_OBJECT;\\r\\ngoto err;\\r\\n}\\r\\nret = c2i_ASN1_OBJECT(a, &p, len);\\r\\nif(ret) *pp = p;\\r\\nreturn ret;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_OBJECT,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_OBJECT_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\\r\\nlong len)\\r\\n{\\r\\nASN1_OBJECT *ret=NULL;\\r\\nconst unsigned char *p;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL) ||\\r\\n!((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC))\\r\\n{\\r\\nif ((ret=ASN1_OBJECT_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse ret=(*a);\\r\\np= *pp;\\r\\nif ((ret->data == NULL) || (ret->length < len))\\r\\n{\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\nret->data=(unsigned char *)OPENSSL_malloc(len ? (int)len : 1);\\r\\nret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\nif (ret->data == NULL)\\r\\n{ i=ERR_R_MALLOC_FAILURE; goto err; }\\r\\n}\\r\\nmemcpy(ret->data,p,(int)len);\\r\\nret->length=(int)len;\\r\\nret->sn=NULL;\\r\\nret->ln=NULL;\\r\\np+=len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_OBJECT,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_OBJECT_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_new(void)\\r\\n{\\r\\nASN1_OBJECT *ret;\\r\\nret=(ASN1_OBJECT *)OPENSSL_malloc(sizeof(ASN1_OBJECT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_OBJECT_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->data=NULL;\\r\\nret->nid=0;\\r\\nret->sn=NULL;\\r\\nret->ln=NULL;\\r\\nret->flags=ASN1_OBJECT_FLAG_DYNAMIC;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ASN1_OBJECT_free(ASN1_OBJECT *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS)\\r\\n{\\r\\n#ifndef CONST_STRICT\\r\\nif (a->sn != NULL) OPENSSL_free((void *)a->sn);\\r\\nif (a->ln != NULL) OPENSSL_free((void *)a->ln);\\r\\n#endif\\r\\na->sn=a->ln=NULL;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA)\\r\\n{\\r\\nif (a->data != NULL) OPENSSL_free(a->data);\\r\\na->data=NULL;\\r\\na->length=0;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC)\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,\\r\\nconst char *sn, const char *ln)\\r\\n{\\r\\nASN1_OBJECT o;\\r\\no.sn=sn;\\r\\no.ln=ln;\\r\\no.data=data;\\r\\no.nid=nid;\\r\\no.length=len;\\r\\no.flags=ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\nreturn(OBJ_dup(&o));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec2_mult_c", "target": 0, "func": "static int gf2m_Mdouble(const EC_GROUP *group, BIGNUM *x, BIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t1;\\r\\nint ret = 0;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL) goto err;\\r\\nif (!group->meth->field_sqr(group, x, x, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, t1, z, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, z, x, t1, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, x, x, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, t1, t1, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, t1, &group->b, t1, ctx)) goto err;\\r\\nif (!BN_GF2m_add(x, x, t1)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int gf2m_Madd(const EC_GROUP *group, const BIGNUM *x, BIGNUM *x1, BIGNUM *z1,\\r\\nconst BIGNUM *x2, const BIGNUM *z2, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t1, *t2;\\r\\nint ret = 0;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t2 == NULL) goto err;\\r\\nif (!BN_copy(t1, x)) goto err;\\r\\nif (!group->meth->field_mul(group, x1, x1, z2, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, z1, z1, x2, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, t2, x1, z1, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z1, z1, x1)) goto err;\\r\\nif (!group->meth->field_sqr(group, z1, z1, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, x1, z1, t1, ctx)) goto err;\\r\\nif (!BN_GF2m_add(x1, x1, t2)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int gf2m_Mxy(const EC_GROUP *group, const BIGNUM *x, const BIGNUM *y, BIGNUM *x1,\\r\\nBIGNUM *z1, BIGNUM *x2, BIGNUM *z2, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t3, *t4, *t5;\\r\\nint ret = 0;\\r\\nif (BN_is_zero(z1))\\r\\n{\\r\\nBN_zero(x2);\\r\\nBN_zero(z2);\\r\\nreturn 1;\\r\\n}\\r\\nif (BN_is_zero(z2))\\r\\n{\\r\\nif (!BN_copy(x2, x)) return 0;\\r\\nif (!BN_GF2m_add(z2, x, y)) return 0;\\r\\nreturn 2;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nt3 = BN_CTX_get(ctx);\\r\\nt4 = BN_CTX_get(ctx);\\r\\nt5 = BN_CTX_get(ctx);\\r\\nif (t5 == NULL) goto err;\\r\\nif (!BN_one(t5)) goto err;\\r\\nif (!group->meth->field_mul(group, t3, z1, z2, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, z1, z1, x, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z1, z1, x1)) goto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, x, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, x1, z2, x1, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z2, z2, x2)) goto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, z1, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, t4, x, ctx)) goto err;\\r\\nif (!BN_GF2m_add(t4, t4, y)) goto err;\\r\\nif (!group->meth->field_mul(group, t4, t4, t3, ctx)) goto err;\\r\\nif (!BN_GF2m_add(t4, t4, z2)) goto err;\\r\\nif (!group->meth->field_mul(group, t3, t3, x, ctx)) goto err;\\r\\nif (!group->meth->field_div(group, t3, t5, t3, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, t4, t3, t4, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, x2, x1, t3, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z2, x2, x)) goto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, t4, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z2, z2, y)) goto err;\\r\\nret = 2;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ec_GF2m_montgomery_point_multiply(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nconst EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *x1, *x2, *z1, *z2;\\r\\nint ret = 0, i, j;\\r\\nBN_ULONG mask;\\r\\nif (r == point)\\r\\n{\\r\\nECerr(EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY, EC_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar == NULL) || BN_is_zero(scalar) || (point == NULL) ||\\r\\nEC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nreturn EC_POINT_set_to_infinity(group, r);\\r\\n}\\r\\nif (!point->Z_is_one) return 0;\\r\\nBN_CTX_start(ctx);\\r\\nx1 = BN_CTX_get(ctx);\\r\\nz1 = BN_CTX_get(ctx);\\r\\nif (z1 == NULL) goto err;\\r\\nx2 = &r->X;\\r\\nz2 = &r->Y;\\r\\nif (!BN_GF2m_mod_arr(x1, &point->X, group->poly)) goto err;\\r\\nif (!BN_one(z1)) goto err;\\r\\nif (!group->meth->field_sqr(group, z2, x1, ctx)) goto err;\\r\\nif (!group->meth->field_sqr(group, x2, z2, ctx)) goto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->b)) goto err;\\r\\ni = scalar->top - 1; j = BN_BITS2 - 1;\\r\\nmask = BN_TBIT;\\r\\nwhile (!(scalar->d[i] & mask)) { mask >>= 1; j--; }\\r\\nmask >>= 1; j--;\\r\\nif (!mask)\\r\\n{\\r\\ni--; j = BN_BITS2 - 1;\\r\\nmask = BN_TBIT;\\r\\n}\\r\\nfor (; i >= 0; i--)\\r\\n{\\r\\nfor (; j >= 0; j--)\\r\\n{\\r\\nif (scalar->d[i] & mask)\\r\\n{\\r\\nif (!gf2m_Madd(group, &point->X, x1, z1, x2, z2, ctx)) goto err;\\r\\nif (!gf2m_Mdouble(group, x2, z2, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx)) goto err;\\r\\nif (!gf2m_Mdouble(group, x1, z1, ctx)) goto err;\\r\\n}\\r\\nmask >>= 1;\\r\\n}\\r\\nj = BN_BITS2 - 1;\\r\\nmask = BN_TBIT;\\r\\n}\\r\\ni = gf2m_Mxy(group, &point->X, &point->Y, x1, z1, x2, z2, ctx);\\r\\nif (i == 0) goto err;\\r\\nelse if (i == 1)\\r\\n{\\r\\nif (!EC_POINT_set_to_infinity(group, r)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_one(&r->Z)) goto err;\\r\\nr->Z_is_one = 1;\\r\\n}\\r\\nBN_set_negative(&r->X, 0);\\r\\nBN_set_negative(&r->Y, 0);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nsize_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nsize_t i;\\r\\nEC_POINT *p=NULL;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar && (num > 1)) || (num > 2) || (num == 0 && EC_GROUP_have_precompute_mult(group)))\\r\\n{\\r\\nret = ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);\\r\\ngoto err;\\r\\n}\\r\\nif ((p = EC_POINT_new(group)) == NULL) goto err;\\r\\nif (!EC_POINT_set_to_infinity(group, r)) goto err;\\r\\nif (scalar)\\r\\n{\\r\\nif (!ec_GF2m_montgomery_point_multiply(group, p, scalar, group->generator, ctx)) goto err;\\r\\nif (BN_is_negative(scalar))\\r\\nif (!group->meth->invert(group, p, ctx)) goto err;\\r\\nif (!group->meth->add(group, r, r, p, ctx)) goto err;\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif (!ec_GF2m_montgomery_point_multiply(group, p, scalars[i], points[i], ctx)) goto err;\\r\\nif (BN_is_negative(scalars[i]))\\r\\nif (!group->meth->invert(group, p, ctx)) goto err;\\r\\nif (!group->meth->add(group, r, r, p, ctx)) goto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (p) EC_POINT_free(p);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nreturn ec_wNAF_precompute_mult(group, ctx);\\r\\n}\\r\\nint ec_GF2m_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nreturn ec_wNAF_have_precompute_mult(group);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_nbio_c", "target": 0, "func": "BIO_METHOD *BIO_f_nbio_test(void)\\r\\n{\\r\\nreturn(&methods_nbiof);\\r\\n}\\r\\nstatic int nbiof_new(BIO *bi)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nif (!(nt=(NBIO_TEST *)OPENSSL_malloc(sizeof(NBIO_TEST)))) return(0);\\r\\nnt->lrn= -1;\\r\\nnt->lwn= -1;\\r\\nbi->ptr=(char *)nt;\\r\\nbi->init=1;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nbiof_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nbiof_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nint ret=0;\\r\\n#if 1\\r\\nint num;\\r\\nunsigned char n;\\r\\n#endif\\r\\nif (out == NULL) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nnt=(NBIO_TEST *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 1\\r\\nRAND_pseudo_bytes(&n,1);\\r\\nnum=(n&0x07);\\r\\nif (outl > num) outl=num;\\r\\nif (num == 0)\\r\\n{\\r\\nret= -1;\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (ret < 0)\\r\\nBIO_copy_next_retry(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nbiof_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nint ret=0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nnt=(NBIO_TEST *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 1\\r\\nif (nt->lwn > 0)\\r\\n{\\r\\nnum=nt->lwn;\\r\\nnt->lwn=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nRAND_pseudo_bytes(&n,1);\\r\\nnum=(n&7);\\r\\n}\\r\\nif (inl > num) inl=num;\\r\\nif (num == 0)\\r\\n{\\r\\nret= -1;\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nif (ret < 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nnt->lwn=inl;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nbiof_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nbiof_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nbiof_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_gets(bp->next_bio,buf,size));\\r\\n}\\r\\nstatic int nbiof_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_puts(bp->next_bio,str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_crl_c", "target": 0, "func": "int X509_CRL_print_fp(FILE *fp, X509_CRL *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_CRL_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_CRL_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_CRL_print(BIO *out, X509_CRL *x)\\r\\n{\\r\\nSTACK_OF(X509_REVOKED) *rev;\\r\\nX509_REVOKED *r;\\r\\nlong l;\\r\\nint i, n;\\r\\nchar *p;\\r\\nBIO_printf(out, \"Certificate Revocation List (CRL):\\n\");\\r\\nl = X509_CRL_get_version(x);\\r\\nBIO_printf(out, \"%8sVersion %lu (0x%lx)\\n\", \"\", l+1, l);\\r\\ni = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nBIO_printf(out, \"%8sSignature Algorithm: %s\\n\", \"\",\\r\\n(i == NID_undef) ? \"NONE\" : OBJ_nid2ln(i));\\r\\np=X509_NAME_oneline(X509_CRL_get_issuer(x),NULL,0);\\r\\nBIO_printf(out,\"%8sIssuer: %s\\n\",\"\",p);\\r\\nOPENSSL_free(p);\\r\\nBIO_printf(out,\"%8sLast Update: \",\"\");\\r\\nASN1_TIME_print(out,X509_CRL_get_lastUpdate(x));\\r\\nBIO_printf(out,\"\\n%8sNext Update: \",\"\");\\r\\nif (X509_CRL_get_nextUpdate(x))\\r\\nASN1_TIME_print(out,X509_CRL_get_nextUpdate(x));\\r\\nelse BIO_printf(out,\"NONE\");\\r\\nBIO_printf(out,\"\\n\");\\r\\nn=X509_CRL_get_ext_count(x);\\r\\nX509V3_extensions_print(out, \"CRL extensions\",\\r\\nx->crl->extensions, 0, 8);\\r\\nrev = X509_CRL_get_REVOKED(x);\\r\\nif(sk_X509_REVOKED_num(rev) > 0)\\r\\nBIO_printf(out, \"Revoked Certificates:\\n\");\\r\\nelse BIO_printf(out, \"No Revoked Certificates.\\n\");\\r\\nfor(i = 0; i < sk_X509_REVOKED_num(rev); i++) {\\r\\nr = sk_X509_REVOKED_value(rev, i);\\r\\nBIO_printf(out,\" Serial Number: \");\\r\\ni2a_ASN1_INTEGER(out,r->serialNumber);\\r\\nBIO_printf(out,\"\\n Revocation Date: \");\\r\\nASN1_TIME_print(out,r->revocationDate);\\r\\nBIO_printf(out,\"\\n\");\\r\\nX509V3_extensions_print(out, \"CRL entry extensions\",\\r\\nr->extensions, 0, 8);\\r\\n}\\r\\nX509_signature_print(out, x->sig_alg, x->signature);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_bf_c", "target": 0, "func": "static int bf_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nBF_set_key(&data(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),key);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_exp_c", "target": 0, "func": "main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nBN_CTX ctx;\\r\\nBIGNUM a,b,c,r,rr,t,l;\\r\\nint j,i,size=SIZE,num=NUM,mod=MOD;\\r\\nchar *start,*end;\\r\\nBN_MONT_CTX mont;\\r\\ndouble d,md;\\r\\nBN_MONT_CTX_init(&mont);\\r\\nBN_CTX_init(&ctx);\\r\\nBN_init(&a);\\r\\nBN_init(&b);\\r\\nBN_init(&c);\\r\\nBN_init(&r);\\r\\nstart=ms_time_new();\\r\\nend=ms_time_new();\\r\\nwhile (size <= 1024*8)\\r\\n{\\r\\nBN_rand(&a,size,0,0);\\r\\nBN_rand(&b,size,1,0);\\r\\nBN_rand(&c,size,0,1);\\r\\nBN_mod(&a,&a,&c,&ctx);\\r\\nms_time_get(start);\\r\\nfor (i=0; i<10; i++)\\r\\nBN_MONT_CTX_set(&mont,&c,&ctx);\\r\\nms_time_get(end);\\r\\nmd=ms_time_diff(start,end);\\r\\nms_time_get(start);\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nBN_mod_exp_mont(&r,&a,&b,&c,&ctx,&mont);\\r\\n}\\r\\nms_time_get(end);\\r\\nd=ms_time_diff(start,end);\\r\\nprintf(\"%5d bit:%6.2f %6d %6.4f %4d m_set(%5.4f)\\n\",size,\\r\\nd,num,d/num,(int)((d/num)*mod),md/10.0);\\r\\nnum/=8;\\r\\nmod/=8;\\r\\nif (num <= 0) num=1;\\r\\nsize*=2;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_lib_c", "target": 0, "func": "int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->set_asn1_parameters != NULL)\\r\\nret=c->cipher->set_asn1_parameters(c,type);\\r\\nelse\\r\\nret=-1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->get_asn1_parameters != NULL)\\r\\nret=c->cipher->get_asn1_parameters(c,type);\\r\\nelse\\r\\nret=-1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i=0;\\r\\nunsigned int l;\\r\\nif (type != NULL)\\r\\n{\\r\\nl=EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(l <= sizeof(c->iv));\\r\\ni=ASN1_TYPE_get_octetstring(type,c->oiv,l);\\r\\nif (i != (int)l)\\r\\nreturn(-1);\\r\\nelse if (i > 0)\\r\\nmemcpy(c->iv,c->oiv,l);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nint EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i=0;\\r\\nunsigned int j;\\r\\nif (type != NULL)\\r\\n{\\r\\nj=EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(j <= sizeof(c->iv));\\r\\ni=ASN1_TYPE_set_octetstring(type,c->oiv,j);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nint EVP_CIPHER_type(const EVP_CIPHER *ctx)\\r\\n{\\r\\nint nid;\\r\\nASN1_OBJECT *otmp;\\r\\nnid = EVP_CIPHER_nid(ctx);\\r\\nswitch(nid) {\\r\\ncase NID_rc2_cbc:\\r\\ncase NID_rc2_64_cbc:\\r\\ncase NID_rc2_40_cbc:\\r\\nreturn NID_rc2_cbc;\\r\\ncase NID_rc4:\\r\\ncase NID_rc4_40:\\r\\nreturn NID_rc4;\\r\\ncase NID_aes_128_cfb128:\\r\\ncase NID_aes_128_cfb8:\\r\\ncase NID_aes_128_cfb1:\\r\\nreturn NID_aes_128_cfb128;\\r\\ncase NID_aes_192_cfb128:\\r\\ncase NID_aes_192_cfb8:\\r\\ncase NID_aes_192_cfb1:\\r\\nreturn NID_aes_192_cfb128;\\r\\ncase NID_aes_256_cfb128:\\r\\ncase NID_aes_256_cfb8:\\r\\ncase NID_aes_256_cfb1:\\r\\nreturn NID_aes_256_cfb128;\\r\\ncase NID_des_cfb64:\\r\\ncase NID_des_cfb8:\\r\\ncase NID_des_cfb1:\\r\\nreturn NID_des_cfb64;\\r\\ndefault:\\r\\notmp = OBJ_nid2obj(nid);\\r\\nif(!otmp || !otmp->data) nid = NID_undef;\\r\\nASN1_OBJECT_free(otmp);\\r\\nreturn nid;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_decr_c", "target": 0, "func": "unsigned char * PKCS12_pbe_crypt(X509_ALGOR *algor, const char *pass,\\r\\nint passlen, unsigned char *in, int inlen, unsigned char **data,\\r\\nint *datalen, int en_de)\\r\\n{\\r\\nunsigned char *out;\\r\\nint outlen, i;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nif (!EVP_PBE_CipherInit(algor->algorithm, pass, passlen,\\r\\nalgor->parameter, &ctx, en_de)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_ALGOR_CIPHERINIT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(out = OPENSSL_malloc(inlen + EVP_CIPHER_CTX_block_size(&ctx)))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CipherUpdate(&ctx, out, &i, in, inlen);\\r\\noutlen = i;\\r\\nif(!EVP_CipherFinal_ex(&ctx, out + i, &i)) {\\r\\nOPENSSL_free(out);\\r\\nout = NULL;\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_CIPHERFINAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\noutlen += i;\\r\\nif (datalen) *datalen = outlen;\\r\\nif (data) *data = out;\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nreturn out;\\r\\n}\\r\\nvoid * PKCS12_item_decrypt_d2i(X509_ALGOR *algor, const ASN1_ITEM *it,\\r\\nconst char *pass, int passlen, ASN1_OCTET_STRING *oct, int zbuf)\\r\\n{\\r\\nunsigned char *out;\\r\\nconst unsigned char *p;\\r\\nvoid *ret;\\r\\nint outlen;\\r\\nif (!PKCS12_pbe_crypt(algor, pass, passlen, oct->data, oct->length,\\r\\n&out, &outlen, 0)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_DECRYPT_D2I,PKCS12_R_PKCS12_PBE_CRYPT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\np = out;\\r\\n#ifdef DEBUG_DECRYPT\\r\\n{\\r\\nFILE *op;\\r\\nchar fname[30];\\r\\nstatic int fnm = 1;\\r\\nsprintf(fname, \"DER%d\", fnm++);\\r\\nop = fopen(fname, \"wb\");\\r\\nfwrite (p, 1, outlen, op);\\r\\nfclose(op);\\r\\n}\\r\\n#endif\\r\\nret = ASN1_item_d2i(NULL, &p, outlen, it);\\r\\nif (zbuf) OPENSSL_cleanse(out, outlen);\\r\\nif(!ret) PKCS12err(PKCS12_F_PKCS12_ITEM_DECRYPT_D2I,PKCS12_R_DECODE_ERROR);\\r\\nOPENSSL_free(out);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_OCTET_STRING *PKCS12_item_i2d_encrypt(X509_ALGOR *algor, const ASN1_ITEM *it,\\r\\nconst char *pass, int passlen,\\r\\nvoid *obj, int zbuf)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nunsigned char *in = NULL;\\r\\nint inlen;\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\ninlen = ASN1_item_i2d(obj, &in, it);\\r\\nif (!in) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT,PKCS12_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!PKCS12_pbe_crypt(algor, pass, passlen, in, inlen, &oct->data,\\r\\n&oct->length, 1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT,PKCS12_R_ENCRYPT_ERROR);\\r\\nOPENSSL_free(in);\\r\\nreturn NULL;\\r\\n}\\r\\nif (zbuf) OPENSSL_cleanse(in, inlen);\\r\\nOPENSSL_free(in);\\r\\nreturn oct;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ofb_enc_c", "target": 0, "func": "void DES_ofb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG d0,d1,vv0,vv1,v0,v1,n=(numbits+7)/8;\\r\\nregister DES_LONG mask0,mask1;\\r\\nregister long l=length;\\r\\nregister int num=numbits;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nif (num > 64) return;\\r\\nif (num > 32)\\r\\n{\\r\\nmask0=0xffffffffL;\\r\\nif (num >= 64)\\r\\nmask1=mask0;\\r\\nelse\\r\\nmask1=(1L<<(num-32))-1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (num == 32)\\r\\nmask0=0xffffffffL;\\r\\nelse\\r\\nmask0=(1L<<num)-1;\\r\\nmask1=0x00000000L;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nwhile (l-- > 0)\\r\\n{\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt1((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nvv0=ti[0];\\r\\nvv1=ti[1];\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nd0=(d0^vv0)&mask0;\\r\\nd1=(d1^vv1)&mask1;\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=vv0; }\\r\\nelse if (num == 64)\\r\\n{ v0=vv0; v1=vv1; }\\r\\nelse if (num > 32)\\r\\n{\\r\\nv0=((v1>>(num-32))|(vv0<<(64-num)))&0xffffffffL;\\r\\nv1=((vv0>>(num-32))|(vv1<<(64-num)))&0xffffffffL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nv0=((v0>>num)|(v1<<(32-num)))&0xffffffffL;\\r\\nv1=((v1>>num)|(vv0<<(32-num)))&0xffffffffL;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nv0=v1=d0=d1=ti[0]=ti[1]=vv0=vv1=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_lib_c", "target": 0, "func": "int X509V3_EXT_add(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ext_cmp(const X509V3_EXT_METHOD * const *a,\\r\\nconst X509V3_EXT_METHOD * const *b)\\r\\n{\\r\\nreturn ((*a)->ext_nid - (*b)->ext_nid);\\r\\n}\\r\\nX509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)\\r\\n{\\r\\nX509V3_EXT_METHOD tmp, *t = &tmp, **ret;\\r\\nint idx;\\r\\nif(nid < 0) return NULL;\\r\\ntmp.ext_nid = nid;\\r\\nret = (X509V3_EXT_METHOD **) OBJ_bsearch((char *)&t,\\r\\n(char *)standard_exts, STANDARD_EXTENSION_COUNT,\\r\\nsizeof(X509V3_EXT_METHOD *), (int (*)(const void *, const void *))ext_cmp);\\r\\nif(ret) return *ret;\\r\\nif(!ext_list) return NULL;\\r\\nidx = sk_X509V3_EXT_METHOD_find(ext_list, &tmp);\\r\\nif(idx == -1) return NULL;\\r\\nreturn sk_X509V3_EXT_METHOD_value(ext_list, idx);\\r\\n}\\r\\nX509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)\\r\\n{\\r\\nint nid;\\r\\nif((nid = OBJ_obj2nid(ext->object)) == NID_undef) return NULL;\\r\\nreturn X509V3_EXT_get_nid(nid);\\r\\n}\\r\\nint X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)\\r\\n{\\r\\nfor(;extlist->ext_nid!=-1;extlist++)\\r\\nif(!X509V3_EXT_add(extlist)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509V3_EXT_add_alias(int nid_to, int nid_from)\\r\\n{\\r\\nX509V3_EXT_METHOD *ext, *tmpext;\\r\\nif(!(ext = X509V3_EXT_get_nid(nid_from))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,X509V3_R_EXTENSION_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(tmpext = (X509V3_EXT_METHOD *)OPENSSL_malloc(sizeof(X509V3_EXT_METHOD)))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n*tmpext = *ext;\\r\\ntmpext->ext_nid = nid_to;\\r\\ntmpext->ext_flags |= X509V3_EXT_DYNAMIC;\\r\\nreturn X509V3_EXT_add(tmpext);\\r\\n}\\r\\nvoid X509V3_EXT_cleanup(void)\\r\\n{\\r\\nsk_X509V3_EXT_METHOD_pop_free(ext_list, ext_list_free);\\r\\next_list = NULL;\\r\\n}\\r\\nstatic void ext_list_free(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif(ext->ext_flags & X509V3_EXT_DYNAMIC) OPENSSL_free(ext);\\r\\n}\\r\\nint X509V3_add_standard_extensions(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nvoid *X509V3_EXT_d2i(X509_EXTENSION *ext)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nconst unsigned char *p;\\r\\nif(!(method = X509V3_EXT_get(ext))) return NULL;\\r\\np = ext->value->data;\\r\\nif(method->it) return ASN1_item_d2i(NULL, &p, ext->value->length, ASN1_ITEM_ptr(method->it));\\r\\nreturn method->d2i(NULL, &p, ext->value->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_aep_c", "target": 0, "func": "static int bind_aep(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth2;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_aep_id) ||\\r\\n!ENGINE_set_name(e, engine_aep_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &aep_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &aep_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &aep_dh) ||\\r\\n#endif\\r\\n#ifdef AEPRAND\\r\\n!ENGINE_set_RAND(e, &aep_random) ||\\r\\n#endif\\r\\n!ENGINE_set_init_function(e, aep_init) ||\\r\\n!ENGINE_set_destroy_function(e, aep_destroy) ||\\r\\n!ENGINE_set_finish_function(e, aep_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, aep_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, aep_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\naep_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\naep_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\naep_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\naep_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth2 = DSA_OpenSSL();\\r\\naep_dsa.dsa_do_sign = meth2->dsa_do_sign;\\r\\naep_dsa.dsa_sign_setup = meth2->dsa_sign_setup;\\r\\naep_dsa.dsa_do_verify = meth2->dsa_do_verify;\\r\\naep_dsa = *DSA_get_default_method();\\r\\naep_dsa.dsa_mod_exp = aep_dsa_mod_exp;\\r\\naep_dsa.bn_mod_exp = aep_mod_exp_dsa;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth3 = DH_OpenSSL();\\r\\naep_dh.generate_key = meth3->generate_key;\\r\\naep_dh.compute_key = meth3->compute_key;\\r\\naep_dh.bn_mod_exp = meth3->bn_mod_exp;\\r\\n#endif\\r\\nERR_load_AEPHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_aep_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_aep(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_aep(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_aep(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_aep(void)\\r\\n{\\r\\nENGINE *toadd = engine_aep();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic const char *get_AEP_LIBNAME(void)\\r\\n{\\r\\nif(AEP_LIBNAME)\\r\\nreturn AEP_LIBNAME;\\r\\nreturn \"aep\";\\r\\n}\\r\\nstatic void free_AEP_LIBNAME(void)\\r\\n{\\r\\nif(AEP_LIBNAME)\\r\\nOPENSSL_free((void*)AEP_LIBNAME);\\r\\nAEP_LIBNAME = NULL;\\r\\n}\\r\\nstatic long set_AEP_LIBNAME(const char *name)\\r\\n{\\r\\nfree_AEP_LIBNAME();\\r\\nreturn ((AEP_LIBNAME = BUF_strdup(name)) != NULL ? 1 : 0);\\r\\n}\\r\\nstatic int aep_init(ENGINE *e)\\r\\n{\\r\\nt_AEP_ModExp *p1;\\r\\nt_AEP_ModExpCrt *p2;\\r\\n#ifdef AEPRAND\\r\\nt_AEP_GenRandom *p3;\\r\\n#endif\\r\\nt_AEP_Finalize *p4;\\r\\nt_AEP_Initialize *p5;\\r\\nt_AEP_OpenConnection *p6;\\r\\nt_AEP_SetBNCallBacks *p7;\\r\\nt_AEP_CloseConnection *p8;\\r\\nint to_return = 0;\\r\\nif(aep_dso != NULL)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_INIT,AEPHK_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\naep_dso = DSO_load(NULL, get_AEP_LIBNAME(), NULL, 0);\\r\\nif(aep_dso == NULL)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_INIT,AEPHK_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif( !(p1 = (t_AEP_ModExp *) DSO_bind_func( aep_dso,AEP_F1)) ||\\r\\n!(p2 = (t_AEP_ModExpCrt*) DSO_bind_func( aep_dso,AEP_F2)) ||\\r\\n#ifdef AEPRAND\\r\\n!(p3 = (t_AEP_GenRandom*) DSO_bind_func( aep_dso,AEP_F3)) ||\\r\\n#endif\\r\\n!(p4 = (t_AEP_Finalize*) DSO_bind_func( aep_dso,AEP_F4)) ||\\r\\n!(p5 = (t_AEP_Initialize*) DSO_bind_func( aep_dso,AEP_F5)) ||\\r\\n!(p6 = (t_AEP_OpenConnection*) DSO_bind_func( aep_dso,AEP_F6)) ||\\r\\n!(p7 = (t_AEP_SetBNCallBacks*) DSO_bind_func( aep_dso,AEP_F7)) ||\\r\\n!(p8 = (t_AEP_CloseConnection*) DSO_bind_func( aep_dso,AEP_F8)))\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_INIT,AEPHK_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\np_AEP_ModExp = p1;\\r\\np_AEP_ModExpCrt = p2;\\r\\n#ifdef AEPRAND\\r\\np_AEP_GenRandom = p3;\\r\\n#endif\\r\\np_AEP_Finalize = p4;\\r\\np_AEP_Initialize = p5;\\r\\np_AEP_OpenConnection = p6;\\r\\np_AEP_SetBNCallBacks = p7;\\r\\np_AEP_CloseConnection = p8;\\r\\nto_return = 1;\\r\\nreturn to_return;\\r\\nerr:\\r\\nif(aep_dso)\\r\\nDSO_free(aep_dso);\\r\\naep_dso = NULL;\\r\\np_AEP_OpenConnection = NULL;\\r\\np_AEP_ModExp = NULL;\\r\\np_AEP_ModExpCrt = NULL;\\r\\n#ifdef AEPRAND\\r\\np_AEP_GenRandom = NULL;\\r\\n#endif\\r\\np_AEP_Initialize = NULL;\\r\\np_AEP_Finalize = NULL;\\r\\np_AEP_SetBNCallBacks = NULL;\\r\\np_AEP_CloseConnection = NULL;\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int aep_destroy(ENGINE *e)\\r\\n{\\r\\nfree_AEP_LIBNAME();\\r\\nERR_unload_AEPHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aep_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 0, in_use;\\r\\nAEP_RV rv;\\r\\nif(aep_dso == NULL)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_FINISH,AEPHK_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nrv = aep_close_all_connections(0, &in_use);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_FINISH,AEPHK_R_CLOSE_HANDLES_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (in_use)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_FINISH,AEPHK_R_CONNECTIONS_IN_USE);\\r\\ngoto err;\\r\\n}\\r\\nrv = p_AEP_Finalize();\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_FINISH,AEPHK_R_FINALIZE_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif(!DSO_free(aep_dso))\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_FINISH,AEPHK_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\naep_dso = NULL;\\r\\np_AEP_CloseConnection = NULL;\\r\\np_AEP_OpenConnection = NULL;\\r\\np_AEP_ModExp = NULL;\\r\\np_AEP_ModExpCrt = NULL;\\r\\n#ifdef AEPRAND\\r\\np_AEP_GenRandom = NULL;\\r\\n#endif\\r\\np_AEP_Initialize = NULL;\\r\\np_AEP_Finalize = NULL;\\r\\np_AEP_SetBNCallBacks = NULL;\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int aep_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((aep_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase AEP_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_CTRL,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_CTRL,\\r\\nAEPHK_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_AEP_LIBNAME((const char*)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nAEPHKerr(AEPHK_F_AEP_CTRL,AEPHK_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int aep_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint to_return = 0;\\r\\nint r_len = 0;\\r\\nAEP_CONNECTION_HNDL hConnection;\\r\\nAEP_RV rv;\\r\\nr_len = BN_num_bits(m);\\r\\nif (r_len > max_key_len){\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP, AEPHK_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nrv = aep_get_connection(&hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP,AEPHK_R_GET_HANDLE_FAILED);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nrv = p_AEP_ModExp(hConnection,(void*)a, (void*)p,(void*)m, (void*)r,NULL);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP,AEPHK_R_MOD_EXP_FAILED);\\r\\nrv = aep_close_connection(hConnection);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nrv = aep_return_connection(hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP,AEPHK_R_RETURN_CONNECTION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic AEP_RV aep_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *q, const BIGNUM *dmp1,\\r\\nconst BIGNUM *dmq1,const BIGNUM *iqmp, BN_CTX *ctx)\\r\\n{\\r\\nAEP_RV rv = AEP_R_OK;\\r\\nAEP_CONNECTION_HNDL hConnection;\\r\\nrv = aep_get_connection(&hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP_CRT,AEPHK_R_GET_HANDLE_FAILED);\\r\\nreturn FAIL_TO_SW;\\r\\n}\\r\\nrv = p_AEP_ModExpCrt(hConnection,(void*)a, (void*)p, (void*)q, (void*)dmp1,(void*)dmq1,\\r\\n(void*)iqmp,(void*)r,NULL);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP_CRT,AEPHK_R_MOD_EXP_CRT_FAILED);\\r\\nrv = aep_close_connection(hConnection);\\r\\nreturn FAIL_TO_SW;\\r\\n}\\r\\nrv = aep_return_connection(hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_MOD_EXP_CRT,AEPHK_R_RETURN_CONNECTION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nreturn rv;\\r\\n}\\r\\nstatic int aep_rand(unsigned char *buf,int len )\\r\\n{\\r\\nAEP_RV rv = AEP_R_OK;\\r\\nAEP_CONNECTION_HNDL hConnection;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nif (len <= rand_block_bytes)\\r\\n{\\r\\nmemcpy(buf, &rand_block[RAND_BLK_SIZE - rand_block_bytes], len);\\r\\nrand_block_bytes -= len;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n}\\r\\nelse\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nrv = aep_get_connection(&hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RAND,AEPHK_R_GET_HANDLE_FAILED);\\r\\ngoto err_nounlock;\\r\\n}\\r\\nif (len > RAND_BLK_SIZE)\\r\\n{\\r\\nrv = p_AEP_GenRandom(hConnection, len, 2, buf, NULL);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RAND,AEPHK_R_GET_RANDOM_FAILED);\\r\\ngoto err_nounlock;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nrv = p_AEP_GenRandom(hConnection, RAND_BLK_SIZE, 2, &rand_block[0], NULL);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RAND,AEPHK_R_GET_RANDOM_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nrand_block_bytes = RAND_BLK_SIZE;\\r\\nmemcpy(buf, &rand_block[RAND_BLK_SIZE - rand_block_bytes], len);\\r\\nrand_block_bytes -= len;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n}\\r\\nrv = aep_return_connection(hConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RAND,AEPHK_R_RETURN_CONNECTION_FAILED);\\r\\ngoto err_nounlock;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nerr_nounlock:\\r\\nreturn 0;\\r\\n}\\r\\nstatic int aep_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aep_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint to_return = 0;\\r\\nAEP_RV rv = AEP_R_OK;\\r\\nif (!aep_dso)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RSA_MOD_EXP,AEPHK_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif (rsa->q && rsa->dmp1 && rsa->dmq1 && rsa->iqmp)\\r\\n{\\r\\nrv = aep_mod_exp_crt(r0,I,rsa->p,rsa->q, rsa->dmp1,rsa->dmq1,rsa->iqmp,ctx);\\r\\nif (rv == FAIL_TO_SW){\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nto_return = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rv != AEP_R_OK)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!rsa->d || !rsa->n)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_RSA_MOD_EXP,AEPHK_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nrv = aep_mod_exp(r0,I,rsa->d,rsa->n,ctx);\\r\\nif (rv != AEP_R_OK)\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int aep_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!aep_mod_exp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!aep_mod_exp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int aep_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn aep_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int aep_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn aep_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int aep_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn aep_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic AEP_RV aep_get_connection(AEP_CONNECTION_HNDL_PTR phConnection)\\r\\n{\\r\\nint count;\\r\\nAEP_RV rv = AEP_R_OK;\\r\\npid_t curr_pid;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\n#ifndef NETWARE_CLIB\\r\\ncurr_pid = getpid();\\r\\n#else\\r\\ncurr_pid = GetThreadID();\\r\\n#endif\\r\\nif (recorded_pid != curr_pid)\\r\\n{\\r\\nrecorded_pid = curr_pid;\\r\\np_AEP_Finalize();\\r\\nrv = p_AEP_Initialize(NULL);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_GET_CONNECTION,AEPHK_R_INIT_FAILURE);\\r\\nrecorded_pid = 0;\\r\\ngoto end;\\r\\n}\\r\\nrv = p_AEP_SetBNCallBacks(&GetBigNumSize, &MakeAEPBigNum,\\r\\n&ConvertAEPBigNum);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_GET_CONNECTION,AEPHK_R_SETBNCALLBACK_FAILURE);\\r\\nrecorded_pid = 0;\\r\\ngoto end;\\r\\n}\\r\\n#ifdef AEPRAND\\r\\nrand_block_bytes = 0;\\r\\n#endif\\r\\nfor (count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\naep_app_conn_table[count].conn_state = NotConnected;\\r\\naep_app_conn_table[count].conn_hndl = 0;\\r\\n}\\r\\nrv = p_AEP_OpenConnection(phConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_GET_CONNECTION,AEPHK_R_UNIT_FAILURE);\\r\\nrecorded_pid = 0;\\r\\ngoto end;\\r\\n}\\r\\naep_app_conn_table[0].conn_state = InUse;\\r\\naep_app_conn_table[0].conn_hndl = *phConnection;\\r\\ngoto end;\\r\\n}\\r\\nfor (count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\nif (aep_app_conn_table[count].conn_state == Connected)\\r\\n{\\r\\naep_app_conn_table[count].conn_state = InUse;\\r\\n*phConnection = aep_app_conn_table[count].conn_hndl;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nfor (count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\nif (aep_app_conn_table[count].conn_state == NotConnected)\\r\\n{\\r\\nrv = p_AEP_OpenConnection(phConnection);\\r\\nif (rv != AEP_R_OK)\\r\\n{\\r\\nAEPHKerr(AEPHK_F_AEP_GET_CONNECTION,AEPHK_R_UNIT_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\naep_app_conn_table[count].conn_state = InUse;\\r\\naep_app_conn_table[count].conn_hndl = *phConnection;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrv = AEP_R_GENERAL_ERROR;\\r\\nend:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn rv;\\r\\n}\\r\\nstatic AEP_RV aep_return_connection(AEP_CONNECTION_HNDL hConnection)\\r\\n{\\r\\nint count;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nfor(count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\nif (aep_app_conn_table[count].conn_hndl == hConnection)\\r\\n{\\r\\naep_app_conn_table[count].conn_state = Connected;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn AEP_R_OK;\\r\\n}\\r\\nstatic AEP_RV aep_close_connection(AEP_CONNECTION_HNDL hConnection)\\r\\n{\\r\\nint count;\\r\\nAEP_RV rv = AEP_R_OK;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nfor(count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\nif (aep_app_conn_table[count].conn_hndl == hConnection)\\r\\n{\\r\\nrv = p_AEP_CloseConnection(aep_app_conn_table[count].conn_hndl);\\r\\nif (rv != AEP_R_OK)\\r\\ngoto end;\\r\\naep_app_conn_table[count].conn_state = NotConnected;\\r\\naep_app_conn_table[count].conn_hndl = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nend:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn rv;\\r\\n}\\r\\nstatic AEP_RV aep_close_all_connections(int use_engine_lock, int *in_use)\\r\\n{\\r\\nint count;\\r\\nAEP_RV rv = AEP_R_OK;\\r\\n*in_use = 0;\\r\\nif (use_engine_lock) CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nfor (count = 0;count < MAX_PROCESS_CONNECTIONS;count ++)\\r\\n{\\r\\nswitch (aep_app_conn_table[count].conn_state)\\r\\n{\\r\\ncase Connected:\\r\\nrv = p_AEP_CloseConnection(aep_app_conn_table[count].conn_hndl);\\r\\nif (rv != AEP_R_OK)\\r\\ngoto end;\\r\\naep_app_conn_table[count].conn_state = NotConnected;\\r\\naep_app_conn_table[count].conn_hndl = 0;\\r\\nbreak;\\r\\ncase InUse:\\r\\n(*in_use)++;\\r\\nbreak;\\r\\ncase NotConnected:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (use_engine_lock) CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn rv;\\r\\n}\\r\\nstatic AEP_RV GetBigNumSize(AEP_VOID_PTR ArbBigNum, AEP_U32* BigNumSize)\\r\\n{\\r\\nBIGNUM* bn;\\r\\nbn = (BIGNUM*) ArbBigNum;\\r\\n#ifdef SIXTY_FOUR_BIT_LONG\\r\\n*BigNumSize = bn->top << 3;\\r\\n#else\\r\\n*BigNumSize = bn->top << 2;\\r\\n#endif\\r\\nreturn AEP_R_OK;\\r\\n}\\r\\nstatic AEP_RV MakeAEPBigNum(AEP_VOID_PTR ArbBigNum, AEP_U32 BigNumSize,\\r\\nunsigned char* AEP_BigNum)\\r\\n{\\r\\nBIGNUM* bn;\\r\\n#ifndef SIXTY_FOUR_BIT_LONG\\r\\nunsigned char* buf;\\r\\nint i;\\r\\n#endif\\r\\nbn = (BIGNUM*) ArbBigNum;\\r\\n#ifdef SIXTY_FOUR_BIT_LONG\\r\\nmemcpy(AEP_BigNum, bn->d, BigNumSize);\\r\\n#else\\r\\nfor(i=0;i<bn->top;i++)\\r\\n{\\r\\nbuf = (unsigned char*)&bn->d[i];\\r\\n*((AEP_U32*)AEP_BigNum) = (AEP_U32)\\r\\n((unsigned) buf[1] << 8 | buf[0]) |\\r\\n((unsigned) buf[3] << 8 | buf[2]) << 16;\\r\\nAEP_BigNum += 4;\\r\\n}\\r\\n#endif\\r\\nreturn AEP_R_OK;\\r\\n}\\r\\nstatic AEP_RV ConvertAEPBigNum(void* ArbBigNum, AEP_U32 BigNumSize,\\r\\nunsigned char* AEP_BigNum)\\r\\n{\\r\\nBIGNUM* bn;\\r\\n#ifndef SIXTY_FOUR_BIT_LONG\\r\\nint i;\\r\\n#endif\\r\\nbn = (BIGNUM*)ArbBigNum;\\r\\nbn_expand(bn, (int)(BigNumSize << 3));\\r\\n#ifdef SIXTY_FOUR_BIT_LONG\\r\\nbn->top = BigNumSize >> 3;\\r\\nif((BigNumSize & 7) != 0)\\r\\nbn->top++;\\r\\nmemset(bn->d, 0, bn->top << 3);\\r\\nmemcpy(bn->d, AEP_BigNum, BigNumSize);\\r\\n#else\\r\\nbn->top = BigNumSize >> 2;\\r\\nfor(i=0;i<bn->top;i++)\\r\\n{\\r\\nbn->d[i] = (AEP_U32)\\r\\n((unsigned) AEP_BigNum[3] << 8 | AEP_BigNum[2]) << 16 |\\r\\n((unsigned) AEP_BigNum[1] << 8 | AEP_BigNum[0]);\\r\\nAEP_BigNum += 4;\\r\\n}\\r\\n#endif\\r\\nreturn AEP_R_OK;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_uplink_c", "target": 0, "func": "static void unimplemented (void)\\r\\n{ OPENSSL_showfatal (sizeof(TCHAR)==sizeof(char)?\"%s\\n\":\"%S\\n\",msg);\\r\\nExitProcess (1);\\r\\n}\\r\\nvoid OPENSSL_Uplink (volatile void **table, int index)\\r\\n{ static HMODULE volatile apphandle=NULL;\\r\\nstatic void ** volatile applinktable=NULL;\\r\\nint len;\\r\\nvoid (*func)(void)=unimplemented;\\r\\nHANDLE h;\\r\\nvoid **p;\\r\\ndo {\\r\\nlen = _stprintf (msg,_T(\"OPENSSL_Uplink(%p,%02X): \"),table,index);\\r\\n_tcscpy (msg+len,_T(\"unimplemented function\"));\\r\\nif ((h=apphandle)==NULL)\\r\\n{ if ((h=GetModuleHandle(NULL))==NULL)\\r\\n{ apphandle=(HMODULE)-1;\\r\\n_tcscpy (msg+len,_T(\"no host application\"));\\r\\nbreak;\\r\\n}\\r\\napphandle = h;\\r\\n}\\r\\nif ((h=apphandle)==(HMODULE)-1)\\r\\nbreak;\\r\\nif (applinktable==NULL)\\r\\n{ void**(*applink)();\\r\\napplink=(void**(*)())GetProcAddress(h,\"OPENSSL_Applink\");\\r\\nif (applink==NULL)\\r\\n{ apphandle=(HMODULE)-1;\\r\\n_tcscpy (msg+len,_T(\"no OPENSSL_Applink\"));\\r\\nbreak;\\r\\n}\\r\\np = (*applink)();\\r\\nif (p==NULL)\\r\\n{ apphandle=(HMODULE)-1;\\r\\n_tcscpy (msg+len,_T(\"no ApplinkTable\"));\\r\\nbreak;\\r\\n}\\r\\napplinktable = p;\\r\\n}\\r\\nif (index > (int)p[0])\\r\\nbreak;\\r\\nif (p[index]) func = p[index];\\r\\n} while (0);\\r\\ntable[index] = func;\\r\\n}\\r\\nmain() { UP_fprintf(UP_stdout,\"hello, world!\\n\"); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_def_c", "target": 0, "func": "const char *X509_get_default_private_dir(void)\\r\\n{ return(X509_PRIVATE_DIR); }\\r\\nconst char *X509_get_default_cert_area(void)\\r\\n{ return(X509_CERT_AREA); }\\r\\nconst char *X509_get_default_cert_dir(void)\\r\\n{ return(X509_CERT_DIR); }\\r\\nconst char *X509_get_default_cert_file(void)\\r\\n{ return(X509_CERT_FILE); }\\r\\nconst char *X509_get_default_cert_dir_env(void)\\r\\n{ return(X509_CERT_DIR_EVP); }\\r\\nconst char *X509_get_default_cert_file_env(void)\\r\\n{ return(X509_CERT_FILE_EVP); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsaparam_c", "target": 0, "func": "static void timebomb_sigalarm(int foo)\\r\\n{\\r\\nstop_keygen_flag = 1;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nDSA *dsa=NULL;\\r\\nint i,badops=0,text=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,noout=0,C=0,ret=1;\\r\\nchar *infile,*outfile,*prog,*inrand=NULL;\\r\\nint numbits= -1,num,genkey=0;\\r\\nint need_rand=0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\n#ifdef GENCB_TEST\\r\\nint timebomb=0;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if(strcmp(*argv, \"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\n#ifdef GENCB_TEST\\r\\nelse if(strcmp(*argv, \"-timebomb\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ntimebomb = atoi(*(++argv));\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC=1;\\r\\nelse if (strcmp(*argv,\"-genkey\") == 0)\\r\\n{\\r\\ngenkey=1;\\r\\nneed_rand=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\nneed_rand=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (sscanf(*argv,\"%d\",&num) == 1)\\r\\n{\\r\\nnumbits=num;\\r\\nneed_rand=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] [bits] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -text print as text\\n\");\\r\\nBIO_printf(bio_err,\" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\" -noout no output\\n\");\\r\\nBIO_printf(bio_err,\" -genkey generate a DSA key\\n\");\\r\\nBIO_printf(bio_err,\" -rand files to use for random number input\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\n#ifdef GENCB_TEST\\r\\nBIO_printf(bio_err,\" -timebomb n interrupt keygen after <n> seconds\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" number number of bits to use for generating private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (need_rand)\\r\\n{\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nif (numbits > 0)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set(&cb, dsa_cb, bio_err);\\r\\nassert(need_rand);\\r\\ndsa = DSA_new();\\r\\nif(!dsa)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error allocating DSA object\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating DSA parameters, %d bit long prime\\n\",num);\\r\\nBIO_printf(bio_err,\"This could take some time\\n\");\\r\\n#ifdef GENCB_TEST\\r\\nif(timebomb > 0)\\r\\n{\\r\\nstruct sigaction act;\\r\\nact.sa_handler = timebomb_sigalarm;\\r\\nact.sa_flags = 0;\\r\\nBIO_printf(bio_err,\"(though I'll stop it if not done within %d secs)\\n\",\\r\\ntimebomb);\\r\\nif(sigaction(SIGALRM, &act, NULL) != 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error, couldn't set SIGALRM handler\\n\");\\r\\ngoto end;\\r\\n}\\r\\nalarm(timebomb);\\r\\n}\\r\\n#endif\\r\\nif(!DSA_generate_parameters_ex(dsa,num,NULL,0,NULL,NULL, &cb))\\r\\n{\\r\\n#ifdef GENCB_TEST\\r\\nif(stop_keygen_flag)\\r\\n{\\r\\nBIO_printf(bio_err,\"DSA key generation time-stopped\\n\");\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nBIO_printf(bio_err,\"Error, DSA key generation failed\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (informat == FORMAT_ASN1)\\r\\ndsa=d2i_DSAparams_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndsa=PEM_read_bio_DSAparams(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nDSAparams_print(out,dsa);\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nunsigned char *data;\\r\\nint l,len,bits_p,bits_q,bits_g;\\r\\nlen=BN_num_bytes(dsa->p);\\r\\nbits_p=BN_num_bits(dsa->p);\\r\\nbits_q=BN_num_bits(dsa->q);\\r\\nbits_g=BN_num_bits(dsa->g);\\r\\ndata=(unsigned char *)OPENSSL_malloc(len+20);\\r\\nif (data == NULL)\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nl=BN_bn2bin(dsa->p,data);\\r\\nprintf(\"static unsigned char dsa%d_p[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dsa->q,data);\\r\\nprintf(\"static unsigned char dsa%d_q[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dsa->g,data);\\r\\nprintf(\"static unsigned char dsa%d_g[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\\n\");\\r\\nprintf(\"DSA *get_dsa%d()\\n\\t{\\n\",bits_p);\\r\\nprintf(\"\\tDSA *dsa;\\n\\n\");\\r\\nprintf(\"\\tif ((dsa=DSA_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdsa->p=BN_bin2bn(dsa%d_p,sizeof(dsa%d_p),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tdsa->q=BN_bin2bn(dsa%d_q,sizeof(dsa%d_q),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tdsa->g=BN_bin2bn(dsa%d_g,sizeof(dsa%d_g),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\n\");\\r\\nprintf(\"\\t\\t{ DSA_free(dsa); return(NULL); }\\n\");\\r\\nprintf(\"\\treturn(dsa);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DSAparams_bio(out,dsa);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DSAparams(out,dsa);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (genkey)\\r\\n{\\r\\nDSA *dsakey;\\r\\nassert(need_rand);\\r\\nif ((dsakey=DSAparams_dup(dsa)) == NULL) goto end;\\r\\nif (!DSA_generate_key(dsakey)) goto end;\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DSAPrivateKey_bio(out,dsakey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DSAPrivateKey(out,dsakey,NULL,NULL,0,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nDSA_free(dsakey);\\r\\n}\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (dsa != NULL) DSA_free(dsa);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK dsa_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write(cb->arg,&c,1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\n#ifdef GENCB_TEST\\r\\nif(stop_keygen_flag)\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"SHA(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nSHA_CTX c;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nunsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nSHA_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nSHA_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nSHA_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_ncons_c", "target": 0, "func": "int i2r_NAME_CONSTRAINTS(X509V3_EXT_METHOD *method,\\r\\nvoid *a, BIO *bp, int ind)\\r\\n{\\r\\nNAME_CONSTRAINTS *ncons = a;\\r\\ndo_i2r_name_constraints(method, ncons->permittedSubtrees,\\r\\nbp, ind, \"Permitted\");\\r\\ndo_i2r_name_constraints(method, ncons->excludedSubtrees,\\r\\nbp, ind, \"Excluded\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int print_nc_ipadd(BIO *bp, ASN1_OCTET_STRING *ip)\\r\\n{\\r\\nint i, len;\\r\\nunsigned char *p;\\r\\np = ip->data;\\r\\nlen = ip->length;\\r\\nBIO_puts(bp, \"IP:\");\\r\\nif(len == 8)\\r\\n{\\r\\nBIO_printf(bp, \"%d.%d.%d.%d/%d.%d.%d.%d\",\\r\\np[0], p[1], p[2], p[3],\\r\\np[4], p[5], p[6], p[7]);\\r\\n}\\r\\nelse if(len == 32)\\r\\n{\\r\\nfor (i = 0; i < 16; i++)\\r\\n{\\r\\nBIO_printf(bp, \"%X\", p[0] << 8 | p[1]);\\r\\np += 2;\\r\\nif (i == 7)\\r\\nBIO_puts(bp, \"/\");\\r\\nelse if (i != 15)\\r\\nBIO_puts(bp, \":\");\\r\\n}\\r\\n}\\r\\nelse\\r\\nBIO_printf(bp, \"IP Address:<invalid>\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_pkey_c", "target": 0, "func": "EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nEVP_PKEY *pkey = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rsa = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nDSA *dsa = NULL;\\r\\nASN1_TYPE *t1, *t2;\\r\\nASN1_INTEGER *privkey;\\r\\nSTACK_OF(ASN1_TYPE) *ndsa = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nEC_KEY *eckey = NULL;\\r\\nconst unsigned char *p_tmp;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_EC)\\r\\nASN1_TYPE *param = NULL;\\r\\nBN_CTX *ctx = NULL;\\r\\nint plen;\\r\\n#endif\\r\\nX509_ALGOR *a;\\r\\nconst unsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nint pkeylen;\\r\\nint nid;\\r\\nchar obj_tmp[80];\\r\\nif(p8->pkey->type == V_ASN1_OCTET_STRING) {\\r\\np8->broken = PKCS8_OK;\\r\\np = p8->pkey->value.octet_string->data;\\r\\npkeylen = p8->pkey->value.octet_string->length;\\r\\n} else {\\r\\np8->broken = PKCS8_NO_OCTET;\\r\\np = p8->pkey->value.sequence->data;\\r\\npkeylen = p8->pkey->value.sequence->length;\\r\\n}\\r\\nif (!(pkey = EVP_PKEY_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\na = p8->pkeyalg;\\r\\nnid = OBJ_obj2nid(a->algorithm);\\r\\nswitch(nid)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase NID_rsaEncryption:\\r\\ncp = p;\\r\\nif (!(rsa = d2i_RSAPrivateKey (NULL,&cp, pkeylen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY_assign_RSA (pkey, rsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase NID_dsa:\\r\\nif(*p == (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED)) {\\r\\nif(!(ndsa = ASN1_seq_unpack_ASN1_TYPE(p, pkeylen,\\r\\nd2i_ASN1_TYPE,\\r\\nASN1_TYPE_free))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif(sk_ASN1_TYPE_num(ndsa) != 2 ) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nt1 = sk_ASN1_TYPE_value(ndsa, 0);\\r\\nt2 = sk_ASN1_TYPE_value(ndsa, 1);\\r\\nif(t1->type == V_ASN1_SEQUENCE) {\\r\\np8->broken = PKCS8_EMBEDDED_PARAM;\\r\\nparam = t1;\\r\\n} else if(a->parameter->type == V_ASN1_SEQUENCE) {\\r\\np8->broken = PKCS8_NS_DB;\\r\\nparam = a->parameter;\\r\\n} else {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif(t2->type != V_ASN1_INTEGER) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nprivkey = t2->value.integer;\\r\\n} else {\\r\\nif (!(privkey=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nparam = p8->pkeyalg->parameter;\\r\\n}\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE)) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\ncp = p = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif (!(dsa = d2i_DSAparams (NULL, &cp, plen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_DECODE_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!(dsa->pub_key = BN_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!(ctx = BN_CTX_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!BN_mod_exp(dsa->pub_key, dsa->g,\\r\\ndsa->priv_key, dsa->p, ctx)) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_PUBKEY_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nBN_CTX_free (ctx);\\r\\nif(ndsa) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nelse ASN1_INTEGER_free(privkey);\\r\\nbreak;\\r\\ndsaerr:\\r\\nBN_CTX_free (ctx);\\r\\nsk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nDSA_free(dsa);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn NULL;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase NID_X9_62_id_ecPublicKey:\\r\\np_tmp = p;\\r\\nparam = p8->pkeyalg->parameter;\\r\\nif (!param || ((param->type != V_ASN1_SEQUENCE) &&\\r\\n(param->type != V_ASN1_OBJECT)))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\nif (param->type == V_ASN1_SEQUENCE)\\r\\n{\\r\\ncp = p = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif (!(eckey = d2i_ECParameters(NULL, &cp, plen)))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,\\r\\nEVP_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nEC_GROUP *group;\\r\\ncp = p = param->value.object->data;\\r\\nplen = param->value.object->length;\\r\\nif ((eckey = EC_KEY_new()) == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto ecerr;\\r\\n}\\r\\ngroup = EC_GROUP_new_by_curve_name(OBJ_obj2nid(a->parameter->value.object));\\r\\nif (group == NULL)\\r\\ngoto ecerr;\\r\\nEC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);\\r\\nif (EC_KEY_set_group(eckey, group) == 0)\\r\\ngoto ecerr;\\r\\nEC_GROUP_free(group);\\r\\n}\\r\\nif (!d2i_ECPrivateKey(&eckey, &p_tmp, pkeylen))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\nif (EC_KEY_get0_public_key(eckey) == NULL)\\r\\n{\\r\\nconst BIGNUM *priv_key;\\r\\nconst EC_GROUP *group;\\r\\nEC_POINT *pub_key;\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\npub_key = EC_POINT_new(group);\\r\\nif (pub_key == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);\\r\\ngoto ecerr;\\r\\n}\\r\\nif (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group)))\\r\\n{\\r\\nEC_POINT_free(pub_key);\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);\\r\\ngoto ecerr;\\r\\n}\\r\\npriv_key = EC_KEY_get0_private_key(eckey);\\r\\nif (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\\r\\n{\\r\\nEC_POINT_free(pub_key);\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);\\r\\ngoto ecerr;\\r\\n}\\r\\nif (EC_KEY_set_public_key(eckey, pub_key) == 0)\\r\\n{\\r\\nEC_POINT_free(pub_key);\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_EC_LIB);\\r\\ngoto ecerr;\\r\\n}\\r\\nEC_POINT_free(pub_key);\\r\\n}\\r\\nEVP_PKEY_assign_EC_KEY(pkey, eckey);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nbreak;\\r\\necerr:\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nif (pkey)\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn NULL;\\r\\n#endif\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\nif (!a->algorithm) BUF_strlcpy (obj_tmp, \"NULL\", sizeof obj_tmp);\\r\\nelse i2t_ASN1_OBJECT(obj_tmp, 80, a->algorithm);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\nEVP_PKEY_free (pkey);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn pkey;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)\\r\\n{\\r\\nreturn EVP_PKEY2PKCS8_broken(pkey, PKCS8_OK);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nif (!(p8 = PKCS8_PRIV_KEY_INFO_new())) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np8->broken = broken;\\r\\nif (!ASN1_INTEGER_set(p8->version, 0)) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(p8->pkeyalg->parameter = ASN1_TYPE_new ())) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\np8->pkey->type = V_ASN1_OCTET_STRING;\\r\\nswitch (EVP_PKEY_type(pkey->type)) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif(p8->broken == PKCS8_NO_OCTET) p8->pkey->type = V_ASN1_SEQUENCE;\\r\\np8->pkeyalg->algorithm = OBJ_nid2obj(NID_rsaEncryption);\\r\\np8->pkeyalg->parameter->type = V_ASN1_NULL;\\r\\nif (!ASN1_pack_string_of (EVP_PKEY,pkey, i2d_PrivateKey,\\r\\n&p8->pkey->value.octet_string)) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif(!dsa_pkey2pkcs8(p8, pkey)) {\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nif (!eckey_pkey2pkcs8(p8, pkey))\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nreturn(NULL);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nRAND_add(p8->pkey->value.octet_string->data,\\r\\np8->pkey->value.octet_string->length, 0.0);\\r\\nreturn p8;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken)\\r\\n{\\r\\nswitch (broken) {\\r\\ncase PKCS8_OK:\\r\\np8->broken = PKCS8_OK;\\r\\nreturn p8;\\r\\nbreak;\\r\\ncase PKCS8_NO_OCTET:\\r\\np8->broken = PKCS8_NO_OCTET;\\r\\np8->pkey->type = V_ASN1_SEQUENCE;\\r\\nreturn p8;\\r\\nbreak;\\r\\ndefault:\\r\\nEVPerr(EVP_F_PKCS8_SET_BROKEN,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nstatic int dsa_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)\\r\\n{\\r\\nASN1_STRING *params = NULL;\\r\\nASN1_INTEGER *prkey = NULL;\\r\\nASN1_TYPE *ttmp = NULL;\\r\\nSTACK_OF(ASN1_TYPE) *ndsa = NULL;\\r\\nunsigned char *p = NULL, *q;\\r\\nint len;\\r\\np8->pkeyalg->algorithm = OBJ_nid2obj(NID_dsa);\\r\\nlen = i2d_DSAparams (pkey->pkey.dsa, NULL);\\r\\nif (!(p = OPENSSL_malloc(len))) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nq = p;\\r\\ni2d_DSAparams (pkey->pkey.dsa, &q);\\r\\nif (!(params = ASN1_STRING_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_STRING_set(params, p, len)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_free(p);\\r\\np = NULL;\\r\\nif (!(prkey = BN_to_ASN1_INTEGER (pkey->pkey.dsa->priv_key, NULL))) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nswitch(p8->broken) {\\r\\ncase PKCS8_OK:\\r\\ncase PKCS8_NO_OCTET:\\r\\nif (!ASN1_pack_string_of(ASN1_INTEGER,prkey, i2d_ASN1_INTEGER,\\r\\n&p8->pkey->value.octet_string)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nM_ASN1_INTEGER_free (prkey);\\r\\nprkey = NULL;\\r\\np8->pkeyalg->parameter->value.sequence = params;\\r\\nparams = NULL;\\r\\np8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;\\r\\nbreak;\\r\\ncase PKCS8_NS_DB:\\r\\np8->pkeyalg->parameter->value.sequence = params;\\r\\nparams = NULL;\\r\\np8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;\\r\\nif (!(ndsa = sk_ASN1_TYPE_new_null())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ttmp = ASN1_TYPE_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ttmp->value.integer =\\r\\nBN_to_ASN1_INTEGER(pkey->pkey.dsa->pub_key, NULL))) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,EVP_R_ENCODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nttmp->type = V_ASN1_INTEGER;\\r\\nif (!sk_ASN1_TYPE_push(ndsa, ttmp)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ttmp = ASN1_TYPE_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nttmp->value.integer = prkey;\\r\\nprkey = NULL;\\r\\nttmp->type = V_ASN1_INTEGER;\\r\\nif (!sk_ASN1_TYPE_push(ndsa, ttmp)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nttmp = NULL;\\r\\nif (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,\\r\\n&p8->pkey->value.octet_string->data,\\r\\n&p8->pkey->value.octet_string->length)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nsk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nbreak;\\r\\ncase PKCS8_EMBEDDED_PARAM:\\r\\np8->pkeyalg->parameter->type = V_ASN1_NULL;\\r\\nif (!(ndsa = sk_ASN1_TYPE_new_null())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ttmp = ASN1_TYPE_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nttmp->value.sequence = params;\\r\\nparams = NULL;\\r\\nttmp->type = V_ASN1_SEQUENCE;\\r\\nif (!sk_ASN1_TYPE_push(ndsa, ttmp)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ttmp = ASN1_TYPE_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nttmp->value.integer = prkey;\\r\\nprkey = NULL;\\r\\nttmp->type = V_ASN1_INTEGER;\\r\\nif (!sk_ASN1_TYPE_push(ndsa, ttmp)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nttmp = NULL;\\r\\nif (!(p8->pkey->value.octet_string = ASN1_OCTET_STRING_new())) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_seq_pack_ASN1_TYPE(ndsa, i2d_ASN1_TYPE,\\r\\n&p8->pkey->value.octet_string->data,\\r\\n&p8->pkey->value.octet_string->length)) {\\r\\nEVPerr(EVP_F_DSA_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nsk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (p != NULL) OPENSSL_free(p);\\r\\nif (params != NULL) ASN1_STRING_free(params);\\r\\nif (prkey != NULL) M_ASN1_INTEGER_free(prkey);\\r\\nif (ttmp != NULL) ASN1_TYPE_free(ttmp);\\r\\nif (ndsa != NULL) sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int eckey_pkey2pkcs8(PKCS8_PRIV_KEY_INFO *p8, EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY *ec_key;\\r\\nconst EC_GROUP *group;\\r\\nunsigned char *p, *pp;\\r\\nint nid, i, ret = 0;\\r\\nunsigned int tmp_flags, old_flags;\\r\\nec_key = pkey->pkey.ec;\\r\\nif (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, EVP_R_MISSING_PARAMETERS);\\r\\nreturn 0;\\r\\n}\\r\\nif (p8->pkeyalg->algorithm)\\r\\nASN1_OBJECT_free(p8->pkeyalg->algorithm);\\r\\np8->pkeyalg->algorithm = OBJ_nid2obj(NID_X9_62_id_ecPublicKey);\\r\\nif (p8->pkeyalg->parameter)\\r\\n{\\r\\nASN1_TYPE_free(p8->pkeyalg->parameter);\\r\\np8->pkeyalg->parameter = NULL;\\r\\n}\\r\\nif ((p8->pkeyalg->parameter = ASN1_TYPE_new()) == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(group)\\r\\n&& (nid = EC_GROUP_get_curve_name(group)))\\r\\n{\\r\\np8->pkeyalg->parameter->type = V_ASN1_OBJECT;\\r\\np8->pkeyalg->parameter->value.object = OBJ_nid2obj(nid);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((i = i2d_ECParameters(ec_key, NULL)) == 0)\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif ((p = (unsigned char *) OPENSSL_malloc(i)) == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npp = p;\\r\\nif (!i2d_ECParameters(ec_key, &pp))\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);\\r\\nOPENSSL_free(p);\\r\\nreturn 0;\\r\\n}\\r\\np8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;\\r\\nif ((p8->pkeyalg->parameter->value.sequence\\r\\n= ASN1_STRING_new()) == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_ASN1_LIB);\\r\\nOPENSSL_free(p);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_STRING_set(p8->pkeyalg->parameter->value.sequence, p, i);\\r\\nOPENSSL_free(p);\\r\\n}\\r\\nold_flags = EC_KEY_get_enc_flags(pkey->pkey.ec);\\r\\ntmp_flags = old_flags | EC_PKEY_NO_PARAMETERS;\\r\\nEC_KEY_set_enc_flags(pkey->pkey.ec, tmp_flags);\\r\\ni = i2d_ECPrivateKey(pkey->pkey.ec, NULL);\\r\\nif (!i)\\r\\n{\\r\\nEC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\np = (unsigned char *) OPENSSL_malloc(i);\\r\\nif (!p)\\r\\n{\\r\\nEC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npp = p;\\r\\nif (!i2d_ECPrivateKey(pkey->pkey.ec, &pp))\\r\\n{\\r\\nEC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_EC_LIB);\\r\\nOPENSSL_free(p);\\r\\nreturn 0;\\r\\n}\\r\\nEC_KEY_set_enc_flags(pkey->pkey.ec, old_flags);\\r\\nswitch(p8->broken) {\\r\\ncase PKCS8_OK:\\r\\np8->pkey->value.octet_string = ASN1_OCTET_STRING_new();\\r\\nif (!p8->pkey->value.octet_string ||\\r\\n!M_ASN1_OCTET_STRING_set(p8->pkey->value.octet_string,\\r\\n(const void *)p, i))\\r\\n{\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\ncase PKCS8_NO_OCTET:\\r\\ncase PKCS8_NS_DB:\\r\\ncase PKCS8_EMBEDDED_PARAM:\\r\\ndefault:\\r\\nEVPerr(EVP_F_ECKEY_PKEY2PKCS8,EVP_R_ENCODE_ERROR);\\r\\n}\\r\\nOPENSSL_cleanse(p, (size_t)i);\\r\\nOPENSSL_free(p);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_get_attr_count(const EVP_PKEY *key)\\r\\n{\\r\\nreturn X509at_get_attr_count(key->attributes);\\r\\n}\\r\\nint EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(key->attributes, nid, lastpos);\\r\\n}\\r\\nint EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(key->attributes, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(key->attributes, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(key->attributes, loc);\\r\\n}\\r\\nint EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif(X509at_add1_attr(&key->attributes, attr)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_OBJ(&key->attributes, obj,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,\\r\\nint nid, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_NID(&key->attributes, nid,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,\\r\\nconst char *attrname, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_txt(&key->attributes, attrname,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_data_c", "target": 0, "func": "void policy_data_free(X509_POLICY_DATA *data)\\r\\n{\\r\\nASN1_OBJECT_free(data->valid_policy);\\r\\nif (!(data->flags & POLICY_DATA_FLAG_SHARED_QUALIFIERS))\\r\\nsk_POLICYQUALINFO_pop_free(data->qualifier_set,\\r\\nPOLICYQUALINFO_free);\\r\\nsk_ASN1_OBJECT_pop_free(data->expected_policy_set, ASN1_OBJECT_free);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nX509_POLICY_DATA *policy_data_new(POLICYINFO *policy, ASN1_OBJECT *id, int crit)\\r\\n{\\r\\nX509_POLICY_DATA *ret;\\r\\nif (!policy && !id)\\r\\nreturn NULL;\\r\\nret = OPENSSL_malloc(sizeof(X509_POLICY_DATA));\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nret->expected_policy_set = sk_ASN1_OBJECT_new_null();\\r\\nif (!ret->expected_policy_set)\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nif (crit)\\r\\nret->flags = POLICY_DATA_FLAG_CRITICAL;\\r\\nelse\\r\\nret->flags = 0;\\r\\nif (id)\\r\\nret->valid_policy = id;\\r\\nelse\\r\\n{\\r\\nret->valid_policy = policy->policyid;\\r\\npolicy->policyid = NULL;\\r\\n}\\r\\nif (policy)\\r\\n{\\r\\nret->qualifier_set = policy->qualifiers;\\r\\npolicy->qualifiers = NULL;\\r\\n}\\r\\nelse\\r\\nret->qualifier_set = NULL;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_lib_c", "target": 0, "func": "int RAND_set_rand_method(const RAND_METHOD *meth)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif(funct_ref)\\r\\n{\\r\\nENGINE_finish(funct_ref);\\r\\nfunct_ref = NULL;\\r\\n}\\r\\n#endif\\r\\ndefault_RAND_meth = meth;\\r\\nreturn 1;\\r\\n}\\r\\nconst RAND_METHOD *RAND_get_rand_method(void)\\r\\n{\\r\\nif (!default_RAND_meth)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = ENGINE_get_default_RAND();\\r\\nif(e)\\r\\n{\\r\\ndefault_RAND_meth = ENGINE_get_RAND(e);\\r\\nif(!default_RAND_meth)\\r\\n{\\r\\nENGINE_finish(e);\\r\\ne = NULL;\\r\\n}\\r\\n}\\r\\nif(e)\\r\\nfunct_ref = e;\\r\\nelse\\r\\n#endif\\r\\ndefault_RAND_meth = RAND_SSLeay();\\r\\n}\\r\\nreturn default_RAND_meth;\\r\\n}\\r\\nint RAND_set_rand_engine(ENGINE *engine)\\r\\n{\\r\\nconst RAND_METHOD *tmp_meth = NULL;\\r\\nif(engine)\\r\\n{\\r\\nif(!ENGINE_init(engine))\\r\\nreturn 0;\\r\\ntmp_meth = ENGINE_get_RAND(engine);\\r\\nif(!tmp_meth)\\r\\n{\\r\\nENGINE_finish(engine);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nRAND_set_rand_method(tmp_meth);\\r\\nfunct_ref = engine;\\r\\nreturn 1;\\r\\n}\\r\\nvoid RAND_cleanup(void)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->cleanup)\\r\\nmeth->cleanup();\\r\\nRAND_set_rand_method(NULL);\\r\\n}\\r\\nvoid RAND_seed(const void *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->seed)\\r\\nmeth->seed(buf,num);\\r\\n}\\r\\nvoid RAND_add(const void *buf, int num, double entropy)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->add)\\r\\nmeth->add(buf,num,entropy);\\r\\n}\\r\\nint RAND_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->bytes)\\r\\nreturn meth->bytes(buf,num);\\r\\nreturn(-1);\\r\\n}\\r\\nint RAND_pseudo_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->pseudorand)\\r\\nreturn meth->pseudorand(buf,num);\\r\\nreturn(-1);\\r\\n}\\r\\nint RAND_status(void)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->status)\\r\\nreturn meth->status();\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_none_c", "target": 0, "func": "int RSA_padding_add_none(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nif (flen > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\nif (flen < tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\nmemcpy(to,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_none(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nif (flen > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_NONE,RSA_R_DATA_TOO_LARGE);\\r\\nreturn(-1);\\r\\n}\\r\\nmemset(to,0,tlen-flen);\\r\\nmemcpy(to+tlen-flen,from,flen);\\r\\nreturn(tlen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2_skey_c", "target": 0, "func": "void RC2_set_key(RC2_KEY *key, int len, const unsigned char *data, int bits)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *k;\\r\\nRC2_INT *ki;\\r\\nunsigned int c,d;\\r\\nk= (unsigned char *)&(key->data[0]);\\r\\n*k=0;\\r\\nif (len > 128) len=128;\\r\\nif (bits <= 0) bits=1024;\\r\\nif (bits > 1024) bits=1024;\\r\\nfor (i=0; i<len; i++)\\r\\nk[i]=data[i];\\r\\nd=k[len-1];\\r\\nj=0;\\r\\nfor (i=len; i < 128; i++,j++)\\r\\n{\\r\\nd=key_table[(k[j]+d)&0xff];\\r\\nk[i]=d;\\r\\n}\\r\\nj=(bits+7)>>3;\\r\\ni=128-j;\\r\\nc= (0xff>>(-bits & 0x07));\\r\\nd=key_table[k[i]&c];\\r\\nk[i]=d;\\r\\nwhile (i--)\\r\\n{\\r\\nd=key_table[k[i+j]^d];\\r\\nk[i]=d;\\r\\n}\\r\\nki= &(key->data[63]);\\r\\nfor (i=127; i>=0; i-=2)\\r\\n*(ki--)=((k[i]<<8)|k[i-1])&0xffff;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_enc_read_c", "target": 0, "func": "int DES_enc_read(int fd, void *buf, int len, DES_key_schedule *sched,\\r\\nDES_cblock *iv)\\r\\n{\\r\\nint net_num=0;\\r\\nstatic unsigned char *net=NULL;\\r\\nstatic unsigned char *unnet=NULL;\\r\\nstatic int unnet_start=0;\\r\\nstatic int unnet_left=0;\\r\\nstatic unsigned char *tmpbuf=NULL;\\r\\nint i;\\r\\nlong num=0,rnum;\\r\\nunsigned char *p;\\r\\nif (tmpbuf == NULL)\\r\\n{\\r\\ntmpbuf=OPENSSL_malloc(BSIZE);\\r\\nif (tmpbuf == NULL) return(-1);\\r\\n}\\r\\nif (net == NULL)\\r\\n{\\r\\nnet=OPENSSL_malloc(BSIZE);\\r\\nif (net == NULL) return(-1);\\r\\n}\\r\\nif (unnet == NULL)\\r\\n{\\r\\nunnet=OPENSSL_malloc(BSIZE);\\r\\nif (unnet == NULL) return(-1);\\r\\n}\\r\\nif (unnet_left != 0)\\r\\n{\\r\\nif (unnet_left < len)\\r\\n{\\r\\nmemcpy(buf,&(unnet[unnet_start]),\\r\\nunnet_left);\\r\\ni=unnet_left;\\r\\nunnet_start=unnet_left=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(buf,&(unnet[unnet_start]),len);\\r\\nunnet_start+=len;\\r\\nunnet_left-=len;\\r\\ni=len;\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nif (len > MAXWRITE) len=MAXWRITE;\\r\\nwhile (net_num < HDRSIZE)\\r\\n{\\r\\ni=read(fd,(void *)&(net[net_num]),HDRSIZE-net_num);\\r\\n#ifdef EINTR\\r\\nif ((i == -1) && (errno == EINTR)) continue;\\r\\n#endif\\r\\nif (i <= 0) return(0);\\r\\nnet_num+=i;\\r\\n}\\r\\np=net;\\r\\nn2l(p,num);\\r\\nif ((num > MAXWRITE) || (num < 0))\\r\\nreturn(-1);\\r\\nrnum=(num < 8)?8:((num+7)/8*8);\\r\\nnet_num=0;\\r\\nwhile (net_num < rnum)\\r\\n{\\r\\ni=read(fd,(void *)&(net[net_num]),rnum-net_num);\\r\\n#ifdef EINTR\\r\\nif ((i == -1) && (errno == EINTR)) continue;\\r\\n#endif\\r\\nif (i <= 0) return(0);\\r\\nnet_num+=i;\\r\\n}\\r\\nif (len < num)\\r\\n{\\r\\nif (DES_rw_mode & DES_PCBC_MODE)\\r\\nDES_pcbc_encrypt(net,unnet,num,sched,iv,DES_DECRYPT);\\r\\nelse\\r\\nDES_cbc_encrypt(net,unnet,num,sched,iv,DES_DECRYPT);\\r\\nmemcpy(buf,unnet,len);\\r\\nunnet_start=len;\\r\\nunnet_left=num-len;\\r\\nnum=len;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len < rnum)\\r\\n{\\r\\nif (DES_rw_mode & DES_PCBC_MODE)\\r\\nDES_pcbc_encrypt(net,tmpbuf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nelse\\r\\nDES_cbc_encrypt(net,tmpbuf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nmemcpy(buf,tmpbuf,num);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (DES_rw_mode & DES_PCBC_MODE)\\r\\nDES_pcbc_encrypt(net,buf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nelse\\r\\nDES_cbc_encrypt(net,buf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\n}\\r\\n}\\r\\nreturn num;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_crl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nunsigned long nmflag = 0;\\r\\nX509_CRL *x=NULL;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nint ret=1,i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile=NULL,*outfile=NULL;\\r\\nint hash=0,issuer=0,lastupdate=0,nextupdate=0,noout=0,text=0;\\r\\nint fingerprint = 0;\\r\\nconst char **pp;\\r\\nX509_STORE *store = NULL;\\r\\nX509_STORE_CTX ctx;\\r\\nX509_LOOKUP *lookup = NULL;\\r\\nX509_OBJECT xobj;\\r\\nEVP_PKEY *pkey;\\r\\nint do_ver = 0;\\r\\nconst EVP_MD *md_alg,*digest=EVP_sha1();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nif (bio_out == NULL)\\r\\nif ((bio_out=BIO_new(BIO_s_file())) != NULL)\\r\\n{\\r\\nBIO_set_fp(bio_out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_out = BIO_push(tmpbio, bio_out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\n#ifdef undef\\r\\nif (strcmp(*argv,\"-p\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!args_from_file(++argv,Nargc,Nargv)) { goto end; }*/\\r\\n}\\r\\n#endif\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCApath = *(++argv);\\r\\ndo_ver = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile = *(++argv);\\r\\ndo_ver = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\ndo_ver = 1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv,\"-hash\") == 0)\\r\\nhash= ++num;\\r\\nelse if (strcmp(*argv,\"-nameopt\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv))) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-issuer\") == 0)\\r\\nissuer= ++num;\\r\\nelse if (strcmp(*argv,\"-lastupdate\") == 0)\\r\\nlastupdate= ++num;\\r\\nelse if (strcmp(*argv,\"-nextupdate\") == 0)\\r\\nnextupdate= ++num;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse if (strcmp(*argv,\"-fingerprint\") == 0)\\r\\nfingerprint= ++num;\\r\\nelse if ((md_alg=EVP_get_digestbyname(*argv + 1)))\\r\\n{\\r\\ndigest=md_alg;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=crl_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nx=load_crl(infile,informat);\\r\\nif (x == NULL) { goto end; }\\r\\nif(do_ver) {\\r\\nstore = X509_STORE_new();\\r\\nlookup=X509_STORE_add_lookup(store,X509_LOOKUP_file());\\r\\nif (lookup == NULL) goto end;\\r\\nif (!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(store,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) goto end;\\r\\nif (!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nif(!X509_STORE_CTX_init(&ctx, store, NULL, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error initialising X509 store\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni = X509_STORE_get_by_subject(&ctx, X509_LU_X509,\\r\\nX509_CRL_get_issuer(x), &xobj);\\r\\nif(i <= 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error getting CRL issuer certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\npkey = X509_get_pubkey(xobj.data.x509);\\r\\nX509_OBJECT_free_contents(&xobj);\\r\\nif(!pkey) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error getting CRL issuer public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni = X509_CRL_verify(x, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif(i < 0) goto end;\\r\\nif(i == 0) BIO_printf(bio_err, \"verify failure\\n\");\\r\\nelse BIO_printf(bio_err, \"verify OK\\n\");\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nfor (i=1; i<=num; i++)\\r\\n{\\r\\nif (issuer == i)\\r\\n{\\r\\nprint_name(bio_out, \"issuer=\", X509_CRL_get_issuer(x), nmflag);\\r\\n}\\r\\nif (hash == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"%08lx\\n\",\\r\\nX509_NAME_hash(X509_CRL_get_issuer(x)));\\r\\n}\\r\\nif (lastupdate == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"lastUpdate=\");\\r\\nASN1_TIME_print(bio_out,\\r\\nX509_CRL_get_lastUpdate(x));\\r\\nBIO_printf(bio_out,\"\\n\");\\r\\n}\\r\\nif (nextupdate == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"nextUpdate=\");\\r\\nif (X509_CRL_get_nextUpdate(x))\\r\\nASN1_TIME_print(bio_out,\\r\\nX509_CRL_get_nextUpdate(x));\\r\\nelse\\r\\nBIO_printf(bio_out,\"NONE\");\\r\\nBIO_printf(bio_out,\"\\n\");\\r\\n}\\r\\nif (fingerprint == i)\\r\\n{\\r\\nint j;\\r\\nunsigned int n;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!X509_CRL_digest(x,digest,md,&n))\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_out,\"%s Fingerprint=\",\\r\\nOBJ_nid2sn(EVP_MD_type(digest)));\\r\\nfor (j=0; j<(int)n; j++)\\r\\n{\\r\\nBIO_printf(bio_out,\"%02X%c\",md[j],\\r\\n(j+1 == (int)n)\\r\\n?'\\n':':');\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text) X509_CRL_print(out, x);\\r\\nif (noout)\\r\\n{\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=(int)i2d_X509_CRL_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509_CRL(out,x);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) { BIO_printf(bio_err,\"unable to write CRL\\n\"); goto end; }\\r\\nret=0;\\r\\nend:\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(bio_out);\\r\\nbio_out=NULL;\\r\\nX509_CRL_free(x);\\r\\nif(store) {\\r\\nX509_STORE_CTX_cleanup(&ctx);\\r\\nX509_STORE_free(store);\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic X509_CRL *load_crl(char *infile, int format)\\r\\n{\\r\\nX509_CRL *x=NULL;\\r\\nBIO *in=NULL;\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_X509_CRL_bio(in,NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nBIO_free(in);\\r\\nreturn(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p512_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,2);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_utf8_c", "target": 0, "func": "int UTF8_getc(const unsigned char *str, int len, unsigned long *val)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nunsigned long value;\\r\\nint ret;\\r\\nif(len <= 0) return 0;\\r\\np = str;\\r\\nif((*p & 0x80) == 0) {\\r\\nvalue = *p++ & 0x7f;\\r\\nret = 1;\\r\\n} else if((*p & 0xe0) == 0xc0) {\\r\\nif(len < 2) return -1;\\r\\nif((p[1] & 0xc0) != 0x80) return -3;\\r\\nvalue = (*p++ & 0x1f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif(value < 0x80) return -4;\\r\\nret = 2;\\r\\n} else if((*p & 0xf0) == 0xe0) {\\r\\nif(len < 3) return -1;\\r\\nif( ((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80) ) return -3;\\r\\nvalue = (*p++ & 0xf) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif(value < 0x800) return -4;\\r\\nret = 3;\\r\\n} else if((*p & 0xf8) == 0xf0) {\\r\\nif(len < 4) return -1;\\r\\nif( ((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80) ) return -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x7)) << 18;\\r\\nvalue |= (*p++ & 0x3f) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif(value < 0x10000) return -4;\\r\\nret = 4;\\r\\n} else if((*p & 0xfc) == 0xf8) {\\r\\nif(len < 5) return -1;\\r\\nif( ((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80)\\r\\n|| ((p[4] & 0xc0) != 0x80) ) return -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x3)) << 24;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 18;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif(value < 0x200000) return -4;\\r\\nret = 5;\\r\\n} else if((*p & 0xfe) == 0xfc) {\\r\\nif(len < 6) return -1;\\r\\nif( ((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80)\\r\\n|| ((p[4] & 0xc0) != 0x80)\\r\\n|| ((p[5] & 0xc0) != 0x80) ) return -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x1)) << 30;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 24;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 18;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif(value < 0x4000000) return -4;\\r\\nret = 6;\\r\\n} else return -2;\\r\\n*val = value;\\r\\nreturn ret;\\r\\n}\\r\\nint UTF8_putc(unsigned char *str, int len, unsigned long value)\\r\\n{\\r\\nif(!str) len = 6;\\r\\nelse if(len <= 0) return -1;\\r\\nif(value < 0x80) {\\r\\nif(str) *str = (unsigned char)value;\\r\\nreturn 1;\\r\\n}\\r\\nif(value < 0x800) {\\r\\nif(len < 2) return -1;\\r\\nif(str) {\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x1f) | 0xc0);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 2;\\r\\n}\\r\\nif(value < 0x10000) {\\r\\nif(len < 3) return -1;\\r\\nif(str) {\\r\\n*str++ = (unsigned char)(((value >> 12) & 0xf) | 0xe0);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 3;\\r\\n}\\r\\nif(value < 0x200000) {\\r\\nif(len < 4) return -1;\\r\\nif(str) {\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x7) | 0xf0);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 4;\\r\\n}\\r\\nif(value < 0x4000000) {\\r\\nif(len < 5) return -1;\\r\\nif(str) {\\r\\n*str++ = (unsigned char)(((value >> 24) & 0x3) | 0xf8);\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 5;\\r\\n}\\r\\nif(len < 6) return -1;\\r\\nif(str) {\\r\\n*str++ = (unsigned char)(((value >> 30) & 0x1) | 0xfc);\\r\\n*str++ = (unsigned char)(((value >> 24) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 6;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_crpt_c", "target": 0, "func": "void PKCS12_PBE_add(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And128BitRC4, EVP_rc4(), EVP_sha1(),\\r\\nPKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And40BitRC4, EVP_rc4_40(), EVP_sha1(),\\r\\nPKCS12_PBE_keyivgen);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DES\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And3_Key_TripleDES_CBC,\\r\\nEVP_des_ede3_cbc(), EVP_sha1(), PKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And2_Key_TripleDES_CBC,\\r\\nEVP_des_ede_cbc(), EVP_sha1(), PKCS12_PBE_keyivgen);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And128BitRC2_CBC, EVP_rc2_cbc(),\\r\\nEVP_sha1(), PKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And40BitRC2_CBC, EVP_rc2_40_cbc(),\\r\\nEVP_sha1(), PKCS12_PBE_keyivgen);\\r\\n#endif\\r\\n}\\r\\nint PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter, ret;\\r\\nunsigned char *salt;\\r\\nconst unsigned char *pbuf;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\npbuf = param->value.sequence->data;\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe = d2i_PBEPARAM (NULL, &pbuf, param->value.sequence->length))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_KEY_ID,\\r\\niter, EVP_CIPHER_key_length(cipher), key, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_KEY_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_IV_ID,\\r\\niter, EVP_CIPHER_iv_length(cipher), iv, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_IV_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nPBEPARAM_free(pbe);\\r\\nret = EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, en_de);\\r\\nOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_null_c", "target": 0, "func": "const EVP_CIPHER *EVP_enc_null(void)\\r\\n{\\r\\nreturn(&n_cipher);\\r\\n}\\r\\nstatic int null_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int null_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nif (in != out)\\r\\nmemcpy((char *)out,(const char *)in,(size_t)inl);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s_time_c", "target": 0, "func": "static void s_time_init(void)\\r\\n{\\r\\nhost=SSL_CONNECT_NAME;\\r\\nt_cert_file=NULL;\\r\\nt_key_file=NULL;\\r\\nCApath=NULL;\\r\\nCAfile=NULL;\\r\\ntm_cipher=NULL;\\r\\ntm_verify = SSL_VERIFY_NONE;\\r\\nmaxTime = SECONDS;\\r\\ntm_ctx=NULL;\\r\\ns_time_meth=NULL;\\r\\ns_www_path=NULL;\\r\\nbytes_read=0;\\r\\nst_bugs=0;\\r\\nperform=0;\\r\\n#ifdef FIONBIO\\r\\nt_nbio=0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_WIN32\\r\\nexitNow = 0;\\r\\n#endif\\r\\n}\\r\\nstatic void s_time_usage(void)\\r\\n{\\r\\nstatic char umsg[] = \"\\\\r\\n-time arg - max number of seconds to collect data, default %d\\n\\\\r\\n-verify arg - turn on peer certificate verification, arg == depth\\n\\\\r\\n-cert arg - certificate file to use, PEM format assumed\\n\\\\r\\n-key arg - RSA file to use, PEM format assumed, key is in cert file\\n\\\\r\\nfile if not specified by this option\\n\\\\r\\n-CApath arg - PEM format directory of CA's\\n\\\\r\\n-CAfile arg - PEM format file of CA's\\n\\\\r\\n-cipher - preferred cipher to use, play with 'openssl ciphers'\\n\\n\";\\r\\nprintf( \"usage: s_time <args>\\n\\n\" );\\r\\nprintf(\"-connect host:port - host:port to connect to (default is %s)\\n\",SSL_CONNECT_NAME);\\r\\n#ifdef FIONBIO\\r\\nprintf(\"-nbio - Run with non-blocking IO\\n\");\\r\\nprintf(\"-ssl2 - Just use SSLv2\\n\");\\r\\nprintf(\"-ssl3 - Just use SSLv3\\n\");\\r\\nprintf(\"-bugs - Turn on SSL bug compatibility\\n\");\\r\\nprintf(\"-new - Just time new connections\\n\");\\r\\nprintf(\"-reuse - Just time connection reuse\\n\");\\r\\nprintf(\"-www page - Retrieve 'page' from the site\\n\");\\r\\n#endif\\r\\nprintf( umsg,SECONDS );\\r\\n}\\r\\nstatic int parseArgs(int argc, char **argv)\\r\\n{\\r\\nint badop = 0;\\r\\nverify_depth=0;\\r\\nverify_error=X509_V_OK;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv,\"-connect\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\n#if 0\\r\\nelse if( strcmp(*argv,\"-host\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\nelse if( strcmp(*argv,\"-port\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nport= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-reuse\") == 0)\\r\\nperform=2;\\r\\nelse if (strcmp(*argv,\"-new\") == 0)\\r\\nperform=1;\\r\\nelse if( strcmp(*argv,\"-verify\") == 0) {\\r\\ntm_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n} else if( strcmp(*argv,\"-cert\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nt_cert_file= *(++argv);\\r\\n} else if( strcmp(*argv,\"-key\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nt_key_file= *(++argv);\\r\\n} else if( strcmp(*argv,\"-CApath\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n} else if( strcmp(*argv,\"-CAfile\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n} else if( strcmp(*argv,\"-cipher\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\ntm_cipher= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if(strcmp(*argv,\"-nbio\") == 0) {\\r\\nt_nbio=1;\\r\\n}\\r\\n#endif\\r\\nelse if(strcmp(*argv,\"-www\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_www_path= *(++argv);\\r\\nif(strlen(s_www_path) > MYBUFSIZ-100)\\r\\n{\\r\\nBIO_printf(bio_err,\"-www option too long\\n\");\\r\\nbadop=1;\\r\\n}\\r\\n}\\r\\nelse if(strcmp(*argv,\"-bugs\") == 0)\\r\\nst_bugs=1;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if(strcmp(*argv,\"-ssl2\") == 0)\\r\\ns_time_meth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if(strcmp(*argv,\"-ssl3\") == 0)\\r\\ns_time_meth=SSLv3_client_method();\\r\\n#endif\\r\\nelse if( strcmp(*argv,\"-time\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nmaxTime= atoi(*(++argv));\\r\\n}\\r\\nelse {\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (perform == 0) perform=3;\\r\\nif(badop) {\\r\\nbad:\\r\\ns_time_usage();\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic double tm_Time_F(int s)\\r\\n{\\r\\nstatic double ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif(s == START) {\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n} else {\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_NETWARE)\\r\\nstatic clock_t tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntstart=clock();\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntend=clock();\\r\\nret=(double)((double)(tend)-(double)(tstart));\\r\\nreturn((ret < 0.001)?0.001:ret);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_VXWORKS)\\r\\n{\\r\\nstatic unsigned long tick_start, tick_end;\\r\\nif( s == START )\\r\\n{\\r\\ntick_start = tickGet();\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntick_end = tickGet();\\r\\nret = (double)(tick_end - tick_start) / (double)sysClkRateGet();\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif(s == START) {\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n} else {\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\ndouble totalTime = 0.0;\\r\\nint nConn = 0;\\r\\nSSL *scon=NULL;\\r\\nlong finishtime=0;\\r\\nint ret=1,i;\\r\\nMS_STATIC char buf[1024*8];\\r\\nint ver;\\r\\napps_startup();\\r\\ns_time_init();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\ns_time_meth=SSLv23_client_method();\\r\\n#elif !defined(OPENSSL_NO_SSL3)\\r\\ns_time_meth=SSLv3_client_method();\\r\\n#elif !defined(OPENSSL_NO_SSL2)\\r\\ns_time_meth=SSLv2_client_method();\\r\\n#endif\\r\\nif( parseArgs( argc, argv ) < 0 )\\r\\ngoto end;\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nif ((tm_ctx=SSL_CTX_new(s_time_meth)) == NULL) return(1);\\r\\nSSL_CTX_set_quiet_shutdown(tm_ctx,1);\\r\\nif (st_bugs) SSL_CTX_set_options(tm_ctx,SSL_OP_ALL);\\r\\nSSL_CTX_set_cipher_list(tm_ctx,tm_cipher);\\r\\nif(!set_cert_stuff(tm_ctx,t_cert_file,t_key_file))\\r\\ngoto end;\\r\\nSSL_load_error_strings();\\r\\nif ((!SSL_CTX_load_verify_locations(tm_ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(tm_ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (tm_cipher == NULL)\\r\\ntm_cipher = getenv(\"SSL_CIPHER\");\\r\\nif (tm_cipher == NULL ) {\\r\\nfprintf( stderr, \"No CIPHER specified\\n\" );\\r\\n}\\r\\nif (!(perform & 1)) goto next;\\r\\nprintf( \"Collecting connection statistics for %d seconds\\n\", maxTime );\\r\\nbytes_read=0;\\r\\nfinishtime=(long)time(NULL)+maxTime;\\r\\ntm_Time_F(START);\\r\\nfor (;;)\\r\\n{\\r\\nif (finishtime < (long)time(NULL)) break;\\r\\n#ifdef WIN32_STUFF\\r\\nif( flushWinMsgs(0) == -1 )\\r\\ngoto end;\\r\\nif( waitingToDie || exitNow )\\r\\ngoto end;\\r\\n#endif\\r\\nif( (scon = doConnection( NULL )) == NULL )\\r\\ngoto end;\\r\\nif (s_www_path != NULL)\\r\\n{\\r\\nBIO_snprintf(buf,sizeof buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile ((i=SSL_read(scon,buf,sizeof(buf))) > 0)\\r\\nbytes_read+=i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver='r';\\r\\nelse\\r\\n{\\r\\nver=SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver='t';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver='3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver='2';\\r\\nelse\\r\\nver='*';\\r\\n}\\r\\nfputc(ver,stdout);\\r\\nfflush(stdout);\\r\\nSSL_free( scon );\\r\\nscon=NULL;\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\ni=(int)((long)time(NULL)-finishtime+maxTime);\\r\\nprintf( \"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\", nConn, totalTime, ((double)nConn/totalTime),bytes_read);\\r\\nprintf( \"%d connections in %ld real seconds, %ld bytes read per connection\\n\",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);\\r\\nnext:\\r\\nif (!(perform & 2)) goto end;\\r\\nprintf( \"\\n\\nNow timing with session id reuse.\\n\" );\\r\\nif( (scon = doConnection( NULL )) == NULL )\\r\\n{\\r\\nfprintf( stderr, \"Unable to get connection\\n\" );\\r\\ngoto end;\\r\\n}\\r\\nif (s_www_path != NULL)\\r\\n{\\r\\nBIO_snprintf(buf,sizeof buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile (SSL_read(scon,buf,sizeof(buf)) > 0)\\r\\n;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn = 0;\\r\\ntotalTime = 0.0;\\r\\nfinishtime=(long)time(NULL)+maxTime;\\r\\nprintf( \"starting\\n\" );\\r\\nbytes_read=0;\\r\\ntm_Time_F(START);\\r\\nfor (;;)\\r\\n{\\r\\nif (finishtime < (long)time(NULL)) break;\\r\\n#ifdef WIN32_STUFF\\r\\nif( flushWinMsgs(0) == -1 )\\r\\ngoto end;\\r\\nif( waitingToDie || exitNow )\\r\\ngoto end;\\r\\n#endif\\r\\nif( (doConnection( scon )) == NULL )\\r\\ngoto end;\\r\\nif (s_www_path)\\r\\n{\\r\\nBIO_snprintf(buf,sizeof buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile ((i=SSL_read(scon,buf,sizeof(buf))) > 0)\\r\\nbytes_read+=i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver='r';\\r\\nelse\\r\\n{\\r\\nver=SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver='t';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver='3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver='2';\\r\\nelse\\r\\nver='*';\\r\\n}\\r\\nfputc(ver,stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\nprintf( \"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\", nConn, totalTime, ((double)nConn/totalTime),bytes_read);\\r\\nprintf( \"%d connections in %ld real seconds, %ld bytes read per connection\\n\",nConn,(long)time(NULL)-finishtime+maxTime,bytes_read/nConn);\\r\\nret=0;\\r\\nend:\\r\\nif (scon != NULL) SSL_free(scon);\\r\\nif (tm_ctx != NULL)\\r\\n{\\r\\nSSL_CTX_free(tm_ctx);\\r\\ntm_ctx=NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic SSL *doConnection(SSL *scon)\\r\\n{\\r\\nBIO *conn;\\r\\nSSL *serverCon;\\r\\nint width, i;\\r\\nfd_set readfds;\\r\\nif ((conn=BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_set_conn_hostname(conn,host);\\r\\nif (scon == NULL)\\r\\nserverCon=SSL_new(tm_ctx);\\r\\nelse\\r\\n{\\r\\nserverCon=scon;\\r\\nSSL_set_connect_state(serverCon);\\r\\n}\\r\\nSSL_set_bio(serverCon,conn,conn);\\r\\n#if 0\\r\\nif( scon != NULL )\\r\\nSSL_set_session(serverCon,SSL_get_session(scon));\\r\\n#endif\\r\\nfor(;;) {\\r\\ni=SSL_connect(serverCon);\\r\\nif (BIO_sock_should_retry(i))\\r\\n{\\r\\nBIO_printf(bio_err,\"DELAY\\n\");\\r\\ni=SSL_get_fd(serverCon);\\r\\nwidth=i+1;\\r\\nFD_ZERO(&readfds);\\r\\nFD_SET(i,&readfds);\\r\\nselect(width,(void *)&readfds,NULL,NULL,NULL);\\r\\ncontinue;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif(i <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR\\n\");\\r\\nif (verify_error != X509_V_OK)\\r\\nBIO_printf(bio_err,\"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nif (scon == NULL)\\r\\nSSL_free(serverCon);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn serverCon;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_err_c", "target": 0, "func": "void ERR_load_CONF_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,CONF_str_functs);\\r\\nERR_load_strings(0,CONF_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_init_c", "target": 0, "func": "int engine_unlocked_init(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif((e->funct_ref == 0) && e->init)\\r\\nto_return = e->init(e);\\r\\nif(to_return)\\r\\n{\\r\\ne->struct_ref++;\\r\\ne->funct_ref++;\\r\\nengine_ref_debug(e, 0, 1)\\r\\nengine_ref_debug(e, 1, 1)\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nint engine_unlocked_finish(ENGINE *e, int unlock_for_handlers)\\r\\n{\\r\\nint to_return = 1;\\r\\ne->funct_ref--;\\r\\nengine_ref_debug(e, 1, -1);\\r\\nif((e->funct_ref == 0) && e->finish)\\r\\n{\\r\\nif(unlock_for_handlers)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nto_return = e->finish(e);\\r\\nif(unlock_for_handlers)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(!to_return)\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef REF_CHECK\\r\\nif(e->funct_ref < 0)\\r\\n{\\r\\nfprintf(stderr,\"ENGINE_finish, bad functional reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif(!engine_free_util(e, 0))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_UNLOCKED_FINISH,ENGINE_R_FINISH_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nint ENGINE_init(ENGINE *e)\\r\\n{\\r\\nint ret;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_INIT,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_unlocked_init(e);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nint ENGINE_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_FINISH,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nto_return = engine_unlocked_finish(e, 1);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif(!to_return)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_FINISH,ENGINE_R_FINISH_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn to_return;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_sap_c", "target": 0, "func": "void OPENSSL_config(const char *config_name)\\r\\n{\\r\\nif (openssl_configured)\\r\\nreturn;\\r\\nOPENSSL_load_builtin_modules();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_load_builtin_engines();\\r\\n#endif\\r\\nERR_clear_error();\\r\\nif (CONF_modules_load_file(NULL, NULL,\\r\\nCONF_MFLAGS_IGNORE_MISSING_FILE) <= 0)\\r\\n{\\r\\nBIO *bio_err;\\r\\nERR_load_crypto_strings();\\r\\nif ((bio_err=BIO_new_fp(stderr, BIO_NOCLOSE)) != NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Auto configuration failed\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nBIO_free(bio_err);\\r\\n}\\r\\nexit(1);\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nvoid OPENSSL_no_config()\\r\\n{\\r\\nopenssl_configured = 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_lh_stats_c", "target": 0, "func": "void lh_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nfprintf(out,\"num_items = %lu\\n\",lh->num_items);\\r\\nfprintf(out,\"num_nodes = %u\\n\",lh->num_nodes);\\r\\nfprintf(out,\"num_alloc_nodes = %u\\n\",lh->num_alloc_nodes);\\r\\nfprintf(out,\"num_expands = %lu\\n\",lh->num_expands);\\r\\nfprintf(out,\"num_expand_reallocs = %lu\\n\",lh->num_expand_reallocs);\\r\\nfprintf(out,\"num_contracts = %lu\\n\",lh->num_contracts);\\r\\nfprintf(out,\"num_contract_reallocs = %lu\\n\",lh->num_contract_reallocs);\\r\\nfprintf(out,\"num_hash_calls = %lu\\n\",lh->num_hash_calls);\\r\\nfprintf(out,\"num_comp_calls = %lu\\n\",lh->num_comp_calls);\\r\\nfprintf(out,\"num_insert = %lu\\n\",lh->num_insert);\\r\\nfprintf(out,\"num_replace = %lu\\n\",lh->num_replace);\\r\\nfprintf(out,\"num_delete = %lu\\n\",lh->num_delete);\\r\\nfprintf(out,\"num_no_delete = %lu\\n\",lh->num_no_delete);\\r\\nfprintf(out,\"num_retrieve = %lu\\n\",lh->num_retrieve);\\r\\nfprintf(out,\"num_retrieve_miss = %lu\\n\",lh->num_retrieve_miss);\\r\\nfprintf(out,\"num_hash_comps = %lu\\n\",lh->num_hash_comps);\\r\\n#if 0\\r\\nfprintf(out,\"p = %u\\n\",lh->p);\\r\\nfprintf(out,\"pmax = %u\\n\",lh->pmax);\\r\\nfprintf(out,\"up_load = %lu\\n\",lh->up_load);\\r\\nfprintf(out,\"down_load = %lu\\n\",lh->down_load);\\r\\n#endif\\r\\n}\\r\\nvoid lh_node_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i,num;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nfprintf(out,\"node %6u -> %3u\\n\",i,num);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total=0,n_used=0;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nif (num != 0)\\r\\n{\\r\\nn_used++;\\r\\ntotal+=num;\\r\\n}\\r\\n}\\r\\nfprintf(out,\"%lu nodes used out of %u\\n\",n_used,lh->num_nodes);\\r\\nfprintf(out,\"%lu items\\n\",total);\\r\\nif (n_used == 0) return;\\r\\nfprintf(out,\"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total/lh->num_nodes),\\r\\n(int)((total%lh->num_nodes)*100/lh->num_nodes),\\r\\n(int)(total/n_used),\\r\\n(int)((total%n_used)*100/n_used));\\r\\n}\\r\\nvoid lh_stats(const LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_stats(const LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_node_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_usage_stats(const LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_node_usage_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_stats_bio(const LHASH *lh, BIO *out)\\r\\n{\\r\\nBIO_printf(out,\"num_items = %lu\\n\",lh->num_items);\\r\\nBIO_printf(out,\"num_nodes = %u\\n\",lh->num_nodes);\\r\\nBIO_printf(out,\"num_alloc_nodes = %u\\n\",lh->num_alloc_nodes);\\r\\nBIO_printf(out,\"num_expands = %lu\\n\",lh->num_expands);\\r\\nBIO_printf(out,\"num_expand_reallocs = %lu\\n\",\\r\\nlh->num_expand_reallocs);\\r\\nBIO_printf(out,\"num_contracts = %lu\\n\",lh->num_contracts);\\r\\nBIO_printf(out,\"num_contract_reallocs = %lu\\n\",\\r\\nlh->num_contract_reallocs);\\r\\nBIO_printf(out,\"num_hash_calls = %lu\\n\",lh->num_hash_calls);\\r\\nBIO_printf(out,\"num_comp_calls = %lu\\n\",lh->num_comp_calls);\\r\\nBIO_printf(out,\"num_insert = %lu\\n\",lh->num_insert);\\r\\nBIO_printf(out,\"num_replace = %lu\\n\",lh->num_replace);\\r\\nBIO_printf(out,\"num_delete = %lu\\n\",lh->num_delete);\\r\\nBIO_printf(out,\"num_no_delete = %lu\\n\",lh->num_no_delete);\\r\\nBIO_printf(out,\"num_retrieve = %lu\\n\",lh->num_retrieve);\\r\\nBIO_printf(out,\"num_retrieve_miss = %lu\\n\",lh->num_retrieve_miss);\\r\\nBIO_printf(out,\"num_hash_comps = %lu\\n\",lh->num_hash_comps);\\r\\n#if 0\\r\\nBIO_printf(out,\"p = %u\\n\",lh->p);\\r\\nBIO_printf(out,\"pmax = %u\\n\",lh->pmax);\\r\\nBIO_printf(out,\"up_load = %lu\\n\",lh->up_load);\\r\\nBIO_printf(out,\"down_load = %lu\\n\",lh->down_load);\\r\\n#endif\\r\\n}\\r\\nvoid lh_node_stats_bio(const LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i,num;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nBIO_printf(out,\"node %6u -> %3u\\n\",i,num);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats_bio(const LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total=0,n_used=0;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nif (num != 0)\\r\\n{\\r\\nn_used++;\\r\\ntotal+=num;\\r\\n}\\r\\n}\\r\\nBIO_printf(out,\"%lu nodes used out of %u\\n\",n_used,lh->num_nodes);\\r\\nBIO_printf(out,\"%lu items\\n\",total);\\r\\nif (n_used == 0) return;\\r\\nBIO_printf(out,\"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total/lh->num_nodes),\\r\\n(int)((total%lh->num_nodes)*100/lh->num_nodes),\\r\\n(int)(total/n_used),\\r\\n(int)((total%n_used)*100/n_used));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_opts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic char key[16]={ 0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nBF_KEY sch;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most accurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nBF_set_key(&sch,16,key);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nBF_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\ntime_it(BF_encrypt_normal, \"BF_encrypt_normal \", 0);\\r\\ntime_it(BF_encrypt_ptr, \"BF_encrypt_ptr \", 1);\\r\\ntime_it(BF_encrypt_ptr2, \"BF_encrypt_ptr2 \", 2);\\r\\nnum+=3;\\r\\nstr[0]=\"<nothing>\";\\r\\nprint_it(\"BF_encrypt_normal \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"ptr \";\\r\\nprint_it(\"BF_encrypt_ptr \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\"ptr2 \";\\r\\nprint_it(\"BF_encrypt_ptr2 \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\nprintf(\"options BF ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DBF_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DBF_PTR\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DBF_PTR2\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_digest_c", "target": 0, "func": "void EVP_MD_CTX_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nmemset(ctx,'\\0',sizeof *ctx);\\r\\n}\\r\\nEVP_MD_CTX *EVP_MD_CTX_create(void)\\r\\n{\\r\\nEVP_MD_CTX *ctx=OPENSSL_malloc(sizeof *ctx);\\r\\nEVP_MD_CTX_init(ctx);\\r\\nreturn ctx;\\r\\n}\\r\\nint EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX_init(ctx);\\r\\nreturn EVP_DigestInit_ex(ctx, type, NULL);\\r\\n}\\r\\nint EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)\\r\\n{\\r\\nEVP_MD_CTX_clear_flags(ctx,EVP_MD_CTX_FLAG_CLEANED);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine && ctx->digest && (!type ||\\r\\n(type && (type->type == ctx->digest->type))))\\r\\ngoto skip_to_init;\\r\\nif (type)\\r\\n{\\r\\nif(ctx->engine)\\r\\nENGINE_finish(ctx->engine);\\r\\nif(impl)\\r\\n{\\r\\nif (!ENGINE_init(impl))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX,EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse\\r\\nimpl = ENGINE_get_digest_engine(type->type);\\r\\nif(impl)\\r\\n{\\r\\nconst EVP_MD *d = ENGINE_get_digest(impl, type->type);\\r\\nif(!d)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX,EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\ntype = d;\\r\\nctx->engine = impl;\\r\\n}\\r\\nelse\\r\\nctx->engine = NULL;\\r\\n}\\r\\nelse\\r\\nif(!ctx->digest)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX,EVP_R_NO_DIGEST_SET);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (ctx->digest != type)\\r\\n{\\r\\nif (ctx->digest && ctx->digest->ctx_size)\\r\\nOPENSSL_free(ctx->md_data);\\r\\nctx->digest=type;\\r\\nif (type->ctx_size)\\r\\nctx->md_data=OPENSSL_malloc(type->ctx_size);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nskip_to_init:\\r\\n#endif\\r\\nreturn ctx->digest->init(ctx);\\r\\n}\\r\\nint EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data,\\r\\nsize_t count)\\r\\n{\\r\\nreturn ctx->digest->update(ctx,data,count);\\r\\n}\\r\\nint EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_DigestFinal_ex(ctx, md, size);\\r\\nEVP_MD_CTX_cleanup(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\\r\\n{\\r\\nint ret;\\r\\nOPENSSL_assert(ctx->digest->md_size <= EVP_MAX_MD_SIZE);\\r\\nret=ctx->digest->final(ctx,md);\\r\\nif (size != NULL)\\r\\n*size=ctx->digest->md_size;\\r\\nif (ctx->digest->cleanup)\\r\\n{\\r\\nctx->digest->cleanup(ctx);\\r\\nEVP_MD_CTX_set_flags(ctx,EVP_MD_CTX_FLAG_CLEANED);\\r\\n}\\r\\nmemset(ctx->md_data,0,ctx->digest->ctx_size);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)\\r\\n{\\r\\nEVP_MD_CTX_init(out);\\r\\nreturn EVP_MD_CTX_copy_ex(out, in);\\r\\n}\\r\\nint EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)\\r\\n{\\r\\nunsigned char *tmp_buf;\\r\\nif ((in == NULL) || (in->digest == NULL))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY_EX,EVP_R_INPUT_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (in->engine && !ENGINE_init(in->engine))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY_EX,ERR_R_ENGINE_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (out->digest == in->digest)\\r\\n{\\r\\ntmp_buf = out->md_data;\\r\\nEVP_MD_CTX_set_flags(out,EVP_MD_CTX_FLAG_REUSE);\\r\\n}\\r\\nelse tmp_buf = NULL;\\r\\nEVP_MD_CTX_cleanup(out);\\r\\nmemcpy(out,in,sizeof *out);\\r\\nif (out->digest->ctx_size)\\r\\n{\\r\\nif (tmp_buf) out->md_data = tmp_buf;\\r\\nelse out->md_data=OPENSSL_malloc(out->digest->ctx_size);\\r\\nmemcpy(out->md_data,in->md_data,out->digest->ctx_size);\\r\\n}\\r\\nif (out->digest->copy)\\r\\nreturn out->digest->copy(out,in);\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_Digest(const void *data, size_t count,\\r\\nunsigned char *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nint ret;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_set_flags(&ctx,EVP_MD_CTX_FLAG_ONESHOT);\\r\\nret=EVP_DigestInit_ex(&ctx, type, impl)\\r\\n&& EVP_DigestUpdate(&ctx, data, count)\\r\\n&& EVP_DigestFinal_ex(&ctx, md, size);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ret;\\r\\n}\\r\\nvoid EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)\\r\\n{\\r\\nEVP_MD_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)\\r\\n{\\r\\nif (ctx->digest && ctx->digest->cleanup\\r\\n&& !EVP_MD_CTX_test_flags(ctx,EVP_MD_CTX_FLAG_CLEANED))\\r\\nctx->digest->cleanup(ctx);\\r\\nif (ctx->digest && ctx->digest->ctx_size && ctx->md_data\\r\\n&& !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE))\\r\\n{\\r\\nOPENSSL_cleanse(ctx->md_data,ctx->digest->ctx_size);\\r\\nOPENSSL_free(ctx->md_data);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif(ctx->engine)\\r\\nENGINE_finish(ctx->engine);\\r\\n#endif\\r\\nmemset(ctx,'\\0',sizeof *ctx);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509type_c", "target": 0, "func": "int X509_certificate_type(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret=0,i;\\r\\nif (x == NULL) return(0);\\r\\nif (pkey == NULL)\\r\\npk=X509_get_pubkey(x);\\r\\nelse\\r\\npk=pkey;\\r\\nif (pk == NULL) return(0);\\r\\nswitch (pk->type)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\nret=EVP_PK_RSA|EVP_PKT_SIGN;\\r\\nret|=EVP_PKT_ENC;\\r\\nbreak;\\r\\ncase EVP_PKEY_DSA:\\r\\nret=EVP_PK_DSA|EVP_PKT_SIGN;\\r\\nbreak;\\r\\ncase EVP_PKEY_EC:\\r\\nret=EVP_PK_EC|EVP_PKT_SIGN|EVP_PKT_EXCH;\\r\\nbreak;\\r\\ncase EVP_PKEY_DH:\\r\\nret=EVP_PK_DH|EVP_PKT_EXCH;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\ni=X509_get_signature_type(x);\\r\\nswitch (i)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\nret|=EVP_PKS_RSA;\\r\\nbreak;\\r\\ncase EVP_PKEY_DSA:\\r\\nret|=EVP_PKS_DSA;\\r\\nbreak;\\r\\ncase EVP_PKEY_EC:\\r\\nret|=EVP_PKS_EC;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (EVP_PKEY_size(pk) <= 1024/8)\\r\\nret|=EVP_PKT_EXP;\\r\\nif(pkey==NULL) EVP_PKEY_free(pk);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nDH *dh=NULL;\\r\\nint i,badops=0,text=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,check=0,noout=0,C=0,ret=1;\\r\\nchar *infile,*outfile,*prog;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nengine=NULL;\\r\\n#endif\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -check check the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -text print a text form of the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\" -noout no output\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\ndh=d2i_DHparams_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndh=PEM_read_bio_DHparams(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dh == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nDHparams_print(out,dh);\\r\\n#ifdef undef\\r\\nprintf(\"p=\");\\r\\nBN_print(stdout,dh->p);\\r\\nprintf(\"\\ng=\");\\r\\nBN_print(stdout,dh->g);\\r\\nprintf(\"\\n\");\\r\\nif (dh->length != 0)\\r\\nprintf(\"recommended private length=%ld\\n\",dh->length);\\r\\n#endif\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nif (!DH_check(dh,&i))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i & DH_CHECK_P_NOT_PRIME)\\r\\nprintf(\"p value is not prime\\n\");\\r\\nif (i & DH_CHECK_P_NOT_SAFE_PRIME)\\r\\nprintf(\"p value is not a safe prime\\n\");\\r\\nif (i & DH_UNABLE_TO_CHECK_GENERATOR)\\r\\nprintf(\"unable to check the generator value\\n\");\\r\\nif (i & DH_NOT_SUITABLE_GENERATOR)\\r\\nprintf(\"the g value is not a generator\\n\");\\r\\nif (i == 0)\\r\\nprintf(\"DH parameters appear to be ok.\\n\");\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nunsigned char *data;\\r\\nint len,l,bits;\\r\\nlen=BN_num_bytes(dh->p);\\r\\nbits=BN_num_bits(dh->p);\\r\\ndata=(unsigned char *)OPENSSL_malloc(len);\\r\\nif (data == NULL)\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nl=BN_bn2bin(dh->p,data);\\r\\nprintf(\"static unsigned char dh%d_p[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dh->g,data);\\r\\nprintf(\"static unsigned char dh%d_g[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\\n\");\\r\\nprintf(\"DH *get_dh%d()\\n\\t{\\n\",bits);\\r\\nprintf(\"\\tDH *dh;\\n\\n\");\\r\\nprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\\r\\nprintf(\"\\t\\treturn(NULL);\\n\");\\r\\nprintf(\"\\treturn(dh);\\n\\t}\\n\");\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DHparams_bio(out,dh);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DHparams(out,dh);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (dh != NULL) DH_free(dh);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p5_crpt2_c", "target": 0, "func": "int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,\\r\\nconst unsigned char *salt, int saltlen, int iter,\\r\\nint keylen, unsigned char *out)\\r\\n{\\r\\nunsigned char digtmp[SHA_DIGEST_LENGTH], *p, itmp[4];\\r\\nint cplen, j, k, tkeylen;\\r\\nunsigned long i = 1;\\r\\nHMAC_CTX hctx;\\r\\nHMAC_CTX_init(&hctx);\\r\\np = out;\\r\\ntkeylen = keylen;\\r\\nif(!pass) passlen = 0;\\r\\nelse if(passlen == -1) passlen = strlen(pass);\\r\\nwhile(tkeylen) {\\r\\nif(tkeylen > SHA_DIGEST_LENGTH) cplen = SHA_DIGEST_LENGTH;\\r\\nelse cplen = tkeylen;\\r\\nitmp[0] = (unsigned char)((i >> 24) & 0xff);\\r\\nitmp[1] = (unsigned char)((i >> 16) & 0xff);\\r\\nitmp[2] = (unsigned char)((i >> 8) & 0xff);\\r\\nitmp[3] = (unsigned char)(i & 0xff);\\r\\nHMAC_Init_ex(&hctx, pass, passlen, EVP_sha1(), NULL);\\r\\nHMAC_Update(&hctx, salt, saltlen);\\r\\nHMAC_Update(&hctx, itmp, 4);\\r\\nHMAC_Final(&hctx, digtmp, NULL);\\r\\nmemcpy(p, digtmp, cplen);\\r\\nfor(j = 1; j < iter; j++) {\\r\\nHMAC(EVP_sha1(), pass, passlen,\\r\\ndigtmp, SHA_DIGEST_LENGTH, digtmp, NULL);\\r\\nfor(k = 0; k < cplen; k++) p[k] ^= digtmp[k];\\r\\n}\\r\\ntkeylen-= cplen;\\r\\ni++;\\r\\np+= cplen;\\r\\n}\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\n#ifdef DEBUG_PKCS5V2\\r\\nfprintf(stderr, \"Password:\\n\");\\r\\nh__dump (pass, passlen);\\r\\nfprintf(stderr, \"Salt:\\n\");\\r\\nh__dump (salt, saltlen);\\r\\nfprintf(stderr, \"Iteration count %d\\n\", iter);\\r\\nfprintf(stderr, \"Key:\\n\");\\r\\nh__dump (out, keylen);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char out[4];\\r\\nunsigned char salt[] = {0x12, 0x34, 0x56, 0x78};\\r\\nPKCS5_PBKDF2_HMAC_SHA1(\"password\", -1, salt, 4, 5, 4, out);\\r\\nfprintf(stderr, \"Out %02X %02X %02X %02X\\n\",\\r\\nout[0], out[1], out[2], out[3]);\\r\\n}\\r\\nint PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *c, const EVP_MD *md,\\r\\nint en_de)\\r\\n{\\r\\nunsigned char *salt, key[EVP_MAX_KEY_LENGTH];\\r\\nconst unsigned char *pbuf;\\r\\nint saltlen, iter, plen;\\r\\nunsigned int keylen;\\r\\nPBE2PARAM *pbe2 = NULL;\\r\\nconst EVP_CIPHER *cipher;\\r\\nPBKDF2PARAM *kdf = NULL;\\r\\npbuf = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif(!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(OBJ_obj2nid(pbe2->keyfunc->algorithm) != NID_id_pbkdf2) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);\\r\\ngoto err;\\r\\n}\\r\\ncipher = EVP_get_cipherbyname(\\r\\nOBJ_nid2sn(OBJ_obj2nid(pbe2->encryption->algorithm)));\\r\\nif(!cipher) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de);\\r\\nif(EVP_CIPHER_asn1_to_param(ctx, pbe2->encryption->parameter) < 0) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_CIPHER_PARAMETER_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nOPENSSL_assert(keylen <= sizeof key);\\r\\npbuf = pbe2->keyfunc->parameter->value.sequence->data;\\r\\nplen = pbe2->keyfunc->parameter->value.sequence->length;\\r\\nif(!pbe2->keyfunc->parameter ||\\r\\n(pbe2->keyfunc->parameter->type != V_ASN1_SEQUENCE) ||\\r\\n!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nPBE2PARAM_free(pbe2);\\r\\npbe2 = NULL;\\r\\nif(kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != (int)keylen)){\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_KEYLENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif(kdf->prf && (OBJ_obj2nid(kdf->prf->algorithm) != NID_hmacWithSHA1)) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);\\r\\ngoto err;\\r\\n}\\r\\nif(kdf->salt->type != V_ASN1_OCTET_STRING) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_SALT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nsalt = kdf->salt->value.octet_string->data;\\r\\nsaltlen = kdf->salt->value.octet_string->length;\\r\\niter = ASN1_INTEGER_get(kdf->iter);\\r\\nPKCS5_PBKDF2_HMAC_SHA1(pass, passlen, salt, saltlen, iter, keylen, key);\\r\\nEVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);\\r\\nOPENSSL_cleanse(key, keylen);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn 1;\\r\\nerr:\\r\\nPBE2PARAM_free(pbe2);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void h__dump (const unsigned char *p, int len)\\r\\n{\\r\\nfor (; len --; p++) fprintf(stderr, \"%02X \", *p);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ui_lib_c", "target": 0, "func": "UI *UI_new(void)\\r\\n{\\r\\nreturn(UI_new_method(NULL));\\r\\n}\\r\\nUI *UI_new_method(const UI_METHOD *method)\\r\\n{\\r\\nUI *ret;\\r\\nret=(UI *)OPENSSL_malloc(sizeof(UI));\\r\\nif (ret == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (method == NULL)\\r\\nret->meth=UI_get_default_method();\\r\\nelse\\r\\nret->meth=method;\\r\\nret->strings=NULL;\\r\\nret->user_data=NULL;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void free_string(UI_STRING *uis)\\r\\n{\\r\\nif (uis->flags & OUT_STRING_FREEABLE)\\r\\n{\\r\\nOPENSSL_free((char *)uis->out_string);\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_BOOLEAN:\\r\\nOPENSSL_free((char *)uis->_.boolean_data.action_desc);\\r\\nOPENSSL_free((char *)uis->_.boolean_data.ok_chars);\\r\\nOPENSSL_free((char *)uis->_.boolean_data.cancel_chars);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(uis);\\r\\n}\\r\\nvoid UI_free(UI *ui)\\r\\n{\\r\\nif (ui == NULL)\\r\\nreturn;\\r\\nsk_UI_STRING_pop_free(ui->strings,free_string);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_UI, ui, &ui->ex_data);\\r\\nOPENSSL_free(ui);\\r\\n}\\r\\nstatic int allocate_string_stack(UI *ui)\\r\\n{\\r\\nif (ui->strings == NULL)\\r\\n{\\r\\nui->strings=sk_UI_STRING_new_null();\\r\\nif (ui->strings == NULL)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic UI_STRING *general_allocate_prompt(UI *ui, const char *prompt,\\r\\nint prompt_freeable, enum UI_string_types type, int input_flags,\\r\\nchar *result_buf)\\r\\n{\\r\\nUI_STRING *ret = NULL;\\r\\nif (prompt == NULL)\\r\\n{\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT,ERR_R_PASSED_NULL_PARAMETER);\\r\\n}\\r\\nelse if ((type == UIT_PROMPT || type == UIT_VERIFY\\r\\n|| type == UIT_BOOLEAN) && result_buf == NULL)\\r\\n{\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT,UI_R_NO_RESULT_BUFFER);\\r\\n}\\r\\nelse if ((ret = (UI_STRING *)OPENSSL_malloc(sizeof(UI_STRING))))\\r\\n{\\r\\nret->out_string=prompt;\\r\\nret->flags=prompt_freeable ? OUT_STRING_FREEABLE : 0;\\r\\nret->input_flags=input_flags;\\r\\nret->type=type;\\r\\nret->result_buf=result_buf;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int general_allocate_string(UI *ui, const char *prompt,\\r\\nint prompt_freeable, enum UI_string_types type, int input_flags,\\r\\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\\r\\n{\\r\\nint ret = -1;\\r\\nUI_STRING *s = general_allocate_prompt(ui, prompt, prompt_freeable,\\r\\ntype, input_flags, result_buf);\\r\\nif (s)\\r\\n{\\r\\nif (allocate_string_stack(ui) >= 0)\\r\\n{\\r\\ns->_.string_data.result_minsize=minsize;\\r\\ns->_.string_data.result_maxsize=maxsize;\\r\\ns->_.string_data.test_buf=test_buf;\\r\\nret=sk_UI_STRING_push(ui->strings, s);\\r\\nif (ret <= 0) ret--;\\r\\n}\\r\\nelse\\r\\nfree_string(s);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int general_allocate_boolean(UI *ui,\\r\\nconst char *prompt, const char *action_desc,\\r\\nconst char *ok_chars, const char *cancel_chars,\\r\\nint prompt_freeable, enum UI_string_types type, int input_flags,\\r\\nchar *result_buf)\\r\\n{\\r\\nint ret = -1;\\r\\nUI_STRING *s;\\r\\nconst char *p;\\r\\nif (ok_chars == NULL)\\r\\n{\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);\\r\\n}\\r\\nelse if (cancel_chars == NULL)\\r\\n{\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor(p = ok_chars; *p; p++)\\r\\n{\\r\\nif (strchr(cancel_chars, *p))\\r\\n{\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,\\r\\nUI_R_COMMON_OK_AND_CANCEL_CHARACTERS);\\r\\n}\\r\\n}\\r\\ns = general_allocate_prompt(ui, prompt, prompt_freeable,\\r\\ntype, input_flags, result_buf);\\r\\nif (s)\\r\\n{\\r\\nif (allocate_string_stack(ui) >= 0)\\r\\n{\\r\\ns->_.boolean_data.action_desc = action_desc;\\r\\ns->_.boolean_data.ok_chars = ok_chars;\\r\\ns->_.boolean_data.cancel_chars = cancel_chars;\\r\\nret=sk_UI_STRING_push(ui->strings, s);\\r\\nif (ret <= 0) ret--;\\r\\n}\\r\\nelse\\r\\nfree_string(s);\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint UI_add_input_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize)\\r\\n{\\r\\nreturn general_allocate_string(ui, prompt, 0,\\r\\nUIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);\\r\\n}\\r\\nint UI_dup_input_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize)\\r\\n{\\r\\nchar *prompt_copy=NULL;\\r\\nif (prompt)\\r\\n{\\r\\nprompt_copy=BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INPUT_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, prompt_copy, 1,\\r\\nUIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);\\r\\n}\\r\\nint UI_add_verify_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\\r\\n{\\r\\nreturn general_allocate_string(ui, prompt, 0,\\r\\nUIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);\\r\\n}\\r\\nint UI_dup_verify_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\\r\\n{\\r\\nchar *prompt_copy=NULL;\\r\\nif (prompt)\\r\\n{\\r\\nprompt_copy=BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_VERIFY_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, prompt_copy, 1,\\r\\nUIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);\\r\\n}\\r\\nint UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\\r\\nconst char *ok_chars, const char *cancel_chars,\\r\\nint flags, char *result_buf)\\r\\n{\\r\\nreturn general_allocate_boolean(ui, prompt, action_desc,\\r\\nok_chars, cancel_chars, 0, UIT_BOOLEAN, flags, result_buf);\\r\\n}\\r\\nint UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\\r\\nconst char *ok_chars, const char *cancel_chars,\\r\\nint flags, char *result_buf)\\r\\n{\\r\\nchar *prompt_copy = NULL;\\r\\nchar *action_desc_copy = NULL;\\r\\nchar *ok_chars_copy = NULL;\\r\\nchar *cancel_chars_copy = NULL;\\r\\nif (prompt)\\r\\n{\\r\\nprompt_copy=BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (action_desc)\\r\\n{\\r\\naction_desc_copy=BUF_strdup(action_desc);\\r\\nif (action_desc_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ok_chars)\\r\\n{\\r\\nok_chars_copy=BUF_strdup(ok_chars);\\r\\nif (ok_chars_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (cancel_chars)\\r\\n{\\r\\ncancel_chars_copy=BUF_strdup(cancel_chars);\\r\\nif (cancel_chars_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_boolean(ui, prompt_copy, action_desc_copy,\\r\\nok_chars_copy, cancel_chars_copy, 1, UIT_BOOLEAN, flags,\\r\\nresult_buf);\\r\\nerr:\\r\\nif (prompt_copy) OPENSSL_free(prompt_copy);\\r\\nif (action_desc_copy) OPENSSL_free(action_desc_copy);\\r\\nif (ok_chars_copy) OPENSSL_free(ok_chars_copy);\\r\\nif (cancel_chars_copy) OPENSSL_free(cancel_chars_copy);\\r\\nreturn -1;\\r\\n}\\r\\nint UI_add_info_string(UI *ui, const char *text)\\r\\n{\\r\\nreturn general_allocate_string(ui, text, 0, UIT_INFO, 0, NULL, 0, 0,\\r\\nNULL);\\r\\n}\\r\\nint UI_dup_info_string(UI *ui, const char *text)\\r\\n{\\r\\nchar *text_copy=NULL;\\r\\nif (text)\\r\\n{\\r\\ntext_copy=BUF_strdup(text);\\r\\nif (text_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_INFO_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, text_copy, 1, UIT_INFO, 0, NULL,\\r\\n0, 0, NULL);\\r\\n}\\r\\nint UI_add_error_string(UI *ui, const char *text)\\r\\n{\\r\\nreturn general_allocate_string(ui, text, 0, UIT_ERROR, 0, NULL, 0, 0,\\r\\nNULL);\\r\\n}\\r\\nint UI_dup_error_string(UI *ui, const char *text)\\r\\n{\\r\\nchar *text_copy=NULL;\\r\\nif (text)\\r\\n{\\r\\ntext_copy=BUF_strdup(text);\\r\\nif (text_copy == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_DUP_ERROR_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, text_copy, 1, UIT_ERROR, 0, NULL,\\r\\n0, 0, NULL);\\r\\n}\\r\\nchar *UI_construct_prompt(UI *ui, const char *object_desc,\\r\\nconst char *object_name)\\r\\n{\\r\\nchar *prompt = NULL;\\r\\nif (ui->meth->ui_construct_prompt)\\r\\nprompt = ui->meth->ui_construct_prompt(ui,\\r\\nobject_desc, object_name);\\r\\nelse\\r\\n{\\r\\nchar prompt1[] = \"Enter \";\\r\\nchar prompt2[] = \" for \";\\r\\nchar prompt3[] = \":\";\\r\\nint len = 0;\\r\\nif (object_desc == NULL)\\r\\nreturn NULL;\\r\\nlen = sizeof(prompt1) - 1 + strlen(object_desc);\\r\\nif (object_name)\\r\\nlen += sizeof(prompt2) - 1 + strlen(object_name);\\r\\nlen += sizeof(prompt3) - 1;\\r\\nprompt = (char *)OPENSSL_malloc(len + 1);\\r\\nBUF_strlcpy(prompt, prompt1, len + 1);\\r\\nBUF_strlcat(prompt, object_desc, len + 1);\\r\\nif (object_name)\\r\\n{\\r\\nBUF_strlcat(prompt, prompt2, len + 1);\\r\\nBUF_strlcat(prompt, object_name, len + 1);\\r\\n}\\r\\nBUF_strlcat(prompt, prompt3, len + 1);\\r\\n}\\r\\nreturn prompt;\\r\\n}\\r\\nvoid *UI_add_user_data(UI *ui, void *user_data)\\r\\n{\\r\\nvoid *old_data = ui->user_data;\\r\\nui->user_data = user_data;\\r\\nreturn old_data;\\r\\n}\\r\\nvoid *UI_get0_user_data(UI *ui)\\r\\n{\\r\\nreturn ui->user_data;\\r\\n}\\r\\nconst char *UI_get0_result(UI *ui, int i)\\r\\n{\\r\\nif (i < 0)\\r\\n{\\r\\nUIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_SMALL);\\r\\nreturn NULL;\\r\\n}\\r\\nif (i >= sk_UI_STRING_num(ui->strings))\\r\\n{\\r\\nUIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_LARGE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn UI_get0_result_string(sk_UI_STRING_value(ui->strings, i));\\r\\n}\\r\\nstatic int print_error(const char *str, size_t len, UI *ui)\\r\\n{\\r\\nUI_STRING uis;\\r\\nmemset(&uis, 0, sizeof(uis));\\r\\nuis.type = UIT_ERROR;\\r\\nuis.out_string = str;\\r\\nif (ui->meth->ui_write_string\\r\\n&& !ui->meth->ui_write_string(ui, &uis))\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nint UI_process(UI *ui)\\r\\n{\\r\\nint i, ok=0;\\r\\nif (ui->meth->ui_open_session && !ui->meth->ui_open_session(ui))\\r\\nreturn -1;\\r\\nif (ui->flags & UI_FLAG_PRINT_ERRORS)\\r\\nERR_print_errors_cb(\\r\\n(int (*)(const char *, size_t, void *))print_error,\\r\\n(void *)ui);\\r\\nfor(i=0; i<sk_UI_STRING_num(ui->strings); i++)\\r\\n{\\r\\nif (ui->meth->ui_write_string\\r\\n&& !ui->meth->ui_write_string(ui,\\r\\nsk_UI_STRING_value(ui->strings, i)))\\r\\n{\\r\\nok=-1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ui->meth->ui_flush)\\r\\nswitch(ui->meth->ui_flush(ui))\\r\\n{\\r\\ncase -1:\\r\\nok = -2;\\r\\ngoto err;\\r\\ncase 0:\\r\\nok = -1;\\r\\ngoto err;\\r\\ndefault:\\r\\nok = 0;\\r\\nbreak;\\r\\n}\\r\\nfor(i=0; i<sk_UI_STRING_num(ui->strings); i++)\\r\\n{\\r\\nif (ui->meth->ui_read_string)\\r\\n{\\r\\nswitch(ui->meth->ui_read_string(ui,\\r\\nsk_UI_STRING_value(ui->strings, i)))\\r\\n{\\r\\ncase -1:\\r\\nok = -2;\\r\\ngoto err;\\r\\ncase 0:\\r\\nok = -1;\\r\\ngoto err;\\r\\ndefault:\\r\\nok = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (ui->meth->ui_close_session && !ui->meth->ui_close_session(ui))\\r\\nreturn -1;\\r\\nreturn ok;\\r\\n}\\r\\nint UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nif (ui == NULL)\\r\\n{\\r\\nUIerr(UI_F_UI_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn -1;\\r\\n}\\r\\nswitch(cmd)\\r\\n{\\r\\ncase UI_CTRL_PRINT_ERRORS:\\r\\n{\\r\\nint save_flag = !!(ui->flags & UI_FLAG_PRINT_ERRORS);\\r\\nif (i)\\r\\nui->flags |= UI_FLAG_PRINT_ERRORS;\\r\\nelse\\r\\nui->flags &= ~UI_FLAG_PRINT_ERRORS;\\r\\nreturn save_flag;\\r\\n}\\r\\ncase UI_CTRL_IS_REDOABLE:\\r\\nreturn !!(ui->flags & UI_FLAG_REDOABLE);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nUIerr(UI_F_UI_CTRL,UI_R_UNKNOWN_CONTROL_COMMAND);\\r\\nreturn -1;\\r\\n}\\r\\nint UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint UI_set_ex_data(UI *r, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\\r\\n}\\r\\nvoid *UI_get_ex_data(UI *r, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\\r\\n}\\r\\nvoid UI_set_default_method(const UI_METHOD *meth)\\r\\n{\\r\\ndefault_UI_meth=meth;\\r\\n}\\r\\nconst UI_METHOD *UI_get_default_method(void)\\r\\n{\\r\\nif (default_UI_meth == NULL)\\r\\n{\\r\\ndefault_UI_meth=UI_OpenSSL();\\r\\n}\\r\\nreturn default_UI_meth;\\r\\n}\\r\\nconst UI_METHOD *UI_get_method(UI *ui)\\r\\n{\\r\\nreturn ui->meth;\\r\\n}\\r\\nconst UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth)\\r\\n{\\r\\nui->meth=meth;\\r\\nreturn ui->meth;\\r\\n}\\r\\nUI_METHOD *UI_create_method(char *name)\\r\\n{\\r\\nUI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));\\r\\nif (ui_method)\\r\\nmemset(ui_method, 0, sizeof(*ui_method));\\r\\nui_method->name = BUF_strdup(name);\\r\\nreturn ui_method;\\r\\n}\\r\\nvoid UI_destroy_method(UI_METHOD *ui_method)\\r\\n{\\r\\nOPENSSL_free(ui_method->name);\\r\\nui_method->name = NULL;\\r\\nOPENSSL_free(ui_method);\\r\\n}\\r\\nint UI_method_set_opener(UI_METHOD *method, int (*opener)(UI *ui))\\r\\n{\\r\\nif (method)\\r\\n{\\r\\nmethod->ui_open_session = opener;\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_writer(UI_METHOD *method, int (*writer)(UI *ui, UI_STRING *uis))\\r\\n{\\r\\nif (method)\\r\\n{\\r\\nmethod->ui_write_string = writer;\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_flusher(UI_METHOD *method, int (*flusher)(UI *ui))\\r\\n{\\r\\nif (method)\\r\\n{\\r\\nmethod->ui_flush = flusher;\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_reader(UI_METHOD *method, int (*reader)(UI *ui, UI_STRING *uis))\\r\\n{\\r\\nif (method)\\r\\n{\\r\\nmethod->ui_read_string = reader;\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_closer(UI_METHOD *method, int (*closer)(UI *ui))\\r\\n{\\r\\nif (method)\\r\\n{\\r\\nmethod->ui_close_session = closer;\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nenum UI_string_types UI_get_string_type(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn UIT_NONE;\\r\\nreturn uis->type;\\r\\n}\\r\\nint UI_get_input_flags(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn 0;\\r\\nreturn uis->input_flags;\\r\\n}\\r\\nconst char *UI_get0_output_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nreturn uis->out_string;\\r\\n}\\r\\nconst char *UI_get0_action_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_BOOLEAN:\\r\\nreturn uis->_.boolean_data.action_desc;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nconst char *UI_get0_result_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->result_buf;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nconst char *UI_get0_test_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.test_buf;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nint UI_get_result_minsize(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.result_minsize;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nint UI_get_result_maxsize(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch(uis->type)\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.result_maxsize;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nint UI_set_result(UI *ui, UI_STRING *uis, const char *result)\\r\\n{\\r\\nint l = strlen(result);\\r\\nui->flags &= ~UI_FLAG_REDOABLE;\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch (uis->type)\\r\\n{\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nchar number1[DECIMAL_SIZE(uis->_.string_data.result_minsize)+1];\\r\\nchar number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize)+1];\\r\\nBIO_snprintf(number1, sizeof(number1), \"%d\",\\r\\nuis->_.string_data.result_minsize);\\r\\nBIO_snprintf(number2, sizeof(number2), \"%d\",\\r\\nuis->_.string_data.result_maxsize);\\r\\nif (l < uis->_.string_data.result_minsize)\\r\\n{\\r\\nui->flags |= UI_FLAG_REDOABLE;\\r\\nUIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_SMALL);\\r\\nERR_add_error_data(5,\"You must type in \",\\r\\nnumber1,\" to \",number2,\" characters\");\\r\\nreturn -1;\\r\\n}\\r\\nif (l > uis->_.string_data.result_maxsize)\\r\\n{\\r\\nui->flags |= UI_FLAG_REDOABLE;\\r\\nUIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_LARGE);\\r\\nERR_add_error_data(5,\"You must type in \",\\r\\nnumber1,\" to \",number2,\" characters\");\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (!uis->result_buf)\\r\\n{\\r\\nUIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);\\r\\nreturn -1;\\r\\n}\\r\\nBUF_strlcpy(uis->result_buf, result,\\r\\nuis->_.string_data.result_maxsize + 1);\\r\\nbreak;\\r\\ncase UIT_BOOLEAN:\\r\\n{\\r\\nconst char *p;\\r\\nif (!uis->result_buf)\\r\\n{\\r\\nUIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);\\r\\nreturn -1;\\r\\n}\\r\\nuis->result_buf[0] = '\\0';\\r\\nfor(p = result; *p; p++)\\r\\n{\\r\\nif (strchr(uis->_.boolean_data.ok_chars, *p))\\r\\n{\\r\\nuis->result_buf[0] =\\r\\nuis->_.boolean_data.ok_chars[0];\\r\\nbreak;\\r\\n}\\r\\nif (strchr(uis->_.boolean_data.cancel_chars, *p))\\r\\n{\\r\\nuis->result_buf[0] =\\r\\nuis->_.boolean_data.cancel_chars[0];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s23_srvr_c", "target": 0, "func": "static SSL_METHOD *ssl23_get_server_method(int ver)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_server_method());\\r\\n#endif\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_server_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_server_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_server_data,\\r\\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\\r\\nSSLv23_server_data.ssl_accept=ssl23_accept;\\r\\nSSLv23_server_data.get_ssl_method=ssl23_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv23_server_data);\\r\\n}\\r\\nint ssl23_accept(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long Time=time(NULL);\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_accept++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A:\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl23_get_client_hello(s);\\r\\nif (ret >= 0) cb=NULL;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL23_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl23_get_client_hello(SSL *s)\\r\\n{\\r\\nchar buf_space[11];\\r\\nchar *buf= &(buf_space[0]);\\r\\nunsigned char *p,*d,*d_len,*dd;\\r\\nunsigned int i;\\r\\nunsigned int csl,sil,cl;\\r\\nint n=0,j;\\r\\nint type=0;\\r\\nint v[2];\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nint use_sslv2_strong=0;\\r\\n#endif\\r\\nif (s->state == SSL23_ST_SR_CLNT_HELLO_A)\\r\\n{\\r\\nv[0]=v[1]=0;\\r\\nif (!ssl3_setup_buffers(s)) goto err;\\r\\nn=ssl23_read_bytes(s, sizeof buf_space);\\r\\nif (n != sizeof buf_space) return(n);\\r\\np=s->packet;\\r\\nmemcpy(buf,p,n);\\r\\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\\r\\n{\\r\\nif ((p[3] == 0x00) && (p[4] == 0x02))\\r\\n{\\r\\nv[0]=p[3]; v[1]=p[4];\\r\\nif (!(s->options & SSL_OP_NO_SSLv2))\\r\\ntype=1;\\r\\n}\\r\\nelse if (p[3] == SSL3_VERSION_MAJOR)\\r\\n{\\r\\nv[0]=p[3]; v[1]=p[4];\\r\\nif (p[4] >= TLS1_VERSION_MINOR)\\r\\n{\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\n{\\r\\ntype=1;\\r\\n}\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\ntype=1;\\r\\n}\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n(p[5] == SSL3_MT_CLIENT_HELLO) &&\\r\\n((p[3] == 0 && p[4] < 5 )\\r\\n|| (p[9] == p[1])))\\r\\n{\\r\\nv[0]=p[1];\\r\\nif (p[3] == 0 && p[4] < 6)\\r\\n{\\r\\n#if 0\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\\r\\ngoto err;\\r\\n#else\\r\\nv[1] = TLS1_VERSION_MINOR;\\r\\n#endif\\r\\n}\\r\\nelse\\r\\nv[1]=p[10];\\r\\nif (v[1] >= TLS1_VERSION_MINOR)\\r\\n{\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ntype=3;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ntype=3;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ntype=3;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ntype=3;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\\r\\n(strncmp(\"POST \",(char *)p,5) == 0) ||\\r\\n(strncmp(\"HEAD \",(char *)p,5) == 0) ||\\r\\n(strncmp(\"PUT \", (char *)p,4) == 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nelse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\\r\\n{\\r\\ntype=2;\\r\\np=s->packet;\\r\\nv[0] = p[3];\\r\\nv[1] = p[4];\\r\\nn=((p[0]&0x7f)<<8)|p[1];\\r\\nif (n > (1024*4))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nj=ssl23_read_bytes(s,n+2);\\r\\nif (j <= 0) return(j);\\r\\nssl3_finish_mac(s, s->packet+2, s->packet_length-2);\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg);\\r\\np=s->packet;\\r\\np+=5;\\r\\nn2s(p,csl);\\r\\nn2s(p,sil);\\r\\nn2s(p,cl);\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\nif ((csl+sil+cl+11) != s->packet_length)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n*(d++) = SSL3_MT_CLIENT_HELLO;\\r\\nd_len = d;\\r\\nd += 3;\\r\\n*(d++) = SSL3_VERSION_MAJOR;\\r\\n*(d++) = v[1];\\r\\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\\r\\nmemset(d,0,SSL3_RANDOM_SIZE);\\r\\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\\r\\nd+=SSL3_RANDOM_SIZE;\\r\\n*(d++)=0;\\r\\nj=0;\\r\\ndd=d;\\r\\nd+=2;\\r\\nfor (i=0; i<csl; i+=3)\\r\\n{\\r\\nif (p[i] != 0) continue;\\r\\n*(d++)=p[i+1];\\r\\n*(d++)=p[i+2];\\r\\nj+=2;\\r\\n}\\r\\ns2n(j,dd);\\r\\n*(d++)=1;\\r\\n*(d++)=0;\\r\\ni = (d-(unsigned char *)s->init_buf->data) - 4;\\r\\nl2n3((long)i, d_len);\\r\\ns->s3->tmp.reuse_message=1;\\r\\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\\r\\ns->s3->tmp.message_size=i;\\r\\n}\\r\\nif (type == 1)\\r\\n{\\r\\n#ifdef OPENSSL_NO_SSL2\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n#else\\r\\nif (s->s2 == NULL)\\r\\n{\\r\\nif (!ssl2_new(s))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nssl2_clear(s);\\r\\nif (s->s3 != NULL) ssl3_free(s);\\r\\nif (!BUF_MEM_grow_clean(s->init_buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\\r\\nif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\\r\\nuse_sslv2_strong ||\\r\\n(s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3))\\r\\ns->s2->ssl2_rollback=0;\\r\\nelse\\r\\ns->s2->ssl2_rollback=1;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s2->rbuf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s2->rbuf_left=n;\\r\\ns->s2->rbuf_offs=0;\\r\\ns->method=SSLv2_server_method();\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\n#endif\\r\\n}\\r\\nif ((type == 2) || (type == 3))\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) goto err;\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\nif (type == 3)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s3->rbuf.left=n;\\r\\ns->s3->rbuf.offset=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->packet_length=0;\\r\\ns->s3->rbuf.left=0;\\r\\ns->s3->rbuf.offset=0;\\r\\n}\\r\\nif (s->version == TLS1_VERSION)\\r\\ns->method = TLSv1_server_method();\\r\\nelse\\r\\ns->method = SSLv3_server_method();\\r\\n#if 0\\r\\ns->client_version=(v[0]<<8)|v[1];\\r\\n#endif\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\n}\\r\\nif ((type < 1) || (type > 3))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (buf != buf_space) OPENSSL_free(buf);\\r\\ns->first_packet=1;\\r\\nreturn(SSL_accept(s));\\r\\nerr:\\r\\nif (buf != buf_space) OPENSSL_free(buf);\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_vfy_c", "target": 0, "func": "static int null_callback(int ok, X509_STORE_CTX *e)\\r\\n{\\r\\nreturn ok;\\r\\n}\\r\\nint X509_verify_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509 *x,*xtmp,*chain_ss=NULL;\\r\\nX509_NAME *xn;\\r\\nint bad_chain = 0;\\r\\nX509_VERIFY_PARAM *param = ctx->param;\\r\\nint depth,i,ok=0;\\r\\nint num;\\r\\nint (*cb)(int xok,X509_STORE_CTX *xctx);\\r\\nSTACK_OF(X509) *sktmp=NULL;\\r\\nif (ctx->cert == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\\r\\nreturn -1;\\r\\n}\\r\\ncb=ctx->verify_cb;\\r\\nif (ctx->chain == NULL)\\r\\n{\\r\\nif ( ((ctx->chain=sk_X509_new_null()) == NULL) ||\\r\\n(!sk_X509_push(ctx->chain,ctx->cert)))\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&ctx->cert->references,1,CRYPTO_LOCK_X509);\\r\\nctx->last_untrusted=1;\\r\\n}\\r\\nif (ctx->untrusted != NULL\\r\\n&& (sktmp=sk_X509_dup(ctx->untrusted)) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nnum=sk_X509_num(ctx->chain);\\r\\nx=sk_X509_value(ctx->chain,num-1);\\r\\ndepth=param->depth;\\r\\nfor (;;)\\r\\n{\\r\\nif (depth < num) break;\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (ctx->check_issued(ctx, x,x)) break;\\r\\nif (ctx->untrusted != NULL)\\r\\n{\\r\\nxtmp=find_issuer(ctx, sktmp,x);\\r\\nif (xtmp != NULL)\\r\\n{\\r\\nif (!sk_X509_push(ctx->chain,xtmp))\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&xtmp->references,1,CRYPTO_LOCK_X509);\\r\\nsk_X509_delete_ptr(sktmp,xtmp);\\r\\nctx->last_untrusted++;\\r\\nx=xtmp;\\r\\nnum++;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\ni=sk_X509_num(ctx->chain);\\r\\nx=sk_X509_value(ctx->chain,i-1);\\r\\nxn = X509_get_subject_name(x);\\r\\nif (ctx->check_issued(ctx, x, x))\\r\\n{\\r\\nif (sk_X509_num(ctx->chain) == 1)\\r\\n{\\r\\nok = ctx->get_issuer(&xtmp, ctx, x);\\r\\nif ((ok <= 0) || X509_cmp(x, xtmp))\\r\\n{\\r\\nctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\\r\\nctx->current_cert=x;\\r\\nctx->error_depth=i-1;\\r\\nif (ok == 1) X509_free(xtmp);\\r\\nbad_chain = 1;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509_free(x);\\r\\nx = xtmp;\\r\\nsk_X509_set(ctx->chain, i - 1, x);\\r\\nctx->last_untrusted=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nchain_ss=sk_X509_pop(ctx->chain);\\r\\nctx->last_untrusted--;\\r\\nnum--;\\r\\nx=sk_X509_value(ctx->chain,num-1);\\r\\n}\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nif (depth < num) break;\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (ctx->check_issued(ctx,x,x)) break;\\r\\nok = ctx->get_issuer(&xtmp, ctx, x);\\r\\nif (ok < 0) return ok;\\r\\nif (ok == 0) break;\\r\\nx = xtmp;\\r\\nif (!sk_X509_push(ctx->chain,x))\\r\\n{\\r\\nX509_free(xtmp);\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nnum++;\\r\\n}\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (!ctx->check_issued(ctx,x,x))\\r\\n{\\r\\nif ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss))\\r\\n{\\r\\nif (ctx->last_untrusted >= num)\\r\\nctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\\r\\nelse\\r\\nctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\\r\\nctx->current_cert=x;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsk_X509_push(ctx->chain,chain_ss);\\r\\nnum++;\\r\\nctx->last_untrusted=num;\\r\\nctx->current_cert=chain_ss;\\r\\nctx->error=X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\\r\\nchain_ss=NULL;\\r\\n}\\r\\nctx->error_depth=num-1;\\r\\nbad_chain = 1;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nok = check_chain_extensions(ctx);\\r\\nif (!ok) goto end;\\r\\nif (param->trust > 0) ok = check_trust(ctx);\\r\\nif (!ok) goto end;\\r\\nX509_get_pubkey_parameters(NULL,ctx->chain);\\r\\nok = ctx->check_revocation(ctx);\\r\\nif(!ok) goto end;\\r\\nif (ctx->verify != NULL)\\r\\nok=ctx->verify(ctx);\\r\\nelse\\r\\nok=internal_verify(ctx);\\r\\nif(!ok) goto end;\\r\\nif (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\\r\\nok = ctx->check_policy(ctx);\\r\\nif(!ok) goto end;\\r\\nif (0)\\r\\n{\\r\\nend:\\r\\nX509_get_pubkey_parameters(NULL,ctx->chain);\\r\\n}\\r\\nif (sktmp != NULL) sk_X509_free(sktmp);\\r\\nif (chain_ss != NULL) X509_free(chain_ss);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\\r\\n{\\r\\nint ret;\\r\\nret = X509_check_issued(issuer, x);\\r\\nif (ret == X509_V_OK)\\r\\nreturn 1;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))\\r\\nreturn 0;\\r\\nctx->error = ret;\\r\\nctx->current_cert = x;\\r\\nctx->current_issuer = issuer;\\r\\nreturn ctx->verify_cb(0, ctx);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\n*issuer = find_issuer(ctx, ctx->other_ctx, x);\\r\\nif (*issuer)\\r\\n{\\r\\nCRYPTO_add(&(*issuer)->references,1,CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_chain_extensions(X509_STORE_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_NO_CHAIN_VERIFY\\r\\nreturn 1;\\r\\n#else\\r\\nint i, ok=0, must_be_ca;\\r\\nX509 *x;\\r\\nint (*cb)(int xok,X509_STORE_CTX *xctx);\\r\\nint proxy_path_length = 0;\\r\\nint allow_proxy_certs =\\r\\n!!(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\\r\\ncb=ctx->verify_cb;\\r\\nmust_be_ca = -1;\\r\\nif (getenv(\"OPENSSL_ALLOW_PROXY_CERTS\"))\\r\\nallow_proxy_certs = 1;\\r\\nfor (i = 0; i < ctx->last_untrusted; i++)\\r\\n{\\r\\nint ret;\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\\r\\n&& (x->ex_flags & EXFLAG_CRITICAL))\\r\\n{\\r\\nctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY))\\r\\n{\\r\\nctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nret = X509_check_ca(x);\\r\\nswitch(must_be_ca)\\r\\n{\\r\\ncase -1:\\r\\nif ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1) && (ret != 0))\\r\\n{\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_CA;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\ncase 0:\\r\\nif (ret != 0)\\r\\n{\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_NON_CA;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nif ((ret == 0)\\r\\n|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1)))\\r\\n{\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_CA;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\n}\\r\\nif (ret == 0)\\r\\n{\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (ctx->param->purpose > 0)\\r\\n{\\r\\nret = X509_check_purpose(x, ctx->param->purpose,\\r\\nmust_be_ca > 0);\\r\\nif ((ret == 0)\\r\\n|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1)))\\r\\n{\\r\\nctx->error = X509_V_ERR_INVALID_PURPOSE;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\n}\\r\\nif ((i > 1) && (x->ex_pathlen != -1)\\r\\n&& (i > (x->ex_pathlen + proxy_path_length + 1)))\\r\\n{\\r\\nctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (x->ex_flags & EXFLAG_PROXY)\\r\\n{\\r\\nif (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen)\\r\\n{\\r\\nctx->error =\\r\\nX509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nproxy_path_length++;\\r\\nmust_be_ca = 0;\\r\\n}\\r\\nelse\\r\\nmust_be_ca = 1;\\r\\n}\\r\\nok = 1;\\r\\nend:\\r\\nreturn ok;\\r\\n#endif\\r\\n}\\r\\nstatic int check_trust(X509_STORE_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_NO_CHAIN_VERIFY\\r\\nreturn 1;\\r\\n#else\\r\\nint i, ok;\\r\\nX509 *x;\\r\\nint (*cb)(int xok,X509_STORE_CTX *xctx);\\r\\ncb=ctx->verify_cb;\\r\\ni = sk_X509_num(ctx->chain) - 1;\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nok = X509_check_trust(x, ctx->param->trust, 0);\\r\\nif (ok == X509_TRUST_TRUSTED)\\r\\nreturn 1;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nif (ok == X509_TRUST_REJECTED)\\r\\nctx->error = X509_V_ERR_CERT_REJECTED;\\r\\nelse\\r\\nctx->error = X509_V_ERR_CERT_UNTRUSTED;\\r\\nok = cb(0, ctx);\\r\\nreturn ok;\\r\\n#endif\\r\\n}\\r\\nstatic int check_revocation(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint i, last, ok;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))\\r\\nreturn 1;\\r\\nif (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)\\r\\nlast = sk_X509_num(ctx->chain) - 1;\\r\\nelse\\r\\nlast = 0;\\r\\nfor(i = 0; i <= last; i++)\\r\\n{\\r\\nctx->error_depth = i;\\r\\nok = check_cert(ctx);\\r\\nif (!ok) return ok;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_CRL *crl = NULL;\\r\\nX509 *x;\\r\\nint ok, cnum;\\r\\ncnum = ctx->error_depth;\\r\\nx = sk_X509_value(ctx->chain, cnum);\\r\\nctx->current_cert = x;\\r\\nok = ctx->get_crl(ctx, &crl, x);\\r\\nif(!ok)\\r\\n{\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\ngoto err;\\r\\n}\\r\\nctx->current_crl = crl;\\r\\nok = ctx->check_crl(ctx, crl);\\r\\nif (!ok) goto err;\\r\\nok = ctx->cert_crl(ctx, crl, x);\\r\\nerr:\\r\\nctx->current_crl = NULL;\\r\\nX509_CRL_free(crl);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)\\r\\n{\\r\\ntime_t *ptime;\\r\\nint i;\\r\\nctx->current_crl = crl;\\r\\nif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\\r\\nptime = &ctx->param->check_time;\\r\\nelse\\r\\nptime = NULL;\\r\\ni=X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\\r\\nif (!notify || !ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i > 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CRL_NOT_YET_VALID;\\r\\nif (!notify || !ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif(X509_CRL_get_nextUpdate(crl))\\r\\n{\\r\\ni=X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\\r\\nif (!notify || !ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CRL_HAS_EXPIRED;\\r\\nif (!notify || !ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nctx->current_crl = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int get_crl(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509 *x)\\r\\n{\\r\\nint ok;\\r\\nX509_CRL *crl = NULL;\\r\\nX509_OBJECT xobj;\\r\\nX509_NAME *nm;\\r\\nnm = X509_get_issuer_name(x);\\r\\nok = get_crl_sk(ctx, &crl, nm, ctx->crls);\\r\\nif (ok)\\r\\n{\\r\\n*pcrl = crl;\\r\\nreturn 1;\\r\\n}\\r\\nok = X509_STORE_get_by_subject(ctx, X509_LU_CRL, nm, &xobj);\\r\\nif (!ok)\\r\\n{\\r\\nif (crl)\\r\\n{\\r\\n*pcrl = crl;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\n*pcrl = xobj.data.crl;\\r\\nif (crl)\\r\\nX509_CRL_free(crl);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)\\r\\n{\\r\\nX509 *issuer = NULL;\\r\\nEVP_PKEY *ikey = NULL;\\r\\nint ok = 0, chnum, cnum;\\r\\ncnum = ctx->error_depth;\\r\\nchnum = sk_X509_num(ctx->chain) - 1;\\r\\nif(cnum < chnum)\\r\\nissuer = sk_X509_value(ctx->chain, cnum + 1);\\r\\nelse\\r\\n{\\r\\nissuer = sk_X509_value(ctx->chain, chnum);\\r\\nif(!ctx->check_issued(ctx, issuer, issuer))\\r\\n{\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif(!ok) goto err;\\r\\n}\\r\\n}\\r\\nif(issuer)\\r\\n{\\r\\nif ((issuer->ex_flags & EXFLAG_KUSAGE) &&\\r\\n!(issuer->ex_kusage & KU_CRL_SIGN))\\r\\n{\\r\\nctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif(!ok) goto err;\\r\\n}\\r\\nikey = X509_get_pubkey(issuer);\\r\\nif(!ikey)\\r\\n{\\r\\nctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif(X509_CRL_verify(crl, ikey) <= 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CRL_SIGNATURE_FAILURE;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nok = check_crl_time(ctx, crl, 1);\\r\\nif (!ok)\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nEVP_PKEY_free(ikey);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)\\r\\n{\\r\\nint idx, ok;\\r\\nX509_REVOKED rtmp;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nX509_EXTENSION *ext;\\r\\nrtmp.serialNumber = X509_get_serialNumber(x);\\r\\nif (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);\\r\\nsk_X509_REVOKED_sort(crl->crl->revoked);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);\\r\\n}\\r\\nidx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);\\r\\nif(idx >= 0)\\r\\n{\\r\\nctx->error = X509_V_ERR_CERT_REVOKED;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok) return 0;\\r\\n}\\r\\nif (ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\\r\\nreturn 1;\\r\\nexts = crl->crl->extensions;\\r\\nfor (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)\\r\\n{\\r\\next = sk_X509_EXTENSION_value(exts, idx);\\r\\nif (ext->critical > 0)\\r\\n{\\r\\nctx->error =\\r\\nX509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif(!ok) return 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_policy(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\\r\\nctx->param->policies, ctx->param->flags);\\r\\nif (ret == 0)\\r\\n{\\r\\nX509err(X509_F_CHECK_POLICY,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (ret == -1)\\r\\n{\\r\\nX509 *x;\\r\\nint i;\\r\\nfor (i = 1; i < sk_X509_num(ctx->chain); i++)\\r\\n{\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\\r\\ncontinue;\\r\\nctx->current_cert = x;\\r\\nctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\\r\\nret = ctx->verify_cb(0, ctx);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nif (ret == -2)\\r\\n{\\r\\nctx->current_cert = NULL;\\r\\nctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\\r\\nreturn ctx->verify_cb(0, ctx);\\r\\n}\\r\\nif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY)\\r\\n{\\r\\nctx->current_cert = NULL;\\r\\nctx->error = X509_V_OK;\\r\\nif (!ctx->verify_cb(2, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_cert_time(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\ntime_t *ptime;\\r\\nint i;\\r\\nif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\\r\\nptime = &ctx->param->check_time;\\r\\nelse\\r\\nptime = NULL;\\r\\ni=X509_cmp_time(X509_get_notBefore(x), ptime);\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\\r\\nctx->current_cert=x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i > 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CERT_NOT_YET_VALID;\\r\\nctx->current_cert=x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\ni=X509_cmp_time(X509_get_notAfter(x), ptime);\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\\r\\nctx->current_cert=x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CERT_HAS_EXPIRED;\\r\\nctx->current_cert=x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int internal_verify(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint ok=0,n;\\r\\nX509 *xs,*xi;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint (*cb)(int xok,X509_STORE_CTX *xctx);\\r\\ncb=ctx->verify_cb;\\r\\nn=sk_X509_num(ctx->chain);\\r\\nctx->error_depth=n-1;\\r\\nn--;\\r\\nxi=sk_X509_value(ctx->chain,n);\\r\\nif (ctx->check_issued(ctx, xi, xi))\\r\\nxs=xi;\\r\\nelse\\r\\n{\\r\\nif (n <= 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\\r\\nctx->current_cert=xi;\\r\\nok=cb(0,ctx);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nn--;\\r\\nctx->error_depth=n;\\r\\nxs=sk_X509_value(ctx->chain,n);\\r\\n}\\r\\n}\\r\\nwhile (n >= 0)\\r\\n{\\r\\nctx->error_depth=n;\\r\\nif (!xs->valid)\\r\\n{\\r\\nif ((pkey=X509_get_pubkey(xi)) == NULL)\\r\\n{\\r\\nctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\\r\\nctx->current_cert=xi;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nelse if (X509_verify(xs,pkey) <= 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok)\\r\\n{\\r\\nEVP_PKEY_free(pkey);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\npkey=NULL;\\r\\n}\\r\\nxs->valid = 1;\\r\\nok = check_cert_time(ctx, xs);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nctx->current_issuer=xi;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(1,ctx);\\r\\nif (!ok) goto end;\\r\\nn--;\\r\\nif (n >= 0)\\r\\n{\\r\\nxi=xs;\\r\\nxs=sk_X509_value(ctx->chain,n);\\r\\n}\\r\\n}\\r\\nok=1;\\r\\nend:\\r\\nreturn ok;\\r\\n}\\r\\nint X509_cmp_current_time(ASN1_TIME *ctm)\\r\\n{\\r\\nreturn X509_cmp_time(ctm, NULL);\\r\\n}\\r\\nint X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)\\r\\n{\\r\\nchar *str;\\r\\nASN1_TIME atm;\\r\\nlong offset;\\r\\nchar buff1[24],buff2[24],*p;\\r\\nint i,j;\\r\\np=buff1;\\r\\ni=ctm->length;\\r\\nstr=(char *)ctm->data;\\r\\nif (ctm->type == V_ASN1_UTCTIME)\\r\\n{\\r\\nif ((i < 11) || (i > 17)) return 0;\\r\\nmemcpy(p,str,10);\\r\\np+=10;\\r\\nstr+=10;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (i < 13) return 0;\\r\\nmemcpy(p,str,12);\\r\\np+=12;\\r\\nstr+=12;\\r\\n}\\r\\nif ((*str == 'Z') || (*str == '-') || (*str == '+'))\\r\\n{ *(p++)='0'; *(p++)='0'; }\\r\\nelse\\r\\n{\\r\\n*(p++)= *(str++);\\r\\n*(p++)= *(str++);\\r\\nif (*str == '.')\\r\\n{\\r\\nstr++;\\r\\nwhile ((*str >= '0') && (*str <= '9')) str++;\\r\\n}\\r\\n}\\r\\n*(p++)='Z';\\r\\n*(p++)='\\0';\\r\\nif (*str == 'Z')\\r\\noffset=0;\\r\\nelse\\r\\n{\\r\\nif ((*str != '+') && (*str != '-'))\\r\\nreturn 0;\\r\\noffset=((str[1]-'0')*10+(str[2]-'0'))*60;\\r\\noffset+=(str[3]-'0')*10+(str[4]-'0');\\r\\nif (*str == '-')\\r\\noffset= -offset;\\r\\n}\\r\\natm.type=ctm->type;\\r\\natm.length=sizeof(buff2);\\r\\natm.data=(unsigned char *)buff2;\\r\\nif (X509_time_adj(&atm,-offset*60, cmp_time) == NULL)\\r\\nreturn 0;\\r\\nif (ctm->type == V_ASN1_UTCTIME)\\r\\n{\\r\\ni=(buff1[0]-'0')*10+(buff1[1]-'0');\\r\\nif (i < 50) i+=100;\\r\\nj=(buff2[0]-'0')*10+(buff2[1]-'0');\\r\\nif (j < 50) j+=100;\\r\\nif (i < j) return -1;\\r\\nif (i > j) return 1;\\r\\n}\\r\\ni=strcmp(buff1,buff2);\\r\\nif (i == 0)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn i;\\r\\n}\\r\\nASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj)\\r\\n{\\r\\nreturn X509_time_adj(s, adj, NULL);\\r\\n}\\r\\nASN1_TIME *X509_time_adj(ASN1_TIME *s, long adj, time_t *in_tm)\\r\\n{\\r\\ntime_t t;\\r\\nint type = -1;\\r\\nif (in_tm) t = *in_tm;\\r\\nelse time(&t);\\r\\nt+=adj;\\r\\nif (s) type = s->type;\\r\\nif (type == V_ASN1_UTCTIME) return ASN1_UTCTIME_set(s,t);\\r\\nif (type == V_ASN1_GENERALIZEDTIME) return ASN1_GENERALIZEDTIME_set(s, t);\\r\\nreturn ASN1_TIME_set(s, t);\\r\\n}\\r\\nint X509_STORE_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\\r\\n{\\r\\nreturn CRYPTO_set_ex_data(&ctx->ex_data,idx,data);\\r\\n}\\r\\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)\\r\\n{\\r\\nreturn CRYPTO_get_ex_data(&ctx->ex_data,idx);\\r\\n}\\r\\nint X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->error;\\r\\n}\\r\\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)\\r\\n{\\r\\nctx->error=err;\\r\\n}\\r\\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->error_depth;\\r\\n}\\r\\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->current_cert;\\r\\n}\\r\\nint X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)\\r\\n{\\r\\nreturn X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);\\r\\n}\\r\\nint X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)\\r\\n{\\r\\nreturn X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);\\r\\n}\\r\\nint X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\\r\\nint purpose, int trust)\\r\\n{\\r\\nint idx;\\r\\nif (!purpose) purpose = def_purpose;\\r\\nif (purpose)\\r\\n{\\r\\nX509_PURPOSE *ptmp;\\r\\nidx = X509_PURPOSE_get_by_id(purpose);\\r\\nif (idx == -1)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_PURPOSE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nptmp = X509_PURPOSE_get0(idx);\\r\\nif (ptmp->trust == X509_TRUST_DEFAULT)\\r\\n{\\r\\nidx = X509_PURPOSE_get_by_id(def_purpose);\\r\\nif (idx == -1)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_PURPOSE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nptmp = X509_PURPOSE_get0(idx);\\r\\n}\\r\\nif (!trust) trust = ptmp->trust;\\r\\n}\\r\\nif (trust)\\r\\n{\\r\\nidx = X509_TRUST_get_by_id(trust);\\r\\nif (idx == -1)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_TRUST_ID);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (purpose && !ctx->param->purpose) ctx->param->purpose = purpose;\\r\\nif (trust && !ctx->param->trust) ctx->param->trust = trust;\\r\\nreturn 1;\\r\\n}\\r\\nX509_STORE_CTX *X509_STORE_CTX_new(void)\\r\\n{\\r\\nX509_STORE_CTX *ctx;\\r\\nctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));\\r\\nif (!ctx)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_CTX_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ctx, 0, sizeof(X509_STORE_CTX));\\r\\nreturn ctx;\\r\\n}\\r\\nvoid X509_STORE_CTX_free(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\\r\\n{\\r\\nif (ctx->cleanup) ctx->cleanup(ctx);\\r\\nX509_VERIFY_PARAM_free(ctx->param);\\r\\nif (ctx->tree)\\r\\nX509_policy_tree_free(ctx->tree);\\r\\nif (ctx->chain != NULL)\\r\\n{\\r\\nsk_X509_pop_free(ctx->chain,X509_free);\\r\\nctx->chain=NULL;\\r\\n}\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\\r\\nmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\\r\\n}\\r\\nvoid X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_flags(ctx->param, flags);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags, time_t t)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_time(ctx->param, t);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\\r\\nint (*verify_cb)(int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_cb=verify_cb;\\r\\n}\\r\\nX509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->tree;\\r\\n}\\r\\nint X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->explicit_policy;\\r\\n}\\r\\nint X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)\\r\\n{\\r\\nconst X509_VERIFY_PARAM *param;\\r\\nparam = X509_VERIFY_PARAM_lookup(name);\\r\\nif (!param)\\r\\nreturn 0;\\r\\nreturn X509_VERIFY_PARAM_inherit(ctx->param, param);\\r\\n}\\r\\nX509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->param;\\r\\n}\\r\\nvoid X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)\\r\\n{\\r\\nif (ctx->param)\\r\\nX509_VERIFY_PARAM_free(ctx->param);\\r\\nctx->param = param;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2ofb64_c", "target": 0, "func": "void RC2_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC2_KEY *schedule, unsigned char *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_set_key_c", "target": 0, "func": "void DES_set_odd_parity(DES_cblock *key)\\r\\n{\\r\\nunsigned int i;\\r\\nfor (i=0; i<DES_KEY_SZ; i++)\\r\\n(*key)[i]=odd_parity[(*key)[i]];\\r\\n}\\r\\nint DES_check_key_parity(const_DES_cblock *key)\\r\\n{\\r\\nunsigned int i;\\r\\nfor (i=0; i<DES_KEY_SZ; i++)\\r\\n{\\r\\nif ((*key)[i] != odd_parity[(*key)[i]])\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint DES_is_weak_key(const_DES_cblock *key)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<NUM_WEAK_KEY; i++)\\r\\nif (memcmp(weak_keys[i],key,sizeof(DES_cblock)) == 0) return(1);\\r\\nreturn(0);\\r\\n}\\r\\nint DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nif (DES_check_key)\\r\\n{\\r\\nreturn DES_set_key_checked(key, schedule);\\r\\n}\\r\\nelse\\r\\n{\\r\\nDES_set_key_unchecked(key, schedule);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nif (!DES_check_key_parity(key))\\r\\nreturn(-1);\\r\\nif (DES_is_weak_key(key))\\r\\nreturn(-2);\\r\\nDES_set_key_unchecked(key, schedule);\\r\\nreturn 0;\\r\\n}\\r\\nvoid DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nstatic int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};\\r\\nregister DES_LONG c,d,t,s,t2;\\r\\nregister const unsigned char *in;\\r\\nregister DES_LONG *k;\\r\\nregister int i;\\r\\n#ifdef OPENBSD_DEV_CRYPTO\\r\\nmemcpy(schedule->key,key,sizeof schedule->key);\\r\\nschedule->session=NULL;\\r\\n#endif\\r\\nk = &schedule->ks->deslong[0];\\r\\nin = &(*key)[0];\\r\\nc2l(in,c);\\r\\nc2l(in,d);\\r\\nPERM_OP (d,c,t,4,0x0f0f0f0fL);\\r\\nHPERM_OP(c,t,-2,0xcccc0000L);\\r\\nHPERM_OP(d,t,-2,0xcccc0000L);\\r\\nPERM_OP (d,c,t,1,0x55555555L);\\r\\nPERM_OP (c,d,t,8,0x00ff00ffL);\\r\\nPERM_OP (d,c,t,1,0x55555555L);\\r\\nd= (((d&0x000000ffL)<<16L)| (d&0x0000ff00L) |\\r\\n((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));\\r\\nc&=0x0fffffffL;\\r\\nfor (i=0; i<ITERATIONS; i++)\\r\\n{\\r\\nif (shifts2[i])\\r\\n{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }\\r\\nelse\\r\\n{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }\\r\\nc&=0x0fffffffL;\\r\\nd&=0x0fffffffL;\\r\\ns= des_skb[0][ (c )&0x3f ]|\\r\\ndes_skb[1][((c>> 6L)&0x03)|((c>> 7L)&0x3c)]|\\r\\ndes_skb[2][((c>>13L)&0x0f)|((c>>14L)&0x30)]|\\r\\ndes_skb[3][((c>>20L)&0x01)|((c>>21L)&0x06) |\\r\\n((c>>22L)&0x38)];\\r\\nt= des_skb[4][ (d )&0x3f ]|\\r\\ndes_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|\\r\\ndes_skb[6][ (d>>15L)&0x3f ]|\\r\\ndes_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];\\r\\nt2=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;\\r\\n*(k++)=ROTATE(t2,30)&0xffffffffL;\\r\\nt2=((s>>16L)|(t&0xffff0000L));\\r\\n*(k++)=ROTATE(t2,26)&0xffffffffL;\\r\\n}\\r\\n}\\r\\nint DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nreturn(DES_set_key(key,schedule));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecs_sign_c", "target": 0, "func": "ECDSA_SIG *ECDSA_do_sign(const unsigned char *dgst, int dlen, EC_KEY *eckey)\\r\\n{\\r\\nreturn ECDSA_do_sign_ex(dgst, dlen, NULL, NULL, eckey);\\r\\n}\\r\\nECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dlen,\\r\\nconst BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey)\\r\\n{\\r\\nECDSA_DATA *ecdsa = ecdsa_check(eckey);\\r\\nif (ecdsa == NULL)\\r\\nreturn NULL;\\r\\nreturn ecdsa->meth->ecdsa_do_sign(dgst, dlen, NULL, NULL, eckey);\\r\\n}\\r\\nint ECDSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char\\r\\n*sig, unsigned int *siglen, EC_KEY *eckey)\\r\\n{\\r\\nreturn ECDSA_sign_ex(type, dgst, dlen, sig, siglen, NULL, NULL, eckey);\\r\\n}\\r\\nint ECDSA_sign_ex(int type, const unsigned char *dgst, int dlen, unsigned char\\r\\n*sig, unsigned int *siglen, const BIGNUM *kinv, const BIGNUM *r,\\r\\nEC_KEY *eckey)\\r\\n{\\r\\nECDSA_SIG *s;\\r\\ns = ECDSA_do_sign_ex(dgst, dlen, kinv, r, eckey);\\r\\nif (s == NULL)\\r\\n{\\r\\n*siglen=0;\\r\\nreturn 0;\\r\\n}\\r\\n*siglen = i2d_ECDSA_SIG(s, &sig);\\r\\nECDSA_SIG_free(s);\\r\\nreturn 1;\\r\\n}\\r\\nint ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,\\r\\nBIGNUM **rp)\\r\\n{\\r\\nECDSA_DATA *ecdsa = ecdsa_check(eckey);\\r\\nif (ecdsa == NULL)\\r\\nreturn 0;\\r\\nreturn ecdsa->meth->ecdsa_sign_setup(eckey, ctx_in, kinvp, rp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_err_c", "target": 0, "func": "void ERR_load_BIO_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,BIO_str_functs);\\r\\nERR_load_strings(0,BIO_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_str_mem_c", "target": 0, "func": "const STORE_METHOD *STORE_Memory(void)\\r\\n{\\r\\nreturn &store_memory;\\r\\n}\\r\\nstatic int mem_init(STORE *s)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic void mem_clean(STORE *s)\\r\\n{\\r\\nreturn;\\r\\n}\\r\\nstatic STORE_OBJECT *mem_generate(STORE *s, STORE_OBJECT_TYPES type,\\r\\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_GENERATE, STORE_R_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic STORE_OBJECT *mem_get(STORE *s, STORE_OBJECT_TYPES type,\\r\\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\nvoid *context = mem_list_start(s, type, attributes, parameters);\\r\\nif (context)\\r\\n{\\r\\nSTORE_OBJECT *object = mem_list_next(s, context);\\r\\nif (mem_list_end(s, context))\\r\\nreturn object;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int mem_store(STORE *s, STORE_OBJECT_TYPES type,\\r\\nSTORE_OBJECT *data, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_STORE, STORE_R_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int mem_modify(STORE *s, STORE_OBJECT_TYPES type,\\r\\nOPENSSL_ITEM search_attributes[], OPENSSL_ITEM add_attributes[],\\r\\nOPENSSL_ITEM modify_attributes[], OPENSSL_ITEM delete_attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_MODIFY, STORE_R_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int mem_delete(STORE *s, STORE_OBJECT_TYPES type,\\r\\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_DELETE, STORE_R_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void *mem_list_start(STORE *s, STORE_OBJECT_TYPES type,\\r\\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\\r\\n{\\r\\nstruct mem_ctx_st *context =\\r\\n(struct mem_ctx_st *)OPENSSL_malloc(sizeof(struct mem_ctx_st));\\r\\nvoid *attribute_context = NULL;\\r\\nSTORE_ATTR_INFO *attrs = NULL;\\r\\nif (!context)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_START, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemset(context, 0, sizeof(struct mem_ctx_st));\\r\\nattribute_context = STORE_parse_attrs_start(attributes);\\r\\nif (!attribute_context)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_START, ERR_R_STORE_LIB);\\r\\ngoto err;\\r\\n}\\r\\nwhile((attrs = STORE_parse_attrs_next(attribute_context)))\\r\\n{\\r\\nif (context->search_attributes == NULL)\\r\\n{\\r\\ncontext->search_attributes =\\r\\nsk_new((int (*)(const char * const *, const char * const *))STORE_ATTR_INFO_compare);\\r\\nif (!context->search_attributes)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_START,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nsk_push(context->search_attributes,(char *)attrs);\\r\\n}\\r\\nif (!STORE_parse_attrs_endp(attribute_context))\\r\\ngoto err;\\r\\nSTORE_parse_attrs_end(attribute_context);\\r\\ncontext->search_index = -1;\\r\\ncontext->index = -1;\\r\\nreturn context;\\r\\nerr:\\r\\nif (attribute_context) STORE_parse_attrs_end(attribute_context);\\r\\nmem_list_end(s, context);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic STORE_OBJECT *mem_list_next(STORE *s, void *handle)\\r\\n{\\r\\nint i;\\r\\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\\r\\nstruct mem_object_data_st key = { 0, 0, 1 };\\r\\nstruct mem_data_st *store =\\r\\n(struct mem_data_st *)STORE_get_ex_data(s, 1);\\r\\nint srch;\\r\\nint cres = 0;\\r\\nif (!context)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_NEXT, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!store)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_NEXT, STORE_R_NO_STORE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (context->search_index == -1)\\r\\n{\\r\\nfor (i = 0; i < sk_num(context->search_attributes); i++)\\r\\n{\\r\\nkey.attr_info =\\r\\n(STORE_ATTR_INFO *)sk_value(context->search_attributes, i);\\r\\nsrch = sk_find_ex(store->data, (char *)&key);\\r\\nif (srch >= 0)\\r\\n{\\r\\ncontext->search_index = srch;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (context->search_index < 0)\\r\\nreturn NULL;\\r\\nkey.attr_info =\\r\\n(STORE_ATTR_INFO *)sk_value(context->search_attributes,\\r\\ncontext->search_index);\\r\\nfor(srch = context->search_index;\\r\\nsrch < sk_num(store->data)\\r\\n&& STORE_ATTR_INFO_in_range(key.attr_info,\\r\\n(STORE_ATTR_INFO *)sk_value(store->data, srch))\\r\\n&& !(cres = STORE_ATTR_INFO_in_ex(key.attr_info,\\r\\n(STORE_ATTR_INFO *)sk_value(store->data, srch)));\\r\\nsrch++)\\r\\n;\\r\\ncontext->search_index = srch;\\r\\nif (cres)\\r\\nreturn ((struct mem_object_data_st *)sk_value(store->data,\\r\\nsrch))->object;\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int mem_list_end(STORE *s, void *handle)\\r\\n{\\r\\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\\r\\nif (!context)\\r\\n{\\r\\nSTOREerr(STORE_F_MEM_LIST_END, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (context && context->search_attributes)\\r\\nsk_free(context->search_attributes);\\r\\nif (context) OPENSSL_free(context);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int mem_list_endp(STORE *s, void *handle)\\r\\n{\\r\\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\\r\\nif (!context\\r\\n|| context->search_index == sk_num(context->search_attributes))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int mem_lock(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int mem_unlock(STORE *s, OPENSSL_ITEM attributes[],\\r\\nOPENSSL_ITEM parameters[])\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int mem_ctrl(STORE *s, int cmd, long l, void *p, void (*f)(void))\\r\\n{\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_req_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nDSA *dsa_params=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nEC_KEY *ec_params = NULL;\\r\\n#endif\\r\\nunsigned long nmflag = 0, reqflag = 0;\\r\\nint ex=1,x509=0,days=30;\\r\\nX509 *x509ss=NULL;\\r\\nX509_REQ *req=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i=0,badops=0,newreq=0,verbose=0,pkey_type=TYPE_RSA;\\r\\nlong newkey = -1;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,verify=0,noout=0,text=0,keyform=FORMAT_PEM;\\r\\nint nodes=0,kludge=0,newhdr=0,subject=0,pubkey=0;\\r\\nchar *infile,*outfile,*prog,*keyfile=NULL,*template=NULL,*keyout=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nchar *extensions = NULL;\\r\\nchar *req_exts = NULL;\\r\\nconst EVP_CIPHER *cipher=NULL;\\r\\nASN1_INTEGER *serial = NULL;\\r\\nint modulus=0;\\r\\nchar *inrand=NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nchar *p;\\r\\nchar *subj = NULL;\\r\\nint multirdn = 0;\\r\\nconst EVP_MD *md_alg=NULL,*digest=EVP_sha1();\\r\\nunsigned long chtype = MBSTRING_ASC;\\r\\n#ifndef MONOLITH\\r\\nchar *to_free;\\r\\nlong errline;\\r\\n#endif\\r\\nreq_conf = NULL;\\r\\n#ifndef OPENSSL_NO_DES\\r\\ncipher=EVP_des_ede3_cbc();\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-pubkey\") == 0)\\r\\n{\\r\\npubkey=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-new\") == 0)\\r\\n{\\r\\nnewreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-config\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ntemplate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyform=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyout= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-newkey\") == 0)\\r\\n{\\r\\nint is_numeric;\\r\\nif (--argc < 1) goto bad;\\r\\np= *(++argv);\\r\\nis_numeric = p[0] >= '0' && p[0] <= '9';\\r\\nif (strncmp(\"rsa:\",p,4) == 0 || is_numeric)\\r\\n{\\r\\npkey_type=TYPE_RSA;\\r\\nif(!is_numeric)\\r\\np+=4;\\r\\nnewkey= atoi(p);\\r\\n}\\r\\nelse\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (strncmp(\"dsa:\",p,4) == 0)\\r\\n{\\r\\nX509 *xtmp=NULL;\\r\\nEVP_PKEY *dtmp;\\r\\npkey_type=TYPE_DSA;\\r\\np+=4;\\r\\nif ((in=BIO_new_file(p,\"r\")) == NULL)\\r\\n{\\r\\nperror(p);\\r\\ngoto end;\\r\\n}\\r\\nif ((dsa_params=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\n(void)BIO_reset(in);\\r\\nif ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameters from file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((dtmp=X509_get_pubkey(xtmp)) == NULL) goto end;\\r\\nif (dtmp->type == EVP_PKEY_DSA)\\r\\ndsa_params=DSAparams_dup(dtmp->pkey.dsa);\\r\\nEVP_PKEY_free(dtmp);\\r\\nX509_free(xtmp);\\r\\nif (dsa_params == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Certificate does not contain DSA parameters\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_free(in);\\r\\nin=NULL;\\r\\nnewkey=BN_num_bits(dsa_params->p);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (strncmp(\"ec:\",p,3) == 0)\\r\\n{\\r\\nX509 *xtmp=NULL;\\r\\nEVP_PKEY *dtmp;\\r\\nEC_GROUP *group;\\r\\npkey_type=TYPE_EC;\\r\\np+=3;\\r\\nif ((in=BIO_new_file(p,\"r\")) == NULL)\\r\\n{\\r\\nperror(p);\\r\\ngoto end;\\r\\n}\\r\\nif ((ec_params = EC_KEY_new()) == NULL)\\r\\ngoto end;\\r\\ngroup = PEM_read_bio_ECPKParameters(in, NULL, NULL, NULL);\\r\\nif (group == NULL)\\r\\n{\\r\\nEC_KEY_free(ec_params);\\r\\nERR_clear_error();\\r\\n(void)BIO_reset(in);\\r\\nif ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load EC parameters from file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((dtmp=X509_get_pubkey(xtmp))==NULL)\\r\\ngoto end;\\r\\nif (dtmp->type == EVP_PKEY_EC)\\r\\nec_params = EC_KEY_dup(dtmp->pkey.ec);\\r\\nEVP_PKEY_free(dtmp);\\r\\nX509_free(xtmp);\\r\\nif (ec_params == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Certificate does not contain EC parameters\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (EC_KEY_set_group(ec_params, group) == 0)\\r\\ngoto end;\\r\\nEC_GROUP_free(group);\\r\\n}\\r\\nBIO_free(in);\\r\\nin=NULL;\\r\\nnewkey = EC_GROUP_get_degree(EC_KEY_get0_group(ec_params));\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (strncmp(\"dh:\",p,4) == 0)\\r\\n{\\r\\npkey_type=TYPE_DH;\\r\\np+=3;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\ngoto bad;\\r\\n}\\r\\nnewreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-batch\") == 0)\\r\\nbatch=1;\\r\\nelse if (strcmp(*argv,\"-newhdr\") == 0)\\r\\nnewhdr=1;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\nverify=1;\\r\\nelse if (strcmp(*argv,\"-nodes\") == 0)\\r\\nnodes=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-verbose\") == 0)\\r\\nverbose=1;\\r\\nelse if (strcmp(*argv,\"-utf8\") == 0)\\r\\nchtype = MBSTRING_UTF8;\\r\\nelse if (strcmp(*argv,\"-nameopt\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv))) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-reqopt\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!set_cert_ex(&reqflag, *(++argv))) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-subject\") == 0)\\r\\nsubject=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-x509\") == 0)\\r\\nx509=1;\\r\\nelse if (strcmp(*argv,\"-asn1-kludge\") == 0)\\r\\nkludge=1;\\r\\nelse if (strcmp(*argv,\"-no-asn1-kludge\") == 0)\\r\\nkludge=0;\\r\\nelse if (strcmp(*argv,\"-subj\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsubj= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-multivalue-rdn\") == 0)\\r\\nmultirdn=1;\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays= atoi(*(++argv));\\r\\nif (days == 0) days=30;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-set_serial\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nserial = s2i_ASN1_INTEGER(NULL, *(++argv));\\r\\nif (!serial) goto bad;\\r\\n}\\r\\nelse if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\n{\\r\\ndigest=md_alg;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extensions\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextensions = *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-reqexts\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nreq_exts = *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -text text form of request\\n\");\\r\\nBIO_printf(bio_err,\" -pubkey output public key\\n\");\\r\\nBIO_printf(bio_err,\" -noout do not output REQ\\n\");\\r\\nBIO_printf(bio_err,\" -verify verify signature on REQ\\n\");\\r\\nBIO_printf(bio_err,\" -modulus RSA modulus\\n\");\\r\\nBIO_printf(bio_err,\" -nodes don't encrypt the output key\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -subject output the request's subject\\n\");\\r\\nBIO_printf(bio_err,\" -passin private key password source\\n\");\\r\\nBIO_printf(bio_err,\" -key file use the private key contained in file\\n\");\\r\\nBIO_printf(bio_err,\" -keyform arg key file format\\n\");\\r\\nBIO_printf(bio_err,\" -keyout arg file to send the key to\\n\");\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\" -newkey rsa:bits generate a new RSA key of 'bits' in size\\n\");\\r\\nBIO_printf(bio_err,\" -newkey dsa:file generate a new DSA key, parameters taken from CA in 'file'\\n\");\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nBIO_printf(bio_err,\" -newkey ec:file generate a new EC key, parameters taken from CA in 'file'\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -[digest] Digest to sign with (md5, sha1, md2, mdc2, md4)\\n\");\\r\\nBIO_printf(bio_err,\" -config file request template file.\\n\");\\r\\nBIO_printf(bio_err,\" -subj arg set or modify request subject\\n\");\\r\\nBIO_printf(bio_err,\" -multivalue-rdn enable support for multivalued RDNs\\n\");\\r\\nBIO_printf(bio_err,\" -new new request.\\n\");\\r\\nBIO_printf(bio_err,\" -batch do not ask anything during request generation\\n\");\\r\\nBIO_printf(bio_err,\" -x509 output a x509 structure instead of a cert. req.\\n\");\\r\\nBIO_printf(bio_err,\" -days number of days a certificate generated by -x509 is valid for.\\n\");\\r\\nBIO_printf(bio_err,\" -set_serial serial number to use for a certificate generated by -x509.\\n\");\\r\\nBIO_printf(bio_err,\" -newhdr output \\\"NEW\\\" in the header lines\\n\");\\r\\nBIO_printf(bio_err,\" -asn1-kludge Output the 'request' in a format that is wrong but some CA's\\n\");\\r\\nBIO_printf(bio_err,\" have been reported as requiring\\n\");\\r\\nBIO_printf(bio_err,\" -extensions .. specify certificate extension section (override value in config file)\\n\");\\r\\nBIO_printf(bio_err,\" -reqexts .. specify request extension section (override value in config file)\\n\");\\r\\nBIO_printf(bio_err,\" -utf8 input characters are UTF8 (default ASCII)\\n\");\\r\\nBIO_printf(bio_err,\" -nameopt arg - various certificate name options\\n\");\\r\\nBIO_printf(bio_err,\" -reqopt arg - various request text options\\n\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef MONOLITH\\r\\np=getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np=getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\np=to_free=make_config_name();\\r\\ndefault_config_file=p;\\r\\nconfig=NCONF_new(NULL);\\r\\ni=NCONF_load(config, p, &errline);\\r\\n#endif\\r\\nif (template != NULL)\\r\\n{\\r\\nlong errline = -1;\\r\\nif( verbose )\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",template);\\r\\nreq_conf=NCONF_new(NULL);\\r\\ni=NCONF_load(req_conf,template,&errline);\\r\\nif (i == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"error on line %ld of %s\\n\",errline,template);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nreq_conf=config;\\r\\nif (req_conf == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Unable to load config info from %s\\n\", default_config_file);\\r\\nif (newreq)\\r\\ngoto end;\\r\\n}\\r\\nelse if( verbose )\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",\\r\\ndefault_config_file);\\r\\n}\\r\\nif (req_conf != NULL)\\r\\n{\\r\\nif (!load_config(bio_err, req_conf))\\r\\ngoto end;\\r\\np=NCONF_get_string(req_conf,NULL,\"oid_file\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO *oid_bio;\\r\\noid_bio=BIO_new_file(p,\"r\");\\r\\nif (oid_bio == NULL)\\r\\n{\\r\\n}\\r\\nelse\\r\\n{\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\n}\\r\\nif(!add_oid_section(bio_err, req_conf)) goto end;\\r\\nif (md_alg == NULL)\\r\\n{\\r\\np=NCONF_get_string(req_conf,SECTION,\"default_md\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL)\\r\\n{\\r\\nif ((md_alg=EVP_get_digestbyname(p)) != NULL)\\r\\ndigest=md_alg;\\r\\n}\\r\\n}\\r\\nif (!extensions)\\r\\n{\\r\\nextensions = NCONF_get_string(req_conf, SECTION, V3_EXTENSIONS);\\r\\nif (!extensions)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (extensions) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, req_conf);\\r\\nif(!X509V3_EXT_add_nconf(req_conf, &ctx, extensions, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\", extensions);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif(!passin)\\r\\n{\\r\\npassin = NCONF_get_string(req_conf, SECTION, \"input_password\");\\r\\nif (!passin)\\r\\nERR_clear_error();\\r\\n}\\r\\nif(!passout)\\r\\n{\\r\\npassout = NCONF_get_string(req_conf, SECTION, \"output_password\");\\r\\nif (!passout)\\r\\nERR_clear_error();\\r\\n}\\r\\np = NCONF_get_string(req_conf, SECTION, STRING_MASK);\\r\\nif (!p)\\r\\nERR_clear_error();\\r\\nif(p && !ASN1_STRING_set_default_mask_asc(p)) {\\r\\nBIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\\r\\ngoto end;\\r\\n}\\r\\nif (chtype != MBSTRING_UTF8)\\r\\n{\\r\\np = NCONF_get_string(req_conf, SECTION, UTF8_IN);\\r\\nif (!p)\\r\\nERR_clear_error();\\r\\nelse if (!strcmp(p, \"yes\"))\\r\\nchtype = MBSTRING_UTF8;\\r\\n}\\r\\nif(!req_exts)\\r\\n{\\r\\nreq_exts = NCONF_get_string(req_conf, SECTION, REQ_EXTENSIONS);\\r\\nif (!req_exts)\\r\\nERR_clear_error();\\r\\n}\\r\\nif(req_exts) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, req_conf);\\r\\nif(!X509V3_EXT_add_nconf(req_conf, &ctx, req_exts, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading request extension section %s\\n\",\\r\\nreq_exts);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (keyfile != NULL)\\r\\n{\\r\\npkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"Private Key\");\\r\\nif (!pkey)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\nif (EVP_PKEY_type(pkey->type) == EVP_PKEY_DSA ||\\r\\nEVP_PKEY_type(pkey->type) == EVP_PKEY_EC)\\r\\n{\\r\\nchar *randfile = NCONF_get_string(req_conf,SECTION,\"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\n}\\r\\n}\\r\\nif (newreq && (pkey == NULL))\\r\\n{\\r\\nBN_GENCB cb;\\r\\nchar *randfile = NCONF_get_string(req_conf,SECTION,\"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nif (inrand)\\r\\napp_RAND_load_files(inrand);\\r\\nif (newkey <= 0)\\r\\n{\\r\\nif (!NCONF_get_number(req_conf,SECTION,BITS, &newkey))\\r\\nnewkey=DEFAULT_KEY_LENGTH;\\r\\n}\\r\\nif (newkey < MIN_KEY_LENGTH && (pkey_type == TYPE_RSA || pkey_type == TYPE_DSA))\\r\\n{\\r\\nBIO_printf(bio_err,\"private key length is too short,\\n\");\\r\\nBIO_printf(bio_err,\"it needs to be at least %d bits, not %ld\\n\",MIN_KEY_LENGTH,newkey);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating a %ld bit %s private key\\n\",\\r\\nnewkey,(pkey_type == TYPE_RSA)?\"RSA\":\\r\\n(pkey_type == TYPE_DSA)?\"DSA\":\"EC\");\\r\\nif ((pkey=EVP_PKEY_new()) == NULL) goto end;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nBN_GENCB_set(&cb, req_cb, bio_err);\\r\\nif (pkey_type == TYPE_RSA)\\r\\n{\\r\\nRSA *rsa = RSA_new();\\r\\nBIGNUM *bn = BN_new();\\r\\nif(!bn || !rsa || !BN_set_word(bn, 0x10001) ||\\r\\n!RSA_generate_key_ex(rsa, newkey, bn, &cb) ||\\r\\n!EVP_PKEY_assign_RSA(pkey, rsa))\\r\\n{\\r\\nif(bn) BN_free(bn);\\r\\nif(rsa) RSA_free(rsa);\\r\\ngoto end;\\r\\n}\\r\\nBN_free(bn);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey_type == TYPE_DSA)\\r\\n{\\r\\nif (!DSA_generate_key(dsa_params)) goto end;\\r\\nif (!EVP_PKEY_assign_DSA(pkey,dsa_params)) goto end;\\r\\ndsa_params=NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey_type == TYPE_EC)\\r\\n{\\r\\nif (!EC_KEY_generate_key(ec_params)) goto end;\\r\\nif (!EVP_PKEY_assign_EC_KEY(pkey, ec_params))\\r\\ngoto end;\\r\\nec_params = NULL;\\r\\n}\\r\\n#endif\\r\\napp_RAND_write_file(randfile, bio_err);\\r\\nif (pkey == NULL) goto end;\\r\\nif (keyout == NULL)\\r\\n{\\r\\nkeyout=NCONF_get_string(req_conf,SECTION,KEYFILE);\\r\\nif (keyout == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (keyout == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"writing new private key to stdout\\n\");\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"writing new private key to '%s'\\n\",keyout);\\r\\nif (BIO_write_filename(out,keyout) <= 0)\\r\\n{\\r\\nperror(keyout);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np=NCONF_get_string(req_conf,SECTION,\"encrypt_rsa_key\");\\r\\nif (p == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\np=NCONF_get_string(req_conf,SECTION,\"encrypt_key\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif ((p != NULL) && (strcmp(p,\"no\") == 0))\\r\\ncipher=NULL;\\r\\nif (nodes) cipher=NULL;\\r\\ni=0;\\r\\nloop:\\r\\nif (!PEM_write_bio_PrivateKey(out,pkey,cipher,\\r\\nNULL,0,NULL,passout))\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3))\\r\\n{\\r\\nERR_clear_error();\\r\\ni++;\\r\\ngoto loop;\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"-----\\n\");\\r\\n}\\r\\nif (!newreq)\\r\\n{\\r\\nkludge= -1;\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\nreq=d2i_X509_REQ_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\nreq=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (newreq || x509)\\r\\n{\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"you need to specify a private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\ndigest=EVP_ecdsa();\\r\\n#endif\\r\\nif (req == NULL)\\r\\n{\\r\\nreq=X509_REQ_new();\\r\\nif (req == NULL)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\ni=make_REQ(req,pkey,subj,multirdn,!x509, chtype);\\r\\nsubj=NULL;\\r\\nif ((kludge > 0) && !sk_X509_ATTRIBUTE_num(req->req_info->attributes))\\r\\n{\\r\\nsk_X509_ATTRIBUTE_free(req->req_info->attributes);\\r\\nreq->req_info->attributes = NULL;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"problems making Certificate Request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (x509)\\r\\n{\\r\\nEVP_PKEY *tmppkey;\\r\\nX509V3_CTX ext_ctx;\\r\\nif ((x509ss=X509_new()) == NULL) goto end;\\r\\nif(extensions && !X509_set_version(x509ss, 2)) goto end;\\r\\nif (serial)\\r\\n{\\r\\nif (!X509_set_serialNumber(x509ss, serial)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!rand_serial(NULL,\\r\\nX509_get_serialNumber(x509ss)))\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_set_issuer_name(x509ss, X509_REQ_get_subject_name(req))) goto end;\\r\\nif (!X509_gmtime_adj(X509_get_notBefore(x509ss),0)) goto end;\\r\\nif (!X509_gmtime_adj(X509_get_notAfter(x509ss), (long)60*60*24*days)) goto end;\\r\\nif (!X509_set_subject_name(x509ss, X509_REQ_get_subject_name(req))) goto end;\\r\\ntmppkey = X509_REQ_get_pubkey(req);\\r\\nif (!tmppkey || !X509_set_pubkey(x509ss,tmppkey)) goto end;\\r\\nEVP_PKEY_free(tmppkey);\\r\\nX509V3_set_ctx(&ext_ctx, x509ss, x509ss, NULL, NULL, 0);\\r\\nX509V3_set_nconf(&ext_ctx, req_conf);\\r\\nif(extensions && !X509V3_EXT_add_nconf(req_conf,\\r\\n&ext_ctx, extensions, x509ss))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\ngoto end;\\r\\n}\\r\\nif (!(i=X509_sign(x509ss,pkey,digest)))\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509V3_CTX ext_ctx;\\r\\nX509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, 0);\\r\\nX509V3_set_nconf(&ext_ctx, req_conf);\\r\\nif(req_exts && !X509V3_EXT_REQ_add_nconf(req_conf,\\r\\n&ext_ctx, req_exts, req))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nreq_exts);\\r\\ngoto end;\\r\\n}\\r\\nif (!(i=X509_REQ_sign(req,pkey,digest)))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (subj && x509)\\r\\n{\\r\\nBIO_printf(bio_err, \"Cannot modifiy certificate subject\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (subj && !x509)\\r\\n{\\r\\nif (verbose)\\r\\n{\\r\\nBIO_printf(bio_err, \"Modifying Request's Subject\\n\");\\r\\nprint_name(bio_err, \"old subject=\", X509_REQ_get_subject_name(req), nmflag);\\r\\n}\\r\\nif (build_subject(req, subj, chtype, multirdn) == 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"ERROR: cannot modify subject\\n\");\\r\\nex=1;\\r\\ngoto end;\\r\\n}\\r\\nreq->req_info->enc.modified = 1;\\r\\nif (verbose)\\r\\n{\\r\\nprint_name(bio_err, \"new subject=\", X509_REQ_get_subject_name(req), nmflag);\\r\\n}\\r\\n}\\r\\nif (verify && !x509)\\r\\n{\\r\\nint tmp=0;\\r\\nif (pkey == NULL)\\r\\n{\\r\\npkey=X509_REQ_get_pubkey(req);\\r\\ntmp=1;\\r\\nif (pkey == NULL) goto end;\\r\\n}\\r\\ni=X509_REQ_verify(req,pkey);\\r\\nif (tmp) {\\r\\nEVP_PKEY_free(pkey);\\r\\npkey=NULL;\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify failure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio_err,\"verify OK\\n\");\\r\\n}\\r\\nif (noout && !text && !modulus && !subject && !pubkey)\\r\\n{\\r\\nex=0;\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((keyout != NULL) && (strcmp(outfile,keyout) == 0))\\r\\ni=(int)BIO_append_filename(out,outfile);\\r\\nelse\\r\\ni=(int)BIO_write_filename(out,outfile);\\r\\nif (!i)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (pubkey)\\r\\n{\\r\\nEVP_PKEY *tpubkey;\\r\\ntpubkey=X509_REQ_get_pubkey(req);\\r\\nif (tpubkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error getting public key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_PUBKEY(out, tpubkey);\\r\\nEVP_PKEY_free(tpubkey);\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nif (x509)\\r\\nX509_print_ex(out, x509ss, nmflag, reqflag);\\r\\nelse\\r\\nX509_REQ_print_ex(out, req, nmflag, reqflag);\\r\\n}\\r\\nif(subject)\\r\\n{\\r\\nif(x509)\\r\\nprint_name(out, \"subject=\", X509_get_subject_name(x509ss), nmflag);\\r\\nelse\\r\\nprint_name(out, \"subject=\", X509_REQ_get_subject_name(req), nmflag);\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nEVP_PKEY *tpubkey;\\r\\nif (x509)\\r\\ntpubkey=X509_get_pubkey(x509ss);\\r\\nelse\\r\\ntpubkey=X509_REQ_get_pubkey(req);\\r\\nif (tpubkey == NULL)\\r\\n{\\r\\nfprintf(stdout,\"Modulus=unavailable\\n\");\\r\\ngoto end;\\r\\n}\\r\\nfprintf(stdout,\"Modulus=\");\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (tpubkey->type == EVP_PKEY_RSA)\\r\\nBN_print(out,tpubkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\nfprintf(stdout,\"Wrong Algorithm type\");\\r\\nEVP_PKEY_free(tpubkey);\\r\\nfprintf(stdout,\"\\n\");\\r\\n}\\r\\nif (!noout && !x509)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_REQ_bio(out,req);\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif(newhdr) i=PEM_write_bio_X509_REQ_NEW(out,req);\\r\\nelse i=PEM_write_bio_X509_REQ(out,req);\\r\\n} else {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!noout && x509 && (x509ss != NULL))\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_bio(out,x509ss);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509(out,x509ss);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write X509 certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nex=0;\\r\\nend:\\r\\n#ifndef MONOLITH\\r\\nif(to_free)\\r\\nOPENSSL_free(to_free);\\r\\n#endif\\r\\nif (ex)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif ((req_conf != NULL) && (req_conf != config)) NCONF_free(req_conf);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(pkey);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x509ss);\\r\\nASN1_INTEGER_free(serial);\\r\\nif(passargin && passin) OPENSSL_free(passin);\\r\\nif(passargout && passout) OPENSSL_free(passout);\\r\\nOBJ_cleanup();\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsa_params != NULL) DSA_free(dsa_params);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (ec_params != NULL) EC_KEY_free(ec_params);\\r\\n#endif\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ex);\\r\\n}\\r\\nstatic int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int multirdn,\\r\\nint attribs, unsigned long chtype)\\r\\n{\\r\\nint ret=0,i;\\r\\nchar no_prompt = 0;\\r\\nSTACK_OF(CONF_VALUE) *dn_sk, *attr_sk = NULL;\\r\\nchar *tmp, *dn_sect,*attr_sect;\\r\\ntmp=NCONF_get_string(req_conf,SECTION,PROMPT);\\r\\nif (tmp == NULL)\\r\\nERR_clear_error();\\r\\nif((tmp != NULL) && !strcmp(tmp, \"no\")) no_prompt = 1;\\r\\ndn_sect=NCONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);\\r\\nif (dn_sect == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to find '%s' in config\\n\",\\r\\nDISTINGUISHED_NAME);\\r\\ngoto err;\\r\\n}\\r\\ndn_sk=NCONF_get_section(req_conf,dn_sect);\\r\\nif (dn_sk == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get '%s' section\\n\",dn_sect);\\r\\ngoto err;\\r\\n}\\r\\nattr_sect=NCONF_get_string(req_conf,SECTION,ATTRIBUTES);\\r\\nif (attr_sect == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\nattr_sk=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nattr_sk=NCONF_get_section(req_conf,attr_sect);\\r\\nif (attr_sk == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get '%s' section\\n\",attr_sect);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!X509_REQ_set_version(req,0L)) goto err;\\r\\nif (no_prompt)\\r\\ni = auto_info(req, dn_sk, attr_sk, attribs, chtype);\\r\\nelse\\r\\n{\\r\\nif (subj)\\r\\ni = build_subject(req, subj, chtype, multirdn);\\r\\nelse\\r\\ni = prompt_info(req, dn_sk, dn_sect, attr_sk, attr_sect, attribs, chtype);\\r\\n}\\r\\nif(!i) goto err;\\r\\nif (!X509_REQ_set_pubkey(req,pkey)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int build_subject(X509_REQ *req, char *subject, unsigned long chtype, int multirdn)\\r\\n{\\r\\nX509_NAME *n;\\r\\nif (!(n = parse_name(subject, chtype, multirdn)))\\r\\nreturn 0;\\r\\nif (!X509_REQ_set_subject_name(req, n))\\r\\n{\\r\\nX509_NAME_free(n);\\r\\nreturn 0;\\r\\n}\\r\\nX509_NAME_free(n);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int add_DN_object(X509_NAME *n, char *text, const char *def, char *value,\\r\\nint nid, int n_min, int n_max, unsigned long chtype, int mval)\\r\\n{\\r\\nint i,ret=0;\\r\\nMS_STATIC char buf[1024];\\r\\nstart:\\r\\nif (!batch) BIO_printf(bio_err,\"%s [%s]:\",text,def);\\r\\n(void)BIO_flush(bio_err);\\r\\nif(value != NULL)\\r\\n{\\r\\nBUF_strlcpy(buf,value,sizeof buf);\\r\\nBUF_strlcat(buf,\"\\n\",sizeof buf);\\r\\nBIO_printf(bio_err,\"%s\\n\",value);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]='\\0';\\r\\nif (!batch)\\r\\n{\\r\\nfgets(buf,sizeof buf,stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0] = '\\n';\\r\\nbuf[1] = '\\0';\\r\\n}\\r\\n}\\r\\nif (buf[0] == '\\0') return(0);\\r\\nelse if (buf[0] == '\\n')\\r\\n{\\r\\nif ((def == NULL) || (def[0] == '\\0'))\\r\\nreturn(1);\\r\\nBUF_strlcpy(buf,def,sizeof buf);\\r\\nBUF_strlcat(buf,\"\\n\",sizeof buf);\\r\\n}\\r\\nelse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\\r\\ni=strlen(buf);\\r\\nif (buf[i-1] != '\\n')\\r\\n{\\r\\nBIO_printf(bio_err,\"weird input :-(\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nbuf[--i]='\\0';\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nif(!req_check_len(i, n_min, n_max)) goto start;\\r\\nif (!X509_NAME_add_entry_by_NID(n,nid, chtype,\\r\\n(unsigned char *) buf, -1,-1,mval)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int add_attribute_object(X509_REQ *req, char *text, const char *def,\\r\\nchar *value, int nid, int n_min,\\r\\nint n_max, unsigned long chtype)\\r\\n{\\r\\nint i;\\r\\nstatic char buf[1024];\\r\\nstart:\\r\\nif (!batch) BIO_printf(bio_err,\"%s [%s]:\",text,def);\\r\\n(void)BIO_flush(bio_err);\\r\\nif (value != NULL)\\r\\n{\\r\\nBUF_strlcpy(buf,value,sizeof buf);\\r\\nBUF_strlcat(buf,\"\\n\",sizeof buf);\\r\\nBIO_printf(bio_err,\"%s\\n\",value);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]='\\0';\\r\\nif (!batch)\\r\\n{\\r\\nfgets(buf,sizeof buf,stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0] = '\\n';\\r\\nbuf[1] = '\\0';\\r\\n}\\r\\n}\\r\\nif (buf[0] == '\\0') return(0);\\r\\nelse if (buf[0] == '\\n')\\r\\n{\\r\\nif ((def == NULL) || (def[0] == '\\0'))\\r\\nreturn(1);\\r\\nBUF_strlcpy(buf,def,sizeof buf);\\r\\nBUF_strlcat(buf,\"\\n\",sizeof buf);\\r\\n}\\r\\nelse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\\r\\ni=strlen(buf);\\r\\nif (buf[i-1] != '\\n')\\r\\n{\\r\\nBIO_printf(bio_err,\"weird input :-(\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nbuf[--i]='\\0';\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nif(!req_check_len(i, n_min, n_max)) goto start;\\r\\nif(!X509_REQ_add1_attr_by_NID(req, nid, chtype,\\r\\n(unsigned char *)buf, -1)) {\\r\\nBIO_printf(bio_err, \"Error adding attribute\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nstatic int MS_CALLBACK req_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write(cb->arg,&c,1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int req_check_len(int len, int n_min, int n_max)\\r\\n{\\r\\nif ((n_min > 0) && (len < n_min))\\r\\n{\\r\\nBIO_printf(bio_err,\"string is too short, it needs to be at least %d bytes long\\n\",n_min);\\r\\nreturn(0);\\r\\n}\\r\\nif ((n_max >= 0) && (len > n_max))\\r\\n{\\r\\nBIO_printf(bio_err,\"string is too long, it needs to be less than %d bytes long\\n\",n_max);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int check_end(const char *str, const char *end)\\r\\n{\\r\\nint elen, slen;\\r\\nconst char *tmp;\\r\\nelen = strlen(end);\\r\\nslen = strlen(str);\\r\\nif(elen > slen) return 1;\\r\\ntmp = str + slen - elen;\\r\\nreturn strcmp(tmp, end);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_npas_c", "target": 0, "func": "int PKCS12_newpass(PKCS12 *p12, char *oldpass, char *newpass)\\r\\n{\\r\\nif(!p12) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_INVALID_NULL_PKCS12_POINTER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_verify_mac(p12, oldpass, -1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_MAC_VERIFY_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!newpass_p12(p12, oldpass, newpass)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS,PKCS12_R_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int newpass_p12(PKCS12 *p12, char *oldpass, char *newpass)\\r\\n{\\r\\nSTACK_OF(PKCS7) *asafes, *newsafes;\\r\\nSTACK_OF(PKCS12_SAFEBAG) *bags;\\r\\nint i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;\\r\\nPKCS7 *p7, *p7new;\\r\\nASN1_OCTET_STRING *p12_data_tmp = NULL, *macnew = NULL;\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (!(asafes = PKCS12_unpack_authsafes(p12))) return 0;\\r\\nif(!(newsafes = sk_PKCS7_new_null())) return 0;\\r\\nfor (i = 0; i < sk_PKCS7_num (asafes); i++) {\\r\\np7 = sk_PKCS7_value(asafes, i);\\r\\nbagnid = OBJ_obj2nid(p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = PKCS12_unpack_p7data(p7);\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nbags = PKCS12_unpack_p7encdata(p7, oldpass, -1);\\r\\nalg_get(p7->d.encrypted->enc_data->algorithm,\\r\\n&pbe_nid, &pbe_iter, &pbe_saltlen);\\r\\n} else continue;\\r\\nif (!bags) {\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (!newpass_bags(bags, oldpass, newpass)) {\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (bagnid == NID_pkcs7_data) p7new = PKCS12_pack_p7data(bags);\\r\\nelse p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,\\r\\npbe_saltlen, pbe_iter, bags);\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nif(!p7new) {\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_PKCS7_push(newsafes, p7new);\\r\\n}\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\np12_data_tmp = p12->authsafes->d.data;\\r\\nif(!(p12->authsafes->d.data = ASN1_OCTET_STRING_new())) goto saferr;\\r\\nif(!PKCS12_pack_authsafes(p12, newsafes)) goto saferr;\\r\\nif(!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen)) goto saferr;\\r\\nif(!(macnew = ASN1_OCTET_STRING_new())) goto saferr;\\r\\nif(!ASN1_OCTET_STRING_set(macnew, mac, maclen)) goto saferr;\\r\\nASN1_OCTET_STRING_free(p12->mac->dinfo->digest);\\r\\np12->mac->dinfo->digest = macnew;\\r\\nASN1_OCTET_STRING_free(p12_data_tmp);\\r\\nreturn 1;\\r\\nsaferr:\\r\\nASN1_OCTET_STRING_free(p12->authsafes->d.data);\\r\\nASN1_OCTET_STRING_free(macnew);\\r\\np12->authsafes->d.data = p12_data_tmp;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, char *oldpass, char *newpass)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509_SIG *p8new;\\r\\nint p8_nid, p8_saltlen, p8_iter;\\r\\nif(M_PKCS12_bag_type(bag) != NID_pkcs8ShroudedKeyBag) return 1;\\r\\nif (!(p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1))) return 0;\\r\\nalg_get(bag->value.shkeybag->algor, &p8_nid, &p8_iter, &p8_saltlen);\\r\\nif(!(p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,\\r\\np8_iter, p8))) return 0;\\r\\nX509_SIG_free(bag->value.shkeybag);\\r\\nbag->value.shkeybag = p8new;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int alg_get(X509_ALGOR *alg, int *pnid, int *piter, int *psaltlen)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nconst unsigned char *p;\\r\\np = alg->parameter->value.sequence->data;\\r\\npbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);\\r\\n*pnid = OBJ_obj2nid(alg->algorithm);\\r\\n*piter = ASN1_INTEGER_get(pbe->iter);\\r\\n*psaltlen = pbe->salt->length;\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_x509_c", "target": 0, "func": "static int x509_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nX509 *ret = (X509 *)*pval;\\r\\nswitch(operation) {\\r\\ncase ASN1_OP_NEW_POST:\\r\\nret->valid=0;\\r\\nret->name = NULL;\\r\\nret->ex_flags = 0;\\r\\nret->ex_pathlen = -1;\\r\\nret->skid = NULL;\\r\\nret->akid = NULL;\\r\\nret->aux = NULL;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);\\r\\nbreak;\\r\\ncase ASN1_OP_D2I_POST:\\r\\nif (ret->name != NULL) OPENSSL_free(ret->name);\\r\\nret->name=X509_NAME_oneline(ret->cert_info->subject,NULL,0);\\r\\nbreak;\\r\\ncase ASN1_OP_FREE_POST:\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);\\r\\nX509_CERT_AUX_free(ret->aux);\\r\\nASN1_OCTET_STRING_free(ret->skid);\\r\\nAUTHORITY_KEYID_free(ret->akid);\\r\\npolicy_cache_free(ret->policy_cache);\\r\\nif (ret->name != NULL) OPENSSL_free(ret->name);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nASN1_METHOD *X509_asn1_meth(void)\\r\\n{\\r\\nreturn(&meth);\\r\\n}\\r\\nint X509_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint X509_set_ex_data(X509 *r, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\\r\\n}\\r\\nvoid *X509_get_ex_data(X509 *r, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\\r\\n}\\r\\nX509 *d2i_X509_AUX(X509 **a, const unsigned char **pp, long length)\\r\\n{\\r\\nconst unsigned char *q;\\r\\nX509 *ret;\\r\\nq = *pp;\\r\\nret = d2i_X509(a, pp, length);\\r\\nif(!ret) return NULL;\\r\\nlength -= *pp - q;\\r\\nif(!length) return ret;\\r\\nif(!d2i_X509_CERT_AUX(&ret->aux, pp, length)) goto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nX509_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nint i2d_X509_AUX(X509 *a, unsigned char **pp)\\r\\n{\\r\\nint length;\\r\\nlength = i2d_X509(a, pp);\\r\\nif(a) length += i2d_X509_CERT_AUX(a->aux, pp);\\r\\nreturn length;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_dlfcn_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_dlfcn(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_dlfcn(void)\\r\\n{\\r\\nreturn(&dso_meth_dlfcn);\\r\\n}\\r\\nstatic int dlfcn_load(DSO *dso)\\r\\n{\\r\\nvoid *ptr = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nint flags = DLOPEN_FLAG;\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_LOAD,DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RTLD_GLOBAL\\r\\nif (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\\r\\nflags |= RTLD_GLOBAL;\\r\\n#endif\\r\\nptr = dlopen(filename, flags);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_LOAD,DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\\r\\ngoto err;\\r\\n}\\r\\nif(!sk_push(dso->meth_data, (char *)ptr))\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_LOAD,DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn(1);\\r\\nerr:\\r\\nif(filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif(ptr != NULL)\\r\\ndlclose(ptr);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int dlfcn_unload(DSO *dso)\\r\\n{\\r\\nvoid *ptr;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\nreturn(1);\\r\\nptr = (void *)sk_pop(dso->meth_data);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_UNLOAD,DSO_R_NULL_HANDLE);\\r\\nsk_push(dso->meth_data, (char *)ptr);\\r\\nreturn(0);\\r\\n}\\r\\ndlclose(ptr);\\r\\nreturn(1);\\r\\n}\\r\\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ptr, *sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (void *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\nsym = dlsym(ptr, symname);\\r\\nif(sym == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ptr;\\r\\nDSO_FUNC_TYPE sym, *tsym = &sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (void *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\n*(void **)(tsym) = dlsym(ptr, symname);\\r\\nif(sym == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(sym);\\r\\n}\\r\\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\\r\\nconst char *filespec2)\\r\\n{\\r\\nchar *merged;\\r\\nif(!filespec1 && !filespec2)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_MERGER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!filespec2 || filespec1[0] == '/')\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n}\\r\\nelse if (!filespec1)\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n}\\r\\nelse\\r\\n{\\r\\nint spec2len, len;\\r\\nspec2len = (filespec2 ? strlen(filespec2) : 0);\\r\\nlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\\r\\nif(filespec2 && filespec2[spec2len - 1] == '/')\\r\\n{\\r\\nspec2len--;\\r\\nlen--;\\r\\n}\\r\\nmerged = OPENSSL_malloc(len + 2);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\nmerged[spec2len] = '/';\\r\\nstrcpy(&merged[spec2len + 1], filespec1);\\r\\n}\\r\\nreturn(merged);\\r\\n}\\r\\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, rsize, transform;\\r\\nlen = strlen(filename);\\r\\nrsize = len + 1;\\r\\ntransform = (strstr(filename, \"/\") == NULL);\\r\\nif(transform)\\r\\n{\\r\\nrsize += 3;\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nrsize += 3;\\r\\n}\\r\\ntranslated = OPENSSL_malloc(rsize);\\r\\nif(translated == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DLFCN_NAME_CONVERTER,\\r\\nDSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(transform)\\r\\n{\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nsprintf(translated, \"lib%s.so\", filename);\\r\\nelse\\r\\nsprintf(translated, \"%s.so\", filename);\\r\\n}\\r\\nelse\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn(translated);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md2_one_c", "target": 0, "func": "unsigned char *MD2(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD2_CTX c;\\r\\nstatic unsigned char m[MD2_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!MD2_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD2_Update(&c,d,n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0)\\r\\n{\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD2_Update(&c,temp,chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD2_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md5_dgst_c", "target": 0, "func": "int MD5_Init(MD5_CTX *c)\\r\\n{\\r\\nc->A=INIT_DATA_A;\\r\\nc->B=INIT_DATA_B;\\r\\nc->C=INIT_DATA_C;\\r\\nc->D=INIT_DATA_D;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid md5_block_host_order (MD5_CTX *c, const void *data, size_t num)\\r\\n{\\r\\nconst MD5_LONG *X=data;\\r\\nregister unsigned MD32_REG_T A,B,C,D;\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;X+=HASH_LBLOCK)\\r\\n{\\r\\nR0(A,B,C,D,X[ 0], 7,0xd76aa478L);\\r\\nR0(D,A,B,C,X[ 1],12,0xe8c7b756L);\\r\\nR0(C,D,A,B,X[ 2],17,0x242070dbL);\\r\\nR0(B,C,D,A,X[ 3],22,0xc1bdceeeL);\\r\\nR0(A,B,C,D,X[ 4], 7,0xf57c0fafL);\\r\\nR0(D,A,B,C,X[ 5],12,0x4787c62aL);\\r\\nR0(C,D,A,B,X[ 6],17,0xa8304613L);\\r\\nR0(B,C,D,A,X[ 7],22,0xfd469501L);\\r\\nR0(A,B,C,D,X[ 8], 7,0x698098d8L);\\r\\nR0(D,A,B,C,X[ 9],12,0x8b44f7afL);\\r\\nR0(C,D,A,B,X[10],17,0xffff5bb1L);\\r\\nR0(B,C,D,A,X[11],22,0x895cd7beL);\\r\\nR0(A,B,C,D,X[12], 7,0x6b901122L);\\r\\nR0(D,A,B,C,X[13],12,0xfd987193L);\\r\\nR0(C,D,A,B,X[14],17,0xa679438eL);\\r\\nR0(B,C,D,A,X[15],22,0x49b40821L);\\r\\nR1(A,B,C,D,X[ 1], 5,0xf61e2562L);\\r\\nR1(D,A,B,C,X[ 6], 9,0xc040b340L);\\r\\nR1(C,D,A,B,X[11],14,0x265e5a51L);\\r\\nR1(B,C,D,A,X[ 0],20,0xe9b6c7aaL);\\r\\nR1(A,B,C,D,X[ 5], 5,0xd62f105dL);\\r\\nR1(D,A,B,C,X[10], 9,0x02441453L);\\r\\nR1(C,D,A,B,X[15],14,0xd8a1e681L);\\r\\nR1(B,C,D,A,X[ 4],20,0xe7d3fbc8L);\\r\\nR1(A,B,C,D,X[ 9], 5,0x21e1cde6L);\\r\\nR1(D,A,B,C,X[14], 9,0xc33707d6L);\\r\\nR1(C,D,A,B,X[ 3],14,0xf4d50d87L);\\r\\nR1(B,C,D,A,X[ 8],20,0x455a14edL);\\r\\nR1(A,B,C,D,X[13], 5,0xa9e3e905L);\\r\\nR1(D,A,B,C,X[ 2], 9,0xfcefa3f8L);\\r\\nR1(C,D,A,B,X[ 7],14,0x676f02d9L);\\r\\nR1(B,C,D,A,X[12],20,0x8d2a4c8aL);\\r\\nR2(A,B,C,D,X[ 5], 4,0xfffa3942L);\\r\\nR2(D,A,B,C,X[ 8],11,0x8771f681L);\\r\\nR2(C,D,A,B,X[11],16,0x6d9d6122L);\\r\\nR2(B,C,D,A,X[14],23,0xfde5380cL);\\r\\nR2(A,B,C,D,X[ 1], 4,0xa4beea44L);\\r\\nR2(D,A,B,C,X[ 4],11,0x4bdecfa9L);\\r\\nR2(C,D,A,B,X[ 7],16,0xf6bb4b60L);\\r\\nR2(B,C,D,A,X[10],23,0xbebfbc70L);\\r\\nR2(A,B,C,D,X[13], 4,0x289b7ec6L);\\r\\nR2(D,A,B,C,X[ 0],11,0xeaa127faL);\\r\\nR2(C,D,A,B,X[ 3],16,0xd4ef3085L);\\r\\nR2(B,C,D,A,X[ 6],23,0x04881d05L);\\r\\nR2(A,B,C,D,X[ 9], 4,0xd9d4d039L);\\r\\nR2(D,A,B,C,X[12],11,0xe6db99e5L);\\r\\nR2(C,D,A,B,X[15],16,0x1fa27cf8L);\\r\\nR2(B,C,D,A,X[ 2],23,0xc4ac5665L);\\r\\nR3(A,B,C,D,X[ 0], 6,0xf4292244L);\\r\\nR3(D,A,B,C,X[ 7],10,0x432aff97L);\\r\\nR3(C,D,A,B,X[14],15,0xab9423a7L);\\r\\nR3(B,C,D,A,X[ 5],21,0xfc93a039L);\\r\\nR3(A,B,C,D,X[12], 6,0x655b59c3L);\\r\\nR3(D,A,B,C,X[ 3],10,0x8f0ccc92L);\\r\\nR3(C,D,A,B,X[10],15,0xffeff47dL);\\r\\nR3(B,C,D,A,X[ 1],21,0x85845dd1L);\\r\\nR3(A,B,C,D,X[ 8], 6,0x6fa87e4fL);\\r\\nR3(D,A,B,C,X[15],10,0xfe2ce6e0L);\\r\\nR3(C,D,A,B,X[ 6],15,0xa3014314L);\\r\\nR3(B,C,D,A,X[13],21,0x4e0811a1L);\\r\\nR3(A,B,C,D,X[ 4], 6,0xf7537e82L);\\r\\nR3(D,A,B,C,X[11],10,0xbd3af235L);\\r\\nR3(C,D,A,B,X[ 2],15,0x2ad7d2bbL);\\r\\nR3(B,C,D,A,X[ 9],21,0xeb86d391L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nvoid md5_block_data_order (MD5_CTX *c, const void *data_, size_t num)\\r\\n{\\r\\nconst unsigned char *data=data_;\\r\\nregister unsigned MD32_REG_T A,B,C,D,l;\\r\\n#ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9,XX10,XX11,XX12,XX13,XX14,XX15;\\r\\n# define X(i) XX##i\\r\\n#else\\r\\nMD5_LONG XX[MD5_LBLOCK];\\r\\n# define X(i) XX[i]\\r\\n#endif\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;)\\r\\n{\\r\\nHOST_c2l(data,l); X( 0)=l; HOST_c2l(data,l); X( 1)=l;\\r\\nR0(A,B,C,D,X( 0), 7,0xd76aa478L); HOST_c2l(data,l); X( 2)=l;\\r\\nR0(D,A,B,C,X( 1),12,0xe8c7b756L); HOST_c2l(data,l); X( 3)=l;\\r\\nR0(C,D,A,B,X( 2),17,0x242070dbL); HOST_c2l(data,l); X( 4)=l;\\r\\nR0(B,C,D,A,X( 3),22,0xc1bdceeeL); HOST_c2l(data,l); X( 5)=l;\\r\\nR0(A,B,C,D,X( 4), 7,0xf57c0fafL); HOST_c2l(data,l); X( 6)=l;\\r\\nR0(D,A,B,C,X( 5),12,0x4787c62aL); HOST_c2l(data,l); X( 7)=l;\\r\\nR0(C,D,A,B,X( 6),17,0xa8304613L); HOST_c2l(data,l); X( 8)=l;\\r\\nR0(B,C,D,A,X( 7),22,0xfd469501L); HOST_c2l(data,l); X( 9)=l;\\r\\nR0(A,B,C,D,X( 8), 7,0x698098d8L); HOST_c2l(data,l); X(10)=l;\\r\\nR0(D,A,B,C,X( 9),12,0x8b44f7afL); HOST_c2l(data,l); X(11)=l;\\r\\nR0(C,D,A,B,X(10),17,0xffff5bb1L); HOST_c2l(data,l); X(12)=l;\\r\\nR0(B,C,D,A,X(11),22,0x895cd7beL); HOST_c2l(data,l); X(13)=l;\\r\\nR0(A,B,C,D,X(12), 7,0x6b901122L); HOST_c2l(data,l); X(14)=l;\\r\\nR0(D,A,B,C,X(13),12,0xfd987193L); HOST_c2l(data,l); X(15)=l;\\r\\nR0(C,D,A,B,X(14),17,0xa679438eL);\\r\\nR0(B,C,D,A,X(15),22,0x49b40821L);\\r\\nR1(A,B,C,D,X( 1), 5,0xf61e2562L);\\r\\nR1(D,A,B,C,X( 6), 9,0xc040b340L);\\r\\nR1(C,D,A,B,X(11),14,0x265e5a51L);\\r\\nR1(B,C,D,A,X( 0),20,0xe9b6c7aaL);\\r\\nR1(A,B,C,D,X( 5), 5,0xd62f105dL);\\r\\nR1(D,A,B,C,X(10), 9,0x02441453L);\\r\\nR1(C,D,A,B,X(15),14,0xd8a1e681L);\\r\\nR1(B,C,D,A,X( 4),20,0xe7d3fbc8L);\\r\\nR1(A,B,C,D,X( 9), 5,0x21e1cde6L);\\r\\nR1(D,A,B,C,X(14), 9,0xc33707d6L);\\r\\nR1(C,D,A,B,X( 3),14,0xf4d50d87L);\\r\\nR1(B,C,D,A,X( 8),20,0x455a14edL);\\r\\nR1(A,B,C,D,X(13), 5,0xa9e3e905L);\\r\\nR1(D,A,B,C,X( 2), 9,0xfcefa3f8L);\\r\\nR1(C,D,A,B,X( 7),14,0x676f02d9L);\\r\\nR1(B,C,D,A,X(12),20,0x8d2a4c8aL);\\r\\nR2(A,B,C,D,X( 5), 4,0xfffa3942L);\\r\\nR2(D,A,B,C,X( 8),11,0x8771f681L);\\r\\nR2(C,D,A,B,X(11),16,0x6d9d6122L);\\r\\nR2(B,C,D,A,X(14),23,0xfde5380cL);\\r\\nR2(A,B,C,D,X( 1), 4,0xa4beea44L);\\r\\nR2(D,A,B,C,X( 4),11,0x4bdecfa9L);\\r\\nR2(C,D,A,B,X( 7),16,0xf6bb4b60L);\\r\\nR2(B,C,D,A,X(10),23,0xbebfbc70L);\\r\\nR2(A,B,C,D,X(13), 4,0x289b7ec6L);\\r\\nR2(D,A,B,C,X( 0),11,0xeaa127faL);\\r\\nR2(C,D,A,B,X( 3),16,0xd4ef3085L);\\r\\nR2(B,C,D,A,X( 6),23,0x04881d05L);\\r\\nR2(A,B,C,D,X( 9), 4,0xd9d4d039L);\\r\\nR2(D,A,B,C,X(12),11,0xe6db99e5L);\\r\\nR2(C,D,A,B,X(15),16,0x1fa27cf8L);\\r\\nR2(B,C,D,A,X( 2),23,0xc4ac5665L);\\r\\nR3(A,B,C,D,X( 0), 6,0xf4292244L);\\r\\nR3(D,A,B,C,X( 7),10,0x432aff97L);\\r\\nR3(C,D,A,B,X(14),15,0xab9423a7L);\\r\\nR3(B,C,D,A,X( 5),21,0xfc93a039L);\\r\\nR3(A,B,C,D,X(12), 6,0x655b59c3L);\\r\\nR3(D,A,B,C,X( 3),10,0x8f0ccc92L);\\r\\nR3(C,D,A,B,X(10),15,0xffeff47dL);\\r\\nR3(B,C,D,A,X( 1),21,0x85845dd1L);\\r\\nR3(A,B,C,D,X( 8), 6,0x6fa87e4fL);\\r\\nR3(D,A,B,C,X(15),10,0xfe2ce6e0L);\\r\\nR3(C,D,A,B,X( 6),15,0xa3014314L);\\r\\nR3(B,C,D,A,X(13),21,0x4e0811a1L);\\r\\nR3(A,B,C,D,X( 4), 6,0xf7537e82L);\\r\\nR3(D,A,B,C,X(11),10,0xbd3af235L);\\r\\nR3(C,D,A,B,X( 2),15,0x2ad7d2bbL);\\r\\nR3(B,C,D,A,X( 9),21,0xeb86d391L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nint printit(unsigned long *l)\\r\\n{\\r\\nint i,ii;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nfor (ii=0; ii<8; ii++)\\r\\n{\\r\\nfprintf(stderr,\"%08lx \",l[i*8+ii]);\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_app_rand_c", "target": 0, "func": "int app_RAND_load_file(const char *file, BIO *bio_e, int dont_warn)\\r\\n{\\r\\nint consider_randfile = (file == NULL);\\r\\nchar buffer[200];\\r\\n#ifdef OPENSSL_SYS_WINDOWS\\r\\nBIO_printf(bio_e,\"Loading 'screen' into random state -\");\\r\\nBIO_flush(bio_e);\\r\\nRAND_screen();\\r\\nBIO_printf(bio_e,\" done\\n\");\\r\\n#endif\\r\\nif (file == NULL)\\r\\nfile = RAND_file_name(buffer, sizeof buffer);\\r\\nelse if (RAND_egd(file) > 0)\\r\\n{\\r\\negdsocket = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (file == NULL || !RAND_load_file(file, -1))\\r\\n{\\r\\nif (RAND_status() == 0)\\r\\n{\\r\\nif (!dont_warn)\\r\\n{\\r\\nBIO_printf(bio_e,\"unable to load 'random state'\\n\");\\r\\nBIO_printf(bio_e,\"This means that the random number generator has not been seeded\\n\");\\r\\nBIO_printf(bio_e,\"with much random data.\\n\");\\r\\nif (consider_randfile)\\r\\n{\\r\\nBIO_printf(bio_e,\"Consider setting the RANDFILE environment variable to point at a file that\\n\");\\r\\nBIO_printf(bio_e,\"'random' data can be kept in (the file will be overwritten).\\n\");\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nseeded = 1;\\r\\nreturn 1;\\r\\n}\\r\\nlong app_RAND_load_files(char *name)\\r\\n{\\r\\nchar *p,*n;\\r\\nint last;\\r\\nlong tot=0;\\r\\nint egd;\\r\\nfor (;;)\\r\\n{\\r\\nlast=0;\\r\\nfor (p=name; ((*p != '\\0') && (*p != LIST_SEPARATOR_CHAR)); p++);\\r\\nif (*p == '\\0') last=1;\\r\\n*p='\\0';\\r\\nn=name;\\r\\nname=p+1;\\r\\nif (*n == '\\0') break;\\r\\negd=RAND_egd(n);\\r\\nif (egd > 0)\\r\\ntot+=egd;\\r\\nelse\\r\\ntot+=RAND_load_file(n,-1);\\r\\nif (last) break;\\r\\n}\\r\\nif (tot > 512)\\r\\napp_RAND_allow_write_file();\\r\\nreturn(tot);\\r\\n}\\r\\nint app_RAND_write_file(const char *file, BIO *bio_e)\\r\\n{\\r\\nchar buffer[200];\\r\\nif (egdsocket || !seeded)\\r\\nreturn 0;\\r\\nif (file == NULL)\\r\\nfile = RAND_file_name(buffer, sizeof buffer);\\r\\nif (file == NULL || !RAND_write_file(file))\\r\\n{\\r\\nBIO_printf(bio_e,\"unable to write 'random state'\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid app_RAND_allow_write_file(void)\\r\\n{\\r\\nseeded = 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_prn_c", "target": 0, "func": "int X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unsigned long flag, int indent)\\r\\n{\\r\\nvoid *ext_str = NULL;\\r\\nchar *value = NULL;\\r\\nconst unsigned char *p;\\r\\nX509V3_EXT_METHOD *method;\\r\\nSTACK_OF(CONF_VALUE) *nval = NULL;\\r\\nint ok = 1;\\r\\nif(!(method = X509V3_EXT_get(ext)))\\r\\nreturn unknown_ext_print(out, ext, flag, indent, 0);\\r\\np = ext->value->data;\\r\\nif(method->it) ext_str = ASN1_item_d2i(NULL, &p, ext->value->length, ASN1_ITEM_ptr(method->it));\\r\\nelse ext_str = method->d2i(NULL, &p, ext->value->length);\\r\\nif(!ext_str) return unknown_ext_print(out, ext, flag, indent, 1);\\r\\nif(method->i2s) {\\r\\nif(!(value = method->i2s(method, ext_str))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\n#ifndef CHARSET_EBCDIC\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", value);\\r\\n#else\\r\\n{\\r\\nint len;\\r\\nchar *tmp;\\r\\nlen = strlen(value)+1;\\r\\ntmp = OPENSSL_malloc(len);\\r\\nif (tmp)\\r\\n{\\r\\nascii2ebcdic(tmp, value, len);\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", tmp);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n} else if(method->i2v) {\\r\\nif(!(nval = method->i2v(method, ext_str, NULL))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\nX509V3_EXT_val_prn(out, nval, indent,\\r\\nmethod->ext_flags & X509V3_EXT_MULTILINE);\\r\\n} else if(method->i2r) {\\r\\nif(!method->i2r(method, ext_str, out, indent)) ok = 0;\\r\\n} else ok = 0;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\\r\\nif(value) OPENSSL_free(value);\\r\\nif(method->it) ASN1_item_free(ext_str, ASN1_ITEM_ptr(method->it));\\r\\nelse method->ext_free(ext_str);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int unknown_ext_print(BIO *out, X509_EXTENSION *ext, unsigned long flag, int indent, int supported)\\r\\n{\\r\\nswitch(flag & X509V3_EXT_UNKNOWN_MASK) {\\r\\ncase X509V3_EXT_DEFAULT:\\r\\nreturn 0;\\r\\ncase X509V3_EXT_ERROR_UNKNOWN:\\r\\nif(supported)\\r\\nBIO_printf(out, \"%*s<Parse Error>\", indent, \"\");\\r\\nelse\\r\\nBIO_printf(out, \"%*s<Not Supported>\", indent, \"\");\\r\\nreturn 1;\\r\\ncase X509V3_EXT_PARSE_UNKNOWN:\\r\\nreturn ASN1_parse_dump(out,\\r\\next->value->data, ext->value->length, indent, -1);\\r\\ncase X509V3_EXT_DUMP_UNKNOWN:\\r\\nreturn BIO_dump_indent(out, (char *)ext->value->data, ext->value->length, indent);\\r\\ndefault:\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint X509V3_EXT_print_fp(FILE *fp, X509_EXTENSION *ext, int flag, int indent)\\r\\n{\\r\\nBIO *bio_tmp;\\r\\nint ret;\\r\\nif(!(bio_tmp = BIO_new_fp(fp, BIO_NOCLOSE))) return 0;\\r\\nret = X509V3_EXT_print(bio_tmp, ext, flag, indent);\\r\\nBIO_free(bio_tmp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_asn1_c", "target": 0, "func": "ASN1_METHOD *RSAPrivateKey_asn1_meth(void)\\r\\n{\\r\\nreturn(&method);\\r\\n}\\r\\nstatic int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(operation == ASN1_OP_NEW_PRE) {\\r\\n*pval = (ASN1_VALUE *)RSA_new();\\r\\nif(*pval) return 2;\\r\\nreturn 0;\\r\\n} else if(operation == ASN1_OP_FREE_PRE) {\\r\\nRSA_free((RSA *)*pval);\\r\\n*pval = NULL;\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nRSA *RSAPrivateKey_dup(RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_dup(ASN1_ITEM_rptr(RSAPrivateKey), rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_prime_c", "target": 0, "func": "void callback(type,num)\\r\\nint type,num;\\r\\n{\\r\\nif (type == 0)\\r\\nfprintf(stderr,\".\");\\r\\nelse if (type == 1)\\r\\nfprintf(stderr,\"+\");\\r\\nelse if (type == 2)\\r\\nfprintf(stderr,\"*\");\\r\\nfflush(stderr);\\r\\n}\\r\\nint main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nBIGNUM *rand;\\r\\nint num=256;\\r\\nif (argc >= 2)\\r\\n{\\r\\nnum=atoi(argv[1]);\\r\\nif (num == 0) num=256;\\r\\n}\\r\\nfprintf(stderr,\"generate a strong prime\\n\");\\r\\nrand=BN_generate_prime(NULL,num,1,NULL,NULL,callback,NULL);\\r\\nfprintf(stderr,\"\\n\");\\r\\nBN_print_fp(stdout,rand);\\r\\nfprintf(stdout,\"\\n\");\\r\\nBN_free(rand);\\r\\nexit(0);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bfspeed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nBF_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nBF_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nBF_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nBF_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing BF_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing BF_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing BF_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing BF_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nBF_LONG data[2];\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing BF_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing BF_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nBF_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),BF_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"Blowfish set_key per sec = %12.3f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"Blowfish raw ecb bytes per sec = %12.3f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"Blowfish cbc bytes per sec = %12.3f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_by_dir_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void)\\r\\n{\\r\\nreturn(&x509_dir_lookup);\\r\\n}\\r\\nstatic int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\\r\\nchar **retp)\\r\\n{\\r\\nint ret=0;\\r\\nBY_DIR *ld;\\r\\nchar *dir = NULL;\\r\\nld=(BY_DIR *)ctx->method_data;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase X509_L_ADD_DIR:\\r\\nif (argl == X509_FILETYPE_DEFAULT)\\r\\n{\\r\\ndir=(char *)Getenv(X509_get_default_cert_dir_env());\\r\\nif (dir)\\r\\nret=add_cert_dir(ld,dir,X509_FILETYPE_PEM);\\r\\nelse\\r\\nret=add_cert_dir(ld,X509_get_default_cert_dir(),\\r\\nX509_FILETYPE_PEM);\\r\\nif (!ret)\\r\\n{\\r\\nX509err(X509_F_DIR_CTRL,X509_R_LOADING_CERT_DIR);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=add_cert_dir(ld,argp,(int)argl);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int new_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\nif ((a=(BY_DIR *)OPENSSL_malloc(sizeof(BY_DIR))) == NULL)\\r\\nreturn(0);\\r\\nif ((a->buffer=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nOPENSSL_free(a);\\r\\nreturn(0);\\r\\n}\\r\\na->num_dirs=0;\\r\\na->dirs=NULL;\\r\\na->dirs_type=NULL;\\r\\na->num_dirs_alloced=0;\\r\\nlu->method_data=(char *)a;\\r\\nreturn(1);\\r\\n}\\r\\nstatic void free_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\nint i;\\r\\na=(BY_DIR *)lu->method_data;\\r\\nfor (i=0; i<a->num_dirs; i++)\\r\\nif (a->dirs[i] != NULL) OPENSSL_free(a->dirs[i]);\\r\\nif (a->dirs != NULL) OPENSSL_free(a->dirs);\\r\\nif (a->dirs_type != NULL) OPENSSL_free(a->dirs_type);\\r\\nif (a->buffer != NULL) BUF_MEM_free(a->buffer);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nstatic int add_cert_dir(BY_DIR *ctx, const char *dir, int type)\\r\\n{\\r\\nint j,len;\\r\\nint *ip;\\r\\nconst char *s,*ss,*p;\\r\\nchar **pp;\\r\\nif (dir == NULL || !*dir)\\r\\n{\\r\\nX509err(X509_F_ADD_CERT_DIR,X509_R_INVALID_DIRECTORY);\\r\\nreturn 0;\\r\\n}\\r\\ns=dir;\\r\\np=s;\\r\\nfor (;;)\\r\\n{\\r\\nif ((*p == LIST_SEPARATOR_CHAR) || (*p == '\\0'))\\r\\n{\\r\\nss=s;\\r\\ns=p+1;\\r\\nlen=(int)(p-ss);\\r\\nif (len == 0) continue;\\r\\nfor (j=0; j<ctx->num_dirs; j++)\\r\\nif (strncmp(ctx->dirs[j],ss,(unsigned int)len) == 0)\\r\\ncontinue;\\r\\nif (ctx->num_dirs_alloced < (ctx->num_dirs+1))\\r\\n{\\r\\nctx->num_dirs_alloced+=10;\\r\\npp=(char **)OPENSSL_malloc(ctx->num_dirs_alloced*\\r\\nsizeof(char *));\\r\\nip=(int *)OPENSSL_malloc(ctx->num_dirs_alloced*\\r\\nsizeof(int));\\r\\nif ((pp == NULL) || (ip == NULL))\\r\\n{\\r\\nX509err(X509_F_ADD_CERT_DIR,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemcpy(pp,ctx->dirs,(ctx->num_dirs_alloced-10)*\\r\\nsizeof(char *));\\r\\nmemcpy(ip,ctx->dirs_type,(ctx->num_dirs_alloced-10)*\\r\\nsizeof(int));\\r\\nif (ctx->dirs != NULL)\\r\\nOPENSSL_free(ctx->dirs);\\r\\nif (ctx->dirs_type != NULL)\\r\\nOPENSSL_free(ctx->dirs_type);\\r\\nctx->dirs=pp;\\r\\nctx->dirs_type=ip;\\r\\n}\\r\\nctx->dirs_type[ctx->num_dirs]=type;\\r\\nctx->dirs[ctx->num_dirs]=(char *)OPENSSL_malloc((unsigned int)len+1);\\r\\nif (ctx->dirs[ctx->num_dirs] == NULL) return(0);\\r\\nstrncpy(ctx->dirs[ctx->num_dirs],ss,(unsigned int)len);\\r\\nctx->dirs[ctx->num_dirs][len]='\\0';\\r\\nctx->num_dirs++;\\r\\n}\\r\\nif (*p == '\\0') break;\\r\\np++;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_cert_by_subject(X509_LOOKUP *xl, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nBY_DIR *ctx;\\r\\nunion {\\r\\nstruct {\\r\\nX509 st_x509;\\r\\nX509_CINF st_x509_cinf;\\r\\n} x509;\\r\\nstruct {\\r\\nX509_CRL st_crl;\\r\\nX509_CRL_INFO st_crl_info;\\r\\n} crl;\\r\\n} data;\\r\\nint ok=0;\\r\\nint i,j,k;\\r\\nunsigned long h;\\r\\nBUF_MEM *b=NULL;\\r\\nstruct stat st;\\r\\nX509_OBJECT stmp,*tmp;\\r\\nconst char *postfix=\"\";\\r\\nif (name == NULL) return(0);\\r\\nstmp.type=type;\\r\\nif (type == X509_LU_X509)\\r\\n{\\r\\ndata.x509.st_x509.cert_info= &data.x509.st_x509_cinf;\\r\\ndata.x509.st_x509_cinf.subject=name;\\r\\nstmp.data.x509= &data.x509.st_x509;\\r\\npostfix=\"\";\\r\\n}\\r\\nelse if (type == X509_LU_CRL)\\r\\n{\\r\\ndata.crl.st_crl.crl= &data.crl.st_crl_info;\\r\\ndata.crl.st_crl_info.issuer=name;\\r\\nstmp.data.crl= &data.crl.st_crl;\\r\\npostfix=\"r\";\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,X509_R_WRONG_LOOKUP_TYPE);\\r\\ngoto finish;\\r\\n}\\r\\nif ((b=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_BUF_LIB);\\r\\ngoto finish;\\r\\n}\\r\\nctx=(BY_DIR *)xl->method_data;\\r\\nh=X509_NAME_hash(name);\\r\\nfor (i=0; i<ctx->num_dirs; i++)\\r\\n{\\r\\nj=strlen(ctx->dirs[i])+1+8+6+1+1;\\r\\nif (!BUF_MEM_grow(b,j))\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_MALLOC_FAILURE);\\r\\ngoto finish;\\r\\n}\\r\\nk=0;\\r\\nfor (;;)\\r\\n{\\r\\nchar c = '/';\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nc = ctx->dirs[i][strlen(ctx->dirs[i])-1];\\r\\nif (c != ':' && c != '>' && c != ']')\\r\\n{\\r\\nc = ':';\\r\\n}\\r\\nelse\\r\\n{\\r\\nc = '\\0';\\r\\n}\\r\\n#endif\\r\\nif (c == '\\0')\\r\\n{\\r\\nBIO_snprintf(b->data,b->max,\\r\\n\"%s%08lx.%s%d\",ctx->dirs[i],h,\\r\\npostfix,k);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_snprintf(b->data,b->max,\\r\\n\"%s%c%08lx.%s%d\",ctx->dirs[i],c,h,\\r\\npostfix,k);\\r\\n}\\r\\nk++;\\r\\nif (stat(b->data,&st) < 0)\\r\\nbreak;\\r\\nif (type == X509_LU_X509)\\r\\n{\\r\\nif ((X509_load_cert_file(xl,b->data,\\r\\nctx->dirs_type[i])) == 0)\\r\\nbreak;\\r\\n}\\r\\nelse if (type == X509_LU_CRL)\\r\\n{\\r\\nif ((X509_load_crl_file(xl,b->data,\\r\\nctx->dirs_type[i])) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_X509_STORE);\\r\\nj = sk_X509_OBJECT_find(xl->store_ctx->objs,&stmp);\\r\\nif(j != -1) tmp=sk_X509_OBJECT_value(xl->store_ctx->objs,j);\\r\\nelse tmp = NULL;\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nif (tmp != NULL)\\r\\n{\\r\\nok=1;\\r\\nret->type=tmp->type;\\r\\nmemcpy(&ret->data,&tmp->data,sizeof(ret->data));\\r\\ngoto finish;\\r\\n}\\r\\n}\\r\\nfinish:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_cfb64_c", "target": 0, "func": "void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister BF_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t1_srvr_c", "target": 0, "func": "static SSL_METHOD *tls1_get_server_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_server_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_server_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_server_data.ssl_accept=ssl3_accept;\\r\\nTLSv1_server_data.get_ssl_method=tls1_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&TLSv1_server_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509name_c", "target": 0, "func": "int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL) return(-1);\\r\\nreturn(X509_NAME_get_text_by_OBJ(name,obj,buf,len));\\r\\n}\\r\\nint X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,\\r\\nint len)\\r\\n{\\r\\nint i;\\r\\nASN1_STRING *data;\\r\\ni=X509_NAME_get_index_by_OBJ(name,obj,-1);\\r\\nif (i < 0) return(-1);\\r\\ndata=X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name,i));\\r\\ni=(data->length > (len-1))?(len-1):data->length;\\r\\nif (buf == NULL) return(data->length);\\r\\nmemcpy(buf,data->data,i);\\r\\nbuf[i]='\\0';\\r\\nreturn(i);\\r\\n}\\r\\nint X509_NAME_entry_count(X509_NAME *name)\\r\\n{\\r\\nif (name == NULL) return(0);\\r\\nreturn(sk_X509_NAME_ENTRY_num(name->entries));\\r\\n}\\r\\nint X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL) return(-2);\\r\\nreturn(X509_NAME_get_index_by_OBJ(name,obj,lastpos));\\r\\n}\\r\\nint X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nint n;\\r\\nX509_NAME_ENTRY *ne;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL) return(-1);\\r\\nif (lastpos < 0)\\r\\nlastpos= -1;\\r\\nsk=name->entries;\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (lastpos++; lastpos < n; lastpos++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(sk,lastpos);\\r\\nif (OBJ_cmp(ne->object,obj) == 0)\\r\\nreturn(lastpos);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nif(name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(sk_X509_NAME_ENTRY_value(name->entries,loc));\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nint i,n,set_prev,set_next;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn(NULL);\\r\\nsk=name->entries;\\r\\nret=sk_X509_NAME_ENTRY_delete(sk,loc);\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nname->modified=1;\\r\\nif (loc == n) return(ret);\\r\\nif (loc != 0)\\r\\nset_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;\\r\\nelse\\r\\nset_prev=ret->set-1;\\r\\nset_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;\\r\\nif (set_prev+1 < set_next)\\r\\nfor (i=loc; i<n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk,i)->set--;\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type,\\r\\nunsigned char *bytes, int len, int loc, int set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_OBJ(NULL, obj, type, bytes, len);\\r\\nif(!ne) return 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,\\r\\nunsigned char *bytes, int len, int loc, int set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_NID(NULL, nid, type, bytes, len);\\r\\nif(!ne) return 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,\\r\\nconst unsigned char *bytes, int len, int loc, int set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_txt(NULL, field, type, bytes, len);\\r\\nif(!ne) return 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *new_name=NULL;\\r\\nint n,i,inc;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL) return(0);\\r\\nsk=name->entries;\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nif (loc > n) loc=n;\\r\\nelse if (loc < 0) loc=n;\\r\\nname->modified=1;\\r\\nif (set == -1)\\r\\n{\\r\\nif (loc == 0)\\r\\n{\\r\\nset=0;\\r\\ninc=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set;\\r\\ninc=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (loc >= n)\\r\\n{\\r\\nif (loc != 0)\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set+1;\\r\\nelse\\r\\nset=0;\\r\\n}\\r\\nelse\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc)->set;\\r\\ninc=(set == 0)?1:0;\\r\\n}\\r\\nif ((new_name=X509_NAME_ENTRY_dup(ne)) == NULL)\\r\\ngoto err;\\r\\nnew_name->set=set;\\r\\nif (!sk_X509_NAME_ENTRY_insert(sk,new_name,loc))\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ADD_ENTRY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (inc)\\r\\n{\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (i=loc+1; i<n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk,i-1)->set+=1;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nif (new_name != NULL)\\r\\nX509_NAME_ENTRY_free(new_name);\\r\\nreturn(0);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,\\r\\nconst char *field, int type, const unsigned char *bytes, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nX509_NAME_ENTRY *nentry;\\r\\nobj=OBJ_txt2obj(field, 0);\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_TXT,\\r\\nX509_R_INVALID_FIELD_NAME);\\r\\nERR_add_error_data(2, \"name=\", field);\\r\\nreturn(NULL);\\r\\n}\\r\\nnentry = X509_NAME_ENTRY_create_by_OBJ(ne,obj,type,bytes,len);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nentry;\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,\\r\\nint type, unsigned char *bytes, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nX509_NAME_ENTRY *nentry;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_NID,X509_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nnentry = X509_NAME_ENTRY_create_by_OBJ(ne,obj,type,bytes,len);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nentry;\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,\\r\\nASN1_OBJECT *obj, int type, const unsigned char *bytes, int len)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nif ((ne == NULL) || (*ne == NULL))\\r\\n{\\r\\nif ((ret=X509_NAME_ENTRY_new()) == NULL)\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nret= *ne;\\r\\nif (!X509_NAME_ENTRY_set_object(ret,obj))\\r\\ngoto err;\\r\\nif (!X509_NAME_ENTRY_set_data(ret,type,bytes,len))\\r\\ngoto err;\\r\\nif ((ne != NULL) && (*ne == NULL)) *ne=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ne == NULL) || (ret != *ne))\\r\\nX509_NAME_ENTRY_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj)\\r\\n{\\r\\nif ((ne == NULL) || (obj == NULL))\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ENTRY_SET_OBJECT,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nASN1_OBJECT_free(ne->object);\\r\\nne->object=OBJ_dup(obj);\\r\\nreturn((ne->object == NULL)?0:1);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nint i;\\r\\nif ((ne == NULL) || ((bytes == NULL) && (len != 0))) return(0);\\r\\nif((type > 0) && (type & MBSTRING_FLAG))\\r\\nreturn ASN1_STRING_set_by_NID(&ne->value, bytes,\\r\\nlen, type,\\r\\nOBJ_obj2nid(ne->object)) ? 1 : 0;\\r\\nif (len < 0) len=strlen((char *)bytes);\\r\\ni=ASN1_STRING_set(ne->value,bytes,len);\\r\\nif (!i) return(0);\\r\\nif (type != V_ASN1_UNDEF)\\r\\n{\\r\\nif (type == V_ASN1_APP_CHOOSE)\\r\\nne->value->type=ASN1_PRINTABLE_type(bytes,len);\\r\\nelse\\r\\nne->value->type=type;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL) return(NULL);\\r\\nreturn(ne->object);\\r\\n}\\r\\nASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL) return(NULL);\\r\\nreturn(ne->value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_passwd_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1;\\r\\nchar *infile = NULL;\\r\\nint in_stdin = 0;\\r\\nint in_noverify = 0;\\r\\nchar *salt = NULL, *passwd = NULL, **passwds = NULL;\\r\\nchar *salt_malloc = NULL, *passwd_malloc = NULL;\\r\\nsize_t passwd_malloc_size = 0;\\r\\nint pw_source_defined = 0;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint i, badopt, opt_done;\\r\\nint passed_salt = 0, quiet = 0, table = 0, reverse = 0;\\r\\nint usecrypt = 0, use1 = 0, useapr1 = 0;\\r\\nsize_t pw_maxlen = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\ngoto err;\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nbadopt = 0, opt_done = 0;\\r\\ni = 0;\\r\\nwhile (!badopt && !opt_done && argv[++i] != NULL)\\r\\n{\\r\\nif (strcmp(argv[i], \"-crypt\") == 0)\\r\\nusecrypt = 1;\\r\\nelse if (strcmp(argv[i], \"-1\") == 0)\\r\\nuse1 = 1;\\r\\nelse if (strcmp(argv[i], \"-apr1\") == 0)\\r\\nuseapr1 = 1;\\r\\nelse if (strcmp(argv[i], \"-salt\") == 0)\\r\\n{\\r\\nif ((argv[i+1] != NULL) && (salt == NULL))\\r\\n{\\r\\npassed_salt = 1;\\r\\nsalt = argv[++i];\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse if (strcmp(argv[i], \"-in\") == 0)\\r\\n{\\r\\nif ((argv[i+1] != NULL) && !pw_source_defined)\\r\\n{\\r\\npw_source_defined = 1;\\r\\ninfile = argv[++i];\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse if (strcmp(argv[i], \"-stdin\") == 0)\\r\\n{\\r\\nif (!pw_source_defined)\\r\\n{\\r\\npw_source_defined = 1;\\r\\nin_stdin = 1;\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse if (strcmp(argv[i], \"-noverify\") == 0)\\r\\nin_noverify = 1;\\r\\nelse if (strcmp(argv[i], \"-quiet\") == 0)\\r\\nquiet = 1;\\r\\nelse if (strcmp(argv[i], \"-table\") == 0)\\r\\ntable = 1;\\r\\nelse if (strcmp(argv[i], \"-reverse\") == 0)\\r\\nreverse = 1;\\r\\nelse if (argv[i][0] == '-')\\r\\nbadopt = 1;\\r\\nelse if (!pw_source_defined)\\r\\n{\\r\\npw_source_defined = 1;\\r\\npasswds = &argv[i];\\r\\nopt_done = 1;\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nif (!usecrypt && !use1 && !useapr1)\\r\\nusecrypt = 1;\\r\\nif (usecrypt + use1 + useapr1 > 1)\\r\\nbadopt = 1;\\r\\n#ifdef OPENSSL_NO_DES\\r\\nif (usecrypt) badopt = 1;\\r\\n#endif\\r\\n#ifdef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1) badopt = 1;\\r\\n#endif\\r\\nif (badopt)\\r\\n{\\r\\nBIO_printf(bio_err, \"Usage: passwd [options] [passwords]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\n#ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err, \"-crypt standard Unix password algorithm (default)\\n\");\\r\\n#endif\\r\\n#ifndef NO_MD5CRYPT_1\\r\\nBIO_printf(bio_err, \"-1 MD5-based password algorithm\\n\");\\r\\nBIO_printf(bio_err, \"-apr1 MD5-based password algorithm, Apache variant\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-salt string use provided salt\\n\");\\r\\nBIO_printf(bio_err, \"-in file read passwords from file\\n\");\\r\\nBIO_printf(bio_err, \"-stdin read passwords from stdin\\n\");\\r\\nBIO_printf(bio_err, \"-noverify never verify when reading password from terminal\\n\");\\r\\nBIO_printf(bio_err, \"-quiet no warnings\\n\");\\r\\nBIO_printf(bio_err, \"-table format output as table\\n\");\\r\\nBIO_printf(bio_err, \"-reverse switch table columns\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((infile != NULL) || in_stdin)\\r\\n{\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\ngoto err;\\r\\nif (infile != NULL)\\r\\n{\\r\\nassert(in_stdin == 0);\\r\\nif (BIO_read_filename(in, infile) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nassert(in_stdin);\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\nif (usecrypt)\\r\\npw_maxlen = 8;\\r\\nelse if (use1 || useapr1)\\r\\npw_maxlen = 256;\\r\\nif (passwds == NULL)\\r\\n{\\r\\npasswd_malloc_size = pw_maxlen + 2;\\r\\npasswd = passwd_malloc = OPENSSL_malloc(passwd_malloc_size);\\r\\nif (passwd_malloc == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif ((in == NULL) && (passwds == NULL))\\r\\n{\\r\\nstatic char *passwds_static[2] = {NULL, NULL};\\r\\npasswds = passwds_static;\\r\\nif (in == NULL)\\r\\nif (EVP_read_pw_string(passwd_malloc, passwd_malloc_size, \"Password: \", !(passed_salt || in_noverify)) != 0)\\r\\ngoto err;\\r\\npasswds[0] = passwd_malloc;\\r\\n}\\r\\nif (in == NULL)\\r\\n{\\r\\nassert(passwds != NULL);\\r\\nassert(*passwds != NULL);\\r\\ndo\\r\\n{\\r\\npasswd = *passwds++;\\r\\nif (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,\\r\\nquiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))\\r\\ngoto err;\\r\\n}\\r\\nwhile (*passwds != NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nint done;\\r\\nassert (passwd != NULL);\\r\\ndo\\r\\n{\\r\\nint r = BIO_gets(in, passwd, pw_maxlen + 1);\\r\\nif (r > 0)\\r\\n{\\r\\nchar *c = (strchr(passwd, '\\n')) ;\\r\\nif (c != NULL)\\r\\n*c = 0;\\r\\nelse\\r\\n{\\r\\nchar trash[BUFSIZ];\\r\\ndo\\r\\nr = BIO_gets(in, trash, sizeof trash);\\r\\nwhile ((r > 0) && (!strchr(trash, '\\n')));\\r\\n}\\r\\nif (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,\\r\\nquiet, table, reverse, pw_maxlen, usecrypt, use1, useapr1))\\r\\ngoto err;\\r\\n}\\r\\ndone = (r <= 0);\\r\\n}\\r\\nwhile (!done);\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nif (salt_malloc)\\r\\nOPENSSL_free(salt_malloc);\\r\\nif (passwd_malloc)\\r\\nOPENSSL_free(passwd_malloc);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic char *md5crypt(const char *passwd, const char *magic, const char *salt)\\r\\n{\\r\\nstatic char out_buf[6 + 9 + 24 + 2];\\r\\nunsigned char buf[MD5_DIGEST_LENGTH];\\r\\nchar *salt_out;\\r\\nint n;\\r\\nunsigned int i;\\r\\nEVP_MD_CTX md,md2;\\r\\nsize_t passwd_len, salt_len;\\r\\npasswd_len = strlen(passwd);\\r\\nout_buf[0] = '$';\\r\\nout_buf[1] = 0;\\r\\nassert(strlen(magic) <= 4);\\r\\nstrncat(out_buf, magic, 4);\\r\\nstrncat(out_buf, \"$\", 1);\\r\\nstrncat(out_buf, salt, 8);\\r\\nassert(strlen(out_buf) <= 6 + 8);\\r\\nsalt_out = out_buf + 2 + strlen(magic);\\r\\nsalt_len = strlen(salt_out);\\r\\nassert(salt_len <= 8);\\r\\nEVP_MD_CTX_init(&md);\\r\\nEVP_DigestInit_ex(&md,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md, \"$\", 1);\\r\\nEVP_DigestUpdate(&md, magic, strlen(magic));\\r\\nEVP_DigestUpdate(&md, \"$\", 1);\\r\\nEVP_DigestUpdate(&md, salt_out, salt_len);\\r\\nEVP_MD_CTX_init(&md2);\\r\\nEVP_DigestInit_ex(&md2,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md2, salt_out, salt_len);\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestFinal_ex(&md2, buf, NULL);\\r\\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)\\r\\nEVP_DigestUpdate(&md, buf, sizeof buf);\\r\\nEVP_DigestUpdate(&md, buf, i);\\r\\nn = passwd_len;\\r\\nwhile (n)\\r\\n{\\r\\nEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1);\\r\\nn >>= 1;\\r\\n}\\r\\nEVP_DigestFinal_ex(&md, buf, NULL);\\r\\nfor (i = 0; i < 1000; i++)\\r\\n{\\r\\nEVP_DigestInit_ex(&md2,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf,\\r\\n(i & 1) ? passwd_len : sizeof buf);\\r\\nif (i % 3)\\r\\nEVP_DigestUpdate(&md2, salt_out, salt_len);\\r\\nif (i % 7)\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd,\\r\\n(i & 1) ? sizeof buf : passwd_len);\\r\\nEVP_DigestFinal_ex(&md2, buf, NULL);\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&md2);\\r\\n{\\r\\nunsigned char buf_perm[sizeof buf];\\r\\nint dest, source;\\r\\nchar *output;\\r\\nfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17)\\r\\nbuf_perm[dest] = buf[source];\\r\\nbuf_perm[14] = buf[5];\\r\\nbuf_perm[15] = buf[11];\\r\\n#ifndef PEDANTIC\\r\\nassert(16 == sizeof buf_perm);\\r\\n#endif\\r\\noutput = salt_out + salt_len;\\r\\nassert(output == out_buf + strlen(out_buf));\\r\\n*output++ = '$';\\r\\nfor (i = 0; i < 15; i += 3)\\r\\n{\\r\\n*output++ = cov_2char[buf_perm[i+2] & 0x3f];\\r\\n*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) |\\r\\n(buf_perm[i+2] >> 6)];\\r\\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\\r\\n(buf_perm[i+1] >> 4)];\\r\\n*output++ = cov_2char[buf_perm[i] >> 2];\\r\\n}\\r\\nassert(i == 15);\\r\\n*output++ = cov_2char[buf_perm[i] & 0x3f];\\r\\n*output++ = cov_2char[buf_perm[i] >> 6];\\r\\n*output = 0;\\r\\nassert(strlen(out_buf) < sizeof(out_buf));\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&md);\\r\\nreturn out_buf;\\r\\n}\\r\\nstatic int do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,\\r\\nchar *passwd, BIO *out, int quiet, int table, int reverse,\\r\\nsize_t pw_maxlen, int usecrypt, int use1, int useapr1)\\r\\n{\\r\\nchar *hash = NULL;\\r\\nassert(salt_p != NULL);\\r\\nassert(salt_malloc_p != NULL);\\r\\nif (!passed_salt)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DES\\r\\nif (usecrypt)\\r\\n{\\r\\nif (*salt_malloc_p == NULL)\\r\\n{\\r\\n*salt_p = *salt_malloc_p = OPENSSL_malloc(3);\\r\\nif (*salt_malloc_p == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (RAND_pseudo_bytes((unsigned char *)*salt_p, 2) < 0)\\r\\ngoto err;\\r\\n(*salt_p)[0] = cov_2char[(*salt_p)[0] & 0x3f];\\r\\n(*salt_p)[1] = cov_2char[(*salt_p)[1] & 0x3f];\\r\\n(*salt_p)[2] = 0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(*salt_p, *salt_p, 2);\\r\\n#endif\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1)\\r\\n{\\r\\nint i;\\r\\nif (*salt_malloc_p == NULL)\\r\\n{\\r\\n*salt_p = *salt_malloc_p = OPENSSL_malloc(9);\\r\\nif (*salt_malloc_p == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (RAND_pseudo_bytes((unsigned char *)*salt_p, 8) < 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < 8; i++)\\r\\n(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f];\\r\\n(*salt_p)[8] = 0;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nassert(*salt_p != NULL);\\r\\nif ((strlen(passwd) > pw_maxlen))\\r\\n{\\r\\nif (!quiet)\\r\\nBIO_printf(bio_err, \"Warning: truncating password to %u characters\\n\", (unsigned)pw_maxlen);\\r\\npasswd[pw_maxlen] = 0;\\r\\n}\\r\\nassert(strlen(passwd) <= pw_maxlen);\\r\\n#ifndef OPENSSL_NO_DES\\r\\nif (usecrypt)\\r\\nhash = DES_crypt(passwd, *salt_p);\\r\\n#endif\\r\\n#ifndef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1)\\r\\nhash = md5crypt(passwd, (use1 ? \"1\" : \"apr1\"), *salt_p);\\r\\n#endif\\r\\nassert(hash != NULL);\\r\\nif (table && !reverse)\\r\\nBIO_printf(out, \"%s\\t%s\\n\", passwd, hash);\\r\\nelse if (table && reverse)\\r\\nBIO_printf(out, \"%s\\t%s\\n\", hash, passwd);\\r\\nelse\\r\\nBIO_printf(out, \"%s\\n\", hash);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nfputs(\"Program not available.\\n\", stderr)\\r\\nOPENSSL_EXIT(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_enc_c", "target": 0, "func": "void CAST_encrypt(CAST_LONG *data, CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l,r,*k,t;\\r\\nk= &(key->data[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nE_CAST( 0,k,l,r,+,^,-);\\r\\nE_CAST( 1,k,r,l,^,-,+);\\r\\nE_CAST( 2,k,l,r,-,+,^);\\r\\nE_CAST( 3,k,r,l,+,^,-);\\r\\nE_CAST( 4,k,l,r,^,-,+);\\r\\nE_CAST( 5,k,r,l,-,+,^);\\r\\nE_CAST( 6,k,l,r,+,^,-);\\r\\nE_CAST( 7,k,r,l,^,-,+);\\r\\nE_CAST( 8,k,l,r,-,+,^);\\r\\nE_CAST( 9,k,r,l,+,^,-);\\r\\nE_CAST(10,k,l,r,^,-,+);\\r\\nE_CAST(11,k,r,l,-,+,^);\\r\\nif(!key->short_key)\\r\\n{\\r\\nE_CAST(12,k,l,r,+,^,-);\\r\\nE_CAST(13,k,r,l,^,-,+);\\r\\nE_CAST(14,k,l,r,-,+,^);\\r\\nE_CAST(15,k,r,l,+,^,-);\\r\\n}\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n}\\r\\nvoid CAST_decrypt(CAST_LONG *data, CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l,r,*k,t;\\r\\nk= &(key->data[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nif(!key->short_key)\\r\\n{\\r\\nE_CAST(15,k,l,r,+,^,-);\\r\\nE_CAST(14,k,r,l,-,+,^);\\r\\nE_CAST(13,k,l,r,^,-,+);\\r\\nE_CAST(12,k,r,l,+,^,-);\\r\\n}\\r\\nE_CAST(11,k,l,r,-,+,^);\\r\\nE_CAST(10,k,r,l,^,-,+);\\r\\nE_CAST( 9,k,l,r,+,^,-);\\r\\nE_CAST( 8,k,r,l,-,+,^);\\r\\nE_CAST( 7,k,l,r,^,-,+);\\r\\nE_CAST( 6,k,r,l,+,^,-);\\r\\nE_CAST( 5,k,l,r,-,+,^);\\r\\nE_CAST( 4,k,r,l,^,-,+);\\r\\nE_CAST( 3,k,l,r,+,^,-);\\r\\nE_CAST( 2,k,r,l,-,+,^);\\r\\nE_CAST( 1,k,l,r,^,-,+);\\r\\nE_CAST( 0,k,r,l,+,^,-);\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n}\\r\\nvoid CAST_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nCAST_KEY *ks, unsigned char *iv, int enc)\\r\\n{\\r\\nregister CAST_LONG tin0,tin1;\\r\\nregister CAST_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nCAST_LONG tin[2];\\r\\nif (enc)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_winrand_c", "target": 0, "func": "int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\\r\\nPSTR cmdline, int iCmdShow)\\r\\n{\\r\\nstatic char appname[] = \"OpenSSL\";\\r\\nHWND hwnd;\\r\\nMSG msg;\\r\\nWNDCLASSEX wndclass;\\r\\nchar buffer[200];\\r\\nif (cmdline[0] == '\\0')\\r\\nfilename = RAND_file_name(buffer, sizeof buffer);\\r\\nelse\\r\\nfilename = cmdline;\\r\\nRAND_load_file(filename, -1);\\r\\nwndclass.cbSize = sizeof(wndclass);\\r\\nwndclass.style = CS_HREDRAW | CS_VREDRAW;\\r\\nwndclass.lpfnWndProc = WndProc;\\r\\nwndclass.cbClsExtra = 0;\\r\\nwndclass.cbWndExtra = 0;\\r\\nwndclass.hInstance = hInstance;\\r\\nwndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\\r\\nwndclass.hCursor = LoadCursor(NULL, IDC_ARROW);\\r\\nwndclass.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);\\r\\nwndclass.lpszMenuName = NULL;\\r\\nwndclass.lpszClassName = appname;\\r\\nwndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\\r\\nRegisterClassEx(&wndclass);\\r\\nhwnd = CreateWindow(appname, OPENSSL_VERSION_TEXT,\\r\\nWS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,\\r\\nCW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);\\r\\nShowWindow(hwnd, iCmdShow);\\r\\nUpdateWindow(hwnd);\\r\\nwhile (GetMessage(&msg, NULL, 0, 0))\\r\\n{\\r\\nTranslateMessage(&msg);\\r\\nDispatchMessage(&msg);\\r\\n}\\r\\nreturn msg.wParam;\\r\\n}\\r\\nLRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)\\r\\n{\\r\\nHDC hdc;\\r\\nPAINTSTRUCT ps;\\r\\nRECT rect;\\r\\nstatic int seeded = 0;\\r\\nswitch (iMsg)\\r\\n{\\r\\ncase WM_PAINT:\\r\\nhdc = BeginPaint(hwnd, &ps);\\r\\nGetClientRect(hwnd, &rect);\\r\\nDrawText(hdc, \"Seeding the PRNG. Please move the mouse!\", -1,\\r\\n&rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);\\r\\nEndPaint(hwnd, &ps);\\r\\nreturn 0;\\r\\ncase WM_DESTROY:\\r\\nPostQuitMessage(0);\\r\\nreturn 0;\\r\\n}\\r\\nif (RAND_event(iMsg, wParam, lParam) == 1 && seeded == 0)\\r\\n{\\r\\nseeded = 1;\\r\\nif (RAND_write_file(filename) <= 0)\\r\\nMessageBox(hwnd, \"Couldn't write random file!\",\\r\\n\"OpenSSL\", MB_OK | MB_ICONERROR);\\r\\nPostQuitMessage(0);\\r\\n}\\r\\nreturn DefWindowProc(hwnd, iMsg, wParam, lParam);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_str_err_c", "target": 0, "func": "void ERR_load_STORE_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,STORE_str_functs);\\r\\nERR_load_strings(0,STORE_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cast_spd_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nCAST_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nCAST_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nCAST_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nCAST_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing CAST_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing CAST_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld cast set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing CAST_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing CAST_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nCAST_LONG data[2];\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld CAST_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing CAST_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing CAST_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nCAST_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),CAST_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld CAST_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"CAST set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"CAST raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"CAST cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_dl_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_dl(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_dl(void)\\r\\n{\\r\\nreturn(&dso_meth_dl);\\r\\n}\\r\\nstatic int dl_load(DSO *dso)\\r\\n{\\r\\nshl_t ptr = NULL;\\r\\nchar *filename= DSO_convert_filename(dso, NULL);\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_LOAD,DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nptr = shl_load(filename, BIND_IMMEDIATE |\\r\\n(dso->flags&DSO_FLAG_NO_NAME_TRANSLATION?0:DYNAMIC_PATH), 0L);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_LOAD,DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(4, \"filename(\", filename, \"): \",\\r\\nstrerror(errno));\\r\\ngoto err;\\r\\n}\\r\\nif(!sk_push(dso->meth_data, (char *)ptr))\\r\\n{\\r\\nDSOerr(DSO_F_DL_LOAD,DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn(1);\\r\\nerr:\\r\\nif(filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif(ptr != NULL)\\r\\nshl_unload(ptr);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int dl_unload(DSO *dso)\\r\\n{\\r\\nshl_t ptr;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\nreturn(1);\\r\\nptr = (shl_t)sk_pop(dso->meth_data);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_UNLOAD,DSO_R_NULL_HANDLE);\\r\\nsk_push(dso->meth_data, (char *)ptr);\\r\\nreturn(0);\\r\\n}\\r\\nshl_unload(ptr);\\r\\nreturn(1);\\r\\n}\\r\\nstatic void *dl_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nshl_t ptr;\\r\\nvoid *sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (shl_t)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \",\\r\\nstrerror(errno));\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE dl_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nshl_t ptr;\\r\\nvoid *sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (shl_t)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0)\\r\\n{\\r\\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \",\\r\\nstrerror(errno));\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn((DSO_FUNC_TYPE)sym);\\r\\n}\\r\\nstatic char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nchar *merged;\\r\\nif(!filespec1 && !filespec2)\\r\\n{\\r\\nDSOerr(DSO_F_DL_MERGER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!filespec2 || filespec1[0] == '/')\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DL_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n}\\r\\nelse if (!filespec1)\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DL_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n}\\r\\nelse\\r\\n{\\r\\nint spec2len, len;\\r\\nspec2len = (filespec2 ? strlen(filespec2) : 0);\\r\\nlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\\r\\nif(filespec2 && filespec2[spec2len - 1] == '/')\\r\\n{\\r\\nspec2len--;\\r\\nlen--;\\r\\n}\\r\\nmerged = OPENSSL_malloc(len + 2);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_DL_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\nmerged[spec2len] = '/';\\r\\nstrcpy(&merged[spec2len + 1], filespec1);\\r\\n}\\r\\nreturn(merged);\\r\\n}\\r\\nstatic char *dl_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, rsize, transform;\\r\\nlen = strlen(filename);\\r\\nrsize = len + 1;\\r\\ntransform = (strstr(filename, \"/\") == NULL);\\r\\n{\\r\\nrsize += strlen(extension);\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nrsize += 3;\\r\\n}\\r\\ntranslated = OPENSSL_malloc(rsize);\\r\\nif(translated == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DL_NAME_CONVERTER,\\r\\nDSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(transform)\\r\\n{\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nsprintf(translated, \"lib%s%s\", filename, extension);\\r\\nelse\\r\\nsprintf(translated, \"%s%s\", filename, extension);\\r\\n}\\r\\nelse\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn(translated);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_cfb64_c", "target": 0, "func": "void CAST_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, CAST_KEY *schedule, unsigned char *ivec,\\r\\nint *num, int enc)\\r\\n{\\r\\nregister CAST_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=ivec;\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\niv=ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\niv=ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p8_pkey_c", "target": 0, "func": "static int pkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(operation == ASN1_OP_FREE_PRE) {\\r\\nPKCS8_PRIV_KEY_INFO *key = (PKCS8_PRIV_KEY_INFO *)*pval;\\r\\nif (key->pkey->value.octet_string)\\r\\nOPENSSL_cleanse(key->pkey->value.octet_string->data,\\r\\nkey->pkey->value.octet_string->length);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_str_meth_c", "target": 0, "func": "STORE_METHOD *STORE_create_method(char *name)\\r\\n{\\r\\nSTORE_METHOD *store_method = (STORE_METHOD *)OPENSSL_malloc(sizeof(STORE_METHOD));\\r\\nif (store_method)\\r\\nmemset(store_method, 0, sizeof(*store_method));\\r\\nstore_method->name = BUF_strdup(name);\\r\\nreturn store_method;\\r\\n}\\r\\nvoid STORE_destroy_method(STORE_METHOD *store_method)\\r\\n{\\r\\nif (!store_method) return;\\r\\nOPENSSL_free(store_method->name);\\r\\nstore_method->name = NULL;\\r\\nOPENSSL_free(store_method);\\r\\n}\\r\\nint STORE_method_set_initialise_function(STORE_METHOD *sm, STORE_INITIALISE_FUNC_PTR init_f)\\r\\n{\\r\\nsm->init = init_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_cleanup_function(STORE_METHOD *sm, STORE_CLEANUP_FUNC_PTR clean_f)\\r\\n{\\r\\nsm->clean = clean_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_generate_function(STORE_METHOD *sm, STORE_GENERATE_OBJECT_FUNC_PTR generate_f)\\r\\n{\\r\\nsm->generate_object = generate_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_get_function(STORE_METHOD *sm, STORE_GET_OBJECT_FUNC_PTR get_f)\\r\\n{\\r\\nsm->get_object = get_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_store_function(STORE_METHOD *sm, STORE_STORE_OBJECT_FUNC_PTR store_f)\\r\\n{\\r\\nsm->store_object = store_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_modify_function(STORE_METHOD *sm, STORE_MODIFY_OBJECT_FUNC_PTR modify_f)\\r\\n{\\r\\nsm->modify_object = modify_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_revoke_function(STORE_METHOD *sm, STORE_HANDLE_OBJECT_FUNC_PTR revoke_f)\\r\\n{\\r\\nsm->revoke_object = revoke_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_delete_function(STORE_METHOD *sm, STORE_HANDLE_OBJECT_FUNC_PTR delete_f)\\r\\n{\\r\\nsm->delete_object = delete_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_list_start_function(STORE_METHOD *sm, STORE_START_OBJECT_FUNC_PTR list_start_f)\\r\\n{\\r\\nsm->list_object_start = list_start_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_list_next_function(STORE_METHOD *sm, STORE_NEXT_OBJECT_FUNC_PTR list_next_f)\\r\\n{\\r\\nsm->list_object_next = list_next_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_list_end_function(STORE_METHOD *sm, STORE_END_OBJECT_FUNC_PTR list_end_f)\\r\\n{\\r\\nsm->list_object_end = list_end_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_update_store_function(STORE_METHOD *sm, STORE_GENERIC_FUNC_PTR update_f)\\r\\n{\\r\\nsm->update_store = update_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_lock_store_function(STORE_METHOD *sm, STORE_GENERIC_FUNC_PTR lock_f)\\r\\n{\\r\\nsm->lock_store = lock_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_unlock_store_function(STORE_METHOD *sm, STORE_GENERIC_FUNC_PTR unlock_f)\\r\\n{\\r\\nsm->unlock_store = unlock_f;\\r\\nreturn 1;\\r\\n}\\r\\nint STORE_method_set_ctrl_function(STORE_METHOD *sm, STORE_CTRL_FUNC_PTR ctrl_f)\\r\\n{\\r\\nsm->ctrl = ctrl_f;\\r\\nreturn 1;\\r\\n}\\r\\nSTORE_INITIALISE_FUNC_PTR STORE_method_get_initialise_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->init;\\r\\n}\\r\\nSTORE_CLEANUP_FUNC_PTR STORE_method_get_cleanup_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->clean;\\r\\n}\\r\\nSTORE_GENERATE_OBJECT_FUNC_PTR STORE_method_get_generate_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->generate_object;\\r\\n}\\r\\nSTORE_GET_OBJECT_FUNC_PTR STORE_method_get_get_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->get_object;\\r\\n}\\r\\nSTORE_STORE_OBJECT_FUNC_PTR STORE_method_get_store_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->store_object;\\r\\n}\\r\\nSTORE_MODIFY_OBJECT_FUNC_PTR STORE_method_get_modify_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->modify_object;\\r\\n}\\r\\nSTORE_HANDLE_OBJECT_FUNC_PTR STORE_method_get_revoke_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->revoke_object;\\r\\n}\\r\\nSTORE_HANDLE_OBJECT_FUNC_PTR STORE_method_get_delete_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->delete_object;\\r\\n}\\r\\nSTORE_START_OBJECT_FUNC_PTR STORE_method_get_list_start_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->list_object_start;\\r\\n}\\r\\nSTORE_NEXT_OBJECT_FUNC_PTR STORE_method_get_list_next_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->list_object_next;\\r\\n}\\r\\nSTORE_END_OBJECT_FUNC_PTR STORE_method_get_list_end_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->list_object_end;\\r\\n}\\r\\nSTORE_GENERIC_FUNC_PTR STORE_method_get_update_store_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->update_store;\\r\\n}\\r\\nSTORE_GENERIC_FUNC_PTR STORE_method_get_lock_store_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->lock_store;\\r\\n}\\r\\nSTORE_GENERIC_FUNC_PTR STORE_method_get_unlock_store_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->unlock_store;\\r\\n}\\r\\nSTORE_CTRL_FUNC_PTR STORE_method_get_ctrl_function(STORE_METHOD *sm)\\r\\n{\\r\\nreturn sm->ctrl;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_gmp_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_e_gmp_id) ||\\r\\n!ENGINE_set_name(e, engine_e_gmp_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &e_gmp_rsa) ||\\r\\n#endif\\r\\n!ENGINE_set_destroy_function(e, e_gmp_destroy) ||\\r\\n!ENGINE_set_init_function(e, e_gmp_init) ||\\r\\n!ENGINE_set_finish_function(e, e_gmp_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, e_gmp_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, e_gmp_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\ne_gmp_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\ne_gmp_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\ne_gmp_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\ne_gmp_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\ne_gmp_rsa.bn_mod_exp = meth1->bn_mod_exp;\\r\\n#endif\\r\\nERR_load_GMP_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_gmp(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_gmp(void)\\r\\n{\\r\\nENGINE *toadd = engine_gmp();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int e_gmp_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_GMP_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int e_gmp_init(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (hndidx_rsa == -1)\\r\\nhndidx_rsa = RSA_get_ex_new_index(0,\\r\\n\"GMP-based RSA key handle\",\\r\\nNULL, NULL, NULL);\\r\\n#endif\\r\\nif (hndidx_rsa == -1)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int e_gmp_finish(ENGINE *e)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int e_gmp_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint to_return = 1;\\r\\nswitch(cmd)\\r\\n{\\r\\n#if 0\\r\\ncase E_GMP_CMD_SO_PATH:\\r\\n#endif\\r\\ndefault:\\r\\nGMPerr(GMP_F_E_GMP_CTRL,\\r\\nGMP_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nto_return = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int bn2gmp(const BIGNUM *bn, mpz_t g)\\r\\n{\\r\\nint toret;\\r\\nchar *tmpchar = BN_bn2hex(bn);\\r\\nif(!tmpchar) return 0;\\r\\ntoret = (mpz_set_str(g, tmpchar, 16) == 0 ? 1 : 0);\\r\\nOPENSSL_free(tmpchar);\\r\\nreturn toret;\\r\\n}\\r\\nstatic int gmp2bn(mpz_t g, BIGNUM *bn)\\r\\n{\\r\\nint toret;\\r\\nchar *tmpchar = OPENSSL_malloc(mpz_sizeinbase(g, 16) + 10);\\r\\nif(!tmpchar) return 0;\\r\\nmpz_get_str(tmpchar, 16, g);\\r\\ntoret = BN_hex2bn(&bn, tmpchar);\\r\\nOPENSSL_free(tmpchar);\\r\\nreturn toret;\\r\\n}\\r\\nstatic E_GMP_RSA_CTX *e_gmp_get_rsa(RSA *rsa)\\r\\n{\\r\\nE_GMP_RSA_CTX *hptr = RSA_get_ex_data(rsa, hndidx_rsa);\\r\\nif(hptr) return hptr;\\r\\nhptr = OPENSSL_malloc(sizeof(E_GMP_RSA_CTX));\\r\\nif(!hptr) return NULL;\\r\\nmpz_init(hptr->n);\\r\\nmpz_init(hptr->d);\\r\\nmpz_init(hptr->e);\\r\\nmpz_init(hptr->p);\\r\\nmpz_init(hptr->q);\\r\\nmpz_init(hptr->dmp1);\\r\\nmpz_init(hptr->dmq1);\\r\\nmpz_init(hptr->iqmp);\\r\\nmpz_init(hptr->r0);\\r\\nmpz_init(hptr->r1);\\r\\nmpz_init(hptr->I0);\\r\\nmpz_init(hptr->m1);\\r\\nif(!bn2gmp(rsa->n, hptr->n) || !bn2gmp(rsa->e, hptr->e))\\r\\ngoto err;\\r\\nif(!rsa->p || !rsa->q || !rsa->d || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\\r\\n{\\r\\nhptr->public_only = 1;\\r\\nreturn hptr;\\r\\n}\\r\\nif(!bn2gmp(rsa->d, hptr->d) || !bn2gmp(rsa->p, hptr->p) ||\\r\\n!bn2gmp(rsa->q, hptr->q) || !bn2gmp(rsa->dmp1, hptr->dmp1) ||\\r\\n!bn2gmp(rsa->dmq1, hptr->dmq1) || !bn2gmp(rsa->iqmp, hptr->iqmp))\\r\\ngoto err;\\r\\nhptr->public_only = 0;\\r\\nRSA_set_ex_data(rsa, hndidx_rsa, hptr);\\r\\nreturn hptr;\\r\\nerr:\\r\\nmpz_clear(hptr->n);\\r\\nmpz_clear(hptr->d);\\r\\nmpz_clear(hptr->e);\\r\\nmpz_clear(hptr->p);\\r\\nmpz_clear(hptr->q);\\r\\nmpz_clear(hptr->dmp1);\\r\\nmpz_clear(hptr->dmq1);\\r\\nmpz_clear(hptr->iqmp);\\r\\nmpz_clear(hptr->r0);\\r\\nmpz_clear(hptr->r1);\\r\\nmpz_clear(hptr->I0);\\r\\nmpz_clear(hptr->m1);\\r\\nOPENSSL_free(hptr);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int e_gmp_rsa_finish(RSA *rsa)\\r\\n{\\r\\nE_GMP_RSA_CTX *hptr = RSA_get_ex_data(rsa, hndidx_rsa);\\r\\nif(!hptr) return 0;\\r\\nmpz_clear(hptr->n);\\r\\nmpz_clear(hptr->d);\\r\\nmpz_clear(hptr->e);\\r\\nmpz_clear(hptr->p);\\r\\nmpz_clear(hptr->q);\\r\\nmpz_clear(hptr->dmp1);\\r\\nmpz_clear(hptr->dmq1);\\r\\nmpz_clear(hptr->iqmp);\\r\\nmpz_clear(hptr->r0);\\r\\nmpz_clear(hptr->r1);\\r\\nmpz_clear(hptr->I0);\\r\\nmpz_clear(hptr->m1);\\r\\nOPENSSL_free(hptr);\\r\\nRSA_set_ex_data(rsa, hndidx_rsa, NULL);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int e_gmp_rsa_mod_exp(BIGNUM *r, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nE_GMP_RSA_CTX *hptr;\\r\\nint to_return = 0;\\r\\nhptr = e_gmp_get_rsa(rsa);\\r\\nif(!hptr)\\r\\n{\\r\\nGMPerr(GMP_F_E_GMP_RSA_MOD_EXP,\\r\\nGMP_R_KEY_CONTEXT_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(hptr->public_only)\\r\\n{\\r\\nGMPerr(GMP_F_E_GMP_RSA_MOD_EXP,\\r\\nGMP_R_MISSING_KEY_COMPONENTS);\\r\\nreturn 0;\\r\\n}\\r\\nif(!bn2gmp(I, hptr->I0))\\r\\nreturn 0;\\r\\nmpz_mod(hptr->r1, hptr->I0, hptr->q);\\r\\nmpz_powm(hptr->m1, hptr->r1, hptr->dmq1, hptr->q);\\r\\nmpz_mod(hptr->r1, hptr->I0, hptr->p);\\r\\nmpz_powm(hptr->r0, hptr->r1, hptr->dmp1, hptr->p);\\r\\nmpz_sub(hptr->r0, hptr->r0, hptr->m1);\\r\\nif(mpz_sgn(hptr->r0) < 0)\\r\\nmpz_add(hptr->r0, hptr->r0, hptr->p);\\r\\nmpz_mul(hptr->r1, hptr->r0, hptr->iqmp);\\r\\nmpz_mod(hptr->r0, hptr->r1, hptr->p);\\r\\nif(mpz_sgn(hptr->r0) < 0)\\r\\nmpz_add(hptr->r0, hptr->r0, hptr->p);\\r\\nmpz_mul(hptr->r1, hptr->r0, hptr->q);\\r\\nmpz_add(hptr->r0, hptr->r1, hptr->m1);\\r\\nif(gmp2bn(hptr->r0, r))\\r\\nto_return = 1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_e_gmp_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_lib_c", "target": 0, "func": "int X509_policy_tree_level_count(const X509_POLICY_TREE *tree)\\r\\n{\\r\\nif (!tree)\\r\\nreturn 0;\\r\\nreturn tree->nlevel;\\r\\n}\\r\\nX509_POLICY_LEVEL *\\r\\nX509_policy_tree_get0_level(const X509_POLICY_TREE *tree, int i)\\r\\n{\\r\\nif (!tree || (i < 0) || (i >= tree->nlevel))\\r\\nreturn NULL;\\r\\nreturn tree->levels + i;\\r\\n}\\r\\nX509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level, int i)\\r\\n{\\r\\nif (!level)\\r\\nreturn NULL;\\r\\nif (level->anyPolicy)\\r\\n{\\r\\nif (i == 0)\\r\\nreturn level->anyPolicy;\\r\\ni--;\\r\\n}\\r\\nreturn sk_X509_POLICY_NODE_value(level->nodes, i);\\r\\n}\\r\\nconst ASN1_OBJECT *X509_policy_node_get0_policy(const X509_POLICY_NODE *node)\\r\\n{\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nreturn node->data->valid_policy;\\r\\n}\\r\\nX509_POLICY_NODE *\\r\\nX509_policy_node_get0_parent(const X509_POLICY_NODE *node)\\r\\n{\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nreturn node->parent;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_req_c", "target": 0, "func": "X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nX509_REQ *ret;\\r\\nX509_REQ_INFO *ri;\\r\\nint i;\\r\\nEVP_PKEY *pktmp;\\r\\nret=X509_REQ_new();\\r\\nif (ret == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_TO_X509_REQ,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nri=ret->req_info;\\r\\nri->version->length=1;\\r\\nri->version->data=(unsigned char *)OPENSSL_malloc(1);\\r\\nif (ri->version->data == NULL) goto err;\\r\\nri->version->data[0]=0;\\r\\nif (!X509_REQ_set_subject_name(ret,X509_get_subject_name(x)))\\r\\ngoto err;\\r\\npktmp = X509_get_pubkey(x);\\r\\ni=X509_REQ_set_pubkey(ret,pktmp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!i) goto err;\\r\\nif (pkey != NULL)\\r\\n{\\r\\nif (!X509_REQ_sign(ret,pkey,md))\\r\\ngoto err;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nX509_REQ_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req)\\r\\n{\\r\\nif ((req == NULL) || (req->req_info == NULL))\\r\\nreturn(NULL);\\r\\nreturn(X509_PUBKEY_get(req->req_info->pubkey));\\r\\n}\\r\\nint X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)\\r\\n{\\r\\nEVP_PKEY *xk=NULL;\\r\\nint ok=0;\\r\\nxk=X509_REQ_get_pubkey(x);\\r\\nswitch (EVP_PKEY_cmp(xk, k))\\r\\n{\\r\\ncase 1:\\r\\nok=1;\\r\\nbreak;\\r\\ncase 0:\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,X509_R_KEY_VALUES_MISMATCH);\\r\\nbreak;\\r\\ncase -1:\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,X509_R_KEY_TYPE_MISMATCH);\\r\\nbreak;\\r\\ncase -2:\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (k->type == EVP_PKEY_EC)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (k->type == EVP_PKEY_DH)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,X509_R_CANT_CHECK_DH_KEY);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,X509_R_UNKNOWN_KEY_TYPE);\\r\\n}\\r\\nEVP_PKEY_free(xk);\\r\\nreturn(ok);\\r\\n}\\r\\nint X509_REQ_extension_nid(int req_nid)\\r\\n{\\r\\nint i, nid;\\r\\nfor(i = 0; ; i++) {\\r\\nnid = ext_nids[i];\\r\\nif(nid == NID_undef) return 0;\\r\\nelse if (req_nid == nid) return 1;\\r\\n}\\r\\n}\\r\\nint *X509_REQ_get_extension_nids(void)\\r\\n{\\r\\nreturn ext_nids;\\r\\n}\\r\\nvoid X509_REQ_set_extension_nids(int *nids)\\r\\n{\\r\\next_nids = nids;\\r\\n}\\r\\nint X509_REQ_get_attr_count(const X509_REQ *req)\\r\\n{\\r\\nreturn X509at_get_attr_count(req->req_info->attributes);\\r\\n}\\r\\nint X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);\\r\\n}\\r\\nint X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(req->req_info->attributes, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(req->req_info->attributes, loc);\\r\\n}\\r\\nint X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif(X509at_add1_attr(&req->req_info->attributes, attr)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_NID(X509_REQ *req,\\r\\nint nid, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_NID(&req->req_info->attributes, nid,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_txt(X509_REQ *req,\\r\\nconst char *attrname, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif(X509at_add1_attr_by_txt(&req->req_info->attributes, attrname,\\r\\ntype, bytes, len)) return 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_gf2m_c", "target": 0, "func": "static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[4], top1b = a >> 7;\\r\\nregister BN_ULONG a1, a2;\\r\\na1 = a & (0x7F); a2 = a1 << 1;\\r\\ntab[0] = 0; tab[1] = a1; tab[2] = a2; tab[3] = a1^a2;\\r\\ns = tab[b & 0x3]; l = s;\\r\\ns = tab[b >> 2 & 0x3]; l ^= s << 2; h = s >> 6;\\r\\ns = tab[b >> 4 & 0x3]; l ^= s << 4; h ^= s >> 4;\\r\\ns = tab[b >> 6 ]; l ^= s << 6; h ^= s >> 2;\\r\\nif (top1b & 01) { l ^= b << 7; h ^= b >> 1; }\\r\\n*r1 = h; *r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[4], top1b = a >> 15;\\r\\nregister BN_ULONG a1, a2;\\r\\na1 = a & (0x7FFF); a2 = a1 << 1;\\r\\ntab[0] = 0; tab[1] = a1; tab[2] = a2; tab[3] = a1^a2;\\r\\ns = tab[b & 0x3]; l = s;\\r\\ns = tab[b >> 2 & 0x3]; l ^= s << 2; h = s >> 14;\\r\\ns = tab[b >> 4 & 0x3]; l ^= s << 4; h ^= s >> 12;\\r\\ns = tab[b >> 6 & 0x3]; l ^= s << 6; h ^= s >> 10;\\r\\ns = tab[b >> 8 & 0x3]; l ^= s << 8; h ^= s >> 8;\\r\\ns = tab[b >>10 & 0x3]; l ^= s << 10; h ^= s >> 6;\\r\\ns = tab[b >>12 & 0x3]; l ^= s << 12; h ^= s >> 4;\\r\\ns = tab[b >>14 ]; l ^= s << 14; h ^= s >> 2;\\r\\nif (top1b & 01) { l ^= b << 15; h ^= b >> 1; }\\r\\n*r1 = h; *r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[8], top2b = a >> 30;\\r\\nregister BN_ULONG a1, a2, a4;\\r\\na1 = a & (0x3FFFFFFF); a2 = a1 << 1; a4 = a2 << 1;\\r\\ntab[0] = 0; tab[1] = a1; tab[2] = a2; tab[3] = a1^a2;\\r\\ntab[4] = a4; tab[5] = a1^a4; tab[6] = a2^a4; tab[7] = a1^a2^a4;\\r\\ns = tab[b & 0x7]; l = s;\\r\\ns = tab[b >> 3 & 0x7]; l ^= s << 3; h = s >> 29;\\r\\ns = tab[b >> 6 & 0x7]; l ^= s << 6; h ^= s >> 26;\\r\\ns = tab[b >> 9 & 0x7]; l ^= s << 9; h ^= s >> 23;\\r\\ns = tab[b >> 12 & 0x7]; l ^= s << 12; h ^= s >> 20;\\r\\ns = tab[b >> 15 & 0x7]; l ^= s << 15; h ^= s >> 17;\\r\\ns = tab[b >> 18 & 0x7]; l ^= s << 18; h ^= s >> 14;\\r\\ns = tab[b >> 21 & 0x7]; l ^= s << 21; h ^= s >> 11;\\r\\ns = tab[b >> 24 & 0x7]; l ^= s << 24; h ^= s >> 8;\\r\\ns = tab[b >> 27 & 0x7]; l ^= s << 27; h ^= s >> 5;\\r\\ns = tab[b >> 30 ]; l ^= s << 30; h ^= s >> 2;\\r\\nif (top2b & 01) { l ^= b << 30; h ^= b >> 2; }\\r\\nif (top2b & 02) { l ^= b << 31; h ^= b >> 1; }\\r\\n*r1 = h; *r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a, const BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[16], top3b = a >> 61;\\r\\nregister BN_ULONG a1, a2, a4, a8;\\r\\na1 = a & (0x1FFFFFFFFFFFFFFFULL); a2 = a1 << 1; a4 = a2 << 1; a8 = a4 << 1;\\r\\ntab[ 0] = 0; tab[ 1] = a1; tab[ 2] = a2; tab[ 3] = a1^a2;\\r\\ntab[ 4] = a4; tab[ 5] = a1^a4; tab[ 6] = a2^a4; tab[ 7] = a1^a2^a4;\\r\\ntab[ 8] = a8; tab[ 9] = a1^a8; tab[10] = a2^a8; tab[11] = a1^a2^a8;\\r\\ntab[12] = a4^a8; tab[13] = a1^a4^a8; tab[14] = a2^a4^a8; tab[15] = a1^a2^a4^a8;\\r\\ns = tab[b & 0xF]; l = s;\\r\\ns = tab[b >> 4 & 0xF]; l ^= s << 4; h = s >> 60;\\r\\ns = tab[b >> 8 & 0xF]; l ^= s << 8; h ^= s >> 56;\\r\\ns = tab[b >> 12 & 0xF]; l ^= s << 12; h ^= s >> 52;\\r\\ns = tab[b >> 16 & 0xF]; l ^= s << 16; h ^= s >> 48;\\r\\ns = tab[b >> 20 & 0xF]; l ^= s << 20; h ^= s >> 44;\\r\\ns = tab[b >> 24 & 0xF]; l ^= s << 24; h ^= s >> 40;\\r\\ns = tab[b >> 28 & 0xF]; l ^= s << 28; h ^= s >> 36;\\r\\ns = tab[b >> 32 & 0xF]; l ^= s << 32; h ^= s >> 32;\\r\\ns = tab[b >> 36 & 0xF]; l ^= s << 36; h ^= s >> 28;\\r\\ns = tab[b >> 40 & 0xF]; l ^= s << 40; h ^= s >> 24;\\r\\ns = tab[b >> 44 & 0xF]; l ^= s << 44; h ^= s >> 20;\\r\\ns = tab[b >> 48 & 0xF]; l ^= s << 48; h ^= s >> 16;\\r\\ns = tab[b >> 52 & 0xF]; l ^= s << 52; h ^= s >> 12;\\r\\ns = tab[b >> 56 & 0xF]; l ^= s << 56; h ^= s >> 8;\\r\\ns = tab[b >> 60 ]; l ^= s << 60; h ^= s >> 4;\\r\\nif (top3b & 01) { l ^= b << 61; h ^= b >> 3; }\\r\\nif (top3b & 02) { l ^= b << 62; h ^= b >> 2; }\\r\\nif (top3b & 04) { l ^= b << 63; h ^= b >> 1; }\\r\\n*r1 = h; *r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_2x2(BN_ULONG *r, const BN_ULONG a1, const BN_ULONG a0, const BN_ULONG b1, const BN_ULONG b0)\\r\\n{\\r\\nBN_ULONG m1, m0;\\r\\nbn_GF2m_mul_1x1(r+3, r+2, a1, b1);\\r\\nbn_GF2m_mul_1x1(r+1, r, a0, b0);\\r\\nbn_GF2m_mul_1x1(&m1, &m0, a0 ^ a1, b0 ^ b1);\\r\\nr[2] ^= m1 ^ r[1] ^ r[3];\\r\\nr[1] = r[3] ^ r[2] ^ r[0] ^ m1 ^ m0;\\r\\n}\\r\\nint BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nconst BIGNUM *at, *bt;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top) { at = b; bt = a; }\\r\\nelse { at = a; bt = b; }\\r\\nbn_wexpand(r, at->top);\\r\\nfor (i = 0; i < bt->top; i++)\\r\\n{\\r\\nr->d[i] = at->d[i] ^ bt->d[i];\\r\\n}\\r\\nfor (; i < at->top; i++)\\r\\n{\\r\\nr->d[i] = at->d[i];\\r\\n}\\r\\nr->top = at->top;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[])\\r\\n{\\r\\nint j, k;\\r\\nint n, dN, d0, d1;\\r\\nBN_ULONG zz, *z;\\r\\nbn_check_top(a);\\r\\nif (!p[0])\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nif (a != r)\\r\\n{\\r\\nif (!bn_wexpand(r, a->top)) return 0;\\r\\nfor (j = 0; j < a->top; j++)\\r\\n{\\r\\nr->d[j] = a->d[j];\\r\\n}\\r\\nr->top = a->top;\\r\\n}\\r\\nz = r->d;\\r\\ndN = p[0] / BN_BITS2;\\r\\nfor (j = r->top - 1; j > dN;)\\r\\n{\\r\\nzz = z[j];\\r\\nif (z[j] == 0) { j--; continue; }\\r\\nz[j] = 0;\\r\\nfor (k = 1; p[k] != 0; k++)\\r\\n{\\r\\nn = p[0] - p[k];\\r\\nd0 = n % BN_BITS2; d1 = BN_BITS2 - d0;\\r\\nn /= BN_BITS2;\\r\\nz[j-n] ^= (zz>>d0);\\r\\nif (d0) z[j-n-1] ^= (zz<<d1);\\r\\n}\\r\\nn = dN;\\r\\nd0 = p[0] % BN_BITS2;\\r\\nd1 = BN_BITS2 - d0;\\r\\nz[j-n] ^= (zz >> d0);\\r\\nif (d0) z[j-n-1] ^= (zz << d1);\\r\\n}\\r\\nwhile (j == dN)\\r\\n{\\r\\nd0 = p[0] % BN_BITS2;\\r\\nzz = z[dN] >> d0;\\r\\nif (zz == 0) break;\\r\\nd1 = BN_BITS2 - d0;\\r\\nif (d0) z[dN] = (z[dN] << d1) >> d1;\\r\\nz[0] ^= zz;\\r\\nfor (k = 1; p[k] != 0; k++)\\r\\n{\\r\\nBN_ULONG tmp_ulong;\\r\\nn = p[k] / BN_BITS2;\\r\\nd0 = p[k] % BN_BITS2;\\r\\nd1 = BN_BITS2 - d0;\\r\\nz[n] ^= (zz << d0);\\r\\ntmp_ulong = zz >> d1;\\r\\nif (d0 && tmp_ulong)\\r\\nz[n+1] ^= tmp_ulong;\\r\\n}\\r\\n}\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_arr(r, a, arr);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nint zlen, i, j, k, ret = 0;\\r\\nBIGNUM *s;\\r\\nBN_ULONG x1, x0, y1, y0, zz[4];\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a == b)\\r\\n{\\r\\nreturn BN_GF2m_mod_sqr_arr(r, a, p, ctx);\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((s = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nzlen = a->top + b->top + 4;\\r\\nif (!bn_wexpand(s, zlen)) goto err;\\r\\ns->top = zlen;\\r\\nfor (i = 0; i < zlen; i++) s->d[i] = 0;\\r\\nfor (j = 0; j < b->top; j += 2)\\r\\n{\\r\\ny0 = b->d[j];\\r\\ny1 = ((j+1) == b->top) ? 0 : b->d[j+1];\\r\\nfor (i = 0; i < a->top; i += 2)\\r\\n{\\r\\nx0 = a->d[i];\\r\\nx1 = ((i+1) == a->top) ? 0 : a->d[i+1];\\r\\nbn_GF2m_mul_2x2(zz, x1, x0, y1, y0);\\r\\nfor (k = 0; k < 4; k++) s->d[i+j+k] ^= zz[k];\\r\\n}\\r\\n}\\r\\nbn_correct_top(s);\\r\\nif (BN_GF2m_mod_arr(r, s, p))\\r\\nret = 1;\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_MUL,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nint i, ret = 0;\\r\\nBIGNUM *s;\\r\\nbn_check_top(a);\\r\\nBN_CTX_start(ctx);\\r\\nif ((s = BN_CTX_get(ctx)) == NULL) return 0;\\r\\nif (!bn_wexpand(s, 2 * a->top)) goto err;\\r\\nfor (i = a->top - 1; i >= 0; i--)\\r\\n{\\r\\ns->d[2*i+1] = SQR1(a->d[i]);\\r\\ns->d[2*i ] = SQR0(a->d[i]);\\r\\n}\\r\\ns->top = 2 * a->top;\\r\\nbn_correct_top(s);\\r\\nif (!BN_GF2m_mod_arr(r, s, p)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_SQR,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_sqr_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *b, *c, *u, *v, *tmp;\\r\\nint ret = 0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nc = BN_CTX_get(ctx);\\r\\nu = BN_CTX_get(ctx);\\r\\nv = BN_CTX_get(ctx);\\r\\nif (v == NULL) goto err;\\r\\nif (!BN_one(b)) goto err;\\r\\nif (!BN_GF2m_mod(u, a, p)) goto err;\\r\\nif (!BN_copy(v, p)) goto err;\\r\\nif (BN_is_zero(u)) goto err;\\r\\nwhile (1)\\r\\n{\\r\\nwhile (!BN_is_odd(u))\\r\\n{\\r\\nif (!BN_rshift1(u, u)) goto err;\\r\\nif (BN_is_odd(b))\\r\\n{\\r\\nif (!BN_GF2m_add(b, b, p)) goto err;\\r\\n}\\r\\nif (!BN_rshift1(b, b)) goto err;\\r\\n}\\r\\nif (BN_abs_is_word(u, 1)) break;\\r\\nif (BN_num_bits(u) < BN_num_bits(v))\\r\\n{\\r\\ntmp = u; u = v; v = tmp;\\r\\ntmp = b; b = c; c = tmp;\\r\\n}\\r\\nif (!BN_GF2m_add(u, u, v)) goto err;\\r\\nif (!BN_GF2m_add(b, b, c)) goto err;\\r\\n}\\r\\nif (!BN_copy(r, b)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *field;\\r\\nint ret = 0;\\r\\nbn_check_top(xx);\\r\\nBN_CTX_start(ctx);\\r\\nif ((field = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_GF2m_arr2poly(p, field)) goto err;\\r\\nret = BN_GF2m_mod_inv(r, xx, field, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *xinv = NULL;\\r\\nint ret = 0;\\r\\nbn_check_top(y);\\r\\nbn_check_top(x);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\nxinv = BN_CTX_get(ctx);\\r\\nif (xinv == NULL) goto err;\\r\\nif (!BN_GF2m_mod_inv(xinv, x, p, ctx)) goto err;\\r\\nif (!BN_GF2m_mod_mul(r, y, xinv, p, ctx)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *a, *b, *u, *v;\\r\\nint ret = 0;\\r\\nbn_check_top(y);\\r\\nbn_check_top(x);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nu = BN_CTX_get(ctx);\\r\\nv = BN_CTX_get(ctx);\\r\\nif (v == NULL) goto err;\\r\\nif (!BN_GF2m_mod(u, y, p)) goto err;\\r\\nif (!BN_GF2m_mod(a, x, p)) goto err;\\r\\nif (!BN_copy(b, p)) goto err;\\r\\nwhile (!BN_is_odd(a))\\r\\n{\\r\\nif (!BN_rshift1(a, a)) goto err;\\r\\nif (BN_is_odd(u)) if (!BN_GF2m_add(u, u, p)) goto err;\\r\\nif (!BN_rshift1(u, u)) goto err;\\r\\n}\\r\\ndo\\r\\n{\\r\\nif (BN_GF2m_cmp(b, a) > 0)\\r\\n{\\r\\nif (!BN_GF2m_add(b, b, a)) goto err;\\r\\nif (!BN_GF2m_add(v, v, u)) goto err;\\r\\ndo\\r\\n{\\r\\nif (!BN_rshift1(b, b)) goto err;\\r\\nif (BN_is_odd(v)) if (!BN_GF2m_add(v, v, p)) goto err;\\r\\nif (!BN_rshift1(v, v)) goto err;\\r\\n} while (!BN_is_odd(b));\\r\\n}\\r\\nelse if (BN_abs_is_word(a, 1))\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nif (!BN_GF2m_add(a, a, b)) goto err;\\r\\nif (!BN_GF2m_add(u, u, v)) goto err;\\r\\ndo\\r\\n{\\r\\nif (!BN_rshift1(a, a)) goto err;\\r\\nif (BN_is_odd(u)) if (!BN_GF2m_add(u, u, p)) goto err;\\r\\nif (!BN_rshift1(u, u)) goto err;\\r\\n} while (!BN_is_odd(a));\\r\\n}\\r\\n} while (1);\\r\\nif (!BN_copy(r, u)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *field;\\r\\nint ret = 0;\\r\\nbn_check_top(yy);\\r\\nbn_check_top(xx);\\r\\nBN_CTX_start(ctx);\\r\\nif ((field = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_GF2m_arr2poly(p, field)) goto err;\\r\\nret = BN_GF2m_mod_div(r, yy, xx, field, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, i, n;\\r\\nBIGNUM *u;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (BN_is_zero(b))\\r\\nreturn(BN_one(r));\\r\\nif (BN_abs_is_word(b, 1))\\r\\nreturn (BN_copy(r, a) != NULL);\\r\\nBN_CTX_start(ctx);\\r\\nif ((u = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_GF2m_mod_arr(u, a, p)) goto err;\\r\\nn = BN_num_bits(b) - 1;\\r\\nfor (i = n - 1; i >= 0; i--)\\r\\n{\\r\\nif (!BN_GF2m_mod_sqr_arr(u, u, p, ctx)) goto err;\\r\\nif (BN_is_bit_set(b, i))\\r\\n{\\r\\nif (!BN_GF2m_mod_mul_arr(u, u, a, p, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nif (!BN_copy(r, u)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_EXP,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_exp_arr(r, a, b, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *u;\\r\\nbn_check_top(a);\\r\\nif (!p[0])\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((u = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_set_bit(u, p[0] - 1)) goto err;\\r\\nret = BN_GF2m_mod_exp_arr(r, a, u, p, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) * max)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_SQRT,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_sqrt_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const unsigned int p[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, count = 0;\\r\\nunsigned int j;\\r\\nBIGNUM *a, *z, *rho, *w, *w2, *tmp;\\r\\nbn_check_top(a_);\\r\\nif (!p[0])\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nz = BN_CTX_get(ctx);\\r\\nw = BN_CTX_get(ctx);\\r\\nif (w == NULL) goto err;\\r\\nif (!BN_GF2m_mod_arr(a, a_, p)) goto err;\\r\\nif (BN_is_zero(a))\\r\\n{\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (p[0] & 0x1)\\r\\n{\\r\\nif (!BN_copy(z, a)) goto err;\\r\\nfor (j = 1; j <= (p[0] - 1) / 2; j++)\\r\\n{\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z, z, a)) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nrho = BN_CTX_get(ctx);\\r\\nw2 = BN_CTX_get(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (tmp == NULL) goto err;\\r\\ndo\\r\\n{\\r\\nif (!BN_rand(rho, p[0], 0, 0)) goto err;\\r\\nif (!BN_GF2m_mod_arr(rho, rho, p)) goto err;\\r\\nBN_zero(z);\\r\\nif (!BN_copy(w, rho)) goto err;\\r\\nfor (j = 1; j <= p[0] - 1; j++)\\r\\n{\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx)) goto err;\\r\\nif (!BN_GF2m_mod_sqr_arr(w2, w, p, ctx)) goto err;\\r\\nif (!BN_GF2m_mod_mul_arr(tmp, w2, a, p, ctx)) goto err;\\r\\nif (!BN_GF2m_add(z, z, tmp)) goto err;\\r\\nif (!BN_GF2m_add(w, w2, rho)) goto err;\\r\\n}\\r\\ncount++;\\r\\n} while (BN_is_zero(w) && (count < MAX_ITERATIONS));\\r\\nif (BN_is_zero(w))\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR,BN_R_TOO_MANY_ITERATIONS);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_GF2m_mod_sqr_arr(w, z, p, ctx)) goto err;\\r\\nif (!BN_GF2m_add(w, z, w)) goto err;\\r\\nif (BN_GF2m_cmp(w, a))\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_NO_SOLUTION);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_copy(r, z)) goto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p);\\r\\nunsigned int *arr=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (unsigned int *)OPENSSL_malloc(sizeof(unsigned int) *\\r\\nmax)) == NULL) goto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max)\\r\\n{\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD,BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_solve_quad_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr) OPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_poly2arr(const BIGNUM *a, unsigned int p[], int max)\\r\\n{\\r\\nint i, j, k = 0;\\r\\nBN_ULONG mask;\\r\\nif (BN_is_zero(a) || !BN_is_bit_set(a, 0))\\r\\nreturn 0;\\r\\nfor (i = a->top - 1; i >= 0; i--)\\r\\n{\\r\\nif (!a->d[i])\\r\\ncontinue;\\r\\nmask = BN_TBIT;\\r\\nfor (j = BN_BITS2 - 1; j >= 0; j--)\\r\\n{\\r\\nif (a->d[i] & mask)\\r\\n{\\r\\nif (k < max) p[k] = BN_BITS2 * i + j;\\r\\nk++;\\r\\n}\\r\\nmask >>= 1;\\r\\n}\\r\\n}\\r\\nreturn k;\\r\\n}\\r\\nint BN_GF2m_arr2poly(const unsigned int p[], BIGNUM *a)\\r\\n{\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nBN_zero(a);\\r\\nfor (i = 0; p[i] != 0; i++)\\r\\n{\\r\\nBN_set_bit(a, p[i]);\\r\\n}\\r\\nBN_set_bit(a, 0);\\r\\nbn_check_top(a);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_chk_c", "target": 0, "func": "int RSA_check_key(const RSA *key)\\r\\n{\\r\\nBIGNUM *i, *j, *k, *l, *m;\\r\\nBN_CTX *ctx;\\r\\nint r;\\r\\nint ret=1;\\r\\ni = BN_new();\\r\\nj = BN_new();\\r\\nk = BN_new();\\r\\nl = BN_new();\\r\\nm = BN_new();\\r\\nctx = BN_CTX_new();\\r\\nif (i == NULL || j == NULL || k == NULL || l == NULL ||\\r\\nm == NULL || ctx == NULL)\\r\\n{\\r\\nret = -1;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nr = BN_is_prime_ex(key->p, BN_prime_checks, NULL, NULL);\\r\\nif (r != 1)\\r\\n{\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_P_NOT_PRIME);\\r\\n}\\r\\nr = BN_is_prime_ex(key->q, BN_prime_checks, NULL, NULL);\\r\\nif (r != 1)\\r\\n{\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_Q_NOT_PRIME);\\r\\n}\\r\\nr = BN_mul(i, key->p, key->q, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(i, key->n) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_N_DOES_NOT_EQUAL_P_Q);\\r\\n}\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_sub(j, key->q, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mul(l, i, j, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_gcd(m, i, j, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_div(k, NULL, l, m, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod_mul(i, key->d, key->e, k, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (!BN_is_one(i))\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_D_E_NOT_CONGRUENT_TO_1);\\r\\n}\\r\\nif (key->dmp1 != NULL && key->dmq1 != NULL && key->iqmp != NULL)\\r\\n{\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(j, key->dmp1) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_DMP1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nr = BN_sub(i, key->q, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(j, key->dmq1) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_DMQ1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nif(!BN_mod_inverse(i, key->q, key->p, ctx))\\r\\n{\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(i, key->iqmp) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_IQMP_NOT_INVERSE_OF_Q);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (i != NULL) BN_free(i);\\r\\nif (j != NULL) BN_free(j);\\r\\nif (k != NULL) BN_free(k);\\r\\nif (l != NULL) BN_free(l);\\r\\nif (m != NULL) BN_free(m);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pqueue_c", "target": 0, "func": "pitem *\\r\\npitem_new(PQ_64BIT priority, void *data)\\r\\n{\\r\\npitem *item = (pitem *) OPENSSL_malloc(sizeof(pitem));\\r\\nif (item == NULL) return NULL;\\r\\npq_64bit_init(&(item->priority));\\r\\npq_64bit_assign(&item->priority, &priority);\\r\\nitem->data = data;\\r\\nitem->next = NULL;\\r\\nreturn item;\\r\\n}\\r\\nvoid\\r\\npitem_free(pitem *item)\\r\\n{\\r\\nif (item == NULL) return;\\r\\npq_64bit_free(&(item->priority));\\r\\nOPENSSL_free(item);\\r\\n}\\r\\npqueue_s *\\r\\npqueue_new()\\r\\n{\\r\\npqueue_s *pq = (pqueue_s *) OPENSSL_malloc(sizeof(pqueue_s));\\r\\nif (pq == NULL) return NULL;\\r\\nmemset(pq, 0x00, sizeof(pqueue_s));\\r\\nreturn pq;\\r\\n}\\r\\nvoid\\r\\npqueue_free(pqueue_s *pq)\\r\\n{\\r\\nif (pq == NULL) return;\\r\\nOPENSSL_free(pq);\\r\\n}\\r\\npitem *\\r\\npqueue_insert(pqueue_s *pq, pitem *item)\\r\\n{\\r\\npitem *curr, *next;\\r\\nif (pq->items == NULL)\\r\\n{\\r\\npq->items = item;\\r\\nreturn item;\\r\\n}\\r\\nfor(curr = NULL, next = pq->items;\\r\\nnext != NULL;\\r\\ncurr = next, next = next->next)\\r\\n{\\r\\nif (pq_64bit_gt(&(next->priority), &(item->priority)))\\r\\n{\\r\\nitem->next = next;\\r\\nif (curr == NULL)\\r\\npq->items = item;\\r\\nelse\\r\\ncurr->next = item;\\r\\nreturn item;\\r\\n}\\r\\nif (pq_64bit_eq(&(item->priority), &(next->priority)))\\r\\nreturn NULL;\\r\\n}\\r\\nitem->next = NULL;\\r\\ncurr->next = item;\\r\\nreturn item;\\r\\n}\\r\\npitem *\\r\\npqueue_peek(pqueue_s *pq)\\r\\n{\\r\\nreturn pq->items;\\r\\n}\\r\\npitem *\\r\\npqueue_pop(pqueue_s *pq)\\r\\n{\\r\\npitem *item = pq->items;\\r\\nif (pq->items != NULL)\\r\\npq->items = pq->items->next;\\r\\nreturn item;\\r\\n}\\r\\npitem *\\r\\npqueue_find(pqueue_s *pq, PQ_64BIT priority)\\r\\n{\\r\\npitem *next, *prev = NULL;\\r\\npitem *found = NULL;\\r\\nif ( pq->items == NULL)\\r\\nreturn NULL;\\r\\nfor ( next = pq->items; next->next != NULL;\\r\\nprev = next, next = next->next)\\r\\n{\\r\\nif ( pq_64bit_eq(&(next->priority), &priority))\\r\\n{\\r\\nfound = next;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif ( pq_64bit_eq(&(next->priority), &priority))\\r\\nfound = next;\\r\\nif ( ! found)\\r\\nreturn NULL;\\r\\n#if 0\\r\\nif ( prev == NULL)\\r\\npq->items = next->next;\\r\\nelse\\r\\nprev->next = next->next;\\r\\n#endif\\r\\nreturn found;\\r\\n}\\r\\nvoid\\r\\npqueue_print(pqueue_s *pq)\\r\\n{\\r\\npitem *item = pq->items;\\r\\nwhile(item != NULL)\\r\\n{\\r\\nprintf(\"item\\t\" PQ_64BIT_PRINT \"\\n\", item->priority);\\r\\nitem = item->next;\\r\\n}\\r\\n}\\r\\npitem *\\r\\npqueue_iterator(pqueue_s *pq)\\r\\n{\\r\\nreturn pqueue_peek(pq);\\r\\n}\\r\\npitem *\\r\\npqueue_next(pitem **item)\\r\\n{\\r\\npitem *ret;\\r\\nif ( item == NULL || *item == NULL)\\r\\nreturn NULL;\\r\\nret = *item;\\r\\n*item = (*item)->next;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_obj_err_c", "target": 0, "func": "void ERR_load_OBJ_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,OBJ_str_functs);\\r\\nERR_load_strings(0,OBJ_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_meth_c", "target": 0, "func": "static SSL_METHOD *ssl3_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv3_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_data.ssl_connect=ssl3_connect;\\r\\nSSLv3_data.ssl_accept=ssl3_accept;\\r\\nSSLv3_data.get_ssl_method=ssl3_get_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv3_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ebcdic_c", "target": 0, "func": "void *\\r\\nebcdic2ascii(void *dest, const void *srce, size_t count)\\r\\n{\\r\\nunsigned char *udest = dest;\\r\\nconst unsigned char *usrce = srce;\\r\\nwhile (count-- != 0) {\\r\\n*udest++ = os_toascii[*usrce++];\\r\\n}\\r\\nreturn dest;\\r\\n}\\r\\nvoid *\\r\\nascii2ebcdic(void *dest, const void *srce, size_t count)\\r\\n{\\r\\nunsigned char *udest = dest;\\r\\nconst unsigned char *usrce = srce;\\r\\nwhile (count-- != 0) {\\r\\n*udest++ = os_toebcdic[*usrce++];\\r\\n}\\r\\nreturn dest;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_cl_c", "target": 0, "func": "OCSP_ONEREQ *OCSP_request_add0_id(OCSP_REQUEST *req, OCSP_CERTID *cid)\\r\\n{\\r\\nOCSP_ONEREQ *one = NULL;\\r\\nif (!(one = OCSP_ONEREQ_new())) goto err;\\r\\nif (one->reqCert) OCSP_CERTID_free(one->reqCert);\\r\\none->reqCert = cid;\\r\\nif (req &&\\r\\n!sk_OCSP_ONEREQ_push(req->tbsRequest->requestList, one))\\r\\ngoto err;\\r\\nreturn one;\\r\\nerr:\\r\\nOCSP_ONEREQ_free(one);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_request_set1_name(OCSP_REQUEST *req, X509_NAME *nm)\\r\\n{\\r\\nGENERAL_NAME *gen;\\r\\ngen = GENERAL_NAME_new();\\r\\nif (!X509_NAME_set(&gen->d.directoryName, nm))\\r\\n{\\r\\nGENERAL_NAME_free(gen);\\r\\nreturn 0;\\r\\n}\\r\\ngen->type = GEN_DIRNAME;\\r\\nif (req->tbsRequest->requestorName)\\r\\nGENERAL_NAME_free(req->tbsRequest->requestorName);\\r\\nreq->tbsRequest->requestorName = gen;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_request_add1_cert(OCSP_REQUEST *req, X509 *cert)\\r\\n{\\r\\nOCSP_SIGNATURE *sig;\\r\\nif (!req->optionalSignature)\\r\\nreq->optionalSignature = OCSP_SIGNATURE_new();\\r\\nsig = req->optionalSignature;\\r\\nif (!sig) return 0;\\r\\nif (!cert) return 1;\\r\\nif (!sig->certs && !(sig->certs = sk_X509_new_null()))\\r\\nreturn 0;\\r\\nif(!sk_X509_push(sig->certs, cert)) return 0;\\r\\nCRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_response_status(OCSP_RESPONSE *resp)\\r\\n{\\r\\nreturn ASN1_ENUMERATED_get(resp->responseStatus);\\r\\n}\\r\\nOCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *resp)\\r\\n{\\r\\nOCSP_RESPBYTES *rb;\\r\\nrb = resp->responseBytes;\\r\\nif (!rb)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NO_RESPONSE_DATA);\\r\\nreturn NULL;\\r\\n}\\r\\nif (OBJ_obj2nid(rb->responseType) != NID_id_pkix_OCSP_basic)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NOT_BASIC_RESPONSE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ASN1_item_unpack(rb->response, ASN1_ITEM_rptr(OCSP_BASICRESP));\\r\\n}\\r\\nint OCSP_resp_count(OCSP_BASICRESP *bs)\\r\\n{\\r\\nif (!bs) return -1;\\r\\nreturn sk_OCSP_SINGLERESP_num(bs->tbsResponseData->responses);\\r\\n}\\r\\nOCSP_SINGLERESP *OCSP_resp_get0(OCSP_BASICRESP *bs, int idx)\\r\\n{\\r\\nif (!bs) return NULL;\\r\\nreturn sk_OCSP_SINGLERESP_value(bs->tbsResponseData->responses, idx);\\r\\n}\\r\\nint OCSP_resp_find(OCSP_BASICRESP *bs, OCSP_CERTID *id, int last)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(OCSP_SINGLERESP) *sresp;\\r\\nOCSP_SINGLERESP *single;\\r\\nif (!bs) return -1;\\r\\nif (last < 0) last = 0;\\r\\nelse last++;\\r\\nsresp = bs->tbsResponseData->responses;\\r\\nfor (i = last; i < sk_OCSP_SINGLERESP_num(sresp); i++)\\r\\n{\\r\\nsingle = sk_OCSP_SINGLERESP_value(sresp, i);\\r\\nif (!OCSP_id_cmp(id, single->certId)) return i;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nint OCSP_single_get0_status(OCSP_SINGLERESP *single, int *reason,\\r\\nASN1_GENERALIZEDTIME **revtime,\\r\\nASN1_GENERALIZEDTIME **thisupd,\\r\\nASN1_GENERALIZEDTIME **nextupd)\\r\\n{\\r\\nint ret;\\r\\nOCSP_CERTSTATUS *cst;\\r\\nif(!single) return -1;\\r\\ncst = single->certStatus;\\r\\nret = cst->type;\\r\\nif (ret == V_OCSP_CERTSTATUS_REVOKED)\\r\\n{\\r\\nOCSP_REVOKEDINFO *rev = cst->value.revoked;\\r\\nif (revtime) *revtime = rev->revocationTime;\\r\\nif (reason)\\r\\n{\\r\\nif(rev->revocationReason)\\r\\n*reason = ASN1_ENUMERATED_get(rev->revocationReason);\\r\\nelse *reason = -1;\\r\\n}\\r\\n}\\r\\nif(thisupd) *thisupd = single->thisUpdate;\\r\\nif(nextupd) *nextupd = single->nextUpdate;\\r\\nreturn ret;\\r\\n}\\r\\nint OCSP_resp_find_status(OCSP_BASICRESP *bs, OCSP_CERTID *id, int *status,\\r\\nint *reason,\\r\\nASN1_GENERALIZEDTIME **revtime,\\r\\nASN1_GENERALIZEDTIME **thisupd,\\r\\nASN1_GENERALIZEDTIME **nextupd)\\r\\n{\\r\\nint i;\\r\\nOCSP_SINGLERESP *single;\\r\\ni = OCSP_resp_find(bs, id, -1);\\r\\nif(i < 0) return 0;\\r\\nsingle = OCSP_resp_get0(bs, i);\\r\\ni = OCSP_single_get0_status(single, reason, revtime, thisupd, nextupd);\\r\\nif(status) *status = i;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd, ASN1_GENERALIZEDTIME *nextupd, long nsec, long maxsec)\\r\\n{\\r\\nint ret = 1;\\r\\ntime_t t_now, t_tmp;\\r\\ntime(&t_now);\\r\\nif (!ASN1_GENERALIZEDTIME_check(thisupd))\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_THISUPDATE_FIELD);\\r\\nret = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nt_tmp = t_now + nsec;\\r\\nif (X509_cmp_time(thisupd, &t_tmp) > 0)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_NOT_YET_VALID);\\r\\nret = 0;\\r\\n}\\r\\nif (maxsec >= 0)\\r\\n{\\r\\nt_tmp = t_now - maxsec;\\r\\nif (X509_cmp_time(thisupd, &t_tmp) < 0)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_TOO_OLD);\\r\\nret = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!nextupd) return ret;\\r\\nif (!ASN1_GENERALIZEDTIME_check(nextupd))\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_NEXTUPDATE_FIELD);\\r\\nret = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nt_tmp = t_now - nsec;\\r\\nif (X509_cmp_time(nextupd, &t_tmp) < 0)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_EXPIRED);\\r\\nret = 0;\\r\\n}\\r\\n}\\r\\nif (ASN1_STRING_cmp(nextupd, thisupd) < 0)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE);\\r\\nret = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509cset_c", "target": 0, "func": "int X509_CRL_set_version(X509_CRL *x, long version)\\r\\n{\\r\\nif (x == NULL) return(0);\\r\\nif (x->crl->version == NULL)\\r\\n{\\r\\nif ((x->crl->version=M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ASN1_INTEGER_set(x->crl->version,version));\\r\\n}\\r\\nint X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->crl == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->crl->issuer,name));\\r\\n}\\r\\nint X509_CRL_set_lastUpdate(X509_CRL *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->crl->lastUpdate;\\r\\nif (in != tm)\\r\\n{\\r\\nin=M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_TIME_free(x->crl->lastUpdate);\\r\\nx->crl->lastUpdate=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_CRL_set_nextUpdate(X509_CRL *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->crl->nextUpdate;\\r\\nif (in != tm)\\r\\n{\\r\\nin=M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_TIME_free(x->crl->nextUpdate);\\r\\nx->crl->nextUpdate=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_CRL_sort(X509_CRL *c)\\r\\n{\\r\\nint i;\\r\\nX509_REVOKED *r;\\r\\nsk_X509_REVOKED_sort(c->crl->revoked);\\r\\nfor (i=0; i<sk_X509_REVOKED_num(c->crl->revoked); i++)\\r\\n{\\r\\nr=sk_X509_REVOKED_value(c->crl->revoked,i);\\r\\nr->sequence=i;\\r\\n}\\r\\nc->crl->enc.modified = 1;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_REVOKED_set_revocationDate(X509_REVOKED *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->revocationDate;\\r\\nif (in != tm)\\r\\n{\\r\\nin=M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_TIME_free(x->revocationDate);\\r\\nx->revocationDate=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->serialNumber;\\r\\nif (in != serial)\\r\\n{\\r\\nin=M_ASN1_INTEGER_dup(serial);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_INTEGER_free(x->serialNumber);\\r\\nx->serialNumber=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_ber_c", "target": 0, "func": "BIO_METHOD *BIO_f_ber(void)\\r\\n{\\r\\nreturn(&methods_ber);\\r\\n}\\r\\nstatic int ber_new(BIO *bi)\\r\\n{\\r\\nBIO_BER_CTX *ctx;\\r\\nctx=(BIO_BER_CTX *)OPENSSL_malloc(sizeof(BIO_BER_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nmemset((char *)ctx,0,sizeof(BIO_BER_CTX));\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ber_free(BIO *a)\\r\\n{\\r\\nBIO_BER_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_BER_CTX *)a->ptr;\\r\\nOPENSSL_cleanse(a->ptr,sizeof(BIO_BER_CTX));\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nint bio_ber_get_header(BIO *bio, BIO_BER_CTX *ctx)\\r\\n{\\r\\nchar buf[64];\\r\\nint i,j,n;\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nunsigned long length\\r\\nint tag;\\r\\nint class;\\r\\nlong max;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->buf_off != 0)\\r\\n{\\r\\np=ctx->buf;\\r\\nj=ctx->buf_off;\\r\\nn=ctx->buf_len-j;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\np[0]=p[j];\\r\\np++;\\r\\n}\\r\\nctx->buf_len-j;\\r\\nctx->buf_off=0;\\r\\n}\\r\\ni=BER_BUF_SIZE-ctx->buf_len;\\r\\nif (i)\\r\\n{\\r\\ni=BIO_read(bio->next_bio,&(ctx->buf[ctx->buf_len]),i);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\nctx->buf_len+=i;\\r\\n}\\r\\nmax=ctx->buf_len;\\r\\np=ctx->buf;\\r\\nret=ASN1_get_object(&p,&length,&tag,&class,max);\\r\\nif (ret & 0x80)\\r\\n{\\r\\nif ((ctx->buf_len < BER_BUF_SIZE) &&\\r\\n(ERR_GET_REASON(ERR_peek_error()) == ASN1_R_TOO_LONG))\\r\\n{\\r\\nERR_clear_error();\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\nif ((ctx->tag >= 0) && (ctx->tag != tag))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_BER_GET_HEADER,BIO_R_TAG_MISMATCH);\\r\\nsprintf(buf,\"tag=%d, got %d\",ctx->tag,tag);\\r\\nERR_add_error_data(1,buf);\\r\\nreturn(-1);\\r\\n}\\r\\nif (ret & 0x01)\\r\\nif (ret & V_ASN1_CONSTRUCTED)\\r\\n}\\r\\nstatic int ber_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,n;\\r\\nBIO_BER_CTX *ctx;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_BER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->finished) return(0);\\r\\nagain:\\r\\nif (ctx->num_left > 0)\\r\\n{\\r\\nif (ctx->num_left < outl)\\r\\nn=ctx->num_left;\\r\\nelse\\r\\nn=outl;\\r\\ni=BIO_read(b->next_bio,out,n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->num_left-=i;\\r\\noutl-=i;\\r\\nret+=i;\\r\\nif (ctx->num_left <= 0)\\r\\n{\\r\\nctx->depth--;\\r\\nif (ctx->depth <= 0)\\r\\nctx->finished=1;\\r\\n}\\r\\nif (outl <= 0)\\r\\nreturn(ret);\\r\\nelse\\r\\ngoto again;\\r\\n}\\r\\nelse\\r\\n{\\r\\n}\\r\\n}\\r\\nstatic int ber_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nret=inl;\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx->buf_off=0;\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ber_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_ENC_CTX *ctx,*dctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ok=1;\\r\\nctx->finished=0;\\r\\nEVP_CipherInit_ex(&(ctx->cipher),NULL,NULL,NULL,NULL,\\r\\nctx->cipher.berrypt);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=ber_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ctx->finished)\\r\\n{\\r\\nctx->finished=1;\\r\\nctx->buf_off=0;\\r\\nret=EVP_CipherFinal_ex(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=(int)ret;\\r\\nif (ret <= 0) break;\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_STATUS:\\r\\nret=(long)ctx->ok;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\ndctx=(BIO_ENC_CTX *)dbio->ptr;\\r\\nmemcpy(&(dctx->cipher),&(ctx->cipher),sizeof(ctx->cipher));\\r\\ndbio->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ber_callback_ctrl(BIO *b, int cmd, void *(*fp)())\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_set_cipher(BIO *b, EVP_CIPHER *c, unsigned char *k, unsigned char *i,\\r\\nint e)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (b == NULL) return;\\r\\nif ((b->callback != NULL) &&\\r\\n(b->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,0L) <= 0))\\r\\nreturn;\\r\\nb->init=1;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nEVP_CipherInit_ex(&(ctx->cipher),c,NULL,k,i,e);\\r\\nif (b->callback != NULL)\\r\\nb->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,1L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_att_c", "target": 0, "func": "int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype, const void *data, int len)\\r\\n{\\r\\nASN1_TYPE *ttmp;\\r\\nASN1_STRING *stmp;\\r\\nint atype;\\r\\nif (!attr) return 0;\\r\\nif(attrtype & MBSTRING_FLAG) {\\r\\nstmp = ASN1_STRING_set_by_NID(NULL, data, len, attrtype,\\r\\nOBJ_obj2nid(attr->object));\\r\\nif(!stmp) {\\r\\nX509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_ASN1_LIB);\\r\\nreturn 0;\\r\\n}\\r\\natype = stmp->type;\\r\\n} else {\\r\\nif(!(stmp = ASN1_STRING_type_new(attrtype))) goto err;\\r\\nif(!ASN1_STRING_set(stmp, data, len)) goto err;\\r\\natype = attrtype;\\r\\n}\\r\\nif(!(attr->value.set = sk_ASN1_TYPE_new_null())) goto err;\\r\\nif(!(ttmp = ASN1_TYPE_new())) goto err;\\r\\nif(!sk_ASN1_TYPE_push(attr->value.set, ttmp)) goto err;\\r\\nattr->single = 0;\\r\\nASN1_TYPE_set(ttmp, atype, stmp);\\r\\nreturn 1;\\r\\nerr:\\r\\nX509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nint X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif(!attr->single) return sk_ASN1_TYPE_num(attr->value.set);\\r\\nif(attr->value.single) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (attr == NULL) return(NULL);\\r\\nreturn(attr->object);\\r\\n}\\r\\nvoid *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,\\r\\nint atrtype, void *data)\\r\\n{\\r\\nASN1_TYPE *ttmp;\\r\\nttmp = X509_ATTRIBUTE_get0_type(attr, idx);\\r\\nif(!ttmp) return NULL;\\r\\nif(atrtype != ASN1_TYPE_get(ttmp)){\\r\\nX509err(X509_F_X509_ATTRIBUTE_GET0_DATA, X509_R_WRONG_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ttmp->value.ptr;\\r\\n}\\r\\nASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx)\\r\\n{\\r\\nif (attr == NULL) return(NULL);\\r\\nif(idx >= X509_ATTRIBUTE_count(attr)) return NULL;\\r\\nif(!attr->single) return sk_ASN1_TYPE_value(attr->value.set, idx);\\r\\nelse return attr->value.single;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p192_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,3);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ede_cbcm_enc_c", "target": 0, "func": "void DES_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *ks1, DES_key_schedule *ks2,\\r\\nDES_key_schedule *ks3, DES_cblock *ivec1, DES_cblock *ivec2,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1,m0,m1;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv1,*iv2;\\r\\niv1 = &(*ivec1)[0];\\r\\niv2 = &(*ivec2)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv1,m0);\\r\\nc2l(iv1,m1);\\r\\nc2l(iv2,tout0);\\r\\nc2l(iv2,tout1);\\r\\nfor (l-=8; l>=-7; l-=8)\\r\\n{\\r\\ntin[0]=m0;\\r\\ntin[1]=m1;\\r\\nDES_encrypt1(tin,ks3,1);\\r\\nm0=tin[0];\\r\\nm1=tin[1];\\r\\nif(l < 0)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\n}\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_encrypt1(tin,ks1,1);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\nDES_encrypt1(tin,ks2,0);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\nDES_encrypt1(tin,ks1,1);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\niv1=&(*ivec1)[0];\\r\\nl2c(m0,iv1);\\r\\nl2c(m1,iv1);\\r\\niv2=&(*ivec2)[0];\\r\\nl2c(tout0,iv2);\\r\\nl2c(tout1,iv2);\\r\\n}\\r\\nelse\\r\\n{\\r\\nregister DES_LONG t0,t1;\\r\\nc2l(iv1,m0);\\r\\nc2l(iv1,m1);\\r\\nc2l(iv2,xor0);\\r\\nc2l(iv2,xor1);\\r\\nfor (l-=8; l>=-7; l-=8)\\r\\n{\\r\\ntin[0]=m0;\\r\\ntin[1]=m1;\\r\\nDES_encrypt1(tin,ks3,1);\\r\\nm0=tin[0];\\r\\nm1=tin[1];\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nDES_encrypt1(tin,ks1,0);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\nDES_encrypt1(tin,ks2,1);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\nDES_encrypt1(tin,ks1,0);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nif(l < 0)\\r\\n{\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\n}\\r\\nelse\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\niv1=&(*ivec1)[0];\\r\\nl2c(m0,iv1);\\r\\nl2c(m1,iv1);\\r\\niv2=&(*ivec2)[0];\\r\\nl2c(xor0,iv2);\\r\\nl2c(xor1,iv2);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_sign_c", "target": 0, "func": "int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,\\r\\nASN1_BIT_STRING *signature, char *data, EVP_PKEY *pkey,\\r\\nconst EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *p,*buf_in=NULL,*buf_out=NULL;\\r\\nint i,inl=0,outl=0,outll=0;\\r\\nX509_ALGOR *a;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nif (i == 0)\\r\\na=algor1;\\r\\nelse\\r\\na=algor2;\\r\\nif (a == NULL) continue;\\r\\nif (type->pkey_type == NID_dsaWithSHA1)\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter = NULL;\\r\\n}\\r\\nelse if ((a->parameter == NULL) ||\\r\\n(a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\nif ((a->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=OBJ_nid2obj(type->pkey_type);\\r\\nif (a->algorithm == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_SIGN,ASN1_R_UNKNOWN_OBJECT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a->algorithm->length == 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_SIGN,ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ninl=i2d(data,NULL);\\r\\nbuf_in=(unsigned char *)OPENSSL_malloc((unsigned int)inl);\\r\\noutll=outl=EVP_PKEY_size(pkey);\\r\\nbuf_out=(unsigned char *)OPENSSL_malloc((unsigned int)outl);\\r\\nif ((buf_in == NULL) || (buf_out == NULL))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_SIGN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf_in;\\r\\ni2d(data,&p);\\r\\nEVP_SignInit_ex(&ctx,type, NULL);\\r\\nEVP_SignUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nif (!EVP_SignFinal(&ctx,(unsigned char *)buf_out,\\r\\n(unsigned int *)&outl,pkey))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_SIGN,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->data != NULL) OPENSSL_free(signature->data);\\r\\nsignature->data=buf_out;\\r\\nbuf_out=NULL;\\r\\nsignature->length=outl;\\r\\nsignature->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nsignature->flags|=ASN1_STRING_FLAG_BITS_LEFT;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (buf_in != NULL)\\r\\n{ OPENSSL_cleanse((char *)buf_in,(unsigned int)inl); OPENSSL_free(buf_in); }\\r\\nif (buf_out != NULL)\\r\\n{ OPENSSL_cleanse((char *)buf_out,outll); OPENSSL_free(buf_out); }\\r\\nreturn(outl);\\r\\n}\\r\\nint ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2,\\r\\nASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey,\\r\\nconst EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *buf_in=NULL,*buf_out=NULL;\\r\\nint i,inl=0,outl=0,outll=0;\\r\\nX509_ALGOR *a;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nif (i == 0)\\r\\na=algor1;\\r\\nelse\\r\\na=algor2;\\r\\nif (a == NULL) continue;\\r\\nif (type->pkey_type == NID_dsaWithSHA1 ||\\r\\ntype->pkey_type == NID_ecdsa_with_SHA1)\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter = NULL;\\r\\n}\\r\\nelse if ((a->parameter == NULL) ||\\r\\n(a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\nif ((a->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=OBJ_nid2obj(type->pkey_type);\\r\\nif (a->algorithm == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN,ASN1_R_UNKNOWN_OBJECT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a->algorithm->length == 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN,ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ninl=ASN1_item_i2d(asn,&buf_in, it);\\r\\noutll=outl=EVP_PKEY_size(pkey);\\r\\nbuf_out=(unsigned char *)OPENSSL_malloc((unsigned int)outl);\\r\\nif ((buf_in == NULL) || (buf_out == NULL))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_SignInit_ex(&ctx,type, NULL);\\r\\nEVP_SignUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nif (!EVP_SignFinal(&ctx,(unsigned char *)buf_out,\\r\\n(unsigned int *)&outl,pkey))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->data != NULL) OPENSSL_free(signature->data);\\r\\nsignature->data=buf_out;\\r\\nbuf_out=NULL;\\r\\nsignature->length=outl;\\r\\nsignature->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nsignature->flags|=ASN1_STRING_FLAG_BITS_LEFT;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (buf_in != NULL)\\r\\n{ OPENSSL_cleanse((char *)buf_in,(unsigned int)inl); OPENSSL_free(buf_in); }\\r\\nif (buf_out != NULL)\\r\\n{ OPENSSL_cleanse((char *)buf_out,outll); OPENSSL_free(buf_out); }\\r\\nreturn(outl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_b64_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar **argv;\\r\\n{\\r\\nchar *strbuf=NULL;\\r\\nunsigned char *buff=NULL,*bufsize=NULL;\\r\\nint bsize=BSIZE,verbose=0;\\r\\nint ret=1,inl;\\r\\nchar *str=NULL;\\r\\nchar *hkey=NULL,*hiv=NULL;\\r\\nint enc=1,printkey=0,i,base64=0;\\r\\nint debug=0;\\r\\nEVP_CIPHER *cipher=NULL,*c;\\r\\nchar *inf=NULL,*outf=NULL;\\r\\nBIO *in=NULL,*out=NULL,*b64=NULL,*benc=NULL,*rbio=NULL,*wbio=NULL;\\r\\n#define PROG_NAME_SIZE 39\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE);\\r\\nbase64=1;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-e\") == 0)\\r\\nenc=1;\\r\\nif (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninf= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutf= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-d\") == 0)\\r\\nenc=0;\\r\\nelse if (strcmp(*argv,\"-v\") == 0)\\r\\nverbose=1;\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\ndebug=1;\\r\\nelse if (strcmp(*argv,\"-bufsize\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nbufsize=(unsigned char *)*(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option '%s'\\n\",*argv);\\r\\nbad:\\r\\nBIO_printf(bio_err,\"options are\\n\");\\r\\nBIO_printf(bio_err,\"%-14s input file\\n\",\"-in <file>\");\\r\\nBIO_printf(bio_err,\"%-14s output file\\n\",\"-out <file>\");\\r\\nBIO_printf(bio_err,\"%-14s encode\\n\",\"-e\");\\r\\nBIO_printf(bio_err,\"%-14s decode\\n\",\"-d\");\\r\\nBIO_printf(bio_err,\"%-14s buffer size\\n\",\"-bufsize <n>\");\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (bufsize != NULL)\\r\\n{\\r\\nint i;\\r\\nunsigned long n;\\r\\nfor (n=0; *bufsize; bufsize++)\\r\\n{\\r\\ni= *bufsize;\\r\\nif ((i <= '9') && (i >= '0'))\\r\\nn=n*10+i-'0';\\r\\nelse if (i == 'k')\\r\\n{\\r\\nn*=1024;\\r\\nbufsize++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (*bufsize != '\\0')\\r\\n{\\r\\nBIO_printf(bio_err,\"invalid 'bufsize' specified.\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (n < 80) n=80;\\r\\nbsize=(int)n;\\r\\nif (verbose) BIO_printf(bio_err,\"bufsize=%d\\n\",bsize);\\r\\n}\\r\\nstrbuf=OPENSSL_malloc(SIZE);\\r\\nbuff=(unsigned char *)OPENSSL_malloc(EVP_ENCODE_LENGTH(bsize));\\r\\nif ((buff == NULL) || (strbuf == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"OPENSSL_malloc failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(in,BIO_debug_callback);\\r\\nBIO_set_callback(out,BIO_debug_callback);\\r\\nBIO_set_callback_arg(in,bio_err);\\r\\nBIO_set_callback_arg(out,bio_err);\\r\\n}\\r\\nif (inf == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,inf) <= 0)\\r\\n{\\r\\nperror(inf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outf == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outf) <= 0)\\r\\n{\\r\\nperror(outf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrbio=in;\\r\\nwbio=out;\\r\\nif (base64)\\r\\n{\\r\\nif ((b64=BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(b64,BIO_debug_callback);\\r\\nBIO_set_callback_arg(b64,bio_err);\\r\\n}\\r\\nif (enc)\\r\\nwbio=BIO_push(b64,wbio);\\r\\nelse\\r\\nrbio=BIO_push(b64,rbio);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ninl=BIO_read(rbio,(char *)buff,bsize);\\r\\nif (inl <= 0) break;\\r\\nif (BIO_write(wbio,(char *)buff,inl) != inl)\\r\\n{\\r\\nBIO_printf(bio_err,\"error writing output file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_flush(wbio);\\r\\nret=0;\\r\\nif (verbose)\\r\\n{\\r\\nBIO_printf(bio_err,\"bytes read :%8ld\\n\",BIO_number_read(in));\\r\\nBIO_printf(bio_err,\"bytes written:%8ld\\n\",BIO_number_written(out));\\r\\n}\\r\\nend:\\r\\nif (strbuf != NULL) OPENSSL_free(strbuf);\\r\\nif (buff != NULL) OPENSSL_free(buff);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (benc != NULL) BIO_free(benc);\\r\\nif (b64 != NULL) BIO_free(b64);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_digest_c", "target": 0, "func": "int ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nint i;\\r\\nunsigned char *str,*p;\\r\\ni=i2d(data,NULL);\\r\\nif ((str=(unsigned char *)OPENSSL_malloc(i)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_DIGEST,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=str;\\r\\ni2d(data,&p);\\r\\nEVP_Digest(str, i, md, len, type, NULL);\\r\\nOPENSSL_free(str);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *asn,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nint i;\\r\\nunsigned char *str = NULL;\\r\\ni=ASN1_item_i2d(asn,&str, it);\\r\\nif (!str) return(0);\\r\\nEVP_Digest(str, i, md, len, type, NULL);\\r\\nOPENSSL_free(str);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_shift_c", "target": 0, "func": "int BN_lshift1(BIGNUM *r, const BIGNUM *a)\\r\\n{\\r\\nregister BN_ULONG *ap,*rp,t,c;\\r\\nint i;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nif (r != a)\\r\\n{\\r\\nr->neg=a->neg;\\r\\nif (bn_wexpand(r,a->top+1) == NULL) return(0);\\r\\nr->top=a->top;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bn_wexpand(r,a->top+1) == NULL) return(0);\\r\\n}\\r\\nap=a->d;\\r\\nrp=r->d;\\r\\nc=0;\\r\\nfor (i=0; i<a->top; i++)\\r\\n{\\r\\nt= *(ap++);\\r\\n*(rp++)=((t<<1)|c)&BN_MASK2;\\r\\nc=(t & BN_TBIT)?1:0;\\r\\n}\\r\\nif (c)\\r\\n{\\r\\n*rp=1;\\r\\nr->top++;\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_rshift1(BIGNUM *r, const BIGNUM *a)\\r\\n{\\r\\nBN_ULONG *ap,*rp,t,c;\\r\\nint i;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nif (BN_is_zero(a))\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\nif (a != r)\\r\\n{\\r\\nif (bn_wexpand(r,a->top) == NULL) return(0);\\r\\nr->top=a->top;\\r\\nr->neg=a->neg;\\r\\n}\\r\\nap=a->d;\\r\\nrp=r->d;\\r\\nc=0;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt=ap[i];\\r\\nrp[i]=((t>>1)&BN_MASK2)|c;\\r\\nc=(t&1)?BN_TBIT:0;\\r\\n}\\r\\nbn_correct_top(r);\\r\\nbn_check_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_lshift(BIGNUM *r, const BIGNUM *a, int n)\\r\\n{\\r\\nint i,nw,lb,rb;\\r\\nBN_ULONG *t,*f;\\r\\nBN_ULONG l;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nr->neg=a->neg;\\r\\nnw=n/BN_BITS2;\\r\\nif (bn_wexpand(r,a->top+nw+1) == NULL) return(0);\\r\\nlb=n%BN_BITS2;\\r\\nrb=BN_BITS2-lb;\\r\\nf=a->d;\\r\\nt=r->d;\\r\\nt[a->top+nw]=0;\\r\\nif (lb == 0)\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\nt[nw+i]=f[i];\\r\\nelse\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nl=f[i];\\r\\nt[nw+i+1]|=(l>>rb)&BN_MASK2;\\r\\nt[nw+i]=(l<<lb)&BN_MASK2;\\r\\n}\\r\\nmemset(t,0,nw*sizeof(t[0]));\\r\\nr->top=a->top+nw+1;\\r\\nbn_correct_top(r);\\r\\nbn_check_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_rshift(BIGNUM *r, const BIGNUM *a, int n)\\r\\n{\\r\\nint i,j,nw,lb,rb;\\r\\nBN_ULONG *t,*f;\\r\\nBN_ULONG l,tmp;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nnw=n/BN_BITS2;\\r\\nrb=n%BN_BITS2;\\r\\nlb=BN_BITS2-rb;\\r\\nif (nw > a->top || a->top == 0)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\nif (r != a)\\r\\n{\\r\\nr->neg=a->neg;\\r\\nif (bn_wexpand(r,a->top-nw+1) == NULL) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (n == 0)\\r\\nreturn 1;\\r\\n}\\r\\nf= &(a->d[nw]);\\r\\nt=r->d;\\r\\nj=a->top-nw;\\r\\nr->top=j;\\r\\nif (rb == 0)\\r\\n{\\r\\nfor (i=j; i != 0; i--)\\r\\n*(t++)= *(f++);\\r\\n}\\r\\nelse\\r\\n{\\r\\nl= *(f++);\\r\\nfor (i=j-1; i != 0; i--)\\r\\n{\\r\\ntmp =(l>>rb)&BN_MASK2;\\r\\nl= *(f++);\\r\\n*(t++) =(tmp|(l<<lb))&BN_MASK2;\\r\\n}\\r\\n*(t++) =(l>>rb)&BN_MASK2;\\r\\n}\\r\\nbn_correct_top(r);\\r\\nbn_check_top(r);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_ecdsa_c", "target": 0, "func": "void ENGINE_unregister_ECDSA(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&ecdsa_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_ECDSA(void)\\r\\n{\\r\\nengine_table_cleanup(&ecdsa_table);\\r\\n}\\r\\nint ENGINE_register_ECDSA(ENGINE *e)\\r\\n{\\r\\nif(e->ecdsa_meth)\\r\\nreturn engine_table_register(&ecdsa_table,\\r\\nengine_unregister_all_ECDSA, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_ECDSA()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_ECDSA(e);\\r\\n}\\r\\nint ENGINE_set_default_ECDSA(ENGINE *e)\\r\\n{\\r\\nif(e->ecdsa_meth)\\r\\nreturn engine_table_register(&ecdsa_table,\\r\\nengine_unregister_all_ECDSA, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_ECDSA(void)\\r\\n{\\r\\nreturn engine_table_select(&ecdsa_table, dummy_nid);\\r\\n}\\r\\nconst ECDSA_METHOD *ENGINE_get_ECDSA(const ENGINE *e)\\r\\n{\\r\\nreturn e->ecdsa_meth;\\r\\n}\\r\\nint ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *ecdsa_meth)\\r\\n{\\r\\ne->ecdsa_meth = ecdsa_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cfb64enc_c", "target": 0, "func": "void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister long l=length;\\r\\nregister int n= *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nDES_encrypt1(ti,schedule,DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0=ti[0]; l2c(v0,iv);\\r\\nv0=ti[1]; l2c(v0,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nDES_encrypt1(ti,schedule,DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0=ti[0]; l2c(v0,iv);\\r\\nv0=ti[1]; l2c(v0,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_p8d_c", "target": 0, "func": "PKCS8_PRIV_KEY_INFO *PKCS8_decrypt(X509_SIG *p8, const char *pass, int passlen)\\r\\n{\\r\\nreturn PKCS12_item_decrypt_d2i(p8->algor, ASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO), pass,\\r\\npasslen, p8->digest, 1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ui_compat_c", "target": 0, "func": "int _ossl_old_des_read_pw_string(char *buf,int length,const char *prompt,int verify)\\r\\n{\\r\\nreturn UI_UTIL_read_pw_string(buf, length, prompt, verify);\\r\\n}\\r\\nint _ossl_old_des_read_pw(char *buf,char *buff,int size,const char *prompt,int verify)\\r\\n{\\r\\nreturn UI_UTIL_read_pw(buf, buff, size, prompt, verify);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ofb64ede_c", "target": 0, "func": "void DES_ede3_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length,\\r\\nDES_key_schedule *k1, DES_key_schedule *k2,\\r\\nDES_key_schedule *k3, DES_cblock *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nDES_cblock d;\\r\\nregister char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nDES_encrypt3(ti,k1,k2,k3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_gendsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nDSA *dsa=NULL;\\r\\nint ret=1;\\r\\nchar *outfile=NULL;\\r\\nchar *inrand=NULL,*dsaparams=NULL;\\r\\nchar *passargout = NULL, *passout = NULL;\\r\\nBIO *out=NULL,*in=NULL;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-\") == 0)\\r\\ngoto bad;\\r\\n#ifndef OPENSSL_NO_DES\\r\\nelse if (strcmp(*argv,\"-des\") == 0)\\r\\nenc=EVP_des_cbc();\\r\\nelse if (strcmp(*argv,\"-des3\") == 0)\\r\\nenc=EVP_des_ede3_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nelse if (strcmp(*argv,\"-idea\") == 0)\\r\\nenc=EVP_idea_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nelse if (strcmp(*argv,\"-aes128\") == 0)\\r\\nenc=EVP_aes_128_cbc();\\r\\nelse if (strcmp(*argv,\"-aes192\") == 0)\\r\\nenc=EVP_aes_192_cbc();\\r\\nelse if (strcmp(*argv,\"-aes256\") == 0)\\r\\nenc=EVP_aes_256_cbc();\\r\\n#endif\\r\\nelse if (**argv != '-' && dsaparams == NULL)\\r\\n{\\r\\ndsaparams = *argv;\\r\\n}\\r\\nelse\\r\\ngoto bad;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif (dsaparams == NULL)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: gendsa [args] dsaparam-file\\n\");\\r\\nBIO_printf(bio_err,\" -out file - output the key to 'file'\\n\");\\r\\n#ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err,\" -des - encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\" -des3 - encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea - encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err,\" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e - use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\" dsaparam-file\\n\");\\r\\nBIO_printf(bio_err,\" - a DSA parameter file as generated by the dsaparam command\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(!app_passwd(bio_err, NULL, passargout, NULL, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (!(BIO_read_filename(in,dsaparams)))\\r\\n{\\r\\nperror(dsaparams);\\r\\ngoto end;\\r\\n}\\r\\nif ((dsa=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameter file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_free(in);\\r\\nin = NULL;\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL) goto end;\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nBIO_printf(bio_err,\"Generating DSA key, %d bits\\n\",\\r\\nBN_num_bits(dsa->p));\\r\\nif (!DSA_generate_key(dsa)) goto end;\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (!PEM_write_bio_DSAPrivateKey(out,dsa,enc,NULL,0,NULL, passout))\\r\\ngoto end;\\r\\nret=0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (dsa != NULL) DSA_free(dsa);\\r\\nif(passout) OPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_err_prn_c", "target": 0, "func": "void ERR_print_errors_cb(int (*cb)(const char *str, size_t len, void *u),\\r\\nvoid *u)\\r\\n{\\r\\nunsigned long l;\\r\\nchar buf[256];\\r\\nchar buf2[4096];\\r\\nconst char *file,*data;\\r\\nint line,flags;\\r\\nunsigned long es;\\r\\nes=CRYPTO_thread_id();\\r\\nwhile ((l=ERR_get_error_line_data(&file,&line,&data,&flags)) != 0)\\r\\n{\\r\\nERR_error_string_n(l, buf, sizeof buf);\\r\\nBIO_snprintf(buf2, sizeof(buf2), \"%lu:%s:%s:%d:%s\\n\", es, buf,\\r\\nfile, line, (flags & ERR_TXT_STRING) ? data : \"\");\\r\\ncb(buf2, strlen(buf2), u);\\r\\n}\\r\\n}\\r\\nstatic int print_fp(const char *str, size_t len, void *fp)\\r\\n{\\r\\nBIO bio;\\r\\nBIO_set(&bio,BIO_s_file());\\r\\nBIO_set_fp(&bio,fp,BIO_NOCLOSE);\\r\\nreturn BIO_printf(&bio, \"%s\", str);\\r\\n}\\r\\nvoid ERR_print_errors_fp(FILE *fp)\\r\\n{\\r\\nERR_print_errors_cb(print_fp, fp);\\r\\n}\\r\\nstatic int print_bio(const char *str, size_t len, void *bp)\\r\\n{\\r\\nreturn BIO_write((BIO *)bp, str, len);\\r\\n}\\r\\nvoid ERR_print_errors(BIO *bp)\\r\\n{\\r\\nERR_print_errors_cb(print_bio, bp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn1_lib_c", "target": 0, "func": "static int _asn1_check_infinite_end(const unsigned char **p, long len)\\r\\n{\\r\\nif (len <= 0)\\r\\nreturn(1);\\r\\nelse if ((len >= 2) && ((*p)[0] == 0) && ((*p)[1] == 0))\\r\\n{\\r\\n(*p)+=2;\\r\\nreturn(1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_check_infinite_end(unsigned char **p, long len)\\r\\n{\\r\\nreturn _asn1_check_infinite_end((const unsigned char **)p, len);\\r\\n}\\r\\nint ASN1_const_check_infinite_end(const unsigned char **p, long len)\\r\\n{\\r\\nreturn _asn1_check_infinite_end(p, len);\\r\\n}\\r\\nint ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\\r\\nint *pclass, long omax)\\r\\n{\\r\\nint i,ret;\\r\\nlong l;\\r\\nconst unsigned char *p= *pp;\\r\\nint tag,xclass,inf;\\r\\nlong max=omax;\\r\\nif (!max) goto err;\\r\\nret=(*p&V_ASN1_CONSTRUCTED);\\r\\nxclass=(*p&V_ASN1_PRIVATE);\\r\\ni= *p&V_ASN1_PRIMITIVE_TAG;\\r\\nif (i == V_ASN1_PRIMITIVE_TAG)\\r\\n{\\r\\np++;\\r\\nif (--max == 0) goto err;\\r\\nl=0;\\r\\nwhile (*p&0x80)\\r\\n{\\r\\nl<<=7L;\\r\\nl|= *(p++)&0x7f;\\r\\nif (--max == 0) goto err;\\r\\nif (l > (INT_MAX >> 7L)) goto err;\\r\\n}\\r\\nl<<=7L;\\r\\nl|= *(p++)&0x7f;\\r\\ntag=(int)l;\\r\\nif (--max == 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntag=i;\\r\\np++;\\r\\nif (--max == 0) goto err;\\r\\n}\\r\\n*ptag=tag;\\r\\n*pclass=xclass;\\r\\nif (!asn1_get_length(&p,&inf,plength,(int)max)) goto err;\\r\\n#if 0\\r\\nfprintf(stderr,\"p=%d + *plength=%ld > omax=%ld + *pp=%d (%d > %d)\\n\",\\r\\n(int)p,*plength,omax,(int)*pp,(int)(p+ *plength),\\r\\n(int)(omax+ *pp));\\r\\n#endif\\r\\nif (*plength > (omax - (p - *pp)))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_TOO_LONG);\\r\\nret|=0x80;\\r\\n}\\r\\n*pp=p;\\r\\nreturn(ret|inf);\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_HEADER_TOO_LONG);\\r\\nreturn(0x80);\\r\\n}\\r\\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl, int max)\\r\\n{\\r\\nconst unsigned char *p= *pp;\\r\\nunsigned long ret=0;\\r\\nunsigned int i;\\r\\nif (max-- < 1) return(0);\\r\\nif (*p == 0x80)\\r\\n{\\r\\n*inf=1;\\r\\nret=0;\\r\\np++;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*inf=0;\\r\\ni= *p&0x7f;\\r\\nif (*(p++) & 0x80)\\r\\n{\\r\\nif (i > sizeof(long))\\r\\nreturn 0;\\r\\nif (max-- == 0) return(0);\\r\\nwhile (i-- > 0)\\r\\n{\\r\\nret<<=8L;\\r\\nret|= *(p++);\\r\\nif (max-- == 0) return(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=i;\\r\\n}\\r\\nif (ret > LONG_MAX)\\r\\nreturn 0;\\r\\n*pp=p;\\r\\n*rl=(long)ret;\\r\\nreturn(1);\\r\\n}\\r\\nvoid ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,\\r\\nint xclass)\\r\\n{\\r\\nunsigned char *p= *pp;\\r\\nint i, ttag;\\r\\ni=(constructed)?V_ASN1_CONSTRUCTED:0;\\r\\ni|=(xclass&V_ASN1_PRIVATE);\\r\\nif (tag < 31)\\r\\n*(p++)=i|(tag&V_ASN1_PRIMITIVE_TAG);\\r\\nelse\\r\\n{\\r\\n*(p++)=i|V_ASN1_PRIMITIVE_TAG;\\r\\nfor(i = 0, ttag = tag; ttag > 0; i++) ttag >>=7;\\r\\nttag = i;\\r\\nwhile(i-- > 0)\\r\\n{\\r\\np[i] = tag & 0x7f;\\r\\nif(i != (ttag - 1)) p[i] |= 0x80;\\r\\ntag >>= 7;\\r\\n}\\r\\np += ttag;\\r\\n}\\r\\nif (constructed == 2)\\r\\n*(p++)=0x80;\\r\\nelse\\r\\nasn1_put_length(&p,length);\\r\\n*pp=p;\\r\\n}\\r\\nint ASN1_put_eoc(unsigned char **pp)\\r\\n{\\r\\nunsigned char *p = *pp;\\r\\n*p++ = 0;\\r\\n*p++ = 0;\\r\\n*pp = p;\\r\\nreturn 2;\\r\\n}\\r\\nstatic void asn1_put_length(unsigned char **pp, int length)\\r\\n{\\r\\nunsigned char *p= *pp;\\r\\nint i,l;\\r\\nif (length <= 127)\\r\\n*(p++)=(unsigned char)length;\\r\\nelse\\r\\n{\\r\\nl=length;\\r\\nfor (i=0; l > 0; i++)\\r\\nl>>=8;\\r\\n*(p++)=i|0x80;\\r\\nl=i;\\r\\nwhile (i-- > 0)\\r\\n{\\r\\np[i]=length&0xff;\\r\\nlength>>=8;\\r\\n}\\r\\np+=l;\\r\\n}\\r\\n*pp=p;\\r\\n}\\r\\nint ASN1_object_size(int constructed, int length, int tag)\\r\\n{\\r\\nint ret;\\r\\nret=length;\\r\\nret++;\\r\\nif (tag >= 31)\\r\\n{\\r\\nwhile (tag > 0)\\r\\n{\\r\\ntag>>=7;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nif (constructed == 2)\\r\\nreturn ret + 3;\\r\\nret++;\\r\\nif (length > 127)\\r\\n{\\r\\nwhile (length > 0)\\r\\n{\\r\\nlength>>=8;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int _asn1_Finish(ASN1_const_CTX *c)\\r\\n{\\r\\nif ((c->inf == (1|V_ASN1_CONSTRUCTED)) && (!c->eos))\\r\\n{\\r\\nif (!ASN1_const_check_infinite_end(&c->p,c->slen))\\r\\n{\\r\\nc->error=ERR_R_MISSING_ASN1_EOS;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nif ( ((c->slen != 0) && !(c->inf & 1)) ||\\r\\n((c->slen < 0) && (c->inf & 1)))\\r\\n{\\r\\nc->error=ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint asn1_Finish(ASN1_CTX *c)\\r\\n{\\r\\nreturn _asn1_Finish((ASN1_const_CTX *)c);\\r\\n}\\r\\nint asn1_const_Finish(ASN1_const_CTX *c)\\r\\n{\\r\\nreturn _asn1_Finish(c);\\r\\n}\\r\\nint asn1_GetSequence(ASN1_const_CTX *c, long *length)\\r\\n{\\r\\nconst unsigned char *q;\\r\\nq=c->p;\\r\\nc->inf=ASN1_get_object(&(c->p),&(c->slen),&(c->tag),&(c->xclass),\\r\\n*length);\\r\\nif (c->inf & 0x80)\\r\\n{\\r\\nc->error=ERR_R_BAD_GET_ASN1_OBJECT_CALL;\\r\\nreturn(0);\\r\\n}\\r\\nif (c->tag != V_ASN1_SEQUENCE)\\r\\n{\\r\\nc->error=ERR_R_EXPECTING_AN_ASN1_SEQUENCE;\\r\\nreturn(0);\\r\\n}\\r\\n(*length)-=(c->p-q);\\r\\nif (c->max && (*length < 0))\\r\\n{\\r\\nc->error=ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn(0);\\r\\n}\\r\\nif (c->inf == (1|V_ASN1_CONSTRUCTED))\\r\\nc->slen= *length+ *(c->pp)-c->p;\\r\\nc->eos=0;\\r\\nreturn(1);\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_dup(ASN1_STRING *str)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nif (str == NULL) return(NULL);\\r\\nif ((ret=ASN1_STRING_type_new(str->type)) == NULL)\\r\\nreturn(NULL);\\r\\nif (!ASN1_STRING_set(ret,str->data,str->length))\\r\\n{\\r\\nASN1_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->flags = str->flags;\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len)\\r\\n{\\r\\nunsigned char *c;\\r\\nconst char *data=_data;\\r\\nif (len < 0)\\r\\n{\\r\\nif (data == NULL)\\r\\nreturn(0);\\r\\nelse\\r\\nlen=strlen(data);\\r\\n}\\r\\nif ((str->length < len) || (str->data == NULL))\\r\\n{\\r\\nc=str->data;\\r\\nif (c == NULL)\\r\\nstr->data=OPENSSL_malloc(len+1);\\r\\nelse\\r\\nstr->data=OPENSSL_realloc(c,len+1);\\r\\nif (str->data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STRING_SET,ERR_R_MALLOC_FAILURE);\\r\\nstr->data=c;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstr->length=len;\\r\\nif (data != NULL)\\r\\n{\\r\\nmemcpy(str->data,data,len);\\r\\nstr->data[len]='\\0';\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_new(void)\\r\\n{\\r\\nreturn(ASN1_STRING_type_new(V_ASN1_OCTET_STRING));\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_type_new(int type)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nret=(ASN1_STRING *)OPENSSL_malloc(sizeof(ASN1_STRING));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STRING_TYPE_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->type=type;\\r\\nret->data=NULL;\\r\\nret->flags=0;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ASN1_STRING_free(ASN1_STRING *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif (a->data != NULL) OPENSSL_free(a->data);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nint ASN1_STRING_cmp(ASN1_STRING *a, ASN1_STRING *b)\\r\\n{\\r\\nint i;\\r\\ni=(a->length-b->length);\\r\\nif (i == 0)\\r\\n{\\r\\ni=memcmp(a->data,b->data,a->length);\\r\\nif (i == 0)\\r\\nreturn(a->type-b->type);\\r\\nelse\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\nreturn(i);\\r\\n}\\r\\nvoid asn1_add_error(const unsigned char *address, int offset)\\r\\n{\\r\\nchar buf1[DECIMAL_SIZE(address)+1],buf2[DECIMAL_SIZE(offset)+1];\\r\\nBIO_snprintf(buf1,sizeof buf1,\"%lu\",(unsigned long)address);\\r\\nBIO_snprintf(buf2,sizeof buf2,\"%d\",offset);\\r\\nERR_add_error_data(4,\"address=\",buf1,\" offset=\",buf2);\\r\\n}\\r\\nint ASN1_STRING_length(ASN1_STRING *x)\\r\\n{ return M_ASN1_STRING_length(x); }\\r\\nvoid ASN1_STRING_length_set(ASN1_STRING *x, int len)\\r\\n{ M_ASN1_STRING_length_set(x, len); return; }\\r\\nint ASN1_STRING_type(ASN1_STRING *x)\\r\\n{ return M_ASN1_STRING_type(x); }\\r\\nunsigned char * ASN1_STRING_data(ASN1_STRING *x)\\r\\n{ return M_ASN1_STRING_data(x); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_word_c", "target": 0, "func": "BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\n#ifndef BN_LLONG\\r\\nBN_ULONG ret=0;\\r\\n#else\\r\\nBN_ULLONG ret=0;\\r\\n#endif\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nw&=BN_MASK2;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\n#ifndef BN_LLONG\\r\\nret=((ret<<BN_BITS4)|((a->d[i]>>BN_BITS4)&BN_MASK2l))%w;\\r\\nret=((ret<<BN_BITS4)|(a->d[i]&BN_MASK2l))%w;\\r\\n#else\\r\\nret=(BN_ULLONG)(((ret<<(BN_ULLONG)BN_BITS2)|a->d[i])%\\r\\n(BN_ULLONG)w);\\r\\n#endif\\r\\n}\\r\\nreturn((BN_ULONG)ret);\\r\\n}\\r\\nBN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ret = 0;\\r\\nint i, j;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w)\\r\\nreturn 0;\\r\\nif (a->top == 0)\\r\\nreturn 0;\\r\\nj = BN_BITS2 - BN_num_bits_word(w);\\r\\nw <<= j;\\r\\nif (!BN_lshift(a, a, j))\\r\\nreturn 0;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nBN_ULONG l,d;\\r\\nl=a->d[i];\\r\\nd=bn_div_words(ret,l,w);\\r\\nret=(l-((d*w)&BN_MASK2))&BN_MASK2;\\r\\na->d[i]=d;\\r\\n}\\r\\nif ((a->top > 0) && (a->d[a->top-1] == 0))\\r\\na->top--;\\r\\nret >>= j;\\r\\nbn_check_top(a);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_add_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG l;\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w) return 1;\\r\\nif(BN_is_zero(a)) return BN_set_word(a, w);\\r\\nif (a->neg)\\r\\n{\\r\\na->neg=0;\\r\\ni=BN_sub_word(a,w);\\r\\nif (!BN_is_zero(a))\\r\\na->neg=!(a->neg);\\r\\nreturn(i);\\r\\n}\\r\\nif (((BN_ULONG)(a->d[a->top - 1] + 1) == 0) &&\\r\\n(bn_wexpand(a,a->top+1) == NULL))\\r\\nreturn(0);\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (i >= a->top)\\r\\nl=w;\\r\\nelse\\r\\nl=(a->d[i]+w)&BN_MASK2;\\r\\na->d[i]=l;\\r\\nif (w > l)\\r\\nw=1;\\r\\nelse\\r\\nbreak;\\r\\ni++;\\r\\n}\\r\\nif (i >= a->top)\\r\\na->top++;\\r\\nbn_check_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w) return 1;\\r\\nif(BN_is_zero(a)) return BN_set_word(a,w);\\r\\nif (a->neg)\\r\\n{\\r\\na->neg=0;\\r\\ni=BN_add_word(a,w);\\r\\na->neg=1;\\r\\nreturn(i);\\r\\n}\\r\\nif ((a->top == 1) && (a->d[0] < w))\\r\\n{\\r\\na->d[0]=w-a->d[0];\\r\\na->neg=1;\\r\\nreturn(1);\\r\\n}\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (a->d[i] >= w)\\r\\n{\\r\\na->d[i]-=w;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\na->d[i]=(a->d[i]-w)&BN_MASK2;\\r\\ni++;\\r\\nw=1;\\r\\n}\\r\\n}\\r\\nif ((a->d[i] == 0) && (i == (a->top-1)))\\r\\na->top--;\\r\\nbn_check_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_mul_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ll;\\r\\nbn_check_top(a);\\r\\nw&=BN_MASK2;\\r\\nif (a->top)\\r\\n{\\r\\nif (w == 0)\\r\\nBN_zero(a);\\r\\nelse\\r\\n{\\r\\nll=bn_mul_words(a->d,a->d,a->top,w);\\r\\nif (ll)\\r\\n{\\r\\nif (bn_wexpand(a,a->top+1) == NULL) return(0);\\r\\na->d[a->top++]=ll;\\r\\n}\\r\\n}\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_rc2_c", "target": 0, "func": "const EVP_CIPHER *EVP_rc2_64_cbc(void)\\r\\n{\\r\\nreturn(&r2_64_cbc_cipher);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc2_40_cbc(void)\\r\\n{\\r\\nreturn(&r2_40_cbc_cipher);\\r\\n}\\r\\nstatic int rc2_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC2_set_key(&data(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,data(ctx)->key_bits);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc2_meth_to_magic(EVP_CIPHER_CTX *e)\\r\\n{\\r\\nint i;\\r\\nEVP_CIPHER_CTX_ctrl(e, EVP_CTRL_GET_RC2_KEY_BITS, 0, &i);\\r\\nif (i == 128) return(RC2_128_MAGIC);\\r\\nelse if (i == 64) return(RC2_64_MAGIC);\\r\\nelse if (i == 40) return(RC2_40_MAGIC);\\r\\nelse return(0);\\r\\n}\\r\\nstatic int rc2_magic_to_meth(int i)\\r\\n{\\r\\nif (i == RC2_128_MAGIC) return 128;\\r\\nelse if (i == RC2_64_MAGIC) return 64;\\r\\nelse if (i == RC2_40_MAGIC) return 40;\\r\\nelse\\r\\n{\\r\\nEVPerr(EVP_F_RC2_MAGIC_TO_METH,EVP_R_UNSUPPORTED_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstatic int rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num=0;\\r\\nint i=0;\\r\\nint key_bits;\\r\\nunsigned int l;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nif (type != NULL)\\r\\n{\\r\\nl=EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(l <= sizeof(iv));\\r\\ni=ASN1_TYPE_get_int_octetstring(type,&num,iv,l);\\r\\nif (i != (int)l)\\r\\nreturn(-1);\\r\\nkey_bits =rc2_magic_to_meth((int)num);\\r\\nif (!key_bits)\\r\\nreturn(-1);\\r\\nif(i > 0) EVP_CipherInit_ex(c, NULL, NULL, NULL, iv, -1);\\r\\nEVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\\r\\nEVP_CIPHER_CTX_set_key_length(c, key_bits / 8);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic int rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num;\\r\\nint i=0,j;\\r\\nif (type != NULL)\\r\\n{\\r\\nnum=rc2_meth_to_magic(c);\\r\\nj=EVP_CIPHER_CTX_iv_length(c);\\r\\ni=ASN1_TYPE_set_int_octetstring(type,num,c->oiv,j);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic int rc2_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch(type)\\r\\n{\\r\\ncase EVP_CTRL_INIT:\\r\\ndata(c)->key_bits = EVP_CIPHER_CTX_key_length(c) * 8;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GET_RC2_KEY_BITS:\\r\\n*(int *)ptr = data(c)->key_bits;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_SET_RC2_KEY_BITS:\\r\\nif(arg > 0)\\r\\n{\\r\\ndata(c)->key_bits = arg;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md_rand_c", "target": 0, "func": "RAND_METHOD *RAND_SSLeay(void)\\r\\n{\\r\\nreturn(&rand_ssleay_meth);\\r\\n}\\r\\nstatic void ssleay_rand_cleanup(void)\\r\\n{\\r\\nOPENSSL_cleanse(state,sizeof(state));\\r\\nstate_num=0;\\r\\nstate_index=0;\\r\\nOPENSSL_cleanse(md,MD_DIGEST_LENGTH);\\r\\nmd_count[0]=0;\\r\\nmd_count[1]=0;\\r\\nentropy=0;\\r\\ninitialized=0;\\r\\n}\\r\\nstatic void ssleay_rand_add(const void *buf, int num, double add)\\r\\n{\\r\\nint i,j,k,st_idx;\\r\\nlong md_c[2];\\r\\nunsigned char local_md[MD_DIGEST_LENGTH];\\r\\nEVP_MD_CTX m;\\r\\nint do_not_lock;\\r\\nif (crypto_lock_rand)\\r\\n{\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_RAND2);\\r\\ndo_not_lock = (locking_thread == CRYPTO_thread_id());\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_RAND2);\\r\\n}\\r\\nelse\\r\\ndo_not_lock = 0;\\r\\nif (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nst_idx=state_index;\\r\\nmd_c[0] = md_count[0];\\r\\nmd_c[1] = md_count[1];\\r\\nmemcpy(local_md, md, sizeof md);\\r\\nstate_index += num;\\r\\nif (state_index >= STATE_SIZE)\\r\\n{\\r\\nstate_index%=STATE_SIZE;\\r\\nstate_num=STATE_SIZE;\\r\\n}\\r\\nelse if (state_num < STATE_SIZE)\\r\\n{\\r\\nif (state_index > state_num)\\r\\nstate_num=state_index;\\r\\n}\\r\\nmd_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);\\r\\nif (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nEVP_MD_CTX_init(&m);\\r\\nfor (i=0; i<num; i+=MD_DIGEST_LENGTH)\\r\\n{\\r\\nj=(num-i);\\r\\nj=(j > MD_DIGEST_LENGTH)?MD_DIGEST_LENGTH:j;\\r\\nMD_Init(&m);\\r\\nMD_Update(&m,local_md,MD_DIGEST_LENGTH);\\r\\nk=(st_idx+j)-STATE_SIZE;\\r\\nif (k > 0)\\r\\n{\\r\\nMD_Update(&m,&(state[st_idx]),j-k);\\r\\nMD_Update(&m,&(state[0]),k);\\r\\n}\\r\\nelse\\r\\nMD_Update(&m,&(state[st_idx]),j);\\r\\nMD_Update(&m,buf,j);\\r\\nMD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));\\r\\nMD_Final(&m,local_md);\\r\\nmd_c[1]++;\\r\\nbuf=(const char *)buf + j;\\r\\nfor (k=0; k<j; k++)\\r\\n{\\r\\nstate[st_idx++]^=local_md[k];\\r\\nif (st_idx >= STATE_SIZE)\\r\\nst_idx=0;\\r\\n}\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&m);\\r\\nif (!do_not_lock) CRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nfor (k = 0; k < (int)sizeof(md); k++)\\r\\n{\\r\\nmd[k] ^= local_md[k];\\r\\n}\\r\\nif (entropy < ENTROPY_NEEDED)\\r\\nentropy += add;\\r\\nif (!do_not_lock) CRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)\\r\\nassert(md_c[1] == md_count[1]);\\r\\n#endif\\r\\n}\\r\\nstatic void ssleay_rand_seed(const void *buf, int num)\\r\\n{\\r\\nssleay_rand_add(buf, num, (double)num);\\r\\n}\\r\\nstatic int ssleay_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nstatic volatile int stirred_pool = 0;\\r\\nint i,j,k,st_num,st_idx;\\r\\nint num_ceil;\\r\\nint ok;\\r\\nlong md_c[2];\\r\\nunsigned char local_md[MD_DIGEST_LENGTH];\\r\\nEVP_MD_CTX m;\\r\\n#ifndef GETPID_IS_MEANINGLESS\\r\\npid_t curr_pid = getpid();\\r\\n#endif\\r\\nint do_stir_pool = 0;\\r\\n#ifdef PREDICT\\r\\nif (rand_predictable)\\r\\n{\\r\\nstatic unsigned char val=0;\\r\\nfor (i=0; i<num; i++)\\r\\nbuf[i]=val++;\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\nif (num <= 0)\\r\\nreturn 1;\\r\\nEVP_MD_CTX_init(&m);\\r\\nnum_ceil = (1 + (num-1)/(MD_DIGEST_LENGTH/2)) * (MD_DIGEST_LENGTH/2);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND2);\\r\\nlocking_thread = CRYPTO_thread_id();\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND2);\\r\\ncrypto_lock_rand = 1;\\r\\nif (!initialized)\\r\\n{\\r\\nRAND_poll();\\r\\ninitialized = 1;\\r\\n}\\r\\nif (!stirred_pool)\\r\\ndo_stir_pool = 1;\\r\\nok = (entropy >= ENTROPY_NEEDED);\\r\\nif (!ok)\\r\\n{\\r\\nentropy -= num;\\r\\nif (entropy < 0)\\r\\nentropy = 0;\\r\\n}\\r\\nif (do_stir_pool)\\r\\n{\\r\\nint n = STATE_SIZE;\\r\\nwhile (n > 0)\\r\\n{\\r\\n#if MD_DIGEST_LENGTH > 20\\r\\n# error \"Please adjust DUMMY_SEED.\"\\r\\n#endif\\r\\n#define DUMMY_SEED \"....................\"\\r\\nssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);\\r\\nn -= MD_DIGEST_LENGTH;\\r\\n}\\r\\nif (ok)\\r\\nstirred_pool = 1;\\r\\n}\\r\\nst_idx=state_index;\\r\\nst_num=state_num;\\r\\nmd_c[0] = md_count[0];\\r\\nmd_c[1] = md_count[1];\\r\\nmemcpy(local_md, md, sizeof md);\\r\\nstate_index+=num_ceil;\\r\\nif (state_index > state_num)\\r\\nstate_index %= state_num;\\r\\nmd_count[0] += 1;\\r\\ncrypto_lock_rand = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nwhile (num > 0)\\r\\n{\\r\\nj=(num >= MD_DIGEST_LENGTH/2)?MD_DIGEST_LENGTH/2:num;\\r\\nnum-=j;\\r\\nMD_Init(&m);\\r\\n#ifndef GETPID_IS_MEANINGLESS\\r\\nif (curr_pid)\\r\\n{\\r\\nMD_Update(&m,(unsigned char*)&curr_pid,sizeof curr_pid);\\r\\ncurr_pid = 0;\\r\\n}\\r\\n#endif\\r\\nMD_Update(&m,local_md,MD_DIGEST_LENGTH);\\r\\nMD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));\\r\\n#ifndef PURIFY\\r\\nMD_Update(&m,buf,j);\\r\\n#endif\\r\\nk=(st_idx+MD_DIGEST_LENGTH/2)-st_num;\\r\\nif (k > 0)\\r\\n{\\r\\nMD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2-k);\\r\\nMD_Update(&m,&(state[0]),k);\\r\\n}\\r\\nelse\\r\\nMD_Update(&m,&(state[st_idx]),MD_DIGEST_LENGTH/2);\\r\\nMD_Final(&m,local_md);\\r\\nfor (i=0; i<MD_DIGEST_LENGTH/2; i++)\\r\\n{\\r\\nstate[st_idx++]^=local_md[i];\\r\\nif (st_idx >= st_num)\\r\\nst_idx=0;\\r\\nif (i < j)\\r\\n*(buf++)=local_md[i+MD_DIGEST_LENGTH/2];\\r\\n}\\r\\n}\\r\\nMD_Init(&m);\\r\\nMD_Update(&m,(unsigned char *)&(md_c[0]),sizeof(md_c));\\r\\nMD_Update(&m,local_md,MD_DIGEST_LENGTH);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nMD_Update(&m,md,MD_DIGEST_LENGTH);\\r\\nMD_Final(&m,md);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nEVP_MD_CTX_cleanup(&m);\\r\\nif (ok)\\r\\nreturn(1);\\r\\nelse\\r\\n{\\r\\nRANDerr(RAND_F_SSLEAY_RAND_BYTES,RAND_R_PRNG_NOT_SEEDED);\\r\\nERR_add_error_data(1, \"You need to read the OpenSSL FAQ, \"\\r\\n\"http://www.openssl.org/support/faq.html\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstatic int ssleay_rand_pseudo_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nint ret;\\r\\nunsigned long err;\\r\\nret = RAND_bytes(buf, num);\\r\\nif (ret == 0)\\r\\n{\\r\\nerr = ERR_peek_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_RAND &&\\r\\nERR_GET_REASON(err) == RAND_R_PRNG_NOT_SEEDED)\\r\\nERR_clear_error();\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssleay_rand_status(void)\\r\\n{\\r\\nint ret;\\r\\nint do_not_lock;\\r\\nif (crypto_lock_rand)\\r\\n{\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_RAND2);\\r\\ndo_not_lock = (locking_thread == CRYPTO_thread_id());\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_RAND2);\\r\\n}\\r\\nelse\\r\\ndo_not_lock = 0;\\r\\nif (!do_not_lock)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND2);\\r\\nlocking_thread = CRYPTO_thread_id();\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND2);\\r\\ncrypto_lock_rand = 1;\\r\\n}\\r\\nif (!initialized)\\r\\n{\\r\\nRAND_poll();\\r\\ninitialized = 1;\\r\\n}\\r\\nret = entropy >= ENTROPY_NEEDED;\\r\\nif (!do_not_lock)\\r\\n{\\r\\ncrypto_lock_rand = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_i2d_fp_c", "target": 0, "func": "int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_I2D_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,out,BIO_NOCLOSE);\\r\\nret=ASN1_i2d_bio(i2d,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x)\\r\\n{\\r\\nchar *b;\\r\\nunsigned char *p;\\r\\nint i,j=0,n,ret=1;\\r\\nn=i2d(x,NULL);\\r\\nb=(char *)OPENSSL_malloc(n);\\r\\nif (b == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_I2D_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)b;\\r\\ni2d(x,&p);\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(out,&(b[j]),n);\\r\\nif (i == n) break;\\r\\nif (i <= 0)\\r\\n{\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nj+=i;\\r\\nn-=i;\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_I2D_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,out,BIO_NOCLOSE);\\r\\nret=ASN1_item_i2d_bio(it,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x)\\r\\n{\\r\\nunsigned char *b = NULL;\\r\\nint i,j=0,n,ret=1;\\r\\nn = ASN1_item_i2d(x, &b, it);\\r\\nif (b == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_I2D_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(out,&(b[j]),n);\\r\\nif (i == n) break;\\r\\nif (i <= 0)\\r\\n{\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nj+=i;\\r\\nn-=i;\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_ibmca_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth2;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_ibmca_id) ||\\r\\n!ENGINE_set_name(e, engine_ibmca_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &ibmca_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &ibmca_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &ibmca_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &ibmca_rand) ||\\r\\n!ENGINE_set_destroy_function(e, ibmca_destroy) ||\\r\\n!ENGINE_set_init_function(e, ibmca_init) ||\\r\\n!ENGINE_set_finish_function(e, ibmca_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, ibmca_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, ibmca_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\nibmca_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\nibmca_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\nibmca_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\nibmca_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth2 = DSA_OpenSSL();\\r\\nibmca_dsa.dsa_do_sign = meth2->dsa_do_sign;\\r\\nibmca_dsa.dsa_sign_setup = meth2->dsa_sign_setup;\\r\\nibmca_dsa.dsa_do_verify = meth2->dsa_do_verify;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth3 = DH_OpenSSL();\\r\\nibmca_dh.generate_key = meth3->generate_key;\\r\\nibmca_dh.compute_key = meth3->compute_key;\\r\\n#endif\\r\\nERR_load_IBMCA_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_ibmca(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic\\r\\n#endif\\r\\nvoid ENGINE_load_ibmca(void)\\r\\n{\\r\\nENGINE *toadd = engine_ibmca();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int ibmca_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_IBMCA_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int get_context(ICA_ADAPTER_HANDLE *p_handle)\\r\\n{\\r\\nunsigned int status=0;\\r\\nstatus = p_icaOpenAdapter(0, p_handle);\\r\\nif(status != 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void release_context(ICA_ADAPTER_HANDLE handle)\\r\\n{\\r\\np_icaCloseAdapter(handle);\\r\\n}\\r\\nstatic int ibmca_init(ENGINE *e)\\r\\n{\\r\\nvoid (*p1)();\\r\\nvoid (*p2)();\\r\\nvoid (*p3)();\\r\\nvoid (*p4)();\\r\\nvoid (*p5)();\\r\\nif(ibmca_dso != NULL)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nibmca_dso = DSO_load(NULL, IBMCA_LIBNAME, NULL,\\r\\n0);\\r\\nif(ibmca_dso == NULL)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif(!(p1 = DSO_bind_func(\\r\\nibmca_dso, IBMCA_F1)) ||\\r\\n!(p2 = DSO_bind_func(\\r\\nibmca_dso, IBMCA_F2)) ||\\r\\n!(p3 = DSO_bind_func(\\r\\nibmca_dso, IBMCA_F3)) ||\\r\\n!(p4 = DSO_bind_func(\\r\\nibmca_dso, IBMCA_F4)) ||\\r\\n!(p5 = DSO_bind_func(\\r\\nibmca_dso, IBMCA_F5)))\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_icaOpenAdapter = (unsigned int (ICA_CALL *)())p1;\\r\\np_icaCloseAdapter = (unsigned int (ICA_CALL *)())p2;\\r\\np_icaRsaModExpo = (unsigned int (ICA_CALL *)())p3;\\r\\np_icaRandomNumberGenerate = (unsigned int (ICA_CALL *)())p4;\\r\\np_icaRsaCrt = (unsigned int (ICA_CALL *)())p5;\\r\\nif(!get_context(&handle))\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif(ibmca_dso)\\r\\nDSO_free(ibmca_dso);\\r\\np_icaOpenAdapter = NULL;\\r\\np_icaCloseAdapter = NULL;\\r\\np_icaRsaModExpo = NULL;\\r\\np_icaRandomNumberGenerate = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ibmca_finish(ENGINE *e)\\r\\n{\\r\\nif(ibmca_dso == NULL)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_FINISH,IBMCA_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nrelease_context(handle);\\r\\nif(!DSO_free(ibmca_dso))\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_FINISH,IBMCA_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nibmca_dso = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ibmca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())\\r\\n{\\r\\nint initialised = ((ibmca_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase IBMCA_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_CTRL,IBMCA_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nIBMCA_LIBNAME = (const char *)p;\\r\\nreturn 1;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nIBMCAerr(IBMCA_F_IBMCA_CTRL,IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ibmca_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *argument=NULL;\\r\\nBIGNUM *result=NULL;\\r\\nBIGNUM *key=NULL;\\r\\nint to_return;\\r\\nint inLen, outLen, tmpLen;\\r\\nICA_KEY_RSA_MODEXPO *publKey=NULL;\\r\\nunsigned int rc;\\r\\nto_return = 0;\\r\\nif(!ibmca_dso)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nargument = BN_CTX_get(ctx);\\r\\nresult = BN_CTX_get(ctx);\\r\\nkey = BN_CTX_get(ctx);\\r\\nif( !argument || !result || !key)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(argument, m->top) || !bn_wexpand(result, m->top) ||\\r\\n!bn_wexpand(key, sizeof(*publKey)/BN_BYTES))\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\npublKey = (ICA_KEY_RSA_MODEXPO *)key->d;\\r\\nif (publKey == NULL)\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\nmemset(publKey, 0, sizeof(ICA_KEY_RSA_MODEXPO));\\r\\npublKey->keyType = CORRECT_ENDIANNESS(ME_KEY_TYPE);\\r\\npublKey->keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_MODEXPO));\\r\\npublKey->expOffset = (char *) publKey->keyRecord - (char *) publKey;\\r\\noutLen = BN_num_bytes(m);\\r\\nif (outLen > 256 ) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_MEXP_LENGTH_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\npublKey->expLength = publKey->nLength = outLen;\\r\\nif (outLen < BN_num_bytes(p)){\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_UNDERFLOW_KEYRECORD);\\r\\ngoto err;\\r\\n}\\r\\nBN_bn2bin(p, &publKey->keyRecord[publKey->expLength -\\r\\nBN_num_bytes(p)]);\\r\\nBN_bn2bin(m, &publKey->keyRecord[publKey->expLength]);\\r\\npublKey->modulusBitLength = CORRECT_ENDIANNESS(publKey->nLength * 8);\\r\\npublKey->nOffset = CORRECT_ENDIANNESS(publKey->expOffset +\\r\\npublKey->expLength);\\r\\npublKey->expOffset = CORRECT_ENDIANNESS((char *) publKey->keyRecord -\\r\\n(char *) publKey);\\r\\ntmpLen = outLen;\\r\\npublKey->expLength = publKey->nLength = CORRECT_ENDIANNESS(tmpLen);\\r\\nmemset(argument->d, 0, outLen);\\r\\nBN_bn2bin(a, (unsigned char *)argument->d + outLen -\\r\\nBN_num_bytes(a));\\r\\ninLen = outLen;\\r\\nif( (rc = p_icaRsaModExpo(handle, inLen,(unsigned char *)argument->d,\\r\\npublKey, &outLen, (unsigned char *)result->d))\\r\\n!=0 )\\r\\n{\\r\\nprintf(\"rc = %d\\n\", rc);\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_REQUEST_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nBN_bin2bn((unsigned char *)result->d, outLen, r);\\r\\nto_return = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ibmca_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nint to_return = 0;\\r\\nif((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\\r\\n{\\r\\nif(!rsa->d || !rsa->n)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_RSA_MOD_EXP,\\r\\nIBMCA_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nto_return = ibmca_mod_exp(r0, I, rsa->d, rsa->n, ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\nto_return = ibmca_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\\r\\nrsa->dmq1, rsa->iqmp, ctx);\\r\\n}\\r\\nerr:\\r\\nif(ctx)\\r\\nBN_CTX_free(ctx);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ibmca_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *q, const BIGNUM *dmp1,\\r\\nconst BIGNUM *dmq1, const BIGNUM *iqmp, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *argument = NULL;\\r\\nBIGNUM *result = NULL;\\r\\nBIGNUM *key = NULL;\\r\\nint to_return = 0;\\r\\nchar *pkey=NULL;\\r\\nICA_KEY_RSA_CRT *privKey=NULL;\\r\\nint inLen, outLen;\\r\\nint rc;\\r\\nunsigned int offset, pSize, qSize;\\r\\nunsigned int keyRecordSize;\\r\\nunsigned int pbytes = BN_num_bytes(p);\\r\\nunsigned int qbytes = BN_num_bytes(q);\\r\\nunsigned int dmp1bytes = BN_num_bytes(dmp1);\\r\\nunsigned int dmq1bytes = BN_num_bytes(dmq1);\\r\\nunsigned int iqmpbytes = BN_num_bytes(iqmp);\\r\\nBN_CTX_start(ctx);\\r\\nargument = BN_CTX_get(ctx);\\r\\nresult = BN_CTX_get(ctx);\\r\\nkey = BN_CTX_get(ctx);\\r\\nif(!argument || !result || !key)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(argument, p->top + q->top) ||\\r\\n!bn_wexpand(result, p->top + q->top) ||\\r\\n!bn_wexpand(key, sizeof(*privKey)/BN_BYTES ))\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nprivKey = (ICA_KEY_RSA_CRT *)key->d;\\r\\nkeyRecordSize = pbytes+qbytes+dmp1bytes+dmq1bytes+iqmpbytes;\\r\\nif ( keyRecordSize > sizeof(privKey->keyRecord )) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif ( (qbytes + dmq1bytes) > 256 ){\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif ( pbytes + dmp1bytes > 256 ) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nmemset(privKey, 0, sizeof(ICA_KEY_RSA_CRT));\\r\\nprivKey->keyType = CORRECT_ENDIANNESS(CRT_KEY_TYPE);\\r\\nprivKey->keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_CRT));\\r\\nprivKey->modulusBitLength =\\r\\nCORRECT_ENDIANNESS(BN_num_bytes(q) * 2 * 8);\\r\\nprivKey->pLength = CORRECT_ENDIANNESS(BN_num_bytes(p)+8);\\r\\nprivKey->qLength = CORRECT_ENDIANNESS(BN_num_bytes(q));\\r\\nprivKey->dpLength = CORRECT_ENDIANNESS(BN_num_bytes(dmp1)+8);\\r\\nprivKey->dqLength = CORRECT_ENDIANNESS(BN_num_bytes(dmq1));\\r\\nprivKey->qInvLength = CORRECT_ENDIANNESS(BN_num_bytes(iqmp)+8);\\r\\noffset = (char *) privKey->keyRecord\\r\\n- (char *) privKey;\\r\\nqSize = BN_num_bytes(q);\\r\\npSize = qSize + 8;\\r\\nif ( (pbytes > pSize) || (dmp1bytes > pSize) ||\\r\\n(iqmpbytes > pSize) || ( qbytes >qSize) ||\\r\\n(dmq1bytes > qSize) ) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nprivKey->dpOffset = CORRECT_ENDIANNESS(offset);\\r\\noffset += pSize;\\r\\nprivKey->dqOffset = CORRECT_ENDIANNESS(offset);\\r\\noffset += qSize;\\r\\nprivKey->pOffset = CORRECT_ENDIANNESS(offset);\\r\\noffset += pSize;\\r\\nprivKey->qOffset = CORRECT_ENDIANNESS(offset);\\r\\noffset += qSize;\\r\\nprivKey->qInvOffset = CORRECT_ENDIANNESS(offset);\\r\\npkey = (char *) privKey->keyRecord;\\r\\nif ( pSize < pbytes ) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_UNDERFLOW_CONDITION);\\r\\ngoto err;\\r\\n}\\r\\npkey += pSize - BN_num_bytes(dmp1);\\r\\nBN_bn2bin(dmp1, pkey);\\r\\npkey += BN_num_bytes(dmp1);\\r\\nBN_bn2bin(dmq1, pkey);\\r\\npkey += qSize;\\r\\npkey += pSize - BN_num_bytes(p);\\r\\nBN_bn2bin(p, pkey);\\r\\npkey += BN_num_bytes(p);\\r\\nBN_bn2bin(q, pkey);\\r\\npkey += qSize ;\\r\\npkey += pSize - BN_num_bytes(iqmp);\\r\\nBN_bn2bin(iqmp, pkey);\\r\\noutLen = CORRECT_ENDIANNESS(privKey->qLength) * 2;\\r\\nif (outLen > 256) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OUTLEN_TO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif ( outLen < BN_num_bytes(a)) {\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_UNDERFLOW_CONDITION);\\r\\ngoto err;\\r\\n}\\r\\nBN_bn2bin(a, (unsigned char *)argument->d + outLen -\\r\\nBN_num_bytes(a));\\r\\ninLen = outLen;\\r\\nmemset(result->d, 0, outLen);\\r\\nif ( (rc = p_icaRsaCrt(handle, inLen, (unsigned char *)argument->d,\\r\\nprivKey, &outLen, (unsigned char *)result->d)) != 0)\\r\\n{\\r\\nprintf(\"rc = %d\\n\", rc);\\r\\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_REQUEST_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nBN_bin2bn((unsigned char *)result->d, outLen, r);\\r\\nto_return = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ibmca_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!ibmca_mod_exp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!ibmca_mod_exp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ibmca_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn ibmca_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int ibmca_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn ibmca_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int ibmca_mod_exp_dh(DH const *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn ibmca_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int ibmca_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nint to_return = 0;\\r\\nunsigned int ret;\\r\\nif(handle == 0)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_RAND_BYTES,IBMCA_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nret = p_icaRandomNumberGenerate(handle, num, buf);\\r\\nif (ret < 0)\\r\\n{\\r\\nIBMCAerr(IBMCA_F_IBMCA_RAND_BYTES,IBMCA_R_REQUEST_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ibmca_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_ibmca_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_all_c", "target": 0, "func": "static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)\\r\\n{\\r\\nRSA *rtmp;\\r\\nif(!key) return NULL;\\r\\nrtmp = EVP_PKEY_get1_RSA(key);\\r\\nEVP_PKEY_free(key);\\r\\nif(!rtmp) return NULL;\\r\\nif(rsa) {\\r\\nRSA_free(*rsa);\\r\\n*rsa = rtmp;\\r\\n}\\r\\nreturn rtmp;\\r\\n}\\r\\nRSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_rsa(pktmp, rsa);\\r\\n}\\r\\nRSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_rsa(pktmp, rsa);\\r\\n}\\r\\nstatic DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)\\r\\n{\\r\\nDSA *dtmp;\\r\\nif(!key) return NULL;\\r\\ndtmp = EVP_PKEY_get1_DSA(key);\\r\\nEVP_PKEY_free(key);\\r\\nif(!dtmp) return NULL;\\r\\nif(dsa) {\\r\\nDSA_free(*dsa);\\r\\n*dsa = dtmp;\\r\\n}\\r\\nreturn dtmp;\\r\\n}\\r\\nDSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_dsa(pktmp, dsa);\\r\\n}\\r\\nDSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_dsa(pktmp, dsa);\\r\\n}\\r\\nstatic EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)\\r\\n{\\r\\nEC_KEY *dtmp;\\r\\nif(!key) return NULL;\\r\\ndtmp = EVP_PKEY_get1_EC_KEY(key);\\r\\nEVP_PKEY_free(key);\\r\\nif(!dtmp) return NULL;\\r\\nif(eckey)\\r\\n{\\r\\nEC_KEY_free(*eckey);\\r\\n*eckey = dtmp;\\r\\n}\\r\\nreturn dtmp;\\r\\n}\\r\\nEC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_eckey(pktmp, key);\\r\\n}\\r\\nEC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_eckey(pktmp, eckey);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_gentm_c", "target": 0, "func": "int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *d)\\r\\n{\\r\\nstatic int min[9]={ 0, 0, 1, 1, 0, 0, 0, 0, 0};\\r\\nstatic int max[9]={99, 99,12,31,23,59,59,12,59};\\r\\nchar *a;\\r\\nint n,i,l,o;\\r\\nif (d->type != V_ASN1_GENERALIZEDTIME) return(0);\\r\\nl=d->length;\\r\\na=(char *)d->data;\\r\\no=0;\\r\\nif (l < 13) goto err;\\r\\nfor (i=0; i<7; i++)\\r\\n{\\r\\nif ((i == 6) && ((a[o] == 'Z') ||\\r\\n(a[o] == '+') || (a[o] == '-')))\\r\\n{ i++; break; }\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\n}\\r\\nif (a[o] == '.')\\r\\n{\\r\\nif (++o > l) goto err;\\r\\ni = o;\\r\\nwhile ((a[o] >= '0') && (a[o] <= '9') && (o <= l))\\r\\no++;\\r\\nif (i == o) goto err;\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-'))\\r\\n{\\r\\no++;\\r\\nif (o+4 > l) goto err;\\r\\nfor (i=7; i<9; i++)\\r\\n{\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\no++;\\r\\n}\\r\\n}\\r\\nreturn(o == l);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str)\\r\\n{\\r\\nASN1_GENERALIZEDTIME t;\\r\\nt.type=V_ASN1_GENERALIZEDTIME;\\r\\nt.length=strlen(str);\\r\\nt.data=(unsigned char *)str;\\r\\nif (ASN1_GENERALIZEDTIME_check(&t))\\r\\n{\\r\\nif (s != NULL)\\r\\n{\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str,t.length))\\r\\nreturn 0;\\r\\ns->type=V_ASN1_GENERALIZEDTIME;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,\\r\\ntime_t t)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nsize_t len = 20;\\r\\nif (s == NULL)\\r\\ns=M_ASN1_GENERALIZEDTIME_new();\\r\\nif (s == NULL)\\r\\nreturn(NULL);\\r\\nts=OPENSSL_gmtime(&t, &data);\\r\\nif (ts == NULL)\\r\\nreturn(NULL);\\r\\np=(char *)s->data;\\r\\nif ((p == NULL) || ((size_t)s->length < len))\\r\\n{\\r\\np=OPENSSL_malloc(len);\\r\\nif (p == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_GENERALIZEDTIME_SET,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (s->data != NULL)\\r\\nOPENSSL_free(s->data);\\r\\ns->data=(unsigned char *)p;\\r\\n}\\r\\nBIO_snprintf(p,len,\"%04d%02d%02d%02d%02d%02dZ\",ts->tm_year + 1900,\\r\\nts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);\\r\\ns->length=strlen(p);\\r\\ns->type=V_ASN1_GENERALIZEDTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn(s);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsaref_c", "target": 0, "func": "static int bind_rsaref(ENGINE *e)\\r\\n{\\r\\nconst RSA_METHOD *meth1;\\r\\nif(!ENGINE_set_id(e, engine_rsaref_id)\\r\\n|| !ENGINE_set_name(e, engine_rsaref_name)\\r\\n|| !ENGINE_set_RSA(e, &rsaref_rsa)\\r\\n|| !ENGINE_set_ciphers(e, rsaref_ciphers)\\r\\n|| !ENGINE_set_digests(e, rsaref_digests)\\r\\n|| !ENGINE_set_destroy_function(e, rsaref_destroy)\\r\\n|| !ENGINE_set_init_function(e, rsaref_init)\\r\\n|| !ENGINE_set_finish_function(e, rsaref_finish)\\r\\n)\\r\\nreturn 0;\\r\\nERR_load_RSAREF_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_rsaref_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_rsaref(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_rsaref(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_rsaref(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_rsaref(void)\\r\\n{\\r\\nENGINE *toadd = engine_rsaref();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int rsaref_init(ENGINE *e)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsaref_finish(ENGINE *e)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsaref_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_RSAREF_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsaref_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int bnref_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_BNREF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int RSAref_bn2bin(BIGNUM *from, unsigned char *to, int max)\\r\\n{\\r\\nint i;\\r\\ni=BN_num_bytes(from);\\r\\nif (i > max)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_BN2BIN,RSAREF_R_LEN);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(to,0,(unsigned int)max);\\r\\nif (!BN_bn2bin(from,&(to[max-i])))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic BIGNUM *RSAref_bin2bn(unsigned char *from, BIGNUM *to, int max)\\r\\n{\\r\\nint i;\\r\\nBIGNUM *ret;\\r\\nfor (i=0; i<max; i++)\\r\\nif (from[i]) break;\\r\\nret=BN_bin2bn(&(from[i]),max-i,to);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int RSAref_Public_ref2eay(RSArefPublicKey *from, RSA *to)\\r\\n{\\r\\nto->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN);\\r\\nto->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN);\\r\\nif ((to->n == NULL) || (to->e == NULL)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Public_eay2ref(RSA *from, R_RSA_PUBLIC_KEY *to)\\r\\n{\\r\\nto->bits=BN_num_bits(from->n);\\r\\nif (!RSAref_bn2bin(from->n,to->modulus,MAX_RSA_MODULUS_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->e,to->exponent,MAX_RSA_MODULUS_LEN)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Private_ref2eay(RSArefPrivateKey *from, RSA *to)\\r\\n{\\r\\nif ((to->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->d=RSAref_bin2bn(from->d,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->p=RSAref_bin2bn(from->prime[0],NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->q=RSAref_bin2bn(from->prime[1],NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->dmp1=RSAref_bin2bn(from->pexp[0],NULL,RSAref_MAX_PLEN))\\r\\n== NULL)\\r\\nreturn(0);\\r\\nif ((to->dmq1=RSAref_bin2bn(from->pexp[1],NULL,RSAref_MAX_PLEN))\\r\\n== NULL)\\r\\nreturn(0);\\r\\nif ((to->iqmp=RSAref_bin2bn(from->coef,NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Private_eay2ref(RSA *from, R_RSA_PRIVATE_KEY *to)\\r\\n{\\r\\nto->bits=BN_num_bits(from->n);\\r\\nif (!RSAref_bn2bin(from->n,to->modulus,MAX_RSA_MODULUS_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->e,to->publicExponent,MAX_RSA_MODULUS_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->d,to->exponent,MAX_RSA_MODULUS_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->p,to->prime[0],MAX_RSA_PRIME_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->q,to->prime[1],MAX_RSA_PRIME_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->dmp1,to->primeExponent[0],MAX_RSA_PRIME_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->dmq1,to->primeExponent[1],MAX_RSA_PRIME_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->iqmp,to->coefficient,MAX_RSA_PRIME_LEN)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int rsaref_private_decrypt(int len, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nR_RSA_PRIVATE_KEY RSAkey;\\r\\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPrivateDecrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_DECRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nstatic int rsaref_private_encrypt(int len, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nR_RSA_PRIVATE_KEY RSAkey;\\r\\nif (padding != RSA_PKCS1_PADDING)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPrivateEncrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nstatic int rsaref_public_decrypt(int len, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nR_RSA_PUBLIC_KEY RSAkey;\\r\\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPublicDecrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_DECRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nstatic int rsaref_public_encrypt(int len, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint outlen= -1;\\r\\nint i;\\r\\nR_RSA_PUBLIC_KEY RSAkey;\\r\\nR_RANDOM_STRUCT rnd;\\r\\nunsigned char buf[16];\\r\\nif (padding != RSA_PKCS1_PADDING && padding != RSA_SSLV23_PADDING)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nR_RandomInit(&rnd);\\r\\nR_GetRandomBytesNeeded((unsigned int *)&i,&rnd);\\r\\nwhile (i > 0)\\r\\n{\\r\\nif (RAND_bytes(buf,16) <= 0)\\r\\ngoto err;\\r\\nR_RandomUpdate(&rnd,buf,(unsigned int)((i>16)?16:i));\\r\\ni-=16;\\r\\n}\\r\\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPublicEncrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey,&rnd)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT,i);\\r\\noutlen= -1;\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nR_RandomFinal(&rnd);\\r\\nmemset(&rnd,0,sizeof(rnd));\\r\\nreturn(outlen);\\r\\n}\\r\\nstatic int rsaref_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nint ok = 1;\\r\\nif(!cipher)\\r\\n{\\r\\n*nids = rsaref_cipher_nids;\\r\\nreturn (sizeof(rsaref_cipher_nids)-1)/sizeof(rsaref_cipher_nids[0]);\\r\\n}\\r\\nswitch (nid)\\r\\n{\\r\\ncase NID_des_cbc:\\r\\n*cipher = &cipher_des_cbc; break;\\r\\ncase NID_des_ede3_cbc:\\r\\n*cipher = &cipher_des_ede3_cbc; break;\\r\\ncase NID_desx_cbc:\\r\\n*cipher = &cipher_desx_cbc; break;\\r\\ndefault:\\r\\nok = 0;\\r\\n*cipher = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nstatic int rsaref_digests(ENGINE *e, const EVP_MD **digest,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nint ok = 1;\\r\\nif(!digest)\\r\\n{\\r\\n*nids = rsaref_digest_nids;\\r\\nreturn (sizeof(rsaref_digest_nids)-1)/sizeof(rsaref_digest_nids[0]);\\r\\n}\\r\\nswitch (nid)\\r\\n{\\r\\ncase NID_md2:\\r\\n*digest = &digest_md2; break;\\r\\ncase NID_md5:\\r\\n*digest = &digest_md5; break;\\r\\ndefault:\\r\\nok = 0;\\r\\n*digest = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nstatic int cipher_des_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv, enc);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cipher_des_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nint ret = DES_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\\r\\nswitch (ret)\\r\\n{\\r\\ncase RE_LEN:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\\r\\nbreak;\\r\\ncase 0:\\r\\nbreak;\\r\\ndefault:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\\r\\n}\\r\\nreturn !ret;\\r\\n}\\r\\nstatic int cipher_des_cbc_clean(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cipher_des_ede3_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES3_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv,\\r\\nenc);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cipher_des_ede3_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nint ret = DES3_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\\r\\nswitch (ret)\\r\\n{\\r\\ncase RE_LEN:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\\r\\nbreak;\\r\\ncase 0:\\r\\nbreak;\\r\\ndefault:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\\r\\n}\\r\\nreturn !ret;\\r\\n}\\r\\nstatic int cipher_des_ede3_cbc_clean(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cipher_desx_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDESX_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv,\\r\\nenc);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cipher_desx_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nint ret = DESX_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\\r\\nswitch (ret)\\r\\n{\\r\\ncase RE_LEN:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\\r\\nbreak;\\r\\ncase 0:\\r\\nbreak;\\r\\ndefault:\\r\\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\\r\\n}\\r\\nreturn !ret;\\r\\n}\\r\\nstatic int cipher_desx_cbc_clean(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md2_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nMD2Init(data(ctx));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md2_update(EVP_MD_CTX *ctx,const void *data,\\r\\nunsigned long count)\\r\\n{\\r\\nMD2Update(data(ctx), (unsigned char *)data, (unsigned int)count);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md2_final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{\\r\\nMD2Final(md, data(ctx));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md5_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nMD5Init(data(ctx));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md5_update(EVP_MD_CTX *ctx,const void *data,\\r\\nunsigned long count)\\r\\n{\\r\\nMD5Update(data(ctx), (unsigned char *)data, (unsigned int)count);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int digest_md5_final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{\\r\\nMD5Final(md, data(ctx));\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3conf_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nLHASH *conf;\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nchar *conf_file;\\r\\nint i;\\r\\nint count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif(!argv[1]) {\\r\\nfprintf(stderr, \"Usage: v3conf cert.pem [file.cnf]\\n\");\\r\\nexit(1);\\r\\n}\\r\\nconf_file = argv[2];\\r\\nif(!conf_file) conf_file = \"test.cnf\";\\r\\nconf = CONF_load(NULL, \"test.cnf\", NULL);\\r\\nif(!conf) {\\r\\nfprintf(stderr, \"Error opening Config file %s\\n\", conf_file);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ninf = fopen(argv[1], \"r\");\\r\\nif(!inf) {\\r\\nfprintf(stderr, \"Can't open certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\ncert = PEM_read_X509(inf, NULL, NULL);\\r\\nif(!cert) {\\r\\nfprintf(stderr, \"Error reading certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\nsk_pop_free(cert->cert_info->extensions, X509_EXTENSION_free);\\r\\ncert->cert_info->extensions = NULL;\\r\\nif(!X509V3_EXT_add_conf(conf, NULL, \"test_section\", cert)) {\\r\\nfprintf(stderr, \"Error adding extensions\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor(i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif(ext->critical) printf(\",critical:\\n\");\\r\\nelse printf(\":\\n\");\\r\\nX509V3_EXT_print_fp(stdout, ext, 0, 0);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_enc_c", "target": 0, "func": "int dtls1_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs,i,ii,j,k,n=0;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send)\\r\\n{\\r\\nif (s->write_hash != NULL)\\r\\nn=EVP_MD_size(s->write_hash);\\r\\nds=s->enc_write_ctx;\\r\\nrec= &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\n{\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\nif ( rec->data != rec->input)\\r\\nfprintf(stderr, \"%s:%d: rec->data != rec->input\\n\",\\r\\n__FILE__, __LINE__);\\r\\nelse if ( EVP_CIPHER_block_size(ds->cipher) > 1)\\r\\nRAND_bytes(rec->input, EVP_CIPHER_block_size(ds->cipher));\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->read_hash != NULL)\\r\\nn=EVP_MD_size(s->read_hash);\\r\\nds=s->enc_read_ctx;\\r\\nrec= &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"dtls1_enc(%d)\\n\", send);\\r\\n#endif\\r\\nif ((s->session == NULL) || (ds == NULL) ||\\r\\n(enc == NULL))\\r\\n{\\r\\nmemmove(rec->data,rec->input,rec->length);\\r\\nrec->input=rec->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=rec->length;\\r\\nbs=EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send)\\r\\n{\\r\\ni=bs-((int)l%bs);\\r\\nj=i-1;\\r\\nif (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\nj++;\\r\\n}\\r\\nfor (k=(int)l; k<(int)(l+i); k++)\\r\\nrec->input[k]=j;\\r\\nl+=i;\\r\\nrec->length+=i;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long ui;\\r\\nprintf(\"EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\\n\",\\r\\nds,rec->data,rec->input,l);\\r\\nprintf(\"\\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\\n\",\\r\\nds->buf_len, ds->cipher->key_len,\\r\\nDES_KEY_SZ, DES_SCHEDULE_SZ,\\r\\nds->cipher->iv_len);\\r\\nprintf(\"\\t\\tIV: \");\\r\\nfor (i=0; i<ds->cipher->iv_len; i++) printf(\"%02X\", ds->iv[i]);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"\\trec->input=\");\\r\\nfor (ui=0; ui<l; ui++) printf(\" %02x\", rec->input[ui]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (!send)\\r\\n{\\r\\nif (l == 0 || l%bs != 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nEVP_Cipher(ds,rec->data,rec->input,l);\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long i;\\r\\nprintf(\"\\trec->data=\");\\r\\nfor (i=0; i<l; i++)\\r\\nprintf(\" %02x\", rec->data[i]); printf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nif ((bs != 1) && !send)\\r\\n{\\r\\nii=i=rec->data[l-1];\\r\\ni++;\\r\\nif (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif ((memcmp(s->s3->read_sequence,\\r\\n\"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) && !(ii & 1))\\r\\ns->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\ni--;\\r\\n}\\r\\nif (i > (int)rec->length)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\nfor (j=(int)(l-i); j<(int)l; j++)\\r\\n{\\r\\nif (rec->data[j] != ii)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nrec->length-=i;\\r\\nrec->data += bs;\\r\\nrec->input += bs;\\r\\nrec->length -= bs;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_lib_c", "target": 0, "func": "ENGINE *ENGINE_new(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));\\r\\nif(ret == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ret, 0, sizeof(ENGINE));\\r\\nret->struct_ref = 1;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_ENGINE, ret, &ret->ex_data);\\r\\nreturn ret;\\r\\n}\\r\\nvoid engine_set_all_null(ENGINE *e)\\r\\n{\\r\\ne->id = NULL;\\r\\ne->name = NULL;\\r\\ne->rsa_meth = NULL;\\r\\ne->dsa_meth = NULL;\\r\\ne->dh_meth = NULL;\\r\\ne->rand_meth = NULL;\\r\\ne->store_meth = NULL;\\r\\ne->ciphers = NULL;\\r\\ne->digests = NULL;\\r\\ne->destroy = NULL;\\r\\ne->init = NULL;\\r\\ne->finish = NULL;\\r\\ne->ctrl = NULL;\\r\\ne->load_privkey = NULL;\\r\\ne->load_pubkey = NULL;\\r\\ne->cmd_defns = NULL;\\r\\ne->flags = 0;\\r\\n}\\r\\nint engine_free_util(ENGINE *e, int locked)\\r\\n{\\r\\nint i;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_FREE_UTIL,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(locked)\\r\\ni = CRYPTO_add(&e->struct_ref,-1,CRYPTO_LOCK_ENGINE);\\r\\nelse\\r\\ni = --e->struct_ref;\\r\\nengine_ref_debug(e, 0, -1)\\r\\nif (i > 0) return 1;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"ENGINE_free, bad structural reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif(e->destroy)\\r\\ne->destroy(e);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ENGINE, e, &e->ex_data);\\r\\nOPENSSL_free(e);\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_free(ENGINE *e)\\r\\n{\\r\\nreturn engine_free_util(e, 1);\\r\\n}\\r\\nstatic int int_cleanup_check(int create)\\r\\n{\\r\\nif(cleanup_stack) return 1;\\r\\nif(!create) return 0;\\r\\ncleanup_stack = sk_ENGINE_CLEANUP_ITEM_new_null();\\r\\nreturn (cleanup_stack ? 1 : 0);\\r\\n}\\r\\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item = OPENSSL_malloc(sizeof(\\r\\nENGINE_CLEANUP_ITEM));\\r\\nif(!item) return NULL;\\r\\nitem->cb = cb;\\r\\nreturn item;\\r\\n}\\r\\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item;\\r\\nif(!int_cleanup_check(1)) return;\\r\\nitem = int_cleanup_item(cb);\\r\\nif(item)\\r\\nsk_ENGINE_CLEANUP_ITEM_insert(cleanup_stack, item, 0);\\r\\n}\\r\\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item;\\r\\nif(!int_cleanup_check(1)) return;\\r\\nitem = int_cleanup_item(cb);\\r\\nif(item)\\r\\nsk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);\\r\\n}\\r\\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\\r\\n{\\r\\n(*(item->cb))();\\r\\nOPENSSL_free(item);\\r\\n}\\r\\nvoid ENGINE_cleanup(void)\\r\\n{\\r\\nif(int_cleanup_check(0))\\r\\n{\\r\\nsk_ENGINE_CLEANUP_ITEM_pop_free(cleanup_stack,\\r\\nengine_cleanup_cb_free);\\r\\ncleanup_stack = NULL;\\r\\n}\\r\\nRAND_set_rand_method(NULL);\\r\\n}\\r\\nint ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ENGINE, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint ENGINE_set_ex_data(ENGINE *e, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&e->ex_data, idx, arg));\\r\\n}\\r\\nvoid *ENGINE_get_ex_data(const ENGINE *e, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&e->ex_data, idx));\\r\\n}\\r\\nint ENGINE_set_id(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_ID,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\ne->id = id;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_name(ENGINE *e, const char *name)\\r\\n{\\r\\nif(name == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_NAME,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\ne->name = name;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f)\\r\\n{\\r\\ne->destroy = destroy_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f)\\r\\n{\\r\\ne->init = init_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f)\\r\\n{\\r\\ne->finish = finish_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f)\\r\\n{\\r\\ne->ctrl = ctrl_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_flags(ENGINE *e, int flags)\\r\\n{\\r\\ne->flags = flags;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns)\\r\\n{\\r\\ne->cmd_defns = defns;\\r\\nreturn 1;\\r\\n}\\r\\nconst char *ENGINE_get_id(const ENGINE *e)\\r\\n{\\r\\nreturn e->id;\\r\\n}\\r\\nconst char *ENGINE_get_name(const ENGINE *e)\\r\\n{\\r\\nreturn e->name;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->destroy;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->init;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->finish;\\r\\n}\\r\\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->ctrl;\\r\\n}\\r\\nint ENGINE_get_flags(const ENGINE *e)\\r\\n{\\r\\nreturn e->flags;\\r\\n}\\r\\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\\r\\n{\\r\\nreturn e->cmd_defns;\\r\\n}\\r\\nvoid *ENGINE_get_static_state(void)\\r\\n{\\r\\nreturn &internal_static_hack;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret=1;\\r\\nX509_REQ *req=NULL;\\r\\nX509 *x=NULL,*xca=NULL;\\r\\nASN1_OBJECT *objtmp;\\r\\nEVP_PKEY *Upkey=NULL,*CApkey=NULL;\\r\\nASN1_INTEGER *sno = NULL;\\r\\nint i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nBIO *STDout=NULL;\\r\\nSTACK_OF(ASN1_OBJECT) *trust = NULL, *reject = NULL;\\r\\nint informat,outformat,keyformat,CAformat,CAkeyformat;\\r\\nchar *infile=NULL,*outfile=NULL,*keyfile=NULL,*CAfile=NULL;\\r\\nchar *CAkeyfile=NULL,*CAserial=NULL;\\r\\nchar *alias=NULL;\\r\\nint text=0,serial=0,subject=0,issuer=0,startdate=0,enddate=0;\\r\\nint next_serial=0;\\r\\nint subject_hash=0,issuer_hash=0,ocspid=0;\\r\\nint noout=0,sign_flag=0,CA_flag=0,CA_createserial=0,email=0;\\r\\nint trustout=0,clrtrust=0,clrreject=0,aliasout=0,clrext=0;\\r\\nint C=0;\\r\\nint x509req=0,days=DEF_DAYS,modulus=0,pubkey=0;\\r\\nint pprint = 0;\\r\\nconst char **pp;\\r\\nX509_STORE *ctx=NULL;\\r\\nX509_REQ *rq=NULL;\\r\\nint fingerprint=0;\\r\\nchar buf[256];\\r\\nconst EVP_MD *md_alg,*digest=EVP_sha1();\\r\\nCONF *extconf = NULL;\\r\\nchar *extsect = NULL, *extfile = NULL, *passin = NULL, *passargin = NULL;\\r\\nint need_rand = 0;\\r\\nint checkend=0,checkoffset=0;\\r\\nunsigned long nmflag = 0, certflag = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nreqfile=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nSTDout=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSTDout = BIO_push(tmpbio, STDout);\\r\\n}\\r\\n#endif\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nkeyformat=FORMAT_PEM;\\r\\nCAformat=FORMAT_PEM;\\r\\nCAkeyformat=FORMAT_PEM;\\r\\nctx=X509_STORE_new();\\r\\nif (ctx == NULL) goto end;\\r\\nX509_STORE_set_verify_cb_func(ctx,callb);\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-req\") == 0)\\r\\n{\\r\\nreqfile=1;\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAkeyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAkeyformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays=atoi(*(++argv));\\r\\nif (days == 0)\\r\\n{\\r\\nBIO_printf(STDout,\"bad number of days\\n\");\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extensions\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextsect= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-signkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\nsign_flag= ++num;\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CA\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\nCA_flag= ++num;\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAserial\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAserial= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-set_serial\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!(sno = s2i_ASN1_INTEGER(NULL, *(++argv))))\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-addtrust\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!(objtmp = OBJ_txt2obj(*(++argv), 0)))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Invalid trust object value %s\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\nif (!trust) trust = sk_ASN1_OBJECT_new_null();\\r\\nsk_ASN1_OBJECT_push(trust, objtmp);\\r\\ntrustout = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-addreject\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!(objtmp = OBJ_txt2obj(*(++argv), 0)))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Invalid reject object value %s\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\nif (!reject) reject = sk_ASN1_OBJECT_new_null();\\r\\nsk_ASN1_OBJECT_push(reject, objtmp);\\r\\ntrustout = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-setalias\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nalias= *(++argv);\\r\\ntrustout = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-certopt\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!set_cert_ex(&certflag, *(++argv))) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-nameopt\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv))) goto bad;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC= ++num;\\r\\nelse if (strcmp(*argv,\"-email\") == 0)\\r\\nemail= ++num;\\r\\nelse if (strcmp(*argv,\"-serial\") == 0)\\r\\nserial= ++num;\\r\\nelse if (strcmp(*argv,\"-next_serial\") == 0)\\r\\nnext_serial= ++num;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus= ++num;\\r\\nelse if (strcmp(*argv,\"-pubkey\") == 0)\\r\\npubkey= ++num;\\r\\nelse if (strcmp(*argv,\"-x509toreq\") == 0)\\r\\nx509req= ++num;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext= ++num;\\r\\nelse if (strcmp(*argv,\"-hash\") == 0\\r\\n|| strcmp(*argv,\"-subject_hash\") == 0)\\r\\nsubject_hash= ++num;\\r\\nelse if (strcmp(*argv,\"-issuer_hash\") == 0)\\r\\nissuer_hash= ++num;\\r\\nelse if (strcmp(*argv,\"-subject\") == 0)\\r\\nsubject= ++num;\\r\\nelse if (strcmp(*argv,\"-issuer\") == 0)\\r\\nissuer= ++num;\\r\\nelse if (strcmp(*argv,\"-fingerprint\") == 0)\\r\\nfingerprint= ++num;\\r\\nelse if (strcmp(*argv,\"-dates\") == 0)\\r\\n{\\r\\nstartdate= ++num;\\r\\nenddate= ++num;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-purpose\") == 0)\\r\\npprint= ++num;\\r\\nelse if (strcmp(*argv,\"-startdate\") == 0)\\r\\nstartdate= ++num;\\r\\nelse if (strcmp(*argv,\"-enddate\") == 0)\\r\\nenddate= ++num;\\r\\nelse if (strcmp(*argv,\"-checkend\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncheckoffset=atoi(*(++argv));\\r\\ncheckend=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse if (strcmp(*argv,\"-trustout\") == 0)\\r\\ntrustout= 1;\\r\\nelse if (strcmp(*argv,\"-clrtrust\") == 0)\\r\\nclrtrust= ++num;\\r\\nelse if (strcmp(*argv,\"-clrreject\") == 0)\\r\\nclrreject= ++num;\\r\\nelse if (strcmp(*argv,\"-alias\") == 0)\\r\\naliasout= ++num;\\r\\nelse if (strcmp(*argv,\"-CAcreateserial\") == 0)\\r\\nCA_createserial= ++num;\\r\\nelse if (strcmp(*argv,\"-clrext\") == 0)\\r\\nclrext = 1;\\r\\n#if 1\\r\\nelse if (strcmp(*argv,\"-crlext\") == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"use -clrext instead of -crlext\\n\");\\r\\nclrext = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-ocspid\") == 0)\\r\\nocspid= ++num;\\r\\nelse if ((md_alg=EVP_get_digestbyname(*argv + 1)))\\r\\n{\\r\\ndigest=md_alg;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=x509_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (need_rand)\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nERR_load_crypto_strings();\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_STORE_set_default_paths(ctx))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif ((CAkeyfile == NULL) && (CA_flag) && (CAformat == FORMAT_PEM))\\r\\n{ CAkeyfile=CAfile; }\\r\\nelse if ((CA_flag) && (CAkeyfile == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"need to specify a CAkey if using the CA command\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (extfile)\\r\\n{\\r\\nlong errorline = -1;\\r\\nX509V3_CTX ctx2;\\r\\nextconf = NCONF_new(NULL);\\r\\nif (!NCONF_load(extconf, extfile,&errorline))\\r\\n{\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err,\\r\\n\"error loading the config file '%s'\\n\",\\r\\nextfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\\r\\n\"error on line %ld of config file '%s'\\n\"\\r\\n,errorline,extfile);\\r\\ngoto end;\\r\\n}\\r\\nif (!extsect)\\r\\n{\\r\\nextsect = NCONF_get_string(extconf, \"default\", \"extensions\");\\r\\nif (!extsect)\\r\\n{\\r\\nERR_clear_error();\\r\\nextsect = \"default\";\\r\\n}\\r\\n}\\r\\nX509V3_set_ctx_test(&ctx2);\\r\\nX509V3_set_nconf(&ctx2, extconf);\\r\\nif (!X509V3_EXT_add_nconf(extconf, &ctx2, extsect, NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextsect);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (reqfile)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nX509_CINF *ci;\\r\\nBIO *in;\\r\\nif (!sign_flag && !CA_flag)\\r\\n{\\r\\nBIO_printf(bio_err,\"We need a private key to sign with\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\nBIO_free(in);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nreq=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);\\r\\nBIO_free(in);\\r\\nif (req == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif ( (req->req_info == NULL) ||\\r\\n(req->req_info->pubkey == NULL) ||\\r\\n(req->req_info->pubkey->public_key == NULL) ||\\r\\n(req->req_info->pubkey->public_key->data == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"The certificate request appears to corrupted\\n\");\\r\\nBIO_printf(bio_err,\"It does not contain a public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((pkey=X509_REQ_get_pubkey(req)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error unpacking public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni=X509_REQ_verify(req,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"Signature verification error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"Signature did not match the certificate request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio_err,\"Signature ok\\n\");\\r\\nprint_name(bio_err, \"subject=\", X509_REQ_get_subject_name(req), nmflag);\\r\\nif ((x=X509_new()) == NULL) goto end;\\r\\nci=x->cert_info;\\r\\nif (sno == NULL)\\r\\n{\\r\\nsno = ASN1_INTEGER_new();\\r\\nif (!sno || !rand_serial(NULL, sno))\\r\\ngoto end;\\r\\nif (!X509_set_serialNumber(x, sno))\\r\\ngoto end;\\r\\nASN1_INTEGER_free(sno);\\r\\nsno = NULL;\\r\\n}\\r\\nelse if (!X509_set_serialNumber(x, sno))\\r\\ngoto end;\\r\\nif (!X509_set_issuer_name(x,req->req_info->subject)) goto end;\\r\\nif (!X509_set_subject_name(x,req->req_info->subject)) goto end;\\r\\nX509_gmtime_adj(X509_get_notBefore(x),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);\\r\\npkey = X509_REQ_get_pubkey(req);\\r\\nX509_set_pubkey(x,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse\\r\\nx=load_cert(bio_err,infile,informat,NULL,e,\"Certificate\");\\r\\nif (x == NULL) goto end;\\r\\nif (CA_flag)\\r\\n{\\r\\nxca=load_cert(bio_err,CAfile,CAformat,NULL,e,\"CA Certificate\");\\r\\nif (xca == NULL) goto end;\\r\\n}\\r\\nif (!noout || text || next_serial)\\r\\n{\\r\\nOBJ_create(\"2.99999.3\",\\r\\n\"SET.ex3\",\"SET x509v3 extension 3\");\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (alias) X509_alias_set1(x, (unsigned char *)alias, -1);\\r\\nif (clrtrust) X509_trust_clear(x);\\r\\nif (clrreject) X509_reject_clear(x);\\r\\nif (trust)\\r\\n{\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(trust); i++)\\r\\n{\\r\\nobjtmp = sk_ASN1_OBJECT_value(trust, i);\\r\\nX509_add1_trust_object(x, objtmp);\\r\\n}\\r\\n}\\r\\nif (reject)\\r\\n{\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(reject); i++)\\r\\n{\\r\\nobjtmp = sk_ASN1_OBJECT_value(reject, i);\\r\\nX509_add1_reject_object(x, objtmp);\\r\\n}\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nfor (i=1; i<=num; i++)\\r\\n{\\r\\nif (issuer == i)\\r\\n{\\r\\nprint_name(STDout, \"issuer= \",\\r\\nX509_get_issuer_name(x), nmflag);\\r\\n}\\r\\nelse if (subject == i)\\r\\n{\\r\\nprint_name(STDout, \"subject= \",\\r\\nX509_get_subject_name(x), nmflag);\\r\\n}\\r\\nelse if (serial == i)\\r\\n{\\r\\nBIO_printf(STDout,\"serial=\");\\r\\ni2a_ASN1_INTEGER(STDout,\\r\\nX509_get_serialNumber(x));\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nelse if (next_serial == i)\\r\\n{\\r\\nBIGNUM *bnser;\\r\\nASN1_INTEGER *ser;\\r\\nser = X509_get_serialNumber(x);\\r\\nbnser = ASN1_INTEGER_to_BN(ser, NULL);\\r\\nif (!bnser)\\r\\ngoto end;\\r\\nif (!BN_add_word(bnser, 1))\\r\\ngoto end;\\r\\nser = BN_to_ASN1_INTEGER(bnser, NULL);\\r\\nif (!ser)\\r\\ngoto end;\\r\\nBN_free(bnser);\\r\\ni2a_ASN1_INTEGER(out, ser);\\r\\nASN1_INTEGER_free(ser);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\nelse if (email == i)\\r\\n{\\r\\nint j;\\r\\nSTACK *emlst;\\r\\nemlst = X509_get1_email(x);\\r\\nfor (j = 0; j < sk_num(emlst); j++)\\r\\nBIO_printf(STDout, \"%s\\n\", sk_value(emlst, j));\\r\\nX509_email_free(emlst);\\r\\n}\\r\\nelse if (aliasout == i)\\r\\n{\\r\\nunsigned char *alstr;\\r\\nalstr = X509_alias_get0(x, NULL);\\r\\nif (alstr) BIO_printf(STDout,\"%s\\n\", alstr);\\r\\nelse BIO_puts(STDout,\"<No Alias>\\n\");\\r\\n}\\r\\nelse if (subject_hash == i)\\r\\n{\\r\\nBIO_printf(STDout,\"%08lx\\n\",X509_subject_name_hash(x));\\r\\n}\\r\\nelse if (issuer_hash == i)\\r\\n{\\r\\nBIO_printf(STDout,\"%08lx\\n\",X509_issuer_name_hash(x));\\r\\n}\\r\\nelse if (pprint == i)\\r\\n{\\r\\nX509_PURPOSE *ptmp;\\r\\nint j;\\r\\nBIO_printf(STDout, \"Certificate purposes:\\n\");\\r\\nfor (j = 0; j < X509_PURPOSE_get_count(); j++)\\r\\n{\\r\\nptmp = X509_PURPOSE_get0(j);\\r\\npurpose_print(STDout, x, ptmp);\\r\\n}\\r\\n}\\r\\nelse\\r\\nif (modulus == i)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Modulus=unavailable\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout,\"Modulus=\");\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nBN_print(STDout,pkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nBN_print(STDout,pkey->pkey.dsa->pub_key);\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(STDout,\"Wrong Algorithm type\");\\r\\nBIO_printf(STDout,\"\\n\");\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse\\r\\nif (pubkey == i)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error getting public key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_PUBKEY(STDout, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse\\r\\nif (C == i)\\r\\n{\\r\\nunsigned char *d;\\r\\nchar *m;\\r\\nint y,z;\\r\\nX509_NAME_oneline(X509_get_subject_name(x),\\r\\nbuf,sizeof buf);\\r\\nBIO_printf(STDout,\"/* subject:%s */\\n\",buf);\\r\\nm=X509_NAME_oneline(\\r\\nX509_get_issuer_name(x),buf,\\r\\nsizeof buf);\\r\\nBIO_printf(STDout,\"/* issuer :%s */\\n\",buf);\\r\\nz=i2d_X509(x,NULL);\\r\\nm=OPENSSL_malloc(z);\\r\\nd=(unsigned char *)m;\\r\\nz=i2d_X509_NAME(X509_get_subject_name(x),&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_subject_name[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f) BIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nz=i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x),&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_public_key[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nz=i2d_X509(x,&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_certificate[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nOPENSSL_free(m);\\r\\n}\\r\\nelse if (text == i)\\r\\n{\\r\\nX509_print_ex(out,x,nmflag, certflag);\\r\\n}\\r\\nelse if (startdate == i)\\r\\n{\\r\\nBIO_puts(STDout,\"notBefore=\");\\r\\nASN1_TIME_print(STDout,X509_get_notBefore(x));\\r\\nBIO_puts(STDout,\"\\n\");\\r\\n}\\r\\nelse if (enddate == i)\\r\\n{\\r\\nBIO_puts(STDout,\"notAfter=\");\\r\\nASN1_TIME_print(STDout,X509_get_notAfter(x));\\r\\nBIO_puts(STDout,\"\\n\");\\r\\n}\\r\\nelse if (fingerprint == i)\\r\\n{\\r\\nint j;\\r\\nunsigned int n;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!X509_digest(x,digest,md,&n))\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout,\"%s Fingerprint=\",\\r\\nOBJ_nid2sn(EVP_MD_type(digest)));\\r\\nfor (j=0; j<(int)n; j++)\\r\\n{\\r\\nBIO_printf(STDout,\"%02X%c\",md[j],\\r\\n(j+1 == (int)n)\\r\\n?'\\n':':');\\r\\n}\\r\\n}\\r\\nelse if ((sign_flag == i) && (x509req == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"Getting Private key\\n\");\\r\\nif (Upkey == NULL)\\r\\n{\\r\\nUpkey=load_key(bio_err,\\r\\nkeyfile, keyformat, 0,\\r\\npassin, e, \"Private key\");\\r\\nif (Upkey == NULL) goto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (Upkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (Upkey->type == EVP_PKEY_EC)\\r\\ndigest=EVP_ecdsa();\\r\\n#endif\\r\\nassert(need_rand);\\r\\nif (!sign(x,Upkey,days,clrext,digest,\\r\\nextconf, extsect)) goto end;\\r\\n}\\r\\nelse if (CA_flag == i)\\r\\n{\\r\\nBIO_printf(bio_err,\"Getting CA Private Key\\n\");\\r\\nif (CAkeyfile != NULL)\\r\\n{\\r\\nCApkey=load_key(bio_err,\\r\\nCAkeyfile, CAkeyformat,\\r\\n0, passin, e,\\r\\n\"CA Private Key\");\\r\\nif (CApkey == NULL) goto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (CApkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (CApkey->type == EVP_PKEY_EC)\\r\\ndigest = EVP_ecdsa();\\r\\n#endif\\r\\nassert(need_rand);\\r\\nif (!x509_certify(ctx,CAfile,digest,x,xca,\\r\\nCApkey, CAserial,CA_createserial,days, clrext,\\r\\nextconf, extsect, sno))\\r\\ngoto end;\\r\\n}\\r\\nelse if (x509req == i)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nBIO_printf(bio_err,\"Getting request Private Key\\n\");\\r\\nif (keyfile == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no request key file specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\npk=load_key(bio_err,\\r\\nkeyfile, FORMAT_PEM, 0,\\r\\npassin, e, \"request key\");\\r\\nif (pk == NULL) goto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating certificate request\\n\");\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pk->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pk->type == EVP_PKEY_EC)\\r\\ndigest=EVP_ecdsa();\\r\\n#endif\\r\\nrq=X509_to_X509_REQ(x,pk,digest);\\r\\nEVP_PKEY_free(pk);\\r\\nif (rq == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nX509_REQ_print(out,rq);\\r\\nPEM_write_bio_X509_REQ(out,rq);\\r\\n}\\r\\nnoout=1;\\r\\n}\\r\\nelse if (ocspid == i)\\r\\n{\\r\\nX509_ocspid_print(out, x);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (checkend)\\r\\n{\\r\\ntime_t tcheck=time(NULL) + checkoffset;\\r\\nif (X509_cmp_time(X509_get_notAfter(x), &tcheck) < 0)\\r\\n{\\r\\nBIO_printf(out,\"Certificate will expire\\n\");\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(out,\"Certificate will not expire\\n\");\\r\\nret=0;\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\nif (noout)\\r\\n{\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\n{\\r\\nif (trustout) i=PEM_write_bio_X509_AUX(out,x);\\r\\nelse i=PEM_write_bio_X509(out,x);\\r\\n}\\r\\nelse if (outformat == FORMAT_NETSCAPE)\\r\\n{\\r\\nASN1_HEADER ah;\\r\\nASN1_OCTET_STRING os;\\r\\nos.data=(unsigned char *)NETSCAPE_CERT_HDR;\\r\\nos.length=strlen(NETSCAPE_CERT_HDR);\\r\\nah.header= &os;\\r\\nah.data=(char *)x;\\r\\nah.meth=X509_asn1_meth();\\r\\ni=ASN1_i2d_bio_of(ASN1_HEADER,i2d_ASN1_HEADER,out,&ah);\\r\\n}\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write certificate\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nOBJ_cleanup();\\r\\nNCONF_free(extconf);\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(STDout);\\r\\nX509_STORE_free(ctx);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x);\\r\\nX509_free(xca);\\r\\nEVP_PKEY_free(Upkey);\\r\\nEVP_PKEY_free(CApkey);\\r\\nX509_REQ_free(rq);\\r\\nASN1_INTEGER_free(sno);\\r\\nsk_ASN1_OBJECT_pop_free(trust, ASN1_OBJECT_free);\\r\\nsk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);\\r\\nif (passin) OPENSSL_free(passin);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create)\\r\\n{\\r\\nchar *buf = NULL, *p;\\r\\nASN1_INTEGER *bs = NULL;\\r\\nBIGNUM *serial = NULL;\\r\\nsize_t len;\\r\\nlen = ((serialfile == NULL)\\r\\n?(strlen(CAfile)+strlen(POSTFIX)+1)\\r\\n:(strlen(serialfile)))+1;\\r\\nbuf=OPENSSL_malloc(len);\\r\\nif (buf == NULL) { BIO_printf(bio_err,\"out of mem\\n\"); goto end; }\\r\\nif (serialfile == NULL)\\r\\n{\\r\\nBUF_strlcpy(buf,CAfile,len);\\r\\nfor (p=buf; *p; p++)\\r\\nif (*p == '.')\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\nBUF_strlcat(buf,POSTFIX,len);\\r\\n}\\r\\nelse\\r\\nBUF_strlcpy(buf,serialfile,len);\\r\\nserial = load_serial(buf, create, NULL);\\r\\nif (serial == NULL) goto end;\\r\\nif (!BN_add_word(serial,1))\\r\\n{ BIO_printf(bio_err,\"add_word failure\\n\"); goto end; }\\r\\nif (!save_serial(buf, NULL, serial, &bs)) goto end;\\r\\nend:\\r\\nif (buf) OPENSSL_free(buf);\\r\\nBN_free(serial);\\r\\nreturn bs;\\r\\n}\\r\\nstatic int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,\\r\\nX509 *x, X509 *xca, EVP_PKEY *pkey, char *serialfile, int create,\\r\\nint days, int clrext, CONF *conf, char *section, ASN1_INTEGER *sno)\\r\\n{\\r\\nint ret=0;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nX509_STORE_CTX xsc;\\r\\nEVP_PKEY *upkey;\\r\\nupkey = X509_get_pubkey(xca);\\r\\nEVP_PKEY_copy_parameters(upkey,pkey);\\r\\nEVP_PKEY_free(upkey);\\r\\nif(!X509_STORE_CTX_init(&xsc,ctx,x,NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Error initialising X509 store\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (sno) bs = sno;\\r\\nelse if (!(bs = x509_load_serial(CAfile, serialfile, create)))\\r\\ngoto end;\\r\\nX509_STORE_CTX_set_cert(&xsc,x);\\r\\nif (!reqfile && !X509_verify_cert(&xsc))\\r\\ngoto end;\\r\\nif (!X509_check_private_key(xca,pkey))\\r\\n{\\r\\nBIO_printf(bio_err,\"CA certificate and CA private key do not match\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_set_issuer_name(x,X509_get_subject_name(xca))) goto end;\\r\\nif (!X509_set_serialNumber(x,bs)) goto end;\\r\\nif (X509_gmtime_adj(X509_get_notBefore(x),0L) == NULL)\\r\\ngoto end;\\r\\nif (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)\\r\\ngoto end;\\r\\nif (clrext)\\r\\n{\\r\\nwhile (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);\\r\\n}\\r\\nif (conf)\\r\\n{\\r\\nX509V3_CTX ctx2;\\r\\nX509_set_version(x,2);\\r\\nX509V3_set_ctx(&ctx2, xca, x, NULL, NULL, 0);\\r\\nX509V3_set_nconf(&ctx2, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx2, section, x)) goto end;\\r\\n}\\r\\nif (!X509_sign(x,pkey,digest)) goto end;\\r\\nret=1;\\r\\nend:\\r\\nX509_STORE_CTX_cleanup(&xsc);\\r\\nif (!ret)\\r\\nERR_print_errors(bio_err);\\r\\nif (!sno) ASN1_INTEGER_free(bs);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint err;\\r\\nX509 *err_cert;\\r\\nerr=X509_STORE_CTX_get_error(ctx);\\r\\nif (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\\r\\nreturn 1;\\r\\nif (ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"error with certificate to be certified - should be self signed\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nprint_name(bio_err, NULL, X509_get_subject_name(err_cert),0);\\r\\nBIO_printf(bio_err,\"error with certificate - error %d at depth %d\\n%s\\n\",\\r\\nerr,X509_STORE_CTX_get_error_depth(ctx),\\r\\nX509_verify_cert_error_string(err));\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nstatic int sign(X509 *x, EVP_PKEY *pkey, int days, int clrext, const EVP_MD *digest,\\r\\nCONF *conf, char *section)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(x);\\r\\nEVP_PKEY_copy_parameters(pktmp,pkey);\\r\\nEVP_PKEY_save_parameters(pktmp,1);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!X509_set_issuer_name(x,X509_get_subject_name(x))) goto err;\\r\\nif (X509_gmtime_adj(X509_get_notBefore(x),0) == NULL) goto err;\\r\\nif (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)\\r\\ngoto err;\\r\\nif (!X509_set_pubkey(x,pkey)) goto err;\\r\\nif (clrext)\\r\\n{\\r\\nwhile (X509_get_ext_count(x) > 0) X509_delete_ext(x, 0);\\r\\n}\\r\\nif (conf)\\r\\n{\\r\\nX509V3_CTX ctx;\\r\\nX509_set_version(x,2);\\r\\nX509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, section, x)) goto err;\\r\\n}\\r\\nif (!X509_sign(x,pkey,digest)) goto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt)\\r\\n{\\r\\nint id, i, idret;\\r\\nchar *pname;\\r\\nid = X509_PURPOSE_get_id(pt);\\r\\npname = X509_PURPOSE_get0_name(pt);\\r\\nfor (i = 0; i < 2; i++)\\r\\n{\\r\\nidret = X509_check_purpose(cert, id, i);\\r\\nBIO_printf(bio, \"%s%s : \", pname, i ? \" CA\" : \"\");\\r\\nif (idret == 1) BIO_printf(bio, \"Yes\\n\");\\r\\nelse if (idret == 0) BIO_printf(bio, \"No\\n\");\\r\\nelse BIO_printf(bio, \"Yes (WARNING code=%d)\\n\", idret);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_openssl_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\nif(!ENGINE_set_id(e, engine_openssl_id)\\r\\n|| !ENGINE_set_name(e, engine_openssl_name)\\r\\n#ifndef TEST_ENG_OPENSSL_NO_ALGORITHMS\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n|| !ENGINE_set_RSA(e, RSA_get_default_method())\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n|| !ENGINE_set_DSA(e, DSA_get_default_method())\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\n|| !ENGINE_set_ECDH(e, ECDH_OpenSSL())\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\n|| !ENGINE_set_ECDSA(e, ECDSA_OpenSSL())\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n|| !ENGINE_set_DH(e, DH_get_default_method())\\r\\n#endif\\r\\n|| !ENGINE_set_RAND(e, RAND_SSLeay())\\r\\n#ifdef TEST_ENG_OPENSSL_RC4\\r\\n|| !ENGINE_set_ciphers(e, openssl_ciphers)\\r\\n#endif\\r\\n#ifdef TEST_ENG_OPENSSL_SHA\\r\\n|| !ENGINE_set_digests(e, openssl_digests)\\r\\n#endif\\r\\n#endif\\r\\n#ifdef TEST_ENG_OPENSSL_PKEY\\r\\n|| !ENGINE_set_load_privkey_function(e, openssl_load_privkey)\\r\\n#endif\\r\\n)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_openssl(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_openssl(void)\\r\\n{\\r\\nENGINE *toadd = engine_openssl();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_openssl_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_RC4_P_INIT\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) test_init_key() called\\n\");\\r\\n#endif\\r\\nmemcpy(&test(ctx)->key[0],key,EVP_CIPHER_CTX_key_length(ctx));\\r\\nRC4_set_key(&test(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),\\r\\ntest(ctx)->key);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_RC4_P_CIPHER\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) test_cipher() called\\n\");\\r\\n#endif\\r\\nRC4(&test(ctx)->ks,inl,in,out);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int openssl_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif(!cipher)\\r\\n{\\r\\n*nids = test_cipher_nids;\\r\\nreturn test_cipher_nids_number;\\r\\n}\\r\\nif(nid == NID_rc4)\\r\\n*cipher = &test_r4_cipher;\\r\\nelse if(nid == NID_rc4_40)\\r\\n*cipher = &test_r4_40_cipher;\\r\\nelse\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_RC4_OTHERS\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) returning NULL for \"\\r\\n\"nid %d\\n\", nid);\\r\\n#endif\\r\\n*cipher = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_sha1_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_SHA_P_INIT\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_init() called\\n\");\\r\\n#endif\\r\\nreturn SHA1_Init(ctx->md_data);\\r\\n}\\r\\nstatic int test_sha1_update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_SHA_P_UPDATE\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_update() called\\n\");\\r\\n#endif\\r\\nreturn SHA1_Update(ctx->md_data,data,count);\\r\\n}\\r\\nstatic int test_sha1_final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_SHA_P_FINAL\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_final() called\\n\");\\r\\n#endif\\r\\nreturn SHA1_Final(md,ctx->md_data);\\r\\n}\\r\\nstatic int openssl_digests(ENGINE *e, const EVP_MD **digest,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif(!digest)\\r\\n{\\r\\n*nids = test_digest_nids;\\r\\nreturn test_digest_nids_number;\\r\\n}\\r\\nif(nid == NID_sha1)\\r\\n*digest = &test_sha_md;\\r\\nelse\\r\\n{\\r\\n#ifdef TEST_ENG_OPENSSL_SHA_OTHERS\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) returning NULL for \"\\r\\n\"nid %d\\n\", nid);\\r\\n#endif\\r\\n*digest = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic EVP_PKEY *openssl_load_privkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nBIO *in;\\r\\nEVP_PKEY *key;\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_PKEY)Loading Private key %s\\n\", key_id);\\r\\nin = BIO_new_file(key_id, \"r\");\\r\\nif (!in)\\r\\nreturn NULL;\\r\\nkey = PEM_read_bio_PrivateKey(in, NULL, 0, NULL);\\r\\nBIO_free(in);\\r\\nreturn key;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sign_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nX509 *x509;\\r\\nEVP_PKEY *pkey;\\r\\nPKCS7 *p7;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nBIO *in;\\r\\nBIO *data,*p7bio;\\r\\nchar buf[1024*4];\\r\\nint i;\\r\\nint nodetach=0;\\r\\n#ifndef OPENSSL_NO_MD2\\r\\nEVP_add_digest(EVP_md2());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA1\\r\\nEVP_add_digest(EVP_sha1());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MDC2\\r\\nEVP_add_digest(EVP_mdc2());\\r\\n#endif\\r\\ndata=BIO_new(BIO_s_file());\\r\\nagain:\\r\\nif (argc > 1)\\r\\n{\\r\\nif (strcmp(argv[1],\"-nd\") == 0)\\r\\n{\\r\\nnodetach=1;\\r\\nargv++; argc--;\\r\\ngoto again;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[1]))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nBIO_set_fp(data,stdin,BIO_NOCLOSE);\\r\\nif ((in=BIO_new_file(\"server.pem\",\"r\")) == NULL) goto err;\\r\\nif ((x509=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL) goto err;\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL)) == NULL) goto err;\\r\\nBIO_free(in);\\r\\np7=PKCS7_new();\\r\\nPKCS7_set_type(p7,NID_pkcs7_signed);\\r\\nsi=PKCS7_add_signature(p7,x509,pkey,EVP_sha1());\\r\\nif (si == NULL) goto err;\\r\\nPKCS7_add_signed_attribute(si, NID_pkcs9_contentType, V_ASN1_OBJECT,\\r\\nOBJ_nid2obj(NID_pkcs7_data));\\r\\nPKCS7_add_certificate(p7,x509);\\r\\nPKCS7_content_new(p7,NID_pkcs7_data);\\r\\nif (!nodetach)\\r\\nPKCS7_set_detached(p7,1);\\r\\nif ((p7bio=PKCS7_dataInit(p7,NULL)) == NULL) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(data,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nBIO_write(p7bio,buf,i);\\r\\n}\\r\\nif (!PKCS7_dataFinal(p7,p7bio)) goto err;\\r\\nBIO_free(p7bio);\\r\\nPEM_write_PKCS7(stdout,p7);\\r\\nPKCS7_free(p7);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_srv_c", "target": 0, "func": "int OCSP_request_onereq_count(OCSP_REQUEST *req)\\r\\n{\\r\\nreturn sk_OCSP_ONEREQ_num(req->tbsRequest->requestList);\\r\\n}\\r\\nOCSP_ONEREQ *OCSP_request_onereq_get0(OCSP_REQUEST *req, int i)\\r\\n{\\r\\nreturn sk_OCSP_ONEREQ_value(req->tbsRequest->requestList, i);\\r\\n}\\r\\nOCSP_CERTID *OCSP_onereq_get0_id(OCSP_ONEREQ *one)\\r\\n{\\r\\nreturn one->reqCert;\\r\\n}\\r\\nint OCSP_id_get0_info(ASN1_OCTET_STRING **piNameHash, ASN1_OBJECT **pmd,\\r\\nASN1_OCTET_STRING **pikeyHash,\\r\\nASN1_INTEGER **pserial, OCSP_CERTID *cid)\\r\\n{\\r\\nif (!cid) return 0;\\r\\nif (pmd) *pmd = cid->hashAlgorithm->algorithm;\\r\\nif(piNameHash) *piNameHash = cid->issuerNameHash;\\r\\nif (pikeyHash) *pikeyHash = cid->issuerKeyHash;\\r\\nif (pserial) *pserial = cid->serialNumber;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_request_is_signed(OCSP_REQUEST *req)\\r\\n{\\r\\nif(req->optionalSignature) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nOCSP_RESPONSE *OCSP_response_create(int status, OCSP_BASICRESP *bs)\\r\\n{\\r\\nOCSP_RESPONSE *rsp = NULL;\\r\\nif (!(rsp = OCSP_RESPONSE_new())) goto err;\\r\\nif (!(ASN1_ENUMERATED_set(rsp->responseStatus, status))) goto err;\\r\\nif (!bs) return rsp;\\r\\nif (!(rsp->responseBytes = OCSP_RESPBYTES_new())) goto err;\\r\\nrsp->responseBytes->responseType = OBJ_nid2obj(NID_id_pkix_OCSP_basic);\\r\\nif (!ASN1_item_pack(bs, ASN1_ITEM_rptr(OCSP_BASICRESP), &rsp->responseBytes->response))\\r\\ngoto err;\\r\\nreturn rsp;\\r\\nerr:\\r\\nif (rsp) OCSP_RESPONSE_free(rsp);\\r\\nreturn NULL;\\r\\n}\\r\\nOCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *rsp,\\r\\nOCSP_CERTID *cid,\\r\\nint status, int reason,\\r\\nASN1_TIME *revtime,\\r\\nASN1_TIME *thisupd, ASN1_TIME *nextupd)\\r\\n{\\r\\nOCSP_SINGLERESP *single = NULL;\\r\\nOCSP_CERTSTATUS *cs;\\r\\nOCSP_REVOKEDINFO *ri;\\r\\nif(!rsp->tbsResponseData->responses &&\\r\\n!(rsp->tbsResponseData->responses = sk_OCSP_SINGLERESP_new_null()))\\r\\ngoto err;\\r\\nif (!(single = OCSP_SINGLERESP_new()))\\r\\ngoto err;\\r\\nif (!ASN1_TIME_to_generalizedtime(thisupd, &single->thisUpdate))\\r\\ngoto err;\\r\\nif (nextupd &&\\r\\n!ASN1_TIME_to_generalizedtime(nextupd, &single->nextUpdate))\\r\\ngoto err;\\r\\nOCSP_CERTID_free(single->certId);\\r\\nif(!(single->certId = OCSP_CERTID_dup(cid)))\\r\\ngoto err;\\r\\ncs = single->certStatus;\\r\\nswitch(cs->type = status)\\r\\n{\\r\\ncase V_OCSP_CERTSTATUS_REVOKED:\\r\\nif (!revtime)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_BASIC_ADD1_STATUS,OCSP_R_NO_REVOKED_TIME);\\r\\ngoto err;\\r\\n}\\r\\nif (!(cs->value.revoked = ri = OCSP_REVOKEDINFO_new())) goto err;\\r\\nif (!ASN1_TIME_to_generalizedtime(revtime, &ri->revocationTime))\\r\\ngoto err;\\r\\nif (reason != OCSP_REVOKED_STATUS_NOSTATUS)\\r\\n{\\r\\nif (!(ri->revocationReason = ASN1_ENUMERATED_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_ENUMERATED_set(ri->revocationReason,\\r\\nreason)))\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase V_OCSP_CERTSTATUS_GOOD:\\r\\ncs->value.good = ASN1_NULL_new();\\r\\nbreak;\\r\\ncase V_OCSP_CERTSTATUS_UNKNOWN:\\r\\ncs->value.unknown = ASN1_NULL_new();\\r\\nbreak;\\r\\ndefault:\\r\\ngoto err;\\r\\n}\\r\\nif (!(sk_OCSP_SINGLERESP_push(rsp->tbsResponseData->responses, single)))\\r\\ngoto err;\\r\\nreturn single;\\r\\nerr:\\r\\nOCSP_SINGLERESP_free(single);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_basic_add1_cert(OCSP_BASICRESP *resp, X509 *cert)\\r\\n{\\r\\nif (!resp->certs && !(resp->certs = sk_X509_new_null()))\\r\\nreturn 0;\\r\\nif(!sk_X509_push(resp->certs, cert)) return 0;\\r\\nCRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_oth_c", "target": 0, "func": "void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nconst unsigned char *p=NULL;\\r\\nunsigned char *data=NULL;\\r\\nlong len;\\r\\nchar *ret=NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, NULL, name, bp, cb, u))\\r\\nreturn NULL;\\r\\np = data;\\r\\nret=d2i(x,&p,len);\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);\\r\\nOPENSSL_free(data);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_sureware_c", "target": 0, "func": "static int surewarehk_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn surewarehk_modexp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int surewarehk_modexp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn surewarehk_modexp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int surewarehk_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!surewarehk_modexp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!surewarehk_modexp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int bind_sureware(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth2;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_sureware_id) ||\\r\\n!ENGINE_set_name(e, engine_sureware_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &surewarehk_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &surewarehk_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &surewarehk_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &surewarehk_rand) ||\\r\\n!ENGINE_set_destroy_function(e, surewarehk_destroy) ||\\r\\n!ENGINE_set_init_function(e, surewarehk_init) ||\\r\\n!ENGINE_set_finish_function(e, surewarehk_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, surewarehk_ctrl) ||\\r\\n!ENGINE_set_load_privkey_function(e, surewarehk_load_privkey) ||\\r\\n!ENGINE_set_load_pubkey_function(e, surewarehk_load_pubkey))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\nif (meth1)\\r\\n{\\r\\nsurewarehk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\nsurewarehk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth2 = DSA_OpenSSL();\\r\\nif (meth2)\\r\\n{\\r\\nsurewarehk_dsa.dsa_do_verify = meth2->dsa_do_verify;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth3 = DH_OpenSSL();\\r\\nif (meth3)\\r\\n{\\r\\nsurewarehk_dh.generate_key = meth3->generate_key;\\r\\nsurewarehk_dh.compute_key = meth3->compute_key;\\r\\n}\\r\\n#endif\\r\\nERR_load_SUREWARE_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_sureware_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_sureware(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_sureware(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_sureware(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_sureware(void)\\r\\n{\\r\\nENGINE *toadd = engine_sureware();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int surewarehk_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint to_return = 1;\\r\\nswitch(cmd)\\r\\n{\\r\\ncase ENGINE_CTRL_SET_LOGSTREAM:\\r\\n{\\r\\nBIO *bio = (BIO *)p;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (logstream)\\r\\n{\\r\\nBIO_free(logstream);\\r\\nlogstream = NULL;\\r\\n}\\r\\nif (CRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO) > 1)\\r\\nlogstream = bio;\\r\\nelse\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_CTRL,SUREWARE_R_BIO_WAS_FREED);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_CHIL_NO_LOCKING:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nthreadsafe = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ndefault:\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_CTRL,\\r\\nENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nto_return = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int surewarehk_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_SUREWARE_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int surewarehk_init(ENGINE *e)\\r\\n{\\r\\nchar msg[64]=\"ENGINE_init\";\\r\\nSureWareHook_Init_t *p1=NULL;\\r\\nSureWareHook_Finish_t *p2=NULL;\\r\\nSureWareHook_Rand_Bytes_t *p3=NULL;\\r\\nSureWareHook_Rand_Seed_t *p4=NULL;\\r\\nSureWareHook_Load_Privkey_t *p5=NULL;\\r\\nSureWareHook_Load_Rsa_Pubkey_t *p6=NULL;\\r\\nSureWareHook_Free_t *p7=NULL;\\r\\nSureWareHook_Rsa_Priv_Dec_t *p8=NULL;\\r\\nSureWareHook_Rsa_Sign_t *p9=NULL;\\r\\nSureWareHook_Dsa_Sign_t *p12=NULL;\\r\\nSureWareHook_Info_Pubkey_t *p13=NULL;\\r\\nSureWareHook_Load_Dsa_Pubkey_t *p14=NULL;\\r\\nSureWareHook_Mod_Exp_t *p15=NULL;\\r\\nif(surewarehk_dso != NULL)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nsurewarehk_dso = DSO_load(NULL, surewarehk_LIBNAME, NULL, 0);\\r\\nif(surewarehk_dso == NULL)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif(!(p1=(SureWareHook_Init_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Init)) ||\\r\\n!(p2=(SureWareHook_Finish_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Finish)) ||\\r\\n!(p3=(SureWareHook_Rand_Bytes_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rand_Bytes)) ||\\r\\n!(p4=(SureWareHook_Rand_Seed_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rand_Seed)) ||\\r\\n!(p5=(SureWareHook_Load_Privkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Privkey)) ||\\r\\n!(p6=(SureWareHook_Load_Rsa_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Rsa_Pubkey)) ||\\r\\n!(p7=(SureWareHook_Free_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Free)) ||\\r\\n!(p8=(SureWareHook_Rsa_Priv_Dec_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rsa_Priv_Dec)) ||\\r\\n!(p9=(SureWareHook_Rsa_Sign_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rsa_Sign)) ||\\r\\n!(p12=(SureWareHook_Dsa_Sign_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Dsa_Sign)) ||\\r\\n!(p13=(SureWareHook_Info_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Info_Pubkey)) ||\\r\\n!(p14=(SureWareHook_Load_Dsa_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Dsa_Pubkey)) ||\\r\\n!(p15=(SureWareHook_Mod_Exp_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Mod_Exp)))\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_surewarehk_Init = p1;\\r\\np_surewarehk_Finish = p2;\\r\\np_surewarehk_Rand_Bytes = p3;\\r\\np_surewarehk_Rand_Seed = p4;\\r\\np_surewarehk_Load_Privkey = p5;\\r\\np_surewarehk_Load_Rsa_Pubkey = p6;\\r\\np_surewarehk_Free = p7;\\r\\np_surewarehk_Rsa_Priv_Dec = p8;\\r\\np_surewarehk_Rsa_Sign = p9;\\r\\np_surewarehk_Dsa_Sign = p12;\\r\\np_surewarehk_Info_Pubkey = p13;\\r\\np_surewarehk_Load_Dsa_Pubkey = p14;\\r\\np_surewarehk_Mod_Exp = p15;\\r\\nif(p_surewarehk_Init(msg,threadsafe)==SUREWAREHOOK_ERROR_UNIT_FAILURE)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,SUREWARE_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif(p_surewarehk_Init(msg,threadsafe)==SUREWAREHOOK_ERROR_UNIT_FAILURE)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,SUREWARE_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nsurewarehk_load_privkey(e,NULL,NULL,NULL);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (rsaHndidx == -1)\\r\\nrsaHndidx = RSA_get_ex_new_index(0,\\r\\n\"SureWareHook RSA key handle\",\\r\\nNULL, NULL, surewarehk_ex_free);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsaHndidx == -1)\\r\\ndsaHndidx = DSA_get_ex_new_index(0,\\r\\n\"SureWareHook DSA key handle\",\\r\\nNULL, NULL, surewarehk_ex_free);\\r\\n#endif\\r\\nreturn 1;\\r\\nerr:\\r\\nif(surewarehk_dso)\\r\\nDSO_free(surewarehk_dso);\\r\\nsurewarehk_dso = NULL;\\r\\np_surewarehk_Init = NULL;\\r\\np_surewarehk_Finish = NULL;\\r\\np_surewarehk_Rand_Bytes = NULL;\\r\\np_surewarehk_Rand_Seed = NULL;\\r\\np_surewarehk_Load_Privkey = NULL;\\r\\np_surewarehk_Load_Rsa_Pubkey = NULL;\\r\\np_surewarehk_Free = NULL;\\r\\np_surewarehk_Rsa_Priv_Dec = NULL;\\r\\np_surewarehk_Rsa_Sign = NULL;\\r\\np_surewarehk_Dsa_Sign = NULL;\\r\\np_surewarehk_Info_Pubkey = NULL;\\r\\np_surewarehk_Load_Dsa_Pubkey = NULL;\\r\\np_surewarehk_Mod_Exp = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int surewarehk_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif(surewarehk_dso == NULL)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_FINISH,ENGINE_R_NOT_LOADED);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\np_surewarehk_Finish();\\r\\nif(!DSO_free(surewarehk_dso))\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_FINISH,ENGINE_R_DSO_FAILURE);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (logstream)\\r\\nBIO_free(logstream);\\r\\nsurewarehk_dso = NULL;\\r\\np_surewarehk_Init = NULL;\\r\\np_surewarehk_Finish = NULL;\\r\\np_surewarehk_Rand_Bytes = NULL;\\r\\np_surewarehk_Rand_Seed = NULL;\\r\\np_surewarehk_Load_Privkey = NULL;\\r\\np_surewarehk_Load_Rsa_Pubkey = NULL;\\r\\np_surewarehk_Free = NULL;\\r\\np_surewarehk_Rsa_Priv_Dec = NULL;\\r\\np_surewarehk_Rsa_Sign = NULL;\\r\\np_surewarehk_Dsa_Sign = NULL;\\r\\np_surewarehk_Info_Pubkey = NULL;\\r\\np_surewarehk_Load_Dsa_Pubkey = NULL;\\r\\np_surewarehk_Mod_Exp = NULL;\\r\\nreturn to_return;\\r\\n}\\r\\nstatic void surewarehk_error_handling(char *const msg,int func,int ret)\\r\\n{\\r\\nswitch (ret)\\r\\n{\\r\\ncase SUREWAREHOOK_ERROR_UNIT_FAILURE:\\r\\nENGINEerr(func,SUREWARE_R_UNIT_FAILURE);\\r\\nbreak;\\r\\ncase SUREWAREHOOK_ERROR_FALLBACK:\\r\\nENGINEerr(func,SUREWARE_R_REQUEST_FALLBACK);\\r\\nbreak;\\r\\ncase SUREWAREHOOK_ERROR_DATA_SIZE:\\r\\nENGINEerr(func,SUREWARE_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nbreak;\\r\\ncase SUREWAREHOOK_ERROR_INVALID_PAD:\\r\\nENGINEerr(func,SUREWARE_R_PADDING_CHECK_FAILED);\\r\\nbreak;\\r\\ndefault:\\r\\nENGINEerr(func,SUREWARE_R_REQUEST_FAILED);\\r\\nbreak;\\r\\ncase 1:\\r\\nmsg[0]='\\0';\\r\\n}\\r\\nif (*msg)\\r\\n{\\r\\nERR_add_error_data(1,msg);\\r\\nif (logstream)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_BIO);\\r\\nBIO_write(logstream, msg, strlen(msg));\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_BIO);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int surewarehk_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nint ret=0;\\r\\nchar msg[64]=\"ENGINE_rand_bytes\";\\r\\nif(!p_surewarehk_Rand_Bytes)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RAND_BYTES,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret = p_surewarehk_Rand_Bytes(msg,buf, num);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RAND_BYTES,ret);\\r\\n}\\r\\nreturn ret==1 ? 1 : 0;\\r\\n}\\r\\nstatic void surewarehk_rand_seed(const void *buf, int num)\\r\\n{\\r\\nint ret=0;\\r\\nchar msg[64]=\"ENGINE_rand_seed\";\\r\\nif(!p_surewarehk_Rand_Seed)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RAND_SEED,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret = p_surewarehk_Rand_Seed(msg,buf, num);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RAND_SEED,ret);\\r\\n}\\r\\n}\\r\\nstatic void surewarehk_rand_add(const void *buf, int num, double entropy)\\r\\n{\\r\\nsurewarehk_rand_seed(buf,num);\\r\\n}\\r\\nstatic EVP_PKEY* sureware_load_public(ENGINE *e,const char *key_id,char *hptr,unsigned long el,char keytype)\\r\\n{\\r\\nEVP_PKEY *res = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rsatmp = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nDSA *dsatmp=NULL;\\r\\n#endif\\r\\nchar msg[64]=\"sureware_load_public\";\\r\\nint ret=0;\\r\\nif(!p_surewarehk_Load_Rsa_Pubkey || !p_surewarehk_Load_Dsa_Pubkey)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nswitch (keytype)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase 1:\\r\\nrsatmp = RSA_new_method(e);\\r\\nRSA_set_ex_data(rsatmp,rsaHndidx,hptr);\\r\\nrsatmp->flags |= RSA_FLAG_EXT_PKEY;\\r\\nrsatmp->e = BN_new();\\r\\nrsatmp->n = BN_new();\\r\\nbn_expand2(rsatmp->e, el/sizeof(BN_ULONG));\\r\\nbn_expand2(rsatmp->n, el/sizeof(BN_ULONG));\\r\\nif (!rsatmp->e || rsatmp->e->dmax!=(int)(el/sizeof(BN_ULONG))||\\r\\n!rsatmp->n || rsatmp->n->dmax!=(int)(el/sizeof(BN_ULONG)))\\r\\ngoto err;\\r\\nret=p_surewarehk_Load_Rsa_Pubkey(msg,key_id,el,\\r\\n(unsigned long *)rsatmp->n->d,\\r\\n(unsigned long *)rsatmp->e->d);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWARE_LOAD_PUBLIC,ret);\\r\\nif (ret!=1)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nrsatmp->e->top=el/sizeof(BN_ULONG);\\r\\nbn_fix_top(rsatmp->e);\\r\\nrsatmp->n->top=el/sizeof(BN_ULONG);\\r\\nbn_fix_top(rsatmp->n);\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_RSA(res, rsatmp);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase 2:\\r\\ndsatmp = DSA_new_method(e);\\r\\nDSA_set_ex_data(dsatmp,dsaHndidx,hptr);\\r\\ndsatmp->pub_key = BN_new();\\r\\ndsatmp->p = BN_new();\\r\\ndsatmp->q = BN_new();\\r\\ndsatmp->g = BN_new();\\r\\nbn_expand2(dsatmp->pub_key, el/sizeof(BN_ULONG));\\r\\nbn_expand2(dsatmp->p, el/sizeof(BN_ULONG));\\r\\nbn_expand2(dsatmp->q, 20/sizeof(BN_ULONG));\\r\\nbn_expand2(dsatmp->g, el/sizeof(BN_ULONG));\\r\\nif (!dsatmp->pub_key || dsatmp->pub_key->dmax!=(int)(el/sizeof(BN_ULONG))||\\r\\n!dsatmp->p || dsatmp->p->dmax!=(int)(el/sizeof(BN_ULONG)) ||\\r\\n!dsatmp->q || dsatmp->q->dmax!=20/sizeof(BN_ULONG) ||\\r\\n!dsatmp->g || dsatmp->g->dmax!=(int)(el/sizeof(BN_ULONG)))\\r\\ngoto err;\\r\\nret=p_surewarehk_Load_Dsa_Pubkey(msg,key_id,el,\\r\\n(unsigned long *)dsatmp->pub_key->d,\\r\\n(unsigned long *)dsatmp->p->d,\\r\\n(unsigned long *)dsatmp->q->d,\\r\\n(unsigned long *)dsatmp->g->d);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWARE_LOAD_PUBLIC,ret);\\r\\nif (ret!=1)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\ndsatmp->pub_key->top=el/sizeof(BN_ULONG);\\r\\nbn_fix_top(dsatmp->pub_key);\\r\\ndsatmp->p->top=el/sizeof(BN_ULONG);\\r\\nbn_fix_top(dsatmp->p);\\r\\ndsatmp->q->top=20/sizeof(BN_ULONG);\\r\\nbn_fix_top(dsatmp->q);\\r\\ndsatmp->g->top=el/sizeof(BN_ULONG);\\r\\nbn_fix_top(dsatmp->g);\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_DSA(res, dsatmp);\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nreturn res;\\r\\nerr:\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (rsatmp)\\r\\nRSA_free(rsatmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dsatmp)\\r\\nDSA_free(dsatmp);\\r\\n#endif\\r\\nreturn NULL;\\r\\n}\\r\\nstatic EVP_PKEY *surewarehk_load_privkey(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *res = NULL;\\r\\nint ret=0;\\r\\nunsigned long el=0;\\r\\nchar *hptr=NULL;\\r\\nchar keytype=0;\\r\\nchar msg[64]=\"ENGINE_load_privkey\";\\r\\nif(!p_surewarehk_Load_Privkey)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PRIVKEY,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=p_surewarehk_Load_Privkey(msg,key_id,&hptr,&el,&keytype);\\r\\nif (ret!=1)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PRIVKEY,ENGINE_R_FAILED_LOADING_PRIVATE_KEY);\\r\\nERR_add_error_data(1,msg);\\r\\n}\\r\\nelse\\r\\nres=sureware_load_public(e,key_id,hptr,el,keytype);\\r\\n}\\r\\nreturn res;\\r\\n}\\r\\nstatic EVP_PKEY *surewarehk_load_pubkey(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *res = NULL;\\r\\nint ret=0;\\r\\nunsigned long el=0;\\r\\nchar *hptr=NULL;\\r\\nchar keytype=0;\\r\\nchar msg[64]=\"ENGINE_load_pubkey\";\\r\\nif(!p_surewarehk_Info_Pubkey)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PUBKEY,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=p_surewarehk_Info_Pubkey(msg,key_id,&el,&keytype);\\r\\nif (ret!=1)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PUBKEY,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\\r\\nERR_add_error_data(1,msg);\\r\\n}\\r\\nelse\\r\\nres=sureware_load_public(e,key_id,hptr,el,keytype);\\r\\n}\\r\\nreturn res;\\r\\n}\\r\\nstatic void surewarehk_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad,\\r\\nint idx,long argl, void *argp)\\r\\n{\\r\\nif(!p_surewarehk_Free)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_EX_FREE,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\np_surewarehk_Free((char *)item,0);\\r\\n}\\r\\nstatic int surewarehk_rsa_priv_dec(int flen,const unsigned char *from,unsigned char *to,\\r\\nRSA *rsa,int padding)\\r\\n{\\r\\nint ret=0,tlen;\\r\\nchar *buf=NULL,*hptr=NULL;\\r\\nchar msg[64]=\"ENGINE_rsa_priv_dec\";\\r\\nif (!p_surewarehk_Rsa_Priv_Dec)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse if (!(hptr=RSA_get_ex_data(rsa, rsaHndidx)))\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nif (padding==RSA_PKCS1_PADDING)\\r\\n{\\r\\nret=p_surewarehk_Rsa_Priv_Dec(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_PKCS1_PAD);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ret);\\r\\nif (ret!=1)\\r\\ngoto err;\\r\\nret=tlen;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=p_surewarehk_Rsa_Priv_Dec(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_NO_PAD);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ret);\\r\\nif (ret!=1)\\r\\ngoto err;\\r\\nif ((buf=OPENSSL_malloc(tlen)) == NULL)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(buf,to,tlen);\\r\\nswitch (padding)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SHA\\r\\ncase RSA_PKCS1_OAEP_PADDING:\\r\\nret=RSA_padding_check_PKCS1_OAEP(to,tlen,(unsigned char *)buf,tlen,tlen,NULL,0);\\r\\nbreak;\\r\\n#endif\\r\\ncase RSA_SSLV23_PADDING:\\r\\nret=RSA_padding_check_SSLv23(to,tlen,(unsigned char *)buf,flen,tlen);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\nret=RSA_padding_check_none(to,tlen,(unsigned char *)buf,flen,tlen);\\r\\nbreak;\\r\\ndefault:\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (ret < 0)\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_PADDING_CHECK_FAILED);\\r\\n}\\r\\nerr:\\r\\nif (buf)\\r\\n{\\r\\nOPENSSL_cleanse(buf,tlen);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int surewarehk_rsa_sign(int flen,const unsigned char *from,unsigned char *to,\\r\\nRSA *rsa,int padding)\\r\\n{\\r\\nint ret=0,tlen;\\r\\nchar *hptr=NULL;\\r\\nchar msg[64]=\"ENGINE_rsa_sign\";\\r\\nif (!p_surewarehk_Rsa_Sign)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse if (!(hptr=RSA_get_ex_data(rsa, rsaHndidx)))\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,SUREWARE_R_MISSING_KEY_COMPONENTS);\\r\\n}\\r\\nelse\\r\\n{\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\nret=p_surewarehk_Rsa_Sign(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_PKCS1_PAD);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_SIGN,ret);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\ndefault:\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,SUREWARE_R_UNKNOWN_PADDING_TYPE);\\r\\n}\\r\\n}\\r\\nreturn ret==1 ? tlen : ret;\\r\\n}\\r\\nstatic DSA_SIG * surewarehk_dsa_do_sign(const unsigned char *from, int flen, DSA *dsa)\\r\\n{\\r\\nint ret=0;\\r\\nchar *hptr=NULL;\\r\\nDSA_SIG *psign=NULL;\\r\\nchar msg[64]=\"ENGINE_dsa_do_sign\";\\r\\nif (!p_surewarehk_Dsa_Sign)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse if (!(hptr=DSA_get_ex_data(dsa, dsaHndidx)))\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,SUREWARE_R_MISSING_KEY_COMPONENTS);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif((psign = DSA_SIG_new()) == NULL)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npsign->r=BN_new();\\r\\npsign->s=BN_new();\\r\\nbn_expand2(psign->r, 20/sizeof(BN_ULONG));\\r\\nbn_expand2(psign->s, 20/sizeof(BN_ULONG));\\r\\nif (!psign->r || psign->r->dmax!=20/sizeof(BN_ULONG) ||\\r\\n!psign->s || psign->s->dmax!=20/sizeof(BN_ULONG))\\r\\ngoto err;\\r\\nret=p_surewarehk_Dsa_Sign(msg,flen,from,\\r\\n(unsigned long *)psign->r->d,\\r\\n(unsigned long *)psign->s->d,\\r\\nhptr);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ret);\\r\\n}\\r\\npsign->r->top=20/sizeof(BN_ULONG);\\r\\nbn_fix_top(psign->r);\\r\\npsign->s->top=20/sizeof(BN_ULONG);\\r\\nbn_fix_top(psign->s);\\r\\nerr:\\r\\nif (psign)\\r\\n{\\r\\nDSA_SIG_free(psign);\\r\\npsign=NULL;\\r\\n}\\r\\nreturn psign;\\r\\n}\\r\\nstatic int surewarehk_modexp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nchar msg[64]=\"ENGINE_modexp\";\\r\\nif (!p_surewarehk_Mod_Exp)\\r\\n{\\r\\nSUREWAREerr(SUREWARE_F_SUREWAREHK_MODEXP,ENGINE_R_NOT_INITIALISED);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbn_expand2(r,m->top);\\r\\nif (r && r->dmax==m->top)\\r\\n{\\r\\nret=p_surewarehk_Mod_Exp(msg,\\r\\nm->top*sizeof(BN_ULONG),\\r\\n(unsigned long *)m->d,\\r\\np->top*sizeof(BN_ULONG),\\r\\n(unsigned long *)p->d,\\r\\na->top*sizeof(BN_ULONG),\\r\\n(unsigned long *)a->d,\\r\\n(unsigned long *)r->d);\\r\\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_MODEXP,ret);\\r\\nif (ret==1)\\r\\n{\\r\\nr->top=m->top;\\r\\nbn_fix_top(r);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_tree_c", "target": 0, "func": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache)\\r\\n{\\r\\nint i;\\r\\nX509_POLICY_LEVEL *last;\\r\\nX509_POLICY_DATA *data;\\r\\nX509_POLICY_NODE *parent;\\r\\nlast = curr - 1;\\r\\nfor (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++)\\r\\n{\\r\\ndata = sk_X509_POLICY_DATA_value(cache->data, i);\\r\\nif ((data->flags & POLICY_DATA_FLAG_MAPPED_ANY)\\r\\n&& !(curr->flags & X509_V_FLAG_INHIBIT_ANY))\\r\\ncontinue;\\r\\nparent = level_find_node(last, data->valid_policy);\\r\\nif (!parent)\\r\\nparent = last->anyPolicy;\\r\\nif (parent && !level_add_node(curr, data, parent, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_link_any(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache,\\r\\nX509_POLICY_TREE *tree)\\r\\n{\\r\\nint i;\\r\\nX509_POLICY_DATA *data;\\r\\nX509_POLICY_NODE *node;\\r\\nX509_POLICY_LEVEL *last;\\r\\nlast = curr - 1;\\r\\nfor (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++)\\r\\n{\\r\\nnode = sk_X509_POLICY_NODE_value(last->nodes, i);\\r\\nif (node->nchild)\\r\\ncontinue;\\r\\ndata = policy_data_new(NULL, node->data->valid_policy,\\r\\nnode_critical(node));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\ndata->qualifier_set = curr->anyPolicy->data->qualifier_set;\\r\\ndata->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\\r\\nif (!level_add_node(curr, data, node, tree))\\r\\n{\\r\\npolicy_data_free(data);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (last->anyPolicy)\\r\\n{\\r\\nif (!level_add_node(curr, cache->anyPolicy,\\r\\nlast->anyPolicy, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_prune(X509_POLICY_TREE *tree, X509_POLICY_LEVEL *curr)\\r\\n{\\r\\nX509_POLICY_NODE *node;\\r\\nint i;\\r\\nfor (i = sk_X509_POLICY_NODE_num(curr->nodes) - 1; i >= 0; i--)\\r\\n{\\r\\nnode = sk_X509_POLICY_NODE_value(curr->nodes, i);\\r\\nif (node->data->flags & POLICY_DATA_FLAG_MAP_MASK)\\r\\n{\\r\\nnode->parent->nchild--;\\r\\nOPENSSL_free(node);\\r\\nsk_X509_POLICY_NODE_delete(curr->nodes, i);\\r\\n}\\r\\n}\\r\\nfor(;;) {\\r\\n--curr;\\r\\nfor (i = sk_X509_POLICY_NODE_num(curr->nodes) - 1; i >= 0; i--)\\r\\n{\\r\\nnode = sk_X509_POLICY_NODE_value(curr->nodes, i);\\r\\nif (node->nchild == 0)\\r\\n{\\r\\nnode->parent->nchild--;\\r\\nOPENSSL_free(node);\\r\\nsk_X509_POLICY_NODE_delete(curr->nodes, i);\\r\\n}\\r\\n}\\r\\nif (curr->anyPolicy && !curr->anyPolicy->nchild)\\r\\n{\\r\\nif (curr->anyPolicy->parent)\\r\\ncurr->anyPolicy->parent->nchild--;\\r\\nOPENSSL_free(curr->anyPolicy);\\r\\ncurr->anyPolicy = NULL;\\r\\n}\\r\\nif (curr == tree->levels)\\r\\n{\\r\\nif (!curr->anyPolicy)\\r\\nreturn 2;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_evaluate(X509_POLICY_TREE *tree)\\r\\n{\\r\\nint ret, i;\\r\\nX509_POLICY_LEVEL *curr = tree->levels + 1;\\r\\nconst X509_POLICY_CACHE *cache;\\r\\nfor(i = 1; i < tree->nlevel; i++, curr++)\\r\\n{\\r\\ncache = policy_cache_set(curr->cert);\\r\\nif (!tree_link_nodes(curr, cache))\\r\\nreturn 0;\\r\\nif (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\\r\\n&& !tree_link_any(curr, cache, tree))\\r\\nreturn 0;\\r\\nret = tree_prune(tree, curr);\\r\\nif (ret != 1)\\r\\nreturn ret;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void exnode_free(X509_POLICY_NODE *node)\\r\\n{\\r\\nif (node->data && (node->data->flags & POLICY_DATA_FLAG_EXTRA_NODE))\\r\\nOPENSSL_free(node);\\r\\n}\\r\\nvoid X509_policy_tree_free(X509_POLICY_TREE *tree)\\r\\n{\\r\\nX509_POLICY_LEVEL *curr;\\r\\nint i;\\r\\nif (!tree)\\r\\nreturn;\\r\\nsk_X509_POLICY_NODE_free(tree->auth_policies);\\r\\nsk_X509_POLICY_NODE_pop_free(tree->user_policies, exnode_free);\\r\\nfor(i = 0, curr = tree->levels; i < tree->nlevel; i++, curr++)\\r\\n{\\r\\nif (curr->cert)\\r\\nX509_free(curr->cert);\\r\\nif (curr->nodes)\\r\\nsk_X509_POLICY_NODE_pop_free(curr->nodes,\\r\\npolicy_node_free);\\r\\nif (curr->anyPolicy)\\r\\npolicy_node_free(curr->anyPolicy);\\r\\n}\\r\\nif (tree->extra_data)\\r\\nsk_X509_POLICY_DATA_pop_free(tree->extra_data,\\r\\npolicy_data_free);\\r\\nOPENSSL_free(tree->levels);\\r\\nOPENSSL_free(tree);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_alt_c", "target": 0, "func": "static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)\\r\\n{\\r\\nGENERAL_NAMES *ialt;\\r\\nGENERAL_NAME *gen;\\r\\nX509_EXTENSION *ext;\\r\\nint i;\\r\\nif(ctx && (ctx->flags == CTX_TEST)) return 1;\\r\\nif(!ctx || !ctx->issuer_cert) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER,X509V3_R_NO_ISSUER_DETAILS);\\r\\ngoto err;\\r\\n}\\r\\ni = X509_get_ext_by_NID(ctx->issuer_cert, NID_subject_alt_name, -1);\\r\\nif(i < 0) return 1;\\r\\nif(!(ext = X509_get_ext(ctx->issuer_cert, i)) ||\\r\\n!(ialt = X509V3_EXT_d2i(ext)) ) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER,X509V3_R_ISSUER_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nfor(i = 0; i < sk_GENERAL_NAME_num(ialt); i++) {\\r\\ngen = sk_GENERAL_NAME_value(ialt, i);\\r\\nif(!sk_GENERAL_NAME_push(gens, gen)) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nsk_GENERAL_NAME_free(ialt);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nstatic int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)\\r\\n{\\r\\nX509_NAME *nm;\\r\\nASN1_IA5STRING *email = NULL;\\r\\nX509_NAME_ENTRY *ne;\\r\\nGENERAL_NAME *gen = NULL;\\r\\nint i;\\r\\nif(ctx->flags == CTX_TEST) return 1;\\r\\nif(!ctx || (!ctx->subject_cert && !ctx->subject_req)) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL,X509V3_R_NO_SUBJECT_DETAILS);\\r\\ngoto err;\\r\\n}\\r\\nif(ctx->subject_cert) nm = X509_get_subject_name(ctx->subject_cert);\\r\\nelse nm = X509_REQ_get_subject_name(ctx->subject_req);\\r\\ni = -1;\\r\\nwhile((i = X509_NAME_get_index_by_NID(nm,\\r\\nNID_pkcs9_emailAddress, i)) >= 0) {\\r\\nne = X509_NAME_get_entry(nm, i);\\r\\nemail = M_ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));\\r\\nif (move_p)\\r\\n{\\r\\nX509_NAME_delete_entry(nm, i);\\r\\ni--;\\r\\n}\\r\\nif(!email || !(gen = GENERAL_NAME_new())) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ngen->d.ia5 = email;\\r\\nemail = NULL;\\r\\ngen->type = GEN_EMAIL;\\r\\nif(!sk_GENERAL_NAME_push(gens, gen)) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ngen = NULL;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nGENERAL_NAME_free(gen);\\r\\nM_ASN1_IA5STRING_free(email);\\r\\nreturn 0;\\r\\n}\\r\\nGENERAL_NAME *v2i_GENERAL_NAME(X509V3_EXT_METHOD *method, X509V3_CTX *ctx,\\r\\nCONF_VALUE *cnf)\\r\\n{\\r\\nreturn v2i_GENERAL_NAME_ex(NULL, method, ctx, cnf, 0);\\r\\n}\\r\\nGENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,\\r\\nX509V3_EXT_METHOD *method, X509V3_CTX *ctx,\\r\\nCONF_VALUE *cnf, int is_nc)\\r\\n{\\r\\nchar is_string = 0;\\r\\nint type;\\r\\nGENERAL_NAME *gen = NULL;\\r\\nchar *name, *value;\\r\\nname = cnf->name;\\r\\nvalue = cnf->value;\\r\\nif(!value)\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_MISSING_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (out)\\r\\ngen = out;\\r\\nelse\\r\\n{\\r\\ngen = GENERAL_NAME_new();\\r\\nif(gen == NULL)\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nif(!name_cmp(name, \"email\"))\\r\\n{\\r\\nis_string = 1;\\r\\ntype = GEN_EMAIL;\\r\\n}\\r\\nelse if(!name_cmp(name, \"URI\"))\\r\\n{\\r\\nis_string = 1;\\r\\ntype = GEN_URI;\\r\\n}\\r\\nelse if(!name_cmp(name, \"DNS\"))\\r\\n{\\r\\nis_string = 1;\\r\\ntype = GEN_DNS;\\r\\n}\\r\\nelse if(!name_cmp(name, \"RID\"))\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nif(!(obj = OBJ_txt2obj(value,0)))\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_OBJECT);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\ngen->d.rid = obj;\\r\\ntype = GEN_RID;\\r\\n}\\r\\nelse if(!name_cmp(name, \"IP\"))\\r\\n{\\r\\nif (is_nc)\\r\\ngen->d.ip = a2i_IPADDRESS_NC(value);\\r\\nelse\\r\\ngen->d.ip = a2i_IPADDRESS(value);\\r\\nif(gen->d.ip == NULL)\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_BAD_IP_ADDRESS);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\ntype = GEN_IPADD;\\r\\n}\\r\\nelse if(!name_cmp(name, \"dirName\"))\\r\\n{\\r\\ntype = GEN_DIRNAME;\\r\\nif (!do_dirname(gen, value, ctx))\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_DIRNAME_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if(!name_cmp(name, \"otherName\"))\\r\\n{\\r\\nif (!do_othername(gen, value, ctx))\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_OTHERNAME_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntype = GEN_OTHERNAME;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,X509V3_R_UNSUPPORTED_OPTION);\\r\\nERR_add_error_data(2, \"name=\", name);\\r\\ngoto err;\\r\\n}\\r\\nif(is_string)\\r\\n{\\r\\nif(!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||\\r\\n!ASN1_STRING_set(gen->d.ia5, (unsigned char*)value,\\r\\nstrlen(value)))\\r\\n{\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ngen->type = type;\\r\\nreturn gen;\\r\\nerr:\\r\\nGENERAL_NAME_free(gen);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)\\r\\n{\\r\\nchar *objtmp = NULL, *p;\\r\\nint objlen;\\r\\nif (!(p = strchr(value, ';')))\\r\\nreturn 0;\\r\\nif (!(gen->d.otherName = OTHERNAME_new()))\\r\\nreturn 0;\\r\\nASN1_TYPE_free(gen->d.otherName->value);\\r\\nif (!(gen->d.otherName->value = ASN1_generate_v3(p + 1, ctx)))\\r\\nreturn 0;\\r\\nobjlen = p - value;\\r\\nobjtmp = OPENSSL_malloc(objlen + 1);\\r\\nstrncpy(objtmp, value, objlen);\\r\\nobjtmp[objlen] = 0;\\r\\ngen->d.otherName->type_id = OBJ_txt2obj(objtmp, 0);\\r\\nOPENSSL_free(objtmp);\\r\\nif (!gen->d.otherName->type_id)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nSTACK_OF(CONF_VALUE) *sk;\\r\\nX509_NAME *nm;\\r\\nif (!(nm = X509_NAME_new()))\\r\\nreturn 0;\\r\\nsk = X509V3_get_section(ctx, value);\\r\\nif (!sk)\\r\\n{\\r\\nX509V3err(X509V3_F_DO_DIRNAME,X509V3_R_SECTION_NOT_FOUND);\\r\\nERR_add_error_data(2, \"section=\", value);\\r\\nX509_NAME_free(nm);\\r\\nreturn 0;\\r\\n}\\r\\nret = X509V3_NAME_from_section(nm, sk, MBSTRING_ASC);\\r\\nif (!ret)\\r\\nX509_NAME_free(nm);\\r\\ngen->d.dirn = nm;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_srvr_c", "target": 0, "func": "static SSL_METHOD *ssl2_get_server_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_server_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_server_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_server_data.ssl_accept=ssl2_accept;\\r\\nSSLv2_server_data.get_ssl_method=ssl2_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv2_server_data);\\r\\n}\\r\\nint ssl2_accept(SSL *s)\\r\\n{\\r\\nunsigned long l=time(NULL);\\r\\nBUF_MEM *buf=NULL;\\r\\nint ret= -1;\\r\\nlong num1;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint new_state,state;\\r\\nRAND_add(&l,sizeof(l),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nclear_sys_error();\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->version=SSL2_VERSION;\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nbuf=s->init_buf;\\r\\nif ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))\\r\\n{ ret= -1; goto end; }\\r\\nif (!BUF_MEM_grow(buf,(int)\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{ ret= -1; goto end; }\\r\\ns->init_buf=buf;\\r\\ns->init_num=0;\\r\\ns->ctx->stats.sess_accept++;\\r\\ns->handshake_func=ssl2_accept;\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A:\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B:\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C:\\r\\ns->shutdown=0;\\r\\nret=get_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A:\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B:\\r\\nret=server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (!s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_GET_CLIENT_MASTER_KEY_A;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_SERVER_START_ENCRYPTION;\\r\\nBREAK;\\r\\n}\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A:\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B:\\r\\nret=get_client_master_key(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SERVER_START_ENCRYPTION;\\r\\nBREAK;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION:\\r\\nif (!ssl2_enc_init(s,0))\\r\\n{ ret= -1; goto end; }\\r\\ns->s2->clear_text=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A:\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B:\\r\\nret=server_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_C;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_A;\\r\\nbreak;\\r\\n}\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 != 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A:\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B:\\r\\nret=get_client_finished(s);\\r\\nif (ret <= 0)\\r\\ngoto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D:\\r\\nif (!(s->verify_mode & SSL_VERIFY_PEER) ||\\r\\n((s->session->peer != NULL) &&\\r\\n(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)))\\r\\n{\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_A;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=request_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_A;\\r\\n}\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A:\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B:\\r\\nret=server_finish(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL_ST_OK;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nBUF_MEM_free(s->init_buf);\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_buf=NULL;\\r\\ns->init_num=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_SERVER);\\r\\ns->ctx->stats.sess_accept_good++;\\r\\nret=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL2_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int get_client_master_key(SSL *s)\\r\\n{\\r\\nint is_export,i,n,keya,ek;\\r\\nunsigned long len;\\r\\nunsigned char *p;\\r\\nSSL_CIPHER *cp;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),10-s->init_num);\\r\\nif (i < (10-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_MASTER_KEY,i));\\r\\ns->init_num = 10;\\r\\nif (*(p++) != SSL2_MT_CLIENT_MASTER_KEY)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ncp=ssl2_get_cipher_by_char(p);\\r\\nif (cp == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_CIPHER_MATCH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->session->cipher= cp;\\r\\np+=3;\\r\\nn2s(p,i); s->s2->tmp.clear=i;\\r\\nn2s(p,i); s->s2->tmp.enc=i;\\r\\nn2s(p,i); s->session->key_arg_length=i;\\r\\nif(s->session->key_arg_length > SSL_MAX_KEY_ARG_LENGTH)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_KEY_ARG_TOO_LONG);\\r\\nreturn -1;\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_MASTER_KEY_B;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->init_buf->length < SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nkeya=s->session->key_arg_length;\\r\\nlen = 10 + (unsigned long)s->s2->tmp.clear + (unsigned long)s->s2->tmp.enc + (unsigned long)keya;\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_MESSAGE_TOO_LONG);\\r\\nreturn -1;\\r\\n}\\r\\nn = (int)len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i != n) return(ssl2_part_read(s,SSL_F_GET_CLIENT_MASTER_KEY,i));\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, (size_t)len, s, s->msg_callback_arg);\\r\\np += 10;\\r\\nmemcpy(s->session->key_arg,&(p[s->s2->tmp.clear+s->s2->tmp.enc]),\\r\\n(unsigned int)keya);\\r\\nif (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_NO_PRIVATEKEY);\\r\\nreturn(-1);\\r\\n}\\r\\ni=ssl_rsa_private_decrypt(s->cert,s->s2->tmp.enc,\\r\\n&(p[s->s2->tmp.clear]),&(p[s->s2->tmp.clear]),\\r\\n(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);\\r\\nis_export=SSL_C_IS_EXPORT(s->session->cipher);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(0);\\r\\n}\\r\\nif (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)\\r\\n{\\r\\nis_export=1;\\r\\nek=8;\\r\\n}\\r\\nelse\\r\\nek=5;\\r\\n#if 1\\r\\nif ((i < 0) ||\\r\\n((!is_export && (i != EVP_CIPHER_key_length(c)))\\r\\n|| (is_export && ((i != ek) || (s->s2->tmp.clear+(unsigned int)i !=\\r\\n(unsigned int)EVP_CIPHER_key_length(c))))))\\r\\n{\\r\\nERR_clear_error();\\r\\nif (is_export)\\r\\ni=ek;\\r\\nelse\\r\\ni=EVP_CIPHER_key_length(c);\\r\\nif (RAND_pseudo_bytes(p,i) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\n#else\\r\\nif (i < 0)\\r\\n{\\r\\nerror=1;\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_RSA_DECRYPT);\\r\\n}\\r\\nelse if ((!is_export && (i != EVP_CIPHER_key_length(c)))\\r\\n|| (is_export && ((i != ek) || (s->s2->tmp.clear+i !=\\r\\nEVP_CIPHER_key_length(c)))))\\r\\n{\\r\\nerror=1;\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_WRONG_NUMBER_OF_KEY_BITS);\\r\\n}\\r\\nif (error)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n#endif\\r\\nif (is_export) i+=s->s2->tmp.clear;\\r\\nif (i > SSL_MAX_MASTER_KEY_LENGTH)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\ns->session->master_key_length=i;\\r\\nmemcpy(s->session->master_key,p,(unsigned int)i);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_client_hello(SSL *s)\\r\\n{\\r\\nint i,n;\\r\\nunsigned long len;\\r\\nunsigned char *p;\\r\\nSTACK_OF(SSL_CIPHER) *cs;\\r\\nSTACK_OF(SSL_CIPHER) *cl;\\r\\nSTACK_OF(SSL_CIPHER) *prio, *allow;\\r\\nint z;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_HELLO_A)\\r\\n{\\r\\ns->first_packet=1;\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_B;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_HELLO_B)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),9-s->init_num);\\r\\nif (i < (9-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_HELLO,i));\\r\\ns->init_num = 9;\\r\\nif (*(p++) != SSL2_MT_CLIENT_HELLO)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nn2s(p,i);\\r\\nif (i < s->version) s->version=i;\\r\\nn2s(p,i); s->s2->tmp.cipher_spec_length=i;\\r\\nn2s(p,i); s->s2->tmp.session_id_length=i;\\r\\nn2s(p,i); s->s2->challenge_length=i;\\r\\nif ( (i < SSL2_MIN_CHALLENGE_LENGTH) ||\\r\\n(i > SSL2_MAX_CHALLENGE_LENGTH))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_INVALID_CHALLENGE_LENGTH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_C;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nlen = 9 + (unsigned long)s->s2->tmp.cipher_spec_length + (unsigned long)s->s2->challenge_length + (unsigned long)s->s2->tmp.session_id_length;\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_MESSAGE_TOO_LONG);\\r\\nreturn -1;\\r\\n}\\r\\nn = (int)len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i != n) return(ssl2_part_read(s,SSL_F_GET_CLIENT_HELLO,i));\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, (size_t)len, s, s->msg_callback_arg);\\r\\np += 9;\\r\\nif ((s->s2->tmp.session_id_length != 0) &&\\r\\n(s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_BAD_SSL_SESSION_ID_LENGTH);\\r\\nreturn(-1);\\r\\n}\\r\\nif (s->s2->tmp.session_id_length == 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_get_prev_session(s,&(p[s->s2->tmp.cipher_spec_length]),\\r\\ns->s2->tmp.session_id_length);\\r\\nif (i == 1)\\r\\n{\\r\\ns->hit=1;\\r\\n}\\r\\nelse if (i == -1)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CERTIFICATE);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!ssl_get_new_session(s,1))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!s->hit)\\r\\n{\\r\\ncs=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.cipher_spec_length,\\r\\n&s->session->ciphers);\\r\\nif (cs == NULL) goto mem_err;\\r\\ncl=SSL_get_ciphers(s);\\r\\nif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\\r\\n{\\r\\nprio=sk_SSL_CIPHER_dup(cl);\\r\\nif (prio == NULL) goto mem_err;\\r\\nallow = cs;\\r\\n}\\r\\nelse\\r\\n{\\r\\nprio = cs;\\r\\nallow = cl;\\r\\n}\\r\\nfor (z=0; z<sk_SSL_CIPHER_num(prio); z++)\\r\\n{\\r\\nif (sk_SSL_CIPHER_find(allow,sk_SSL_CIPHER_value(prio,z)) < 0)\\r\\n{\\r\\nsk_SSL_CIPHER_delete(prio,z);\\r\\nz--;\\r\\n}\\r\\n}\\r\\nif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\\r\\n{\\r\\nsk_SSL_CIPHER_free(s->session->ciphers);\\r\\ns->session->ciphers = prio;\\r\\n}\\r\\n}\\r\\np+=s->s2->tmp.cipher_spec_length;\\r\\np+=s->s2->tmp.session_id_length;\\r\\nif (s->s2->challenge_length > sizeof s->s2->challenge)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(s->s2->challenge,p,(unsigned int)s->s2->challenge_length);\\r\\nreturn(1);\\r\\nmem_err:\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint n,hit;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_HELLO_A)\\r\\n{\\r\\nd=p+11;\\r\\n*(p++)=SSL2_MT_SERVER_HELLO;\\r\\nhit=s->hit;\\r\\n*(p++)=(unsigned char)hit;\\r\\n#if 1\\r\\nif (!hit)\\r\\n{\\r\\nif (s->session->sess_cert != NULL)\\r\\nssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert = ssl_sess_cert_new();\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SERVER_HELLO, ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (!hit)\\r\\n{\\r\\nCRYPTO_add(&s->cert->references,1,CRYPTO_LOCK_SSL_CERT);\\r\\nif (s->session->sess_cert != NULL)\\r\\nssl_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=s->cert;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nCRYPTO_add(&s->cert->references,1,\\r\\nCRYPTO_LOCK_SSL_CERT);\\r\\ns->session->sess_cert=s->cert;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CERTIFICATE);\\r\\nSSLerr(SSL_F_SERVER_HELLO,SSL_R_NO_CERTIFICATE_SPECIFIED);\\r\\nreturn(-1);\\r\\n}\\r\\nif (hit)\\r\\n{\\r\\n*(p++)=0;\\r\\ns2n(s->version,p);\\r\\ns2n(0,p);\\r\\ns2n(0,p);\\r\\n}\\r\\nelse\\r\\n{\\r\\n*(p++)=SSL2_CT_X509_CERTIFICATE;\\r\\ns2n(s->version,p);\\r\\nn=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,NULL);\\r\\ns2n(n,p);\\r\\ni2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,&d);\\r\\nn=0;\\r\\nsk= s->session->ciphers;\\r\\nn=ssl_cipher_list_to_bytes(s,s->session->ciphers,d,0);\\r\\nd+=n;\\r\\ns2n(n,p);\\r\\n}\\r\\ns2n(SSL2_CONNECTION_ID_LENGTH,p);\\r\\ns->s2->conn_id_length=SSL2_CONNECTION_ID_LENGTH;\\r\\nif (RAND_pseudo_bytes(s->s2->conn_id,(int)s->s2->conn_id_length) <= 0)\\r\\nreturn -1;\\r\\nmemcpy(d,s->s2->conn_id,SSL2_CONNECTION_ID_LENGTH);\\r\\nd+=SSL2_CONNECTION_ID_LENGTH;\\r\\ns->state=SSL2_ST_SEND_SERVER_HELLO_B;\\r\\ns->init_num=d-(unsigned char *)s->init_buf->data;\\r\\ns->init_off=0;\\r\\n}\\r\\nif (s->hit)\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) return(-1);\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int get_client_finished(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nint i, n;\\r\\nunsigned long len;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_FINISHED_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);\\r\\nif (i < 1-s->init_num)\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_FINISHED,i));\\r\\ns->init_num += i;\\r\\nif (*p != SSL2_MT_CLIENT_FINISHED)\\r\\n{\\r\\nif (*p != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_PEER_ERROR);\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);\\r\\nreturn ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_B;\\r\\n}\\r\\nif (s->s2->conn_id_length > sizeof s->s2->conn_id)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nlen = 1 + (unsigned long)s->s2->conn_id_length;\\r\\nn = (int)len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i < n)\\r\\n{\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_FINISHED,i));\\r\\n}\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg);\\r\\np += 1;\\r\\nif (memcmp(p,s->s2->conn_id,s->s2->conn_id_length) != 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_CONNECTION_ID_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int server_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_VERIFY_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_SERVER_VERIFY;\\r\\nif (s->s2->challenge_length > sizeof s->s2->challenge)\\r\\n{\\r\\nSSLerr(SSL_F_SERVER_VERIFY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(p,s->s2->challenge,(unsigned int)s->s2->challenge_length);\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_B;\\r\\ns->init_num=s->s2->challenge_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int server_finish(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_FINISHED_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_SERVER_FINISHED;\\r\\nif (s->session->session_id_length > sizeof s->session->session_id)\\r\\n{\\r\\nSSLerr(SSL_F_SERVER_FINISH, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(p,s->session->session_id, (unsigned int)s->session->session_id_length);\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_B;\\r\\ns->init_num=s->session->session_id_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int request_certificate(SSL *s)\\r\\n{\\r\\nconst unsigned char *cp;\\r\\nunsigned char *p,*p2,*buf2;\\r\\nunsigned char *ccd;\\r\\nint i,j,ctype,ret= -1;\\r\\nunsigned long len;\\r\\nX509 *x509=NULL;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nccd=s->s2->tmp.ccl;\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_REQUEST_CERTIFICATE;\\r\\n*(p++)=SSL2_AT_MD5_WITH_RSA_ENCRYPTION;\\r\\nif (RAND_pseudo_bytes(ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH) <= 0)\\r\\nreturn -1;\\r\\nmemcpy(p,ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH);\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_B;\\r\\ns->init_num=SSL2_MIN_CERT_CHALLENGE_LENGTH+2;\\r\\ns->init_off=0;\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_B)\\r\\n{\\r\\ni=ssl2_do_write(s);\\r\\nif (i <= 0)\\r\\n{\\r\\nret=i;\\r\\ngoto end;\\r\\n}\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_C;\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_C)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),6-s->init_num);\\r\\nif (i < 3-s->init_num)\\r\\n{\\r\\nret=ssl2_part_read(s,SSL_F_REQUEST_CERTIFICATE,i);\\r\\ngoto end;\\r\\n}\\r\\ns->init_num += i;\\r\\nif ((s->init_num >= 3) && (p[0] == SSL2_MT_ERROR))\\r\\n{\\r\\nn2s(p,i);\\r\\nif (i != SSL2_PE_NO_CERTIFICATE)\\r\\n{\\r\\ns->init_num -= 3;\\r\\nret = ssl2_part_read(s,SSL_F_REQUEST_CERTIFICATE, 3);\\r\\ngoto end;\\r\\n}\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, 3, s, s->msg_callback_arg);\\r\\nif (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\ngoto end;\\r\\n}\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif ((*(p++) != SSL2_MT_CLIENT_CERTIFICATE) || (s->init_num < 6))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_SHORT_READ);\\r\\ngoto end;\\r\\n}\\r\\nif (s->init_num != 6)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE, ERR_R_INTERNAL_ERROR);\\r\\ngoto end;\\r\\n}\\r\\nctype= *(p++);\\r\\nif (ctype != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_RESPONSE_ARGUMENT);\\r\\ngoto end;\\r\\n}\\r\\nn2s(p,i); s->s2->tmp.clen=i;\\r\\nn2s(p,i); s->s2->tmp.rlen=i;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_D;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nlen = 6 + (unsigned long)s->s2->tmp.clen + (unsigned long)s->s2->tmp.rlen;\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_MESSAGE_TOO_LONG);\\r\\ngoto end;\\r\\n}\\r\\nj = (int)len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(p[s->init_num]),j);\\r\\nif (i < j)\\r\\n{\\r\\nret=ssl2_part_read(s,SSL_F_REQUEST_CERTIFICATE,i);\\r\\ngoto end;\\r\\n}\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg);\\r\\np += 6;\\r\\ncp = p;\\r\\nx509=(X509 *)d2i_X509(NULL,&cp,(long)s->s2->tmp.clen);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_X509_LIB);\\r\\ngoto msg_end;\\r\\n}\\r\\nif (((sk=sk_X509_new_null()) == NULL) || (!sk_X509_push(sk,x509)))\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto msg_end;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif (i)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_VerifyInit_ex(&ctx,s->ctx->rsa_md5, NULL);\\r\\nEVP_VerifyUpdate(&ctx,s->s2->key_material,\\r\\ns->s2->key_material_length);\\r\\nEVP_VerifyUpdate(&ctx,ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH);\\r\\ni=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,NULL);\\r\\nbuf2=OPENSSL_malloc((unsigned int)i);\\r\\nif (buf2 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto msg_end;\\r\\n}\\r\\np2=buf2;\\r\\ni=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,&p2);\\r\\nEVP_VerifyUpdate(&ctx,buf2,(unsigned int)i);\\r\\nOPENSSL_free(buf2);\\r\\npkey=X509_get_pubkey(x509);\\r\\nif (pkey == NULL) goto end;\\r\\ni=EVP_VerifyFinal(&ctx,cp,s->s2->tmp.rlen,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (i)\\r\\n{\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\ns->session->peer=x509;\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\ns->session->verify_result = s->verify_result;\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);\\r\\ngoto msg_end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmsg_end:\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\n}\\r\\nend:\\r\\nsk_X509_free(sk);\\r\\nX509_free(x509);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_rsa_private_decrypt(CERT *c, int len, unsigned char *from,\\r\\nunsigned char *to, int padding)\\r\\n{\\r\\nRSA *rsa;\\r\\nint i;\\r\\nif ((c == NULL) || (c->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,SSL_R_NO_PRIVATEKEY);\\r\\nreturn(-1);\\r\\n}\\r\\nif (c->pkeys[SSL_PKEY_RSA_ENC].privatekey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);\\r\\nreturn(-1);\\r\\n}\\r\\nrsa=c->pkeys[SSL_PKEY_RSA_ENC].privatekey->pkey.rsa;\\r\\ni=RSA_private_decrypt(len,from,to,rsa,padding);\\r\\nif (i < 0)\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,ERR_R_RSA_LIB);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_selfsign_c", "target": 0, "func": "int main()\\r\\n{\\r\\nBIO *bio_err;\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\nbio_err=BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nmkit(&x509,&pkey,512,0,365);\\r\\nRSA_print_fp(stdout,pkey->pkey.rsa,0);\\r\\nX509_print_fp(stdout,x509);\\r\\nPEM_write_PrivateKey(stdout,pkey,NULL,NULL,0,NULL, NULL);\\r\\nPEM_write_X509(stdout,x509);\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\n#ifdef CUSTOM_EXT\\r\\nX509V3_EXT_cleanup();\\r\\nOBJ_cleanup();\\r\\n#endif\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nBIO_free(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void MS_CALLBACK callback(p, n, arg)\\r\\nint p;\\r\\nint n;\\r\\nvoid *arg;\\r\\n{\\r\\nchar c='B';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nfputc(c,stderr);\\r\\n}\\r\\nint mkit(x509p,pkeyp,bits,serial,days)\\r\\nX509 **x509p;\\r\\nEVP_PKEY **pkeyp;\\r\\nint bits;\\r\\nint serial;\\r\\nint days;\\r\\n{\\r\\nX509 *x;\\r\\nEVP_PKEY *pk;\\r\\nRSA *rsa;\\r\\nX509_NAME *name=NULL;\\r\\nX509_NAME_ENTRY *ne=NULL;\\r\\nX509_EXTENSION *ex=NULL;\\r\\nif ((pkeyp == NULL) || (*pkeyp == NULL))\\r\\n{\\r\\nif ((pk=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nabort();\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\npk= *pkeyp;\\r\\nif ((x509p == NULL) || (*x509p == NULL))\\r\\n{\\r\\nif ((x=X509_new()) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nx= *x509p;\\r\\nrsa=RSA_generate_key(bits,RSA_F4,callback,NULL);\\r\\nif (!EVP_PKEY_assign_RSA(pk,rsa))\\r\\n{\\r\\nabort();\\r\\ngoto err;\\r\\n}\\r\\nrsa=NULL;\\r\\nX509_set_version(x,3);\\r\\nASN1_INTEGER_set(X509_get_serialNumber(x),serial);\\r\\nX509_gmtime_adj(X509_get_notBefore(x),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);\\r\\nX509_set_pubkey(x,pk);\\r\\nname=X509_get_subject_name(x);\\r\\nX509_NAME_add_entry_by_txt(name,\"C\",\\r\\nMBSTRING_ASC, \"UK\", -1, -1, 0);\\r\\nX509_NAME_add_entry_by_txt(name,\"CN\",\\r\\nMBSTRING_ASC, \"OpenSSL Group\", -1, -1, 0);\\r\\nX509_set_issuer_name(x,name);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_cert_type, \"server\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_comment,\\r\\n\"example comment extension\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_ssl_server_name,\\r\\n\"www.openssl.org\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\n#if 0\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_basic_constraints,\\r\\n\"critical,CA:TRUE\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\n#endif\\r\\n#ifdef CUSTOM_EXT\\r\\n{\\r\\nint nid;\\r\\nnid = OBJ_create(\"1.2.3.4\", \"MyAlias\", \"My Test Alias Extension\");\\r\\nX509V3_EXT_add_alias(nid, NID_netscape_comment);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, nid,\\r\\n\"example comment alias\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\n}\\r\\n#endif\\r\\nif (!X509_sign(x,pk,EVP_md5()))\\r\\ngoto err;\\r\\n*x509p=x;\\r\\n*pkeyp=pk;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_d2_c", "target": 0, "func": "int X509_STORE_set_default_paths(X509_STORE *ctx)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nreturn(1);\\r\\n}\\r\\nint X509_STORE_load_locations(X509_STORE *ctx, const char *file,\\r\\nconst char *path)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nif (file != NULL)\\r\\n{\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) return(0);\\r\\nif (X509_LOOKUP_load_file(lookup,file,X509_FILETYPE_PEM) != 1)\\r\\nreturn(0);\\r\\n}\\r\\nif (path != NULL)\\r\\n{\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) return(0);\\r\\nif (X509_LOOKUP_add_dir(lookup,path,X509_FILETYPE_PEM) != 1)\\r\\nreturn(0);\\r\\n}\\r\\nif ((path == NULL) && (file == NULL))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_alld_c", "target": 0, "func": "void OpenSSL_add_all_digests(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_MD2\\r\\nEVP_add_digest(EVP_md2());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD4\\r\\nEVP_add_digest(EVP_md4());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest_alias(SN_md5,\"ssl2-md5\");\\r\\nEVP_add_digest_alias(SN_md5,\"ssl3-md5\");\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA0)\\r\\nEVP_add_digest(EVP_sha());\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nEVP_add_digest(EVP_dss());\\r\\n#endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");\\r\\nEVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nEVP_add_digest(EVP_dss1());\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"DSS1\");\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"dss1\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nEVP_add_digest(EVP_ecdsa());\\r\\n#endif\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_MDC2) && !defined(OPENSSL_NO_DES)\\r\\nEVP_add_digest(EVP_mdc2());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RIPEMD\\r\\nEVP_add_digest(EVP_ripemd160());\\r\\nEVP_add_digest_alias(SN_ripemd160,\"ripemd\");\\r\\nEVP_add_digest_alias(SN_ripemd160,\"rmd160\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA256\\r\\nEVP_add_digest(EVP_sha224());\\r\\nEVP_add_digest(EVP_sha256());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA512\\r\\nEVP_add_digest(EVP_sha384());\\r\\nEVP_add_digest(EVP_sha512());\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cfb_enc_c", "target": 0, "func": "void DES_cfb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, DES_key_schedule *schedule, DES_cblock *ivec,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG d0,d1,v0,v1;\\r\\nregister unsigned long l=length;\\r\\nregister int num=numbits/8,n=(numbits+7)/8,i,rem=numbits%8;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\n#ifndef L_ENDIAN\\r\\nunsigned char ovec[16];\\r\\n#else\\r\\nunsigned int sh[4];\\r\\nunsigned char *ovec=(unsigned char *)sh;\\r\\nassert (sizeof(sh[0])==4);\\r\\n#endif\\r\\nif (numbits<=0 || numbits > 64) return;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nif (enc)\\r\\n{\\r\\nwhile (l >= (unsigned long)n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt1((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nd0^=ti[0];\\r\\nd1^=ti[1];\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\nif (numbits == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (numbits == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse\\r\\n{\\r\\n#ifndef L_ENDIAN\\r\\niv=&ovec[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nl2c(d0,iv);\\r\\nl2c(d1,iv);\\r\\n#else\\r\\nsh[0]=v0, sh[1]=v1, sh[2]=d0, sh[3]=d1;\\r\\n#endif\\r\\nif (rem==0)\\r\\nmemcpy(ovec,ovec+num,8);\\r\\nelse\\r\\nfor(i=0 ; i < 8 ; ++i)\\r\\novec[i]=ovec[i+num]<<rem |\\r\\novec[i+num+1]>>(8-rem);\\r\\n#ifdef L_ENDIAN\\r\\nv0=sh[0], v1=sh[1];\\r\\n#else\\r\\niv=&ovec[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\n#endif\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l >= (unsigned long)n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt1((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nif (numbits == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (numbits == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse\\r\\n{\\r\\n#ifndef L_ENDIAN\\r\\niv=&ovec[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nl2c(d0,iv);\\r\\nl2c(d1,iv);\\r\\n#else\\r\\nsh[0]=v0, sh[1]=v1, sh[2]=d0, sh[3]=d1;\\r\\n#endif\\r\\nif (rem==0)\\r\\nmemcpy (ovec,ovec+num,8);\\r\\nelse\\r\\nfor(i=0 ; i < 8 ; ++i)\\r\\novec[i]=ovec[i+num]<<rem |\\r\\novec[i+num+1]>>(8-rem);\\r\\n#ifdef L_ENDIAN\\r\\nv0=sh[0], v1=sh[1];\\r\\n#else\\r\\niv=&ovec[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\n#endif\\r\\n}\\r\\nd0^=ti[0];\\r\\nd1^=ti[1];\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nv0=v1=d0=d1=ti[0]=ti[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_mem_c", "target": 0, "func": "BIO_METHOD *BIO_s_mem(void)\\r\\n{\\r\\nreturn(&mem_method);\\r\\n}\\r\\nBIO *BIO_new_mem_buf(void *buf, int len)\\r\\n{\\r\\nBIO *ret;\\r\\nBUF_MEM *b;\\r\\nif (!buf) {\\r\\nBIOerr(BIO_F_BIO_NEW_MEM_BUF,BIO_R_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif(len == -1) len = strlen(buf);\\r\\nif(!(ret = BIO_new(BIO_s_mem())) ) return NULL;\\r\\nb = (BUF_MEM *)ret->ptr;\\r\\nb->data = buf;\\r\\nb->length = len;\\r\\nb->max = len;\\r\\nret->flags |= BIO_FLAGS_MEM_RDONLY;\\r\\nret->num = 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int mem_new(BIO *bi)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nif ((b=BUF_MEM_new()) == NULL)\\r\\nreturn(0);\\r\\nbi->shutdown=1;\\r\\nbi->init=1;\\r\\nbi->num= -1;\\r\\nbi->ptr=(char *)b;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int mem_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif ((a->init) && (a->ptr != NULL))\\r\\n{\\r\\nBUF_MEM *b;\\r\\nb = (BUF_MEM *)a->ptr;\\r\\nif(a->flags & BIO_FLAGS_MEM_RDONLY) b->data = NULL;\\r\\nBUF_MEM_free(b);\\r\\na->ptr=NULL;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int mem_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret= -1;\\r\\nBUF_MEM *bm;\\r\\nint i;\\r\\nchar *from,*to;\\r\\nbm=(BUF_MEM *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nret=(outl > bm->length)?bm->length:outl;\\r\\nif ((out != NULL) && (ret > 0)) {\\r\\nmemcpy(out,bm->data,ret);\\r\\nbm->length-=ret;\\r\\nif(b->flags & BIO_FLAGS_MEM_RDONLY) bm->data += ret;\\r\\nelse {\\r\\nfrom=(char *)&(bm->data[ret]);\\r\\nto=(char *)&(bm->data[0]);\\r\\nfor (i=0; i<bm->length; i++)\\r\\nto[i]=from[i];\\r\\n}\\r\\n} else if (bm->length == 0)\\r\\n{\\r\\nret = b->num;\\r\\nif (ret != 0)\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret= -1;\\r\\nint blen;\\r\\nBUF_MEM *bm;\\r\\nbm=(BUF_MEM *)b->ptr;\\r\\nif (in == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_MEM_WRITE,BIO_R_NULL_PARAMETER);\\r\\ngoto end;\\r\\n}\\r\\nif(b->flags & BIO_FLAGS_MEM_RDONLY) {\\r\\nBIOerr(BIO_F_MEM_WRITE,BIO_R_WRITE_TO_READ_ONLY_BIO);\\r\\ngoto end;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nblen=bm->length;\\r\\nif (BUF_MEM_grow_clean(bm,blen+inl) != (blen+inl))\\r\\ngoto end;\\r\\nmemcpy(&(bm->data[blen]),in,inl);\\r\\nret=inl;\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long mem_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nchar **pptr;\\r\\nBUF_MEM *bm=(BUF_MEM *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nif (bm->data != NULL)\\r\\n{\\r\\nif(b->flags & BIO_FLAGS_MEM_RDONLY)\\r\\n{\\r\\nbm->data -= bm->max - bm->length;\\r\\nbm->length = bm->max;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemset(bm->data,0,bm->max);\\r\\nbm->length=0;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nret=(long)(bm->length == 0);\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM_EOF_RETURN:\\r\\nb->num=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)bm->length;\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(char **)ptr;\\r\\n*pptr=(char *)&(bm->data[0]);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM:\\r\\nmem_free(b);\\r\\nb->shutdown=(int)num;\\r\\nb->ptr=ptr;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUF_MEM_PTR:\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(char **)ptr;\\r\\n*pptr=(char *)bm;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=(long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0L;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=(long)bm->length;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i,j;\\r\\nint ret= -1;\\r\\nchar *p;\\r\\nBUF_MEM *bm=(BUF_MEM *)bp->ptr;\\r\\nBIO_clear_retry_flags(bp);\\r\\nj=bm->length;\\r\\nif (j <= 0)\\r\\n{\\r\\n*buf='\\0';\\r\\nreturn 0;\\r\\n}\\r\\np=bm->data;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (p[i] == '\\n') break;\\r\\n}\\r\\nif (i == j)\\r\\n{\\r\\nBIO_set_retry_read(bp);\\r\\n}\\r\\nelse\\r\\ni++;\\r\\nif ((size-1) < i) i=size-1;\\r\\ni=mem_read(bp,buf,i);\\r\\nif (i > 0) buf[i]='\\0';\\r\\nret=i;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=mem_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_b64_c", "target": 0, "func": "BIO_METHOD *BIO_f_base64(void)\\r\\n{\\r\\nreturn(&methods_b64);\\r\\n}\\r\\nstatic int b64_new(BIO *bi)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nctx=(BIO_B64_CTX *)OPENSSL_malloc(sizeof(BIO_B64_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->buf_len=0;\\r\\nctx->tmp_len=0;\\r\\nctx->tmp_nl=0;\\r\\nctx->buf_off=0;\\r\\nctx->cont=1;\\r\\nctx->start=1;\\r\\nctx->encode=0;\\r\\nbi->init=1;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int b64_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int b64_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,ii,j,k,x,n,num,ret_code=0;\\r\\nBIO_B64_CTX *ctx;\\r\\nunsigned char *p,*q;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->encode != B64_DECODE)\\r\\n{\\r\\nctx->encode=B64_DECODE;\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\nEVP_DecodeInit(&(ctx->base64));\\r\\n}\\r\\nif (ctx->buf_len > 0)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nOPENSSL_assert(ctx->buf_off+i < (int)sizeof(ctx->buf));\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\n}\\r\\nret_code=0;\\r\\nwhile (outl > 0)\\r\\n{\\r\\nif (ctx->cont <= 0)\\r\\nbreak;\\r\\ni=BIO_read(b->next_bio,&(ctx->tmp[ctx->tmp_len]),\\r\\nB64_BLOCK_SIZE-ctx->tmp_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nret_code=i;\\r\\nif (!BIO_should_retry(b->next_bio))\\r\\n{\\r\\nctx->cont=i;\\r\\nif(ctx->tmp_len == 0)\\r\\nbreak;\\r\\nelse\\r\\ni = 0;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\ni+=ctx->tmp_len;\\r\\nctx->tmp_len = i;\\r\\nif (ctx->start && (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL))\\r\\n{\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nelse if (ctx->start)\\r\\n{\\r\\nq=p=(unsigned char *)ctx->tmp;\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (*(q++) != '\\n') continue;\\r\\nif (ctx->tmp_nl)\\r\\n{\\r\\np=q;\\r\\nctx->tmp_nl=0;\\r\\ncontinue;\\r\\n}\\r\\nk=EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,\\r\\n&num,p,q-p);\\r\\nif ((k <= 0) && (num == 0) && (ctx->start))\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\nelse\\r\\n{\\r\\nif (p != (unsigned char *)\\r\\n&(ctx->tmp[0]))\\r\\n{\\r\\ni-=(p- (unsigned char *)\\r\\n&(ctx->tmp[0]));\\r\\nfor (x=0; x < i; x++)\\r\\nctx->tmp[x]=p[x];\\r\\n}\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\nctx->start=0;\\r\\nbreak;\\r\\n}\\r\\np=q;\\r\\n}\\r\\nif (j == i)\\r\\n{\\r\\nif (p == (unsigned char *)&(ctx->tmp[0]))\\r\\n{\\r\\nif (i == B64_BLOCK_SIZE)\\r\\n{\\r\\nctx->tmp_nl=1;\\r\\nctx->tmp_len=0;\\r\\n}\\r\\n}\\r\\nelse if (p != q)\\r\\n{\\r\\nn=q-p;\\r\\nfor (ii=0; ii<n; ii++)\\r\\nctx->tmp[ii]=p[ii];\\r\\nctx->tmp_len=n;\\r\\n}\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nelse if ((i < B64_BLOCK_SIZE) && (ctx->cont > 0))\\r\\ncontinue;\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nint z,jj;\\r\\njj=(i>>2)<<2;\\r\\nz=EVP_DecodeBlock((unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,jj);\\r\\nif (jj > 2)\\r\\n{\\r\\nif (ctx->tmp[jj-1] == '=')\\r\\n{\\r\\nz--;\\r\\nif (ctx->tmp[jj-2] == '=')\\r\\nz--;\\r\\n}\\r\\n}\\r\\nif (jj != i)\\r\\n{\\r\\nmemcpy((unsigned char *)ctx->tmp,\\r\\n(unsigned char *)&(ctx->tmp[jj]),i-jj);\\r\\nctx->tmp_len=i-jj;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nif (z > 0)\\r\\n{\\r\\nctx->buf_len=z;\\r\\ni=1;\\r\\n}\\r\\nelse\\r\\ni=z;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)ctx->tmp,i);\\r\\nctx->tmp_len = 0;\\r\\n}\\r\\nctx->buf_off=0;\\r\\nif (i < 0)\\r\\n{\\r\\nret_code=0;\\r\\nctx->buf_len=0;\\r\\nbreak;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni=ctx->buf_len;\\r\\nelse\\r\\ni=outl;\\r\\nmemcpy(out,ctx->buf,i);\\r\\nret+=i;\\r\\nctx->buf_off=i;\\r\\nif (ctx->buf_off == ctx->buf_len)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?ret_code:ret);\\r\\n}\\r\\nstatic int b64_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=inl,n,i;\\r\\nBIO_B64_CTX *ctx;\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->encode != B64_ENCODE)\\r\\n{\\r\\nctx->encode=B64_ENCODE;\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\nEVP_EncodeInit(&(ctx->base64));\\r\\n}\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nctx->buf_off=0;\\r\\nctx->buf_len=0;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > B64_BLOCK_SIZE)?B64_BLOCK_SIZE:inl;\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nif (ctx->tmp_len > 0)\\r\\n{\\r\\nn=3-ctx->tmp_len;\\r\\nif (n > inl)\\r\\nn=inl;\\r\\nmemcpy(&(ctx->tmp[ctx->tmp_len]),in,n);\\r\\nctx->tmp_len+=n;\\r\\nif (ctx->tmp_len < 3)\\r\\nbreak;\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,\\r\\nctx->tmp_len);\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (n < 3)\\r\\n{\\r\\nmemcpy(&(ctx->tmp[0]),in,n);\\r\\nctx->tmp_len=n;\\r\\nbreak;\\r\\n}\\r\\nn-=n%3;\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)in,n);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nEVP_EncodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\n}\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?i:ret);\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long b64_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->cont=1;\\r\\nctx->start=1;\\r\\nctx->encode=B64_NONE;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif ((ret == 0) && (ctx->encode != B64_NONE)\\r\\n&& (ctx->base64.num != 0))\\r\\nret=1;\\r\\nelse if (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=b64_write(b,NULL,0);\\r\\nif (i < 0)\\r\\nreturn i;\\r\\n}\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nif (ctx->tmp_len != 0)\\r\\n{\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,\\r\\nctx->tmp_len);\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\nelse if (ctx->encode != B64_NONE && ctx->base64.num != 0)\\r\\n{\\r\\nctx->buf_off=0;\\r\\nEVP_EncodeFinal(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_SET:\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long b64_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_init_c", "target": 0, "func": "PKCS12 *PKCS12_init(int mode)\\r\\n{\\r\\nPKCS12 *pkcs12;\\r\\nif (!(pkcs12 = PKCS12_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_set(pkcs12->version, 3);\\r\\npkcs12->authsafes->type = OBJ_nid2obj(mode);\\r\\nswitch (mode) {\\r\\ncase NID_pkcs7_data:\\r\\nif (!(pkcs12->authsafes->d.data =\\r\\nM_ASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,\\r\\nPKCS12_R_UNSUPPORTED_PKCS12_MODE);\\r\\ngoto err;\\r\\n}\\r\\nreturn pkcs12;\\r\\nerr:\\r\\nif (pkcs12 != NULL) PKCS12_free(pkcs12);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_idea_c", "target": 0, "func": "static int idea_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nidea_ecb_encrypt(in + i, out + i, ctx->cipher_data);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int idea_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nif(!enc) {\\r\\nif (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE) enc = 1;\\r\\nelse if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE) enc = 1;\\r\\n}\\r\\nif (enc) idea_set_encrypt_key(key,ctx->cipher_data);\\r\\nelse\\r\\n{\\r\\nIDEA_KEY_SCHEDULE tmp;\\r\\nidea_set_encrypt_key(key,&tmp);\\r\\nidea_set_decrypt_key(&tmp,ctx->cipher_data);\\r\\nOPENSSL_cleanse((unsigned char *)&tmp,\\r\\nsizeof(IDEA_KEY_SCHEDULE));\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_bytes_c", "target": 0, "func": "ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a, const unsigned char **pp,\\r\\nlong length, int type)\\r\\n{\\r\\nASN1_STRING *ret=NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80) goto err;\\r\\nif (tag >= 32)\\r\\n{\\r\\ni=ASN1_R_TAG_VALUE_TOO_HIGH;;\\r\\ngoto err;\\r\\n}\\r\\nif (!(ASN1_tag2bit(tag) & type))\\r\\n{\\r\\ni=ASN1_R_WRONG_TYPE;\\r\\ngoto err;\\r\\n}\\r\\nif (tag == V_ASN1_BIT_STRING)\\r\\nreturn(d2i_ASN1_BIT_STRING(a,pp,length));\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\nif (len != 0)\\r\\n{\\r\\ns=(unsigned char *)OPENSSL_malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\ns[len]='\\0';\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\nret->length=(int)len;\\r\\nret->data=s;\\r\\nret->type=tag;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_TYPE_BYTES,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass)\\r\\n{\\r\\nint ret,r,constructed;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nif (tag == V_ASN1_BIT_STRING)\\r\\nreturn(i2d_ASN1_BIT_STRING(a,pp));\\r\\nret=a->length;\\r\\nr=ASN1_object_size(0,ret,tag);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nif ((tag == V_ASN1_SEQUENCE) || (tag == V_ASN1_SET))\\r\\nconstructed=1;\\r\\nelse\\r\\nconstructed=0;\\r\\nASN1_put_object(&p,constructed,ret,tag,xclass);\\r\\nmemcpy(p,a->data,a->length);\\r\\np+=a->length;\\r\\n*pp= p;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, const unsigned char **pp,\\r\\nlong length, int Ptag, int Pclass)\\r\\n{\\r\\nASN1_STRING *ret=NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != Ptag)\\r\\n{\\r\\ni=ASN1_R_WRONG_TAG;\\r\\ngoto err;\\r\\n}\\r\\nif (inf & V_ASN1_CONSTRUCTED)\\r\\n{\\r\\nASN1_const_CTX c;\\r\\nc.pp=pp;\\r\\nc.p=p;\\r\\nc.inf=inf;\\r\\nc.slen=len;\\r\\nc.tag=Ptag;\\r\\nc.xclass=Pclass;\\r\\nc.max=(length == 0)?0:(p+length);\\r\\nif (!asn1_collate_primitive(ret,&c))\\r\\ngoto err;\\r\\nelse\\r\\n{\\r\\np=c.p;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len != 0)\\r\\n{\\r\\nif ((ret->length < len) || (ret->data == NULL))\\r\\n{\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\ns=(unsigned char *)OPENSSL_malloc((int)len + 1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\ns=ret->data;\\r\\nmemcpy(s,p,(int)len);\\r\\ns[len] = '\\0';\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns=NULL;\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\n}\\r\\nret->length=(int)len;\\r\\nret->data=s;\\r\\nret->type=Ptag;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_STRING_free(ret);\\r\\nASN1err(ASN1_F_D2I_ASN1_BYTES,i);\\r\\nreturn(NULL);\\r\\n}\\r\\nstatic int asn1_collate_primitive(ASN1_STRING *a, ASN1_const_CTX *c)\\r\\n{\\r\\nASN1_STRING *os=NULL;\\r\\nBUF_MEM b;\\r\\nint num;\\r\\nb.length=0;\\r\\nb.max=0;\\r\\nb.data=NULL;\\r\\nif (a == NULL)\\r\\n{\\r\\nc->error=ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nnum=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (c->inf & 1)\\r\\n{\\r\\nc->eos=ASN1_const_check_infinite_end(&c->p,\\r\\n(long)(c->max-c->p));\\r\\nif (c->eos) break;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (c->slen <= 0) break;\\r\\n}\\r\\nc->q=c->p;\\r\\nif (d2i_ASN1_bytes(&os,&c->p,c->max-c->p,c->tag,c->xclass)\\r\\n== NULL)\\r\\n{\\r\\nc->error=ERR_R_ASN1_LIB;\\r\\ngoto err;\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(&b,num+os->length))\\r\\n{\\r\\nc->error=ERR_R_BUF_LIB;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(&(b.data[num]),os->data,os->length);\\r\\nif (!(c->inf & 1))\\r\\nc->slen-=(c->p-c->q);\\r\\nnum+=os->length;\\r\\n}\\r\\nif (!asn1_const_Finish(c)) goto err;\\r\\na->length=num;\\r\\nif (a->data != NULL) OPENSSL_free(a->data);\\r\\na->data=(unsigned char *)b.data;\\r\\nif (os != NULL) ASN1_STRING_free(os);\\r\\nreturn(1);\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_COLLATE_PRIMITIVE,c->error);\\r\\nif (os != NULL) ASN1_STRING_free(os);\\r\\nif (b.data != NULL) OPENSSL_free(b.data);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_pbe_c", "target": 0, "func": "int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\\r\\n{\\r\\nEVP_PBE_CTL *pbetmp, pbelu;\\r\\nint i;\\r\\npbelu.pbe_nid = OBJ_obj2nid(pbe_obj);\\r\\nif (pbelu.pbe_nid != NID_undef) i = sk_find(pbe_algs, (char *)&pbelu);\\r\\nelse i = -1;\\r\\nif (i == -1) {\\r\\nchar obj_tmp[80];\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_UNKNOWN_PBE_ALGORITHM);\\r\\nif (!pbe_obj) BUF_strlcpy (obj_tmp, \"NULL\", sizeof obj_tmp);\\r\\nelse i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\nreturn 0;\\r\\n}\\r\\nif(!pass) passlen = 0;\\r\\nelse if (passlen == -1) passlen = strlen(pass);\\r\\npbetmp = (EVP_PBE_CTL *)sk_value (pbe_algs, i);\\r\\ni = (*pbetmp->keygen)(ctx, pass, passlen, param, pbetmp->cipher,\\r\\npbetmp->md, en_de);\\r\\nif (!i) {\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_KEYGEN_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pbe_cmp(const char * const *a, const char * const *b)\\r\\n{\\r\\nconst EVP_PBE_CTL * const *pbe1 = (const EVP_PBE_CTL * const *) a,\\r\\n* const *pbe2 = (const EVP_PBE_CTL * const *)b;\\r\\nreturn ((*pbe1)->pbe_nid - (*pbe2)->pbe_nid);\\r\\n}\\r\\nint EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,\\r\\nEVP_PBE_KEYGEN *keygen)\\r\\n{\\r\\nEVP_PBE_CTL *pbe_tmp;\\r\\nif (!pbe_algs) pbe_algs = sk_new(pbe_cmp);\\r\\nif (!(pbe_tmp = (EVP_PBE_CTL*) OPENSSL_malloc (sizeof(EVP_PBE_CTL)))) {\\r\\nEVPerr(EVP_F_EVP_PBE_ALG_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npbe_tmp->pbe_nid = nid;\\r\\npbe_tmp->cipher = cipher;\\r\\npbe_tmp->md = md;\\r\\npbe_tmp->keygen = keygen;\\r\\nsk_push (pbe_algs, (char *)pbe_tmp);\\r\\nreturn 1;\\r\\n}\\r\\nvoid EVP_PBE_cleanup(void)\\r\\n{\\r\\nsk_pop_free(pbe_algs, OPENSSL_freeFunc);\\r\\npbe_algs = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s23_clnt_c", "target": 0, "func": "static SSL_METHOD *ssl23_get_client_method(int ver)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_client_method());\\r\\n#endif\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_client_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_client_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_client_data,\\r\\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\\r\\nSSLv23_client_data.ssl_connect=ssl23_connect;\\r\\nSSLv23_client_data.get_ssl_method=ssl23_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv23_client_data);\\r\\n}\\r\\nint ssl23_connect(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf=NULL;\\r\\nunsigned long Time=time(NULL);\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CONNECT,SSL_R_SSL23_DOING_SESSION_ID_REUSE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->type=SSL_ST_CONNECT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\nbuf=NULL;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL23_ST_CW_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A:\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl23_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL23_ST_CR_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A:\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B:\\r\\nret=ssl23_get_server_hello(s);\\r\\nif (ret >= 0) cb=NULL;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL23_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (s->debug) { (void)BIO_flush(s->wbio); }\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl23_client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,j,ch_len;\\r\\nunsigned long Time,l;\\r\\nint ssl2_compat;\\r\\nint version = 0, version_major, version_minor;\\r\\nSSL_COMP *comp;\\r\\nint ret;\\r\\nssl2_compat = (s->options & SSL_OP_NO_SSLv2) ? 0 : 1;\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\nversion = TLS1_VERSION;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\nversion = SSL3_VERSION;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\n{\\r\\nversion = SSL2_VERSION;\\r\\n}\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL23_ST_CW_CLNT_HELLO_A)\\r\\n{\\r\\n#if 0\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\n#endif\\r\\np=s->s3->client_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nif (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)\\r\\nreturn -1;\\r\\nif (version == TLS1_VERSION)\\r\\n{\\r\\nversion_major = TLS1_VERSION_MAJOR;\\r\\nversion_minor = TLS1_VERSION_MINOR;\\r\\n}\\r\\nelse if (version == SSL3_VERSION)\\r\\n{\\r\\nversion_major = SSL3_VERSION_MAJOR;\\r\\nversion_minor = SSL3_VERSION_MINOR;\\r\\n}\\r\\nelse if (version == SSL2_VERSION)\\r\\n{\\r\\nversion_major = SSL2_VERSION_MAJOR;\\r\\nversion_minor = SSL2_VERSION_MINOR;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_PROTOCOLS_AVAILABLE);\\r\\nreturn(-1);\\r\\n}\\r\\ns->client_version = version;\\r\\nif (ssl2_compat)\\r\\n{\\r\\nd = &(buf[2]);\\r\\np = d + 9;\\r\\n*(d++) = SSL2_MT_CLIENT_HELLO;\\r\\n*(d++) = version_major;\\r\\n*(d++) = version_minor;\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),p,0);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\nreturn -1;\\r\\n}\\r\\ns2n(i,d);\\r\\np+=i;\\r\\n#if 0\\r\\ns->session->session_id_length=0;\\r\\n#endif\\r\\ns2n(0,d);\\r\\nif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\\r\\nch_len=SSL2_CHALLENGE_LENGTH;\\r\\nelse\\r\\nch_len=SSL2_MAX_CHALLENGE_LENGTH;\\r\\nif (SSL3_RANDOM_SIZE < ch_len)\\r\\ni=SSL3_RANDOM_SIZE;\\r\\nelse\\r\\ni=ch_len;\\r\\ns2n(i,d);\\r\\nmemset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);\\r\\nif (RAND_pseudo_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i) <= 0)\\r\\nreturn -1;\\r\\nmemcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\\r\\np+=i;\\r\\ni= p- &(buf[2]);\\r\\nbuf[0]=((i>>8)&0xff)|0x80;\\r\\nbuf[1]=(i&0xff);\\r\\ns->init_num=i+2;\\r\\ns->init_off=0;\\r\\nssl3_finish_mac(s,&(buf[2]),i);\\r\\n}\\r\\nelse\\r\\n{\\r\\nd = p = &(buf[9]);\\r\\n*(p++) = version_major;\\r\\n*(p++) = version_minor;\\r\\nmemcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);\\r\\np += SSL3_RANDOM_SIZE;\\r\\n*(p++) = 0;\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),ssl3_put_cipher_by_char);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\nreturn -1;\\r\\n}\\r\\ns2n(i,p);\\r\\np+=i;\\r\\nif (s->ctx->comp_methods == NULL)\\r\\nj=0;\\r\\nelse\\r\\nj=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\n*(p++)=1+j;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,i);\\r\\n*(p++)=comp->id;\\r\\n}\\r\\n*(p++)=0;\\r\\nl = p-d;\\r\\n*p = 42;\\r\\nd=&(buf[5]);\\r\\n*(d++)=SSL3_MT_CLIENT_HELLO;\\r\\nl2n3(l,d);\\r\\nl += 4;\\r\\nif (l > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nd=buf;\\r\\n*(d++) = SSL3_RT_HANDSHAKE;\\r\\n*(d++) = version_major;\\r\\n*(d++) = version_minor;\\r\\ns2n((int)l,d);\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\nssl3_finish_mac(s,&(buf[5]), s->init_num - 5);\\r\\n}\\r\\ns->state=SSL23_ST_CW_CLNT_HELLO_B;\\r\\ns->init_off=0;\\r\\n}\\r\\nret = ssl23_write_bytes(s);\\r\\nif ((ret >= 2) && s->msg_callback)\\r\\n{\\r\\nif (ssl2_compat)\\r\\ns->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data+2, ret-2, s, s->msg_callback_arg);\\r\\nelse\\r\\ns->msg_callback(1, version, SSL3_RT_HANDSHAKE, s->init_buf->data+5, ret-5, s, s->msg_callback_arg);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ssl23_get_server_hello(SSL *s)\\r\\n{\\r\\nchar buf[8];\\r\\nunsigned char *p;\\r\\nint i;\\r\\nint n;\\r\\nn=ssl23_read_bytes(s,7);\\r\\nif (n != 7) return(n);\\r\\np=s->packet;\\r\\nmemcpy(buf,p,n);\\r\\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&\\r\\n(p[5] == 0x00) && (p[6] == 0x02))\\r\\n{\\r\\n#ifdef OPENSSL_NO_SSL2\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n#else\\r\\nint ch_len;\\r\\nif (s->options & SSL_OP_NO_SSLv2)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\nif (s->s2 == NULL)\\r\\n{\\r\\nif (!ssl2_new(s))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nssl2_clear(s);\\r\\nif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\\r\\nch_len=SSL2_CHALLENGE_LENGTH;\\r\\nelse\\r\\nch_len=SSL2_MAX_CHALLENGE_LENGTH;\\r\\ni=(SSL3_RANDOM_SIZE < ch_len)\\r\\n?SSL3_RANDOM_SIZE:ch_len;\\r\\ns->s2->challenge_length=i;\\r\\nmemcpy(s->s2->challenge,\\r\\n&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\\r\\nif (s->s3 != NULL) ssl3_free(s);\\r\\nif (!BUF_MEM_grow_clean(s->init_buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_A;\\r\\nif (!(s->client_version == SSL2_VERSION))\\r\\ns->s2->ssl2_rollback=1;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s2->rbuf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s2->rbuf_left=n;\\r\\ns->s2->rbuf_offs=0;\\r\\ns->s2->write_sequence=1;\\r\\ns->method=SSLv2_client_method();\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\n#endif\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n((p[2] == SSL3_VERSION_MINOR) ||\\r\\n(p[2] == TLS1_VERSION_MINOR)) &&\\r\\n(p[5] == SSL3_MT_SERVER_HELLO))\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) goto err;\\r\\ns->state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s3->rbuf.left=n;\\r\\ns->s3->rbuf.offset=0;\\r\\nif ((p[2] == SSL3_VERSION_MINOR) &&\\r\\n!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ns->method=SSLv3_client_method();\\r\\n}\\r\\nelse if ((p[2] == TLS1_VERSION_MINOR) &&\\r\\n!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ns->method=TLSv1_client_method();\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_ALERT) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n((p[2] == SSL3_VERSION_MINOR) ||\\r\\n(p[2] == TLS1_VERSION_MINOR)) &&\\r\\n(p[3] == 0) &&\\r\\n(p[4] == 2))\\r\\n{\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint j;\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ni=p[5];\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(i<<8)|p[6];\\r\\ncb(s,SSL_CB_READ_ALERT,j);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNKNOWN_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (!ssl_get_new_session(s,0))\\r\\ngoto err;\\r\\ns->first_packet=1;\\r\\nreturn(SSL_connect(s));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_cert_c", "target": 0, "func": "int SSL_get_ex_data_X509_STORE_CTX_idx(void)\\r\\n{\\r\\nstatic volatile int ssl_x509_store_ctx_idx= -1;\\r\\nif (ssl_x509_store_ctx_idx < 0)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ssl_x509_store_ctx_idx < 0)\\r\\n{\\r\\nssl_x509_store_ctx_idx=X509_STORE_CTX_get_ex_new_index(\\r\\n0,\"SSL for verify callback\",NULL,NULL,NULL);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\n}\\r\\nreturn ssl_x509_store_ctx_idx;\\r\\n}\\r\\nCERT *ssl_cert_new(void)\\r\\n{\\r\\nCERT *ret;\\r\\nret=(CERT *)OPENSSL_malloc(sizeof(CERT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(CERT));\\r\\nret->key= &(ret->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\n}\\r\\nCERT *ssl_cert_dup(CERT *cert)\\r\\n{\\r\\nCERT *ret;\\r\\nint i;\\r\\nret = (CERT *)OPENSSL_malloc(sizeof(CERT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(CERT));\\r\\nret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];\\r\\nret->valid = cert->valid;\\r\\nret->mask = cert->mask;\\r\\nret->export_mask = cert->export_mask;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (cert->rsa_tmp != NULL)\\r\\n{\\r\\nRSA_up_ref(cert->rsa_tmp);\\r\\nret->rsa_tmp = cert->rsa_tmp;\\r\\n}\\r\\nret->rsa_tmp_cb = cert->rsa_tmp_cb;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (cert->dh_tmp != NULL)\\r\\n{\\r\\nret->dh_tmp = DHparams_dup(cert->dh_tmp);\\r\\nif (ret->dh_tmp == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (cert->dh_tmp->priv_key)\\r\\n{\\r\\nBIGNUM *b = BN_dup(cert->dh_tmp->priv_key);\\r\\nif (!b)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->dh_tmp->priv_key = b;\\r\\n}\\r\\nif (cert->dh_tmp->pub_key)\\r\\n{\\r\\nBIGNUM *b = BN_dup(cert->dh_tmp->pub_key);\\r\\nif (!b)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->dh_tmp->pub_key = b;\\r\\n}\\r\\n}\\r\\nret->dh_tmp_cb = cert->dh_tmp_cb;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (cert->ecdh_tmp)\\r\\n{\\r\\nEC_KEY_up_ref(cert->ecdh_tmp);\\r\\nret->ecdh_tmp = cert->ecdh_tmp;\\r\\n}\\r\\nret->ecdh_tmp_cb = cert->ecdh_tmp_cb;\\r\\n#endif\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (cert->pkeys[i].x509 != NULL)\\r\\n{\\r\\nret->pkeys[i].x509 = cert->pkeys[i].x509;\\r\\nCRYPTO_add(&ret->pkeys[i].x509->references, 1,\\r\\nCRYPTO_LOCK_X509);\\r\\n}\\r\\nif (cert->pkeys[i].privatekey != NULL)\\r\\n{\\r\\nret->pkeys[i].privatekey = cert->pkeys[i].privatekey;\\r\\nCRYPTO_add(&ret->pkeys[i].privatekey->references, 1,\\r\\nCRYPTO_LOCK_EVP_PKEY);\\r\\nswitch(i)\\r\\n{\\r\\ncase SSL_PKEY_RSA_ENC:\\r\\ncase SSL_PKEY_RSA_SIGN:\\r\\nbreak;\\r\\ncase SSL_PKEY_DSA_SIGN:\\r\\nbreak;\\r\\ncase SSL_PKEY_DH_RSA:\\r\\ncase SSL_PKEY_DH_DSA:\\r\\nbreak;\\r\\ncase SSL_PKEY_ECC:\\r\\nbreak;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, SSL_R_LIBRARY_BUG);\\r\\n}\\r\\n}\\r\\n}\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\n#ifndef OPENSSL_NO_DH\\r\\nerr:\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (ret->rsa_tmp != NULL)\\r\\nRSA_free(ret->rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (ret->dh_tmp != NULL)\\r\\nDH_free(ret->dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (ret->ecdh_tmp != NULL)\\r\\nEC_KEY_free(ret->ecdh_tmp);\\r\\n#endif\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (ret->pkeys[i].x509 != NULL)\\r\\nX509_free(ret->pkeys[i].x509);\\r\\nif (ret->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(ret->pkeys[i].privatekey);\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid ssl_cert_free(CERT *c)\\r\\n{\\r\\nint i;\\r\\nif(c == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"CERT\",c);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"ssl_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (c->rsa_tmp) RSA_free(c->rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (c->dh_tmp) DH_free(c->dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (c->ecdh_tmp) EC_KEY_free(c->ecdh_tmp);\\r\\n#endif\\r\\nfor (i=0; i<SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\nX509_free(c->pkeys[i].x509);\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\n#if 0\\r\\nif (c->pkeys[i].publickey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].publickey);\\r\\n#endif\\r\\n}\\r\\nOPENSSL_free(c);\\r\\n}\\r\\nint ssl_cert_inst(CERT **o)\\r\\n{\\r\\nif (o == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (*o == NULL)\\r\\n{\\r\\nif ((*o = ssl_cert_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSESS_CERT *ssl_sess_cert_new(void)\\r\\n{\\r\\nSESS_CERT *ret;\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESS_CERT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ret, 0 ,sizeof *ret);\\r\\nret->peer_key = &(ret->peer_pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nvoid ssl_sess_cert_free(SESS_CERT *sc)\\r\\n{\\r\\nint i;\\r\\nif (sc == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&sc->references, -1, CRYPTO_LOCK_SSL_SESS_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SESS_CERT\", sc);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"ssl_sess_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (sc->cert_chain != NULL)\\r\\nsk_X509_pop_free(sc->cert_chain, X509_free);\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (sc->peer_pkeys[i].x509 != NULL)\\r\\nX509_free(sc->peer_pkeys[i].x509);\\r\\n#if 0\\r\\nif (sc->peer_pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(sc->peer_pkeys[i].privatekey);\\r\\n#endif\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (sc->peer_rsa_tmp != NULL)\\r\\nRSA_free(sc->peer_rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (sc->peer_dh_tmp != NULL)\\r\\nDH_free(sc->peer_dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (sc->peer_ecdh_tmp != NULL)\\r\\nEC_KEY_free(sc->peer_ecdh_tmp);\\r\\n#endif\\r\\nOPENSSL_free(sc);\\r\\n}\\r\\nint ssl_set_peer_cert_type(SESS_CERT *sc,int type)\\r\\n{\\r\\nsc->peer_cert_type = type;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_add_client_CA(SSL *ssl,X509 *x)\\r\\n{\\r\\nreturn(add_client_CA(&(ssl->client_CA),x));\\r\\n}\\r\\nint SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x)\\r\\n{\\r\\nreturn(add_client_CA(&(ctx->client_CA),x));\\r\\n}\\r\\nstatic int xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(*a,*b));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ciphers_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1,i;\\r\\nint verbose=0;\\r\\nconst char **pp;\\r\\nconst char *p;\\r\\nint badops=0;\\r\\nSSL_CTX *ctx=NULL;\\r\\nSSL *ssl=NULL;\\r\\nchar *ciphers=NULL;\\r\\nSSL_METHOD *meth=NULL;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nchar buf[512];\\r\\nBIO *STDout=NULL;\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv23_server_method();\\r\\n#elif !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv3_server_method();\\r\\n#elif !defined(OPENSSL_NO_SSL2)\\r\\nmeth=SSLv2_server_method();\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nSTDout=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSTDout = BIO_push(tmpbio, STDout);\\r\\n}\\r\\n#endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-v\") == 0)\\r\\nverbose=1;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\nmeth=SSLv3_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv,\"-tls1\") == 0)\\r\\nmeth=TLSv1_client_method();\\r\\n#endif\\r\\nelse if ((strncmp(*argv,\"-h\",2) == 0) ||\\r\\n(strcmp(*argv,\"-?\") == 0))\\r\\n{\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nciphers= *argv;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nfor (pp=ciphers_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto end;\\r\\n}\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL) goto err;\\r\\nif (ciphers != NULL) {\\r\\nif(!SSL_CTX_set_cipher_list(ctx,ciphers)) {\\r\\nBIO_printf(bio_err, \"Error in cipher list\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nssl=SSL_new(ctx);\\r\\nif (ssl == NULL) goto err;\\r\\nif (!verbose)\\r\\n{\\r\\nfor (i=0; ; i++)\\r\\n{\\r\\np=SSL_get_cipher_list(ssl,i);\\r\\nif (p == NULL) break;\\r\\nif (i != 0) BIO_printf(STDout,\":\");\\r\\nBIO_printf(STDout,\"%s\",p);\\r\\n}\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nsk=SSL_get_ciphers(ssl);\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nBIO_puts(STDout,SSL_CIPHER_description(\\r\\nsk_SSL_CIPHER_value(sk,i),\\r\\nbuf,sizeof buf));\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nSSL_load_error_strings();\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nend:\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (ssl != NULL) SSL_free(ssl);\\r\\nif (STDout != NULL) BIO_free_all(STDout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_n_pkey_c", "target": 0, "func": "int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,\\r\\nint (*cb)(char *buf, int len, const char *prompt,\\r\\nint verify))\\r\\n{\\r\\nreturn i2d_RSA_NET(a, pp, cb, 0);\\r\\n}\\r\\nint i2d_RSA_NET(const RSA *a, unsigned char **pp,\\r\\nint (*cb)(char *buf, int len, const char *prompt, int verify),\\r\\nint sgckey)\\r\\n{\\r\\nint i, j, ret = 0;\\r\\nint rsalen, pkeylen, olen;\\r\\nNETSCAPE_PKEY *pkey = NULL;\\r\\nNETSCAPE_ENCRYPTED_PKEY *enckey = NULL;\\r\\nunsigned char buf[256],*zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\nif (a == NULL) return(0);\\r\\nif ((pkey=NETSCAPE_PKEY_new()) == NULL) goto err;\\r\\nif ((enckey=NETSCAPE_ENCRYPTED_PKEY_new()) == NULL) goto err;\\r\\npkey->version = 0;\\r\\npkey->algor->algorithm=OBJ_nid2obj(NID_rsaEncryption);\\r\\nif ((pkey->algor->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\npkey->algor->parameter->type=V_ASN1_NULL;\\r\\nrsalen = i2d_RSAPrivateKey(a, NULL);\\r\\npkey->private_key->length=rsalen;\\r\\npkeylen=i2d_NETSCAPE_PKEY(pkey,NULL);\\r\\nenckey->enckey->digest->length = pkeylen;\\r\\nenckey->os->length = 11;\\r\\nenckey->enckey->algor->algorithm=OBJ_nid2obj(NID_rc4);\\r\\nif ((enckey->enckey->algor->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\nenckey->enckey->algor->parameter->type=V_ASN1_NULL;\\r\\nif (pp == NULL)\\r\\n{\\r\\nolen = i2d_NETSCAPE_ENCRYPTED_PKEY(enckey, NULL);\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn olen;\\r\\n}\\r\\nif ((zz=(unsigned char *)OPENSSL_malloc(rsalen)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSA_NET,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npkey->private_key->data = zz;\\r\\ni2d_RSAPrivateKey(a,&zz);\\r\\nif ((zz=OPENSSL_malloc(pkeylen)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSA_NET,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_STRING_set(enckey->os, \"private-key\", -1))\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSA_NET,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nenckey->enckey->digest->data = zz;\\r\\ni2d_NETSCAPE_PKEY(pkey,&zz);\\r\\nOPENSSL_cleanse(pkey->private_key->data, rsalen);\\r\\nif (cb == NULL)\\r\\ncb=EVP_read_pw_string;\\r\\ni=cb((char *)buf,256,\"Enter Private Key password:\",1);\\r\\nif (i != 0)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSA_NET,ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\ni = strlen((char *)buf);\\r\\nif(sgckey) {\\r\\nEVP_Digest(buf, i, buf, NULL, EVP_md5(), NULL);\\r\\nmemcpy(buf + 16, \"SGCKEYSALT\", 10);\\r\\ni = 26;\\r\\n}\\r\\nEVP_BytesToKey(EVP_rc4(),EVP_md5(),NULL,buf,i,1,key,NULL);\\r\\nOPENSSL_cleanse(buf,256);\\r\\nzz = enckey->enckey->digest->data;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_EncryptInit_ex(&ctx,EVP_rc4(),NULL,key,NULL);\\r\\nEVP_EncryptUpdate(&ctx,zz,&i,zz,pkeylen);\\r\\nEVP_EncryptFinal_ex(&ctx,zz + i,&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nret = i2d_NETSCAPE_ENCRYPTED_PKEY(enckey, pp);\\r\\nerr:\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nRSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,\\r\\nint (*cb)(char *buf, int len, const char *prompt,\\r\\nint verify))\\r\\n{\\r\\nreturn d2i_RSA_NET(a, pp, length, cb, 0);\\r\\n}\\r\\nRSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,\\r\\nint (*cb)(char *buf, int len, const char *prompt, int verify),\\r\\nint sgckey)\\r\\n{\\r\\nRSA *ret=NULL;\\r\\nconst unsigned char *p, *kp;\\r\\nNETSCAPE_ENCRYPTED_PKEY *enckey = NULL;\\r\\np = *pp;\\r\\nenckey = d2i_NETSCAPE_ENCRYPTED_PKEY(NULL, &p, length);\\r\\nif(!enckey) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET,ASN1_R_DECODING_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((enckey->os->length != 11) || (strncmp(\"private-key\",\\r\\n(char *)enckey->os->data,11) != 0))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_RSA_NET,ASN1_R_PRIVATE_KEY_HEADER_MISSING);\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn NULL;\\r\\n}\\r\\nif (OBJ_obj2nid(enckey->enckey->algor->algorithm) != NID_rc4)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_RSA_NET,ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nkp = enckey->enckey->digest->data;\\r\\nif (cb == NULL)\\r\\ncb=EVP_read_pw_string;\\r\\nif ((ret=d2i_RSA_NET_2(a, enckey->enckey->digest,cb, sgckey)) == NULL) goto err;\\r\\n*pp = p;\\r\\nerr:\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn ret;\\r\\n}\\r\\nstatic RSA *d2i_RSA_NET_2(RSA **a, ASN1_OCTET_STRING *os,\\r\\nint (*cb)(char *buf, int len, const char *prompt,\\r\\nint verify), int sgckey)\\r\\n{\\r\\nNETSCAPE_PKEY *pkey=NULL;\\r\\nRSA *ret=NULL;\\r\\nint i,j;\\r\\nunsigned char buf[256];\\r\\nconst unsigned char *zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\ni=cb((char *)buf,256,\"Enter Private Key password:\",0);\\r\\nif (i != 0)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2,ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\ni = strlen((char *)buf);\\r\\nif(sgckey){\\r\\nEVP_Digest(buf, i, buf, NULL, EVP_md5(), NULL);\\r\\nmemcpy(buf + 16, \"SGCKEYSALT\", 10);\\r\\ni = 26;\\r\\n}\\r\\nEVP_BytesToKey(EVP_rc4(),EVP_md5(),NULL,buf,i,1,key,NULL);\\r\\nOPENSSL_cleanse(buf,256);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_DecryptInit_ex(&ctx,EVP_rc4(),NULL, key,NULL);\\r\\nEVP_DecryptUpdate(&ctx,os->data,&i,os->data,os->length);\\r\\nEVP_DecryptFinal_ex(&ctx,&(os->data[i]),&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nos->length=i+j;\\r\\nzz=os->data;\\r\\nif ((pkey=d2i_NETSCAPE_PKEY(NULL,&zz,os->length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2,ASN1_R_UNABLE_TO_DECODE_RSA_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nzz=pkey->private_key->data;\\r\\nif ((ret=d2i_RSAPrivateKey(a,&zz,pkey->private_key->length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2,ASN1_R_UNABLE_TO_DECODE_RSA_KEY);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcbc_enc_c", "target": 0, "func": "void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG sin0,sin1,xor0,xor1,tout0,tout1;\\r\\nDES_LONG tin[2];\\r\\nconst unsigned char *in;\\r\\nunsigned char *out,*iv;\\r\\nin=input;\\r\\nout=output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (; length>0; length-=8)\\r\\n{\\r\\nif (length >= 8)\\r\\n{\\r\\nc2l(in,sin0);\\r\\nc2l(in,sin1);\\r\\n}\\r\\nelse\\r\\nc2ln(in,sin0,sin1,length);\\r\\ntin[0]=sin0^xor0;\\r\\ntin[1]=sin1^xor1;\\r\\nDES_encrypt1((DES_LONG *)tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nxor0=sin0^tout0;\\r\\nxor1=sin1^tout1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0); c2l(iv,xor1);\\r\\nfor (; length>0; length-=8)\\r\\n{\\r\\nc2l(in,sin0);\\r\\nc2l(in,sin1);\\r\\ntin[0]=sin0;\\r\\ntin[1]=sin1;\\r\\nDES_encrypt1((DES_LONG *)tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nif (length >= 8)\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nelse\\r\\nl2cn(tout0,tout1,out,length);\\r\\nxor0=tout0^sin0;\\r\\nxor1=tout1^sin1;\\r\\n}\\r\\n}\\r\\ntin[0]=tin[1]=0;\\r\\nsin0=sin1=xor0=xor1=tout0=tout1=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_long_c", "target": 0, "func": "static void long_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\n*(long *)pval = it->size;\\r\\n}\\r\\nstatic int long_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it)\\r\\n{\\r\\nlong ltmp;\\r\\nunsigned long utmp;\\r\\nint clen, pad, i;\\r\\nchar *cp = (char *)pval;\\r\\nmemcpy(&ltmp, cp, sizeof(long));\\r\\nif(ltmp == it->size) return -1;\\r\\nif(ltmp < 0) utmp = -ltmp - 1;\\r\\nelse utmp = ltmp;\\r\\nclen = BN_num_bits_word(utmp);\\r\\nif(!(clen & 0x7)) pad = 1;\\r\\nelse pad = 0;\\r\\nclen = (clen + 7) >> 3;\\r\\nif(cont) {\\r\\nif(pad) *cont++ = (ltmp < 0) ? 0xff : 0;\\r\\nfor(i = clen - 1; i >= 0; i--) {\\r\\ncont[i] = (unsigned char)(utmp & 0xff);\\r\\nif(ltmp < 0) cont[i] ^= 0xff;\\r\\nutmp >>= 8;\\r\\n}\\r\\n}\\r\\nreturn clen + pad;\\r\\n}\\r\\nstatic int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nint neg, i;\\r\\nlong ltmp;\\r\\nunsigned long utmp = 0;\\r\\nchar *cp = (char *)pval;\\r\\nif(len > (int)sizeof(long)) {\\r\\nASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif(len && (cont[0] & 0x80)) neg = 1;\\r\\nelse neg = 0;\\r\\nutmp = 0;\\r\\nfor(i = 0; i < len; i++) {\\r\\nutmp <<= 8;\\r\\nif(neg) utmp |= cont[i] ^ 0xff;\\r\\nelse utmp |= cont[i];\\r\\n}\\r\\nltmp = (long)utmp;\\r\\nif(neg) {\\r\\nltmp++;\\r\\nltmp = -ltmp;\\r\\n}\\r\\nif(ltmp == it->size) {\\r\\nASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(cp, &ltmp, sizeof(long));\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509rset_c", "target": 0, "func": "int X509_REQ_set_version(X509_REQ *x, long version)\\r\\n{\\r\\nif (x == NULL) return(0);\\r\\nreturn(ASN1_INTEGER_set(x->req_info->version,version));\\r\\n}\\r\\nint X509_REQ_set_subject_name(X509_REQ *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->req_info->subject,name));\\r\\n}\\r\\nint X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL)) return(0);\\r\\nreturn(X509_PUBKEY_set(&x->req_info->pubkey,pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5_ecb_c", "target": 0, "func": "void RC5_32_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nRC5_32_KEY *ks, int encrypt)\\r\\n{\\r\\nunsigned long l,d[2];\\r\\nc2l(in,l); d[0]=l;\\r\\nc2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nRC5_32_encrypt(d,ks);\\r\\nelse\\r\\nRC5_32_decrypt(d,ks);\\r\\nl=d[0]; l2c(l,out);\\r\\nl=d[1]; l2c(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_seal_c", "target": 0, "func": "int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char **ek,\\r\\nint *ekl, unsigned char *iv, EVP_PKEY **pubk, int npubk)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nint i;\\r\\nif(type) {\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nif(!EVP_EncryptInit_ex(ctx,type,NULL,NULL,NULL)) return 0;\\r\\n}\\r\\nif ((npubk <= 0) || !pubk)\\r\\nreturn 1;\\r\\nif (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)\\r\\nreturn 0;\\r\\nif (EVP_CIPHER_CTX_iv_length(ctx))\\r\\nRAND_pseudo_bytes(iv,EVP_CIPHER_CTX_iv_length(ctx));\\r\\nif(!EVP_EncryptInit_ex(ctx,NULL,NULL,key,iv)) return 0;\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nekl[i]=EVP_PKEY_encrypt(ek[i],key,EVP_CIPHER_CTX_key_length(ctx),\\r\\npubk[i]);\\r\\nif (ekl[i] <= 0) return(-1);\\r\\n}\\r\\nreturn(npubk);\\r\\n}\\r\\nint EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\ni = EVP_EncryptFinal_ex(ctx,out,outl);\\r\\nEVP_EncryptInit_ex(ctx,NULL,NULL,NULL,NULL);\\r\\nreturn i;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_rtcp_c", "target": 0, "func": "BIO_METHOD *BIO_s_rtcp(void)\\r\\n{\\r\\nreturn(&rtcp_method);\\r\\n}\\r\\nstatic int get ( io_channel chan, char *buffer, int maxlen, int *length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = sys$qiow ( 0, chan, IO$_READVBLK, &iosb, 0, 0,\\r\\nbuffer, maxlen, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nif ( (status&1) == 1 ) *length = iosb.count;\\r\\nreturn status;\\r\\n}\\r\\nstatic int put ( io_channel chan, char *buffer, int length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = sys$qiow ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,\\r\\nbuffer, length, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nreturn status;\\r\\n}\\r\\nstatic int rtcp_new(BIO *bi)\\r\\n{\\r\\nstruct rpc_ctx *ctx;\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->flags = 0;\\r\\nbi->ptr=OPENSSL_malloc(sizeof(struct rpc_ctx));\\r\\nctx = (struct rpc_ctx *) bi->ptr;\\r\\nctx->filled = 0;\\r\\nctx->pos = 0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int rtcp_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif ( a->ptr ) OPENSSL_free ( a->ptr );\\r\\na->ptr = NULL;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int rtcp_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint status, length;\\r\\nstruct rpc_ctx *ctx;\\r\\nctx = (struct rpc_ctx *) b->ptr;\\r\\nif ( ctx->pos < ctx->filled ) {\\r\\nlength = ctx->filled - ctx->pos;\\r\\nif ( length > outl ) length = outl;\\r\\nmemmove ( out, &ctx->msg.data[ctx->pos], length );\\r\\nctx->pos += length;\\r\\nreturn length;\\r\\n}\\r\\nctx->msg.channel = 'R';\\r\\nctx->msg.function = 'G';\\r\\nctx->msg.length = sizeof(ctx->msg.data);\\r\\nstatus = put ( b->num, (char *) &ctx->msg, RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) {\\r\\nreturn -1;\\r\\n}\\r\\nctx->pos = ctx->filled = 0;\\r\\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\\r\\nif ( (status&1) == 0 ) length = -1;\\r\\nif ( ctx->msg.channel != 'R' || ctx->msg.function != 'C' ) {\\r\\nlength = -1;\\r\\n}\\r\\nctx->filled = length - RPC_HDR_SIZE;\\r\\nif ( ctx->pos < ctx->filled ) {\\r\\nlength = ctx->filled - ctx->pos;\\r\\nif ( length > outl ) length = outl;\\r\\nmemmove ( out, ctx->msg.data, length );\\r\\nctx->pos += length;\\r\\nreturn length;\\r\\n}\\r\\nreturn length;\\r\\n}\\r\\nstatic int rtcp_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint status, i, segment, length;\\r\\nstruct rpc_ctx *ctx;\\r\\nctx = (struct rpc_ctx *) b->ptr;\\r\\nfor ( i = 0; i < inl; i += segment ) {\\r\\nsegment = inl - i;\\r\\nif ( segment > sizeof(ctx->msg.data) ) segment = sizeof(ctx->msg.data);\\r\\nctx->msg.channel = 'R';\\r\\nctx->msg.function = 'P';\\r\\nctx->msg.length = segment;\\r\\nmemmove ( ctx->msg.data, &in[i], segment );\\r\\nstatus = put ( b->num, (char *) &ctx->msg, segment + RPC_HDR_SIZE );\\r\\nif ((status&1) == 0 ) { i = -1; break; }\\r\\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\\r\\nif ( ((status&1) == 0) || (length < RPC_HDR_SIZE) ) { i = -1; break; }\\r\\nif ( (ctx->msg.channel != 'R') || (ctx->msg.function != 'C') ) {\\r\\nprintf(\"unexpected response when confirming put %c %c\\n\",\\r\\nctx->msg.channel, ctx->msg.function );\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic long rtcp_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\ncase BIO_CTRL_EOF:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nb->num = num;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\ncase BIO_CTRL_FLUSH:\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int rtcp_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int rtcp_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint length;\\r\\nif (str == NULL) return(0);\\r\\nlength = strlen ( str );\\r\\nif ( length == 0 ) return (0);\\r\\nreturn rtcp_write ( bp,str, length );\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_castopts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic char key[16]={ 0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nCAST_KEY sch;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most accurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nCAST_set_key(&sch,16,key);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nCAST_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\ntime_it(CAST_encrypt_normal, \"CAST_encrypt_normal \", 0);\\r\\ntime_it(CAST_encrypt_ptr, \"CAST_encrypt_ptr \", 1);\\r\\ntime_it(CAST_encrypt_ptr2, \"CAST_encrypt_ptr2 \", 2);\\r\\nnum+=3;\\r\\nstr[0]=\"<nothing>\";\\r\\nprint_it(\"CAST_encrypt_normal \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"ptr \";\\r\\nprint_it(\"CAST_encrypt_ptr \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\"ptr2 \";\\r\\nprint_it(\"CAST_encrypt_ptr2 \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\nprintf(\"options CAST ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DCAST_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DCAST_PTR\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DCAST_PTR2\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_lib_c", "target": 0, "func": "void CONF_set_nconf(CONF *conf, LHASH *hash)\\r\\n{\\r\\nif (default_CONF_method == NULL)\\r\\ndefault_CONF_method = NCONF_default();\\r\\ndefault_CONF_method->init(conf);\\r\\nconf->data = hash;\\r\\n}\\r\\nint CONF_set_default_method(CONF_METHOD *meth)\\r\\n{\\r\\ndefault_CONF_method = meth;\\r\\nreturn 1;\\r\\n}\\r\\nLHASH *CONF_load(LHASH *conf, const char *file, long *eline)\\r\\n{\\r\\nLHASH *ltmp;\\r\\nBIO *in=NULL;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nin=BIO_new_file(file, \"r\");\\r\\n#else\\r\\nin=BIO_new_file(file, \"rb\");\\r\\n#endif\\r\\nif (in == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD,ERR_R_SYS_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nltmp = CONF_load_bio(conf, in, eline);\\r\\nBIO_free(in);\\r\\nreturn ltmp;\\r\\n}\\r\\nLHASH *CONF_load_fp(LHASH *conf, FILE *fp,long *eline)\\r\\n{\\r\\nBIO *btmp;\\r\\nLHASH *ltmp;\\r\\nif(!(btmp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_CONF_LOAD_FP,ERR_R_BUF_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nltmp = CONF_load_bio(conf, btmp, eline);\\r\\nBIO_free(btmp);\\r\\nreturn ltmp;\\r\\n}\\r\\nLHASH *CONF_load_bio(LHASH *conf, BIO *bp,long *eline)\\r\\n{\\r\\nCONF ctmp;\\r\\nint ret;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nret = NCONF_load_bio(&ctmp, bp, eline);\\r\\nif (ret)\\r\\nreturn ctmp.data;\\r\\nreturn NULL;\\r\\n}\\r\\nvoid CONF_free(LHASH *conf)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nNCONF_free_data(&ctmp);\\r\\n}\\r\\nint CONF_dump_fp(LHASH *conf, FILE *out)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nif(!(btmp = BIO_new_fp(out, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_CONF_DUMP_FP,ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = CONF_dump_bio(conf, btmp);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nint CONF_dump_bio(LHASH *conf, BIO *out)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn NCONF_dump_bio(&ctmp, out);\\r\\n}\\r\\nCONF *NCONF_new(CONF_METHOD *meth)\\r\\n{\\r\\nCONF *ret;\\r\\nif (meth == NULL)\\r\\nmeth = NCONF_default();\\r\\nret = meth->create(meth);\\r\\nif (ret == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_NCONF_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid NCONF_free(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn;\\r\\nconf->meth->destroy(conf);\\r\\n}\\r\\nvoid NCONF_free_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn;\\r\\nconf->meth->destroy_data(conf);\\r\\n}\\r\\nint NCONF_load(CONF *conf, const char *file, long *eline)\\r\\n{\\r\\nif (conf == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_NCONF_LOAD,CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->load(conf, file, eline);\\r\\n}\\r\\nint NCONF_load_fp(CONF *conf, FILE *fp,long *eline)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nif(!(btmp = BIO_new_fp(fp, BIO_NOCLOSE)))\\r\\n{\\r\\nCONFerr(CONF_F_NCONF_LOAD_FP,ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = NCONF_load_bio(conf, btmp, eline);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nint NCONF_load_bio(CONF *conf, BIO *bp,long *eline)\\r\\n{\\r\\nif (conf == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_NCONF_LOAD_BIO,CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->load_bio(conf, bp, eline);\\r\\n}\\r\\nint NCONF_dump_fp(const CONF *conf, FILE *out)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nif(!(btmp = BIO_new_fp(out, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_NCONF_DUMP_FP,ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = NCONF_dump_bio(conf, btmp);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nint NCONF_dump_bio(const CONF *conf, BIO *out)\\r\\n{\\r\\nif (conf == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_NCONF_DUMP_BIO,CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->dump(conf, out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nint ret=1;\\r\\nDSA *dsa=NULL;\\r\\nint i,badops=0;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,text=0,noout=0;\\r\\nint pubin = 0, pubout = 0;\\r\\nchar *infile,*outfile,*prog;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine;\\r\\n#endif\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nint modulus=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nengine=NULL;\\r\\n#endif\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if (strcmp(*argv,\"-pubin\") == 0)\\r\\npubin=1;\\r\\nelse if (strcmp(*argv,\"-pubout\") == 0)\\r\\npubout=1;\\r\\nelse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -passout arg output file pass phrase source\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err,\" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err,\" -modulus print the DSA public value\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"read DSA key\\n\");\\r\\nif (informat == FORMAT_ASN1) {\\r\\nif(pubin) dsa=d2i_DSA_PUBKEY_bio(in,NULL);\\r\\nelse dsa=d2i_DSAPrivateKey_bio(in,NULL);\\r\\n} else if (informat == FORMAT_PEM) {\\r\\nif(pubin) dsa=PEM_read_bio_DSA_PUBKEY(in,NULL, NULL, NULL);\\r\\nelse dsa=PEM_read_bio_DSAPrivateKey(in,NULL,NULL,passin);\\r\\n} else\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!DSA_print(out,dsa,0))\\r\\n{\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nfprintf(stdout,\"Public Key=\");\\r\\nBN_print(out,dsa->pub_key);\\r\\nfprintf(stdout,\"\\n\");\\r\\n}\\r\\nif (noout) goto end;\\r\\nBIO_printf(bio_err,\"writing DSA key\\n\");\\r\\nif (outformat == FORMAT_ASN1) {\\r\\nif(pubin || pubout) i=i2d_DSA_PUBKEY_bio(out,dsa);\\r\\nelse i=i2d_DSAPrivateKey_bio(out,dsa);\\r\\n} else if (outformat == FORMAT_PEM) {\\r\\nif(pubin || pubout)\\r\\ni=PEM_write_bio_DSA_PUBKEY(out,dsa);\\r\\nelse i=PEM_write_bio_DSAPrivateKey(out,dsa,enc,\\r\\nNULL,0,NULL, passout);\\r\\n} else {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nend:\\r\\nif(in != NULL) BIO_free(in);\\r\\nif(out != NULL) BIO_free_all(out);\\r\\nif(dsa != NULL) DSA_free(dsa);\\r\\nif(passin) OPENSSL_free(passin);\\r\\nif(passout) OPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_openssl_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_openssl(void)\\r\\n{\\r\\n#ifdef DEF_DSO_METHOD\\r\\nreturn(DEF_DSO_METHOD());\\r\\n#elif defined(DSO_DLFCN)\\r\\nreturn(DSO_METHOD_dlfcn());\\r\\n#elif defined(DSO_DL)\\r\\nreturn(DSO_METHOD_dl());\\r\\n#elif defined(DSO_WIN32)\\r\\nreturn(DSO_METHOD_win32());\\r\\n#elif defined(DSO_VMS)\\r\\nreturn(DSO_METHOD_vms());\\r\\n#else\\r\\nreturn(DSO_METHOD_null());\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_null_c", "target": 0, "func": "BIO_METHOD *BIO_s_null(void)\\r\\n{\\r\\nreturn(&null_method);\\r\\n}\\r\\nstatic int null_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->ptr=(NULL);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int null_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int null_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int null_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nreturn(inl);\\r\\n}\\r\\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\ncase BIO_CTRL_EOF:\\r\\ncase BIO_CTRL_SET:\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\ncase BIO_CTRL_FLUSH:\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int null_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int null_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (str == NULL) return(0);\\r\\nreturn(strlen(str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_enc_c", "target": 0, "func": "static int ssl3_generate_key_block(SSL *s, unsigned char *km, int num)\\r\\n{\\r\\nEVP_MD_CTX m5;\\r\\nEVP_MD_CTX s1;\\r\\nunsigned char buf[16],smd[SHA_DIGEST_LENGTH];\\r\\nunsigned char c='A';\\r\\nunsigned int i,j,k;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nc = os_toascii[c];\\r\\n#endif\\r\\nk=0;\\r\\nEVP_MD_CTX_init(&m5);\\r\\nEVP_MD_CTX_init(&s1);\\r\\nfor (i=0; (int)i<num; i+=MD5_DIGEST_LENGTH)\\r\\n{\\r\\nk++;\\r\\nif (k > sizeof buf)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (j=0; j<k; j++)\\r\\nbuf[j]=c;\\r\\nc++;\\r\\nEVP_DigestInit_ex(&s1,EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&s1,buf,k);\\r\\nEVP_DigestUpdate(&s1,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&s1,smd,NULL);\\r\\nEVP_DigestInit_ex(&m5,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&m5,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&m5,smd,SHA_DIGEST_LENGTH);\\r\\nif ((int)(i+MD5_DIGEST_LENGTH) > num)\\r\\n{\\r\\nEVP_DigestFinal_ex(&m5,smd,NULL);\\r\\nmemcpy(km,smd,(num-i));\\r\\n}\\r\\nelse\\r\\nEVP_DigestFinal_ex(&m5,km,NULL);\\r\\nkm+=MD5_DIGEST_LENGTH;\\r\\n}\\r\\nOPENSSL_cleanse(smd,SHA_DIGEST_LENGTH);\\r\\nEVP_MD_CTX_cleanup(&m5);\\r\\nEVP_MD_CTX_cleanup(&s1);\\r\\nreturn 1;\\r\\n}\\r\\nint ssl3_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nunsigned char *p,*key_block,*mac_secret;\\r\\nunsigned char exp_key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char exp_iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *ms,*key,*iv,*er1,*er2;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\nCOMP_METHOD *comp;\\r\\nconst EVP_MD *m;\\r\\nEVP_MD_CTX md;\\r\\nint is_exp,n,i,j,k,cl;\\r\\nint reuse_dd = 0;\\r\\nis_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc=s->s3->tmp.new_sym_enc;\\r\\nm=s->s3->tmp.new_hash;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ncomp=NULL;\\r\\nelse\\r\\ncomp=s->s3->tmp.new_compression->method;\\r\\nkey_block=s->s3->tmp.key_block;\\r\\nif (which & SSL3_CC_READ)\\r\\n{\\r\\nif (s->enc_read_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\ndd= s->enc_read_ctx;\\r\\ns->read_hash=m;\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->expand=COMP_CTX_new(comp);\\r\\nif (s->expand == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp=(unsigned char *)\\r\\nOPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\nmemset(&(s->s3->read_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->read_mac_secret[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->enc_write_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\ndd= s->enc_write_ctx;\\r\\ns->write_hash=m;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->compress=COMP_CTX_new(comp);\\r\\nif (s->compress == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\nmemset(&(s->s3->write_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->write_mac_secret[0]);\\r\\n}\\r\\nif (reuse_dd)\\r\\nEVP_CIPHER_CTX_cleanup(dd);\\r\\nEVP_CIPHER_CTX_init(dd);\\r\\np=s->s3->tmp.key_block;\\r\\ni=EVP_MD_size(m);\\r\\ncl=EVP_CIPHER_key_length(c);\\r\\nj=is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nk=EVP_CIPHER_iv_length(c);\\r\\nif ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ))\\r\\n{\\r\\nms= &(p[ 0]); n=i+i;\\r\\nkey= &(p[ n]); n+=j+j;\\r\\niv= &(p[ n]); n+=k+k;\\r\\ner1= &(s->s3->client_random[0]);\\r\\ner2= &(s->s3->server_random[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=i;\\r\\nms= &(p[ n]); n+=i+j;\\r\\nkey= &(p[ n]); n+=j+k;\\r\\niv= &(p[ n]); n+=k;\\r\\ner1= &(s->s3->server_random[0]);\\r\\ner2= &(s->s3->client_random[0]);\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nEVP_MD_CTX_init(&md);\\r\\nmemcpy(mac_secret,ms,i);\\r\\nif (is_exp)\\r\\n{\\r\\nEVP_DigestInit_ex(&md,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md,key,j);\\r\\nEVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&md,&(exp_key[0]),NULL);\\r\\nkey= &(exp_key[0]);\\r\\nif (k > 0)\\r\\n{\\r\\nEVP_DigestInit_ex(&md,EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md,er1,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md,er2,SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&md,&(exp_iv[0]),NULL);\\r\\niv= &(exp_iv[0]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length=0;\\r\\nEVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));\\r\\nOPENSSL_cleanse(&(exp_key[0]),sizeof(exp_key));\\r\\nOPENSSL_cleanse(&(exp_iv[0]),sizeof(exp_iv));\\r\\nEVP_MD_CTX_cleanup(&md);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nint ret = 0;\\r\\nSSL_COMP *comp;\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn(1);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn(0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc=c;\\r\\ns->s3->tmp.new_hash=hash;\\r\\ns->s3->tmp.new_compression=comp;\\r\\nnum=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);\\r\\nnum*=2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p=OPENSSL_malloc(num)) == NULL)\\r\\ngoto err;\\r\\ns->s3->tmp.key_block_length=num;\\r\\ns->s3->tmp.key_block=p;\\r\\nret = ssl3_generate_key_block(s,p,num);\\r\\nif (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))\\r\\n{\\r\\ns->s3->need_empty_fragments = 1;\\r\\nif (s->session->cipher != NULL)\\r\\n{\\r\\nif ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nif ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl3_cleanup_key_block(SSL *s)\\r\\n{\\r\\nif (s->s3->tmp.key_block != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(s->s3->tmp.key_block,\\r\\ns->s3->tmp.key_block_length);\\r\\nOPENSSL_free(s->s3->tmp.key_block);\\r\\ns->s3->tmp.key_block=NULL;\\r\\n}\\r\\ns->s3->tmp.key_block_length=0;\\r\\n}\\r\\nint ssl3_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs,i;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send)\\r\\n{\\r\\nds=s->enc_write_ctx;\\r\\nrec= &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\nds=s->enc_read_ctx;\\r\\nrec= &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\nif ((s->session == NULL) || (ds == NULL) ||\\r\\n(enc == NULL))\\r\\n{\\r\\nmemmove(rec->data,rec->input,rec->length);\\r\\nrec->input=rec->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=rec->length;\\r\\nbs=EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send)\\r\\n{\\r\\ni=bs-((int)l%bs);\\r\\nl+=i;\\r\\nrec->length+=i;\\r\\nrec->input[l-1]=(i-1);\\r\\n}\\r\\nif (!send)\\r\\n{\\r\\nif (l == 0 || l%bs != 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nEVP_Cipher(ds,rec->data,rec->input,l);\\r\\nif ((bs != 1) && !send)\\r\\n{\\r\\ni=rec->data[l-1]+1;\\r\\nif (i > bs)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\nrec->length-=i;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nvoid ssl3_init_finished_mac(SSL *s)\\r\\n{\\r\\nEVP_DigestInit_ex(&(s->s3->finish_dgst1),s->ctx->md5, NULL);\\r\\nEVP_DigestInit_ex(&(s->s3->finish_dgst2),s->ctx->sha1, NULL);\\r\\n}\\r\\nvoid ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)\\r\\n{\\r\\nEVP_DigestUpdate(&(s->s3->finish_dgst1),buf,len);\\r\\nEVP_DigestUpdate(&(s->s3->finish_dgst2),buf,len);\\r\\n}\\r\\nint ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *ctx, unsigned char *p)\\r\\n{\\r\\nreturn(ssl3_handshake_mac(s,ctx,NULL,0,p));\\r\\n}\\r\\nint ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,\\r\\nconst char *sender, int len, unsigned char *p)\\r\\n{\\r\\nint ret;\\r\\nret=ssl3_handshake_mac(s,ctx1,sender,len,p);\\r\\np+=ret;\\r\\nret+=ssl3_handshake_mac(s,ctx2,sender,len,p);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_handshake_mac(SSL *s, EVP_MD_CTX *in_ctx,\\r\\nconst char *sender, int len, unsigned char *p)\\r\\n{\\r\\nunsigned int ret;\\r\\nint npad,n;\\r\\nunsigned int i;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_copy_ex(&ctx,in_ctx);\\r\\nn=EVP_MD_CTX_size(&ctx);\\r\\nnpad=(48/n)*n;\\r\\nif (sender != NULL)\\r\\nEVP_DigestUpdate(&ctx,sender,len);\\r\\nEVP_DigestUpdate(&ctx,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx,ssl3_pad_1,npad);\\r\\nEVP_DigestFinal_ex(&ctx,md_buf,&i);\\r\\nEVP_DigestInit_ex(&ctx,EVP_MD_CTX_md(&ctx), NULL);\\r\\nEVP_DigestUpdate(&ctx,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx,ssl3_pad_2,npad);\\r\\nEVP_DigestUpdate(&ctx,md_buf,i);\\r\\nEVP_DigestFinal_ex(&ctx,p,&ret);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn((int)ret);\\r\\n}\\r\\nint ssl3_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *mac_sec,*seq;\\r\\nEVP_MD_CTX md_ctx;\\r\\nconst EVP_MD *hash;\\r\\nunsigned char *p,rec_char;\\r\\nunsigned int md_size;\\r\\nint npad;\\r\\nif (send)\\r\\n{\\r\\nrec= &(ssl->s3->wrec);\\r\\nmac_sec= &(ssl->s3->write_mac_secret[0]);\\r\\nseq= &(ssl->s3->write_sequence[0]);\\r\\nhash=ssl->write_hash;\\r\\n}\\r\\nelse\\r\\n{\\r\\nrec= &(ssl->s3->rrec);\\r\\nmac_sec= &(ssl->s3->read_mac_secret[0]);\\r\\nseq= &(ssl->s3->read_sequence[0]);\\r\\nhash=ssl->read_hash;\\r\\n}\\r\\nmd_size=EVP_MD_size(hash);\\r\\nnpad=(48/md_size)*md_size;\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nEVP_DigestInit_ex( &md_ctx,hash, NULL);\\r\\nEVP_DigestUpdate(&md_ctx,mac_sec,md_size);\\r\\nEVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);\\r\\nEVP_DigestUpdate(&md_ctx,seq,8);\\r\\nrec_char=rec->type;\\r\\nEVP_DigestUpdate(&md_ctx,&rec_char,1);\\r\\np=md;\\r\\ns2n(rec->length,p);\\r\\nEVP_DigestUpdate(&md_ctx,md,2);\\r\\nEVP_DigestUpdate(&md_ctx,rec->input,rec->length);\\r\\nEVP_DigestFinal_ex( &md_ctx,md,NULL);\\r\\nEVP_DigestInit_ex( &md_ctx,hash, NULL);\\r\\nEVP_DigestUpdate(&md_ctx,mac_sec,md_size);\\r\\nEVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);\\r\\nEVP_DigestUpdate(&md_ctx,md,md_size);\\r\\nEVP_DigestFinal_ex( &md_ctx,md,&md_size);\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nssl3_record_sequence_update(seq);\\r\\nreturn(md_size);\\r\\n}\\r\\nvoid ssl3_record_sequence_update(unsigned char *seq)\\r\\n{\\r\\nint i;\\r\\nfor (i=7; i>=0; i--)\\r\\n{\\r\\n++seq[i];\\r\\nif (seq[i] != 0) break;\\r\\n}\\r\\n}\\r\\nint ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nstatic const unsigned char *salt[3]={\\r\\n#ifndef CHARSET_EBCDIC\\r\\n(const unsigned char *)\"A\",\\r\\n(const unsigned char *)\"BB\",\\r\\n(const unsigned char *)\"CCC\",\\r\\n#else\\r\\n(const unsigned char *)\"\\x41\",\\r\\n(const unsigned char *)\"\\x42\\x42\",\\r\\n(const unsigned char *)\"\\x43\\x43\\x43\",\\r\\n#endif\\r\\n};\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx;\\r\\nint i,ret=0;\\r\\nunsigned int n;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nEVP_DigestInit_ex(&ctx,s->ctx->sha1, NULL);\\r\\nEVP_DigestUpdate(&ctx,salt[i],strlen((const char *)salt[i]));\\r\\nEVP_DigestUpdate(&ctx,p,len);\\r\\nEVP_DigestUpdate(&ctx,&(s->s3->client_random[0]),\\r\\nSSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&ctx,&(s->s3->server_random[0]),\\r\\nSSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&ctx,buf,&n);\\r\\nEVP_DigestInit_ex(&ctx,s->ctx->md5, NULL);\\r\\nEVP_DigestUpdate(&ctx,p,len);\\r\\nEVP_DigestUpdate(&ctx,buf,n);\\r\\nEVP_DigestFinal_ex(&ctx,out,&n);\\r\\nout+=n;\\r\\nret+=n;\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_alert_code(int code)\\r\\n{\\r\\nswitch (code)\\r\\n{\\r\\ncase SSL_AD_CLOSE_NOTIFY: return(SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE: return(SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_RECORD_OVERFLOW: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE: return(SSL3_AD_NO_CERTIFICATE);\\r\\ncase SSL_AD_BAD_CERTIFICATE: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER: return(SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_ACCESS_DENIED: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECODE_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECRYPT_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_EXPORT_RESTRICTION: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_PROTOCOL_VERSION: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INTERNAL_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_USER_CANCELLED: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_RENEGOTIATION: return(-1);\\r\\ndefault: return(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_fcrypt_c", "target": 0, "func": "char *DES_crypt(const char *buf, const char *salt)\\r\\n{\\r\\nstatic char buff[14];\\r\\n#ifndef CHARSET_EBCDIC\\r\\nreturn(DES_fcrypt(buf,salt,buff));\\r\\n#else\\r\\nchar e_salt[2+1];\\r\\nchar e_buf[32+1];\\r\\nchar *ret;\\r\\nif ((e_salt[0] = salt[0]) != '\\0')\\r\\ne_salt[1] = salt[1];\\r\\nstrncpy (e_buf, buf, sizeof(e_buf));\\r\\ne_salt[sizeof(e_salt)-1] = e_buf[sizeof(e_buf)-1] = '\\0';\\r\\nebcdic2ascii(e_salt, e_salt, sizeof e_salt);\\r\\nebcdic2ascii(e_buf, e_buf, sizeof e_buf);\\r\\nret = DES_fcrypt(e_buf,e_salt,buff);\\r\\nascii2ebcdic(ret, ret, strlen(ret));\\r\\nreturn ret;\\r\\n#endif\\r\\n}\\r\\nchar *DES_fcrypt(const char *buf, const char *salt, char *ret)\\r\\n{\\r\\nunsigned int i,j,x,y;\\r\\nDES_LONG Eswap0,Eswap1;\\r\\nDES_LONG out[2],ll;\\r\\nDES_cblock key;\\r\\nDES_key_schedule ks;\\r\\nunsigned char bb[9];\\r\\nunsigned char *b=bb;\\r\\nunsigned char c,u;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nx=ret[0]=((salt[0] == '\\0')?'A':salt[0]);\\r\\nEswap0=con_salt[x]<<2;\\r\\nx=ret[1]=((salt[1] == '\\0')?'A':salt[1]);\\r\\nEswap1=con_salt[x]<<6;\\r\\n#else\\r\\nx=ret[0]=((salt[0] == '\\0')?os_toascii['A']:salt[0]);\\r\\nEswap0=con_salt[x]<<2;\\r\\nx=ret[1]=((salt[1] == '\\0')?os_toascii['A']:salt[1]);\\r\\nEswap1=con_salt[x]<<6;\\r\\n#endif\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nc= *(buf++);\\r\\nif (!c) break;\\r\\nkey[i]=(c<<1);\\r\\n}\\r\\nfor (; i<8; i++)\\r\\nkey[i]=0;\\r\\nDES_set_key_unchecked(&key,&ks);\\r\\nfcrypt_body(&(out[0]),&ks,Eswap0,Eswap1);\\r\\nll=out[0]; l2c(ll,b);\\r\\nll=out[1]; l2c(ll,b);\\r\\ny=0;\\r\\nu=0x80;\\r\\nbb[8]=0;\\r\\nfor (i=2; i<13; i++)\\r\\n{\\r\\nc=0;\\r\\nfor (j=0; j<6; j++)\\r\\n{\\r\\nc<<=1;\\r\\nif (bb[y] & u) c|=1;\\r\\nu>>=1;\\r\\nif (!u)\\r\\n{\\r\\ny++;\\r\\nu=0x80;\\r\\n}\\r\\n}\\r\\nret[i]=cov_2char[c];\\r\\n}\\r\\nret[13]='\\0';\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_err_c", "target": 0, "func": "void ERR_load_OCSP_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,OCSP_str_functs);\\r\\nERR_load_strings(0,OCSP_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_txt_c", "target": 0, "func": "const char *X509_verify_cert_error_string(long n)\\r\\n{\\r\\nstatic char buf[100];\\r\\nswitch ((int)n)\\r\\n{\\r\\ncase X509_V_OK:\\r\\nreturn(\"ok\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nreturn(\"unable to get issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL:\\r\\nreturn(\"unable to get certificate CRL\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\\r\\nreturn(\"unable to decrypt certificate's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\\r\\nreturn(\"unable to decrypt CRL's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\\r\\nreturn(\"unable to decode issuer public key\");\\r\\ncase X509_V_ERR_CERT_SIGNATURE_FAILURE:\\r\\nreturn(\"certificate signature failure\");\\r\\ncase X509_V_ERR_CRL_SIGNATURE_FAILURE:\\r\\nreturn(\"CRL signature failure\");\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\nreturn(\"certificate is not yet valid\");\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\nreturn(\"CRL is not yet valid\");\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\nreturn(\"certificate has expired\");\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\nreturn(\"CRL has expired\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nreturn(\"format error in certificate's notBefore field\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nreturn(\"format error in certificate's notAfter field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\\r\\nreturn(\"format error in CRL's lastUpdate field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\\r\\nreturn(\"format error in CRL's nextUpdate field\");\\r\\ncase X509_V_ERR_OUT_OF_MEM:\\r\\nreturn(\"out of memory\");\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\nreturn(\"self signed certificate\");\\r\\ncase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\\r\\nreturn(\"self signed certificate in certificate chain\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\\r\\nreturn(\"unable to get local issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\\r\\nreturn(\"unable to verify the first certificate\");\\r\\ncase X509_V_ERR_CERT_CHAIN_TOO_LONG:\\r\\nreturn(\"certificate chain too long\");\\r\\ncase X509_V_ERR_CERT_REVOKED:\\r\\nreturn(\"certificate revoked\");\\r\\ncase X509_V_ERR_INVALID_CA:\\r\\nreturn (\"invalid CA certificate\");\\r\\ncase X509_V_ERR_INVALID_NON_CA:\\r\\nreturn (\"invalid non-CA certificate (has CA markings)\");\\r\\ncase X509_V_ERR_PATH_LENGTH_EXCEEDED:\\r\\nreturn (\"path length constraint exceeded\");\\r\\ncase X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED:\\r\\nreturn(\"proxy path length constraint exceeded\");\\r\\ncase X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED:\\r\\nreturn(\"proxy cerificates not allowed, please set the appropriate flag\");\\r\\ncase X509_V_ERR_INVALID_PURPOSE:\\r\\nreturn (\"unsupported certificate purpose\");\\r\\ncase X509_V_ERR_CERT_UNTRUSTED:\\r\\nreturn (\"certificate not trusted\");\\r\\ncase X509_V_ERR_CERT_REJECTED:\\r\\nreturn (\"certificate rejected\");\\r\\ncase X509_V_ERR_APPLICATION_VERIFICATION:\\r\\nreturn(\"application verification failure\");\\r\\ncase X509_V_ERR_SUBJECT_ISSUER_MISMATCH:\\r\\nreturn(\"subject issuer mismatch\");\\r\\ncase X509_V_ERR_AKID_SKID_MISMATCH:\\r\\nreturn(\"authority and subject key identifier mismatch\");\\r\\ncase X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:\\r\\nreturn(\"authority and issuer serial number mismatch\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_CERTSIGN:\\r\\nreturn(\"key usage does not include certificate signing\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:\\r\\nreturn(\"unable to get CRL issuer certificate\");\\r\\ncase X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:\\r\\nreturn(\"unhandled critical extension\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_CRL_SIGN:\\r\\nreturn(\"key usage does not include CRL signing\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE:\\r\\nreturn(\"key usage does not include digital signature\");\\r\\ncase X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION:\\r\\nreturn(\"unhandled critical CRL extension\");\\r\\ncase X509_V_ERR_INVALID_EXTENSION:\\r\\nreturn(\"invalid or inconsistent certificate extension\");\\r\\ncase X509_V_ERR_INVALID_POLICY_EXTENSION:\\r\\nreturn(\"invalid or inconsistent certificate policy extension\");\\r\\ncase X509_V_ERR_NO_EXPLICIT_POLICY:\\r\\nreturn(\"no explicit policy\");\\r\\ndefault:\\r\\nBIO_snprintf(buf,sizeof buf,\"error number %ld\",n);\\r\\nreturn(buf);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pk7_mime_c", "target": 0, "func": "static int B64_write_PKCS7(BIO *bio, PKCS7 *p7)\\r\\n{\\r\\nBIO *b64;\\r\\nif(!(b64 = BIO_new(BIO_f_base64()))) {\\r\\nPKCS7err(PKCS7_F_B64_WRITE_PKCS7,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nbio = BIO_push(b64, bio);\\r\\ni2d_PKCS7_bio(bio, p7);\\r\\nBIO_flush(bio);\\r\\nbio = BIO_pop(bio);\\r\\nBIO_free(b64);\\r\\nreturn 1;\\r\\n}\\r\\nstatic PKCS7 *B64_read_PKCS7(BIO *bio)\\r\\n{\\r\\nBIO *b64;\\r\\nPKCS7 *p7;\\r\\nif(!(b64 = BIO_new(BIO_f_base64()))) {\\r\\nPKCS7err(PKCS7_F_B64_READ_PKCS7,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nbio = BIO_push(b64, bio);\\r\\nif(!(p7 = d2i_PKCS7_bio(bio, NULL)))\\r\\nPKCS7err(PKCS7_F_B64_READ_PKCS7,PKCS7_R_DECODE_ERROR);\\r\\nBIO_flush(bio);\\r\\nbio = BIO_pop(bio);\\r\\nBIO_free(b64);\\r\\nreturn p7;\\r\\n}\\r\\nint SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\\r\\n{\\r\\nchar bound[33], c;\\r\\nint i;\\r\\nchar *mime_prefix, *mime_eol, *msg_type=NULL;\\r\\nif (flags & PKCS7_NOOLDMIMETYPE)\\r\\nmime_prefix = \"application/pkcs7-\";\\r\\nelse\\r\\nmime_prefix = \"application/x-pkcs7-\";\\r\\nif (flags & PKCS7_CRLFEOL)\\r\\nmime_eol = \"\\r\\n\";\\r\\nelse\\r\\nmime_eol = \"\\n\";\\r\\nif((flags & PKCS7_DETACHED) && data) {\\r\\nRAND_pseudo_bytes((unsigned char *)bound, 32);\\r\\nfor(i = 0; i < 32; i++) {\\r\\nc = bound[i] & 0xf;\\r\\nif(c < 10) c += '0';\\r\\nelse c += 'A' - 10;\\r\\nbound[i] = c;\\r\\n}\\r\\nbound[32] = 0;\\r\\nBIO_printf(bio, \"MIME-Version: 1.0%s\", mime_eol);\\r\\nBIO_printf(bio, \"Content-Type: multipart/signed;\");\\r\\nBIO_printf(bio, \" protocol=\\\"%ssignature\\\";\", mime_prefix);\\r\\nBIO_printf(bio, \" micalg=sha1; boundary=\\\"----%s\\\"%s%s\",\\r\\nbound, mime_eol, mime_eol);\\r\\nBIO_printf(bio, \"This is an S/MIME signed message%s%s\",\\r\\nmime_eol, mime_eol);\\r\\nBIO_printf(bio, \"------%s%s\", bound, mime_eol);\\r\\npkcs7_output_data(bio, data, p7, flags);\\r\\nBIO_printf(bio, \"%s------%s%s\", mime_eol, bound, mime_eol);\\r\\nBIO_printf(bio, \"Content-Type: %ssignature;\", mime_prefix);\\r\\nBIO_printf(bio, \" name=\\\"smime.p7s\\\"%s\", mime_eol);\\r\\nBIO_printf(bio, \"Content-Transfer-Encoding: base64%s\",\\r\\nmime_eol);\\r\\nBIO_printf(bio, \"Content-Disposition: attachment;\");\\r\\nBIO_printf(bio, \" filename=\\\"smime.p7s\\\"%s%s\",\\r\\nmime_eol, mime_eol);\\r\\nB64_write_PKCS7(bio, p7);\\r\\nBIO_printf(bio,\"%s------%s--%s%s\", mime_eol, bound,\\r\\nmime_eol, mime_eol);\\r\\nreturn 1;\\r\\n}\\r\\nif (PKCS7_type_is_enveloped(p7))\\r\\nmsg_type = \"enveloped-data\";\\r\\nelse if (PKCS7_type_is_signed(p7))\\r\\n{\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *sinfos;\\r\\nsinfos = PKCS7_get_signer_info(p7);\\r\\nif (sk_PKCS7_SIGNER_INFO_num(sinfos) > 0)\\r\\nmsg_type = \"signed-data\";\\r\\nelse\\r\\nmsg_type = \"certs-only\";\\r\\n}\\r\\nBIO_printf(bio, \"MIME-Version: 1.0%s\", mime_eol);\\r\\nBIO_printf(bio, \"Content-Disposition: attachment;\");\\r\\nBIO_printf(bio, \" filename=\\\"smime.p7m\\\"%s\", mime_eol);\\r\\nBIO_printf(bio, \"Content-Type: %smime;\", mime_prefix);\\r\\nif (msg_type)\\r\\nBIO_printf(bio, \" smime-type=%s;\", msg_type);\\r\\nBIO_printf(bio, \" name=\\\"smime.p7m\\\"%s\", mime_eol);\\r\\nBIO_printf(bio, \"Content-Transfer-Encoding: base64%s%s\",\\r\\nmime_eol, mime_eol);\\r\\nB64_write_PKCS7(bio, p7);\\r\\nBIO_printf(bio, \"%s\", mime_eol);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkcs7_output_data(BIO *out, BIO *data, PKCS7 *p7, int flags)\\r\\n{\\r\\nBIO *tmpbio, *p7bio;\\r\\nif (!(flags & PKCS7_STREAM))\\r\\n{\\r\\nSMIME_crlf_copy(data, out, flags);\\r\\nreturn 1;\\r\\n}\\r\\np7bio = PKCS7_dataInit(p7, out);\\r\\nSMIME_crlf_copy(data, p7bio, flags);\\r\\nPKCS7_set_detached(p7, 1);\\r\\nPKCS7_dataFinal(p7, p7bio);\\r\\nwhile (p7bio != out)\\r\\n{\\r\\ntmpbio = BIO_pop(p7bio);\\r\\nBIO_free(p7bio);\\r\\np7bio = tmpbio;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nPKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)\\r\\n{\\r\\nBIO *p7in;\\r\\nSTACK_OF(MIME_HEADER) *headers = NULL;\\r\\nSTACK_OF(BIO) *parts = NULL;\\r\\nMIME_HEADER *hdr;\\r\\nMIME_PARAM *prm;\\r\\nPKCS7 *p7;\\r\\nint ret;\\r\\nif(bcont) *bcont = NULL;\\r\\nif (!(headers = mime_parse_hdr(bio))) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_MIME_PARSE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(hdr = mime_hdr_find(headers, \"content-type\")) || !hdr->value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!strcmp(hdr->value, \"multipart/signed\")) {\\r\\nprm = mime_param_find(hdr, \"boundary\");\\r\\nif(!prm || !prm->param_value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_MULTIPART_BOUNDARY);\\r\\nreturn NULL;\\r\\n}\\r\\nret = multi_split(bio, prm->param_value, &parts);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif(!ret || (sk_BIO_num(parts) != 2) ) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_MULTIPART_BODY_FAILURE);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\np7in = sk_BIO_value(parts, 1);\\r\\nif (!(headers = mime_parse_hdr(p7in))) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_MIME_SIG_PARSE_ERROR);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(hdr = mime_hdr_find(headers, \"content-type\")) ||\\r\\n!hdr->value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_NO_SIG_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(strcmp(hdr->value, \"application/x-pkcs7-signature\") &&\\r\\nstrcmp(hdr->value, \"application/pkcs7-signature\")) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_SIG_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif(!(p7 = B64_read_PKCS7(p7in))) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_PKCS7_SIG_PARSE_ERROR);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nif(bcont) {\\r\\n*bcont = sk_BIO_value(parts, 0);\\r\\nBIO_free(p7in);\\r\\nsk_BIO_free(parts);\\r\\n} else sk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn p7;\\r\\n}\\r\\nif (strcmp (hdr->value, \"application/x-pkcs7-mime\") &&\\r\\nstrcmp (hdr->value, \"application/pkcs7-mime\")) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7,PKCS7_R_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn NULL;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif(!(p7 = B64_read_PKCS7(bio))) {\\r\\nPKCS7err(PKCS7_F_SMIME_READ_PKCS7, PKCS7_R_PKCS7_PARSE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn p7;\\r\\n}\\r\\nint SMIME_crlf_copy(BIO *in, BIO *out, int flags)\\r\\n{\\r\\nchar eol;\\r\\nint len;\\r\\nchar linebuf[MAX_SMLEN];\\r\\nif(flags & PKCS7_BINARY) {\\r\\nwhile((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)\\r\\nBIO_write(out, linebuf, len);\\r\\nreturn 1;\\r\\n}\\r\\nif(flags & PKCS7_TEXT)\\r\\nBIO_printf(out, \"Content-Type: text/plain\\r\\n\\r\\n\");\\r\\nwhile ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0) {\\r\\neol = strip_eol(linebuf, &len);\\r\\nif (len)\\r\\nBIO_write(out, linebuf, len);\\r\\nif(eol) BIO_write(out, \"\\r\\n\", 2);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SMIME_text(BIO *in, BIO *out)\\r\\n{\\r\\nchar iobuf[4096];\\r\\nint len;\\r\\nSTACK_OF(MIME_HEADER) *headers;\\r\\nMIME_HEADER *hdr;\\r\\nif (!(headers = mime_parse_hdr(in))) {\\r\\nPKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_MIME_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(hdr = mime_hdr_find(headers, \"content-type\")) || !hdr->value) {\\r\\nPKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_MIME_NO_CONTENT_TYPE);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (strcmp (hdr->value, \"text/plain\")) {\\r\\nPKCS7err(PKCS7_F_SMIME_TEXT,PKCS7_R_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nwhile ((len = BIO_read(in, iobuf, sizeof(iobuf))) > 0)\\r\\nBIO_write(out, iobuf, len);\\r\\nreturn 1;\\r\\n}\\r\\nchar *strip_ends(char *name)\\r\\n{\\r\\nreturn strip_end(strip_start(name));\\r\\n}\\r\\nstatic char *strip_start(char *name)\\r\\n{\\r\\nchar *p, c;\\r\\nfor(p = name; (c = *p) ;p++) {\\r\\nif(c == '\"') {\\r\\nif(p[1]) return p + 1;\\r\\nreturn NULL;\\r\\n}\\r\\nif(!isspace((unsigned char)c)) return p;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic char *strip_end(char *name)\\r\\n{\\r\\nchar *p, c;\\r\\nif(!name) return NULL;\\r\\nfor(p = name + strlen(name) - 1; p >= name ;p--) {\\r\\nc = *p;\\r\\nif(c == '\"') {\\r\\nif(p - 1 == name) return NULL;\\r\\n*p = 0;\\r\\nreturn name;\\r\\n}\\r\\nif(isspace((unsigned char)c)) *p = 0;\\r\\nelse return name;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic MIME_HEADER *mime_hdr_new(char *name, char *value)\\r\\n{\\r\\nMIME_HEADER *mhdr;\\r\\nchar *tmpname, *tmpval, *p;\\r\\nint c;\\r\\nif(name) {\\r\\nif(!(tmpname = BUF_strdup(name))) return NULL;\\r\\nfor(p = tmpname ; *p; p++) {\\r\\nc = *p;\\r\\nif(isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else tmpname = NULL;\\r\\nif(value) {\\r\\nif(!(tmpval = BUF_strdup(value))) return NULL;\\r\\nfor(p = tmpval ; *p; p++) {\\r\\nc = *p;\\r\\nif(isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else tmpval = NULL;\\r\\nmhdr = (MIME_HEADER *) OPENSSL_malloc(sizeof(MIME_HEADER));\\r\\nif(!mhdr) return NULL;\\r\\nmhdr->name = tmpname;\\r\\nmhdr->value = tmpval;\\r\\nif(!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp))) return NULL;\\r\\nreturn mhdr;\\r\\n}\\r\\nstatic int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value)\\r\\n{\\r\\nchar *tmpname, *tmpval, *p;\\r\\nint c;\\r\\nMIME_PARAM *mparam;\\r\\nif(name) {\\r\\ntmpname = BUF_strdup(name);\\r\\nif(!tmpname) return 0;\\r\\nfor(p = tmpname ; *p; p++) {\\r\\nc = *p;\\r\\nif(isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else tmpname = NULL;\\r\\nif(value) {\\r\\ntmpval = BUF_strdup(value);\\r\\nif(!tmpval) return 0;\\r\\n} else tmpval = NULL;\\r\\nmparam = (MIME_PARAM *) OPENSSL_malloc(sizeof(MIME_PARAM));\\r\\nif(!mparam) return 0;\\r\\nmparam->param_name = tmpname;\\r\\nmparam->param_value = tmpval;\\r\\nsk_MIME_PARAM_push(mhdr->params, mparam);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int mime_hdr_cmp(const MIME_HEADER * const *a,\\r\\nconst MIME_HEADER * const *b)\\r\\n{\\r\\nreturn(strcmp((*a)->name, (*b)->name));\\r\\n}\\r\\nstatic int mime_param_cmp(const MIME_PARAM * const *a,\\r\\nconst MIME_PARAM * const *b)\\r\\n{\\r\\nreturn(strcmp((*a)->param_name, (*b)->param_name));\\r\\n}\\r\\nstatic MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name)\\r\\n{\\r\\nMIME_PARAM param;\\r\\nint idx;\\r\\nparam.param_name = name;\\r\\nidx = sk_MIME_PARAM_find(hdr->params, &param);\\r\\nif(idx < 0) return NULL;\\r\\nreturn sk_MIME_PARAM_value(hdr->params, idx);\\r\\n}\\r\\nstatic void mime_hdr_free(MIME_HEADER *hdr)\\r\\n{\\r\\nif(hdr->name) OPENSSL_free(hdr->name);\\r\\nif(hdr->value) OPENSSL_free(hdr->value);\\r\\nif(hdr->params) sk_MIME_PARAM_pop_free(hdr->params, mime_param_free);\\r\\nOPENSSL_free(hdr);\\r\\n}\\r\\nstatic void mime_param_free(MIME_PARAM *param)\\r\\n{\\r\\nif(param->param_name) OPENSSL_free(param->param_name);\\r\\nif(param->param_value) OPENSSL_free(param->param_value);\\r\\nOPENSSL_free(param);\\r\\n}\\r\\nstatic int mime_bound_check(char *line, int linelen, char *bound, int blen)\\r\\n{\\r\\nif(linelen == -1) linelen = strlen(line);\\r\\nif(blen == -1) blen = strlen(bound);\\r\\nif(blen + 2 > linelen) return 0;\\r\\nif(!strncmp(line, \"--\", 2) && !strncmp(line + 2, bound, blen)) {\\r\\nif(!strncmp(line + blen + 2, \"--\", 2)) return 2;\\r\\nelse return 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int strip_eol(char *linebuf, int *plen)\\r\\n{\\r\\nint len = *plen;\\r\\nchar *p, c;\\r\\nint is_eol = 0;\\r\\np = linebuf + len - 1;\\r\\nfor (p = linebuf + len - 1; len > 0; len--, p--)\\r\\n{\\r\\nc = *p;\\r\\nif (c == '\\n')\\r\\nis_eol = 1;\\r\\nelse if (c != '\\r')\\r\\nbreak;\\r\\n}\\r\\n*plen = len;\\r\\nreturn is_eol;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_x509a_c", "target": 0, "func": "int X509_CERT_AUX_print(BIO *out, X509_CERT_AUX *aux, int indent)\\r\\n{\\r\\nchar oidstr[80], first;\\r\\nint i;\\r\\nif(!aux) return 1;\\r\\nif(aux->trust) {\\r\\nfirst = 1;\\r\\nBIO_printf(out, \"%*sTrusted Uses:\\n%*s\",\\r\\nindent, \"\", indent + 2, \"\");\\r\\nfor(i = 0; i < sk_ASN1_OBJECT_num(aux->trust); i++) {\\r\\nif(!first) BIO_puts(out, \", \");\\r\\nelse first = 0;\\r\\nOBJ_obj2txt(oidstr, sizeof oidstr,\\r\\nsk_ASN1_OBJECT_value(aux->trust, i), 0);\\r\\nBIO_puts(out, oidstr);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\n} else BIO_printf(out, \"%*sNo Trusted Uses.\\n\", indent, \"\");\\r\\nif(aux->reject) {\\r\\nfirst = 1;\\r\\nBIO_printf(out, \"%*sRejected Uses:\\n%*s\",\\r\\nindent, \"\", indent + 2, \"\");\\r\\nfor(i = 0; i < sk_ASN1_OBJECT_num(aux->reject); i++) {\\r\\nif(!first) BIO_puts(out, \", \");\\r\\nelse first = 0;\\r\\nOBJ_obj2txt(oidstr, sizeof oidstr,\\r\\nsk_ASN1_OBJECT_value(aux->reject, i), 0);\\r\\nBIO_puts(out, oidstr);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\n} else BIO_printf(out, \"%*sNo Rejected Uses.\\n\", indent, \"\");\\r\\nif(aux->alias) BIO_printf(out, \"%*sAlias: %s\\n\", indent, \"\",\\r\\naux->alias->data);\\r\\nif(aux->keyid) {\\r\\nBIO_printf(out, \"%*sKey Id: \", indent, \"\");\\r\\nfor(i = 0; i < aux->keyid->length; i++)\\r\\nBIO_printf(out, \"%s%02X\",\\r\\ni ? \":\" : \"\",\\r\\naux->keyid->data[i]);\\r\\nBIO_write(out,\"\\n\",1);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_table_c", "target": 0, "func": "unsigned int ENGINE_get_table_flags(void)\\r\\n{\\r\\nreturn table_flags;\\r\\n}\\r\\nvoid ENGINE_set_table_flags(unsigned int flags)\\r\\n{\\r\\ntable_flags = flags;\\r\\n}\\r\\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\\r\\n{\\r\\nreturn c->nid;\\r\\n}\\r\\nstatic int engine_pile_cmp(const ENGINE_PILE *a, const ENGINE_PILE *b)\\r\\n{\\r\\nreturn a->nid - b->nid;\\r\\n}\\r\\nstatic void int_unregister_cb(ENGINE_PILE *pile, ENGINE *e)\\r\\n{\\r\\nint n;\\r\\nwhile((n = sk_ENGINE_find(pile->sk, e)) >= 0)\\r\\n{\\r\\nsk_ENGINE_delete(pile->sk, n);\\r\\npile->uptodate = 1;\\r\\n}\\r\\nif(pile->funct == e)\\r\\n{\\r\\nengine_unlocked_finish(e, 0);\\r\\npile->funct = NULL;\\r\\n}\\r\\n}\\r\\nvoid int_cleanup_cb(ENGINE_PILE *p)\\r\\n{\\r\\nsk_ENGINE_free(p->sk);\\r\\nif(p->funct)\\r\\nengine_unlocked_finish(p->funct, 0);\\r\\nOPENSSL_free(p);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_err_c", "target": 0, "func": "void ERR_load_RAND_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,RAND_str_functs);\\r\\nERR_load_strings(0,RAND_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mem_dbg_c", "target": 0, "func": "static void app_info_free(APP_INFO *inf)\\r\\n{\\r\\nif (--(inf->references) <= 0)\\r\\n{\\r\\nif (inf->next != NULL)\\r\\n{\\r\\napp_info_free(inf->next);\\r\\n}\\r\\nOPENSSL_free(inf);\\r\\n}\\r\\n}\\r\\nint CRYPTO_mem_ctrl(int mode)\\r\\n{\\r\\nint ret=mh_mode;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nswitch (mode)\\r\\n{\\r\\ncase CRYPTO_MEM_CHECK_ON:\\r\\nmh_mode = CRYPTO_MEM_CHECK_ON|CRYPTO_MEM_CHECK_ENABLE;\\r\\nnum_disable = 0;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_OFF:\\r\\nmh_mode = 0;\\r\\nnum_disable = 0;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_DISABLE:\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\\r\\n{\\r\\nif (!num_disable || (disabling_thread != CRYPTO_thread_id()))\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nmh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;\\r\\ndisabling_thread=CRYPTO_thread_id();\\r\\n}\\r\\nnum_disable++;\\r\\n}\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_ENABLE:\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\\r\\n{\\r\\nif (num_disable)\\r\\n{\\r\\nnum_disable--;\\r\\nif (num_disable == 0)\\r\\n{\\r\\nmh_mode|=CRYPTO_MEM_CHECK_ENABLE;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);\\r\\n}\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nreturn(ret);\\r\\n}\\r\\nint CRYPTO_is_mem_check_on(void)\\r\\n{\\r\\nint ret = 0;\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\\r\\n{\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_MALLOC);\\r\\nret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)\\r\\n|| (disabling_thread != CRYPTO_thread_id());\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_dbg_set_options(long bits)\\r\\n{\\r\\noptions = bits;\\r\\n}\\r\\nlong CRYPTO_dbg_get_options(void)\\r\\n{\\r\\nreturn options;\\r\\n}\\r\\nstatic int mem_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\n#ifdef _WIN64\\r\\nconst char *a=(const char *)((const MEM *)a_void)->addr,\\r\\n*b=(const char *)((const MEM *)b_void)->addr;\\r\\nif (a==b) return 0;\\r\\nelse if (a>b) return 1;\\r\\nelse return -1;\\r\\n#else\\r\\nreturn((const char *)((const MEM *)a_void)->addr\\r\\n- (const char *)((const MEM *)b_void)->addr);\\r\\n#endif\\r\\n}\\r\\nstatic unsigned long mem_hash(const void *a_void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)((const MEM *)a_void)->addr;\\r\\nret=ret*17851+(ret>>14)*7+(ret>>4)*251;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int app_info_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nreturn(((const APP_INFO *)a_void)->thread\\r\\n!= ((const APP_INFO *)b_void)->thread);\\r\\n}\\r\\nstatic unsigned long app_info_hash(const void *a_void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)((const APP_INFO *)a_void)->thread;\\r\\nret=ret*17851+(ret>>14)*7+(ret>>4)*251;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic APP_INFO *pop_info(void)\\r\\n{\\r\\nAPP_INFO tmp;\\r\\nAPP_INFO *ret = NULL;\\r\\nif (amih != NULL)\\r\\n{\\r\\ntmp.thread=CRYPTO_thread_id();\\r\\nif ((ret=(APP_INFO *)lh_delete(amih,&tmp)) != NULL)\\r\\n{\\r\\nAPP_INFO *next=ret->next;\\r\\nif (next != NULL)\\r\\n{\\r\\nnext->references++;\\r\\nlh_insert(amih,(char *)next);\\r\\n}\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nif (ret->thread != tmp.thread)\\r\\n{\\r\\nfprintf(stderr, \"pop_info(): deleted info has other thread ID (%lu) than the current thread (%lu)!!!!\\n\",\\r\\nret->thread, tmp.thread);\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (--(ret->references) <= 0)\\r\\n{\\r\\nret->next = NULL;\\r\\nif (next != NULL)\\r\\nnext->references--;\\r\\nOPENSSL_free(ret);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint CRYPTO_push_info_(const char *info, const char *file, int line)\\r\\n{\\r\\nAPP_INFO *ami, *amim;\\r\\nint ret=0;\\r\\nif (is_MemCheck_on())\\r\\n{\\r\\nMemCheck_off();\\r\\nif ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL)\\r\\n{\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nif (amih == NULL)\\r\\n{\\r\\nif ((amih=lh_new(app_info_hash, app_info_cmp)) == NULL)\\r\\n{\\r\\nOPENSSL_free(ami);\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nami->thread=CRYPTO_thread_id();\\r\\nami->file=file;\\r\\nami->line=line;\\r\\nami->info=info;\\r\\nami->references=1;\\r\\nami->next=NULL;\\r\\nif ((amim=(APP_INFO *)lh_insert(amih,(char *)ami)) != NULL)\\r\\n{\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nif (ami->thread != amim->thread)\\r\\n{\\r\\nfprintf(stderr, \"CRYPTO_push_info(): previous info has other thread ID (%lu) than the current thread (%lu)!!!!\\n\",\\r\\namim->thread, ami->thread);\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nami->next=amim;\\r\\n}\\r\\nerr:\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint CRYPTO_pop_info(void)\\r\\n{\\r\\nint ret=0;\\r\\nif (is_MemCheck_on())\\r\\n{\\r\\nMemCheck_off();\\r\\nret=(pop_info() != NULL);\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint CRYPTO_remove_all_info(void)\\r\\n{\\r\\nint ret=0;\\r\\nif (is_MemCheck_on())\\r\\n{\\r\\nMemCheck_off();\\r\\nwhile(pop_info() != NULL)\\r\\nret++;\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,\\r\\nint before_p)\\r\\n{\\r\\nMEM *m,*mm;\\r\\nAPP_INFO tmp,*amim;\\r\\nswitch(before_p & 127)\\r\\n{\\r\\ncase 0:\\r\\nbreak;\\r\\ncase 1:\\r\\nif (addr == NULL)\\r\\nbreak;\\r\\nif (is_MemCheck_on())\\r\\n{\\r\\nMemCheck_off();\\r\\nif ((m=(MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL)\\r\\n{\\r\\nOPENSSL_free(addr);\\r\\nMemCheck_on();\\r\\nreturn;\\r\\n}\\r\\nif (mh == NULL)\\r\\n{\\r\\nif ((mh=lh_new(mem_hash, mem_cmp)) == NULL)\\r\\n{\\r\\nOPENSSL_free(addr);\\r\\nOPENSSL_free(m);\\r\\naddr=NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nm->addr=addr;\\r\\nm->file=file;\\r\\nm->line=line;\\r\\nm->num=num;\\r\\nif (options & V_CRYPTO_MDEBUG_THREAD)\\r\\nm->thread=CRYPTO_thread_id();\\r\\nelse\\r\\nm->thread=0;\\r\\nif (order == break_order_num)\\r\\n{\\r\\nm->order=order;\\r\\n}\\r\\nm->order=order++;\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: [%5d] %c 0x%p (%d)\\n\",\\r\\nm->order,\\r\\n(before_p & 128) ? '*' : '+',\\r\\nm->addr, m->num);\\r\\n#endif\\r\\nif (options & V_CRYPTO_MDEBUG_TIME)\\r\\nm->time=time(NULL);\\r\\nelse\\r\\nm->time=0;\\r\\ntmp.thread=CRYPTO_thread_id();\\r\\nm->app_info=NULL;\\r\\nif (amih != NULL\\r\\n&& (amim=(APP_INFO *)lh_retrieve(amih,(char *)&tmp)) != NULL)\\r\\n{\\r\\nm->app_info = amim;\\r\\namim->references++;\\r\\n}\\r\\nif ((mm=(MEM *)lh_insert(mh,(char *)m)) != NULL)\\r\\n{\\r\\nif (mm->app_info != NULL)\\r\\n{\\r\\nmm->app_info->references--;\\r\\n}\\r\\nOPENSSL_free(mm);\\r\\n}\\r\\nerr:\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nvoid CRYPTO_dbg_free(void *addr, int before_p)\\r\\n{\\r\\nMEM m,*mp;\\r\\nswitch(before_p)\\r\\n{\\r\\ncase 0:\\r\\nif (addr == NULL)\\r\\nbreak;\\r\\nif (is_MemCheck_on() && (mh != NULL))\\r\\n{\\r\\nMemCheck_off();\\r\\nm.addr=addr;\\r\\nmp=(MEM *)lh_delete(mh,(char *)&m);\\r\\nif (mp != NULL)\\r\\n{\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: [%5d] - 0x%p (%d)\\n\",\\r\\nmp->order, mp->addr, mp->num);\\r\\n#endif\\r\\nif (mp->app_info != NULL)\\r\\napp_info_free(mp->app_info);\\r\\nOPENSSL_free(mp);\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\ncase 1:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_dbg_realloc(void *addr1, void *addr2, int num,\\r\\nconst char *file, int line, int before_p)\\r\\n{\\r\\nMEM m,*mp;\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \\\"%s\\\", line = %d, before_p = %d)\\n\",\\r\\naddr1, addr2, num, file, line, before_p);\\r\\n#endif\\r\\nswitch(before_p)\\r\\n{\\r\\ncase 0:\\r\\nbreak;\\r\\ncase 1:\\r\\nif (addr2 == NULL)\\r\\nbreak;\\r\\nif (addr1 == NULL)\\r\\n{\\r\\nCRYPTO_dbg_malloc(addr2, num, file, line, 128 | before_p);\\r\\nbreak;\\r\\n}\\r\\nif (is_MemCheck_on())\\r\\n{\\r\\nMemCheck_off();\\r\\nm.addr=addr1;\\r\\nmp=(MEM *)lh_delete(mh,(char *)&m);\\r\\nif (mp != NULL)\\r\\n{\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: [%5d] * 0x%p (%d) -> 0x%p (%d)\\n\",\\r\\nmp->order,\\r\\nmp->addr, mp->num,\\r\\naddr2, num);\\r\\n#endif\\r\\nmp->addr=addr2;\\r\\nmp->num=num;\\r\\nlh_insert(mh,(char *)mp);\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic void print_leak(const MEM *m, MEM_LEAK *l)\\r\\n{\\r\\nchar buf[1024];\\r\\nchar *bufp = buf;\\r\\nAPP_INFO *amip;\\r\\nint ami_cnt;\\r\\nstruct tm *lcl = NULL;\\r\\nunsigned long ti;\\r\\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\\r\\nif(m->addr == (char *)l->bio)\\r\\nreturn;\\r\\nif (options & V_CRYPTO_MDEBUG_TIME)\\r\\n{\\r\\nlcl = localtime(&m->time);\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"[%02d:%02d:%02d] \",\\r\\nlcl->tm_hour,lcl->tm_min,lcl->tm_sec);\\r\\nbufp += strlen(bufp);\\r\\n}\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"%5lu file=%s, line=%d, \",\\r\\nm->order,m->file,m->line);\\r\\nbufp += strlen(bufp);\\r\\nif (options & V_CRYPTO_MDEBUG_THREAD)\\r\\n{\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"thread=%lu, \", m->thread);\\r\\nbufp += strlen(bufp);\\r\\n}\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"number=%d, address=%08lX\\n\",\\r\\nm->num,(unsigned long)m->addr);\\r\\nbufp += strlen(bufp);\\r\\nBIO_puts(l->bio,buf);\\r\\nl->chunks++;\\r\\nl->bytes+=m->num;\\r\\namip=m->app_info;\\r\\nami_cnt=0;\\r\\nif (!amip)\\r\\nreturn;\\r\\nti=amip->thread;\\r\\ndo\\r\\n{\\r\\nint buf_len;\\r\\nint info_len;\\r\\nami_cnt++;\\r\\nmemset(buf,'>',ami_cnt);\\r\\nBIO_snprintf(buf + ami_cnt, sizeof buf - ami_cnt,\\r\\n\" thread=%lu, file=%s, line=%d, info=\\\"\",\\r\\namip->thread, amip->file, amip->line);\\r\\nbuf_len=strlen(buf);\\r\\ninfo_len=strlen(amip->info);\\r\\nif (128 - buf_len - 3 < info_len)\\r\\n{\\r\\nmemcpy(buf + buf_len, amip->info, 128 - buf_len - 3);\\r\\nbuf_len = 128 - 3;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBUF_strlcpy(buf + buf_len, amip->info,\\r\\nsizeof buf - buf_len);\\r\\nbuf_len = strlen(buf);\\r\\n}\\r\\nBIO_snprintf(buf + buf_len, sizeof buf - buf_len, \"\\\"\\n\");\\r\\nBIO_puts(l->bio,buf);\\r\\namip = amip->next;\\r\\n}\\r\\nwhile(amip && amip->thread == ti);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nif (amip)\\r\\n{\\r\\nfprintf(stderr, \"Thread switch detected in backtrace!!!!\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void cb_leak(const MEM *m, CRYPTO_MEM_LEAK_CB **cb)\\r\\n{\\r\\n(**cb)(m->order,m->file,m->line,m->num,m->addr);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha1_one_c", "target": 0, "func": "unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA_CTX c;\\r\\nstatic unsigned char m[SHA_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!SHA1_Init(&c))\\r\\nreturn NULL;\\r\\nSHA1_Update(&c,d,n);\\r\\nSHA1_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_all_c", "target": 0, "func": "void ENGINE_load_builtin_engines(void)\\r\\n{\\r\\n#if 0\\r\\nENGINE_load_openssl();\\r\\n#endif\\r\\nENGINE_load_dynamic();\\r\\n#ifndef OPENSSL_NO_STATIC_ENGINE\\r\\n#ifndef OPENSSL_NO_HW\\r\\n#ifndef OPENSSL_NO_HW_4758_CCA\\r\\nENGINE_load_4758cca();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_AEP\\r\\nENGINE_load_aep();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_ATALLA\\r\\nENGINE_load_atalla();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_CSWIFT\\r\\nENGINE_load_cswift();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_NCIPHER\\r\\nENGINE_load_chil();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_NURON\\r\\nENGINE_load_nuron();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_SUREWARE\\r\\nENGINE_load_sureware();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_UBSEC\\r\\nENGINE_load_ubsec();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HW_PADLOCK\\r\\nENGINE_load_padlock();\\r\\n#endif\\r\\n#endif\\r\\n#if defined(__OpenBSD__) || defined(__FreeBSD__)\\r\\nENGINE_load_cryptodev();\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_GMP) && !defined(OPENSSL_NO_HW_GMP)\\r\\nENGINE_load_gmp();\\r\\n#endif\\r\\n#endif\\r\\n}\\r\\nvoid ENGINE_setup_bsd_cryptodev(void) {\\r\\nstatic int bsd_cryptodev_default_loaded = 0;\\r\\nif (!bsd_cryptodev_default_loaded) {\\r\\nENGINE_load_cryptodev();\\r\\nENGINE_register_all_complete();\\r\\n}\\r\\nbsd_cryptodev_default_loaded=1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_ssl_c", "target": 0, "func": "int RSA_padding_add_SSLv23(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-11))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_SSLV23,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=2;\\r\\nj=tlen-3-8-flen;\\r\\nif (RAND_bytes(p,j) <= 0)\\r\\nreturn(0);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nif (RAND_bytes(p,1) <= 0)\\r\\nreturn(0);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\nmemset(p,3,8);\\r\\np+=8;\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_SSLv23(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i,j,k;\\r\\nconst unsigned char *p;\\r\\np=from;\\r\\nif (flen < 10)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_DATA_TOO_SMALL);\\r\\nreturn(-1);\\r\\n}\\r\\nif ((num != (flen+1)) || (*(p++) != 02))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_BLOCK_TYPE_IS_NOT_02);\\r\\nreturn(-1);\\r\\n}\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\nif (*(p++) == 0) break;\\r\\nif ((i == j) || (i < 8))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (k= -8; k<0; k++)\\r\\n{\\r\\nif (p[k] != 0x03) break;\\r\\n}\\r\\nif (k == -1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_SSLV3_ROLLBACK_ATTACK);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nif (j > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_DATA_TOO_LARGE);\\r\\nreturn(-1);\\r\\n}\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_lhash_c", "target": 0, "func": "LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)\\r\\n{\\r\\nLHASH *ret;\\r\\nint i;\\r\\nif ((ret=(LHASH *)OPENSSL_malloc(sizeof(LHASH))) == NULL)\\r\\ngoto err0;\\r\\nif ((ret->b=(LHASH_NODE **)OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)\\r\\ngoto err1;\\r\\nfor (i=0; i<MIN_NODES; i++)\\r\\nret->b[i]=NULL;\\r\\nret->comp=((c == NULL)?(LHASH_COMP_FN_TYPE)strcmp:c);\\r\\nret->hash=((h == NULL)?(LHASH_HASH_FN_TYPE)lh_strhash:h);\\r\\nret->num_nodes=MIN_NODES/2;\\r\\nret->num_alloc_nodes=MIN_NODES;\\r\\nret->p=0;\\r\\nret->pmax=MIN_NODES/2;\\r\\nret->up_load=UP_LOAD;\\r\\nret->down_load=DOWN_LOAD;\\r\\nret->num_items=0;\\r\\nret->num_expands=0;\\r\\nret->num_expand_reallocs=0;\\r\\nret->num_contracts=0;\\r\\nret->num_contract_reallocs=0;\\r\\nret->num_hash_calls=0;\\r\\nret->num_comp_calls=0;\\r\\nret->num_insert=0;\\r\\nret->num_replace=0;\\r\\nret->num_delete=0;\\r\\nret->num_no_delete=0;\\r\\nret->num_retrieve=0;\\r\\nret->num_retrieve_miss=0;\\r\\nret->num_hash_comps=0;\\r\\nret->error=0;\\r\\nreturn(ret);\\r\\nerr1:\\r\\nOPENSSL_free(ret);\\r\\nerr0:\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid lh_free(LHASH *lh)\\r\\n{\\r\\nunsigned int i;\\r\\nLHASH_NODE *n,*nn;\\r\\nif (lh == NULL)\\r\\nreturn;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nn=lh->b[i];\\r\\nwhile (n != NULL)\\r\\n{\\r\\nnn=n->next;\\r\\nOPENSSL_free(n);\\r\\nn=nn;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(lh->b);\\r\\nOPENSSL_free(lh);\\r\\n}\\r\\nvoid *lh_insert(LHASH *lh, void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn,**rn;\\r\\nvoid *ret;\\r\\nlh->error=0;\\r\\nif (lh->up_load <= (lh->num_items*LH_LOAD_MULT/lh->num_nodes))\\r\\nexpand(lh);\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nif ((nn=(LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nreturn(NULL);\\r\\n}\\r\\nnn->data=data;\\r\\nnn->next=NULL;\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nnn->hash=hash;\\r\\n#endif\\r\\n*rn=nn;\\r\\nret=NULL;\\r\\nlh->num_insert++;\\r\\nlh->num_items++;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= (*rn)->data;\\r\\n(*rn)->data=data;\\r\\nlh->num_replace++;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *lh_delete(LHASH *lh, const void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn,**rn;\\r\\nvoid *ret;\\r\\nlh->error=0;\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nlh->num_no_delete++;\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nnn= *rn;\\r\\n*rn=nn->next;\\r\\nret=nn->data;\\r\\nOPENSSL_free(nn);\\r\\nlh->num_delete++;\\r\\n}\\r\\nlh->num_items--;\\r\\nif ((lh->num_nodes > MIN_NODES) &&\\r\\n(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))\\r\\ncontract(lh);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *lh_retrieve(LHASH *lh, const void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE **rn;\\r\\nvoid *ret;\\r\\nlh->error=0;\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nlh->num_retrieve_miss++;\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= (*rn)->data;\\r\\nlh->num_retrieve++;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void doall_util_fn(LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,\\r\\nLHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)\\r\\n{\\r\\nint i;\\r\\nLHASH_NODE *a,*n;\\r\\nfor (i=lh->num_nodes-1; i>=0; i--)\\r\\n{\\r\\na=lh->b[i];\\r\\nwhile (a != NULL)\\r\\n{\\r\\nn=a->next;\\r\\nif(use_arg)\\r\\nfunc_arg(a->data,arg);\\r\\nelse\\r\\nfunc(a->data);\\r\\na=n;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid lh_doall(LHASH *lh, LHASH_DOALL_FN_TYPE func)\\r\\n{\\r\\ndoall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);\\r\\n}\\r\\nvoid lh_doall_arg(LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)\\r\\n{\\r\\ndoall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);\\r\\n}\\r\\nstatic void expand(LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n,**n1,**n2,*np;\\r\\nunsigned int p,i,j;\\r\\nunsigned long hash,nni;\\r\\nlh->num_nodes++;\\r\\nlh->num_expands++;\\r\\np=(int)lh->p++;\\r\\nn1= &(lh->b[p]);\\r\\nn2= &(lh->b[p+(int)lh->pmax]);\\r\\n*n2=NULL;\\r\\nnni=lh->num_alloc_nodes;\\r\\nfor (np= *n1; np != NULL; )\\r\\n{\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nhash=np->hash;\\r\\n#else\\r\\nhash=lh->hash(np->data);\\r\\nlh->num_hash_calls++;\\r\\n#endif\\r\\nif ((hash%nni) != p)\\r\\n{\\r\\n*n1= (*n1)->next;\\r\\nnp->next= *n2;\\r\\n*n2=np;\\r\\n}\\r\\nelse\\r\\nn1= &((*n1)->next);\\r\\nnp= *n1;\\r\\n}\\r\\nif ((lh->p) >= lh->pmax)\\r\\n{\\r\\nj=(int)lh->num_alloc_nodes*2;\\r\\nn=(LHASH_NODE **)OPENSSL_realloc(lh->b,\\r\\n(int)(sizeof(LHASH_NODE *)*j));\\r\\nif (n == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nlh->p=0;\\r\\nreturn;\\r\\n}\\r\\nfor (i=(int)lh->num_alloc_nodes; i<j; i++)\\r\\nn[i]=NULL;\\r\\nlh->pmax=lh->num_alloc_nodes;\\r\\nlh->num_alloc_nodes=j;\\r\\nlh->num_expand_reallocs++;\\r\\nlh->p=0;\\r\\nlh->b=n;\\r\\n}\\r\\n}\\r\\nstatic void contract(LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n,*n1,*np;\\r\\nnp=lh->b[lh->p+lh->pmax-1];\\r\\nlh->b[lh->p+lh->pmax-1]=NULL;\\r\\nif (lh->p == 0)\\r\\n{\\r\\nn=(LHASH_NODE **)OPENSSL_realloc(lh->b,\\r\\n(unsigned int)(sizeof(LHASH_NODE *)*lh->pmax));\\r\\nif (n == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nreturn;\\r\\n}\\r\\nlh->num_contract_reallocs++;\\r\\nlh->num_alloc_nodes/=2;\\r\\nlh->pmax/=2;\\r\\nlh->p=lh->pmax-1;\\r\\nlh->b=n;\\r\\n}\\r\\nelse\\r\\nlh->p--;\\r\\nlh->num_nodes--;\\r\\nlh->num_contracts++;\\r\\nn1=lh->b[(int)lh->p];\\r\\nif (n1 == NULL)\\r\\nlh->b[(int)lh->p]=np;\\r\\nelse\\r\\n{\\r\\nwhile (n1->next != NULL)\\r\\nn1=n1->next;\\r\\nn1->next=np;\\r\\n}\\r\\n}\\r\\nstatic LHASH_NODE **getrn(LHASH *lh, const void *data, unsigned long *rhash)\\r\\n{\\r\\nLHASH_NODE **ret,*n1;\\r\\nunsigned long hash,nn;\\r\\nLHASH_COMP_FN_TYPE cf;\\r\\nhash=(*(lh->hash))(data);\\r\\nlh->num_hash_calls++;\\r\\n*rhash=hash;\\r\\nnn=hash%lh->pmax;\\r\\nif (nn < lh->p)\\r\\nnn=hash%lh->num_alloc_nodes;\\r\\ncf=lh->comp;\\r\\nret= &(lh->b[(int)nn]);\\r\\nfor (n1= *ret; n1 != NULL; n1=n1->next)\\r\\n{\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nlh->num_hash_comps++;\\r\\nif (n1->hash != hash)\\r\\n{\\r\\nret= &(n1->next);\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\nlh->num_comp_calls++;\\r\\nif(cf(n1->data,data) == 0)\\r\\nbreak;\\r\\nret= &(n1->next);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nunsigned long lh_strhash(const char *c)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nlong n;\\r\\nunsigned long v;\\r\\nint r;\\r\\nif ((c == NULL) || (*c == '\\0'))\\r\\nreturn(ret);\\r\\nn=0x100;\\r\\nwhile (*c)\\r\\n{\\r\\nv=n|(*c);\\r\\nn+=0x100;\\r\\nr= (int)((v>>2)^v)&0x0f;\\r\\nret=(ret<<r)|(ret>>(32-r));\\r\\nret&=0xFFFFFFFFL;\\r\\nret^=v*v;\\r\\nc++;\\r\\n}\\r\\nreturn((ret>>16)^ret);\\r\\n}\\r\\nunsigned long lh_num_items(const LHASH *lh)\\r\\n{\\r\\nreturn lh ? lh->num_items : 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_txt_c", "target": 0, "func": "int SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file_internal())) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESSION_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=SSL_SESSION_print(b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_SESSION_print(BIO *bp, const SSL_SESSION *x)\\r\\n{\\r\\nunsigned int i;\\r\\nconst char *s;\\r\\nif (x == NULL) goto err;\\r\\nif (BIO_puts(bp,\"SSL-Session:\\n\") <= 0) goto err;\\r\\nif (x->ssl_version == SSL2_VERSION)\\r\\ns=\"SSLv2\";\\r\\nelse if (x->ssl_version == SSL3_VERSION)\\r\\ns=\"SSLv3\";\\r\\nelse if (x->ssl_version == TLS1_VERSION)\\r\\ns=\"TLSv1\";\\r\\nelse\\r\\ns=\"unknown\";\\r\\nif (BIO_printf(bp,\" Protocol : %s\\n\",s) <= 0) goto err;\\r\\nif (x->cipher == NULL)\\r\\n{\\r\\nif (((x->cipher_id) & 0xff000000) == 0x02000000)\\r\\n{\\r\\nif (BIO_printf(bp,\" Cipher : %06lX\\n\",x->cipher_id&0xffffff) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,\" Cipher : %04lX\\n\",x->cipher_id&0xffff) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,\" Cipher : %s\\n\",((x->cipher == NULL)?\"unknown\":x->cipher->name)) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp,\" Session-ID: \") <= 0) goto err;\\r\\nfor (i=0; i<x->session_id_length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",x->session_id[i]) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n Session-ID-ctx: \") <= 0) goto err;\\r\\nfor (i=0; i<x->sid_ctx_length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",x->sid_ctx[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n Master-Key: \") <= 0) goto err;\\r\\nfor (i=0; i<(unsigned int)x->master_key_length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",x->master_key[i]) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n Key-Arg : \") <= 0) goto err;\\r\\nif (x->key_arg_length == 0)\\r\\n{\\r\\nif (BIO_puts(bp,\"None\") <= 0) goto err;\\r\\n}\\r\\nelse\\r\\nfor (i=0; i<x->key_arg_length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",x->key_arg[i]) <= 0) goto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (BIO_puts(bp,\"\\n Krb5 Principal: \") <= 0) goto err;\\r\\nif (x->krb5_client_princ_len == 0)\\r\\n{\\r\\nif (BIO_puts(bp,\"None\") <= 0) goto err;\\r\\n}\\r\\nelse\\r\\nfor (i=0; i<x->krb5_client_princ_len; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",x->krb5_client_princ[i]) <= 0) goto err;\\r\\n}\\r\\n#endif\\r\\nif (x->compress_meth != 0)\\r\\n{\\r\\nSSL_COMP *comp;\\r\\nssl_cipher_get_evp(x,NULL,NULL,&comp);\\r\\nif (comp == NULL)\\r\\n{\\r\\nif (BIO_printf(bp,\"\\n Compression: %d\",x->compress_meth) <= 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,\"\\n Compression: %d (%s)\", comp->id,comp->method->name) <= 0) goto err;\\r\\n}\\r\\n}\\r\\nif (x->time != 0L)\\r\\n{\\r\\nif (BIO_printf(bp, \"\\n Start Time: %ld\",x->time) <= 0) goto err;\\r\\n}\\r\\nif (x->timeout != 0L)\\r\\n{\\r\\nif (BIO_printf(bp, \"\\n Timeout : %ld (sec)\",x->timeout) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n\") <= 0) goto err;\\r\\nif (BIO_puts(bp, \" Verify return code: \") <= 0) goto err;\\r\\nif (BIO_printf(bp, \"%ld (%s)\\n\", x->verify_result,\\r\\nX509_verify_cert_error_string(x->verify_result)) <= 0) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_meth_c", "target": 0, "func": "static SSL_METHOD *ssl2_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_data.ssl_connect=ssl2_connect;\\r\\nSSLv2_data.ssl_accept=ssl2_accept;\\r\\nSSLv2_data.get_ssl_method=ssl2_get_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv2_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_sqr_c", "target": 0, "func": "int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nint max,al;\\r\\nint ret = 0;\\r\\nBIGNUM *tmp,*rr;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\"BN_sqr %d * %d\\n\",a->top,a->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nal=a->top;\\r\\nif (al <= 0)\\r\\n{\\r\\nr->top=0;\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nrr=(a != r) ? r : BN_CTX_get(ctx);\\r\\ntmp=BN_CTX_get(ctx);\\r\\nif (!rr || !tmp) goto err;\\r\\nmax = 2 * al;\\r\\nif (bn_wexpand(rr,max) == NULL) goto err;\\r\\nif (al == 4)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(rr->d,a->d,4,t);\\r\\n#else\\r\\nbn_sqr_comba4(rr->d,a->d);\\r\\n#endif\\r\\n}\\r\\nelse if (al == 8)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(rr->d,a->d,8,t);\\r\\n#else\\r\\nbn_sqr_comba8(rr->d,a->d);\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if defined(BN_RECURSION)\\r\\nif (al < BN_SQR_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nBN_ULONG t[BN_SQR_RECURSIVE_SIZE_NORMAL*2];\\r\\nbn_sqr_normal(rr->d,a->d,al,t);\\r\\n}\\r\\nelse\\r\\n{\\r\\nint j,k;\\r\\nj=BN_num_bits_word((BN_ULONG)al);\\r\\nj=1<<(j-1);\\r\\nk=j+j;\\r\\nif (al == j)\\r\\n{\\r\\nif (bn_wexpand(tmp,k*2) == NULL) goto err;\\r\\nbn_sqr_recursive(rr->d,a->d,al,tmp->d);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bn_wexpand(tmp,max) == NULL) goto err;\\r\\nbn_sqr_normal(rr->d,a->d,al,tmp->d);\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (bn_wexpand(tmp,max) == NULL) goto err;\\r\\nbn_sqr_normal(rr->d,a->d,al,tmp->d);\\r\\n#endif\\r\\n}\\r\\nrr->neg=0;\\r\\nif(a->d[al - 1] == (a->d[al - 1] & BN_MASK2l))\\r\\nrr->top = max - 1;\\r\\nelse\\r\\nrr->top = max;\\r\\nif (rr != r) BN_copy(r,rr);\\r\\nret = 1;\\r\\nerr:\\r\\nif(rr) bn_check_top(rr);\\r\\nif(tmp) bn_check_top(tmp);\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)\\r\\n{\\r\\nint i,j,max;\\r\\nconst BN_ULONG *ap;\\r\\nBN_ULONG *rp;\\r\\nmax=n*2;\\r\\nap=a;\\r\\nrp=r;\\r\\nrp[0]=rp[max-1]=0;\\r\\nrp++;\\r\\nj=n;\\r\\nif (--j > 0)\\r\\n{\\r\\nap++;\\r\\nrp[j]=bn_mul_words(rp,ap,j,ap[-1]);\\r\\nrp+=2;\\r\\n}\\r\\nfor (i=n-2; i>0; i--)\\r\\n{\\r\\nj--;\\r\\nap++;\\r\\nrp[j]=bn_mul_add_words(rp,ap,j,ap[-1]);\\r\\nrp+=2;\\r\\n}\\r\\nbn_add_words(r,r,r,max);\\r\\nbn_sqr_words(tmp,a,n);\\r\\nbn_add_words(r,r,tmp,max);\\r\\n}\\r\\nvoid bn_sqr_recursive(BN_ULONG *r, const BN_ULONG *a, int n2, BN_ULONG *t)\\r\\n{\\r\\nint n=n2/2;\\r\\nint zero,c1;\\r\\nBN_ULONG ln,lo,*p;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_sqr_recursive %d * %d\\n\",n2,n2);\\r\\n#endif\\r\\nif (n2 == 4)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r,a,4,t);\\r\\n#else\\r\\nbn_sqr_comba4(r,a);\\r\\n#endif\\r\\nreturn;\\r\\n}\\r\\nelse if (n2 == 8)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r,a,8,t);\\r\\n#else\\r\\nbn_sqr_comba8(r,a);\\r\\n#endif\\r\\nreturn;\\r\\n}\\r\\nif (n2 < BN_SQR_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_sqr_normal(r,a,n2,t);\\r\\nreturn;\\r\\n}\\r\\nc1=bn_cmp_words(a,&(a[n]),n);\\r\\nzero=0;\\r\\nif (c1 > 0)\\r\\nbn_sub_words(t,a,&(a[n]),n);\\r\\nelse if (c1 < 0)\\r\\nbn_sub_words(t,&(a[n]),a,n);\\r\\nelse\\r\\nzero=1;\\r\\np= &(t[n2*2]);\\r\\nif (!zero)\\r\\nbn_sqr_recursive(&(t[n2]),t,n,p);\\r\\nelse\\r\\nmemset(&(t[n2]),0,n2*sizeof(BN_ULONG));\\r\\nbn_sqr_recursive(r,a,n,p);\\r\\nbn_sqr_recursive(&(r[n2]),&(a[n]),n,p);\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < (BN_ULONG)c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_errstr_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,ret=0;\\r\\nchar buf[256];\\r\\nunsigned long l;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nSSL_load_error_strings();\\r\\nif ((argc > 1) && (strcmp(argv[1],\"-stats\") == 0))\\r\\n{\\r\\nBIO *out=NULL;\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((out != NULL) && BIO_set_fp(out,stdout,BIO_NOCLOSE))\\r\\n{\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nlh_node_stats_bio((LHASH *)ERR_get_string_table(),out);\\r\\nlh_stats_bio((LHASH *)ERR_get_string_table(),out);\\r\\nlh_node_usage_stats_bio((LHASH *)\\r\\nERR_get_string_table(),out);\\r\\n}\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nif (sscanf(argv[i],\"%lx\",&l))\\r\\n{\\r\\nERR_error_string_n(l, buf, sizeof buf);\\r\\nprintf(\"%s\\n\",buf);\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"%s: bad error code\\n\",argv[i]);\\r\\nprintf(\"usage: errstr [-stats] <errno> ...\\n\");\\r\\nret++;\\r\\n}\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_base64_c", "target": 0, "func": "main()\\r\\n{\\r\\nint i;\\r\\nBIO *mbio,*b64bio,*bio;\\r\\nchar buf[512];\\r\\nchar *p;\\r\\nmbio=BIO_new(BIO_s_mem());\\r\\nb64bio=BIO_new(BIO_f_base64());\\r\\nbio=BIO_push(b64bio,mbio);\\r\\nfor (;;)\\r\\n{\\r\\ni=fread(buf,1,512,stdin);\\r\\nif (i <= 0) break;\\r\\nBIO_write(bio,buf,i);\\r\\n}\\r\\nBIO_flush(bio);\\r\\nprintf(\"We have %d bytes available\\n\",BIO_pending(mbio));\\r\\ni=(int)BIO_ctrl(mbio,BIO_CTRL_INFO,0,(char *)&p);\\r\\nprintf(\"%d\\n\",i);\\r\\nfwrite(\"---\\n\",1,4,stdout);\\r\\nfwrite(p,1,i,stdout);\\r\\nfwrite(\"---\\n\",1,4,stdout);\\r\\nBIO_free_all(bio);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_pkt_c", "target": 0, "func": "int ssl3_read_n(SSL *s, int n, int max, int extend)\\r\\n{\\r\\nint i,off,newb;\\r\\nif (!extend)\\r\\n{\\r\\nif (s->s3->rbuf.left == 0)\\r\\ns->s3->rbuf.offset = 0;\\r\\ns->packet = s->s3->rbuf.buf + s->s3->rbuf.offset;\\r\\ns->packet_length = 0;\\r\\n}\\r\\nif ( SSL_version(s) == DTLS1_VERSION &&\\r\\nextend)\\r\\n{\\r\\nif ( s->s3->rbuf.left > 0 && n > s->s3->rbuf.left)\\r\\nn = s->s3->rbuf.left;\\r\\n}\\r\\nif (s->s3->rbuf.left >= (int)n)\\r\\n{\\r\\ns->packet_length+=n;\\r\\ns->s3->rbuf.left-=n;\\r\\ns->s3->rbuf.offset+=n;\\r\\nreturn(n);\\r\\n}\\r\\nif (!s->read_ahead)\\r\\nmax=n;\\r\\n{\\r\\nint max_max = s->s3->rbuf.len - s->packet_length;\\r\\nif (max > max_max)\\r\\nmax = max_max;\\r\\n}\\r\\nif (n > max)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_N,ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\noff = s->packet_length;\\r\\nnewb = s->s3->rbuf.left;\\r\\nif (s->packet != s->s3->rbuf.buf)\\r\\n{\\r\\nmemmove(s->s3->rbuf.buf, s->packet, off+newb);\\r\\ns->packet = s->s3->rbuf.buf;\\r\\n}\\r\\nwhile (newb < n)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\ni=BIO_read(s->rbio, &(s->s3->rbuf.buf[off+newb]), max-newb);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_N,SSL_R_READ_BIO_NOT_SET);\\r\\ni = -1;\\r\\n}\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->rbuf.left = newb;\\r\\nreturn(i);\\r\\n}\\r\\nnewb+=i;\\r\\n}\\r\\ns->s3->rbuf.offset = off + n;\\r\\ns->s3->rbuf.left = newb - n;\\r\\ns->packet_length += n;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(n);\\r\\n}\\r\\nstatic int ssl3_get_record(SSL *s)\\r\\n{\\r\\nint ssl_major,ssl_minor,al;\\r\\nint enc_err,n,i,ret= -1;\\r\\nSSL3_RECORD *rr;\\r\\nSSL_SESSION *sess;\\r\\nunsigned char *p;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nshort version;\\r\\nunsigned int mac_size;\\r\\nint clear=0;\\r\\nsize_t extra;\\r\\nint decryption_failed_or_bad_record_mac = 0;\\r\\nunsigned char *mac = NULL;\\r\\nrr= &(s->s3->rrec);\\r\\nsess=s->session;\\r\\nif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\\r\\nextra=SSL3_RT_MAX_EXTRA;\\r\\nelse\\r\\nextra=0;\\r\\nif (extra != s->s3->rbuf.len - SSL3_RT_MAX_PACKET_SIZE)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nagain:\\r\\nif ( (s->rstate != SSL_ST_READ_BODY) ||\\r\\n(s->packet_length < SSL3_RT_HEADER_LENGTH))\\r\\n{\\r\\nn=ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\\r\\nif (n <= 0) return(n);\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\np=s->packet;\\r\\nrr->type= *(p++);\\r\\nssl_major= *(p++);\\r\\nssl_minor= *(p++);\\r\\nversion=(ssl_major<<8)|ssl_minor;\\r\\nn2s(p,rr->length);\\r\\nif (s->first_packet)\\r\\n{\\r\\ns->first_packet=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (version != s->version)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ns->version=version;\\r\\nal=SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif ((version>>8) != SSL3_VERSION_MAJOR)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (rr->length > s->packet_length-SSL3_RT_HEADER_LENGTH)\\r\\n{\\r\\ni=rr->length;\\r\\nn=ssl3_read_n(s,i,i,1);\\r\\nif (n <= 0) return(n);\\r\\n}\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nrr->input= &(s->packet[SSL3_RT_HEADER_LENGTH]);\\r\\nif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->data=rr->input;\\r\\nenc_err = s->method->ssl3_enc->enc(s,0);\\r\\nif (enc_err <= 0)\\r\\n{\\r\\nif (enc_err == 0)\\r\\ngoto err;\\r\\ndecryption_failed_or_bad_record_mac = 1;\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"dec %d\\n\",rr->length);\\r\\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_read_ctx == NULL) ||\\r\\n(s->read_hash == NULL))\\r\\nclear=1;\\r\\nif (!clear)\\r\\n{\\r\\nmac_size=EVP_MD_size(s->read_hash);\\r\\nif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)\\r\\n{\\r\\n#if 0\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n#else\\r\\ndecryption_failed_or_bad_record_mac = 1;\\r\\n#endif\\r\\n}\\r\\nif (rr->length >= mac_size)\\r\\n{\\r\\nrr->length -= mac_size;\\r\\nmac = &rr->data[rr->length];\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if 0\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);\\r\\ngoto f_err;\\r\\n#else\\r\\ndecryption_failed_or_bad_record_mac = 1;\\r\\nrr->length = 0;\\r\\n#endif\\r\\n}\\r\\ni=s->method->ssl3_enc->mac(s,md,0);\\r\\nif (mac == NULL || memcmp(md, mac, mac_size) != 0)\\r\\n{\\r\\ndecryption_failed_or_bad_record_mac = 1;\\r\\n}\\r\\n}\\r\\nif (decryption_failed_or_bad_record_mac)\\r\\n{\\r\\nal=SSL_AD_BAD_RECORD_MAC;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!ssl3_do_uncompress(s))\\r\\n{\\r\\nal=SSL_AD_DECOMPRESSION_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_DECOMPRESSION);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (rr->length > SSL3_RT_MAX_PLAIN_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->off=0;\\r\\ns->packet_length=0;\\r\\nif (rr->length == 0) goto again;\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_do_uncompress(SSL *ssl)\\r\\n{\\r\\nint i;\\r\\nSSL3_RECORD *rr;\\r\\nrr= &(ssl->s3->rrec);\\r\\ni=COMP_expand_block(ssl->expand,rr->comp,\\r\\nSSL3_RT_MAX_PLAIN_LENGTH,rr->data,(int)rr->length);\\r\\nif (i < 0)\\r\\nreturn(0);\\r\\nelse\\r\\nrr->length=i;\\r\\nrr->data=rr->comp;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_do_compress(SSL *ssl)\\r\\n{\\r\\nint i;\\r\\nSSL3_RECORD *wr;\\r\\nwr= &(ssl->s3->wrec);\\r\\ni=COMP_compress_block(ssl->compress,wr->data,\\r\\nSSL3_RT_MAX_COMPRESSED_LENGTH,\\r\\nwr->input,(int)wr->length);\\r\\nif (i < 0)\\r\\nreturn(0);\\r\\nelse\\r\\nwr->length=i;\\r\\nwr->input=wr->data;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\\r\\n{\\r\\nconst unsigned char *buf=buf_;\\r\\nunsigned int tot,n,nw;\\r\\nint i;\\r\\ns->rwstate=SSL_NOTHING;\\r\\ntot=s->s3->wnum;\\r\\ns->s3->wnum=0;\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nn=(len-tot);\\r\\nfor (;;)\\r\\n{\\r\\nif (n > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\nnw=SSL3_RT_MAX_PLAIN_LENGTH;\\r\\nelse\\r\\nnw=n;\\r\\ni=do_ssl3_write(s, type, &(buf[tot]), nw, 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->wnum=tot;\\r\\nreturn i;\\r\\n}\\r\\nif ((i == (int)n) ||\\r\\n(type == SSL3_RT_APPLICATION_DATA &&\\r\\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))\\r\\n{\\r\\ns->s3->empty_fragment_done = 0;\\r\\nreturn tot+i;\\r\\n}\\r\\nn-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nstatic int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\\r\\nunsigned int len, int create_empty_fragment)\\r\\n{\\r\\nunsigned char *p,*plen;\\r\\nint i,mac_size,clear=0;\\r\\nint prefix_len = 0;\\r\\nSSL3_RECORD *wr;\\r\\nSSL3_BUFFER *wb;\\r\\nSSL_SESSION *sess;\\r\\nif (s->s3->wbuf.left != 0)\\r\\nreturn(ssl3_write_pending(s,type,buf,len));\\r\\nif (s->s3->alert_dispatch)\\r\\n{\\r\\ni=s->method->ssl_dispatch_alert(s);\\r\\nif (i <= 0)\\r\\nreturn(i);\\r\\n}\\r\\nif (len == 0 && !create_empty_fragment)\\r\\nreturn 0;\\r\\nwr= &(s->s3->wrec);\\r\\nwb= &(s->s3->wbuf);\\r\\nsess=s->session;\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_write_ctx == NULL) ||\\r\\n(s->write_hash == NULL))\\r\\nclear=1;\\r\\nif (clear)\\r\\nmac_size=0;\\r\\nelse\\r\\nmac_size=EVP_MD_size(s->write_hash);\\r\\nif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done)\\r\\n{\\r\\nif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\\r\\n{\\r\\nprefix_len = do_ssl3_write(s, type, buf, 0, 1);\\r\\nif (prefix_len <= 0)\\r\\ngoto err;\\r\\nif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\\r\\n{\\r\\nSSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ns->s3->empty_fragment_done = 1;\\r\\n}\\r\\np = wb->buf + prefix_len;\\r\\n*(p++)=type&0xff;\\r\\nwr->type=type;\\r\\n*(p++)=(s->version>>8);\\r\\n*(p++)=s->version&0xff;\\r\\nplen=p;\\r\\np+=2;\\r\\nwr->data=p;\\r\\nwr->length=(int)len;\\r\\nwr->input=(unsigned char *)buf;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nif (!ssl3_do_compress(s))\\r\\n{\\r\\nSSLerr(SSL_F_DO_SSL3_WRITE,SSL_R_COMPRESSION_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(wr->data,wr->input,wr->length);\\r\\nwr->input=wr->data;\\r\\n}\\r\\nif (mac_size != 0)\\r\\n{\\r\\ns->method->ssl3_enc->mac(s,&(p[wr->length]),1);\\r\\nwr->length+=mac_size;\\r\\nwr->input=p;\\r\\nwr->data=p;\\r\\n}\\r\\ns->method->ssl3_enc->enc(s,1);\\r\\ns2n(wr->length,plen);\\r\\nwr->type=type;\\r\\nwr->length+=SSL3_RT_HEADER_LENGTH;\\r\\nif (create_empty_fragment)\\r\\n{\\r\\nreturn wr->length;\\r\\n}\\r\\nwb->left = prefix_len + wr->length;\\r\\nwb->offset = 0;\\r\\ns->s3->wpend_tot=len;\\r\\ns->s3->wpend_buf=buf;\\r\\ns->s3->wpend_type=type;\\r\\ns->s3->wpend_ret=len;\\r\\nreturn ssl3_write_pending(s,type,buf,len);\\r\\nerr:\\r\\nreturn -1;\\r\\n}\\r\\nint ssl3_write_pending(SSL *s, int type, const unsigned char *buf,\\r\\nunsigned int len)\\r\\n{\\r\\nint i;\\r\\nif ((s->s3->wpend_tot > (int)len)\\r\\n|| ((s->s3->wpend_buf != buf) &&\\r\\n!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))\\r\\n|| (s->s3->wpend_type != type))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,\\r\\n(char *)&(s->s3->wbuf.buf[s->s3->wbuf.offset]),\\r\\n(unsigned int)s->s3->wbuf.left);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\nif (i == s->s3->wbuf.left)\\r\\n{\\r\\ns->s3->wbuf.left=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(s->s3->wpend_ret);\\r\\n}\\r\\nelse if (i <= 0)\\r\\nreturn(i);\\r\\ns->s3->wbuf.offset+=i;\\r\\ns->s3->wbuf.left-=i;\\r\\n}\\r\\n}\\r\\nint ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\\r\\n{\\r\\nint al,i,j,ret;\\r\\nunsigned int n;\\r\\nSSL3_RECORD *rr;\\r\\nvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\\r\\nif (s->s3->rbuf.buf == NULL)\\r\\nif (!ssl3_setup_buffers(s))\\r\\nreturn(-1);\\r\\nif ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE) && type) ||\\r\\n(peek && (type != SSL3_RT_APPLICATION_DATA)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\\r\\n{\\r\\nunsigned char *src = s->s3->handshake_fragment;\\r\\nunsigned char *dst = buf;\\r\\nunsigned int k;\\r\\nn = 0;\\r\\nwhile ((len > 0) && (s->s3->handshake_fragment_len > 0))\\r\\n{\\r\\n*dst++ = *src++;\\r\\nlen--; s->s3->handshake_fragment_len--;\\r\\nn++;\\r\\n}\\r\\nfor (k = 0; k < s->s3->handshake_fragment_len; k++)\\r\\ns->s3->handshake_fragment[k] = *src++;\\r\\nreturn n;\\r\\n}\\r\\nif (!s->in_handshake && SSL_in_init(s))\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstart:\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr = &(s->s3->rrec);\\r\\nif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\\r\\n{\\r\\nret=ssl3_get_record(s);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nif (s->s3->change_cipher_spec\\r\\n&& (rr->type != SSL3_RT_HANDSHAKE))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\nrr->length=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\nif (type == rr->type)\\r\\n{\\r\\nif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\\r\\n(s->enc_read_ctx == NULL))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (len <= 0) return(len);\\r\\nif ((unsigned int)len > rr->length)\\r\\nn = rr->length;\\r\\nelse\\r\\nn = (unsigned int)len;\\r\\nmemcpy(buf,&(rr->data[rr->off]),n);\\r\\nif (!peek)\\r\\n{\\r\\nrr->length-=n;\\r\\nrr->off+=n;\\r\\nif (rr->length == 0)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nrr->off=0;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\n{\\r\\nunsigned int dest_maxlen = 0;\\r\\nunsigned char *dest = NULL;\\r\\nunsigned int *dest_len = NULL;\\r\\nif (rr->type == SSL3_RT_HANDSHAKE)\\r\\n{\\r\\ndest_maxlen = sizeof s->s3->handshake_fragment;\\r\\ndest = s->s3->handshake_fragment;\\r\\ndest_len = &s->s3->handshake_fragment_len;\\r\\n}\\r\\nelse if (rr->type == SSL3_RT_ALERT)\\r\\n{\\r\\ndest_maxlen = sizeof s->s3->alert_fragment;\\r\\ndest = s->s3->alert_fragment;\\r\\ndest_len = &s->s3->alert_fragment_len;\\r\\n}\\r\\nif (dest_maxlen > 0)\\r\\n{\\r\\nn = dest_maxlen - *dest_len;\\r\\nif (rr->length < n)\\r\\nn = rr->length;\\r\\nwhile (n-- > 0)\\r\\n{\\r\\ndest[(*dest_len)++] = rr->data[rr->off++];\\r\\nrr->length--;\\r\\n}\\r\\nif (*dest_len < dest_maxlen)\\r\\ngoto start;\\r\\n}\\r\\n}\\r\\nif ((!s->server) &&\\r\\n(s->s3->handshake_fragment_len >= 4) &&\\r\\n(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\\r\\n(s->session != NULL) && (s->session->cipher != NULL))\\r\\n{\\r\\ns->s3->handshake_fragment_len = 0;\\r\\nif ((s->s3->handshake_fragment[1] != 0) ||\\r\\n(s->s3->handshake_fragment[2] != 0) ||\\r\\n(s->s3->handshake_fragment[3] != 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);\\r\\nif (SSL_is_init_finished(s) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\\r\\n!s->s3->renegotiate)\\r\\n{\\r\\nssl3_renegotiate(s);\\r\\nif (ssl3_renegotiate_check(s))\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!(s->mode & SSL_MODE_AUTO_RETRY))\\r\\n{\\r\\nif (s->s3->rbuf.left == 0)\\r\\n{\\r\\nBIO *bio;\\r\\ns->rwstate=SSL_READING;\\r\\nbio=SSL_get_rbio(s);\\r\\nBIO_clear_retry_flags(bio);\\r\\nBIO_set_retry_read(bio);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nif (s->s3->alert_fragment_len >= 2)\\r\\n{\\r\\nint alert_level = s->s3->alert_fragment[0];\\r\\nint alert_descr = s->s3->alert_fragment[1];\\r\\ns->s3->alert_fragment_len = 0;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj = (alert_level << 8) | alert_descr;\\r\\ncb(s, SSL_CB_READ_ALERT, j);\\r\\n}\\r\\nif (alert_level == 1)\\r\\n{\\r\\ns->s3->warn_alert = alert_descr;\\r\\nif (alert_descr == SSL_AD_CLOSE_NOTIFY)\\r\\n{\\r\\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse if (alert_level == 2)\\r\\n{\\r\\nchar tmp[16];\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->s3->fatal_alert = alert_descr;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\\r\\nERR_add_error_data(2,\"SSL alert number \",tmp);\\r\\ns->shutdown|=SSL_RECEIVED_SHUTDOWN;\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr->length=0;\\r\\nreturn(0);\\r\\n}\\r\\nif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\\r\\n{\\r\\nif ( (rr->length != 1) || (rr->off != 0) ||\\r\\n(rr->data[0] != SSL3_MT_CCS))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->tmp.new_cipher == NULL)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->length=0;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);\\r\\ns->s3->change_cipher_spec=1;\\r\\nif (!ssl3_do_change_cipher_spec(s))\\r\\ngoto err;\\r\\nelse\\r\\ngoto start;\\r\\n}\\r\\nif ((s->s3->handshake_fragment_len >= 4) && !s->in_handshake)\\r\\n{\\r\\nif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\\r\\n{\\r\\n#if 0\\r\\ns->state=SSL_ST_BEFORE|(s->server)\\r\\n?SSL_ST_ACCEPT\\r\\n:SSL_ST_CONNECT;\\r\\n#else\\r\\ns->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\\r\\n#endif\\r\\ns->new_session=1;\\r\\n}\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!(s->mode & SSL_MODE_AUTO_RETRY))\\r\\n{\\r\\nif (s->s3->rbuf.left == 0)\\r\\n{\\r\\nBIO *bio;\\r\\ns->rwstate=SSL_READING;\\r\\nbio=SSL_get_rbio(s);\\r\\nBIO_clear_retry_flags(bio);\\r\\nBIO_set_retry_read(bio);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nswitch (rr->type)\\r\\n{\\r\\ndefault:\\r\\n#ifndef OPENSSL_NO_TLS\\r\\nif (s->version == TLS1_VERSION)\\r\\n{\\r\\nrr->length = 0;\\r\\ngoto start;\\r\\n}\\r\\n#endif\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\\r\\ncase SSL3_RT_ALERT:\\r\\ncase SSL3_RT_HANDSHAKE:\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);\\r\\ngoto f_err;\\r\\ncase SSL3_RT_APPLICATION_DATA:\\r\\nif (s->s3->in_read_app_data &&\\r\\n(s->s3->total_renegotiations != 0) &&\\r\\n((\\r\\n(s->state & SSL_ST_CONNECT) &&\\r\\n(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\\r\\n(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\\r\\n) || (\\r\\n(s->state & SSL_ST_ACCEPT) &&\\r\\n(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\\r\\n(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\\r\\n)\\r\\n))\\r\\n{\\r\\ns->s3->in_read_app_data=2;\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_do_change_cipher_spec(SSL *s)\\r\\n{\\r\\nint i;\\r\\nconst char *sender;\\r\\nint slen;\\r\\nif (s->state & SSL_ST_ACCEPT)\\r\\ni=SSL3_CHANGE_CIPHER_SERVER_READ;\\r\\nelse\\r\\ni=SSL3_CHANGE_CIPHER_CLIENT_READ;\\r\\nif (s->s3->tmp.key_block == NULL)\\r\\n{\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\\r\\n}\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,i))\\r\\nreturn(0);\\r\\nif (s->state & SSL_ST_CONNECT)\\r\\n{\\r\\nsender=s->method->ssl3_enc->server_finished_label;\\r\\nslen=s->method->ssl3_enc->server_finished_label_len;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsender=s->method->ssl3_enc->client_finished_label;\\r\\nslen=s->method->ssl3_enc->client_finished_label_len;\\r\\n}\\r\\ns->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->finish_dgst2),\\r\\nsender,slen,s->s3->tmp.peer_finish_md);\\r\\nreturn(1);\\r\\n}\\r\\nvoid ssl3_send_alert(SSL *s, int level, int desc)\\r\\n{\\r\\ndesc=s->method->ssl3_enc->alert_value(desc);\\r\\nif (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\\r\\ndesc = SSL_AD_HANDSHAKE_FAILURE;\\r\\nif (desc < 0) return;\\r\\nif ((level == 2) && (s->session != NULL))\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\ns->s3->alert_dispatch=1;\\r\\ns->s3->send_alert[0]=level;\\r\\ns->s3->send_alert[1]=desc;\\r\\nif (s->s3->wbuf.left == 0)\\r\\ns->method->ssl_dispatch_alert(s);\\r\\n}\\r\\nint ssl3_dispatch_alert(SSL *s)\\r\\n{\\r\\nint i,j;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\ns->s3->alert_dispatch=0;\\r\\ni = do_ssl3_write(s, SSL3_RT_ALERT, &s->s3->send_alert[0], 2, 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->alert_dispatch=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->s3->send_alert[0] == SSL3_AL_FATAL)\\r\\n(void)BIO_flush(s->wbio);\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, SSL3_RT_ALERT, s->s3->send_alert, 2, s, s->msg_callback_arg);\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(s->s3->send_alert[0]<<8)|s->s3->send_alert[1];\\r\\ncb(s,SSL_CB_WRITE_ALERT,j);\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_ctrl_c", "target": 0, "func": "static int int_ctrl_cmd_is_null(const ENGINE_CMD_DEFN *defn)\\r\\n{\\r\\nif((defn->cmd_num == 0) || (defn->cmd_name == NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int int_ctrl_cmd_by_name(const ENGINE_CMD_DEFN *defn, const char *s)\\r\\n{\\r\\nint idx = 0;\\r\\nwhile(!int_ctrl_cmd_is_null(defn) && (strcmp(defn->cmd_name, s) != 0))\\r\\n{\\r\\nidx++;\\r\\ndefn++;\\r\\n}\\r\\nif(int_ctrl_cmd_is_null(defn))\\r\\nreturn -1;\\r\\nreturn idx;\\r\\n}\\r\\nstatic int int_ctrl_cmd_by_num(const ENGINE_CMD_DEFN *defn, unsigned int num)\\r\\n{\\r\\nint idx = 0;\\r\\nwhile(!int_ctrl_cmd_is_null(defn) && (defn->cmd_num < num))\\r\\n{\\r\\nidx++;\\r\\ndefn++;\\r\\n}\\r\\nif(defn->cmd_num == num)\\r\\nreturn idx;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,\\r\\nvoid (*f)(void))\\r\\n{\\r\\nint idx;\\r\\nchar *s = (char *)p;\\r\\nif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE)\\r\\n{\\r\\nif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\\r\\nreturn 0;\\r\\nreturn e->cmd_defns->cmd_num;\\r\\n}\\r\\nif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\\r\\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\\r\\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD))\\r\\n{\\r\\nif(s == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME)\\r\\n{\\r\\nif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(\\r\\ne->cmd_defns, s)) < 0))\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER,\\r\\nENGINE_R_INVALID_CMD_NAME);\\r\\nreturn -1;\\r\\n}\\r\\nreturn e->cmd_defns[idx].cmd_num;\\r\\n}\\r\\nif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\\r\\n(unsigned int)i)) < 0))\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER,\\r\\nENGINE_R_INVALID_CMD_NUMBER);\\r\\nreturn -1;\\r\\n}\\r\\nswitch(cmd)\\r\\n{\\r\\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\\r\\nidx++;\\r\\nif(int_ctrl_cmd_is_null(e->cmd_defns + idx))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn e->cmd_defns[idx].cmd_num;\\r\\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\\r\\nreturn strlen(e->cmd_defns[idx].cmd_name);\\r\\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\\r\\nreturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1,\\r\\n\"%s\", e->cmd_defns[idx].cmd_name);\\r\\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\\r\\nif(e->cmd_defns[idx].cmd_desc)\\r\\nreturn strlen(e->cmd_defns[idx].cmd_desc);\\r\\nreturn strlen(int_no_description);\\r\\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\\r\\nif(e->cmd_defns[idx].cmd_desc)\\r\\nreturn BIO_snprintf(s,\\r\\nstrlen(e->cmd_defns[idx].cmd_desc) + 1,\\r\\n\"%s\", e->cmd_defns[idx].cmd_desc);\\r\\nreturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\",\\r\\nint_no_description);\\r\\ncase ENGINE_CTRL_GET_CMD_FLAGS:\\r\\nreturn e->cmd_defns[idx].cmd_flags;\\r\\n}\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nint ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint ctrl_exists, ref_exists;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nref_exists = ((e->struct_ref > 0) ? 1 : 0);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nctrl_exists = ((e->ctrl == NULL) ? 0 : 1);\\r\\nif(!ref_exists)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL,ENGINE_R_NO_REFERENCE);\\r\\nreturn 0;\\r\\n}\\r\\nswitch(cmd)\\r\\n{\\r\\ncase ENGINE_CTRL_HAS_CTRL_FUNCTION:\\r\\nreturn ctrl_exists;\\r\\ncase ENGINE_CTRL_GET_FIRST_CMD_TYPE:\\r\\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\\r\\ncase ENGINE_CTRL_GET_CMD_FROM_NAME:\\r\\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_CMD_FLAGS:\\r\\nif(ctrl_exists && !(e->flags & ENGINE_FLAGS_MANUAL_CMD_CTRL))\\r\\nreturn int_ctrl_helper(e,cmd,i,p,f);\\r\\nif(!ctrl_exists)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL,ENGINE_R_NO_CONTROL_FUNCTION);\\r\\nreturn -1;\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif(!ctrl_exists)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL,ENGINE_R_NO_CONTROL_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\nreturn e->ctrl(e, cmd, i, p, f);\\r\\n}\\r\\nint ENGINE_cmd_is_executable(ENGINE *e, int cmd)\\r\\n{\\r\\nint flags;\\r\\nif((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, cmd, NULL, NULL)) < 0)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CMD_IS_EXECUTABLE,\\r\\nENGINE_R_INVALID_CMD_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(flags & ENGINE_CMD_FLAG_NO_INPUT) &&\\r\\n!(flags & ENGINE_CMD_FLAG_NUMERIC) &&\\r\\n!(flags & ENGINE_CMD_FLAG_STRING))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\\r\\nlong i, void *p, void (*f)(void), int cmd_optional)\\r\\n{\\r\\nint num;\\r\\nif((e == NULL) || (cmd_name == NULL))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif((e->ctrl == NULL) || ((num = ENGINE_ctrl(e,\\r\\nENGINE_CTRL_GET_CMD_FROM_NAME,\\r\\n0, (void *)cmd_name, NULL)) <= 0))\\r\\n{\\r\\nif(cmd_optional)\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD,\\r\\nENGINE_R_INVALID_CMD_NAME);\\r\\nreturn 0;\\r\\n}\\r\\nif (ENGINE_ctrl(e, num, i, p, f))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\\r\\nint cmd_optional)\\r\\n{\\r\\nint num, flags;\\r\\nlong l;\\r\\nchar *ptr;\\r\\nif((e == NULL) || (cmd_name == NULL))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif((e->ctrl == NULL) || ((num = ENGINE_ctrl(e,\\r\\nENGINE_CTRL_GET_CMD_FROM_NAME,\\r\\n0, (void *)cmd_name, NULL)) <= 0))\\r\\n{\\r\\nif(cmd_optional)\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_INVALID_CMD_NAME);\\r\\nreturn 0;\\r\\n}\\r\\nif(!ENGINE_cmd_is_executable(e, num))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_CMD_NOT_EXECUTABLE);\\r\\nreturn 0;\\r\\n}\\r\\nif((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL)) < 0)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_NO_INPUT)\\r\\n{\\r\\nif(arg != NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_COMMAND_TAKES_NO_INPUT);\\r\\nreturn 0;\\r\\n}\\r\\nif(ENGINE_ctrl(e, num, 0, (void *)arg, NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif(arg == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_COMMAND_TAKES_INPUT);\\r\\nreturn 0;\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_STRING)\\r\\n{\\r\\nif(ENGINE_ctrl(e, num, 0, (void *)arg, NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif(!(flags & ENGINE_CMD_FLAG_NUMERIC))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nl = strtol(arg, &ptr, 10);\\r\\nif((arg == ptr) || (*ptr != '\\0'))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_ARGUMENT_IS_NOT_A_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif(ENGINE_ctrl(e, num, l, NULL, NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_vms_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nlong pid, iosb[2];\\r\\nint status = 0;\\r\\nstruct\\r\\n{\\r\\nshort length, code;\\r\\nlong *buffer;\\r\\nint *retlen;\\r\\n} item[32], *pitem;\\r\\nunsigned char data_buffer[256];\\r\\nshort total_length = 0;\\r\\nstruct items_data_st *pitems_data;\\r\\npitems_data = items_data;\\r\\npitem = item;\\r\\nwhile (pitems_data->length\\r\\n&& (total_length + pitems_data->length <= 256))\\r\\n{\\r\\npitem->length = pitems_data->length;\\r\\npitem->code = pitems_data->code;\\r\\npitem->buffer = (long *)&data_buffer[total_length];\\r\\npitem->retlen = 0;\\r\\ntotal_length += pitems_data->length;\\r\\npitems_data++;\\r\\npitem++;\\r\\n}\\r\\npitem->length = pitem->code = 0;\\r\\npid = -1;\\r\\nwhile ((status = sys$getjpiw(0, &pid, 0, item, iosb, 0, 0))\\r\\n!= SS$_NOMOREPROC)\\r\\n{\\r\\nif (status == SS$_NORMAL)\\r\\n{\\r\\nRAND_add(data_buffer, total_length, total_length/2);\\r\\n}\\r\\n}\\r\\nsys$gettim(iosb);\\r\\nRAND_add((unsigned char *)iosb, sizeof(iosb), sizeof(iosb)/2);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tab_c", "target": 0, "func": "main()\\r\\n{\\r\\nint i,j;\\r\\nfor (i=0; i<256; i++)\\r\\n{\\r\\nfor (j=0; j<256; j++)\\r\\nif (ebits_to_num[j] == i)\\r\\n{\\r\\nprintf(\"0x%02x,\",j);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_gmp_err_c", "target": 0, "func": "static void ERR_load_GMP_strings(void)\\r\\n{\\r\\nif (GMP_lib_error_code == 0)\\r\\nGMP_lib_error_code=ERR_get_next_error_library();\\r\\nif (GMP_error_init)\\r\\n{\\r\\nGMP_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(GMP_lib_error_code,GMP_str_functs);\\r\\nERR_load_strings(GMP_lib_error_code,GMP_str_reasons);\\r\\n#endif\\r\\n#ifdef GMP_LIB_NAME\\r\\nGMP_lib_name->error = ERR_PACK(GMP_lib_error_code,0,0);\\r\\nERR_load_strings(0,GMP_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_GMP_strings(void)\\r\\n{\\r\\nif (GMP_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(GMP_lib_error_code,GMP_str_functs);\\r\\nERR_unload_strings(GMP_lib_error_code,GMP_str_reasons);\\r\\n#endif\\r\\n#ifdef GMP_LIB_NAME\\r\\nERR_unload_strings(0,GMP_lib_name);\\r\\n#endif\\r\\nGMP_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_GMP_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (GMP_lib_error_code == 0)\\r\\nGMP_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(GMP_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ca_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar *key=NULL,*passargin=NULL;\\r\\nint create_ser = 0;\\r\\nint free_key = 0;\\r\\nint total=0;\\r\\nint total_done=0;\\r\\nint badops=0;\\r\\nint ret=1;\\r\\nint email_dn=1;\\r\\nint req=0;\\r\\nint verbose=0;\\r\\nint gencrl=0;\\r\\nint dorevoke=0;\\r\\nint doupdatedb=0;\\r\\nlong crldays=0;\\r\\nlong crlhours=0;\\r\\nlong errorline= -1;\\r\\nchar *configfile=NULL;\\r\\nchar *md=NULL;\\r\\nchar *policy=NULL;\\r\\nchar *keyfile=NULL;\\r\\nchar *certfile=NULL;\\r\\nint keyform=FORMAT_PEM;\\r\\nchar *infile=NULL;\\r\\nchar *spkac_file=NULL;\\r\\nchar *ss_cert_file=NULL;\\r\\nchar *ser_status=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint output_der = 0;\\r\\nchar *outfile=NULL;\\r\\nchar *outdir=NULL;\\r\\nchar *serialfile=NULL;\\r\\nchar *crlnumberfile=NULL;\\r\\nchar *extensions=NULL;\\r\\nchar *extfile=NULL;\\r\\nchar *subj=NULL;\\r\\nunsigned long chtype = MBSTRING_ASC;\\r\\nint multirdn = 0;\\r\\nchar *tmp_email_dn=NULL;\\r\\nchar *crl_ext=NULL;\\r\\nint rev_type = REV_NONE;\\r\\nchar *rev_arg = NULL;\\r\\nBIGNUM *serial=NULL;\\r\\nBIGNUM *crlnumber=NULL;\\r\\nchar *startdate=NULL;\\r\\nchar *enddate=NULL;\\r\\nlong days=0;\\r\\nint batch=0;\\r\\nint notext=0;\\r\\nunsigned long nameopt = 0, certopt = 0;\\r\\nint default_op = 1;\\r\\nint ext_copy = EXT_COPY_NONE;\\r\\nint selfsign = 0;\\r\\nX509 *x509=NULL, *x509p = NULL;\\r\\nX509 *x=NULL;\\r\\nBIO *in=NULL,*out=NULL,*Sout=NULL,*Cout=NULL;\\r\\nchar *dbfile=NULL;\\r\\nCA_DB *db=NULL;\\r\\nX509_CRL *crl=NULL;\\r\\nX509_REVOKED *r=NULL;\\r\\nASN1_TIME *tmptm;\\r\\nASN1_INTEGER *tmpser;\\r\\nchar *f;\\r\\nconst char *p, **pp;\\r\\nint i,j;\\r\\nconst EVP_MD *dgst=NULL;\\r\\nSTACK_OF(CONF_VALUE) *attribs=NULL;\\r\\nSTACK_OF(X509) *cert_sk=NULL;\\r\\n#undef BSIZE\\r\\n#define BSIZE 256\\r\\nMS_STATIC char buf[3][BSIZE];\\r\\nchar *randfile=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nchar *tofree=NULL;\\r\\nDB_ATTR db_attr;\\r\\n#ifdef EFENCE\\r\\nEF_PROTECT_FREE=1;\\r\\nEF_PROTECT_BELOW=1;\\r\\nEF_ALIGNMENT=0;\\r\\n#endif\\r\\napps_startup();\\r\\nconf = NULL;\\r\\nkey = NULL;\\r\\nsection = NULL;\\r\\npreserve=0;\\r\\nmsie_hack=0;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-verbose\") == 0)\\r\\nverbose=1;\\r\\nelse if (strcmp(*argv,\"-config\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nconfigfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-name\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsection= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-subj\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsubj= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-utf8\") == 0)\\r\\nchtype = MBSTRING_UTF8;\\r\\nelse if (strcmp(*argv,\"-create_serial\") == 0)\\r\\ncreate_ser = 1;\\r\\nelse if (strcmp(*argv,\"-multivalue-rdn\") == 0)\\r\\nmultirdn=1;\\r\\nelse if (strcmp(*argv,\"-startdate\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nstartdate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-enddate\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nenddate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays=atoi(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-md\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nmd= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-policy\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npolicy= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyform=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncertfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-selfsign\") == 0)\\r\\nselfsign=1;\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outdir\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutdir= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-notext\") == 0)\\r\\nnotext=1;\\r\\nelse if (strcmp(*argv,\"-batch\") == 0)\\r\\nbatch=1;\\r\\nelse if (strcmp(*argv,\"-preserveDN\") == 0)\\r\\npreserve=1;\\r\\nelse if (strcmp(*argv,\"-noemailDN\") == 0)\\r\\nemail_dn=0;\\r\\nelse if (strcmp(*argv,\"-gencrl\") == 0)\\r\\ngencrl=1;\\r\\nelse if (strcmp(*argv,\"-msie_hack\") == 0)\\r\\nmsie_hack=1;\\r\\nelse if (strcmp(*argv,\"-crldays\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncrldays= atol(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crlhours\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncrlhours= atol(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-infiles\") == 0)\\r\\n{\\r\\nargc--;\\r\\nargv++;\\r\\nreq=1;\\r\\nbreak;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-ss_cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nss_cert_file = *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-spkac\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nspkac_file = *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-revoke\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\ndorevoke=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extensions\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextensions= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-status\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nser_status= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-updatedb\") == 0)\\r\\n{\\r\\ndoupdatedb=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crlexts\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncrl_ext= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_reason\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_CRL_REASON;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_hold\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_HOLD;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_compromise\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_KEY_COMPROMISE;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_CA_compromise\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_CA_COMPROMISE;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nfor (pp=ca_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\ntofree=NULL;\\r\\nif (configfile == NULL) configfile = getenv(\"OPENSSL_CONF\");\\r\\nif (configfile == NULL) configfile = getenv(\"SSLEAY_CONF\");\\r\\nif (configfile == NULL)\\r\\n{\\r\\nconst char *s=X509_get_default_cert_area();\\r\\nsize_t len;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nlen = strlen(s)+sizeof(CONFIG_FILE);\\r\\ntofree=OPENSSL_malloc(len);\\r\\nstrcpy(tofree,s);\\r\\n#else\\r\\nlen = strlen(s)+sizeof(CONFIG_FILE)+1;\\r\\ntofree=OPENSSL_malloc(len);\\r\\nBUF_strlcpy(tofree,s,len);\\r\\nBUF_strlcat(tofree,\"/\",len);\\r\\n#endif\\r\\nBUF_strlcat(tofree,CONFIG_FILE,len);\\r\\nconfigfile=tofree;\\r\\n}\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",configfile);\\r\\nconf = NCONF_new(NULL);\\r\\nif (NCONF_load(conf,configfile,&errorline) <= 0)\\r\\n{\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err,\"error loading the config file '%s'\\n\",\\r\\nconfigfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\"error on line %ld of config file '%s'\\n\"\\r\\n,errorline,configfile);\\r\\ngoto err;\\r\\n}\\r\\nif(tofree)\\r\\n{\\r\\nOPENSSL_free(tofree);\\r\\ntofree = NULL;\\r\\n}\\r\\nif (!load_config(bio_err, conf))\\r\\ngoto err;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (section == NULL)\\r\\n{\\r\\nsection=NCONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_CA);\\r\\nif (section == NULL)\\r\\n{\\r\\nlookup_fail(BASE_SECTION,ENV_DEFAULT_CA);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (conf != NULL)\\r\\n{\\r\\np=NCONF_get_string(conf,NULL,\"oid_file\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO *oid_bio;\\r\\noid_bio=BIO_new_file(p,\"r\");\\r\\nif (oid_bio == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\n}\\r\\nelse\\r\\n{\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\nif (!add_oid_section(bio_err,conf))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nrandfile = NCONF_get_string(conf, BASE_SECTION, \"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nf = NCONF_get_string(conf, section, STRING_MASK);\\r\\nif (!f)\\r\\nERR_clear_error();\\r\\nif(f && !ASN1_STRING_set_default_mask_asc(f)) {\\r\\nBIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\nif (chtype != MBSTRING_UTF8){\\r\\nf = NCONF_get_string(conf, section, UTF8_IN);\\r\\nif (!f)\\r\\nERR_clear_error();\\r\\nelse if (!strcmp(f, \"yes\"))\\r\\nchtype = MBSTRING_UTF8;\\r\\n}\\r\\ndb_attr.unique_subject = 1;\\r\\np = NCONF_get_string(conf, section, ENV_UNIQUE_SUBJECT);\\r\\nif (p)\\r\\n{\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: unique_subject = \\\"%s\\\"\\n\", p);\\r\\n#endif\\r\\ndb_attr.unique_subject = parse_yesno(p,1);\\r\\n}\\r\\nelse\\r\\nERR_clear_error();\\r\\n#ifdef RL_DEBUG\\r\\nif (!p)\\r\\nBIO_printf(bio_err, \"DEBUG: unique_subject undefined\\n\", p);\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: configured unique_subject is %d\\n\",\\r\\ndb_attr.unique_subject);\\r\\n#endif\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nSout=BIO_new(BIO_s_file());\\r\\nCout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL) || (Sout == NULL) || (Cout == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (ser_status)\\r\\n{\\r\\nif ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)\\r\\n{\\r\\nlookup_fail(section,ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\ndb = load_index(dbfile,&db_attr);\\r\\nif (db == NULL) goto err;\\r\\nif (!index_index(db)) goto err;\\r\\nif (get_certificate_status(ser_status,db) != 1)\\r\\nBIO_printf(bio_err,\"Error verifying serial %s!\\n\",\\r\\nser_status);\\r\\ngoto err;\\r\\n}\\r\\nif ((keyfile == NULL) && ((keyfile=NCONF_get_string(conf,\\r\\nsection,ENV_PRIVATE_KEY)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!key)\\r\\n{\\r\\nfree_key = 1;\\r\\nif (!app_passwd(bio_err, passargin, NULL, &key, NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Error getting password\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\npkey = load_key(bio_err, keyfile, keyform, 0, key, e,\\r\\n\"CA private key\");\\r\\nif (key) OPENSSL_cleanse(key,strlen(key));\\r\\nif (pkey == NULL)\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\nif (!selfsign || spkac_file || ss_cert_file || gencrl)\\r\\n{\\r\\nif ((certfile == NULL)\\r\\n&& ((certfile=NCONF_get_string(conf,\\r\\nsection,ENV_CERTIFICATE)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nx509=load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,\\r\\n\"CA certificate\");\\r\\nif (x509 == NULL)\\r\\ngoto err;\\r\\nif (!X509_check_private_key(x509,pkey))\\r\\n{\\r\\nBIO_printf(bio_err,\"CA certificate and CA private key do not match\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!selfsign) x509p = x509;\\r\\nf=NCONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);\\r\\nif (f == NULL)\\r\\nERR_clear_error();\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\npreserve=1;\\r\\nf=NCONF_get_string(conf,BASE_SECTION,ENV_MSIE_HACK);\\r\\nif (f == NULL)\\r\\nERR_clear_error();\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\nmsie_hack=1;\\r\\nf=NCONF_get_string(conf,section,ENV_NAMEOPT);\\r\\nif (f)\\r\\n{\\r\\nif (!set_name_ex(&nameopt, f))\\r\\n{\\r\\nBIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\ndefault_op = 0;\\r\\n}\\r\\nelse\\r\\nERR_clear_error();\\r\\nf=NCONF_get_string(conf,section,ENV_CERTOPT);\\r\\nif (f)\\r\\n{\\r\\nif (!set_cert_ex(&certopt, f))\\r\\n{\\r\\nBIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\ndefault_op = 0;\\r\\n}\\r\\nelse\\r\\nERR_clear_error();\\r\\nf=NCONF_get_string(conf,section,ENV_EXTCOPY);\\r\\nif (f)\\r\\n{\\r\\nif (!set_ext_copy(&ext_copy, f))\\r\\n{\\r\\nBIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nERR_clear_error();\\r\\nif ((outdir == NULL) && (req))\\r\\n{\\r\\nstruct stat sb;\\r\\nif ((outdir=NCONF_get_string(conf,section,ENV_NEW_CERTS_DIR))\\r\\n== NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"there needs to be defined a directory for new certificate to be placed in\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nif (access(outdir,R_OK|W_OK|X_OK) != 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"I am unable to access the %s directory\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\nif (stat(outdir,&sb) != 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to stat(%s)\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef S_IFDIR\\r\\nif (!(sb.st_mode & S_IFDIR))\\r\\n{\\r\\nBIO_printf(bio_err,\"%s need to be a directory\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\n}\\r\\nif ((dbfile=NCONF_get_string(conf,section,ENV_DATABASE)) == NULL)\\r\\n{\\r\\nlookup_fail(section,ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\ndb = load_index(dbfile, &db_attr);\\r\\nif (db == NULL) goto err;\\r\\nfor (i=0; i<sk_num(db->db->data); i++)\\r\\n{\\r\\npp=(const char **)sk_value(db->db->data,i);\\r\\nif ((pp[DB_type][0] != DB_TYPE_REV) &&\\r\\n(pp[DB_rev_date][0] != '\\0'))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: not revoked yet, but has a revocation date\\n\",i+1);\\r\\ngoto err;\\r\\n}\\r\\nif ((pp[DB_type][0] == DB_TYPE_REV) &&\\r\\n!make_revoked(NULL, pp[DB_rev_date]))\\r\\n{\\r\\nBIO_printf(bio_err,\" in entry %d\\n\", i+1);\\r\\ngoto err;\\r\\n}\\r\\nif (!check_time_format((char *)pp[DB_exp_date]))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: invalid expiry date\\n\",i+1);\\r\\ngoto err;\\r\\n}\\r\\np=pp[DB_serial];\\r\\nj=strlen(p);\\r\\nif (*p == '-')\\r\\n{\\r\\np++;\\r\\nj--;\\r\\n}\\r\\nif ((j&1) || (j < 2))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: bad serial number length (%d)\\n\",i+1,j);\\r\\ngoto err;\\r\\n}\\r\\nwhile (*p)\\r\\n{\\r\\nif (!( ((*p >= '0') && (*p <= '9')) ||\\r\\n((*p >= 'A') && (*p <= 'F')) ||\\r\\n((*p >= 'a') && (*p <= 'f'))) )\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: bad serial number characters, char pos %ld, char is '%c'\\n\",i+1,(long)(p-pp[DB_serial]),*p);\\r\\ngoto err;\\r\\n}\\r\\np++;\\r\\n}\\r\\n}\\r\\nif (verbose)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nTXT_DB_write(out,db->db);\\r\\nBIO_printf(bio_err,\"%d entries loaded from the database\\n\",\\r\\ndb->db->data->num);\\r\\nBIO_printf(bio_err,\"generating index\\n\");\\r\\n}\\r\\nif (!index_index(db)) goto err;\\r\\nif (doupdatedb)\\r\\n{\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"Updating %s ...\\n\",\\r\\ndbfile);\\r\\ni = do_updatedb(db);\\r\\nif (i == -1)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nif (verbose) BIO_printf(bio_err,\\r\\n\"No entries found to mark expired\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!save_index(dbfile,\"new\",db)) goto err;\\r\\nif (!rotate_index(dbfile,\"new\",\"old\")) goto err;\\r\\nif (verbose) BIO_printf(bio_err,\\r\\n\"Done. %d entries marked as expired\\n\",i);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nif (extfile)\\r\\n{\\r\\nextconf = NCONF_new(NULL);\\r\\nif (NCONF_load(extconf,extfile,&errorline) <= 0)\\r\\n{\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err, \"ERROR: loading the config file '%s'\\n\",\\r\\nextfile);\\r\\nelse\\r\\nBIO_printf(bio_err, \"ERROR: on line %ld of config file '%s'\\n\",\\r\\nerrorline,extfile);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\", extfile);\\r\\nif (!extensions && !(extensions = NCONF_get_string(extconf, \"default\", \"extensions\")))\\r\\nextensions = \"default\";\\r\\n}\\r\\nif (req || gencrl)\\r\\n{\\r\\nif (outfile != NULL)\\r\\n{\\r\\nif (BIO_write_filename(Sout,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_set_fp(Sout,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSout = BIO_push(tmpbio, Sout);\\r\\n}\\r\\n#endif\\r\\n}\\r\\n}\\r\\nif ((md == NULL) && ((md=NCONF_get_string(conf,\\r\\nsection,ENV_DEFAULT_MD)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_DEFAULT_MD);\\r\\ngoto err;\\r\\n}\\r\\nif ((dgst=EVP_get_digestbyname(md)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s is an unsupported message digest type\\n\",md);\\r\\ngoto err;\\r\\n}\\r\\nif (req)\\r\\n{\\r\\nif ((email_dn == 1) && ((tmp_email_dn=NCONF_get_string(conf,\\r\\nsection,ENV_DEFAULT_EMAIL_DN)) != NULL ))\\r\\n{\\r\\nif(strcmp(tmp_email_dn,\"no\") == 0)\\r\\nemail_dn=0;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"message digest is %s\\n\",\\r\\nOBJ_nid2ln(dgst->type));\\r\\nif ((policy == NULL) && ((policy=NCONF_get_string(conf,\\r\\nsection,ENV_POLICY)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_POLICY);\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"policy is %s\\n\",policy);\\r\\nif ((serialfile=NCONF_get_string(conf,section,ENV_SERIAL))\\r\\n== NULL)\\r\\n{\\r\\nlookup_fail(section,ENV_SERIAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!extconf)\\r\\n{\\r\\nif (!extensions)\\r\\n{\\r\\nextensions=NCONF_get_string(conf,section,\\r\\nENV_EXTENSIONS);\\r\\nif (!extensions)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (extensions)\\r\\n{\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, extensions,\\r\\nNULL))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (startdate == NULL)\\r\\n{\\r\\nstartdate=NCONF_get_string(conf,section,\\r\\nENV_DEFAULT_STARTDATE);\\r\\nif (startdate == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (startdate && !ASN1_UTCTIME_set_string(NULL,startdate))\\r\\n{\\r\\nBIO_printf(bio_err,\"start date is invalid, it should be YYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (startdate == NULL) startdate=\"today\";\\r\\nif (enddate == NULL)\\r\\n{\\r\\nenddate=NCONF_get_string(conf,section,\\r\\nENV_DEFAULT_ENDDATE);\\r\\nif (enddate == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (enddate && !ASN1_UTCTIME_set_string(NULL,enddate))\\r\\n{\\r\\nBIO_printf(bio_err,\"end date is invalid, it should be YYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (days == 0)\\r\\n{\\r\\nif(!NCONF_get_number(conf,section, ENV_DEFAULT_DAYS, &days))\\r\\ndays = 0;\\r\\n}\\r\\nif (!enddate && (days == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"cannot lookup how many days to certify for\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((serial=load_serial(serialfile, create_ser, NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error while loading serial number\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\n{\\r\\nif (BN_is_zero(serial))\\r\\nBIO_printf(bio_err,\"next serial number is 00\\n\");\\r\\nelse\\r\\n{\\r\\nif ((f=BN_bn2hex(serial)) == NULL) goto err;\\r\\nBIO_printf(bio_err,\"next serial number is %s\\n\",f);\\r\\nOPENSSL_free(f);\\r\\n}\\r\\n}\\r\\nif ((attribs=NCONF_get_section(conf,policy)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to find 'section' for %s\\n\",policy);\\r\\ngoto err;\\r\\n}\\r\\nif ((cert_sk=sk_X509_new_null()) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (spkac_file != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify_spkac(&x,spkac_file,pkey,x509,dgst,attribs,db,\\r\\nserial,subj,chtype,multirdn,email_dn,startdate,enddate,days,extensions,\\r\\nconf,verbose,certopt,nameopt,default_op,ext_copy);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_X509_push(cert_sk,x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (outfile)\\r\\n{\\r\\noutput_der = 1;\\r\\nbatch = 1;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (ss_cert_file != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify_cert(&x,ss_cert_file,pkey,x509,dgst,attribs,\\r\\ndb,serial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose, certopt, nameopt,\\r\\ndefault_op, ext_copy, e);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_X509_push(cert_sk,x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (infile != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify(&x,infile,pkey,x509p,dgst,attribs,db,\\r\\nserial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose, certopt, nameopt,\\r\\ndefault_op, ext_copy, selfsign);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_X509_push(cert_sk,x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nfor (i=0; i<argc; i++)\\r\\n{\\r\\ntotal++;\\r\\nj=certify(&x,argv[i],pkey,x509p,dgst,attribs,db,\\r\\nserial,subj,chtype,multirdn,email_dn,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose, certopt, nameopt,\\r\\ndefault_op, ext_copy, selfsign);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_X509_push(cert_sk,x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (sk_X509_num(cert_sk) > 0)\\r\\n{\\r\\nif (!batch)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n%d out of %d certificate requests certified, commit? [y/n]\",total_done,total);\\r\\n(void)BIO_flush(bio_err);\\r\\nbuf[0][0]='\\0';\\r\\nfgets(buf[0],10,stdin);\\r\\nif ((buf[0][0] != 'y') && (buf[0][0] != 'Y'))\\r\\n{\\r\\nBIO_printf(bio_err,\"CERTIFICATION CANCELED\\n\");\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"Write out database with %d new entries\\n\",sk_X509_num(cert_sk));\\r\\nif (!save_serial(serialfile,\"new\",serial,NULL)) goto err;\\r\\nif (!save_index(dbfile, \"new\", db)) goto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"writing new certificates\\n\");\\r\\nfor (i=0; i<sk_X509_num(cert_sk); i++)\\r\\n{\\r\\nint k;\\r\\nchar *n;\\r\\nx=sk_X509_value(cert_sk,i);\\r\\nj=x->cert_info->serialNumber->length;\\r\\np=(const char *)x->cert_info->serialNumber->data;\\r\\nif(strlen(outdir) >= (size_t)(j ? BSIZE-j*2-6 : BSIZE-8))\\r\\n{\\r\\nBIO_printf(bio_err,\"certificate file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\nstrcpy(buf[2],outdir);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(buf[2],\"/\",sizeof(buf[2]));\\r\\n#endif\\r\\nn=(char *)&(buf[2][strlen(buf[2])]);\\r\\nif (j > 0)\\r\\n{\\r\\nfor (k=0; k<j; k++)\\r\\n{\\r\\nif (n >= &(buf[2][sizeof(buf[2])]))\\r\\nbreak;\\r\\nBIO_snprintf(n,\\r\\n&buf[2][0] + sizeof(buf[2]) - n,\\r\\n\"%02X\",(unsigned char)*(p++));\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n*(n++)='0';\\r\\n*(n++)='0';\\r\\n}\\r\\n*(n++)='.'; *(n++)='p'; *(n++)='e'; *(n++)='m';\\r\\n*n='\\0';\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"writing %s\\n\",buf[2]);\\r\\nif (BIO_write_filename(Cout,buf[2]) <= 0)\\r\\n{\\r\\nperror(buf[2]);\\r\\ngoto err;\\r\\n}\\r\\nwrite_new_certificate(Cout,x, 0, notext);\\r\\nwrite_new_certificate(Sout,x, output_der, notext);\\r\\n}\\r\\nif (sk_X509_num(cert_sk))\\r\\n{\\r\\nif (!rotate_serial(serialfile,\"new\",\"old\")) goto err;\\r\\nif (!rotate_index(dbfile,\"new\",\"old\")) goto err;\\r\\nBIO_printf(bio_err,\"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nif (gencrl)\\r\\n{\\r\\nint crl_v2 = 0;\\r\\nif (!crl_ext)\\r\\n{\\r\\ncrl_ext=NCONF_get_string(conf,section,ENV_CRLEXT);\\r\\nif (!crl_ext)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (crl_ext)\\r\\n{\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading CRL extension section %s\\n\",\\r\\ncrl_ext);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((crlnumberfile=NCONF_get_string(conf,section,ENV_CRLNUMBER))\\r\\n!= NULL)\\r\\nif ((crlnumber=load_serial(crlnumberfile,0,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error while loading CRL number\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!crldays && !crlhours)\\r\\n{\\r\\nif (!NCONF_get_number(conf,section,\\r\\nENV_DEFAULT_CRL_DAYS, &crldays))\\r\\ncrldays = 0;\\r\\nif (!NCONF_get_number(conf,section,\\r\\nENV_DEFAULT_CRL_HOURS, &crlhours))\\r\\ncrlhours = 0;\\r\\n}\\r\\nif ((crldays == 0) && (crlhours == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"cannot lookup how long until the next CRL is issued\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose) BIO_printf(bio_err,\"making CRL\\n\");\\r\\nif ((crl=X509_CRL_new()) == NULL) goto err;\\r\\nif (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509))) goto err;\\r\\ntmptm = ASN1_TIME_new();\\r\\nif (!tmptm) goto err;\\r\\nX509_gmtime_adj(tmptm,0);\\r\\nX509_CRL_set_lastUpdate(crl, tmptm);\\r\\nX509_gmtime_adj(tmptm,(crldays*24+crlhours)*60*60);\\r\\nX509_CRL_set_nextUpdate(crl, tmptm);\\r\\nASN1_TIME_free(tmptm);\\r\\nfor (i=0; i<sk_num(db->db->data); i++)\\r\\n{\\r\\npp=(const char **)sk_value(db->db->data,i);\\r\\nif (pp[DB_type][0] == DB_TYPE_REV)\\r\\n{\\r\\nif ((r=X509_REVOKED_new()) == NULL) goto err;\\r\\nj = make_revoked(r, pp[DB_rev_date]);\\r\\nif (!j) goto err;\\r\\nif (j == 2) crl_v2 = 1;\\r\\nif (!BN_hex2bn(&serial, pp[DB_serial]))\\r\\ngoto err;\\r\\ntmpser = BN_to_ASN1_INTEGER(serial, NULL);\\r\\nBN_free(serial);\\r\\nserial = NULL;\\r\\nif (!tmpser)\\r\\ngoto err;\\r\\nX509_REVOKED_set_serialNumber(r, tmpser);\\r\\nASN1_INTEGER_free(tmpser);\\r\\nX509_CRL_add0_revoked(crl,r);\\r\\n}\\r\\n}\\r\\nX509_CRL_sort(crl);\\r\\nif (verbose) BIO_printf(bio_err,\"signing CRL\\n\");\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\ndgst=EVP_dss1();\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\ndgst=EVP_ecdsa();\\r\\n#endif\\r\\nif (crl_ext || crlnumberfile != NULL)\\r\\n{\\r\\nX509V3_CTX crlctx;\\r\\nX509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\\r\\nX509V3_set_nconf(&crlctx, conf);\\r\\nif (crl_ext)\\r\\nif (!X509V3_EXT_CRL_add_nconf(conf, &crlctx,\\r\\ncrl_ext, crl)) goto err;\\r\\nif (crlnumberfile != NULL)\\r\\n{\\r\\ntmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\\r\\nif (!tmpser) goto err;\\r\\nX509_CRL_add1_ext_i2d(crl,NID_crl_number,tmpser,0,0);\\r\\nASN1_INTEGER_free(tmpser);\\r\\ncrl_v2 = 1;\\r\\nif (!BN_add_word(crlnumber,1)) goto err;\\r\\n}\\r\\n}\\r\\nif (crl_ext || crl_v2)\\r\\n{\\r\\nif (!X509_CRL_set_version(crl, 1))\\r\\ngoto err;\\r\\n}\\r\\nif (crlnumberfile != NULL)\\r\\nif (!save_serial(crlnumberfile,\"new\",crlnumber,NULL)) goto err;\\r\\nif (!X509_CRL_sign(crl,pkey,dgst)) goto err;\\r\\nPEM_write_bio_X509_CRL(Sout,crl);\\r\\nif (crlnumberfile != NULL)\\r\\nif (!rotate_serial(crlnumberfile,\"new\",\"old\")) goto err;\\r\\n}\\r\\nif (dorevoke)\\r\\n{\\r\\nif (infile == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no input files\\n\");\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509 *revcert;\\r\\nrevcert=load_cert(bio_err, infile, FORMAT_PEM,\\r\\nNULL, e, infile);\\r\\nif (revcert == NULL)\\r\\ngoto err;\\r\\nj=do_revoke(revcert,db, rev_type, rev_arg);\\r\\nif (j <= 0) goto err;\\r\\nX509_free(revcert);\\r\\nif (!save_index(dbfile, \"new\", db)) goto err;\\r\\nif (!rotate_index(dbfile, \"new\", \"old\")) goto err;\\r\\nBIO_printf(bio_err,\"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nerr:\\r\\nif(tofree)\\r\\nOPENSSL_free(tofree);\\r\\nBIO_free_all(Cout);\\r\\nBIO_free_all(Sout);\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(in);\\r\\nif (cert_sk)\\r\\nsk_X509_pop_free(cert_sk,X509_free);\\r\\nif (ret) ERR_print_errors(bio_err);\\r\\napp_RAND_write_file(randfile, bio_err);\\r\\nif (free_key && key)\\r\\nOPENSSL_free(key);\\r\\nBN_free(serial);\\r\\nfree_index(db);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (x509) X509_free(x509);\\r\\nX509_CRL_free(crl);\\r\\nNCONF_free(conf);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void lookup_fail(const char *name, const char *tag)\\r\\n{\\r\\nBIO_printf(bio_err,\"variable lookup failed for %s::%s\\n\",name,tag);\\r\\n}\\r\\nstatic void write_new_certificate(BIO *bp, X509 *x, int output_der, int notext)\\r\\n{\\r\\nif (output_der)\\r\\n{\\r\\n(void)i2d_X509_bio(bp,x);\\r\\nreturn;\\r\\n}\\r\\n#if 0\\r\\nf=X509_NAME_oneline(X509_get_issuer_name(x),buf,256);\\r\\nBIO_printf(bp,\"issuer :%s\\n\",f);\\r\\nf=X509_NAME_oneline(X509_get_subject_name(x),buf,256);\\r\\nBIO_printf(bp,\"subject:%s\\n\",f);\\r\\nBIO_puts(bp,\"serial :\");\\r\\ni2a_ASN1_INTEGER(bp,x->cert_info->serialNumber);\\r\\nBIO_puts(bp,\"\\n\\n\");\\r\\n#endif\\r\\nif (!notext)X509_print(bp,x);\\r\\nPEM_write_bio_X509(bp,x);\\r\\n}\\r\\nstatic int fix_data(int nid, int *type)\\r\\n{\\r\\nif (nid == NID_pkcs9_emailAddress)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nif ((nid == NID_commonName) && (*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_challengePassword) && (*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_unstructuredName) && (*type == V_ASN1_T61STRING))\\r\\nreturn(0);\\r\\nif (nid == NID_pkcs9_unstructuredName)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int check_time_format(char *str)\\r\\n{\\r\\nASN1_UTCTIME tm;\\r\\ntm.data=(unsigned char *)str;\\r\\ntm.length=strlen(str);\\r\\ntm.type=V_ASN1_UTCTIME;\\r\\nreturn(ASN1_UTCTIME_check(&tm));\\r\\n}\\r\\nstatic int do_revoke(X509 *x509, CA_DB *db, int type, char *value)\\r\\n{\\r\\nASN1_UTCTIME *tm=NULL;\\r\\nchar *row[DB_NUMBER],**rrow,**irow;\\r\\nchar *rev_str = NULL;\\r\\nBIGNUM *bn = NULL;\\r\\nint ok=-1,i;\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\nrow[i]=NULL;\\r\\nrow[DB_name]=X509_NAME_oneline(X509_get_subject_name(x509),NULL,0);\\r\\nbn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509),NULL);\\r\\nif (BN_is_zero(bn))\\r\\nrow[DB_serial]=BUF_strdup(\"00\");\\r\\nelse\\r\\nrow[DB_serial]=BN_bn2hex(bn);\\r\\nBN_free(bn);\\r\\nif ((row[DB_name] == NULL) || (row[DB_serial] == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nrrow=TXT_DB_get_by_index(db->db,DB_serial,row);\\r\\nif (rrow == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Adding Entry with serial number %s to DB for %s\\n\", row[DB_serial], row[DB_name]);\\r\\nrow[DB_type]=(char *)OPENSSL_malloc(2);\\r\\ntm=X509_get_notAfter(x509);\\r\\nrow[DB_exp_date]=(char *)OPENSSL_malloc(tm->length+1);\\r\\nmemcpy(row[DB_exp_date],tm->data,tm->length);\\r\\nrow[DB_exp_date][tm->length]='\\0';\\r\\nrow[DB_rev_date]=NULL;\\r\\nrow[DB_file]=(char *)OPENSSL_malloc(8);\\r\\nif ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||\\r\\n(row[DB_file] == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(row[DB_file],\"unknown\",8);\\r\\nrow[DB_type][0]='V';\\r\\nrow[DB_type][1]='\\0';\\r\\nif ((irow=(char **)OPENSSL_malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\n{\\r\\nirow[i]=row[i];\\r\\nrow[i]=NULL;\\r\\n}\\r\\nirow[DB_NUMBER]=NULL;\\r\\nif (!TXT_DB_insert(db->db,irow))\\r\\n{\\r\\nBIO_printf(bio_err,\"failed to update database\\n\");\\r\\nBIO_printf(bio_err,\"TXT_DB error number %ld\\n\",db->db->error);\\r\\ngoto err;\\r\\n}\\r\\nok = do_revoke(x509,db, type, value);\\r\\ngoto err;\\r\\n}\\r\\nelse if (index_name_cmp((const char **)row,(const char **)rrow))\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR:name does not match %s\\n\",\\r\\nrow[DB_name]);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='R')\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR:Already revoked, serial number %s\\n\",\\r\\nrow[DB_serial]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"Revoking Certificate %s.\\n\", rrow[DB_serial]);\\r\\nrev_str = make_revocation_str(type, value);\\r\\nif (!rev_str)\\r\\n{\\r\\nBIO_printf(bio_err, \"Error in revocation arguments\\n\");\\r\\ngoto err;\\r\\n}\\r\\nrrow[DB_type][0]='R';\\r\\nrrow[DB_type][1]='\\0';\\r\\nrrow[DB_rev_date] = rev_str;\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\n{\\r\\nif (row[i] != NULL)\\r\\nOPENSSL_free(row[i]);\\r\\n}\\r\\nreturn(ok);\\r\\n}\\r\\nstatic int get_certificate_status(const char *serial, CA_DB *db)\\r\\n{\\r\\nchar *row[DB_NUMBER],**rrow;\\r\\nint ok=-1,i;\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\nrow[i]=NULL;\\r\\nrow[DB_serial] = OPENSSL_malloc(strlen(serial) + 2);\\r\\nif (row[DB_serial] == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (strlen(serial) % 2)\\r\\n{\\r\\n;\\r\\nrow[DB_serial][0]='0';\\r\\nmemcpy(row[DB_serial]+1, serial, strlen(serial));\\r\\nrow[DB_serial][strlen(serial)+1]='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(row[DB_serial], serial, strlen(serial));\\r\\nrow[DB_serial][strlen(serial)]='\\0';\\r\\n}\\r\\nfor (i=0; row[DB_serial][i] != '\\0'; i++)\\r\\nrow[DB_serial][i] = toupper(row[DB_serial][i]);\\r\\nok=1;\\r\\nrrow=TXT_DB_get_by_index(db->db,DB_serial,row);\\r\\nif (rrow == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Serial %s not present in db.\\n\",\\r\\nrow[DB_serial]);\\r\\nok=-1;\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='V')\\r\\n{\\r\\nBIO_printf(bio_err,\"%s=Valid (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='R')\\r\\n{\\r\\nBIO_printf(bio_err,\"%s=Revoked (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='E')\\r\\n{\\r\\nBIO_printf(bio_err,\"%s=Expired (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='S')\\r\\n{\\r\\nBIO_printf(bio_err,\"%s=Suspended (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"%s=Unknown (%c).\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\nok=-1;\\r\\n}\\r\\nerr:\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\n{\\r\\nif (row[i] != NULL)\\r\\nOPENSSL_free(row[i]);\\r\\n}\\r\\nreturn(ok);\\r\\n}\\r\\nstatic int do_updatedb (CA_DB *db)\\r\\n{\\r\\nASN1_UTCTIME *a_tm = NULL;\\r\\nint i, cnt = 0;\\r\\nint db_y2k, a_y2k;\\r\\nchar **rrow, *a_tm_s;\\r\\na_tm = ASN1_UTCTIME_new();\\r\\na_tm = X509_gmtime_adj(a_tm, 0);\\r\\na_tm_s = (char *) OPENSSL_malloc(a_tm->length+1);\\r\\nif (a_tm_s == NULL)\\r\\n{\\r\\ncnt = -1;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(a_tm_s, a_tm->data, a_tm->length);\\r\\na_tm_s[a_tm->length] = '\\0';\\r\\nif (strncmp(a_tm_s, \"49\", 2) <= 0)\\r\\na_y2k = 1;\\r\\nelse\\r\\na_y2k = 0;\\r\\nfor (i = 0; i < sk_num(db->db->data); i++)\\r\\n{\\r\\nrrow = (char **) sk_value(db->db->data, i);\\r\\nif (rrow[DB_type][0] == 'V')\\r\\n{\\r\\nif (strncmp(rrow[DB_exp_date], \"49\", 2) <= 0)\\r\\ndb_y2k = 1;\\r\\nelse\\r\\ndb_y2k = 0;\\r\\nif (db_y2k == a_y2k)\\r\\n{\\r\\nif (strcmp(rrow[DB_exp_date], a_tm_s) <= 0)\\r\\n{\\r\\nrrow[DB_type][0] = 'E';\\r\\nrrow[DB_type][1] = '\\0';\\r\\ncnt++;\\r\\nBIO_printf(bio_err, \"%s=Expired\\n\",\\r\\nrrow[DB_serial]);\\r\\n}\\r\\n}\\r\\nelse if (db_y2k < a_y2k)\\r\\n{\\r\\nrrow[DB_type][0] = 'E';\\r\\nrrow[DB_type][1] = '\\0';\\r\\ncnt++;\\r\\nBIO_printf(bio_err, \"%s=Expired\\n\",\\r\\nrrow[DB_serial]);\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nASN1_UTCTIME_free(a_tm);\\r\\nOPENSSL_free(a_tm_s);\\r\\nreturn (cnt);\\r\\n}\\r\\nchar *make_revocation_str(int rev_type, char *rev_arg)\\r\\n{\\r\\nchar *other = NULL, *str;\\r\\nconst char *reason = NULL;\\r\\nASN1_OBJECT *otmp;\\r\\nASN1_UTCTIME *revtm = NULL;\\r\\nint i;\\r\\nswitch (rev_type)\\r\\n{\\r\\ncase REV_NONE:\\r\\nbreak;\\r\\ncase REV_CRL_REASON:\\r\\nfor (i = 0; i < 8; i++)\\r\\n{\\r\\nif (!strcasecmp(rev_arg, crl_reasons[i]))\\r\\n{\\r\\nreason = crl_reasons[i];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (reason == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"Unknown CRL reason %s\\n\", rev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\ncase REV_HOLD:\\r\\notmp = OBJ_txt2obj(rev_arg, 0);\\r\\nASN1_OBJECT_free(otmp);\\r\\nif (otmp == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"Invalid object identifier %s\\n\", rev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nreason = \"holdInstruction\";\\r\\nother = rev_arg;\\r\\nbreak;\\r\\ncase REV_KEY_COMPROMISE:\\r\\ncase REV_CA_COMPROMISE:\\r\\nif (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg))\\r\\n{\\r\\nBIO_printf(bio_err, \"Invalid time format %s. Need YYYYMMDDHHMMSSZ\\n\", rev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nother = rev_arg;\\r\\nif (rev_type == REV_KEY_COMPROMISE)\\r\\nreason = \"keyTime\";\\r\\nelse\\r\\nreason = \"CAkeyTime\";\\r\\nbreak;\\r\\n}\\r\\nrevtm = X509_gmtime_adj(NULL, 0);\\r\\ni = revtm->length + 1;\\r\\nif (reason) i += strlen(reason) + 1;\\r\\nif (other) i += strlen(other) + 1;\\r\\nstr = OPENSSL_malloc(i);\\r\\nif (!str) return NULL;\\r\\nBUF_strlcpy(str, (char *)revtm->data, i);\\r\\nif (reason)\\r\\n{\\r\\nBUF_strlcat(str, \",\", i);\\r\\nBUF_strlcat(str, reason, i);\\r\\n}\\r\\nif (other)\\r\\n{\\r\\nBUF_strlcat(str, \",\", i);\\r\\nBUF_strlcat(str, other, i);\\r\\n}\\r\\nASN1_UTCTIME_free(revtm);\\r\\nreturn str;\\r\\n}\\r\\nint make_revoked(X509_REVOKED *rev, const char *str)\\r\\n{\\r\\nchar *tmp = NULL;\\r\\nint reason_code = -1;\\r\\nint i, ret = 0;\\r\\nASN1_OBJECT *hold = NULL;\\r\\nASN1_GENERALIZEDTIME *comp_time = NULL;\\r\\nASN1_ENUMERATED *rtmp = NULL;\\r\\nASN1_TIME *revDate = NULL;\\r\\ni = unpack_revinfo(&revDate, &reason_code, &hold, &comp_time, str);\\r\\nif (i == 0)\\r\\ngoto err;\\r\\nif (rev && !X509_REVOKED_set_revocationDate(rev, revDate))\\r\\ngoto err;\\r\\nif (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS))\\r\\n{\\r\\nrtmp = ASN1_ENUMERATED_new();\\r\\nif (!rtmp || !ASN1_ENUMERATED_set(rtmp, reason_code))\\r\\ngoto err;\\r\\nif (!X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rtmp, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (rev && comp_time)\\r\\n{\\r\\nif (!X509_REVOKED_add1_ext_i2d(rev, NID_invalidity_date, comp_time, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (rev && hold)\\r\\n{\\r\\nif (!X509_REVOKED_add1_ext_i2d(rev, NID_hold_instruction_code, hold, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)\\r\\nret = 2;\\r\\nelse ret = 1;\\r\\nerr:\\r\\nif (tmp) OPENSSL_free(tmp);\\r\\nASN1_OBJECT_free(hold);\\r\\nASN1_GENERALIZEDTIME_free(comp_time);\\r\\nASN1_ENUMERATED_free(rtmp);\\r\\nASN1_TIME_free(revDate);\\r\\nreturn ret;\\r\\n}\\r\\nint old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str)\\r\\n{\\r\\nchar buf[25],*pbuf, *p;\\r\\nint j;\\r\\nj=i2a_ASN1_OBJECT(bp,obj);\\r\\npbuf=buf;\\r\\nfor (j=22-j; j>0; j--)\\r\\n*(pbuf++)=' ';\\r\\n*(pbuf++)=':';\\r\\n*(pbuf++)='\\0';\\r\\nBIO_puts(bp,buf);\\r\\nif (str->type == V_ASN1_PRINTABLESTRING)\\r\\nBIO_printf(bp,\"PRINTABLE:'\");\\r\\nelse if (str->type == V_ASN1_T61STRING)\\r\\nBIO_printf(bp,\"T61STRING:'\");\\r\\nelse if (str->type == V_ASN1_IA5STRING)\\r\\nBIO_printf(bp,\"IA5STRING:'\");\\r\\nelse if (str->type == V_ASN1_UNIVERSALSTRING)\\r\\nBIO_printf(bp,\"UNIVERSALSTRING:'\");\\r\\nelse\\r\\nBIO_printf(bp,\"ASN.1 %2d:'\",str->type);\\r\\np=(char *)str->data;\\r\\nfor (j=str->length; j>0; j--)\\r\\n{\\r\\nif ((*p >= ' ') && (*p <= '~'))\\r\\nBIO_printf(bp,\"%c\",*p);\\r\\nelse if (*p & 0x80)\\r\\nBIO_printf(bp,\"\\\\0x%02X\",*p);\\r\\nelse if ((unsigned char)*p == 0xf7)\\r\\nBIO_printf(bp,\"^?\");\\r\\nelse BIO_printf(bp,\"^%c\",*p+'@');\\r\\np++;\\r\\n}\\r\\nBIO_printf(bp,\"'\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold, ASN1_GENERALIZEDTIME **pinvtm, const char *str)\\r\\n{\\r\\nchar *tmp = NULL;\\r\\nchar *rtime_str, *reason_str = NULL, *arg_str = NULL, *p;\\r\\nint reason_code = -1;\\r\\nint ret = 0;\\r\\nunsigned int i;\\r\\nASN1_OBJECT *hold = NULL;\\r\\nASN1_GENERALIZEDTIME *comp_time = NULL;\\r\\ntmp = BUF_strdup(str);\\r\\np = strchr(tmp, ',');\\r\\nrtime_str = tmp;\\r\\nif (p)\\r\\n{\\r\\n*p = '\\0';\\r\\np++;\\r\\nreason_str = p;\\r\\np = strchr(p, ',');\\r\\nif (p)\\r\\n{\\r\\n*p = '\\0';\\r\\narg_str = p + 1;\\r\\n}\\r\\n}\\r\\nif (prevtm)\\r\\n{\\r\\n*prevtm = ASN1_UTCTIME_new();\\r\\nif (!ASN1_UTCTIME_set_string(*prevtm, rtime_str))\\r\\n{\\r\\nBIO_printf(bio_err, \"invalid revocation date %s\\n\", rtime_str);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (reason_str)\\r\\n{\\r\\nfor (i = 0; i < NUM_REASONS; i++)\\r\\n{\\r\\nif(!strcasecmp(reason_str, crl_reasons[i]))\\r\\n{\\r\\nreason_code = i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (reason_code == OCSP_REVOKED_STATUS_NOSTATUS)\\r\\n{\\r\\nBIO_printf(bio_err, \"invalid reason code %s\\n\", reason_str);\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code == 7)\\r\\nreason_code = OCSP_REVOKED_STATUS_REMOVEFROMCRL;\\r\\nelse if (reason_code == 8)\\r\\n{\\r\\nif (!arg_str)\\r\\n{\\r\\nBIO_printf(bio_err, \"missing hold instruction\\n\");\\r\\ngoto err;\\r\\n}\\r\\nreason_code = OCSP_REVOKED_STATUS_CERTIFICATEHOLD;\\r\\nhold = OBJ_txt2obj(arg_str, 0);\\r\\nif (!hold)\\r\\n{\\r\\nBIO_printf(bio_err, \"invalid object identifier %s\\n\", arg_str);\\r\\ngoto err;\\r\\n}\\r\\nif (phold) *phold = hold;\\r\\n}\\r\\nelse if ((reason_code == 9) || (reason_code == 10))\\r\\n{\\r\\nif (!arg_str)\\r\\n{\\r\\nBIO_printf(bio_err, \"missing compromised time\\n\");\\r\\ngoto err;\\r\\n}\\r\\ncomp_time = ASN1_GENERALIZEDTIME_new();\\r\\nif (!ASN1_GENERALIZEDTIME_set_string(comp_time, arg_str))\\r\\n{\\r\\nBIO_printf(bio_err, \"invalid compromised time %s\\n\", arg_str);\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code == 9)\\r\\nreason_code = OCSP_REVOKED_STATUS_KEYCOMPROMISE;\\r\\nelse\\r\\nreason_code = OCSP_REVOKED_STATUS_CACOMPROMISE;\\r\\n}\\r\\n}\\r\\nif (preason) *preason = reason_code;\\r\\nif (pinvtm) *pinvtm = comp_time;\\r\\nelse ASN1_GENERALIZEDTIME_free(comp_time);\\r\\nret = 1;\\r\\nerr:\\r\\nif (tmp) OPENSSL_free(tmp);\\r\\nif (!phold) ASN1_OBJECT_free(hold);\\r\\nif (!pinvtm) ASN1_GENERALIZEDTIME_free(comp_time);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn_moid_c", "target": 0, "func": "static int oid_module_init(CONF_IMODULE *md, const CONF *cnf)\\r\\n{\\r\\nint i;\\r\\nconst char *oid_section;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *oval;\\r\\noid_section = CONF_imodule_get_value(md);\\r\\nif(!(sktmp = NCONF_get_section(cnf, oid_section)))\\r\\n{\\r\\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ERROR_LOADING_SECTION);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(sktmp); i++)\\r\\n{\\r\\noval = sk_CONF_VALUE_value(sktmp, i);\\r\\nif(!do_create(oval->value, oval->name))\\r\\n{\\r\\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ADDING_OBJECT);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void oid_module_finish(CONF_IMODULE *md)\\r\\n{\\r\\nOBJ_cleanup();\\r\\n}\\r\\nvoid ASN1_add_oid_module(void)\\r\\n{\\r\\nCONF_module_add(\"oid_section\", oid_module_init, oid_module_finish);\\r\\n}\\r\\nstatic int do_create(char *value, char *name)\\r\\n{\\r\\nint nid;\\r\\nASN1_OBJECT *oid;\\r\\nchar *ln, *ostr, *p, *lntmp;\\r\\np = strrchr(value, ',');\\r\\nif (!p)\\r\\n{\\r\\nln = name;\\r\\nostr = value;\\r\\n}\\r\\nelse\\r\\n{\\r\\nln = NULL;\\r\\nostr = p + 1;\\r\\nif (!*ostr)\\r\\nreturn 0;\\r\\nwhile(isspace((unsigned char)*ostr)) ostr++;\\r\\n}\\r\\nnid = OBJ_create(ostr, name, ln);\\r\\nif (nid == NID_undef)\\r\\nreturn 0;\\r\\nif (p)\\r\\n{\\r\\nln = value;\\r\\nwhile(isspace((unsigned char)*ln)) ln++;\\r\\np--;\\r\\nwhile(isspace((unsigned char)*p))\\r\\n{\\r\\nif (p == ln)\\r\\nreturn 0;\\r\\np--;\\r\\n}\\r\\np++;\\r\\nlntmp = OPENSSL_malloc((p - ln) + 1);\\r\\nif (lntmp == NULL)\\r\\nreturn 0;\\r\\nmemcpy(lntmp, ln, p - ln);\\r\\nlntmp[p - ln + 1] = 0;\\r\\noid = OBJ_nid2obj(nid);\\r\\noid->ln = lntmp;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_conn_c", "target": 0, "func": "static int conn_state(BIO *b, BIO_CONNECT *c)\\r\\n{\\r\\nint ret= -1,i;\\r\\nunsigned long l;\\r\\nchar *p,*q;\\r\\nint (*cb)(const BIO *,int,int)=NULL;\\r\\nif (c->info_callback != NULL)\\r\\ncb=c->info_callback;\\r\\nfor (;;)\\r\\n{\\r\\nswitch (c->state)\\r\\n{\\r\\ncase BIO_CONN_S_BEFORE:\\r\\np=c->param_hostname;\\r\\nif (p == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_HOSTNAME_SPECIFIED);\\r\\ngoto exit_loop;\\r\\n}\\r\\nfor ( ; *p != '\\0'; p++)\\r\\n{\\r\\nif ((*p == ':') || (*p == '/')) break;\\r\\n}\\r\\ni= *p;\\r\\nif ((i == ':') || (i == '/'))\\r\\n{\\r\\n*(p++)='\\0';\\r\\nif (i == ':')\\r\\n{\\r\\nfor (q=p; *q; q++)\\r\\nif (*q == '/')\\r\\n{\\r\\n*q='\\0';\\r\\nbreak;\\r\\n}\\r\\nif (c->param_port != NULL)\\r\\nOPENSSL_free(c->param_port);\\r\\nc->param_port=BUF_strdup(p);\\r\\n}\\r\\n}\\r\\nif (c->param_port == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_PORT_SPECIFIED);\\r\\nERR_add_error_data(2,\"host=\",c->param_hostname);\\r\\ngoto exit_loop;\\r\\n}\\r\\nc->state=BIO_CONN_S_GET_IP;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_IP:\\r\\nif (BIO_get_host_ip(c->param_hostname,&(c->ip[0])) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state=BIO_CONN_S_GET_PORT;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_PORT:\\r\\nif (c->param_port == NULL)\\r\\n{\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse if (BIO_get_port(c->param_port,&c->port) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state=BIO_CONN_S_CREATE_SOCKET;\\r\\nbreak;\\r\\ncase BIO_CONN_S_CREATE_SOCKET:\\r\\nmemset((char *)&c->them,0,sizeof(c->them));\\r\\nc->them.sin_family=AF_INET;\\r\\nc->them.sin_port=htons((unsigned short)c->port);\\r\\nl=(unsigned long)\\r\\n((unsigned long)c->ip[0]<<24L)|\\r\\n((unsigned long)c->ip[1]<<16L)|\\r\\n((unsigned long)c->ip[2]<< 8L)|\\r\\n((unsigned long)c->ip[3]);\\r\\nc->them.sin_addr.s_addr=htonl(l);\\r\\nc->state=BIO_CONN_S_CREATE_SOCKET;\\r\\nret=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",c->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto exit_loop;\\r\\n}\\r\\nb->num=ret;\\r\\nc->state=BIO_CONN_S_NBIO;\\r\\nbreak;\\r\\ncase BIO_CONN_S_NBIO:\\r\\nif (c->nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(b->num,1))\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_ERROR_SETTING_NBIO);\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\ngoto exit_loop;\\r\\n}\\r\\n}\\r\\nc->state=BIO_CONN_S_CONNECT;\\r\\n#if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)\\r\\ni=1;\\r\\ni=setsockopt(b->num,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\\r\\nif (i < 0)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",c->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_KEEPALIVE);\\r\\ngoto exit_loop;\\r\\n}\\r\\n#endif\\r\\nbreak;\\r\\ncase BIO_CONN_S_CONNECT:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=connect(b->num,\\r\\n(struct sockaddr *)&c->them,\\r\\nsizeof(c->them));\\r\\nb->retry_reason=0;\\r\\nif (ret < 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\n{\\r\\nBIO_set_retry_special(b);\\r\\nc->state=BIO_CONN_S_BLOCKED_CONNECT;\\r\\nb->retry_reason=BIO_RR_CONNECT;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSYSerr(SYS_F_CONNECT,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_CONNECT_ERROR);\\r\\n}\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse\\r\\nc->state=BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_BLOCKED_CONNECT:\\r\\ni=BIO_sock_error(b->num);\\r\\nif (i)\\r\\n{\\r\\nBIO_clear_retry_flags(b);\\r\\nSYSerr(SYS_F_CONNECT,i);\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NBIO_CONNECT_ERROR);\\r\\nret=0;\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse\\r\\nc->state=BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_OK:\\r\\nret=1;\\r\\ngoto exit_loop;\\r\\ndefault:\\r\\ngoto exit_loop;\\r\\n}\\r\\nif (cb != NULL)\\r\\n{\\r\\nif (!(ret=cb((BIO *)b,c->state,ret)))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nexit_loop:\\r\\nif (cb != NULL)\\r\\nret=cb((BIO *)b,c->state,ret);\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nBIO_CONNECT *BIO_CONNECT_new(void)\\r\\n{\\r\\nBIO_CONNECT *ret;\\r\\nif ((ret=(BIO_CONNECT *)OPENSSL_malloc(sizeof(BIO_CONNECT))) == NULL)\\r\\nreturn(NULL);\\r\\nret->state=BIO_CONN_S_BEFORE;\\r\\nret->param_hostname=NULL;\\r\\nret->param_port=NULL;\\r\\nret->info_callback=NULL;\\r\\nret->nbio=0;\\r\\nret->ip[0]=0;\\r\\nret->ip[1]=0;\\r\\nret->ip[2]=0;\\r\\nret->ip[3]=0;\\r\\nret->port=0;\\r\\nmemset((char *)&ret->them,0,sizeof(ret->them));\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_CONNECT_free(BIO_CONNECT *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->param_hostname != NULL)\\r\\nOPENSSL_free(a->param_hostname);\\r\\nif (a->param_port != NULL)\\r\\nOPENSSL_free(a->param_port);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nBIO_METHOD *BIO_s_connect(void)\\r\\n{\\r\\nreturn(&methods_connectp);\\r\\n}\\r\\nstatic int conn_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=INVALID_SOCKET;\\r\\nbi->flags=0;\\r\\nif ((bi->ptr=(char *)BIO_CONNECT_new()) == NULL)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nstatic void conn_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_CONNECT *c;\\r\\nc=(BIO_CONNECT *)bio->ptr;\\r\\nif (bio->num != INVALID_SOCKET)\\r\\n{\\r\\nif (c->state == BIO_CONN_S_OK)\\r\\nshutdown(bio->num,2);\\r\\nclosesocket(bio->num);\\r\\nbio->num=INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int conn_free(BIO *a)\\r\\n{\\r\\nBIO_CONNECT *data;\\r\\nif (a == NULL) return(0);\\r\\ndata=(BIO_CONNECT *)a->ptr;\\r\\nif (a->shutdown)\\r\\n{\\r\\nconn_close_socket(a);\\r\\nBIO_CONNECT_free(data);\\r\\na->ptr=NULL;\\r\\na->flags=0;\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int conn_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK)\\r\\n{\\r\\nret=conn_state(b,data);\\r\\nif (ret <= 0)\\r\\nreturn(ret);\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nclear_socket_error();\\r\\nret=readsocket(b->num,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int conn_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK)\\r\\n{\\r\\nret=conn_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nclear_socket_error();\\r\\nret=writesocket(b->num,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long conn_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nint *ip;\\r\\nconst char **pptr;\\r\\nlong ret=1;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nret=0;\\r\\ndata->state=BIO_CONN_S_BEFORE;\\r\\nconn_close_socket(b);\\r\\nb->flags=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (!(data->state != BIO_CONN_S_OK))\\r\\nret=(long)conn_state(b,data);\\r\\nelse\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_CONNECT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(const char **)ptr;\\r\\nif (num == 0)\\r\\n{\\r\\n*pptr=data->param_hostname;\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\n*pptr=data->param_port;\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\n*pptr= (char *)&(data->ip[0]);\\r\\n}\\r\\nelse if (num == 3)\\r\\n{\\r\\n*((int *)ptr)=data->port;\\r\\n}\\r\\nif ((!b->init) || (ptr == NULL))\\r\\n*pptr=\"not initialized\";\\r\\nret=1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_CONNECT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nb->init=1;\\r\\nif (num == 0)\\r\\n{\\r\\nif (data->param_hostname != NULL)\\r\\nOPENSSL_free(data->param_hostname);\\r\\ndata->param_hostname=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\nif (data->param_port != NULL)\\r\\nOPENSSL_free(data->param_port);\\r\\ndata->param_port=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\nchar buf[16];\\r\\nunsigned char *p = ptr;\\r\\nBIO_snprintf(buf,sizeof buf,\"%d.%d.%d.%d\",\\r\\np[0],p[1],p[2],p[3]);\\r\\nif (data->param_hostname != NULL)\\r\\nOPENSSL_free(data->param_hostname);\\r\\ndata->param_hostname=BUF_strdup(buf);\\r\\nmemcpy(&(data->ip[0]),ptr,4);\\r\\n}\\r\\nelse if (num == 3)\\r\\n{\\r\\nchar buf[DECIMAL_SIZE(int)+1];\\r\\nBIO_snprintf(buf,sizeof buf,\"%d\",*(int *)ptr);\\r\\nif (data->param_port != NULL)\\r\\nOPENSSL_free(data->param_port);\\r\\ndata->param_port=BUF_strdup(buf);\\r\\ndata->port= *(int *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip=b->num;\\r\\nret=b->num;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\n{\\r\\ndbio=(BIO *)ptr;\\r\\nif (data->param_port)\\r\\nBIO_set_conn_port(dbio,data->param_port);\\r\\nif (data->param_hostname)\\r\\nBIO_set_conn_hostname(dbio,data->param_hostname);\\r\\nBIO_set_nbio(dbio,data->nbio);\\r\\n(void)BIO_set_info_callback(dbio,(bio_info_cb *)data->info_callback);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\n#if 0\\r\\nBIOerr(BIO_F_CONN_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nret = -1;\\r\\n#else\\r\\nret=0;\\r\\n#endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nint (**fptr)(const BIO *bio,int state,int xret);\\r\\nfptr=(int (**)(const BIO *bio,int state,int xret))ptr;\\r\\n*fptr=data->info_callback;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long conn_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\ndata->info_callback=(int (*)(const struct bio_st *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int conn_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=conn_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_connect(char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_connect());\\r\\nif (ret == NULL) return(NULL);\\r\\nif (BIO_set_conn_hostname(ret,str))\\r\\nreturn(ret);\\r\\nelse\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pk7_doit_c", "target": 0, "func": "static int PKCS7_type_is_other(PKCS7* p7)\\r\\n{\\r\\nint isOther=1;\\r\\nint nid=OBJ_obj2nid(p7->type);\\r\\nswitch( nid )\\r\\n{\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_signed:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncase NID_pkcs7_digest:\\r\\ncase NID_pkcs7_encrypted:\\r\\nisOther=0;\\r\\nbreak;\\r\\ndefault:\\r\\nisOther=1;\\r\\n}\\r\\nreturn isOther;\\r\\n}\\r\\nstatic ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7)\\r\\n{\\r\\nif ( PKCS7_type_is_data(p7))\\r\\nreturn p7->d.data;\\r\\nif ( PKCS7_type_is_other(p7) && p7->d.other\\r\\n&& (p7->d.other->type == V_ASN1_OCTET_STRING))\\r\\nreturn p7->d.other->value.octet_string;\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)\\r\\n{\\r\\nBIO *btmp;\\r\\nconst EVP_MD *md;\\r\\nif ((btmp=BIO_new(BIO_f_md())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nmd=EVP_get_digestbyobj(alg->algorithm);\\r\\nif (md == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,PKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp,md);\\r\\nif (*pbio == NULL)\\r\\n*pbio=btmp;\\r\\nelse if (!BIO_push(*pbio,btmp))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbtmp=NULL;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (btmp)\\r\\nBIO_free(btmp);\\r\\nreturn 0;\\r\\n}\\r\\nBIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint i;\\r\\nBIO *out=NULL,*btmp=NULL;\\r\\nX509_ALGOR *xa = NULL;\\r\\nconst EVP_CIPHER *evp_cipher=NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk=NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\\r\\nX509_ALGOR *xalg=NULL;\\r\\nPKCS7_RECIP_INFO *ri=NULL;\\r\\nEVP_PKEY *pkey;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nmd_sk=p7->d.sign->md_algs;\\r\\nos = PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk=p7->d.signed_and_enveloped->md_algs;\\r\\nxalg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher=p7->d.signed_and_enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,\\r\\nPKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk=p7->d.enveloped->recipientinfo;\\r\\nxalg=p7->d.enveloped->enc_data->algorithm;\\r\\nevp_cipher=p7->d.enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,\\r\\nPKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nxa = p7->d.digest->md;\\r\\nos = PKCS7_get_octet_string(p7->d.digest->contents);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\nif (!PKCS7_bio_add_digest(&out, sk_X509_ALGOR_value(md_sk, i)))\\r\\ngoto err;\\r\\nif (xa && !PKCS7_bio_add_digest(&out, xa))\\r\\ngoto err;\\r\\nif (evp_cipher != NULL)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nint keylen,ivlen;\\r\\nint jj,max;\\r\\nunsigned char *tmp;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nif ((btmp=BIO_new(BIO_f_cipher())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_cipher_ctx(btmp, &ctx);\\r\\nkeylen=EVP_CIPHER_key_length(evp_cipher);\\r\\nivlen=EVP_CIPHER_iv_length(evp_cipher);\\r\\nxalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));\\r\\nif (ivlen > 0) RAND_pseudo_bytes(iv,ivlen);\\r\\nif (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1)<=0)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) <= 0)\\r\\ngoto err;\\r\\nif (ivlen > 0) {\\r\\nif (xalg->parameter == NULL)\\r\\nxalg->parameter=ASN1_TYPE_new();\\r\\nif(EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)\\r\\ngoto err;\\r\\n}\\r\\nmax=0;\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)\\r\\n{\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\nif (ri->cert == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_MISSING_CERIPEND_INFO);\\r\\ngoto err;\\r\\n}\\r\\npkey=X509_get_pubkey(ri->cert);\\r\\njj=EVP_PKEY_size(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (max < jj) max=jj;\\r\\n}\\r\\nif ((tmp=(unsigned char *)OPENSSL_malloc(max)) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)\\r\\n{\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\npkey=X509_get_pubkey(ri->cert);\\r\\njj=EVP_PKEY_encrypt(tmp,key,keylen,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (jj <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_EVP_LIB);\\r\\nOPENSSL_free(tmp);\\r\\ngoto err;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(ri->enc_key,tmp,jj))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(tmp);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(tmp);\\r\\nOPENSSL_cleanse(key, keylen);\\r\\nif (out == NULL)\\r\\nout=btmp;\\r\\nelse\\r\\nBIO_push(out,btmp);\\r\\nbtmp=NULL;\\r\\n}\\r\\nif (bio == NULL)\\r\\n{\\r\\nif (PKCS7_is_detached(p7))\\r\\nbio=BIO_new(BIO_s_null());\\r\\nelse if (os && os->length > 0)\\r\\nbio = BIO_new_mem_buf(os->data, os->length);\\r\\nif(bio == NULL)\\r\\n{\\r\\nbio=BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio,0);\\r\\n}\\r\\n}\\r\\nBIO_push(out,bio);\\r\\nbio=NULL;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (btmp != NULL)\\r\\nBIO_free_all(btmp);\\r\\nout=NULL;\\r\\n}\\r\\nreturn(out);\\r\\n}\\r\\nBIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\\r\\n{\\r\\nint i,j;\\r\\nBIO *out=NULL,*btmp=NULL,*etmp=NULL,*bio=NULL;\\r\\nunsigned char *tmp=NULL;\\r\\nX509_ALGOR *xa;\\r\\nASN1_OCTET_STRING *data_body=NULL;\\r\\nconst EVP_MD *evp_md;\\r\\nconst EVP_CIPHER *evp_cipher=NULL;\\r\\nEVP_CIPHER_CTX *evp_ctx=NULL;\\r\\nX509_ALGOR *enc_alg=NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk=NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\\r\\nX509_ALGOR *xalg=NULL;\\r\\nPKCS7_RECIP_INFO *ri=NULL;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\ndata_body=PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nmd_sk=p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk=p7->d.signed_and_enveloped->md_algs;\\r\\ndata_body=p7->d.signed_and_enveloped->enc_data->enc_data;\\r\\nenc_alg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nxalg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk=p7->d.enveloped->recipientinfo;\\r\\nenc_alg=p7->d.enveloped->enc_data->algorithm;\\r\\ndata_body=p7->d.enveloped->enc_data->enc_data;\\r\\nevp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nxalg=p7->d.enveloped->enc_data->algorithm;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (md_sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\n{\\r\\nxa=sk_X509_ALGOR_value(md_sk,i);\\r\\nif ((btmp=BIO_new(BIO_f_md())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nj=OBJ_obj2nid(xa->algorithm);\\r\\nevp_md=EVP_get_digestbynid(j);\\r\\nif (evp_md == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp,evp_md);\\r\\nif (out == NULL)\\r\\nout=btmp;\\r\\nelse\\r\\nBIO_push(out,btmp);\\r\\nbtmp=NULL;\\r\\n}\\r\\n}\\r\\nif (evp_cipher != NULL)\\r\\n{\\r\\n#if 0\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *p;\\r\\nint keylen,ivlen;\\r\\nint max;\\r\\nX509_OBJECT ret;\\r\\n#endif\\r\\nint jj;\\r\\nif ((etmp=BIO_new(BIO_f_cipher())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\nif(!X509_NAME_cmp(ri->issuer_and_serial->issuer,\\r\\npcert->cert_info->issuer) &&\\r\\n!M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,\\r\\nri->issuer_and_serial->serial)) break;\\r\\nri=NULL;\\r\\n}\\r\\nif (ri == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\njj=EVP_PKEY_size(pkey);\\r\\ntmp=(unsigned char *)OPENSSL_malloc(jj+10);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\njj=EVP_PKEY_decrypt(tmp, M_ASN1_STRING_data(ri->enc_key),\\r\\nM_ASN1_STRING_length(ri->enc_key), pkey);\\r\\nif (jj <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nevp_ctx=NULL;\\r\\nBIO_get_cipher_ctx(etmp,&evp_ctx);\\r\\nif (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)\\r\\ngoto err;\\r\\nif (jj != EVP_CIPHER_CTX_key_length(evp_ctx)) {\\r\\nif(!EVP_CIPHER_CTX_set_key_length(evp_ctx, jj))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0) <= 0)\\r\\ngoto err;\\r\\nOPENSSL_cleanse(tmp,jj);\\r\\nif (out == NULL)\\r\\nout=etmp;\\r\\nelse\\r\\nBIO_push(out,etmp);\\r\\netmp=NULL;\\r\\n}\\r\\n#if 1\\r\\nif (PKCS7_is_detached(p7) || (in_bio != NULL))\\r\\n{\\r\\nbio=in_bio;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if 0\\r\\nbio=BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio,0);\\r\\nif (data_body->length > 0)\\r\\nBIO_write(bio,(char *)data_body->data,data_body->length);\\r\\n#else\\r\\nif (data_body->length > 0)\\r\\nbio = BIO_new_mem_buf(data_body->data,data_body->length);\\r\\nelse {\\r\\nbio=BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio,0);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nBIO_push(out,bio);\\r\\nbio=NULL;\\r\\n#endif\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (btmp != NULL) BIO_free_all(btmp);\\r\\nif (etmp != NULL) BIO_free_all(etmp);\\r\\nif (bio != NULL) BIO_free_all(bio);\\r\\nout=NULL;\\r\\n}\\r\\nif (tmp != NULL)\\r\\nOPENSSL_free(tmp);\\r\\nreturn(out);\\r\\n}\\r\\nstatic BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nbio=BIO_find_type(bio,BIO_TYPE_MD);\\r\\nif (bio == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_get_md_ctx(bio,pmd);\\r\\nif (*pmd == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (EVP_MD_CTX_type(*pmd) == nid)\\r\\nreturn bio;\\r\\nbio=BIO_next(bio);\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nint PKCS7_dataFinal(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j;\\r\\nBIO *btmp;\\r\\nBUF_MEM *buf_mem=NULL;\\r\\nBUF_MEM *buf=NULL;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nEVP_MD_CTX *mdc,ctx_tmp;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *si_sk=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nEVP_MD_CTX_init(&ctx_tmp);\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsi_sk=p7->d.signed_and_enveloped->signer_info;\\r\\nif (!(os=M_ASN1_OCTET_STRING_new()))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np7->d.signed_and_enveloped->enc_data->enc_data=os;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nif (!(os=M_ASN1_OCTET_STRING_new()))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np7->d.enveloped->enc_data->enc_data=os;\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nsi_sk=p7->d.sign->signer_info;\\r\\nos=PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nif(PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\np7->d.sign->contents->d.data = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nos=PKCS7_get_octet_string(p7->d.digest->contents);\\r\\nif(PKCS7_type_is_data(p7->d.digest->contents) && p7->detached)\\r\\n{\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\np7->d.digest->contents->d.data = NULL;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (si_sk != NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_SIGNER_INFO_num(si_sk); i++)\\r\\n{\\r\\nsi=sk_PKCS7_SIGNER_INFO_value(si_sk,i);\\r\\nif (si->pkey == NULL) continue;\\r\\nj=OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp=bio;\\r\\nbtmp = PKCS7_find_digest(&mdc, btmp, j);\\r\\nif (btmp == NULL)\\r\\ngoto err;\\r\\nEVP_MD_CTX_copy_ex(&ctx_tmp,mdc);\\r\\nif (!BUF_MEM_grow_clean(buf,EVP_PKEY_size(si->pkey)))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nsk=si->auth_attr;\\r\\nif ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))\\r\\n{\\r\\nunsigned char md_data[EVP_MAX_MD_SIZE], *abuf=NULL;\\r\\nunsigned int md_len, alen;\\r\\nASN1_OCTET_STRING *digest;\\r\\nASN1_UTCTIME *sign_time;\\r\\nconst EVP_MD *md_tmp;\\r\\nif (!PKCS7_get_signed_attribute(si,\\r\\nNID_pkcs9_signingTime))\\r\\n{\\r\\nif (!(sign_time=X509_gmtime_adj(NULL,0)))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nPKCS7_add_signed_attribute(si,\\r\\nNID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,sign_time);\\r\\n}\\r\\nmd_tmp=EVP_MD_CTX_md(&ctx_tmp);\\r\\nEVP_DigestFinal_ex(&ctx_tmp,md_data,&md_len);\\r\\nif (!(digest=M_ASN1_OCTET_STRING_new()))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(digest,md_data,\\r\\nmd_len))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nPKCS7_add_signed_attribute(si,\\r\\nNID_pkcs9_messageDigest,\\r\\nV_ASN1_OCTET_STRING,digest);\\r\\nEVP_SignInit_ex(&ctx_tmp,md_tmp,NULL);\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)sk,&abuf,\\r\\nASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\\r\\nif(!abuf) goto err;\\r\\nEVP_SignUpdate(&ctx_tmp,abuf,alen);\\r\\nOPENSSL_free(abuf);\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (si->pkey->type == EVP_PKEY_DSA)\\r\\nctx_tmp.digest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (si->pkey->type == EVP_PKEY_EC)\\r\\nctx_tmp.digest=EVP_ecdsa();\\r\\n#endif\\r\\nif (!EVP_SignFinal(&ctx_tmp,(unsigned char *)buf->data,\\r\\n(unsigned int *)&buf->length,si->pkey))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_STRING_set(si->enc_digest,\\r\\n(unsigned char *)buf->data,buf->length))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse if (i == NID_pkcs7_digest)\\r\\n{\\r\\nunsigned char md_data[EVP_MAX_MD_SIZE];\\r\\nunsigned int md_len;\\r\\nif (!PKCS7_find_digest(&mdc, bio,\\r\\nOBJ_obj2nid(p7->d.digest->md->algorithm)))\\r\\ngoto err;\\r\\nEVP_DigestFinal_ex(mdc,md_data,&md_len);\\r\\nM_ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data, md_len);\\r\\n}\\r\\nif (!PKCS7_is_detached(p7))\\r\\n{\\r\\nbtmp=BIO_find_type(bio,BIO_TYPE_MEM);\\r\\nif (btmp == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_mem_ptr(btmp,&buf_mem);\\r\\nBIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);\\r\\nBIO_set_mem_eof_return(btmp, 0);\\r\\nos->data = (unsigned char *)buf_mem->data;\\r\\nos->length = buf_mem->length;\\r\\n#if 0\\r\\nM_ASN1_OCTET_STRING_set(os,\\r\\n(unsigned char *)buf_mem->data,buf_mem->length);\\r\\n#endif\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx_tmp);\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nint PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,\\r\\nPKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nPKCS7_ISSUER_AND_SERIAL *ias;\\r\\nint ret=0,i;\\r\\nSTACK_OF(X509) *cert;\\r\\nX509 *x509;\\r\\nif (PKCS7_type_is_signed(p7))\\r\\n{\\r\\ncert=p7->d.sign->cert;\\r\\n}\\r\\nelse if (PKCS7_type_is_signedAndEnveloped(p7))\\r\\n{\\r\\ncert=p7->d.signed_and_enveloped->cert;\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nias=si->issuer_and_serial;\\r\\nx509=X509_find_by_issuer_and_serial(cert,ias->issuer,ias->serial);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nif(!X509_STORE_CTX_init(ctx,cert_store,x509,cert))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);\\r\\ni=X509_verify_cert(ctx);\\r\\nif (i <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\nreturn PKCS7_signatureVerify(bio, p7, si, x509);\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\\r\\nX509 *x509)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nEVP_MD_CTX mdc_tmp,*mdc;\\r\\nint ret=0,i;\\r\\nint md_type;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nBIO *btmp;\\r\\nEVP_PKEY *pkey;\\r\\nEVP_MD_CTX_init(&mdc_tmp);\\r\\nif (!PKCS7_type_is_signed(p7) &&\\r\\n!PKCS7_type_is_signedAndEnveloped(p7)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nmd_type=OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp=bio;\\r\\nfor (;;)\\r\\n{\\r\\nif ((btmp == NULL) ||\\r\\n((btmp=BIO_find_type(btmp,BIO_TYPE_MD)) == NULL))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_md_ctx(btmp,&mdc);\\r\\nif (mdc == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_MD_CTX_type(mdc) == md_type)\\r\\nbreak;\\r\\nif (EVP_MD_pkey_type(EVP_MD_CTX_md(mdc)) == md_type)\\r\\nbreak;\\r\\nbtmp=BIO_next(btmp);\\r\\n}\\r\\nEVP_MD_CTX_copy_ex(&mdc_tmp,mdc);\\r\\nsk=si->auth_attr;\\r\\nif ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))\\r\\n{\\r\\nunsigned char md_dat[EVP_MAX_MD_SIZE], *abuf = NULL;\\r\\nunsigned int md_len, alen;\\r\\nASN1_OCTET_STRING *message_digest;\\r\\nEVP_DigestFinal_ex(&mdc_tmp,md_dat,&md_len);\\r\\nmessage_digest=PKCS7_digest_from_attributes(sk);\\r\\nif (!message_digest)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nif ((message_digest->length != (int)md_len) ||\\r\\n(memcmp(message_digest->data,md_dat,md_len)))\\r\\n{\\r\\n#if 0\\r\\n{\\r\\nint ii;\\r\\nfor (ii=0; ii<message_digest->length; ii++)\\r\\nprintf(\"%02X\",message_digest->data[ii]); printf(\" sent\\n\");\\r\\nfor (ii=0; ii<md_len; ii++) printf(\"%02X\",md_dat[ii]); printf(\" calc\\n\");\\r\\n}\\r\\n#endif\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_DIGEST_FAILURE);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nEVP_VerifyInit_ex(&mdc_tmp,EVP_get_digestbynid(md_type), NULL);\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,\\r\\nASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));\\r\\nEVP_VerifyUpdate(&mdc_tmp, abuf, alen);\\r\\nOPENSSL_free(abuf);\\r\\n}\\r\\nos=si->enc_digest;\\r\\npkey = X509_get_pubkey(x509);\\r\\nif (!pkey)\\r\\n{\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif(pkey->type == EVP_PKEY_DSA) mdc_tmp.digest=EVP_dss1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC) mdc_tmp.digest=EVP_ecdsa();\\r\\n#endif\\r\\ni=EVP_VerifyFinal(&mdc_tmp,os->data,os->length, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_SIGNATURE_FAILURE);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&mdc_tmp);\\r\\nreturn(ret);\\r\\n}\\r\\nPKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)\\r\\n{\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk;\\r\\nPKCS7_RECIP_INFO *ri;\\r\\nint i;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nif (i != NID_pkcs7_signedAndEnveloped) return(NULL);\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,0);\\r\\nif (sk_PKCS7_RECIP_INFO_num(rsk) <= idx) return(NULL);\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,idx);\\r\\nreturn(ri->issuer_and_serial);\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn(get_attribute(si->auth_attr,nid));\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn(get_attribute(si->unauth_attr,nid));\\r\\n}\\r\\nint PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn(add_attribute(&(p7si->auth_attr),nid,atrtype,value));\\r\\n}\\r\\nint PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn(add_attribute(&(p7si->unauth_attr),nid,atrtype,value));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_cache_c", "target": 0, "func": "static int policy_cache_create(X509 *x,\\r\\nCERTIFICATEPOLICIES *policies, int crit)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nX509_POLICY_CACHE *cache = x->policy_cache;\\r\\nX509_POLICY_DATA *data = NULL;\\r\\nPOLICYINFO *policy;\\r\\nif (sk_POLICYINFO_num(policies) == 0)\\r\\ngoto bad_policy;\\r\\ncache->data = sk_X509_POLICY_DATA_new(policy_data_cmp);\\r\\nif (!cache->data)\\r\\ngoto bad_policy;\\r\\nfor (i = 0; i < sk_POLICYINFO_num(policies); i++)\\r\\n{\\r\\npolicy = sk_POLICYINFO_value(policies, i);\\r\\ndata = policy_data_new(policy, NULL, crit);\\r\\nif (!data)\\r\\ngoto bad_policy;\\r\\nif (OBJ_obj2nid(data->valid_policy) == NID_any_policy)\\r\\n{\\r\\nif (cache->anyPolicy)\\r\\n{\\r\\nret = -1;\\r\\ngoto bad_policy;\\r\\n}\\r\\ncache->anyPolicy = data;\\r\\n}\\r\\nelse if (sk_X509_POLICY_DATA_find(cache->data, data) != -1)\\r\\n{\\r\\nret = -1;\\r\\ngoto bad_policy;\\r\\n}\\r\\nelse if (!sk_X509_POLICY_DATA_push(cache->data, data))\\r\\ngoto bad_policy;\\r\\ndata = NULL;\\r\\n}\\r\\nret = 1;\\r\\nbad_policy:\\r\\nif (ret == -1)\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\nif (data)\\r\\npolicy_data_free(data);\\r\\nsk_POLICYINFO_pop_free(policies, POLICYINFO_free);\\r\\nif (ret <= 0)\\r\\n{\\r\\nsk_X509_POLICY_DATA_pop_free(cache->data, policy_data_free);\\r\\ncache->data = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int policy_cache_new(X509 *x)\\r\\n{\\r\\nX509_POLICY_CACHE *cache;\\r\\nASN1_INTEGER *ext_any = NULL;\\r\\nPOLICY_CONSTRAINTS *ext_pcons = NULL;\\r\\nCERTIFICATEPOLICIES *ext_cpols = NULL;\\r\\nPOLICY_MAPPINGS *ext_pmaps = NULL;\\r\\nint i;\\r\\ncache = OPENSSL_malloc(sizeof(X509_POLICY_CACHE));\\r\\nif (!cache)\\r\\nreturn 0;\\r\\ncache->anyPolicy = NULL;\\r\\ncache->data = NULL;\\r\\ncache->maps = NULL;\\r\\ncache->any_skip = -1;\\r\\ncache->explicit_skip = -1;\\r\\ncache->map_skip = -1;\\r\\nx->policy_cache = cache;\\r\\next_pcons = X509_get_ext_d2i(x, NID_policy_constraints, &i, NULL);\\r\\nif (!ext_pcons)\\r\\n{\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!ext_pcons->requireExplicitPolicy\\r\\n&& !ext_pcons->inhibitPolicyMapping)\\r\\ngoto bad_cache;\\r\\nif (!policy_cache_set_int(&cache->explicit_skip,\\r\\next_pcons->requireExplicitPolicy))\\r\\ngoto bad_cache;\\r\\nif (!policy_cache_set_int(&cache->map_skip,\\r\\next_pcons->inhibitPolicyMapping))\\r\\ngoto bad_cache;\\r\\n}\\r\\next_cpols = X509_get_ext_d2i(x, NID_certificate_policies, &i, NULL);\\r\\nif (!ext_cpols)\\r\\n{\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\nreturn 1;\\r\\n}\\r\\ni = policy_cache_create(x, ext_cpols, i);\\r\\nif (i <= 0)\\r\\nreturn i;\\r\\next_pmaps = X509_get_ext_d2i(x, NID_policy_mappings, &i, NULL);\\r\\nif (!ext_pmaps)\\r\\n{\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni = policy_cache_set_mapping(x, ext_pmaps);\\r\\nif (i <= 0)\\r\\ngoto bad_cache;\\r\\n}\\r\\next_any = X509_get_ext_d2i(x, NID_inhibit_any_policy, &i, NULL);\\r\\nif (!ext_any)\\r\\n{\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n}\\r\\nelse if (!policy_cache_set_int(&cache->any_skip, ext_any))\\r\\ngoto bad_cache;\\r\\nif (0)\\r\\n{\\r\\nbad_cache:\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\n}\\r\\nif(ext_pcons)\\r\\nPOLICY_CONSTRAINTS_free(ext_pcons);\\r\\nif (ext_any)\\r\\nASN1_INTEGER_free(ext_any);\\r\\nreturn 1;\\r\\n}\\r\\nvoid policy_cache_free(X509_POLICY_CACHE *cache)\\r\\n{\\r\\nif (!cache)\\r\\nreturn;\\r\\nif (cache->anyPolicy)\\r\\npolicy_data_free(cache->anyPolicy);\\r\\nif (cache->data)\\r\\nsk_X509_POLICY_DATA_pop_free(cache->data, policy_data_free);\\r\\nOPENSSL_free(cache);\\r\\n}\\r\\nconst X509_POLICY_CACHE *policy_cache_set(X509 *x)\\r\\n{\\r\\nif (x->policy_cache == NULL)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\npolicy_cache_new(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nreturn x->policy_cache;\\r\\n}\\r\\nX509_POLICY_DATA *policy_cache_find_data(const X509_POLICY_CACHE *cache,\\r\\nconst ASN1_OBJECT *id)\\r\\n{\\r\\nint idx;\\r\\nX509_POLICY_DATA tmp;\\r\\ntmp.valid_policy = (ASN1_OBJECT *)id;\\r\\nidx = sk_X509_POLICY_DATA_find(cache->data, &tmp);\\r\\nif (idx == -1)\\r\\nreturn NULL;\\r\\nreturn sk_X509_POLICY_DATA_value(cache->data, idx);\\r\\n}\\r\\nstatic int policy_data_cmp(const X509_POLICY_DATA * const *a,\\r\\nconst X509_POLICY_DATA * const *b)\\r\\n{\\r\\nreturn OBJ_cmp((*a)->valid_policy, (*b)->valid_policy);\\r\\n}\\r\\nstatic int policy_cache_set_int(long *out, ASN1_INTEGER *value)\\r\\n{\\r\\nif (value == NULL)\\r\\nreturn 1;\\r\\nif (value->type == V_ASN1_NEG_INTEGER)\\r\\nreturn 0;\\r\\n*out = ASN1_INTEGER_get(value);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t1_meth_c", "target": 0, "func": "static SSL_METHOD *tls1_get_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_data.ssl_connect=ssl3_connect;\\r\\nTLSv1_data.ssl_accept=ssl3_accept;\\r\\nTLSv1_data.get_ssl_method=tls1_get_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&TLSv1_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn1_par_c", "target": 0, "func": "static int asn1_print_info(BIO *bp, int tag, int xclass, int constructed,\\r\\nint indent)\\r\\n{\\r\\nstatic const char fmt[]=\"%-18s\";\\r\\nstatic const char fmt2[]=\"%2d %-15s\";\\r\\nchar str[128];\\r\\nconst char *p,*p2=NULL;\\r\\nif (constructed & V_ASN1_CONSTRUCTED)\\r\\np=\"cons: \";\\r\\nelse\\r\\np=\"prim: \";\\r\\nif (BIO_write(bp,p,6) < 6) goto err;\\r\\nBIO_indent(bp,indent,128);\\r\\np=str;\\r\\nif ((xclass & V_ASN1_PRIVATE) == V_ASN1_PRIVATE)\\r\\nBIO_snprintf(str,sizeof str,\"priv [ %d ] \",tag);\\r\\nelse if ((xclass & V_ASN1_CONTEXT_SPECIFIC) == V_ASN1_CONTEXT_SPECIFIC)\\r\\nBIO_snprintf(str,sizeof str,\"cont [ %d ]\",tag);\\r\\nelse if ((xclass & V_ASN1_APPLICATION) == V_ASN1_APPLICATION)\\r\\nBIO_snprintf(str,sizeof str,\"appl [ %d ]\",tag);\\r\\nelse p = ASN1_tag2str(tag);\\r\\nif (p2 != NULL)\\r\\n{\\r\\nif (BIO_printf(bp,fmt2,tag,p2) <= 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,fmt,p) <= 0) goto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_parse(BIO *bp, const unsigned char *pp, long len, int indent)\\r\\n{\\r\\nreturn(asn1_parse2(bp,&pp,len,0,0,indent,0));\\r\\n}\\r\\nint ASN1_parse_dump(BIO *bp, const unsigned char *pp, long len, int indent, int dump)\\r\\n{\\r\\nreturn(asn1_parse2(bp,&pp,len,0,0,indent,dump));\\r\\n}\\r\\nstatic int asn1_parse2(BIO *bp, const unsigned char **pp, long length, int offset,\\r\\nint depth, int indent, int dump)\\r\\n{\\r\\nconst unsigned char *p,*ep,*tot,*op,*opp;\\r\\nlong len;\\r\\nint tag,xclass,ret=0;\\r\\nint nl,hl,j,r;\\r\\nASN1_OBJECT *o=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nint dump_indent;\\r\\n#if 0\\r\\ndump_indent = indent;\\r\\n#else\\r\\ndump_indent = 6;\\r\\n#endif\\r\\np= *pp;\\r\\ntot=p+length;\\r\\nop=p-1;\\r\\nwhile ((p < tot) && (op < p))\\r\\n{\\r\\nop=p;\\r\\nj=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\n#ifdef LINT\\r\\nj=j;\\r\\n#endif\\r\\nif (j & 0x80)\\r\\n{\\r\\nif (BIO_write(bp,\"Error in encoding\\n\",18) <= 0)\\r\\ngoto end;\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nhl=(p-op);\\r\\nlength-=hl;\\r\\nif (BIO_printf(bp,\"%5ld:\",(long)offset+(long)(op- *pp))\\r\\n<= 0) goto end;\\r\\nif (j != (V_ASN1_CONSTRUCTED | 1))\\r\\n{\\r\\nif (BIO_printf(bp,\"d=%-2d hl=%ld l=%4ld \",\\r\\ndepth,(long)hl,len) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,\"d=%-2d hl=%ld l=inf \",\\r\\ndepth,(long)hl) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (!asn1_print_info(bp,tag,xclass,j,(indent)?depth:0))\\r\\ngoto end;\\r\\nif (j & V_ASN1_CONSTRUCTED)\\r\\n{\\r\\nep=p+len;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\nif (len > length)\\r\\n{\\r\\nBIO_printf(bp,\\r\\n\"length is greater than %ld\\n\",length);\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif ((j == 0x21) && (len == 0))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nr=asn1_parse2(bp,&p,(long)(tot-p),\\r\\noffset+(p - *pp),depth+1,\\r\\nindent,dump);\\r\\nif (r == 0) { ret=0; goto end; }\\r\\nif ((r == 2) || (p >= tot)) break;\\r\\n}\\r\\n}\\r\\nelse\\r\\nwhile (p < ep)\\r\\n{\\r\\nr=asn1_parse2(bp,&p,(long)len,\\r\\noffset+(p - *pp),depth+1,\\r\\nindent,dump);\\r\\nif (r == 0) { ret=0; goto end; }\\r\\n}\\r\\n}\\r\\nelse if (xclass != 0)\\r\\n{\\r\\np+=len;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nnl=0;\\r\\nif ( (tag == V_ASN1_PRINTABLESTRING) ||\\r\\n(tag == V_ASN1_T61STRING) ||\\r\\n(tag == V_ASN1_IA5STRING) ||\\r\\n(tag == V_ASN1_VISIBLESTRING) ||\\r\\n(tag == V_ASN1_UTCTIME) ||\\r\\n(tag == V_ASN1_GENERALIZEDTIME))\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif ((len > 0) &&\\r\\nBIO_write(bp,(const char *)p,(int)len)\\r\\n!= (int)len)\\r\\ngoto end;\\r\\n}\\r\\nelse if (tag == V_ASN1_OBJECT)\\r\\n{\\r\\nopp=op;\\r\\nif (d2i_ASN1_OBJECT(&o,&opp,len+hl) != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\ni2a_ASN1_OBJECT(bp,o);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\":BAD OBJECT\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (tag == V_ASN1_BOOLEAN)\\r\\n{\\r\\nint ii;\\r\\nopp=op;\\r\\nii=d2i_ASN1_BOOLEAN(NULL,&opp,len+hl);\\r\\nif (ii < 0)\\r\\n{\\r\\nif (BIO_write(bp,\"Bad boolean\\n\",12))\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bp,\":%d\",ii);\\r\\n}\\r\\nelse if (tag == V_ASN1_BMPSTRING)\\r\\n{\\r\\n}\\r\\nelse if (tag == V_ASN1_OCTET_STRING)\\r\\n{\\r\\nint i,printable=1;\\r\\nopp=op;\\r\\nos=d2i_ASN1_OCTET_STRING(NULL,&opp,len+hl);\\r\\nif (os != NULL && os->length > 0)\\r\\n{\\r\\nopp = os->data;\\r\\nfor (i=0; i<os->length; i++)\\r\\n{\\r\\nif (( (opp[i] < ' ') &&\\r\\n(opp[i] != '\\n') &&\\r\\n(opp[i] != '\\r') &&\\r\\n(opp[i] != '\\t')) ||\\r\\n(opp[i] > '~'))\\r\\n{\\r\\nprintable=0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (printable)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0)\\r\\ngoto end;\\r\\nif (BIO_write(bp,(const char *)opp,\\r\\nos->length) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nelse if (!dump)\\r\\n{\\r\\nif (BIO_write(bp,\"[HEX DUMP]:\",11) <= 0)\\r\\ngoto end;\\r\\nfor (i=0; i<os->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\"\\r\\n, opp[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!nl)\\r\\n{\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_dump_indent(bp,\\r\\n(const char *)opp,\\r\\n((dump == -1 || dump >\\r\\nos->length)?os->length:dump),\\r\\ndump_indent) <= 0)\\r\\ngoto end;\\r\\nnl=1;\\r\\n}\\r\\n}\\r\\nif (os != NULL)\\r\\n{\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\nos=NULL;\\r\\n}\\r\\n}\\r\\nelse if (tag == V_ASN1_INTEGER)\\r\\n{\\r\\nASN1_INTEGER *bs;\\r\\nint i;\\r\\nopp=op;\\r\\nbs=d2i_ASN1_INTEGER(NULL,&opp,len+hl);\\r\\nif (bs != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif (bs->type == V_ASN1_NEG_INTEGER)\\r\\nif (BIO_write(bp,\"-\",1) <= 0)\\r\\ngoto end;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",\\r\\nbs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\"BAD INTEGER\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nM_ASN1_INTEGER_free(bs);\\r\\n}\\r\\nelse if (tag == V_ASN1_ENUMERATED)\\r\\n{\\r\\nASN1_ENUMERATED *bs;\\r\\nint i;\\r\\nopp=op;\\r\\nbs=d2i_ASN1_ENUMERATED(NULL,&opp,len+hl);\\r\\nif (bs != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif (bs->type == V_ASN1_NEG_ENUMERATED)\\r\\nif (BIO_write(bp,\"-\",1) <= 0)\\r\\ngoto end;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",\\r\\nbs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\"BAD ENUMERATED\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nM_ASN1_ENUMERATED_free(bs);\\r\\n}\\r\\nelse if (len > 0 && dump)\\r\\n{\\r\\nif (!nl)\\r\\n{\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_dump_indent(bp,(const char *)p,\\r\\n((dump == -1 || dump > len)?len:dump),\\r\\ndump_indent) <= 0)\\r\\ngoto end;\\r\\nnl=1;\\r\\n}\\r\\nif (!nl)\\r\\n{\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\n}\\r\\np+=len;\\r\\nif ((tag == V_ASN1_EOC) && (xclass == 0))\\r\\n{\\r\\nret=2;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nlength-=len;\\r\\n}\\r\\nret=1;\\r\\nend:\\r\\nif (o != NULL) ASN1_OBJECT_free(o);\\r\\nif (os != NULL) M_ASN1_OCTET_STRING_free(os);\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\n}\\r\\nconst char *ASN1_tag2str(int tag)\\r\\n{\\r\\nconst static char *tag2str[] = {\\r\\n\"EOC\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\\r\\n\"NULL\", \"OBJECT\", \"OBJECT DESCRIPTOR\", \"EXTERNAL\", \"REAL\",\\r\\n\"ENUMERATED\", \"<ASN1 11>\", \"UTF8STRING\", \"<ASN1 13>\",\\r\\n\"<ASN1 14>\", \"<ASN1 15>\", \"SEQUENCE\", \"SET\",\\r\\n\"NUMERICSTRING\", \"PRINTABLESTRING\", \"T61STRING\",\\r\\n\"VIDEOTEXSTRING\", \"IA5STRING\", \"UTCTIME\",\"GENERALIZEDTIME\",\\r\\n\"GRAPHICSTRING\", \"VISIBLESTRING\", \"GENERALSTRING\",\\r\\n\"UNIVERSALSTRING\", \"<ASN1 29>\", \"BMPSTRING\"\\r\\n};\\r\\nif((tag == V_ASN1_NEG_INTEGER) || (tag == V_ASN1_NEG_ENUMERATED))\\r\\ntag &= ~0x100;\\r\\nif(tag < 0 || tag > 30) return \"(unknown)\";\\r\\nreturn tag2str[tag];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d2i_pu_c", "target": 0, "func": "EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL))\\r\\n{\\r\\nif ((ret=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_EVP_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nelse ret= *a;\\r\\nret->save_type=type;\\r\\nret->type=EVP_PKEY_type(type);\\r\\nswitch (ret->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif ((ret->pkey.rsa=d2i_RSAPublicKey(NULL,\\r\\n(const unsigned char **)pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif (!d2i_DSAPublicKey(&(ret->pkey.dsa),\\r\\n(const unsigned char **)pp,length))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nif (!o2i_ECPublicKey(&(ret->pkey.ec),\\r\\n(const unsigned char **)pp, length))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) EVP_PKEY_free(ret);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_null_c", "target": 0, "func": "const RSA_METHOD *RSA_null_method(void)\\r\\n{\\r\\nreturn(&rsa_null_meth);\\r\\n}\\r\\nstatic int RSA_null_public_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PUBLIC_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_private_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PRIVATE_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_private_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PRIVATE_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_public_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PUBLIC_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_init(RSA *rsa)\\r\\n{\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSA_null_finish(RSA *rsa)\\r\\n{\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_acpt_c", "target": 0, "func": "BIO_METHOD *BIO_s_accept(void)\\r\\n{\\r\\nreturn(&methods_acceptp);\\r\\n}\\r\\nstatic int acpt_new(BIO *bi)\\r\\n{\\r\\nBIO_ACCEPT *ba;\\r\\nbi->init=0;\\r\\nbi->num=INVALID_SOCKET;\\r\\nbi->flags=0;\\r\\nif ((ba=BIO_ACCEPT_new()) == NULL)\\r\\nreturn(0);\\r\\nbi->ptr=(char *)ba;\\r\\nba->state=ACPT_S_BEFORE;\\r\\nbi->shutdown=1;\\r\\nreturn(1);\\r\\n}\\r\\nBIO_ACCEPT *BIO_ACCEPT_new(void)\\r\\n{\\r\\nBIO_ACCEPT *ret;\\r\\nif ((ret=(BIO_ACCEPT *)OPENSSL_malloc(sizeof(BIO_ACCEPT))) == NULL)\\r\\nreturn(NULL);\\r\\nmemset(ret,0,sizeof(BIO_ACCEPT));\\r\\nret->accept_sock=INVALID_SOCKET;\\r\\nret->bind_mode=BIO_BIND_NORMAL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_ACCEPT_free(BIO_ACCEPT *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->param_addr != NULL) OPENSSL_free(a->param_addr);\\r\\nif (a->addr != NULL) OPENSSL_free(a->addr);\\r\\nif (a->bio_chain != NULL) BIO_free(a->bio_chain);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nstatic void acpt_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_ACCEPT *c;\\r\\nc=(BIO_ACCEPT *)bio->ptr;\\r\\nif (c->accept_sock != INVALID_SOCKET)\\r\\n{\\r\\nshutdown(c->accept_sock,2);\\r\\nclosesocket(c->accept_sock);\\r\\nc->accept_sock=INVALID_SOCKET;\\r\\nbio->num=INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int acpt_free(BIO *a)\\r\\n{\\r\\nBIO_ACCEPT *data;\\r\\nif (a == NULL) return(0);\\r\\ndata=(BIO_ACCEPT *)a->ptr;\\r\\nif (a->shutdown)\\r\\n{\\r\\nacpt_close_socket(a);\\r\\nBIO_ACCEPT_free(data);\\r\\na->ptr=NULL;\\r\\na->flags=0;\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int acpt_state(BIO *b, BIO_ACCEPT *c)\\r\\n{\\r\\nBIO *bio=NULL,*dbio;\\r\\nint s= -1;\\r\\nint i;\\r\\nagain:\\r\\nswitch (c->state)\\r\\n{\\r\\ncase ACPT_S_BEFORE:\\r\\nif (c->param_addr == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_NO_ACCEPT_PORT_SPECIFIED);\\r\\nreturn(-1);\\r\\n}\\r\\ns=BIO_get_accept_socket(c->param_addr,c->bind_mode);\\r\\nif (s == INVALID_SOCKET)\\r\\nreturn(-1);\\r\\nif (c->accept_nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(s,1))\\r\\n{\\r\\nclosesocket(s);\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_ERROR_SETTING_NBIO_ON_ACCEPT_SOCKET);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nc->accept_sock=s;\\r\\nb->num=s;\\r\\nc->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\nreturn(1);\\r\\ncase ACPT_S_GET_ACCEPT_SOCKET:\\r\\nif (b->next_bio != NULL)\\r\\n{\\r\\nc->state=ACPT_S_OK;\\r\\ngoto again;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nb->retry_reason=0;\\r\\ni=BIO_accept(c->accept_sock,&(c->addr));\\r\\nif(i == -2)\\r\\n{\\r\\nBIO_set_retry_special(b);\\r\\nb->retry_reason=BIO_RR_ACCEPT;\\r\\nreturn -1;\\r\\n}\\r\\nif (i < 0) return(i);\\r\\nbio=BIO_new_socket(i,BIO_CLOSE);\\r\\nif (bio == NULL) goto err;\\r\\nBIO_set_callback(bio,BIO_get_callback(b));\\r\\nBIO_set_callback_arg(bio,BIO_get_callback_arg(b));\\r\\nif (c->nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(i,1))\\r\\n{\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_ERROR_SETTING_NBIO_ON_ACCEPTED_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (c->bio_chain != NULL)\\r\\n{\\r\\nif ((dbio=BIO_dup_chain(c->bio_chain)) == NULL)\\r\\ngoto err;\\r\\nif (!BIO_push(dbio,bio)) goto err;\\r\\nbio=dbio;\\r\\n}\\r\\nif (BIO_push(b,bio) == NULL) goto err;\\r\\nc->state=ACPT_S_OK;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (bio != NULL)\\r\\nBIO_free(bio);\\r\\nelse if (s >= 0)\\r\\nclosesocket(s);\\r\\nreturn(0);\\r\\ncase ACPT_S_OK:\\r\\nif (b->next_bio == NULL)\\r\\n{\\r\\nc->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\ngoto again;\\r\\n}\\r\\nreturn(1);\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstatic int acpt_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL)\\r\\n{\\r\\nret=acpt_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int acpt_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL)\\r\\n{\\r\\nret=acpt_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long acpt_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nint *ip;\\r\\nlong ret=1;\\r\\nBIO_ACCEPT *data;\\r\\nchar **pp;\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nret=0;\\r\\ndata->state=ACPT_S_BEFORE;\\r\\nacpt_close_socket(b);\\r\\nb->flags=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nret=(long)acpt_state(b,data);\\r\\nbreak;\\r\\ncase BIO_C_SET_ACCEPT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nif (num == 0)\\r\\n{\\r\\nb->init=1;\\r\\nif (data->param_addr != NULL)\\r\\nOPENSSL_free(data->param_addr);\\r\\ndata->param_addr=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\ndata->accept_nbio=(ptr != NULL);\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\nif (data->bio_chain != NULL)\\r\\nBIO_free(data->bio_chain);\\r\\ndata->bio_chain=(BIO *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nb->init=1;\\r\\nb->num= *((int *)ptr);\\r\\ndata->accept_sock=b->num;\\r\\ndata->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\nb->shutdown=(int)num;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip=data->accept_sock;\\r\\nret=data->accept_sock;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_C_GET_ACCEPT:\\r\\nif (b->init)\\r\\n{\\r\\nif (ptr != NULL)\\r\\n{\\r\\npp=(char **)ptr;\\r\\n*pp=data->param_addr;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_C_SET_BIND_MODE:\\r\\ndata->bind_mode=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_BIND_MODE:\\r\\nret=(long)data->bind_mode;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int acpt_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=acpt_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_accept(char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_accept());\\r\\nif (ret == NULL) return(NULL);\\r\\nif (BIO_set_accept_port(ret,str))\\r\\nreturn(ret);\\r\\nelse\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_example3_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nif ((argc == 2))\\r\\n{\\r\\ndo_cipher(argv[1],ENCRYPT);\\r\\n}\\r\\nelse if ((argc == 3) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\ndo_cipher(argv[2],DECRYPT);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"%s\", usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid do_cipher(char *pw, int operation)\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN + 8];\\r\\nunsigned int ebuflen;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH], key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ectx;\\r\\nmemcpy(iv, INIT_VECTOR, sizeof(iv));\\r\\nEVP_BytesToKey(ALG, EVP_md5(), \"salu\", pw, strlen(pw), 1, key, iv);\\r\\nEVP_CIPHER_CTX_init(&ectx);\\r\\nEVP_CipherInit_ex(&ectx, ALG, NULL, key, iv, operation);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nEVP_CipherUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_CipherFinal_ex(&ectx, ebuf, &ebuflen);\\r\\nEVP_CIPHER_CTX_cleanup(&ectx);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_pk1_c", "target": 0, "func": "int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-RSA_PKCS1_PADDING_SIZE))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=1;\\r\\nj=tlen-3-flen;\\r\\nmemset(p,0xff,j);\\r\\np+=j;\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i,j;\\r\\nconst unsigned char *p;\\r\\np=from;\\r\\nif ((num != (flen+1)) || (*(p++) != 01))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BLOCK_TYPE_IS_NOT_01);\\r\\nreturn(-1);\\r\\n}\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p != 0xff)\\r\\n{\\r\\nif (*p == 0)\\r\\n{ p++; break; }\\r\\nelse {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_FIXED_HEADER_DECRYPT);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (i == j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nif (i < 8)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_PAD_BYTE_COUNT);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nif (j > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE);\\r\\nreturn(-1);\\r\\n}\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}\\r\\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-11))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=2;\\r\\nj=tlen-3-flen;\\r\\nif (RAND_bytes(p,j) <= 0)\\r\\nreturn(0);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nif (RAND_bytes(p,1) <= 0)\\r\\nreturn(0);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i,j;\\r\\nconst unsigned char *p;\\r\\np=from;\\r\\nif ((num != (flen+1)) || (*(p++) != 02))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BLOCK_TYPE_IS_NOT_02);\\r\\nreturn(-1);\\r\\n}\\r\\n#ifdef PKCS1_CHECK\\r\\nreturn(num-11);\\r\\n#endif\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\nif (*(p++) == 0) break;\\r\\nif (i == j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nif (i < 8)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BAD_PAD_BYTE_COUNT);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nif (j > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE);\\r\\nreturn(-1);\\r\\n}\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_x509_c", "target": 0, "func": "int X509_print_fp(FILE *fp, X509 *x)\\r\\n{\\r\\nreturn X509_print_ex_fp(fp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}\\r\\nint X509_print_ex_fp(FILE *fp, X509 *x, unsigned long nmflag, unsigned long cflag)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_PRINT_EX_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_print_ex(b, x, nmflag, cflag);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_print(BIO *bp, X509 *x)\\r\\n{\\r\\nreturn X509_print_ex(bp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}\\r\\nint X509_print_ex(BIO *bp, X509 *x, unsigned long nmflags, unsigned long cflag)\\r\\n{\\r\\nlong l;\\r\\nint ret=0,i;\\r\\nchar *m=NULL,mlch = ' ';\\r\\nint nmindent = 0;\\r\\nX509_CINF *ci;\\r\\nASN1_INTEGER *bs;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nconst char *neg;\\r\\nASN1_STRING *str=NULL;\\r\\nif((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmlch = '\\n';\\r\\nnmindent = 12;\\r\\n}\\r\\nif(nmflags == X509_FLAG_COMPAT)\\r\\nnmindent = 16;\\r\\nci=x->cert_info;\\r\\nif(!(cflag & X509_FLAG_NO_HEADER))\\r\\n{\\r\\nif (BIO_write(bp,\"Certificate:\\n\",13) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Data:\\n\",10) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_VERSION))\\r\\n{\\r\\nl=X509_get_version(x);\\r\\nif (BIO_printf(bp,\"%8sVersion: %lu (0x%lx)\\n\",\"\",l+1,l) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_SERIAL))\\r\\n{\\r\\nif (BIO_write(bp,\" Serial Number:\",22) <= 0) goto err;\\r\\nbs=X509_get_serialNumber(x);\\r\\nif (bs->length <= 4)\\r\\n{\\r\\nl=ASN1_INTEGER_get(bs);\\r\\nif (l < 0)\\r\\n{\\r\\nl= -l;\\r\\nneg=\"-\";\\r\\n}\\r\\nelse\\r\\nneg=\"\";\\r\\nif (BIO_printf(bp,\" %s%lu (%s0x%lx)\\n\",neg,l,neg,l) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nneg=(bs->type == V_ASN1_NEG_INTEGER)?\" (Negative)\":\"\";\\r\\nif (BIO_printf(bp,\"\\n%12s%s\",\"\",neg) <= 0) goto err;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02x%c\",bs->data[i],\\r\\n((i+1 == bs->length)?'\\n':':')) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_SIGNAME))\\r\\n{\\r\\nif (BIO_printf(bp,\"%8sSignature Algorithm: \",\"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ci->signature->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_ISSUER))\\r\\n{\\r\\nif (BIO_printf(bp,\" Issuer:%c\",mlch) <= 0) goto err;\\r\\nif (X509_NAME_print_ex(bp,X509_get_issuer_name(x),nmindent, nmflags) < 0) goto err;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_VALIDITY))\\r\\n{\\r\\nif (BIO_write(bp,\" Validity\\n\",17) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Not Before: \",24) <= 0) goto err;\\r\\nif (!ASN1_TIME_print(bp,X509_get_notBefore(x))) goto err;\\r\\nif (BIO_write(bp,\"\\n Not After : \",25) <= 0) goto err;\\r\\nif (!ASN1_TIME_print(bp,X509_get_notAfter(x))) goto err;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_SUBJECT))\\r\\n{\\r\\nif (BIO_printf(bp,\" Subject:%c\",mlch) <= 0) goto err;\\r\\nif (X509_NAME_print_ex(bp,X509_get_subject_name(x),nmindent, nmflags) < 0) goto err;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_PUBKEY))\\r\\n{\\r\\nif (BIO_write(bp,\" Subject Public Key Info:\\n\",33) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp,\"%12sPublic Key Algorithm: \",\"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ci->key->algor->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bp,\"%12sUnable to load Public Key\\n\",\"\");\\r\\nERR_print_errors(bp);\\r\\n}\\r\\nelse\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sRSA Public Key: (%d bit)\\n\",\"\",\\r\\nBN_num_bits(pkey->pkey.rsa->n));\\r\\nRSA_print(bp,pkey->pkey.rsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sDSA Public Key:\\n\",\"\");\\r\\nDSA_print(bp,pkey->pkey.dsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nBIO_printf(bp, \"%12sEC Public Key:\\n\",\"\");\\r\\nEC_KEY_print(bp, pkey->pkey.ec, 16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(bp,\"%12sUnknown Public Key:\\n\",\"\");\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_EXTENSIONS))\\r\\nX509V3_extensions_print(bp, \"X509v3 extensions\",\\r\\nci->extensions, cflag, 8);\\r\\nif(!(cflag & X509_FLAG_NO_SIGDUMP))\\r\\n{\\r\\nif(X509_signature_print(bp, x->sig_alg, x->signature) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_AUX))\\r\\n{\\r\\nif (!X509_CERT_AUX_print(bp, x->aux, 0)) goto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (str != NULL) ASN1_STRING_free(str);\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_ocspid_print (BIO *bp, X509 *x)\\r\\n{\\r\\nunsigned char *der=NULL ;\\r\\nunsigned char *dertmp;\\r\\nint derlen;\\r\\nint i;\\r\\nunsigned char SHA1md[SHA_DIGEST_LENGTH];\\r\\nif (BIO_printf(bp,\" Subject OCSP hash: \") <= 0)\\r\\ngoto err;\\r\\nderlen = i2d_X509_NAME(x->cert_info->subject, NULL);\\r\\nif ((der = dertmp = (unsigned char *)OPENSSL_malloc (derlen)) == NULL)\\r\\ngoto err;\\r\\ni2d_X509_NAME(x->cert_info->subject, &dertmp);\\r\\nEVP_Digest(der, derlen, SHA1md, NULL, EVP_sha1(), NULL);\\r\\nfor (i=0; i < SHA_DIGEST_LENGTH; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",SHA1md[i]) <= 0) goto err;\\r\\n}\\r\\nOPENSSL_free (der);\\r\\nder=NULL;\\r\\nif (BIO_printf(bp,\"\\n Public key OCSP hash: \") <= 0)\\r\\ngoto err;\\r\\nEVP_Digest(x->cert_info->key->public_key->data,\\r\\nx->cert_info->key->public_key->length, SHA1md, NULL, EVP_sha1(), NULL);\\r\\nfor (i=0; i < SHA_DIGEST_LENGTH; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",SHA1md[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(bp,\"\\n\");\\r\\nreturn (1);\\r\\nerr:\\r\\nif (der != NULL) OPENSSL_free(der);\\r\\nreturn(0);\\r\\n}\\r\\nint X509_signature_print(BIO *bp, X509_ALGOR *sigalg, ASN1_STRING *sig)\\r\\n{\\r\\nunsigned char *s;\\r\\nint i, n;\\r\\nif (BIO_puts(bp,\" Signature Algorithm: \") <= 0) return 0;\\r\\nif (i2a_ASN1_OBJECT(bp, sigalg->algorithm) <= 0) return 0;\\r\\nn=sig->length;\\r\\ns=sig->data;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%18) == 0)\\r\\nif (BIO_write(bp,\"\\n \",9) <= 0) return 0;\\r\\nif (BIO_printf(bp,\"%02x%s\",s[i],\\r\\n((i+1) == n)?\"\":\":\") <= 0) return 0;\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) != 1) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_STRING_print(BIO *bp, ASN1_STRING *v)\\r\\n{\\r\\nint i,n;\\r\\nchar buf[80],*p;;\\r\\nif (v == NULL) return(0);\\r\\nn=0;\\r\\np=(char *)v->data;\\r\\nfor (i=0; i<v->length; i++)\\r\\n{\\r\\nif ((p[i] > '~') || ((p[i] < ' ') &&\\r\\n(p[i] != '\\n') && (p[i] != '\\r')))\\r\\nbuf[n]='.';\\r\\nelse\\r\\nbuf[n]=p[i];\\r\\nn++;\\r\\nif (n >= 80)\\r\\n{\\r\\nif (BIO_write(bp,buf,n) <= 0)\\r\\nreturn(0);\\r\\nn=0;\\r\\n}\\r\\n}\\r\\nif (n > 0)\\r\\nif (BIO_write(bp,buf,n) <= 0)\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TIME_print(BIO *bp, ASN1_TIME *tm)\\r\\n{\\r\\nif(tm->type == V_ASN1_UTCTIME) return ASN1_UTCTIME_print(bp, tm);\\r\\nif(tm->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_print(bp, tm);\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_print(BIO *bp, ASN1_GENERALIZEDTIME *tm)\\r\\n{\\r\\nchar *v;\\r\\nint gmt=0;\\r\\nint i;\\r\\nint y=0,M=0,d=0,h=0,m=0,s=0;\\r\\ni=tm->length;\\r\\nv=(char *)tm->data;\\r\\nif (i < 12) goto err;\\r\\nif (v[i-1] == 'Z') gmt=1;\\r\\nfor (i=0; i<12; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0')) goto err;\\r\\ny= (v[0]-'0')*1000+(v[1]-'0')*100 + (v[2]-'0')*10+(v[3]-'0');\\r\\nM= (v[4]-'0')*10+(v[5]-'0');\\r\\nif ((M > 12) || (M < 1)) goto err;\\r\\nd= (v[6]-'0')*10+(v[7]-'0');\\r\\nh= (v[8]-'0')*10+(v[9]-'0');\\r\\nm= (v[10]-'0')*10+(v[11]-'0');\\r\\nif ( (v[12] >= '0') && (v[12] <= '9') &&\\r\\n(v[13] >= '0') && (v[13] <= '9'))\\r\\ns= (v[12]-'0')*10+(v[13]-'0');\\r\\nif (BIO_printf(bp,\"%s %2d %02d:%02d:%02d %d%s\",\\r\\nmon[M-1],d,h,m,s,y,(gmt)?\" GMT\":\"\") <= 0)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\nerr:\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_UTCTIME_print(BIO *bp, ASN1_UTCTIME *tm)\\r\\n{\\r\\nchar *v;\\r\\nint gmt=0;\\r\\nint i;\\r\\nint y=0,M=0,d=0,h=0,m=0,s=0;\\r\\ni=tm->length;\\r\\nv=(char *)tm->data;\\r\\nif (i < 10) goto err;\\r\\nif (v[i-1] == 'Z') gmt=1;\\r\\nfor (i=0; i<10; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0')) goto err;\\r\\ny= (v[0]-'0')*10+(v[1]-'0');\\r\\nif (y < 50) y+=100;\\r\\nM= (v[2]-'0')*10+(v[3]-'0');\\r\\nif ((M > 12) || (M < 1)) goto err;\\r\\nd= (v[4]-'0')*10+(v[5]-'0');\\r\\nh= (v[6]-'0')*10+(v[7]-'0');\\r\\nm= (v[8]-'0')*10+(v[9]-'0');\\r\\nif ( (v[10] >= '0') && (v[10] <= '9') &&\\r\\n(v[11] >= '0') && (v[11] <= '9'))\\r\\ns= (v[10]-'0')*10+(v[11]-'0');\\r\\nif (BIO_printf(bp,\"%s %2d %02d:%02d:%02d %d%s\",\\r\\nmon[M-1],d,h,m,s,y+1900,(gmt)?\" GMT\":\"\") <= 0)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\nerr:\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint X509_NAME_print(BIO *bp, X509_NAME *name, int obase)\\r\\n{\\r\\nchar *s,*c,*b;\\r\\nint ret=0,l,ll,i,first=1;\\r\\nll=80-2-obase;\\r\\nb=s=X509_NAME_oneline(name,NULL,0);\\r\\nif (!*s)\\r\\n{\\r\\nOPENSSL_free(b);\\r\\nreturn 1;\\r\\n}\\r\\ns++;\\r\\nl=ll;\\r\\nc=s;\\r\\nfor (;;)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ( ((*s == '/') &&\\r\\n((s[1] >= 'A') && (s[1] <= 'Z') && (\\r\\n(s[2] == '=') ||\\r\\n((s[2] >= 'A') && (s[2] <= 'Z') &&\\r\\n(s[3] == '='))\\r\\n))) ||\\r\\n(*s == '\\0'))\\r\\n#else\\r\\nif ( ((*s == '/') &&\\r\\n(isupper(s[1]) && (\\r\\n(s[2] == '=') ||\\r\\n(isupper(s[2]) &&\\r\\n(s[3] == '='))\\r\\n))) ||\\r\\n(*s == '\\0'))\\r\\n#endif\\r\\n{\\r\\nif ((l <= 0) && !first)\\r\\n{\\r\\nfirst=0;\\r\\nif (BIO_write(bp,\"\\n\",1) != 1) goto err;\\r\\nfor (i=0; i<obase; i++)\\r\\n{\\r\\nif (BIO_write(bp,\" \",1) != 1) goto err;\\r\\n}\\r\\nl=ll;\\r\\n}\\r\\ni=s-c;\\r\\nif (BIO_write(bp,c,i) != i) goto err;\\r\\nc+=i;\\r\\nc++;\\r\\nif (*s != '\\0')\\r\\n{\\r\\nif (BIO_write(bp,\", \",2) != 2) goto err;\\r\\n}\\r\\nl--;\\r\\n}\\r\\nif (*s == '\\0') break;\\r\\ns++;\\r\\nl--;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_PRINT,ERR_R_BUF_LIB);\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_b_sock_c", "target": 0, "func": "int BIO_get_host_ip(const char *str, unsigned char *ip)\\r\\n{\\r\\nint i;\\r\\nint err = 1;\\r\\nint locked = 0;\\r\\nstruct hostent *he;\\r\\ni=get_ip(str,ip);\\r\\nif (i < 0)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_INVALID_IP_ADDRESS);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_sock_init() != 1)\\r\\nreturn 0;\\r\\nif (i > 0) return(1);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nlocked = 1;\\r\\nhe=BIO_gethostbyname(str);\\r\\nif (he == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_BAD_HOSTNAME_LOOKUP);\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<4; i++)\\r\\nip[i]=he->h_addr_list[0][i];\\r\\nerr = 0;\\r\\nerr:\\r\\nif (locked)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nif (err)\\r\\n{\\r\\nERR_add_error_data(2,\"host=\",str);\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint BIO_get_port(const char *str, unsigned short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\nif (str == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_PORT,BIO_R_NO_PORT_DEFINED);\\r\\nreturn(0);\\r\\n}\\r\\ni=atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr=(unsigned short)i;\\r\\nelse\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\ns=getservbyname(\\r\\n#ifndef CONST_STRICT\\r\\n(char *)\\r\\n#endif\\r\\nstr,\"tcp\");\\r\\nif(s != NULL)\\r\\n*port_ptr=ntohs((unsigned short)s->s_port);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\nif(s == NULL)\\r\\n{\\r\\nif (strcmp(str,\"http\") == 0)\\r\\n*port_ptr=80;\\r\\nelse if (strcmp(str,\"telnet\") == 0)\\r\\n*port_ptr=23;\\r\\nelse if (strcmp(str,\"socks\") == 0)\\r\\n*port_ptr=1080;\\r\\nelse if (strcmp(str,\"https\") == 0)\\r\\n*port_ptr=443;\\r\\nelse if (strcmp(str,\"ssl\") == 0)\\r\\n*port_ptr=443;\\r\\nelse if (strcmp(str,\"ftp\") == 0)\\r\\n*port_ptr=21;\\r\\nelse if (strcmp(str,\"gopher\") == 0)\\r\\n*port_ptr=70;\\r\\n#if 0\\r\\nelse if (strcmp(str,\"wais\") == 0)\\r\\n*port_ptr=21;\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nSYSerr(SYS_F_GETSERVBYNAME,get_last_socket_error());\\r\\nERR_add_error_data(3,\"service='\",str,\"'\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_sock_error(int sock)\\r\\n{\\r\\nint j,i;\\r\\nint size;\\r\\nsize=sizeof(int);\\r\\ni=getsockopt(sock,SOL_SOCKET,SO_ERROR,(void *)&j,(void *)&size);\\r\\nif (i < 0)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(j);\\r\\n}\\r\\nstruct hostent *BIO_gethostbyname(const char *name)\\r\\n{\\r\\n#if 1\\r\\nreturn gethostbyname(name);\\r\\n#else\\r\\nstruct hostent *ret;\\r\\nint i,lowi=0,j;\\r\\nunsigned long low= (unsigned long)-1;\\r\\n# if 0\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n# endif\\r\\nj=strlen(name);\\r\\nif (j < 128)\\r\\n{\\r\\nfor (i=0; i<GHBN_NUM; i++)\\r\\n{\\r\\nif (low > ghbn_cache[i].order)\\r\\n{\\r\\nlow=ghbn_cache[i].order;\\r\\nlowi=i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0)\\r\\n{\\r\\nif (strncmp(name,ghbn_cache[i].name,128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\ni=GHBN_NUM;\\r\\nif (i == GHBN_NUM)\\r\\n{\\r\\nBIO_ghbn_miss++;\\r\\nret=gethostbyname(\\r\\n# ifndef CONST_STRICT\\r\\n(char *)\\r\\n# endif\\r\\nname);\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (j > 128)\\r\\n{\\r\\n# if 0\\r\\nret = NULL;\\r\\n# endif\\r\\ngoto end;\\r\\n}\\r\\nif (ghbn_cache[lowi].ent != NULL)\\r\\nghbn_free(ghbn_cache[lowi].ent);\\r\\nghbn_cache[lowi].name[0] = '\\0';\\r\\nif((ret=ghbn_cache[lowi].ent=ghbn_dup(ret)) == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETHOSTBYNAME,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nstrncpy(ghbn_cache[lowi].name,name,128);\\r\\nghbn_cache[lowi].order=BIO_ghbn_miss+BIO_ghbn_hits;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_ghbn_hits++;\\r\\nret= ghbn_cache[i].ent;\\r\\nghbn_cache[i].order=BIO_ghbn_miss+BIO_ghbn_hits;\\r\\n}\\r\\nend:\\r\\n# if 0\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n# endif\\r\\nreturn(ret);\\r\\n#endif\\r\\n}\\r\\nint BIO_sock_init(void)\\r\\n{\\r\\n#ifdef OPENSSL_SYS_WINDOWS\\r\\nstatic struct WSAData wsa_state;\\r\\nif (!wsa_init_done)\\r\\n{\\r\\nint err;\\r\\n#ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))BIO_sock_cleanup);\\r\\n#endif\\r\\nwsa_init_done=1;\\r\\nmemset(&wsa_state,0,sizeof(wsa_state));\\r\\nif (WSAStartup(0x0101,&wsa_state)!=0)\\r\\n{\\r\\nerr=WSAGetLastError();\\r\\nSYSerr(SYS_F_WSASTARTUP,err);\\r\\nBIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef WATT32\\r\\nextern int _watt_do_exit;\\r\\n_watt_do_exit = 0;\\r\\nif (sock_init())\\r\\nreturn (-1);\\r\\n#endif\\r\\n#if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nWORD wVerReq;\\r\\nWSADATA wsaData;\\r\\nint err;\\r\\nif (!wsa_init_done)\\r\\n{\\r\\n# ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))BIO_sock_cleanup);\\r\\n# endif\\r\\nwsa_init_done=1;\\r\\nwVerReq = MAKEWORD( 2, 0 );\\r\\nerr = WSAStartup(wVerReq,&wsaData);\\r\\nif (err != 0)\\r\\n{\\r\\nSYSerr(SYS_F_WSASTARTUP,err);\\r\\nBIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nvoid BIO_sock_cleanup(void)\\r\\n{\\r\\n#ifdef OPENSSL_SYS_WINDOWS\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\n#ifndef OPENSSL_SYS_WINCE\\r\\nWSACancelBlockingCall();\\r\\n#endif\\r\\nWSACleanup();\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\nWSACleanup();\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint BIO_socket_ioctl(int fd, long type, void *arg)\\r\\n{\\r\\nint i;\\r\\n#ifdef __DJGPP__\\r\\ni=ioctlsocket(fd,type,(char *)arg);\\r\\n#else\\r\\ni=ioctlsocket(fd,type,arg);\\r\\n#endif\\r\\nif (i < 0)\\r\\nSYSerr(SYS_F_IOCTLSOCKET,get_last_socket_error());\\r\\nreturn(i);\\r\\n}\\r\\nstatic int get_ip(const char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int tmp[4];\\r\\nint num=0,c,ok=0;\\r\\ntmp[0]=tmp[1]=tmp[2]=tmp[3]=0;\\r\\nfor (;;)\\r\\n{\\r\\nc= *(str++);\\r\\nif ((c >= '0') && (c <= '9'))\\r\\n{\\r\\nok=1;\\r\\ntmp[num]=tmp[num]*10+c-'0';\\r\\nif (tmp[num] > 255) return(0);\\r\\n}\\r\\nelse if (c == '.')\\r\\n{\\r\\nif (!ok) return(-1);\\r\\nif (num == 3) return(0);\\r\\nnum++;\\r\\nok=0;\\r\\n}\\r\\nelse if (c == '\\0' && (num == 3) && ok)\\r\\nbreak;\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nip[0]=tmp[0];\\r\\nip[1]=tmp[1];\\r\\nip[2]=tmp[2];\\r\\nip[3]=tmp[3];\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_get_accept_socket(char *host, int bind_mode)\\r\\n{\\r\\nint ret=0;\\r\\nstruct sockaddr_in server,client;\\r\\nint s=INVALID_SOCKET,cs;\\r\\nunsigned char ip[4];\\r\\nunsigned short port;\\r\\nchar *str=NULL,*e;\\r\\nconst char *h,*p;\\r\\nunsigned long l;\\r\\nint err_num;\\r\\nif (BIO_sock_init() != 1) return(INVALID_SOCKET);\\r\\nif ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);\\r\\nh=p=NULL;\\r\\nh=str;\\r\\nfor (e=str; *e; e++)\\r\\n{\\r\\nif (*e == ':')\\r\\n{\\r\\np= &(e[1]);\\r\\n*e='\\0';\\r\\n}\\r\\nelse if (*e == '/')\\r\\n{\\r\\n*e='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p == NULL)\\r\\n{\\r\\np=h;\\r\\nh=\"*\";\\r\\n}\\r\\nif (!BIO_get_port(p,&port)) goto err;\\r\\nmemset((char *)&server,0,sizeof(server));\\r\\nserver.sin_family=AF_INET;\\r\\nserver.sin_port=htons(port);\\r\\nif (strcmp(h,\"*\") == 0)\\r\\nserver.sin_addr.s_addr=INADDR_ANY;\\r\\nelse\\r\\n{\\r\\nif (!BIO_get_host_ip(h,&(ip[0]))) goto err;\\r\\nl=(unsigned long)\\r\\n((unsigned long)ip[0]<<24L)|\\r\\n((unsigned long)ip[1]<<16L)|\\r\\n((unsigned long)ip[2]<< 8L)|\\r\\n((unsigned long)ip[3]);\\r\\nserver.sin_addr.s_addr=htonl(l);\\r\\n}\\r\\nagain:\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef SO_REUSEADDR\\r\\nif (bind_mode == BIO_BIND_REUSEADDR)\\r\\n{\\r\\nint i=1;\\r\\nret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));\\r\\nbind_mode=BIO_BIND_NORMAL;\\r\\n}\\r\\n#endif\\r\\nif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\\r\\n{\\r\\n#ifdef SO_REUSEADDR\\r\\nerr_num=get_last_socket_error();\\r\\nif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\\r\\n(err_num == EADDRINUSE))\\r\\n{\\r\\nmemcpy((char *)&client,(char *)&server,sizeof(server));\\r\\nif (strcmp(h,\"*\") == 0)\\r\\nclient.sin_addr.s_addr=htonl(0x7F000001);\\r\\ncs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (cs != INVALID_SOCKET)\\r\\n{\\r\\nint ii;\\r\\nii=connect(cs,(struct sockaddr *)&client,\\r\\nsizeof(client));\\r\\nclosesocket(cs);\\r\\nif (ii == INVALID_SOCKET)\\r\\n{\\r\\nbind_mode=BIO_BIND_REUSEADDR;\\r\\nclosesocket(s);\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\nSYSerr(SYS_F_BIND,err_num);\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\nif (listen(s,MAX_LISTEN) == -1)\\r\\n{\\r\\nSYSerr(SYS_F_BIND,get_last_socket_error());\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (str != NULL) OPENSSL_free(str);\\r\\nif ((ret == 0) && (s != INVALID_SOCKET))\\r\\n{\\r\\nclosesocket(s);\\r\\ns= INVALID_SOCKET;\\r\\n}\\r\\nreturn(s);\\r\\n}\\r\\nint BIO_accept(int sock, char **addr)\\r\\n{\\r\\nint ret=INVALID_SOCKET;\\r\\nstatic struct sockaddr_in from;\\r\\nunsigned long l;\\r\\nunsigned short port;\\r\\nint len;\\r\\nchar *p;\\r\\nmemset((char *)&from,0,sizeof(from));\\r\\nlen=sizeof(from);\\r\\nret=accept(sock,(struct sockaddr *)&from,(void *)&len);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\nif(BIO_sock_should_retry(ret)) return -2;\\r\\nSYSerr(SYS_F_ACCEPT,get_last_socket_error());\\r\\nBIOerr(BIO_F_BIO_ACCEPT,BIO_R_ACCEPT_ERROR);\\r\\ngoto end;\\r\\n}\\r\\nif (addr == NULL) goto end;\\r\\nl=ntohl(from.sin_addr.s_addr);\\r\\nport=ntohs(from.sin_port);\\r\\nif (*addr == NULL)\\r\\n{\\r\\nif ((p=OPENSSL_malloc(24)) == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\n*addr=p;\\r\\n}\\r\\nBIO_snprintf(*addr,24,\"%d.%d.%d.%d:%d\",\\r\\n(unsigned char)(l>>24L)&0xff,\\r\\n(unsigned char)(l>>16L)&0xff,\\r\\n(unsigned char)(l>> 8L)&0xff,\\r\\n(unsigned char)(l )&0xff,\\r\\nport);\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_set_tcp_ndelay(int s, int on)\\r\\n{\\r\\nint ret=0;\\r\\n#if defined(TCP_NODELAY) && (defined(IPPROTO_TCP) || defined(SOL_TCP))\\r\\nint opt;\\r\\n#ifdef SOL_TCP\\r\\nopt=SOL_TCP;\\r\\n#else\\r\\n#ifdef IPPROTO_TCP\\r\\nopt=IPPROTO_TCP;\\r\\n#endif\\r\\n#endif\\r\\nret=setsockopt(s,opt,TCP_NODELAY,(char *)&on,sizeof(on));\\r\\n#endif\\r\\nreturn(ret == 0);\\r\\n}\\r\\nint BIO_socket_nbio(int s, int mode)\\r\\n{\\r\\nint ret= -1;\\r\\nint l;\\r\\nl=mode;\\r\\n#ifdef FIONBIO\\r\\nret=BIO_socket_ioctl(s,FIONBIO,&l);\\r\\n#endif\\r\\nreturn(ret == 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkwrite_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nFILE *fp;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *cert;\\r\\nPKCS12 *p12;\\r\\nif (argc != 5) {\\r\\nfprintf(stderr, \"Usage: pkwrite infile password name p12file\\n\");\\r\\nexit(1);\\r\\n}\\r\\nSSLeay_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nif (!(fp = fopen(argv[1], \"r\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\ncert = PEM_read_X509(fp, NULL, NULL, NULL);\\r\\nrewind(fp);\\r\\npkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL);\\r\\nfclose(fp);\\r\\np12 = PKCS12_create(argv[2], argv[3], pkey, cert, NULL, 0,0,0,0,0);\\r\\nif(!p12) {\\r\\nfprintf(stderr, \"Error creating PKCS#12 structure\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nif (!(fp = fopen(argv[4], \"wb\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ni2d_PKCS12_fp(fp, p12);\\r\\nPKCS12_free(p12);\\r\\nfclose(fp);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_ia5_c", "target": 0, "func": "static char *i2s_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nASN1_IA5STRING *ia5)\\r\\n{\\r\\nchar *tmp;\\r\\nif(!ia5 || !ia5->length) return NULL;\\r\\nif(!(tmp = OPENSSL_malloc(ia5->length + 1))) {\\r\\nX509V3err(X509V3_F_I2S_ASN1_IA5STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemcpy(tmp, ia5->data, ia5->length);\\r\\ntmp[ia5->length] = 0;\\r\\nreturn tmp;\\r\\n}\\r\\nstatic ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_IA5STRING *ia5;\\r\\nif(!str) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(ia5 = M_ASN1_IA5STRING_new())) goto err;\\r\\nif(!ASN1_STRING_set((ASN1_STRING *)ia5, (unsigned char*)str,\\r\\nstrlen(str))) {\\r\\nM_ASN1_IA5STRING_free(ia5);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(ia5->data, ia5->data, ia5->length);\\r\\n#endif\\r\\nreturn ia5;\\r\\nerr:\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_sxnet_c", "target": 0, "func": "int SXNET_add_id_asc(SXNET **psx, char *zone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif(!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_ASC,X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif(!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_ULONG,ERR_R_MALLOC_FAILURE);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nSXNET *sx = NULL;\\r\\nSXNETID *id = NULL;\\r\\nif(!psx || !zone || !user) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif(userlen == -1) userlen = strlen(user);\\r\\nif(userlen > 64) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_USER_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif(!*psx) {\\r\\nif(!(sx = SXNET_new())) goto err;\\r\\nif(!ASN1_INTEGER_set(sx->version, 0)) goto err;\\r\\n*psx = sx;\\r\\n} else sx = *psx;\\r\\nif(SXNET_get_id_INTEGER(sx, zone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_DUPLICATE_ZONE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(id = SXNETID_new())) goto err;\\r\\nif(userlen == -1) userlen = strlen(user);\\r\\nif(!M_ASN1_OCTET_STRING_set(id->user, user, userlen)) goto err;\\r\\nif(!sk_SXNETID_push(sx->ids, id)) goto err;\\r\\nid->zone = zone;\\r\\nreturn 1;\\r\\nerr:\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nSXNETID_free(id);\\r\\nSXNET_free(sx);\\r\\n*psx = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, char *zone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif(!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ASC,X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif(!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ULONG,ERR_R_MALLOC_FAILURE);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)\\r\\n{\\r\\nSXNETID *id;\\r\\nint i;\\r\\nfor(i = 0; i < sk_SXNETID_num(sx->ids); i++) {\\r\\nid = sk_SXNETID_value(sx->ids, i);\\r\\nif(!M_ASN1_INTEGER_cmp(id->zone, zone)) return id->user;\\r\\n}\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc4_skey_c", "target": 0, "func": "const char *RC4_options(void)\\r\\n{\\r\\n#ifdef RC4_INDEX\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn(\"rc4(idx,char)\");\\r\\nelse\\r\\nreturn(\"rc4(idx,int)\");\\r\\n#else\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn(\"rc4(ptr,char)\");\\r\\nelse\\r\\nreturn(\"rc4(ptr,int)\");\\r\\n#endif\\r\\n}\\r\\nvoid RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\\r\\n{\\r\\nregister RC4_INT tmp;\\r\\nregister int id1,id2;\\r\\nregister RC4_INT *d;\\r\\nunsigned int i;\\r\\nd= &(key->data[0]);\\r\\nkey->x = 0;\\r\\nkey->y = 0;\\r\\nid1=id2=0;\\r\\n#define SK_LOOP(d,n) { \\\\r\\ntmp=d[(n)]; \\\\r\\nid2 = (data[id1] + tmp + id2) & 0xff; \\\\r\\nif (++id1 == len) id1=0; \\\\r\\nd[(n)]=d[id2]; \\\\r\\nd[id2]=tmp; }\\r\\n#if defined(OPENSSL_CPUID_OBJ) && !defined(OPENSSL_NO_ASM)\\r\\n# if defined(__i386) || defined(__i386__) || defined(_M_IX86) || \\\\r\\ndefined(__INTEL__) || \\\\r\\ndefined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64)\\r\\nif (sizeof(RC4_INT) > 1) {\\r\\nif (OPENSSL_ia32cap_P & (1<<28)) {\\r\\nunsigned char *cp=(unsigned char *)d;\\r\\nfor (i=0;i<256;i++) cp[i]=i;\\r\\nfor (i=0;i<256;i++) SK_LOOP(cp,i);\\r\\nd[256/sizeof(RC4_INT)]=-1;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n#endif\\r\\nfor (i=0; i < 256; i++) d[i]=i;\\r\\nfor (i=0; i < 256; i+=4)\\r\\n{\\r\\nSK_LOOP(d,i+0);\\r\\nSK_LOOP(d,i+1);\\r\\nSK_LOOP(d,i+2);\\r\\nSK_LOOP(d,i+3);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_engine_c", "target": 0, "func": "static void identity(void *ptr)\\r\\n{\\r\\nreturn;\\r\\n}\\r\\nstatic int append_buf(char **buf, const char *s, int *size, int step)\\r\\n{\\r\\nint l = strlen(s);\\r\\nif (*buf == NULL)\\r\\n{\\r\\n*size = step;\\r\\n*buf = OPENSSL_malloc(*size);\\r\\nif (*buf == NULL)\\r\\nreturn 0;\\r\\n**buf = '\\0';\\r\\n}\\r\\nif (**buf != '\\0')\\r\\nl += 2;\\r\\nif (strlen(*buf) + strlen(s) >= (unsigned int)*size)\\r\\n{\\r\\n*size += step;\\r\\n*buf = OPENSSL_realloc(*buf, *size);\\r\\n}\\r\\nif (*buf == NULL)\\r\\nreturn 0;\\r\\nif (**buf != '\\0')\\r\\nBUF_strlcat(*buf, \", \", *size);\\r\\nBUF_strlcat(*buf, s, *size);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int util_flags(BIO *bio_out, unsigned int flags, const char *indent)\\r\\n{\\r\\nint started = 0, err = 0;\\r\\nBIO_printf(bio_out, \"%s%s(input flags): \", indent, indent);\\r\\nif(flags == 0)\\r\\n{\\r\\nBIO_printf(bio_out, \"<no flags>\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_INTERNAL)\\r\\n{\\r\\nBIO_printf(bio_out, \"[Internal] \");\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_NUMERIC)\\r\\n{\\r\\nif(started)\\r\\n{\\r\\nBIO_printf(bio_out, \"|\");\\r\\nerr = 1;\\r\\n}\\r\\nBIO_printf(bio_out, \"NUMERIC\");\\r\\nstarted = 1;\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_STRING)\\r\\n{\\r\\nif(started)\\r\\n{\\r\\nBIO_printf(bio_out, \"|\");\\r\\nerr = 1;\\r\\n}\\r\\nBIO_printf(bio_out, \"STRING\");\\r\\nstarted = 1;\\r\\n}\\r\\nif(flags & ENGINE_CMD_FLAG_NO_INPUT)\\r\\n{\\r\\nif(started)\\r\\n{\\r\\nBIO_printf(bio_out, \"|\");\\r\\nerr = 1;\\r\\n}\\r\\nBIO_printf(bio_out, \"NO_INPUT\");\\r\\nstarted = 1;\\r\\n}\\r\\nflags = flags & ~ENGINE_CMD_FLAG_NUMERIC &\\r\\n~ENGINE_CMD_FLAG_STRING &\\r\\n~ENGINE_CMD_FLAG_NO_INPUT &\\r\\n~ENGINE_CMD_FLAG_INTERNAL;\\r\\nif(flags)\\r\\n{\\r\\nif(started) BIO_printf(bio_out, \"|\");\\r\\nBIO_printf(bio_out, \"<0x%04X>\", flags);\\r\\n}\\r\\nif(err)\\r\\nBIO_printf(bio_out, \" <illegal flags!>\");\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int util_verbose(ENGINE *e, int verbose, BIO *bio_out, const char *indent)\\r\\n{\\r\\nstatic const int line_wrap = 78;\\r\\nint num;\\r\\nint ret = 0;\\r\\nchar *name = NULL;\\r\\nchar *desc = NULL;\\r\\nint flags;\\r\\nint xpos = 0;\\r\\nSTACK *cmds = NULL;\\r\\nif(!ENGINE_ctrl(e, ENGINE_CTRL_HAS_CTRL_FUNCTION, 0, NULL, NULL) ||\\r\\n((num = ENGINE_ctrl(e, ENGINE_CTRL_GET_FIRST_CMD_TYPE,\\r\\n0, NULL, NULL)) <= 0))\\r\\n{\\r\\n#if 0\\r\\nBIO_printf(bio_out, \"%s<no control commands>\\n\", indent);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\ncmds = sk_new_null();\\r\\nif(!cmds)\\r\\ngoto err;\\r\\ndo {\\r\\nint len;\\r\\nif((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num,\\r\\nNULL, NULL)) < 0)\\r\\ngoto err;\\r\\nif (!(flags & ENGINE_CMD_FLAG_INTERNAL) || verbose >= 4)\\r\\n{\\r\\nif((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_LEN_FROM_CMD, num,\\r\\nNULL, NULL)) <= 0)\\r\\ngoto err;\\r\\nif((name = OPENSSL_malloc(len + 1)) == NULL)\\r\\ngoto err;\\r\\nif(ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_FROM_CMD, num, name,\\r\\nNULL) <= 0)\\r\\ngoto err;\\r\\nif((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_LEN_FROM_CMD, num,\\r\\nNULL, NULL)) < 0)\\r\\ngoto err;\\r\\nif(len > 0)\\r\\n{\\r\\nif((desc = OPENSSL_malloc(len + 1)) == NULL)\\r\\ngoto err;\\r\\nif(ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_FROM_CMD, num, desc,\\r\\nNULL) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif(xpos == 0)\\r\\nxpos = BIO_printf(bio_out, indent);\\r\\nelse\\r\\nxpos += BIO_printf(bio_out, \", \");\\r\\nif(verbose == 1)\\r\\n{\\r\\nif((xpos > (int)strlen(indent)) &&\\r\\n(xpos + (int)strlen(name) > line_wrap))\\r\\n{\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nxpos = BIO_printf(bio_out, indent);\\r\\n}\\r\\nxpos += BIO_printf(bio_out, \"%s\", name);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_out, \"%s: %s\\n\", name,\\r\\n(desc == NULL) ? \"<no description>\" : desc);\\r\\nif((verbose >= 3) && !util_flags(bio_out, flags,\\r\\nindent))\\r\\ngoto err;\\r\\nxpos = 0;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(name); name = NULL;\\r\\nif(desc) { OPENSSL_free(desc); desc = NULL; }\\r\\nnum = ENGINE_ctrl(e, ENGINE_CTRL_GET_NEXT_CMD_TYPE,\\r\\nnum, NULL, NULL);\\r\\n} while(num > 0);\\r\\nif(xpos > 0)\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nret = 1;\\r\\nerr:\\r\\nif(cmds) sk_pop_free(cmds, identity);\\r\\nif(name) OPENSSL_free(name);\\r\\nif(desc) OPENSSL_free(desc);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void util_do_cmds(ENGINE *e, STACK *cmds, BIO *bio_out, const char *indent)\\r\\n{\\r\\nint loop, res, num = sk_num(cmds);\\r\\nif(num < 0)\\r\\n{\\r\\nBIO_printf(bio_out, \"[Error]: internal stack error\\n\");\\r\\nreturn;\\r\\n}\\r\\nfor(loop = 0; loop < num; loop++)\\r\\n{\\r\\nchar buf[256];\\r\\nconst char *cmd, *arg;\\r\\ncmd = sk_value(cmds, loop);\\r\\nres = 1;\\r\\nif((arg = strstr(cmd, \":\")) == NULL)\\r\\n{\\r\\nif(!ENGINE_ctrl_cmd_string(e, cmd, NULL, 0))\\r\\nres = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif((int)(arg - cmd) > 254)\\r\\n{\\r\\nBIO_printf(bio_out,\"[Error]: command name too long\\n\");\\r\\nreturn;\\r\\n}\\r\\nmemcpy(buf, cmd, (int)(arg - cmd));\\r\\nbuf[arg-cmd] = '\\0';\\r\\narg++;\\r\\nif(!ENGINE_ctrl_cmd_string(e, buf, arg, 0))\\r\\nres = 0;\\r\\n}\\r\\nif(res)\\r\\nBIO_printf(bio_out, \"[Success]: %s\\n\", cmd);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_out, \"[Failure]: %s\\n\", cmd);\\r\\nERR_print_errors(bio_out);\\r\\n}\\r\\n}\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1,i;\\r\\nconst char **pp;\\r\\nint verbose=0, list_cap=0, test_avail=0, test_avail_noise = 0;\\r\\nENGINE *e;\\r\\nSTACK *engines = sk_new_null();\\r\\nSTACK *pre_cmds = sk_new_null();\\r\\nSTACK *post_cmds = sk_new_null();\\r\\nint badops=1;\\r\\nBIO *bio_out=NULL;\\r\\nconst char *indent = \" \";\\r\\napps_startup();\\r\\nSSL_load_error_strings();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nbio_out=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_out = BIO_push(tmpbio, bio_out);\\r\\n}\\r\\n#endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strncmp(*argv,\"-v\",2) == 0)\\r\\n{\\r\\nif(strspn(*argv + 1, \"v\") < strlen(*argv + 1))\\r\\ngoto skip_arg_loop;\\r\\nif((verbose=strlen(*argv + 1)) > 4)\\r\\ngoto skip_arg_loop;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-c\") == 0)\\r\\nlist_cap=1;\\r\\nelse if (strncmp(*argv,\"-t\",2) == 0)\\r\\n{\\r\\ntest_avail=1;\\r\\nif(strspn(*argv + 1, \"t\") < strlen(*argv + 1))\\r\\ngoto skip_arg_loop;\\r\\nif((test_avail_noise = strlen(*argv + 1) - 1) > 1)\\r\\ngoto skip_arg_loop;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-pre\") == 0)\\r\\n{\\r\\nargc--; argv++;\\r\\nif (argc == 0)\\r\\ngoto skip_arg_loop;\\r\\nsk_push(pre_cmds,*argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-post\") == 0)\\r\\n{\\r\\nargc--; argv++;\\r\\nif (argc == 0)\\r\\ngoto skip_arg_loop;\\r\\nsk_push(post_cmds,*argv);\\r\\n}\\r\\nelse if ((strncmp(*argv,\"-h\",2) == 0) ||\\r\\n(strcmp(*argv,\"-?\") == 0))\\r\\ngoto skip_arg_loop;\\r\\nelse\\r\\nsk_push(engines,*argv);\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nbadops = 0;\\r\\nskip_arg_loop:\\r\\nif (badops)\\r\\n{\\r\\nfor (pp=engine_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto end;\\r\\n}\\r\\nif (sk_num(engines) == 0)\\r\\n{\\r\\nfor(e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e))\\r\\n{\\r\\nsk_push(engines,(char *)ENGINE_get_id(e));\\r\\n}\\r\\n}\\r\\nfor (i=0; i<sk_num(engines); i++)\\r\\n{\\r\\nconst char *id = sk_value(engines,i);\\r\\nif ((e = ENGINE_by_id(id)) != NULL)\\r\\n{\\r\\nconst char *name = ENGINE_get_name(e);\\r\\nBIO_printf(bio_out, \"(%s) %s\\n\", id, name);\\r\\nutil_do_cmds(e, pre_cmds, bio_out, indent);\\r\\nif (strcmp(ENGINE_get_id(e), id) != 0)\\r\\n{\\r\\nBIO_printf(bio_out, \"Loaded: (%s) %s\\n\",\\r\\nENGINE_get_id(e), ENGINE_get_name(e));\\r\\n}\\r\\nif (list_cap)\\r\\n{\\r\\nint cap_size = 256;\\r\\nchar *cap_buf = NULL;\\r\\nint k,n;\\r\\nconst int *nids;\\r\\nENGINE_CIPHERS_PTR fn_c;\\r\\nENGINE_DIGESTS_PTR fn_d;\\r\\nif (ENGINE_get_RSA(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"RSA\",\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_DSA(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"DSA\",\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_DH(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"DH\",\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_RAND(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"RAND\",\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nfn_c = ENGINE_get_ciphers(e);\\r\\nif(!fn_c) goto skip_ciphers;\\r\\nn = fn_c(e, NULL, &nids, 0);\\r\\nfor(k=0 ; k < n ; ++k)\\r\\nif(!append_buf(&cap_buf,\\r\\nOBJ_nid2sn(nids[k]),\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nskip_ciphers:\\r\\nfn_d = ENGINE_get_digests(e);\\r\\nif(!fn_d) goto skip_digests;\\r\\nn = fn_d(e, NULL, &nids, 0);\\r\\nfor(k=0 ; k < n ; ++k)\\r\\nif(!append_buf(&cap_buf,\\r\\nOBJ_nid2sn(nids[k]),\\r\\n&cap_size, 256))\\r\\ngoto end;\\r\\nskip_digests:\\r\\nif (cap_buf && (*cap_buf != '\\0'))\\r\\nBIO_printf(bio_out, \" [%s]\\n\", cap_buf);\\r\\nOPENSSL_free(cap_buf);\\r\\n}\\r\\nif(test_avail)\\r\\n{\\r\\nBIO_printf(bio_out, \"%s\", indent);\\r\\nif (ENGINE_init(e))\\r\\n{\\r\\nBIO_printf(bio_out, \"[ available ]\\n\");\\r\\nutil_do_cmds(e, post_cmds, bio_out, indent);\\r\\nENGINE_finish(e);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_out, \"[ unavailable ]\\n\");\\r\\nif(test_avail_noise)\\r\\nERR_print_errors_fp(stdout);\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nif((verbose > 0) && !util_verbose(e, verbose, bio_out, indent))\\r\\ngoto end;\\r\\nENGINE_free(e);\\r\\n}\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nsk_pop_free(engines, identity);\\r\\nsk_pop_free(pre_cmds, identity);\\r\\nsk_pop_free(post_cmds, identity);\\r\\nif (bio_out != NULL) BIO_free_all(bio_out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_cryptodev_c", "target": 0, "func": "void\\r\\nENGINE_load_cryptodev(void)\\r\\n{\\r\\nreturn;\\r\\n}\\r\\nstatic int\\r\\nopen_dev_crypto(void)\\r\\n{\\r\\nstatic int fd = -1;\\r\\nif (fd == -1) {\\r\\nif ((fd = open(\"/dev/crypto\", O_RDWR, 0)) == -1)\\r\\nreturn (-1);\\r\\nif (fcntl(fd, F_SETFD, 1) == -1) {\\r\\nclose(fd);\\r\\nfd = -1;\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\nreturn (fd);\\r\\n}\\r\\nstatic int\\r\\nget_dev_crypto(void)\\r\\n{\\r\\nint fd, retfd;\\r\\nif ((fd = open_dev_crypto()) == -1)\\r\\nreturn (-1);\\r\\nif (ioctl(fd, CRIOGET, &retfd) == -1)\\r\\nreturn (-1);\\r\\nif (fcntl(retfd, F_SETFD, 1) == -1) {\\r\\nclose(retfd);\\r\\nreturn (-1);\\r\\n}\\r\\nreturn (retfd);\\r\\n}\\r\\nstatic int\\r\\nget_asym_dev_crypto(void)\\r\\n{\\r\\nstatic int fd = -1;\\r\\nif (fd == -1)\\r\\nfd = get_dev_crypto();\\r\\nreturn fd;\\r\\n}\\r\\nstatic int\\r\\ncryptodev_max_iv(int cipher)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; ciphers[i].id; i++)\\r\\nif (ciphers[i].id == cipher)\\r\\nreturn (ciphers[i].ivmax);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_key_length_valid(int cipher, int len)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; ciphers[i].id; i++)\\r\\nif (ciphers[i].id == cipher)\\r\\nreturn (ciphers[i].keylen == len);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int\\r\\ncipher_nid_to_cryptodev(int nid)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; ciphers[i].id; i++)\\r\\nif (ciphers[i].nid == nid)\\r\\nreturn (ciphers[i].id);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int\\r\\nget_cryptodev_ciphers(const int **cnids)\\r\\n{\\r\\nstatic int nids[CRYPTO_ALGORITHM_MAX];\\r\\nstruct session_op sess;\\r\\nint fd, i, count = 0;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\n*cnids = NULL;\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&sess, 0, sizeof(sess));\\r\\nsess.key = (caddr_t)\"123456781234567812345678\";\\r\\nfor (i = 0; ciphers[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\\r\\nif (ciphers[i].nid == NID_undef)\\r\\ncontinue;\\r\\nsess.cipher = ciphers[i].id;\\r\\nsess.keylen = ciphers[i].keylen;\\r\\nsess.mac = 0;\\r\\nif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\\r\\nioctl(fd, CIOCFSESSION, &sess.ses) != -1)\\r\\nnids[count++] = ciphers[i].nid;\\r\\n}\\r\\nclose(fd);\\r\\nif (count > 0)\\r\\n*cnids = nids;\\r\\nelse\\r\\n*cnids = NULL;\\r\\nreturn (count);\\r\\n}\\r\\nstatic int\\r\\nget_cryptodev_digests(const int **cnids)\\r\\n{\\r\\nstatic int nids[CRYPTO_ALGORITHM_MAX];\\r\\nstruct session_op sess;\\r\\nint fd, i, count = 0;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\n*cnids = NULL;\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&sess, 0, sizeof(sess));\\r\\nfor (i = 0; digests[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\\r\\nif (digests[i].nid == NID_undef)\\r\\ncontinue;\\r\\nsess.mac = digests[i].id;\\r\\nsess.cipher = 0;\\r\\nif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\\r\\nioctl(fd, CIOCFSESSION, &sess.ses) != -1)\\r\\nnids[count++] = digests[i].nid;\\r\\n}\\r\\nclose(fd);\\r\\nif (count > 0)\\r\\n*cnids = nids;\\r\\nelse\\r\\n*cnids = NULL;\\r\\nreturn (count);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_usable_ciphers(const int **nids)\\r\\n{\\r\\nreturn (get_cryptodev_ciphers(nids));\\r\\n}\\r\\nstatic int\\r\\ncryptodev_usable_digests(const int **nids)\\r\\n{\\r\\n*nids = NULL;\\r\\nreturn (0);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nstruct crypt_op cryp;\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nvoid *iiv;\\r\\nunsigned char save_iv[EVP_MAX_IV_LENGTH];\\r\\nif (state->d_fd < 0)\\r\\nreturn (0);\\r\\nif (!inl)\\r\\nreturn (1);\\r\\nif ((inl % ctx->cipher->block_size) != 0)\\r\\nreturn (0);\\r\\nmemset(&cryp, 0, sizeof(cryp));\\r\\ncryp.ses = sess->ses;\\r\\ncryp.flags = 0;\\r\\ncryp.len = inl;\\r\\ncryp.src = (caddr_t) in;\\r\\ncryp.dst = (caddr_t) out;\\r\\ncryp.mac = 0;\\r\\ncryp.op = ctx->encrypt ? COP_ENCRYPT : COP_DECRYPT;\\r\\nif (ctx->cipher->iv_len) {\\r\\ncryp.iv = (caddr_t) ctx->iv;\\r\\nif (!ctx->encrypt) {\\r\\niiv = (void *) in + inl - ctx->cipher->iv_len;\\r\\nmemcpy(save_iv, iiv, ctx->cipher->iv_len);\\r\\n}\\r\\n} else\\r\\ncryp.iv = NULL;\\r\\nif (ioctl(state->d_fd, CIOCCRYPT, &cryp) == -1) {\\r\\nreturn (0);\\r\\n}\\r\\nif (ctx->cipher->iv_len) {\\r\\nif (ctx->encrypt)\\r\\niiv = (void *) out + inl - ctx->cipher->iv_len;\\r\\nelse\\r\\niiv = save_iv;\\r\\nmemcpy(ctx->iv, iiv, ctx->cipher->iv_len);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nint cipher;\\r\\nif ((cipher = cipher_nid_to_cryptodev(ctx->cipher->nid)) == NID_undef)\\r\\nreturn (0);\\r\\nif (ctx->cipher->iv_len > cryptodev_max_iv(cipher))\\r\\nreturn (0);\\r\\nif (!cryptodev_key_length_valid(cipher, ctx->key_len))\\r\\nreturn (0);\\r\\nmemset(sess, 0, sizeof(struct session_op));\\r\\nif ((state->d_fd = get_dev_crypto()) < 0)\\r\\nreturn (0);\\r\\nsess->key = (unsigned char *)key;\\r\\nsess->keylen = ctx->key_len;\\r\\nsess->cipher = cipher;\\r\\nif (ioctl(state->d_fd, CIOCGSESSION, sess) == -1) {\\r\\nclose(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_cleanup(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nif (state->d_fd < 0)\\r\\nreturn (0);\\r\\nif (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) == -1) {\\r\\nret = 0;\\r\\n} else {\\r\\nret = 1;\\r\\n}\\r\\nclose(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!cipher)\\r\\nreturn (cryptodev_usable_ciphers(nids));\\r\\nswitch (nid) {\\r\\ncase NID_des_ede3_cbc:\\r\\n*cipher = &cryptodev_3des_cbc;\\r\\nbreak;\\r\\ncase NID_des_cbc:\\r\\n*cipher = &cryptodev_des_cbc;\\r\\nbreak;\\r\\ncase NID_bf_cbc:\\r\\n*cipher = &cryptodev_bf_cbc;\\r\\nbreak;\\r\\ncase NID_cast5_cbc:\\r\\n*cipher = &cryptodev_cast_cbc;\\r\\nbreak;\\r\\ncase NID_aes_128_cbc:\\r\\n*cipher = &cryptodev_aes_cbc;\\r\\nbreak;\\r\\ndefault:\\r\\n*cipher = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn (*cipher != NULL);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!digest)\\r\\nreturn (cryptodev_usable_digests(nids));\\r\\nswitch (nid) {\\r\\ncase NID_md5:\\r\\n*digest = NULL;\\r\\nbreak;\\r\\ndefault:\\r\\n*digest = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn (*digest != NULL);\\r\\n}\\r\\nstatic int\\r\\nbn2crparam(const BIGNUM *a, struct crparam *crp)\\r\\n{\\r\\nint i, j, k;\\r\\nssize_t words, bytes, bits;\\r\\nu_char *b;\\r\\ncrp->crp_p = NULL;\\r\\ncrp->crp_nbits = 0;\\r\\nbits = BN_num_bits(a);\\r\\nbytes = (bits + 7) / 8;\\r\\nb = malloc(bytes);\\r\\nif (b == NULL)\\r\\nreturn (1);\\r\\ncrp->crp_p = b;\\r\\ncrp->crp_nbits = bits;\\r\\nfor (i = 0, j = 0; i < a->top; i++) {\\r\\nfor (k = 0; k < BN_BITS2 / 8; k++) {\\r\\nif ((j + k) >= bytes)\\r\\nreturn (0);\\r\\nb[j + k] = a->d[i] >> (k * 8);\\r\\n}\\r\\nj += BN_BITS2 / 8;\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nstatic int\\r\\ncrparam2bn(struct crparam *crp, BIGNUM *a)\\r\\n{\\r\\nu_int8_t *pd;\\r\\nint i, bytes;\\r\\nbytes = (crp->crp_nbits + 7) / 8;\\r\\nif (bytes == 0)\\r\\nreturn (-1);\\r\\nif ((pd = (u_int8_t *) malloc(bytes)) == NULL)\\r\\nreturn (-1);\\r\\nfor (i = 0; i < bytes; i++)\\r\\npd[i] = crp->crp_p[bytes - i - 1];\\r\\nBN_bin2bn(pd, bytes, a);\\r\\nfree(pd);\\r\\nreturn (0);\\r\\n}\\r\\nstatic void\\r\\nzapparams(struct crypt_kop *kop)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i <= kop->crk_iparams + kop->crk_oparams; i++) {\\r\\nif (kop->crk_param[i].crp_p)\\r\\nfree(kop->crk_param[i].crp_p);\\r\\nkop->crk_param[i].crp_p = NULL;\\r\\nkop->crk_param[i].crp_nbits = 0;\\r\\n}\\r\\n}\\r\\nstatic int\\r\\ncryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen, BIGNUM *s)\\r\\n{\\r\\nint fd, ret = -1;\\r\\nif ((fd = get_asym_dev_crypto()) < 0)\\r\\nreturn (ret);\\r\\nif (r) {\\r\\nkop->crk_param[kop->crk_iparams].crp_p = calloc(rlen, sizeof(char));\\r\\nkop->crk_param[kop->crk_iparams].crp_nbits = rlen * 8;\\r\\nkop->crk_oparams++;\\r\\n}\\r\\nif (s) {\\r\\nkop->crk_param[kop->crk_iparams+1].crp_p = calloc(slen, sizeof(char));\\r\\nkop->crk_param[kop->crk_iparams+1].crp_nbits = slen * 8;\\r\\nkop->crk_oparams++;\\r\\n}\\r\\nif (ioctl(fd, CIOCKEY, kop) == 0) {\\r\\nif (r)\\r\\ncrparam2bn(&kop->crk_param[kop->crk_iparams], r);\\r\\nif (s)\\r\\ncrparam2bn(&kop->crk_param[kop->crk_iparams+1], s);\\r\\nret = 0;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint ret = 1;\\r\\nif (cryptodev_asymfeat == 0) {\\r\\nret = BN_mod_exp(r, a, p, m, ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_MOD_EXP;\\r\\nif (bn2crparam(a, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(m, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 3;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL) == -1) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);\\r\\n}\\r\\nerr:\\r\\nzapparams(&kop);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nint r;\\r\\nBN_CTX *ctx;\\r\\nctx = BN_CTX_new();\\r\\nr = cryptodev_bn_mod_exp(r0, I, rsa->d, rsa->n, ctx, NULL);\\r\\nBN_CTX_free(ctx);\\r\\nreturn (r);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint ret = 1;\\r\\nif (!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) {\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_MOD_EXP_CRT;\\r\\nif (bn2crparam(rsa->p, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->q, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(I, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->dmp1, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->dmq1, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->iqmp, &kop.crk_param[5]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 6;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL) == -1) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nret = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);\\r\\n}\\r\\nerr:\\r\\nzapparams(&kop);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,\\r\\nBIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,\\r\\nBN_CTX *ctx, BN_MONT_CTX *mont)\\r\\n{\\r\\nBIGNUM t2;\\r\\nint ret = 0;\\r\\nBN_init(&t2);\\r\\nret = 0;\\r\\nif (!dsa->meth->bn_mod_exp(dsa,t1,dsa->g,u1,dsa->p,ctx,mont))\\r\\ngoto err;\\r\\nif (!dsa->meth->bn_mod_exp(dsa,&t2,dsa->pub_key,u2,dsa->p,ctx,mont))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(u1,t1,&t2,dsa->p,ctx))\\r\\ngoto err;\\r\\nBN_copy(t1,u1);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_free(&t2);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic DSA_SIG *\\r\\ncryptodev_dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nBIGNUM *r = NULL, *s = NULL;\\r\\nDSA_SIG *dsaret = NULL;\\r\\nif ((r = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif ((s = BN_new()) == NULL) {\\r\\nBN_free(r);\\r\\ngoto err;\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DSA_SIGN;\\r\\nkop.crk_param[0].crp_p = (caddr_t)dgst;\\r\\nkop.crk_param[0].crp_nbits = dlen * 8;\\r\\nif (bn2crparam(dsa->p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->q, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->g, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->priv_key, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 5;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(dsa->q), r,\\r\\nBN_num_bytes(dsa->q), s) == 0) {\\r\\ndsaret = DSA_SIG_new();\\r\\ndsaret->r = r;\\r\\ndsaret->s = s;\\r\\n} else {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\nBN_free(r);\\r\\nBN_free(s);\\r\\ndsaret = (meth->dsa_do_sign)(dgst, dlen, dsa);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[0].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dsaret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_verify(const unsigned char *dgst, int dlen,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint dsaret = 1;\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DSA_VERIFY;\\r\\nkop.crk_param[0].crp_p = (caddr_t)dgst;\\r\\nkop.crk_param[0].crp_nbits = dlen * 8;\\r\\nif (bn2crparam(dsa->p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->q, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->g, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->pub_key, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nif (bn2crparam(sig->r, &kop.crk_param[5]))\\r\\ngoto err;\\r\\nif (bn2crparam(sig->s, &kop.crk_param[6]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 7;\\r\\nif (cryptodev_asym(&kop, 0, NULL, 0, NULL) == 0) {\\r\\ndsaret = kop.crk_status;\\r\\n} else {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\ndsaret = (meth->dsa_do_verify)(dgst, dlen, sig, dsa);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[0].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dsaret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint dhret = 1;\\r\\nint fd, keylen;\\r\\nif ((fd = get_asym_dev_crypto()) < 0) {\\r\\nconst DH_METHOD *meth = DH_OpenSSL();\\r\\nreturn ((meth->compute_key)(key, pub_key, dh));\\r\\n}\\r\\nkeylen = BN_num_bits(dh->p);\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DH_COMPUTE_KEY;\\r\\nif (bn2crparam(dh->priv_key, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(pub_key, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dh->p, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 3;\\r\\nkop.crk_param[3].crp_p = key;\\r\\nkop.crk_param[3].crp_nbits = keylen * 8;\\r\\nkop.crk_oparams = 1;\\r\\nif (ioctl(fd, CIOCKEY, &kop) == -1) {\\r\\nconst DH_METHOD *meth = DH_OpenSSL();\\r\\ndhret = (meth->compute_key)(key, pub_key, dh);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[3].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dhret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())\\r\\n{\\r\\n#ifdef HAVE_SYSLOG_R\\r\\nstruct syslog_data sd = SYSLOG_DATA_INIT;\\r\\n#endif\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\n#ifdef HAVE_SYSLOG_R\\r\\nsyslog_r(LOG_ERR, &sd,\\r\\n\"cryptodev_ctrl: unknown command %d\", cmd);\\r\\n#else\\r\\nsyslog(LOG_ERR, \"cryptodev_ctrl: unknown command %d\", cmd);\\r\\n#endif\\r\\nbreak;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid\\r\\nENGINE_load_cryptodev(void)\\r\\n{\\r\\nENGINE *engine = ENGINE_new();\\r\\nint fd;\\r\\nif (engine == NULL)\\r\\nreturn;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nif (ioctl(fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {\\r\\nclose(fd);\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nclose(fd);\\r\\nif (!ENGINE_set_id(engine, \"cryptodev\") ||\\r\\n!ENGINE_set_name(engine, \"BSD cryptodev engine\") ||\\r\\n!ENGINE_set_ciphers(engine, cryptodev_engine_ciphers) ||\\r\\n!ENGINE_set_digests(engine, cryptodev_engine_digests) ||\\r\\n!ENGINE_set_ctrl_function(engine, cryptodev_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(engine, cryptodev_defns)) {\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nif (ENGINE_set_RSA(engine, &cryptodev_rsa)) {\\r\\nconst RSA_METHOD *rsa_meth = RSA_PKCS1_SSLeay();\\r\\ncryptodev_rsa.bn_mod_exp = rsa_meth->bn_mod_exp;\\r\\ncryptodev_rsa.rsa_mod_exp = rsa_meth->rsa_mod_exp;\\r\\ncryptodev_rsa.rsa_pub_enc = rsa_meth->rsa_pub_enc;\\r\\ncryptodev_rsa.rsa_pub_dec = rsa_meth->rsa_pub_dec;\\r\\ncryptodev_rsa.rsa_priv_enc = rsa_meth->rsa_priv_enc;\\r\\ncryptodev_rsa.rsa_priv_dec = rsa_meth->rsa_priv_dec;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_rsa.bn_mod_exp = cryptodev_bn_mod_exp;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP_CRT)\\r\\ncryptodev_rsa.rsa_mod_exp =\\r\\ncryptodev_rsa_mod_exp;\\r\\nelse\\r\\ncryptodev_rsa.rsa_mod_exp =\\r\\ncryptodev_rsa_nocrt_mod_exp;\\r\\n}\\r\\n}\\r\\nif (ENGINE_set_DSA(engine, &cryptodev_dsa)) {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\nmemcpy(&cryptodev_dsa, meth, sizeof(DSA_METHOD));\\r\\nif (cryptodev_asymfeat & CRF_DSA_SIGN)\\r\\ncryptodev_dsa.dsa_do_sign = cryptodev_dsa_do_sign;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_dsa.bn_mod_exp = cryptodev_dsa_bn_mod_exp;\\r\\ncryptodev_dsa.dsa_mod_exp = cryptodev_dsa_dsa_mod_exp;\\r\\n}\\r\\nif (cryptodev_asymfeat & CRF_DSA_VERIFY)\\r\\ncryptodev_dsa.dsa_do_verify = cryptodev_dsa_verify;\\r\\n}\\r\\nif (ENGINE_set_DH(engine, &cryptodev_dh)){\\r\\nconst DH_METHOD *dh_meth = DH_OpenSSL();\\r\\ncryptodev_dh.generate_key = dh_meth->generate_key;\\r\\ncryptodev_dh.compute_key = dh_meth->compute_key;\\r\\ncryptodev_dh.bn_mod_exp = dh_meth->bn_mod_exp;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_dh.bn_mod_exp = cryptodev_mod_exp_dh;\\r\\nif (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY)\\r\\ncryptodev_dh.compute_key =\\r\\ncryptodev_dh_compute_key;\\r\\n}\\r\\n}\\r\\nENGINE_add(engine);\\r\\nENGINE_free(engine);\\r\\nERR_clear_error();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_ubsec_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n#ifndef HAVE_UBSEC_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_ubsec_id) ||\\r\\n!ENGINE_set_name(e, engine_ubsec_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &ubsec_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &ubsec_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &ubsec_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_destroy_function(e, ubsec_destroy) ||\\r\\n!ENGINE_set_init_function(e, ubsec_init) ||\\r\\n!ENGINE_set_finish_function(e, ubsec_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, ubsec_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, ubsec_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\nubsec_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\nubsec_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\nubsec_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\nubsec_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n#ifndef HAVE_UBSEC_DH\\r\\nmeth3 = DH_OpenSSL();\\r\\nubsec_dh.generate_key = meth3->generate_key;\\r\\nubsec_dh.compute_key = meth3->compute_key;\\r\\n#endif\\r\\n#endif\\r\\nERR_load_UBSEC_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_ubsec(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_ubsec(void)\\r\\n{\\r\\nENGINE *toadd = engine_ubsec();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic const char *get_UBSEC_LIBNAME(void)\\r\\n{\\r\\nif(UBSEC_LIBNAME)\\r\\nreturn UBSEC_LIBNAME;\\r\\nreturn \"ubsec\";\\r\\n}\\r\\nstatic void free_UBSEC_LIBNAME(void)\\r\\n{\\r\\nif(UBSEC_LIBNAME)\\r\\nOPENSSL_free((void*)UBSEC_LIBNAME);\\r\\nUBSEC_LIBNAME = NULL;\\r\\n}\\r\\nstatic long set_UBSEC_LIBNAME(const char *name)\\r\\n{\\r\\nfree_UBSEC_LIBNAME();\\r\\nreturn (((UBSEC_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int ubsec_destroy(ENGINE *e)\\r\\n{\\r\\nfree_UBSEC_LIBNAME();\\r\\nERR_unload_UBSEC_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ubsec_init(ENGINE *e)\\r\\n{\\r\\nt_UBSEC_ubsec_bytes_to_bits *p1;\\r\\nt_UBSEC_ubsec_bits_to_bytes *p2;\\r\\nt_UBSEC_ubsec_open *p3;\\r\\nt_UBSEC_ubsec_close *p4;\\r\\n#ifndef OPENSSL_NO_DH\\r\\nt_UBSEC_diffie_hellman_generate_ioctl *p5;\\r\\nt_UBSEC_diffie_hellman_agree_ioctl *p6;\\r\\n#endif\\r\\nt_UBSEC_rsa_mod_exp_ioctl *p7;\\r\\nt_UBSEC_rsa_mod_exp_crt_ioctl *p8;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nt_UBSEC_dsa_sign_ioctl *p9;\\r\\nt_UBSEC_dsa_verify_ioctl *p10;\\r\\n#endif\\r\\nt_UBSEC_math_accelerate_ioctl *p11;\\r\\nt_UBSEC_rng_ioctl *p12;\\r\\nt_UBSEC_max_key_len_ioctl *p13;\\r\\nint fd = 0;\\r\\nif(ubsec_dso != NULL)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nubsec_dso = DSO_load(NULL, get_UBSEC_LIBNAME(), NULL, 0);\\r\\nif(ubsec_dso == NULL)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (\\r\\n!(p1 = (t_UBSEC_ubsec_bytes_to_bits *) DSO_bind_func(ubsec_dso, UBSEC_F1)) ||\\r\\n!(p2 = (t_UBSEC_ubsec_bits_to_bytes *) DSO_bind_func(ubsec_dso, UBSEC_F2)) ||\\r\\n!(p3 = (t_UBSEC_ubsec_open *) DSO_bind_func(ubsec_dso, UBSEC_F3)) ||\\r\\n!(p4 = (t_UBSEC_ubsec_close *) DSO_bind_func(ubsec_dso, UBSEC_F4)) ||\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!(p5 = (t_UBSEC_diffie_hellman_generate_ioctl *)\\r\\nDSO_bind_func(ubsec_dso, UBSEC_F5)) ||\\r\\n!(p6 = (t_UBSEC_diffie_hellman_agree_ioctl *)\\r\\nDSO_bind_func(ubsec_dso, UBSEC_F6)) ||\\r\\n#endif\\r\\n!(p7 = (t_UBSEC_rsa_mod_exp_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F7)) ||\\r\\n!(p8 = (t_UBSEC_rsa_mod_exp_crt_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F8)) ||\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!(p9 = (t_UBSEC_dsa_sign_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F9)) ||\\r\\n!(p10 = (t_UBSEC_dsa_verify_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F10)) ||\\r\\n#endif\\r\\n!(p11 = (t_UBSEC_math_accelerate_ioctl *)\\r\\nDSO_bind_func(ubsec_dso, UBSEC_F11)) ||\\r\\n!(p12 = (t_UBSEC_rng_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F12)) ||\\r\\n!(p13 = (t_UBSEC_max_key_len_ioctl *) DSO_bind_func(ubsec_dso, UBSEC_F13)))\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_bytes_to_bits = p1;\\r\\np_UBSEC_ubsec_bits_to_bytes = p2;\\r\\np_UBSEC_ubsec_open = p3;\\r\\np_UBSEC_ubsec_close = p4;\\r\\n#ifndef OPENSSL_NO_DH\\r\\np_UBSEC_diffie_hellman_generate_ioctl = p5;\\r\\np_UBSEC_diffie_hellman_agree_ioctl = p6;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_UBSEC_rsa_mod_exp_ioctl = p7;\\r\\np_UBSEC_rsa_mod_exp_crt_ioctl = p8;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\np_UBSEC_dsa_sign_ioctl = p9;\\r\\np_UBSEC_dsa_verify_ioctl = p10;\\r\\n#endif\\r\\np_UBSEC_math_accelerate_ioctl = p11;\\r\\np_UBSEC_rng_ioctl = p12;\\r\\np_UBSEC_max_key_len_ioctl = p13;\\r\\nif (((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) > 0) && (p_UBSEC_max_key_len_ioctl(fd, &max_key_len) == 0))\\r\\n{\\r\\np_UBSEC_ubsec_close(fd);\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE);\\r\\n}\\r\\nerr:\\r\\nif(ubsec_dso)\\r\\nDSO_free(ubsec_dso);\\r\\nubsec_dso = NULL;\\r\\np_UBSEC_ubsec_bytes_to_bits = NULL;\\r\\np_UBSEC_ubsec_bits_to_bytes = NULL;\\r\\np_UBSEC_ubsec_open = NULL;\\r\\np_UBSEC_ubsec_close = NULL;\\r\\n#ifndef OPENSSL_NO_DH\\r\\np_UBSEC_diffie_hellman_generate_ioctl = NULL;\\r\\np_UBSEC_diffie_hellman_agree_ioctl = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_UBSEC_rsa_mod_exp_ioctl = NULL;\\r\\np_UBSEC_rsa_mod_exp_crt_ioctl = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\np_UBSEC_dsa_sign_ioctl = NULL;\\r\\np_UBSEC_dsa_verify_ioctl = NULL;\\r\\n#endif\\r\\np_UBSEC_math_accelerate_ioctl = NULL;\\r\\np_UBSEC_rng_ioctl = NULL;\\r\\np_UBSEC_max_key_len_ioctl = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ubsec_finish(ENGINE *e)\\r\\n{\\r\\nfree_UBSEC_LIBNAME();\\r\\nif(ubsec_dso == NULL)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_FINISH, UBSEC_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(ubsec_dso))\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_FINISH, UBSEC_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nubsec_dso = NULL;\\r\\np_UBSEC_ubsec_bytes_to_bits = NULL;\\r\\np_UBSEC_ubsec_bits_to_bytes = NULL;\\r\\np_UBSEC_ubsec_open = NULL;\\r\\np_UBSEC_ubsec_close = NULL;\\r\\n#ifndef OPENSSL_NO_DH\\r\\np_UBSEC_diffie_hellman_generate_ioctl = NULL;\\r\\np_UBSEC_diffie_hellman_agree_ioctl = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_UBSEC_rsa_mod_exp_ioctl = NULL;\\r\\np_UBSEC_rsa_mod_exp_crt_ioctl = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\np_UBSEC_dsa_sign_ioctl = NULL;\\r\\np_UBSEC_dsa_verify_ioctl = NULL;\\r\\n#endif\\r\\np_UBSEC_math_accelerate_ioctl = NULL;\\r\\np_UBSEC_rng_ioctl = NULL;\\r\\np_UBSEC_max_key_len_ioctl = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ubsec_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((ubsec_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase UBSEC_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_CTRL,UBSEC_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_UBSEC_LIBNAME((const char *)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nUBSECerr(UBSEC_F_UBSEC_CTRL,UBSEC_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ubsec_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint y_len = 0;\\r\\nint fd;\\r\\nif(ubsec_dso == NULL)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\ny_len = BN_num_bits(m);\\r\\nif (y_len > max_key_len) {\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nif(!bn_wexpand(r, m->top))\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_BN_EXPAND_FAIL);\\r\\nreturn 0;\\r\\n}\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\\r\\nfd = 0;\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_UNIT_FAILURE);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nif (p_UBSEC_rsa_mod_exp_ioctl(fd, (unsigned char *)a->d, BN_num_bits(a),\\r\\n(unsigned char *)m->d, BN_num_bits(m), (unsigned char *)p->d,\\r\\nBN_num_bits(p), (unsigned char *)r->d, &y_len) != 0)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nreturn BN_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nr->top = (BN_num_bits(m)+BN_BITS2-1)/BN_BITS2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ubsec_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint to_return = 0;\\r\\nif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\\r\\n{\\r\\nUBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP, UBSEC_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nto_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\\r\\nrsa->dmq1, rsa->iqmp, ctx);\\r\\nif (to_return == FAIL_TO_SOFTWARE)\\r\\n{\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nto_return = (*meth->rsa_mod_exp)(r0, I, rsa, ctx);\\r\\n}\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ubsec_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *q, const BIGNUM *dp,\\r\\nconst BIGNUM *dq, const BIGNUM *qinv, BN_CTX *ctx)\\r\\n{\\r\\nint y_len,\\r\\nm_len,\\r\\nfd;\\r\\nm_len = BN_num_bytes(p) + BN_num_bytes(q) + 1;\\r\\ny_len = BN_num_bits(p) + BN_num_bits(q);\\r\\nif (y_len > max_key_len) {\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP_CRT, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn FAIL_TO_SOFTWARE;\\r\\n}\\r\\nif (!bn_wexpand(r, p->top + q->top + 1)) {\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP_CRT, UBSEC_R_BN_EXPAND_FAIL);\\r\\nreturn 0;\\r\\n}\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\\r\\nfd = 0;\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP_CRT, UBSEC_R_UNIT_FAILURE);\\r\\nreturn FAIL_TO_SOFTWARE;\\r\\n}\\r\\nif (p_UBSEC_rsa_mod_exp_crt_ioctl(fd,\\r\\n(unsigned char *)a->d, BN_num_bits(a),\\r\\n(unsigned char *)qinv->d, BN_num_bits(qinv),\\r\\n(unsigned char *)dp->d, BN_num_bits(dp),\\r\\n(unsigned char *)p->d, BN_num_bits(p),\\r\\n(unsigned char *)dq->d, BN_num_bits(dq),\\r\\n(unsigned char *)q->d, BN_num_bits(q),\\r\\n(unsigned char *)r->d, &y_len) != 0) {\\r\\nUBSECerr(UBSEC_F_UBSEC_MOD_EXP_CRT, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nreturn FAIL_TO_SOFTWARE;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nr->top = (BN_num_bits(p) + BN_num_bits(q) + BN_BITS2 - 1)/BN_BITS2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ubsec_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!ubsec_mod_exp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!ubsec_mod_exp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ubsec_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn ubsec_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int ubsec_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nint ret = 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (BN_num_bits(m) > max_key_len)\\r\\n{\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nret = (*meth->bn_mod_exp)(r, a, p, m, ctx, m_ctx);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nret = ubsec_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ubsec_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn ubsec_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic DSA_SIG *ubsec_dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *to_return = NULL;\\r\\nint s_len = 160, r_len = 160, d_len, fd;\\r\\nBIGNUM m, *r=NULL, *s=NULL;\\r\\nBN_init(&m);\\r\\ns = BN_new();\\r\\nr = BN_new();\\r\\nif ((s == NULL) || (r==NULL))\\r\\ngoto err;\\r\\nd_len = p_UBSEC_ubsec_bytes_to_bits((unsigned char *)dgst, dlen);\\r\\nif(!bn_wexpand(r, (160+BN_BITS2-1)/BN_BITS2) ||\\r\\n(!bn_wexpand(s, (160+BN_BITS2-1)/BN_BITS2))) {\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_DO_SIGN, UBSEC_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_bin2bn(dgst,dlen,&m) == NULL) {\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_DO_SIGN, UBSEC_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\\r\\nconst DSA_METHOD *meth;\\r\\nfd = 0;\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_DO_SIGN, UBSEC_R_UNIT_FAILURE);\\r\\nmeth = DSA_OpenSSL();\\r\\nto_return = meth->dsa_do_sign(dgst, dlen, dsa);\\r\\ngoto err;\\r\\n}\\r\\nif (p_UBSEC_dsa_sign_ioctl(fd, 0,\\r\\n(unsigned char *)dgst, d_len,\\r\\nNULL, 0,\\r\\n(unsigned char *)dsa->p->d, BN_num_bits(dsa->p),\\r\\n(unsigned char *)dsa->q->d, BN_num_bits(dsa->q),\\r\\n(unsigned char *)dsa->g->d, BN_num_bits(dsa->g),\\r\\n(unsigned char *)dsa->priv_key->d, BN_num_bits(dsa->priv_key),\\r\\n(unsigned char *)r->d, &r_len,\\r\\n(unsigned char *)s->d, &s_len ) != 0) {\\r\\nconst DSA_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_DO_SIGN, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nmeth = DSA_OpenSSL();\\r\\nto_return = meth->dsa_do_sign(dgst, dlen, dsa);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nr->top = (160+BN_BITS2-1)/BN_BITS2;\\r\\ns->top = (160+BN_BITS2-1)/BN_BITS2;\\r\\nto_return = DSA_SIG_new();\\r\\nif(to_return == NULL) {\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_DO_SIGN, UBSEC_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nto_return->r = r;\\r\\nto_return->s = s;\\r\\nerr:\\r\\nif (!to_return) {\\r\\nif (r) BN_free(r);\\r\\nif (s) BN_free(s);\\r\\n}\\r\\nBN_clear_free(&m);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ubsec_dsa_verify(const unsigned char *dgst, int dgst_len,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nint v_len, d_len;\\r\\nint to_return = 0;\\r\\nint fd;\\r\\nBIGNUM v;\\r\\nBN_init(&v);\\r\\nif(!bn_wexpand(&v, dsa->p->top)) {\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_VERIFY, UBSEC_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nv_len = BN_num_bits(dsa->p);\\r\\nd_len = p_UBSEC_ubsec_bytes_to_bits((unsigned char *)dgst, dgst_len);\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\\r\\nconst DSA_METHOD *meth;\\r\\nfd = 0;\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_VERIFY, UBSEC_R_UNIT_FAILURE);\\r\\nmeth = DSA_OpenSSL();\\r\\nto_return = meth->dsa_do_verify(dgst, dgst_len, sig, dsa);\\r\\ngoto err;\\r\\n}\\r\\nif (p_UBSEC_dsa_verify_ioctl(fd, 0,\\r\\n(unsigned char *)dgst, d_len,\\r\\n(unsigned char *)dsa->p->d, BN_num_bits(dsa->p),\\r\\n(unsigned char *)dsa->q->d, BN_num_bits(dsa->q),\\r\\n(unsigned char *)dsa->g->d, BN_num_bits(dsa->g),\\r\\n(unsigned char *)dsa->pub_key->d, BN_num_bits(dsa->pub_key),\\r\\n(unsigned char *)sig->r->d, BN_num_bits(sig->r),\\r\\n(unsigned char *)sig->s->d, BN_num_bits(sig->s),\\r\\n(unsigned char *)v.d, &v_len) != 0) {\\r\\nconst DSA_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DSA_VERIFY, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nmeth = DSA_OpenSSL();\\r\\nto_return = meth->dsa_do_verify(dgst, dgst_len, sig, dsa);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nto_return = 1;\\r\\nerr:\\r\\nBN_clear_free(&v);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int ubsec_dh_compute_key(unsigned char *key,const BIGNUM *pub_key,DH *dh)\\r\\n{\\r\\nint ret = -1,\\r\\nk_len,\\r\\nfd;\\r\\nk_len = BN_num_bits(dh->p);\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0)\\r\\n{\\r\\nconst DH_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DH_COMPUTE_KEY, UBSEC_R_UNIT_FAILURE);\\r\\nmeth = DH_OpenSSL();\\r\\nret = meth->compute_key(key, pub_key, dh);\\r\\ngoto err;\\r\\n}\\r\\nif (p_UBSEC_diffie_hellman_agree_ioctl(fd,\\r\\n(unsigned char *)dh->priv_key->d, BN_num_bits(dh->priv_key),\\r\\n(unsigned char *)pub_key->d, BN_num_bits(pub_key),\\r\\n(unsigned char *)dh->p->d, BN_num_bits(dh->p),\\r\\nkey, &k_len) != 0)\\r\\n{\\r\\nconst DH_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DH_COMPUTE_KEY, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nmeth = DH_OpenSSL();\\r\\nret = meth->compute_key(key, pub_key, dh);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nret = p_UBSEC_ubsec_bits_to_bytes(k_len);\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ubsec_dh_generate_key(DH *dh)\\r\\n{\\r\\nint ret = 0,\\r\\nrandom_bits = 0,\\r\\npub_key_len = 0,\\r\\npriv_key_len = 0,\\r\\nfd;\\r\\nBIGNUM *pub_key = NULL;\\r\\nBIGNUM *priv_key = NULL;\\r\\nif (dh->priv_key == NULL)\\r\\n{\\r\\npriv_key = BN_new();\\r\\nif (priv_key == NULL) goto err;\\r\\npriv_key_len = BN_num_bits(dh->p);\\r\\nbn_wexpand(priv_key, dh->p->top);\\r\\ndo\\r\\nif (!BN_rand_range(priv_key, dh->p)) goto err;\\r\\nwhile (BN_is_zero(priv_key));\\r\\nrandom_bits = BN_num_bits(priv_key);\\r\\n}\\r\\nelse\\r\\n{\\r\\npriv_key = dh->priv_key;\\r\\n}\\r\\nif (dh->pub_key == NULL)\\r\\n{\\r\\npub_key = BN_new();\\r\\npub_key_len = BN_num_bits(dh->p);\\r\\nbn_wexpand(pub_key, dh->p->top);\\r\\nif(pub_key == NULL) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\npub_key = dh->pub_key;\\r\\n}\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0)\\r\\n{\\r\\nconst DH_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DH_GENERATE_KEY, UBSEC_R_UNIT_FAILURE);\\r\\nmeth = DH_OpenSSL();\\r\\nret = meth->generate_key(dh);\\r\\ngoto err;\\r\\n}\\r\\nif (p_UBSEC_diffie_hellman_generate_ioctl(fd,\\r\\n(unsigned char *)priv_key->d, &priv_key_len,\\r\\n(unsigned char *)pub_key->d, &pub_key_len,\\r\\n(unsigned char *)dh->g->d, BN_num_bits(dh->g),\\r\\n(unsigned char *)dh->p->d, BN_num_bits(dh->p),\\r\\n0, 0, random_bits) != 0)\\r\\n{\\r\\nconst DH_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_DH_GENERATE_KEY, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nmeth = DH_OpenSSL();\\r\\nret = meth->generate_key(dh);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\ndh->pub_key = pub_key;\\r\\ndh->pub_key->top = (pub_key_len + BN_BITS2-1) / BN_BITS2;\\r\\ndh->priv_key = priv_key;\\r\\ndh->priv_key->top = (priv_key_len + BN_BITS2-1) / BN_BITS2;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ubsec_rand_bytes(unsigned char * buf,\\r\\nint num)\\r\\n{\\r\\nint ret = 0,\\r\\nfd;\\r\\nif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0)\\r\\n{\\r\\nconst RAND_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_RAND_BYTES, UBSEC_R_UNIT_FAILURE);\\r\\nnum = p_UBSEC_ubsec_bits_to_bytes(num);\\r\\nmeth = RAND_SSLeay();\\r\\nmeth->seed(buf, num);\\r\\nret = meth->bytes(buf, num);\\r\\ngoto err;\\r\\n}\\r\\nnum *= 8;\\r\\nif (p_UBSEC_rng_ioctl(fd,\\r\\nUBSEC_RNG_DIRECT,\\r\\nbuf,\\r\\n&num) != 0)\\r\\n{\\r\\nconst RAND_METHOD *meth;\\r\\nUBSECerr(UBSEC_F_UBSEC_RAND_BYTES, UBSEC_R_REQUEST_FAILED);\\r\\np_UBSEC_ubsec_close(fd);\\r\\nnum = p_UBSEC_ubsec_bits_to_bytes(num);\\r\\nmeth = RAND_SSLeay();\\r\\nmeth->seed(buf, num);\\r\\nret = meth->bytes(buf, num);\\r\\ngoto err;\\r\\n}\\r\\np_UBSEC_ubsec_close(fd);\\r\\nret = 1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ubsec_rand_status(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_ubsec_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nint ret = 1;\\r\\nEC_KEY *eckey = NULL;\\r\\nconst EC_GROUP *group;\\r\\nint i, badops = 0;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, text=0, noout=0;\\r\\nint pubin = 0, pubout = 0, param_out = 0;\\r\\nchar *infile, *outfile, *prog, *engine;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\npoint_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nint new_form = 0;\\r\\nint asn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nint new_asn1_flag = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nengine = NULL;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv, \"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-conv_form\") == 0)\\r\\n{\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_form = 1;\\r\\nif (strcmp(*argv, \"compressed\") == 0)\\r\\nform = POINT_CONVERSION_COMPRESSED;\\r\\nelse if (strcmp(*argv, \"uncompressed\") == 0)\\r\\nform = POINT_CONVERSION_UNCOMPRESSED;\\r\\nelse if (strcmp(*argv, \"hybrid\") == 0)\\r\\nform = POINT_CONVERSION_HYBRID;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-param_enc\") == 0)\\r\\n{\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_asn1_flag = 1;\\r\\nif (strcmp(*argv, \"named_curve\") == 0)\\r\\nasn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nelse if (strcmp(*argv, \"explicit\") == 0)\\r\\nasn1_flag = 0;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-param_out\") == 0)\\r\\nparam_out = 1;\\r\\nelse if (strcmp(*argv, \"-pubin\") == 0)\\r\\npubin=1;\\r\\nelse if (strcmp(*argv, \"-pubout\") == 0)\\r\\npubout=1;\\r\\nelse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - \"\\r\\n\"DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - \"\\r\\n\"DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -passin arg input file pass \"\\r\\n\"phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err, \" -passout arg output file pass \"\\r\\n\"phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -engine e use engine e, \"\\r\\n\"possibly a hardware device.\\n\");\\r\\nBIO_printf(bio_err, \" -des encrypt PEM output, \"\\r\\n\"instead of 'des' every other \\n\"\\r\\n\" cipher \"\\r\\n\"supported by OpenSSL can be used\\n\");\\r\\nBIO_printf(bio_err, \" -text print the key\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err, \" -param_out print the elliptic \"\\r\\n\"curve parameters\\n\");\\r\\nBIO_printf(bio_err, \" -conv_form arg specifies the \"\\r\\n\"point conversion form \\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" compressed\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" uncompressed (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" hybrid\\n\");\\r\\nBIO_printf(bio_err, \" -param_enc arg specifies the way\"\\r\\n\" the ec parameters are encoded\\n\");\\r\\nBIO_printf(bio_err, \" in the asn1 der \"\\r\\n\"encoding\\n\");\\r\\nBIO_printf(bio_err, \" possilbe values:\"\\r\\n\" named_curve (default)\\n\");\\r\\nBIO_printf(bio_err,\" \"\\r\\n\"explicit\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(!app_passwd(bio_err, passargin, passargout, &passin, &passout))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in, infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"read EC key\\n\");\\r\\nif (informat == FORMAT_ASN1)\\r\\n{\\r\\nif (pubin)\\r\\neckey = d2i_EC_PUBKEY_bio(in, NULL);\\r\\nelse\\r\\neckey = d2i_ECPrivateKey_bio(in, NULL);\\r\\n}\\r\\nelse if (informat == FORMAT_PEM)\\r\\n{\\r\\nif (pubin)\\r\\neckey = PEM_read_bio_EC_PUBKEY(in, NULL, NULL,\\r\\nNULL);\\r\\nelse\\r\\neckey = PEM_read_bio_ECPrivateKey(in, NULL, NULL,\\r\\npassin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (eckey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out, outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\nif (new_form)\\r\\nEC_KEY_set_conv_form(eckey, form);\\r\\nif (new_asn1_flag)\\r\\nEC_KEY_set_asn1_flag(eckey, asn1_flag);\\r\\nif (text)\\r\\nif (!EC_KEY_print(out, eckey, 0))\\r\\n{\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (noout)\\r\\ngoto end;\\r\\nBIO_printf(bio_err, \"writing EC key\\n\");\\r\\nif (outformat == FORMAT_ASN1)\\r\\n{\\r\\nif (param_out)\\r\\ni = i2d_ECPKParameters_bio(out, group);\\r\\nelse if (pubin || pubout)\\r\\ni = i2d_EC_PUBKEY_bio(out, eckey);\\r\\nelse\\r\\ni = i2d_ECPrivateKey_bio(out, eckey);\\r\\n}\\r\\nelse if (outformat == FORMAT_PEM)\\r\\n{\\r\\nif (param_out)\\r\\ni = PEM_write_bio_ECPKParameters(out, group);\\r\\nelse if (pubin || pubout)\\r\\ni = PEM_write_bio_EC_PUBKEY(out, eckey);\\r\\nelse\\r\\ni = PEM_write_bio_ECPrivateKey(out, eckey, enc,\\r\\nNULL, 0, NULL, passout);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"bad output format specified for \"\\r\\n\"outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err, \"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nend:\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_print_c", "target": 0, "func": "char *BN_bn2hex(const BIGNUM *a)\\r\\n{\\r\\nint i,j,v,z=0;\\r\\nchar *buf;\\r\\nchar *p;\\r\\nbuf=(char *)OPENSSL_malloc(a->top*BN_BYTES*2+2);\\r\\nif (buf == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_BN2HEX,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf;\\r\\nif (a->neg) *(p++)='-';\\r\\nif (BN_is_zero(a)) *(p++)='0';\\r\\nfor (i=a->top-1; i >=0; i--)\\r\\n{\\r\\nfor (j=BN_BITS2-8; j >= 0; j-=8)\\r\\n{\\r\\nv=((int)(a->d[i]>>(long)j))&0xff;\\r\\nif (z || (v != 0))\\r\\n{\\r\\n*(p++)=Hex[v>>4];\\r\\n*(p++)=Hex[v&0x0f];\\r\\nz=1;\\r\\n}\\r\\n}\\r\\n}\\r\\n*p='\\0';\\r\\nerr:\\r\\nreturn(buf);\\r\\n}\\r\\nchar *BN_bn2dec(const BIGNUM *a)\\r\\n{\\r\\nint i=0,num, ok = 0;\\r\\nchar *buf=NULL;\\r\\nchar *p;\\r\\nBIGNUM *t=NULL;\\r\\nBN_ULONG *bn_data=NULL,*lp;\\r\\ni=BN_num_bits(a)*3;\\r\\nnum=(i/10+i/1000+1)+1;\\r\\nbn_data=(BN_ULONG *)OPENSSL_malloc((num/BN_DEC_NUM+1)*sizeof(BN_ULONG));\\r\\nbuf=(char *)OPENSSL_malloc(num+3);\\r\\nif ((buf == NULL) || (bn_data == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BN2DEC,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((t=BN_dup(a)) == NULL) goto err;\\r\\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\\r\\np=buf;\\r\\nlp=bn_data;\\r\\nif (BN_is_zero(t))\\r\\n{\\r\\n*(p++)='0';\\r\\n*(p++)='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_is_negative(t))\\r\\n*p++ = '-';\\r\\ni=0;\\r\\nwhile (!BN_is_zero(t))\\r\\n{\\r\\n*lp=BN_div_word(t,BN_DEC_CONV);\\r\\nlp++;\\r\\n}\\r\\nlp--;\\r\\nBIO_snprintf(p,BUF_REMAIN,BN_DEC_FMT1,*lp);\\r\\nwhile (*p) p++;\\r\\nwhile (lp != bn_data)\\r\\n{\\r\\nlp--;\\r\\nBIO_snprintf(p,BUF_REMAIN,BN_DEC_FMT2,*lp);\\r\\nwhile (*p) p++;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (bn_data != NULL) OPENSSL_free(bn_data);\\r\\nif (t != NULL) BN_free(t);\\r\\nif (!ok && buf)\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nbuf = NULL;\\r\\n}\\r\\nreturn(buf);\\r\\n}\\r\\nint BN_hex2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret=NULL;\\r\\nBN_ULONG l=0;\\r\\nint neg=0,h,m,i,j,k,c;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0')) return(0);\\r\\nif (*a == '-') { neg=1; a++; }\\r\\nfor (i=0; isxdigit((unsigned char) a[i]); i++)\\r\\n;\\r\\nnum=i+neg;\\r\\nif (bn == NULL) return(num);\\r\\nif (*bn == NULL)\\r\\n{\\r\\nif ((ret=BN_new()) == NULL) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret,i*4) == NULL) goto err;\\r\\nj=i;\\r\\nm=0;\\r\\nh=0;\\r\\nwhile (j > 0)\\r\\n{\\r\\nm=((BN_BYTES*2) <= j)?(BN_BYTES*2):j;\\r\\nl=0;\\r\\nfor (;;)\\r\\n{\\r\\nc=a[j-m];\\r\\nif ((c >= '0') && (c <= '9')) k=c-'0';\\r\\nelse if ((c >= 'a') && (c <= 'f')) k=c-'a'+10;\\r\\nelse if ((c >= 'A') && (c <= 'F')) k=c-'A'+10;\\r\\nelse k=0;\\r\\nl=(l<<4)|k;\\r\\nif (--m <= 0)\\r\\n{\\r\\nret->d[h++]=l;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nj-=(BN_BYTES*2);\\r\\n}\\r\\nret->top=h;\\r\\nbn_correct_top(ret);\\r\\nret->neg=neg;\\r\\n*bn=ret;\\r\\nbn_check_top(ret);\\r\\nreturn(num);\\r\\nerr:\\r\\nif (*bn == NULL) BN_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint BN_dec2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret=NULL;\\r\\nBN_ULONG l=0;\\r\\nint neg=0,i,j;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0')) return(0);\\r\\nif (*a == '-') { neg=1; a++; }\\r\\nfor (i=0; isdigit((unsigned char) a[i]); i++)\\r\\n;\\r\\nnum=i+neg;\\r\\nif (bn == NULL) return(num);\\r\\nif (*bn == NULL)\\r\\n{\\r\\nif ((ret=BN_new()) == NULL) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret,i*4) == NULL) goto err;\\r\\nj=BN_DEC_NUM-(i%BN_DEC_NUM);\\r\\nif (j == BN_DEC_NUM) j=0;\\r\\nl=0;\\r\\nwhile (*a)\\r\\n{\\r\\nl*=10;\\r\\nl+= *a-'0';\\r\\na++;\\r\\nif (++j == BN_DEC_NUM)\\r\\n{\\r\\nBN_mul_word(ret,BN_DEC_CONV);\\r\\nBN_add_word(ret,l);\\r\\nl=0;\\r\\nj=0;\\r\\n}\\r\\n}\\r\\nret->neg=neg;\\r\\nbn_correct_top(ret);\\r\\n*bn=ret;\\r\\nbn_check_top(ret);\\r\\nreturn(num);\\r\\nerr:\\r\\nif (*bn == NULL) BN_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint BN_print_fp(FILE *fp, const BIGNUM *a)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\nreturn(0);\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=BN_print(b,a);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_print(BIO *bp, const BIGNUM *a)\\r\\n{\\r\\nint i,j,v,z=0;\\r\\nint ret=0;\\r\\nif ((a->neg) && (BIO_write(bp,\"-\",1) != 1)) goto end;\\r\\nif (BN_is_zero(a) && (BIO_write(bp,\"0\",1) != 1)) goto end;\\r\\nfor (i=a->top-1; i >=0; i--)\\r\\n{\\r\\nfor (j=BN_BITS2-4; j >= 0; j-=4)\\r\\n{\\r\\nv=((int)(a->d[i]>>(long)j))&0x0f;\\r\\nif (z || (v != 0))\\r\\n{\\r\\nif (BIO_write(bp,&(Hex[v]),1) != 1)\\r\\ngoto end;\\r\\nz=1;\\r\\n}\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nend:\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i_ofb64_c", "target": 0, "func": "void idea_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, IDEA_KEY_SCHEDULE *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_asn1_c", "target": 0, "func": "int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)\\r\\n{\\r\\n#define LSIZE2 (sizeof(long)*2)\\r\\nint v1=0,v2=0,v3=0,v4=0,v5=0;\\r\\nunsigned char buf[4],ibuf1[LSIZE2],ibuf2[LSIZE2];\\r\\nunsigned char ibuf3[LSIZE2],ibuf4[LSIZE2],ibuf5[LSIZE2];\\r\\nlong l;\\r\\nSSL_SESSION_ASN1 a;\\r\\nM_ASN1_I2D_vars(in);\\r\\nif ((in == NULL) || ((in->cipher == NULL) && (in->cipher_id == 0)))\\r\\nreturn(0);\\r\\na.version.length=LSIZE2;\\r\\na.version.type=V_ASN1_INTEGER;\\r\\na.version.data=ibuf1;\\r\\nASN1_INTEGER_set(&(a.version),SSL_SESSION_ASN1_VERSION);\\r\\na.ssl_version.length=LSIZE2;\\r\\na.ssl_version.type=V_ASN1_INTEGER;\\r\\na.ssl_version.data=ibuf2;\\r\\nASN1_INTEGER_set(&(a.ssl_version),in->ssl_version);\\r\\na.cipher.type=V_ASN1_OCTET_STRING;\\r\\na.cipher.data=buf;\\r\\nif (in->cipher == NULL)\\r\\nl=in->cipher_id;\\r\\nelse\\r\\nl=in->cipher->id;\\r\\nif (in->ssl_version == SSL2_VERSION)\\r\\n{\\r\\na.cipher.length=3;\\r\\nbuf[0]=((unsigned char)(l>>16L))&0xff;\\r\\nbuf[1]=((unsigned char)(l>> 8L))&0xff;\\r\\nbuf[2]=((unsigned char)(l ))&0xff;\\r\\n}\\r\\nelse\\r\\n{\\r\\na.cipher.length=2;\\r\\nbuf[0]=((unsigned char)(l>>8L))&0xff;\\r\\nbuf[1]=((unsigned char)(l ))&0xff;\\r\\n}\\r\\na.master_key.length=in->master_key_length;\\r\\na.master_key.type=V_ASN1_OCTET_STRING;\\r\\na.master_key.data=in->master_key;\\r\\na.session_id.length=in->session_id_length;\\r\\na.session_id.type=V_ASN1_OCTET_STRING;\\r\\na.session_id.data=in->session_id;\\r\\na.session_id_context.length=in->sid_ctx_length;\\r\\na.session_id_context.type=V_ASN1_OCTET_STRING;\\r\\na.session_id_context.data=in->sid_ctx;\\r\\na.key_arg.length=in->key_arg_length;\\r\\na.key_arg.type=V_ASN1_OCTET_STRING;\\r\\na.key_arg.data=in->key_arg;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len)\\r\\n{\\r\\na.krb5_princ.length=in->krb5_client_princ_len;\\r\\na.krb5_princ.type=V_ASN1_OCTET_STRING;\\r\\na.krb5_princ.data=in->krb5_client_princ;\\r\\n}\\r\\n#endif\\r\\nif (in->time != 0L)\\r\\n{\\r\\na.time.length=LSIZE2;\\r\\na.time.type=V_ASN1_INTEGER;\\r\\na.time.data=ibuf3;\\r\\nASN1_INTEGER_set(&(a.time),in->time);\\r\\n}\\r\\nif (in->timeout != 0L)\\r\\n{\\r\\na.timeout.length=LSIZE2;\\r\\na.timeout.type=V_ASN1_INTEGER;\\r\\na.timeout.data=ibuf4;\\r\\nASN1_INTEGER_set(&(a.timeout),in->timeout);\\r\\n}\\r\\nif (in->verify_result != X509_V_OK)\\r\\n{\\r\\na.verify_result.length=LSIZE2;\\r\\na.verify_result.type=V_ASN1_INTEGER;\\r\\na.verify_result.data=ibuf5;\\r\\nASN1_INTEGER_set(&a.verify_result,in->verify_result);\\r\\n}\\r\\nM_ASN1_I2D_len(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len)\\r\\nM_ASN1_I2D_len(&(a.krb5_princ), i2d_ASN1_OCTET_STRING);\\r\\n#endif\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_len_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_len_EXP_opt(in->peer,i2d_X509,3,v3);\\r\\nM_ASN1_I2D_len_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,v4);\\r\\nif (in->verify_result != X509_V_OK)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.verify_result),i2d_ASN1_INTEGER,5,v5);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len)\\r\\nM_ASN1_I2D_put(&(a.krb5_princ), i2d_ASN1_OCTET_STRING);\\r\\n#endif\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_put_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING,0);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_put_EXP_opt(in->peer,i2d_X509,3,v3);\\r\\nM_ASN1_I2D_put_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,\\r\\nv4);\\r\\nif (in->verify_result != X509_V_OK)\\r\\nM_ASN1_I2D_put_EXP_opt(&a.verify_result,i2d_ASN1_INTEGER,5,v5);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nSSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint version,ssl_version=0,i;\\r\\nlong id;\\r\\nASN1_INTEGER ai,*aip;\\r\\nASN1_OCTET_STRING os,*osp;\\r\\nM_ASN1_D2I_vars(a,SSL_SESSION *,SSL_SESSION_new);\\r\\naip= &ai;\\r\\nosp= &os;\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nai.data=NULL; ai.length=0;\\r\\nM_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);\\r\\nversion=(int)ASN1_INTEGER_get(aip);\\r\\nif (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }\\r\\nM_ASN1_D2I_get_x(ASN1_INTEGER,aip,d2i_ASN1_INTEGER);\\r\\nssl_version=(int)ASN1_INTEGER_get(aip);\\r\\nret->ssl_version=ssl_version;\\r\\nif (ai.data != NULL) { OPENSSL_free(ai.data); ai.data=NULL; ai.length=0; }\\r\\nos.data=NULL; os.length=0;\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);\\r\\nif (ssl_version == SSL2_VERSION)\\r\\n{\\r\\nif (os.length != 3)\\r\\n{\\r\\nc.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nid=0x02000000L|\\r\\n((unsigned long)os.data[0]<<16L)|\\r\\n((unsigned long)os.data[1]<< 8L)|\\r\\n(unsigned long)os.data[2];\\r\\n}\\r\\nelse if ((ssl_version>>8) == SSL3_VERSION_MAJOR)\\r\\n{\\r\\nif (os.length != 2)\\r\\n{\\r\\nc.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nid=0x03000000L|\\r\\n((unsigned long)os.data[0]<<8L)|\\r\\n(unsigned long)os.data[1];\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_UNKNOWN_SSL_VERSION);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->cipher=NULL;\\r\\nret->cipher_id=id;\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);\\r\\nif ((ssl_version>>8) == SSL3_VERSION_MAJOR)\\r\\ni=SSL3_MAX_SSL_SESSION_ID_LENGTH;\\r\\nelse\\r\\ni=SSL2_MAX_SSL_SESSION_ID_LENGTH;\\r\\nif (os.length > i)\\r\\nos.length = i;\\r\\nif (os.length > (int)sizeof(ret->session_id))\\r\\nos.length = sizeof(ret->session_id);\\r\\nret->session_id_length=os.length;\\r\\nOPENSSL_assert(os.length <= (int)sizeof(ret->session_id));\\r\\nmemcpy(ret->session_id,os.data,os.length);\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING,osp,d2i_ASN1_OCTET_STRING);\\r\\nif (ret->master_key_length > SSL_MAX_MASTER_KEY_LENGTH)\\r\\nret->master_key_length=SSL_MAX_MASTER_KEY_LENGTH;\\r\\nelse\\r\\nret->master_key_length=os.length;\\r\\nmemcpy(ret->master_key,os.data,ret->master_key_length);\\r\\nos.length=0;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nos.length=0;\\r\\nM_ASN1_D2I_get_opt(osp,d2i_ASN1_OCTET_STRING,V_ASN1_OCTET_STRING);\\r\\nif (os.data)\\r\\n{\\r\\nif (os.length > SSL_MAX_KRB5_PRINCIPAL_LENGTH)\\r\\nret->krb5_client_princ_len=0;\\r\\nelse\\r\\nret->krb5_client_princ_len=os.length;\\r\\nmemcpy(ret->krb5_client_princ,os.data,ret->krb5_client_princ_len);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n}\\r\\nelse\\r\\nret->krb5_client_princ_len=0;\\r\\n#endif\\r\\nM_ASN1_D2I_get_IMP_opt(osp,d2i_ASN1_OCTET_STRING,0,V_ASN1_OCTET_STRING);\\r\\nif (os.length > SSL_MAX_KEY_ARG_LENGTH)\\r\\nret->key_arg_length=SSL_MAX_KEY_ARG_LENGTH;\\r\\nelse\\r\\nret->key_arg_length=os.length;\\r\\nmemcpy(ret->key_arg,os.data,ret->key_arg_length);\\r\\nif (os.data != NULL) OPENSSL_free(os.data);\\r\\nai.length=0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,1);\\r\\nif (ai.data != NULL)\\r\\n{\\r\\nret->time=ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data); ai.data=NULL; ai.length=0;\\r\\n}\\r\\nelse\\r\\nret->time=time(NULL);\\r\\nai.length=0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,2);\\r\\nif (ai.data != NULL)\\r\\n{\\r\\nret->timeout=ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data); ai.data=NULL; ai.length=0;\\r\\n}\\r\\nelse\\r\\nret->timeout=3;\\r\\nif (ret->peer != NULL)\\r\\n{\\r\\nX509_free(ret->peer);\\r\\nret->peer=NULL;\\r\\n}\\r\\nM_ASN1_D2I_get_EXP_opt(ret->peer,d2i_X509,3);\\r\\nos.length=0;\\r\\nos.data=NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,4);\\r\\nif(os.data != NULL)\\r\\n{\\r\\nif (os.length > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nret->sid_ctx_length=os.length;\\r\\nSSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_BAD_LENGTH);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->sid_ctx_length=os.length;\\r\\nmemcpy(ret->sid_ctx,os.data,os.length);\\r\\n}\\r\\nOPENSSL_free(os.data); os.data=NULL; os.length=0;\\r\\n}\\r\\nelse\\r\\nret->sid_ctx_length=0;\\r\\nai.length=0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,5);\\r\\nif (ai.data != NULL)\\r\\n{\\r\\nret->verify_result=ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data); ai.data=NULL; ai.length=0;\\r\\n}\\r\\nelse\\r\\nret->verify_result=X509_V_OK;\\r\\nM_ASN1_D2I_Finish(a,SSL_SESSION_free,SSL_F_D2I_SSL_SESSION);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ech_key_c", "target": 0, "func": "int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,\\r\\nEC_KEY *eckey,\\r\\nvoid *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))\\r\\n{\\r\\nECDH_DATA *ecdh = ecdh_check(eckey);\\r\\nif (ecdh == NULL)\\r\\nreturn 0;\\r\\nreturn ecdh->meth->compute_key(out, outlen, pub_key, eckey, KDF);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_enc_c", "target": 0, "func": "void BF_encrypt(BF_LONG *data, const BF_KEY *key)\\r\\n{\\r\\n#ifndef BF_PTR2\\r\\nregister BF_LONG l,r;\\r\\nconst register BF_LONG *p,*s;\\r\\np=key->P;\\r\\ns= &(key->S[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nl^=p[0];\\r\\nBF_ENC(r,l,s,p[ 1]);\\r\\nBF_ENC(l,r,s,p[ 2]);\\r\\nBF_ENC(r,l,s,p[ 3]);\\r\\nBF_ENC(l,r,s,p[ 4]);\\r\\nBF_ENC(r,l,s,p[ 5]);\\r\\nBF_ENC(l,r,s,p[ 6]);\\r\\nBF_ENC(r,l,s,p[ 7]);\\r\\nBF_ENC(l,r,s,p[ 8]);\\r\\nBF_ENC(r,l,s,p[ 9]);\\r\\nBF_ENC(l,r,s,p[10]);\\r\\nBF_ENC(r,l,s,p[11]);\\r\\nBF_ENC(l,r,s,p[12]);\\r\\nBF_ENC(r,l,s,p[13]);\\r\\nBF_ENC(l,r,s,p[14]);\\r\\nBF_ENC(r,l,s,p[15]);\\r\\nBF_ENC(l,r,s,p[16]);\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,s,p[17]);\\r\\nBF_ENC(l,r,s,p[18]);\\r\\nBF_ENC(r,l,s,p[19]);\\r\\nBF_ENC(l,r,s,p[20]);\\r\\n#endif\\r\\nr^=p[BF_ROUNDS+1];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#else\\r\\nregister BF_LONG l,r,t,*k;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nk=(BF_LONG*)key;\\r\\nl^=k[0];\\r\\nBF_ENC(r,l,k, 1);\\r\\nBF_ENC(l,r,k, 2);\\r\\nBF_ENC(r,l,k, 3);\\r\\nBF_ENC(l,r,k, 4);\\r\\nBF_ENC(r,l,k, 5);\\r\\nBF_ENC(l,r,k, 6);\\r\\nBF_ENC(r,l,k, 7);\\r\\nBF_ENC(l,r,k, 8);\\r\\nBF_ENC(r,l,k, 9);\\r\\nBF_ENC(l,r,k,10);\\r\\nBF_ENC(r,l,k,11);\\r\\nBF_ENC(l,r,k,12);\\r\\nBF_ENC(r,l,k,13);\\r\\nBF_ENC(l,r,k,14);\\r\\nBF_ENC(r,l,k,15);\\r\\nBF_ENC(l,r,k,16);\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,k,17);\\r\\nBF_ENC(l,r,k,18);\\r\\nBF_ENC(r,l,k,19);\\r\\nBF_ENC(l,r,k,20);\\r\\n#endif\\r\\nr^=k[BF_ROUNDS+1];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#endif\\r\\n}\\r\\nvoid BF_decrypt(BF_LONG *data, const BF_KEY *key)\\r\\n{\\r\\n#ifndef BF_PTR2\\r\\nregister BF_LONG l,r;\\r\\nconst register BF_LONG *p,*s;\\r\\np=key->P;\\r\\ns= &(key->S[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nl^=p[BF_ROUNDS+1];\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,s,p[20]);\\r\\nBF_ENC(l,r,s,p[19]);\\r\\nBF_ENC(r,l,s,p[18]);\\r\\nBF_ENC(l,r,s,p[17]);\\r\\n#endif\\r\\nBF_ENC(r,l,s,p[16]);\\r\\nBF_ENC(l,r,s,p[15]);\\r\\nBF_ENC(r,l,s,p[14]);\\r\\nBF_ENC(l,r,s,p[13]);\\r\\nBF_ENC(r,l,s,p[12]);\\r\\nBF_ENC(l,r,s,p[11]);\\r\\nBF_ENC(r,l,s,p[10]);\\r\\nBF_ENC(l,r,s,p[ 9]);\\r\\nBF_ENC(r,l,s,p[ 8]);\\r\\nBF_ENC(l,r,s,p[ 7]);\\r\\nBF_ENC(r,l,s,p[ 6]);\\r\\nBF_ENC(l,r,s,p[ 5]);\\r\\nBF_ENC(r,l,s,p[ 4]);\\r\\nBF_ENC(l,r,s,p[ 3]);\\r\\nBF_ENC(r,l,s,p[ 2]);\\r\\nBF_ENC(l,r,s,p[ 1]);\\r\\nr^=p[0];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#else\\r\\nregister BF_LONG l,r,t,*k;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nk=(BF_LONG *)key;\\r\\nl^=k[BF_ROUNDS+1];\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,k,20);\\r\\nBF_ENC(l,r,k,19);\\r\\nBF_ENC(r,l,k,18);\\r\\nBF_ENC(l,r,k,17);\\r\\n#endif\\r\\nBF_ENC(r,l,k,16);\\r\\nBF_ENC(l,r,k,15);\\r\\nBF_ENC(r,l,k,14);\\r\\nBF_ENC(l,r,k,13);\\r\\nBF_ENC(r,l,k,12);\\r\\nBF_ENC(l,r,k,11);\\r\\nBF_ENC(r,l,k,10);\\r\\nBF_ENC(l,r,k, 9);\\r\\nBF_ENC(r,l,k, 8);\\r\\nBF_ENC(l,r,k, 7);\\r\\nBF_ENC(r,l,k, 6);\\r\\nBF_ENC(l,r,k, 5);\\r\\nBF_ENC(r,l,k, 4);\\r\\nBF_ENC(l,r,k, 3);\\r\\nBF_ENC(r,l,k, 2);\\r\\nBF_ENC(l,r,k, 1);\\r\\nr^=k[0];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#endif\\r\\n}\\r\\nvoid BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0,tin1;\\r\\nregister BF_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(ivec,tout0);\\r\\nn2l(ivec,tout1);\\r\\nivec-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,schedule);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,schedule);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,ivec);\\r\\nl2n(tout1,ivec);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(ivec,xor0);\\r\\nn2l(ivec,xor1);\\r\\nivec-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,schedule);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,schedule);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,ivec);\\r\\nl2n(xor1,ivec);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_enc_c", "target": 0, "func": "int EVP_PKEY_encrypt(unsigned char *ek, const unsigned char *key, int key_len,\\r\\nEVP_PKEY *pubk)\\r\\n{\\r\\nint ret=0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pubk->type != EVP_PKEY_RSA)\\r\\n{\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret=RSA_public_encrypt(key_len,key,ek,pubk->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_name_c", "target": 0, "func": "static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)\\r\\n{\\r\\nX509_NAME *ret = NULL;\\r\\nret = OPENSSL_malloc(sizeof(X509_NAME));\\r\\nif(!ret) goto memerr;\\r\\nif ((ret->entries=sk_X509_NAME_ENTRY_new_null()) == NULL)\\r\\ngoto memerr;\\r\\nif((ret->bytes = BUF_MEM_new()) == NULL) goto memerr;\\r\\nret->modified=1;\\r\\n*val = (ASN1_VALUE *)ret;\\r\\nreturn 1;\\r\\nmemerr:\\r\\nASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nif (ret)\\r\\n{\\r\\nif (ret->entries)\\r\\nsk_X509_NAME_ENTRY_free(ret->entries);\\r\\nOPENSSL_free(ret);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nX509_NAME *a;\\r\\nif(!pval || !*pval)\\r\\nreturn;\\r\\na = (X509_NAME *)*pval;\\r\\nBUF_MEM_free(a->bytes);\\r\\nsk_X509_NAME_ENTRY_pop_free(a->entries,X509_NAME_ENTRY_free);\\r\\nOPENSSL_free(a);\\r\\n*pval = NULL;\\r\\n}\\r\\nstatic void sk_internal_free(void *a)\\r\\n{\\r\\nsk_free(a);\\r\\n}\\r\\nstatic int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_ITEM *it,\\r\\nint tag, int aclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nconst unsigned char *p = *in, *q;\\r\\nSTACK *intname = NULL, **intname_pp = &intname;\\r\\nint i, j, ret;\\r\\nX509_NAME *nm = NULL, **nm_pp = &nm;\\r\\nSTACK_OF(X509_NAME_ENTRY) *entries;\\r\\nX509_NAME_ENTRY *entry;\\r\\nq = p;\\r\\nret = ASN1_item_ex_d2i((ASN1_VALUE **)intname_pp,\\r\\n&p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),\\r\\ntag, aclass, opt, ctx);\\r\\nif(ret <= 0) return ret;\\r\\nif(*val) x509_name_ex_free(val, NULL);\\r\\nif(!x509_name_ex_new((ASN1_VALUE **)nm_pp, NULL)) goto err;\\r\\nif(!BUF_MEM_grow(nm->bytes, p - q)) goto err;\\r\\nmemcpy(nm->bytes->data, q, p - q);\\r\\nfor(i = 0; i < sk_num(intname); i++) {\\r\\nentries = (STACK_OF(X509_NAME_ENTRY) *)sk_value(intname, i);\\r\\nfor(j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {\\r\\nentry = sk_X509_NAME_ENTRY_value(entries, j);\\r\\nentry->set = i;\\r\\nif(!sk_X509_NAME_ENTRY_push(nm->entries, entry))\\r\\ngoto err;\\r\\n}\\r\\nsk_X509_NAME_ENTRY_free(entries);\\r\\n}\\r\\nsk_free(intname);\\r\\nnm->modified = 0;\\r\\n*val = (ASN1_VALUE *)nm;\\r\\n*in = p;\\r\\nreturn ret;\\r\\nerr:\\r\\nASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out, const ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nint ret;\\r\\nX509_NAME *a = (X509_NAME *)*val;\\r\\nif(a->modified) {\\r\\nret = x509_name_encode((X509_NAME *)a);\\r\\nif(ret < 0) return ret;\\r\\n}\\r\\nret = a->bytes->length;\\r\\nif(out != NULL) {\\r\\nmemcpy(*out,a->bytes->data,ret);\\r\\n*out+=ret;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int x509_name_encode(X509_NAME *a)\\r\\n{\\r\\nSTACK *intname = NULL, **intname_pp = &intname;\\r\\nint len;\\r\\nunsigned char *p;\\r\\nSTACK_OF(X509_NAME_ENTRY) *entries = NULL;\\r\\nX509_NAME_ENTRY *entry;\\r\\nint i, set = -1;\\r\\nintname = sk_new_null();\\r\\nif(!intname) goto memerr;\\r\\nfor(i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\\r\\nentry = sk_X509_NAME_ENTRY_value(a->entries, i);\\r\\nif(entry->set != set) {\\r\\nentries = sk_X509_NAME_ENTRY_new_null();\\r\\nif(!entries) goto memerr;\\r\\nif(!sk_push(intname, (char *)entries)) goto memerr;\\r\\nset = entry->set;\\r\\n}\\r\\nif(!sk_X509_NAME_ENTRY_push(entries, entry)) goto memerr;\\r\\n}\\r\\nlen = ASN1_item_ex_i2d((ASN1_VALUE **)intname_pp, NULL,\\r\\nASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);\\r\\nif (!BUF_MEM_grow(a->bytes,len)) goto memerr;\\r\\np=(unsigned char *)a->bytes->data;\\r\\nASN1_item_ex_i2d((ASN1_VALUE **)intname_pp,\\r\\n&p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);\\r\\nsk_pop_free(intname, sk_internal_free);\\r\\na->modified = 0;\\r\\nreturn len;\\r\\nmemerr:\\r\\nsk_pop_free(intname, sk_internal_free);\\r\\nASN1err(ASN1_F_X509_NAME_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nint X509_NAME_set(X509_NAME **xn, X509_NAME *name)\\r\\n{\\r\\nX509_NAME *in;\\r\\nif (!xn || !name) return(0);\\r\\nif (*xn != name)\\r\\n{\\r\\nin=X509_NAME_dup(name);\\r\\nif (in != NULL)\\r\\n{\\r\\nX509_NAME_free(*xn);\\r\\n*xn=in;\\r\\n}\\r\\n}\\r\\nreturn(*xn != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_pkt_c", "target": 0, "func": "static int\\r\\ndtls1_copy_record(SSL *s, pitem *item)\\r\\n{\\r\\nDTLS1_RECORD_DATA *rdata;\\r\\nrdata = (DTLS1_RECORD_DATA *)item->data;\\r\\nif (s->s3->rbuf.buf != NULL)\\r\\nOPENSSL_free(s->s3->rbuf.buf);\\r\\ns->packet = rdata->packet;\\r\\ns->packet_length = rdata->packet_length;\\r\\nmemcpy(&(s->s3->rbuf), &(rdata->rbuf), sizeof(SSL3_BUFFER));\\r\\nmemcpy(&(s->s3->rrec), &(rdata->rrec), sizeof(SSL3_RECORD));\\r\\nreturn(1);\\r\\n}\\r\\nstatic int\\r\\ndtls1_buffer_record(SSL *s, record_pqueue *queue, PQ_64BIT priority)\\r\\n{\\r\\nDTLS1_RECORD_DATA *rdata;\\r\\npitem *item;\\r\\nrdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\\r\\nitem = pitem_new(priority, rdata);\\r\\nif (rdata == NULL || item == NULL)\\r\\n{\\r\\nif (rdata != NULL) OPENSSL_free(rdata);\\r\\nif (item != NULL) pitem_free(item);\\r\\nSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\\r\\nreturn(0);\\r\\n}\\r\\nrdata->packet = s->packet;\\r\\nrdata->packet_length = s->packet_length;\\r\\nmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\\r\\nmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\\r\\nitem->data = rdata;\\r\\nif (pqueue_insert(queue->q, item) == NULL)\\r\\n{\\r\\nOPENSSL_free(rdata);\\r\\npitem_free(item);\\r\\nreturn(0);\\r\\n}\\r\\ns->packet = NULL;\\r\\ns->packet_length = 0;\\r\\nmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\\r\\nmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\\r\\nssl3_setup_buffers(s);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int\\r\\ndtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)\\r\\n{\\r\\npitem *item;\\r\\nitem = pqueue_pop(queue->q);\\r\\nif (item)\\r\\n{\\r\\ndtls1_copy_record(s, item);\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\nreturn(1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nstatic int\\r\\ndtls1_process_buffered_records(SSL *s)\\r\\n{\\r\\npitem *item;\\r\\nitem = pqueue_peek(s->d1->unprocessed_rcds.q);\\r\\nif (item)\\r\\n{\\r\\nDTLS1_RECORD_DATA *rdata;\\r\\nrdata = (DTLS1_RECORD_DATA *)item->data;\\r\\nif (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\\r\\nreturn(1);\\r\\nwhile (pqueue_peek(s->d1->unprocessed_rcds.q))\\r\\n{\\r\\ndtls1_get_unprocessed_record(s);\\r\\nif ( ! dtls1_process_record(s))\\r\\nreturn(0);\\r\\ndtls1_buffer_record(s, &(s->d1->processed_rcds),\\r\\ns->s3->rrec.seq_num);\\r\\n}\\r\\n}\\r\\ns->d1->processed_rcds.epoch = s->d1->r_epoch;\\r\\ns->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int\\r\\ndtls1_process_record(SSL *s)\\r\\n{\\r\\nint i,al;\\r\\nint clear=0;\\r\\nint enc_err;\\r\\nSSL_SESSION *sess;\\r\\nSSL3_RECORD *rr;\\r\\nunsigned int mac_size;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nrr= &(s->s3->rrec);\\r\\nsess = s->session;\\r\\nrr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);\\r\\nif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->data=rr->input;\\r\\nenc_err = s->method->ssl3_enc->enc(s,0);\\r\\nif (enc_err <= 0)\\r\\n{\\r\\nif (enc_err == 0)\\r\\ngoto err;\\r\\ngoto decryption_failed_or_bad_record_mac;\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"dec %d\\n\",rr->length);\\r\\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_read_ctx == NULL) ||\\r\\n(s->read_hash == NULL))\\r\\nclear=1;\\r\\nif (!clear)\\r\\n{\\r\\nmac_size=EVP_MD_size(s->read_hash);\\r\\nif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)\\r\\n{\\r\\n#if 0\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n#else\\r\\ngoto decryption_failed_or_bad_record_mac;\\r\\n#endif\\r\\n}\\r\\nif (rr->length < mac_size)\\r\\n{\\r\\n#if 0\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);\\r\\ngoto f_err;\\r\\n#else\\r\\ngoto decryption_failed_or_bad_record_mac;\\r\\n#endif\\r\\n}\\r\\nrr->length-=mac_size;\\r\\ni=s->method->ssl3_enc->mac(s,md,0);\\r\\nif (memcmp(md,&(rr->data[rr->length]),mac_size) != 0)\\r\\n{\\r\\ngoto decryption_failed_or_bad_record_mac;\\r\\n}\\r\\n}\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!ssl3_do_uncompress(s))\\r\\n{\\r\\nal=SSL_AD_DECOMPRESSION_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->off=0;\\r\\ns->packet_length=0;\\r\\ndtls1_record_bitmap_update(s, &(s->d1->bitmap));\\r\\nreturn(1);\\r\\ndecryption_failed_or_bad_record_mac:\\r\\nal=SSL_AD_BAD_RECORD_MAC;\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint dtls1_get_record(SSL *s)\\r\\n{\\r\\nint ssl_major,ssl_minor,al;\\r\\nint i,n;\\r\\nSSL3_RECORD *rr;\\r\\nSSL_SESSION *sess;\\r\\nunsigned char *p;\\r\\nshort version;\\r\\nDTLS1_BITMAP *bitmap;\\r\\nunsigned int is_next_epoch;\\r\\nrr= &(s->s3->rrec);\\r\\nsess=s->session;\\r\\nif ( ! dtls1_process_buffered_records(s))\\r\\nreturn 0;\\r\\nif (dtls1_get_processed_record(s))\\r\\nreturn 1;\\r\\nagain:\\r\\nif ( (s->rstate != SSL_ST_READ_BODY) ||\\r\\n(s->packet_length < DTLS1_RT_HEADER_LENGTH))\\r\\n{\\r\\nn=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);\\r\\nif (n <= 0) return(n);\\r\\nOPENSSL_assert(s->packet_length == DTLS1_RT_HEADER_LENGTH);\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\np=s->packet;\\r\\nrr->type= *(p++);\\r\\nssl_major= *(p++);\\r\\nssl_minor= *(p++);\\r\\nversion=(ssl_major<<8)|ssl_minor;\\r\\nn2s(p,rr->epoch);\\r\\nmemcpy(&(s->s3->read_sequence[2]), p, 6);\\r\\np+=6;\\r\\nn2s(p,rr->length);\\r\\nif (s->first_packet)\\r\\n{\\r\\ns->first_packet=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (version != s->version)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ns->version=version;\\r\\nal=SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif ((version & 0xff00) != (DTLS1_VERSION & 0xff00))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_DTLS1_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)\\r\\n{\\r\\ni=rr->length;\\r\\nn=ssl3_read_n(s,i,i,1);\\r\\nif (n <= 0) return(n);\\r\\nif ( n != i)\\r\\n{\\r\\ns->packet_length = 0;\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nbitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\\r\\nif ( bitmap == NULL)\\r\\n{\\r\\ns->packet_length = 0;\\r\\ngoto again;\\r\\n}\\r\\nif ( ! dtls1_record_replay_check(s, bitmap, &(rr->seq_num)))\\r\\n{\\r\\ns->packet_length=0;\\r\\ngoto again;\\r\\n}\\r\\nif (rr->length == 0) goto again;\\r\\nif (is_next_epoch)\\r\\n{\\r\\ndtls1_record_bitmap_update(s, bitmap);\\r\\ndtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);\\r\\ns->packet_length = 0;\\r\\ngoto again;\\r\\n}\\r\\nif ( ! dtls1_process_record(s))\\r\\nreturn(0);\\r\\ndtls1_clear_timeouts(s);\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\\r\\n{\\r\\nint al,i,j,ret;\\r\\nunsigned int n;\\r\\nSSL3_RECORD *rr;\\r\\nvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\\r\\nif (s->s3->rbuf.buf == NULL)\\r\\nif (!ssl3_setup_buffers(s))\\r\\nreturn(-1);\\r\\nif ((type && (type != SSL3_RT_APPLICATION_DATA) &&\\r\\n(type != SSL3_RT_HANDSHAKE) && type) ||\\r\\n(peek && (type != SSL3_RT_APPLICATION_DATA)))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nif ( (ret = have_handshake_fragment(s, type, buf, len, peek)))\\r\\nreturn ret;\\r\\nif (!s->in_handshake && SSL_in_init(s))\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstart:\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr = &(s->s3->rrec);\\r\\nif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\\r\\n{\\r\\nret=dtls1_get_record(s);\\r\\nif (ret <= 0)\\r\\n{\\r\\nret = dtls1_read_failed(s, ret);\\r\\nif (ret <= 0)\\r\\nreturn(ret);\\r\\nelse\\r\\ngoto start;\\r\\n}\\r\\n}\\r\\nif (s->s3->change_cipher_spec\\r\\n&& (rr->type != SSL3_RT_HANDSHAKE))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\\r\\ngoto err;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\nrr->length=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\nif (type == rr->type)\\r\\n{\\r\\nif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\\r\\n(s->enc_read_ctx == NULL))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (len <= 0) return(len);\\r\\nif ((unsigned int)len > rr->length)\\r\\nn = rr->length;\\r\\nelse\\r\\nn = (unsigned int)len;\\r\\nmemcpy(buf,&(rr->data[rr->off]),n);\\r\\nif (!peek)\\r\\n{\\r\\nrr->length-=n;\\r\\nrr->off+=n;\\r\\nif (rr->length == 0)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nrr->off=0;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\n{\\r\\nunsigned int k, dest_maxlen = 0;\\r\\nunsigned char *dest = NULL;\\r\\nunsigned int *dest_len = NULL;\\r\\nif (rr->type == SSL3_RT_HANDSHAKE)\\r\\n{\\r\\ndest_maxlen = sizeof s->d1->handshake_fragment;\\r\\ndest = s->d1->handshake_fragment;\\r\\ndest_len = &s->d1->handshake_fragment_len;\\r\\n}\\r\\nelse if (rr->type == SSL3_RT_ALERT)\\r\\n{\\r\\ndest_maxlen = sizeof(s->d1->alert_fragment);\\r\\ndest = s->d1->alert_fragment;\\r\\ndest_len = &s->d1->alert_fragment_len;\\r\\n}\\r\\nelse\\r\\nOPENSSL_assert(rr->type == SSL3_RT_CHANGE_CIPHER_SPEC);\\r\\nif (dest_maxlen > 0)\\r\\n{\\r\\nif ( rr->length < dest_maxlen)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nrr->length = 0;\\r\\ngoto start;\\r\\n}\\r\\nfor ( k = 0; k < dest_maxlen; k++)\\r\\n{\\r\\ndest[k] = rr->data[rr->off++];\\r\\nrr->length--;\\r\\n}\\r\\n*dest_len = dest_maxlen;\\r\\n}\\r\\n}\\r\\nif ((!s->server) &&\\r\\n(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&\\r\\n(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\\r\\n(s->session != NULL) && (s->session->cipher != NULL))\\r\\n{\\r\\ns->d1->handshake_fragment_len = 0;\\r\\nif ((s->d1->handshake_fragment[1] != 0) ||\\r\\n(s->d1->handshake_fragment[2] != 0) ||\\r\\n(s->d1->handshake_fragment[3] != 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\\r\\ns->d1->handshake_fragment, 4, s, s->msg_callback_arg);\\r\\nif (SSL_is_init_finished(s) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\\r\\n!s->s3->renegotiate)\\r\\n{\\r\\nssl3_renegotiate(s);\\r\\nif (ssl3_renegotiate_check(s))\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!(s->mode & SSL_MODE_AUTO_RETRY))\\r\\n{\\r\\nif (s->s3->rbuf.left == 0)\\r\\n{\\r\\nBIO *bio;\\r\\ns->rwstate=SSL_READING;\\r\\nbio=SSL_get_rbio(s);\\r\\nBIO_clear_retry_flags(bio);\\r\\nBIO_set_retry_read(bio);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nif (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)\\r\\n{\\r\\nint alert_level = s->d1->alert_fragment[0];\\r\\nint alert_descr = s->d1->alert_fragment[1];\\r\\ns->d1->alert_fragment_len = 0;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_ALERT,\\r\\ns->d1->alert_fragment, 2, s, s->msg_callback_arg);\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj = (alert_level << 8) | alert_descr;\\r\\ncb(s, SSL_CB_READ_ALERT, j);\\r\\n}\\r\\nif (alert_level == 1)\\r\\n{\\r\\ns->s3->warn_alert = alert_descr;\\r\\nif (alert_descr == SSL_AD_CLOSE_NOTIFY)\\r\\n{\\r\\ns->shutdown |= SSL_RECEIVED_SHUTDOWN;\\r\\nreturn(0);\\r\\n}\\r\\n#if 0\\r\\nif (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\\r\\n{\\r\\nunsigned short seq;\\r\\nunsigned int frag_off;\\r\\nunsigned char *p = &(s->d1->alert_fragment[2]);\\r\\nn2s(p, seq);\\r\\nn2l3(p, frag_off);\\r\\ndtls1_retransmit_message(s, seq, frag_off, &found);\\r\\nif ( ! found && SSL_in_init(s))\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,\\r\\nDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse if (alert_level == 2)\\r\\n{\\r\\nchar tmp[16];\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->s3->fatal_alert = alert_descr;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\\r\\nERR_add_error_data(2,\"SSL alert number \",tmp);\\r\\ns->shutdown|=SSL_RECEIVED_SHUTDOWN;\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr->length=0;\\r\\nreturn(0);\\r\\n}\\r\\nif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\\r\\n{\\r\\nstruct ccs_header_st ccs_hdr;\\r\\ndtls1_get_ccs_header(rr->data, &ccs_hdr);\\r\\nif ( ccs_hdr.seq == s->d1->handshake_read_seq)\\r\\n{\\r\\nif ( (rr->length != DTLS1_CCS_HEADER_LENGTH) ||\\r\\n(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))\\r\\n{\\r\\ni=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\\r\\ngoto err;\\r\\n}\\r\\nrr->length=0;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC,\\r\\nrr->data, 1, s, s->msg_callback_arg);\\r\\ns->s3->change_cipher_spec=1;\\r\\nif (!ssl3_do_change_cipher_spec(s))\\r\\ngoto err;\\r\\ndtls1_reset_seq_numbers(s, SSL3_CC_READ);\\r\\ns->d1->handshake_read_seq++;\\r\\ngoto start;\\r\\n}\\r\\nelse\\r\\n{\\r\\nrr->length = 0;\\r\\ngoto start;\\r\\n}\\r\\n}\\r\\nif ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&\\r\\n!s->in_handshake)\\r\\n{\\r\\nstruct hm_header_st msg_hdr;\\r\\ndtls1_get_message_header(rr->data, &msg_hdr);\\r\\nif( rr->epoch != s->d1->r_epoch)\\r\\n{\\r\\nrr->length = 0;\\r\\ngoto start;\\r\\n}\\r\\nif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\\r\\n{\\r\\n#if 0\\r\\ns->state=SSL_ST_BEFORE|(s->server)\\r\\n?SSL_ST_ACCEPT\\r\\n:SSL_ST_CONNECT;\\r\\n#else\\r\\ns->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\\r\\n#endif\\r\\ns->new_session=1;\\r\\n}\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!(s->mode & SSL_MODE_AUTO_RETRY))\\r\\n{\\r\\nif (s->s3->rbuf.left == 0)\\r\\n{\\r\\nBIO *bio;\\r\\ns->rwstate=SSL_READING;\\r\\nbio=SSL_get_rbio(s);\\r\\nBIO_clear_retry_flags(bio);\\r\\nBIO_set_retry_read(bio);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nswitch (rr->type)\\r\\n{\\r\\ndefault:\\r\\n#ifndef OPENSSL_NO_TLS\\r\\nif (s->version == TLS1_VERSION)\\r\\n{\\r\\nrr->length = 0;\\r\\ngoto start;\\r\\n}\\r\\n#endif\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\\r\\ncase SSL3_RT_ALERT:\\r\\ncase SSL3_RT_HANDSHAKE:\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);\\r\\ngoto f_err;\\r\\ncase SSL3_RT_APPLICATION_DATA:\\r\\nif (s->s3->in_read_app_data &&\\r\\n(s->s3->total_renegotiations != 0) &&\\r\\n((\\r\\n(s->state & SSL_ST_CONNECT) &&\\r\\n(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\\r\\n(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\\r\\n) || (\\r\\n(s->state & SSL_ST_ACCEPT) &&\\r\\n(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\\r\\n(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\\r\\n)\\r\\n))\\r\\n{\\r\\ns->s3->in_read_app_data=2;\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint\\r\\ndtls1_write_app_data_bytes(SSL *s, int type, const void *buf_, int len)\\r\\n{\\r\\nunsigned int n,tot;\\r\\nint i;\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\ntot = s->s3->wnum;\\r\\nn = len - tot;\\r\\nwhile( n)\\r\\n{\\r\\ni = dtls1_write_bytes(s, type, buf_, len);\\r\\nif (i <= 0) return i;\\r\\nif ((i == (int)n) ||\\r\\n(type == SSL3_RT_APPLICATION_DATA &&\\r\\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))\\r\\n{\\r\\ns->s3->empty_fragment_done = 0;\\r\\nreturn tot+i;\\r\\n}\\r\\ntot += i;\\r\\nn-=i;\\r\\n}\\r\\nreturn tot;\\r\\n}\\r\\nstatic int\\r\\nhave_handshake_fragment(SSL *s, int type, unsigned char *buf,\\r\\nint len, int peek)\\r\\n{\\r\\nif ((type == SSL3_RT_HANDSHAKE) && (s->d1->handshake_fragment_len > 0))\\r\\n{\\r\\nunsigned char *src = s->d1->handshake_fragment;\\r\\nunsigned char *dst = buf;\\r\\nunsigned int k,n;\\r\\nn = 0;\\r\\nwhile ((len > 0) && (s->d1->handshake_fragment_len > 0))\\r\\n{\\r\\n*dst++ = *src++;\\r\\nlen--; s->d1->handshake_fragment_len--;\\r\\nn++;\\r\\n}\\r\\nfor (k = 0; k < s->d1->handshake_fragment_len; k++)\\r\\ns->d1->handshake_fragment[k] = *src++;\\r\\nreturn n;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint dtls1_write_bytes(SSL *s, int type, const void *buf_, int len)\\r\\n{\\r\\nconst unsigned char *buf=buf_;\\r\\nunsigned int tot,n,nw;\\r\\nint i;\\r\\nunsigned int mtu;\\r\\ns->rwstate=SSL_NOTHING;\\r\\ntot=s->s3->wnum;\\r\\nn=(len-tot);\\r\\n#if 0\\r\\nmtu = BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_MTU, 0, NULL);\\r\\nmtu += DTLS1_HM_HEADER_LENGTH;\\r\\n#endif\\r\\nmtu = s->d1->mtu;\\r\\nif (mtu > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\nmtu = SSL3_RT_MAX_PLAIN_LENGTH;\\r\\nif (n > mtu)\\r\\nnw=mtu;\\r\\nelse\\r\\nnw=n;\\r\\ni=do_dtls1_write(s, type, &(buf[tot]), nw, 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->wnum=tot;\\r\\nreturn i;\\r\\n}\\r\\nif ( (int)s->s3->wnum + i == len)\\r\\ns->s3->wnum = 0;\\r\\nelse\\r\\ns->s3->wnum += i;\\r\\nreturn tot + i;\\r\\n}\\r\\nint do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)\\r\\n{\\r\\nunsigned char *p,*pseq;\\r\\nint i,mac_size,clear=0;\\r\\nint prefix_len = 0;\\r\\nSSL3_RECORD *wr;\\r\\nSSL3_BUFFER *wb;\\r\\nSSL_SESSION *sess;\\r\\nint bs;\\r\\nif (s->s3->wbuf.left != 0)\\r\\n{\\r\\nOPENSSL_assert(0);\\r\\nreturn(ssl3_write_pending(s,type,buf,len));\\r\\n}\\r\\nif (s->s3->alert_dispatch)\\r\\n{\\r\\ni=s->method->ssl_dispatch_alert(s);\\r\\nif (i <= 0)\\r\\nreturn(i);\\r\\n}\\r\\nif (len == 0 && !create_empty_fragment)\\r\\nreturn 0;\\r\\nwr= &(s->s3->wrec);\\r\\nwb= &(s->s3->wbuf);\\r\\nsess=s->session;\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_write_ctx == NULL) ||\\r\\n(s->write_hash == NULL))\\r\\nclear=1;\\r\\nif (clear)\\r\\nmac_size=0;\\r\\nelse\\r\\nmac_size=EVP_MD_size(s->write_hash);\\r\\n#if 0\\r\\nif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done\\r\\n&& SSL_version(s) != DTLS1_VERSION)\\r\\n{\\r\\nif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\\r\\n{\\r\\nprefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);\\r\\nif (prefix_len <= 0)\\r\\ngoto err;\\r\\nif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\\r\\n{\\r\\nSSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ns->s3->empty_fragment_done = 1;\\r\\n}\\r\\n#endif\\r\\np = wb->buf + prefix_len;\\r\\n*(p++)=type&0xff;\\r\\nwr->type=type;\\r\\n*(p++)=(s->version>>8);\\r\\n*(p++)=s->version&0xff;\\r\\npseq=p;\\r\\np+=10;\\r\\nif ( s->enc_write_ctx &&\\r\\n(EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))\\r\\nbs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher);\\r\\nelse\\r\\nbs = 0;\\r\\nwr->data=p + bs;\\r\\nwr->length=(int)len;\\r\\nwr->input=(unsigned char *)buf;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nif (!ssl3_do_compress(s))\\r\\n{\\r\\nSSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(wr->data,wr->input,wr->length);\\r\\nwr->input=wr->data;\\r\\n}\\r\\nif (mac_size != 0)\\r\\n{\\r\\ns->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1);\\r\\nwr->length+=mac_size;\\r\\n}\\r\\nwr->input=p;\\r\\nwr->data=p;\\r\\nwr->length += bs;\\r\\ns->method->ssl3_enc->enc(s,1);\\r\\ns2n(s->d1->w_epoch, pseq);\\r\\nmemcpy(pseq, &(s->s3->write_sequence[2]), 6);\\r\\npseq+=6;\\r\\ns2n(wr->length,pseq);\\r\\nwr->type=type;\\r\\nwr->length+=DTLS1_RT_HEADER_LENGTH;\\r\\n#if 0\\r\\nif ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)\\r\\ndtls1_buffer_record(s, wr->data, wr->length,\\r\\n*((PQ_64BIT *)&(s->s3->write_sequence[0])));\\r\\n#endif\\r\\nssl3_record_sequence_update(&(s->s3->write_sequence[0]));\\r\\nif (create_empty_fragment)\\r\\n{\\r\\nreturn wr->length;\\r\\n}\\r\\nwb->left = prefix_len + wr->length;\\r\\nwb->offset = 0;\\r\\ns->s3->wpend_tot=len;\\r\\ns->s3->wpend_buf=buf;\\r\\ns->s3->wpend_type=type;\\r\\ns->s3->wpend_ret=len;\\r\\nreturn ssl3_write_pending(s,type,buf,len);\\r\\nerr:\\r\\nreturn -1;\\r\\n}\\r\\nstatic int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap,\\r\\nPQ_64BIT *seq_num)\\r\\n{\\r\\n#if PQ_64BIT_IS_INTEGER\\r\\nPQ_64BIT mask = 0x0000000000000001L;\\r\\n#endif\\r\\nPQ_64BIT rcd_num, tmp;\\r\\npq_64bit_init(&rcd_num);\\r\\npq_64bit_init(&tmp);\\r\\npq_64bit_bin2num(&rcd_num, s->s3->read_sequence, 8);\\r\\nif (pq_64bit_gt(&rcd_num, &(bitmap->max_seq_num)) ||\\r\\npq_64bit_eq(&rcd_num, &(bitmap->max_seq_num)))\\r\\n{\\r\\npq_64bit_assign(seq_num, &rcd_num);\\r\\npq_64bit_free(&rcd_num);\\r\\npq_64bit_free(&tmp);\\r\\nreturn 1;\\r\\n}\\r\\npq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);\\r\\nif ( pq_64bit_get_word(&tmp) > bitmap->length)\\r\\n{\\r\\npq_64bit_free(&rcd_num);\\r\\npq_64bit_free(&tmp);\\r\\nreturn 0;\\r\\n}\\r\\n#if PQ_64BIT_IS_BIGNUM\\r\\n{\\r\\nint offset;\\r\\npq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);\\r\\npq_64bit_sub_word(&tmp, 1);\\r\\noffset = pq_64bit_get_word(&tmp);\\r\\nif ( pq_64bit_is_bit_set(&(bitmap->map), offset))\\r\\n{\\r\\npq_64bit_free(&rcd_num);\\r\\npq_64bit_free(&tmp);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n#else\\r\\nmask <<= (bitmap->max_seq_num - rcd_num - 1);\\r\\nif (bitmap->map & mask)\\r\\nreturn 0;\\r\\n#endif\\r\\npq_64bit_assign(seq_num, &rcd_num);\\r\\npq_64bit_free(&rcd_num);\\r\\npq_64bit_free(&tmp);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)\\r\\n{\\r\\nunsigned int shift;\\r\\nPQ_64BIT rcd_num;\\r\\nPQ_64BIT tmp;\\r\\nPQ_64BIT_CTX *ctx;\\r\\npq_64bit_init(&rcd_num);\\r\\npq_64bit_init(&tmp);\\r\\npq_64bit_bin2num(&rcd_num, s->s3->read_sequence, 8);\\r\\nif ( pq_64bit_gt(&rcd_num, &(bitmap->max_seq_num)) ||\\r\\npq_64bit_eq(&rcd_num, &(bitmap->max_seq_num)))\\r\\n{\\r\\npq_64bit_sub(&tmp, &rcd_num, &(bitmap->max_seq_num));\\r\\npq_64bit_add_word(&tmp, 1);\\r\\nshift = (unsigned int)pq_64bit_get_word(&tmp);\\r\\npq_64bit_lshift(&(tmp), &(bitmap->map), shift);\\r\\npq_64bit_assign(&(bitmap->map), &tmp);\\r\\npq_64bit_set_bit(&(bitmap->map), 0);\\r\\npq_64bit_add_word(&rcd_num, 1);\\r\\npq_64bit_assign(&(bitmap->max_seq_num), &rcd_num);\\r\\npq_64bit_assign_word(&tmp, 1);\\r\\npq_64bit_lshift(&tmp, &tmp, bitmap->length);\\r\\nctx = pq_64bit_ctx_new(&ctx);\\r\\npq_64bit_mod(&(bitmap->map), &(bitmap->map), &tmp, ctx);\\r\\npq_64bit_ctx_free(ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\npq_64bit_sub(&tmp, &(bitmap->max_seq_num), &rcd_num);\\r\\npq_64bit_sub_word(&tmp, 1);\\r\\nshift = (unsigned int)pq_64bit_get_word(&tmp);\\r\\npq_64bit_set_bit(&(bitmap->map), shift);\\r\\n}\\r\\npq_64bit_free(&rcd_num);\\r\\npq_64bit_free(&tmp);\\r\\n}\\r\\nint dtls1_dispatch_alert(SSL *s)\\r\\n{\\r\\nint i,j;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nunsigned char buf[2 + 2 + 3];\\r\\nunsigned char *ptr = &buf[0];\\r\\ns->s3->alert_dispatch=0;\\r\\nmemset(buf, 0x00, sizeof(buf));\\r\\n*ptr++ = s->s3->send_alert[0];\\r\\n*ptr++ = s->s3->send_alert[1];\\r\\nif (s->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\\r\\n{\\r\\ns2n(s->d1->handshake_read_seq, ptr);\\r\\n#if 0\\r\\nif ( s->d1->r_msg_hdr.frag_off == 0)\\r\\nelse\\r\\ns2n(s->d1->r_msg_hdr.seq, ptr);\\r\\n#endif\\r\\n#if 0\\r\\nfprintf(stderr, \"s->d1->handshake_read_seq = %d, s->d1->r_msg_hdr.seq = %d\\n\",s->d1->handshake_read_seq,s->d1->r_msg_hdr.seq);\\r\\n#endif\\r\\nl2n3(s->d1->r_msg_hdr.frag_off, ptr);\\r\\n}\\r\\ni = do_dtls1_write(s, SSL3_RT_ALERT, &buf[0], sizeof(buf), 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->alert_dispatch=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ( s->s3->send_alert[0] == SSL3_AL_FATAL ||\\r\\ns->s3->send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\\r\\n(void)BIO_flush(s->wbio);\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, SSL3_RT_ALERT, s->s3->send_alert,\\r\\n2, s, s->msg_callback_arg);\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(s->s3->send_alert[0]<<8)|s->s3->send_alert[1];\\r\\ncb(s,SSL_CB_WRITE_ALERT,j);\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic DTLS1_BITMAP *\\r\\ndtls1_get_bitmap(SSL *s, SSL3_RECORD *rr, unsigned int *is_next_epoch)\\r\\n{\\r\\n*is_next_epoch = 0;\\r\\nif (rr->epoch == s->d1->r_epoch)\\r\\nreturn &s->d1->bitmap;\\r\\nelse if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&\\r\\n(rr->type == SSL3_RT_HANDSHAKE ||\\r\\nrr->type == SSL3_RT_ALERT))\\r\\n{\\r\\n*is_next_epoch = 1;\\r\\nreturn &s->d1->next_bitmap;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid\\r\\ndtls1_reset_seq_numbers(SSL *s, int rw)\\r\\n{\\r\\nunsigned char *seq;\\r\\nunsigned int seq_bytes = sizeof(s->s3->read_sequence);\\r\\nif ( rw & SSL3_CC_READ)\\r\\n{\\r\\nseq = s->s3->read_sequence;\\r\\ns->d1->r_epoch++;\\r\\npq_64bit_assign(&(s->d1->bitmap.map), &(s->d1->next_bitmap.map));\\r\\ns->d1->bitmap.length = s->d1->next_bitmap.length;\\r\\npq_64bit_assign(&(s->d1->bitmap.max_seq_num),\\r\\n&(s->d1->next_bitmap.max_seq_num));\\r\\npq_64bit_free(&(s->d1->next_bitmap.map));\\r\\npq_64bit_free(&(s->d1->next_bitmap.max_seq_num));\\r\\nmemset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\\r\\npq_64bit_init(&(s->d1->next_bitmap.map));\\r\\npq_64bit_init(&(s->d1->next_bitmap.max_seq_num));\\r\\n}\\r\\nelse\\r\\n{\\r\\nseq = s->s3->write_sequence;\\r\\ns->d1->w_epoch++;\\r\\n}\\r\\nmemset(seq, 0x00, seq_bytes);\\r\\n}\\r\\nstatic PQ_64BIT\\r\\nbytes_to_long_long(unsigned char *bytes, PQ_64BIT *num)\\r\\n{\\r\\nPQ_64BIT _num;\\r\\n_num = (((PQ_64BIT)bytes[0]) << 56) |\\r\\n(((PQ_64BIT)bytes[1]) << 48) |\\r\\n(((PQ_64BIT)bytes[2]) << 40) |\\r\\n(((PQ_64BIT)bytes[3]) << 32) |\\r\\n(((PQ_64BIT)bytes[4]) << 24) |\\r\\n(((PQ_64BIT)bytes[5]) << 16) |\\r\\n(((PQ_64BIT)bytes[6]) << 8) |\\r\\n(((PQ_64BIT)bytes[7]) );\\r\\n*num = _num ;\\r\\nreturn _num;\\r\\n}\\r\\nstatic void\\r\\ndtls1_clear_timeouts(SSL *s)\\r\\n{\\r\\nmemset(&(s->d1->timeout), 0x00, sizeof(struct dtls1_timeout_st));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_null_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return 1; }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return 1; }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return 1; }\\r\\nconst EVP_MD *EVP_md_null(void)\\r\\n{\\r\\nreturn(&null_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_info_c", "target": 0, "func": "int i2a_ACCESS_DESCRIPTION(BIO *bp, ACCESS_DESCRIPTION* a)\\r\\n{\\r\\ni2a_ASN1_OBJECT(bp, a->method);\\r\\n#ifdef UNDEF\\r\\ni2a_GENERAL_NAME(bp, a->location);\\r\\n#endif\\r\\nreturn 2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_os2_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nchar failed_module[20];\\r\\nQWORD qwTime;\\r\\nULONG SysVars[QSV_FOREGROUND_PROCESS];\\r\\nif (hDoscalls == 0) {\\r\\nULONG rc = DosLoadModule(failed_module, sizeof(failed_module), \"DOSCALLS\", &hDoscalls);\\r\\nif (rc == 0) {\\r\\nrc = DosQueryProcAddr(hDoscalls, 976, NULL, (PFN *)&DosPerfSysCall);\\r\\nif (rc)\\r\\nDosPerfSysCall = NULL;\\r\\nrc = DosQueryProcAddr(hDoscalls, 368, NULL, (PFN *)&DosQuerySysState);\\r\\nif (rc)\\r\\nDosQuerySysState = NULL;\\r\\n}\\r\\n}\\r\\nDosTmrQueryTime(&qwTime);\\r\\nRAND_add(&qwTime, sizeof(qwTime), 2);\\r\\nDosQuerySysInfo(1, QSV_FOREGROUND_PROCESS, SysVars, sizeof(SysVars));\\r\\nRAND_add(SysVars, sizeof(SysVars), 4);\\r\\nif (DosPerfSysCall) {\\r\\nCPUUTIL util;\\r\\nif (DosPerfSysCall(CMD_KI_RDCNT, (ULONG)&util, 0, 0) == 0) {\\r\\nRAND_add(&util, sizeof(util), 10);\\r\\n}\\r\\nelse {\\r\\nDosPerfSysCall = NULL;\\r\\n}\\r\\n}\\r\\nif (DosQuerySysState) {\\r\\nchar *buffer = OPENSSL_malloc(256 * 1024);\\r\\nif (DosQuerySysState(0x1F, 0, 0, 0, buffer, 256 * 1024) == 0) {\\r\\nRAND_add(buffer, 256 * 1024, **(ULONG **)buffer);\\r\\n}\\r\\nOPENSSL_free(buffer);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_f_enum_c", "target": 0, "func": "int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) != 2) goto err;\\r\\nn=2;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbs->type=V_ASN1_ENUMERATED;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1) goto err_sl;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nif (first)\\r\\n{\\r\\nfirst=0;\\r\\nif ((bufp[0] == '0') && (buf[1] == '0'))\\r\\n{\\r\\nbufp+=2;\\r\\ni-=2;\\r\\n}\\r\\n}\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)OPENSSL_malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=(unsigned char *)OPENSSL_realloc(s,\\r\\n(unsigned int)num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) OPENSSL_free(s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_req_c", "target": 0, "func": "int X509_REQ_print_fp(FILE *fp, X509_REQ *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_REQ_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags, unsigned long cflag)\\r\\n{\\r\\nunsigned long l;\\r\\nint i;\\r\\nconst char *neg;\\r\\nX509_REQ_INFO *ri;\\r\\nEVP_PKEY *pkey;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nchar mlch = ' ';\\r\\nint nmindent = 0;\\r\\nif((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmlch = '\\n';\\r\\nnmindent = 12;\\r\\n}\\r\\nif(nmflags == X509_FLAG_COMPAT)\\r\\nnmindent = 16;\\r\\nri=x->req_info;\\r\\nif(!(cflag & X509_FLAG_NO_HEADER))\\r\\n{\\r\\nif (BIO_write(bp,\"Certificate Request:\\n\",21) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Data:\\n\",10) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_VERSION))\\r\\n{\\r\\nneg=(ri->version->type == V_ASN1_NEG_INTEGER)?\"-\":\"\";\\r\\nl=0;\\r\\nfor (i=0; i<ri->version->length; i++)\\r\\n{ l<<=8; l+=ri->version->data[i]; }\\r\\nif(BIO_printf(bp,\"%8sVersion: %s%lu (%s0x%lx)\\n\",\"\",neg,l,neg,\\r\\nl) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_SUBJECT))\\r\\n{\\r\\nif (BIO_printf(bp,\" Subject:%c\",mlch) <= 0) goto err;\\r\\nif (X509_NAME_print_ex(bp,ri->subject,nmindent, nmflags) < 0) goto err;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_PUBKEY))\\r\\n{\\r\\nif (BIO_write(bp,\" Subject Public Key Info:\\n\",33) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp,\"%12sPublic Key Algorithm: \",\"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ri->pubkey->algor->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\npkey=X509_REQ_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bp,\"%12sUnable to load Public Key\\n\",\"\");\\r\\nERR_print_errors(bp);\\r\\n}\\r\\nelse\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sRSA Public Key: (%d bit)\\n\",\"\",\\r\\nBN_num_bits(pkey->pkey.rsa->n));\\r\\nRSA_print(bp,pkey->pkey.rsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sDSA Public Key:\\n\",\"\");\\r\\nDSA_print(bp,pkey->pkey.dsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nBIO_printf(bp, \"%12sEC Public Key: \\n\",\"\");\\r\\nEC_KEY_print(bp, pkey->pkey.ec, 16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(bp,\"%12sUnknown Public Key:\\n\",\"\");\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_ATTRIBUTES))\\r\\n{\\r\\nif(BIO_printf(bp,\"%8sAttributes:\\n\",\"\") <= 0)\\r\\ngoto err;\\r\\nsk=x->req_info->attributes;\\r\\nif (sk_X509_ATTRIBUTE_num(sk) == 0)\\r\\n{\\r\\nif(BIO_printf(bp,\"%12sa0:00\\n\",\"\") <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)\\r\\n{\\r\\nASN1_TYPE *at;\\r\\nX509_ATTRIBUTE *a;\\r\\nASN1_BIT_STRING *bs=NULL;\\r\\nASN1_TYPE *t;\\r\\nint j,type=0,count=1,ii=0;\\r\\na=sk_X509_ATTRIBUTE_value(sk,i);\\r\\nif(X509_REQ_extension_nid(OBJ_obj2nid(a->object)))\\r\\ncontinue;\\r\\nif(BIO_printf(bp,\"%12s\",\"\") <= 0)\\r\\ngoto err;\\r\\nif ((j=i2a_ASN1_OBJECT(bp,a->object)) > 0)\\r\\n{\\r\\nif (a->single)\\r\\n{\\r\\nt=a->value.single;\\r\\ntype=t->type;\\r\\nbs=t->value.bit_string;\\r\\n}\\r\\nelse\\r\\n{\\r\\nii=0;\\r\\ncount=sk_ASN1_TYPE_num(a->value.set);\\r\\nget_next:\\r\\nat=sk_ASN1_TYPE_value(a->value.set,ii);\\r\\ntype=at->type;\\r\\nbs=at->value.asn1_string;\\r\\n}\\r\\n}\\r\\nfor (j=25-j; j>0; j--)\\r\\nif (BIO_write(bp,\" \",1) != 1) goto err;\\r\\nif (BIO_puts(bp,\":\") <= 0) goto err;\\r\\nif ( (type == V_ASN1_PRINTABLESTRING) ||\\r\\n(type == V_ASN1_T61STRING) ||\\r\\n(type == V_ASN1_IA5STRING))\\r\\n{\\r\\nif (BIO_write(bp,(char *)bs->data,bs->length)\\r\\n!= bs->length)\\r\\ngoto err;\\r\\nBIO_puts(bp,\"\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_puts(bp,\"unable to print attribute\\n\");\\r\\n}\\r\\nif (++ii < count) goto get_next;\\r\\n}\\r\\n}\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_ATTRIBUTES))\\r\\n{\\r\\nexts = X509_REQ_get_extensions(x);\\r\\nif(exts)\\r\\n{\\r\\nBIO_printf(bp,\"%8sRequested Extensions:\\n\",\"\");\\r\\nfor (i=0; i<sk_X509_EXTENSION_num(exts); i++)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nX509_EXTENSION *ex;\\r\\nint j;\\r\\nex=sk_X509_EXTENSION_value(exts, i);\\r\\nif (BIO_printf(bp,\"%12s\",\"\") <= 0) goto err;\\r\\nobj=X509_EXTENSION_get_object(ex);\\r\\ni2a_ASN1_OBJECT(bp,obj);\\r\\nj=X509_EXTENSION_get_critical(ex);\\r\\nif (BIO_printf(bp,\": %s\\n\",j?\"critical\":\"\") <= 0)\\r\\ngoto err;\\r\\nif(!X509V3_EXT_print(bp, ex, 0, 16))\\r\\n{\\r\\nBIO_printf(bp, \"%16s\", \"\");\\r\\nM_ASN1_OCTET_STRING_print(bp,ex->value);\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\n}\\r\\n}\\r\\nif(!(cflag & X509_FLAG_NO_SIGDUMP))\\r\\n{\\r\\nif(!X509_signature_print(bp, x->sig_alg, x->signature)) goto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nX509err(X509_F_X509_REQ_PRINT_EX,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nint X509_REQ_print(BIO *bp, X509_REQ *x)\\r\\n{\\r\\nreturn X509_REQ_print_ex(bp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ultrixcc_c", "target": 0, "func": "main()\\r\\n{\\r\\nf(5);\\r\\nf(0);\\r\\n}\\r\\nint f(a)\\r\\nint a;\\r\\n{\\r\\nswitch(a&7)\\r\\n{\\r\\ncase 7:\\r\\nprintf(\"7\\n\");\\r\\ncase 6:\\r\\nprintf(\"6\\n\");\\r\\ncase 5:\\r\\nprintf(\"5\\n\");\\r\\ncase 4:\\r\\nprintf(\"4\\n\");\\r\\ncase 3:\\r\\nprintf(\"3\\n\");\\r\\ncase 2:\\r\\nprintf(\"2\\n\");\\r\\ncase 1:\\r\\nprintf(\"1\\n\");\\r\\n#ifdef FIX_BUG\\r\\ncase 0:\\r\\n;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_ofb64_c", "target": 0, "func": "void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int *num)\\r\\n{\\r\\nregister BF_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_encode_c", "target": 0, "func": "void EVP_EncodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length=48;\\r\\nctx->num=0;\\r\\nctx->line_num=0;\\r\\n}\\r\\nvoid EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint i,j;\\r\\nunsigned int total=0;\\r\\n*outl=0;\\r\\nif (inl == 0) return;\\r\\nOPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\\r\\nif ((ctx->num+inl) < ctx->length)\\r\\n{\\r\\nmemcpy(&(ctx->enc_data[ctx->num]),in,inl);\\r\\nctx->num+=inl;\\r\\nreturn;\\r\\n}\\r\\nif (ctx->num != 0)\\r\\n{\\r\\ni=ctx->length-ctx->num;\\r\\nmemcpy(&(ctx->enc_data[ctx->num]),in,i);\\r\\nin+=i;\\r\\ninl-=i;\\r\\nj=EVP_EncodeBlock(out,ctx->enc_data,ctx->length);\\r\\nctx->num=0;\\r\\nout+=j;\\r\\n*(out++)='\\n';\\r\\n*out='\\0';\\r\\ntotal=j+1;\\r\\n}\\r\\nwhile (inl >= ctx->length)\\r\\n{\\r\\nj=EVP_EncodeBlock(out,in,ctx->length);\\r\\nin+=ctx->length;\\r\\ninl-=ctx->length;\\r\\nout+=j;\\r\\n*(out++)='\\n';\\r\\n*out='\\0';\\r\\ntotal+=j+1;\\r\\n}\\r\\nif (inl != 0)\\r\\nmemcpy(&(ctx->enc_data[0]),in,inl);\\r\\nctx->num=inl;\\r\\n*outl=total;\\r\\n}\\r\\nvoid EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nunsigned int ret=0;\\r\\nif (ctx->num != 0)\\r\\n{\\r\\nret=EVP_EncodeBlock(out,ctx->enc_data,ctx->num);\\r\\nout[ret++]='\\n';\\r\\nout[ret]='\\0';\\r\\nctx->num=0;\\r\\n}\\r\\n*outl=ret;\\r\\n}\\r\\nint EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int dlen)\\r\\n{\\r\\nint i,ret=0;\\r\\nunsigned long l;\\r\\nfor (i=dlen; i > 0; i-=3)\\r\\n{\\r\\nif (i >= 3)\\r\\n{\\r\\nl= (((unsigned long)f[0])<<16L)|\\r\\n(((unsigned long)f[1])<< 8L)|f[2];\\r\\n*(t++)=conv_bin2ascii(l>>18L);\\r\\n*(t++)=conv_bin2ascii(l>>12L);\\r\\n*(t++)=conv_bin2ascii(l>> 6L);\\r\\n*(t++)=conv_bin2ascii(l );\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=((unsigned long)f[0])<<16L;\\r\\nif (i == 2) l|=((unsigned long)f[1]<<8L);\\r\\n*(t++)=conv_bin2ascii(l>>18L);\\r\\n*(t++)=conv_bin2ascii(l>>12L);\\r\\n*(t++)=(i == 1)?'=':conv_bin2ascii(l>> 6L);\\r\\n*(t++)='=';\\r\\n}\\r\\nret+=4;\\r\\nf+=3;\\r\\n}\\r\\n*t='\\0';\\r\\nreturn(ret);\\r\\n}\\r\\nvoid EVP_DecodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length=30;\\r\\nctx->num=0;\\r\\nctx->line_num=0;\\r\\nctx->expect_nl=0;\\r\\n}\\r\\nint EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,tmp2,exp_nl;\\r\\nunsigned char *d;\\r\\nn=ctx->num;\\r\\nd=ctx->enc_data;\\r\\nln=ctx->line_num;\\r\\nexp_nl=ctx->expect_nl;\\r\\nif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\\r\\n{ rv=0; goto end; }\\r\\nfor (i=0; i<inl; i++)\\r\\n{\\r\\nif (ln >= 80) { rv= -1; goto end; }\\r\\ntmp= *(in++);\\r\\nv=conv_ascii2bin(tmp);\\r\\nif (!B64_NOT_BASE64(v))\\r\\n{\\r\\nOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\\r\\nd[n++]=tmp;\\r\\nln++;\\r\\n}\\r\\nelse if (v == B64_ERROR)\\r\\n{\\r\\nrv= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (tmp == '=')\\r\\n{\\r\\nif (seof == -1) seof=n;\\r\\neof++;\\r\\n}\\r\\nif (v == B64_CR)\\r\\n{\\r\\nln = 0;\\r\\nif (exp_nl)\\r\\ncontinue;\\r\\n}\\r\\nif (v == B64_EOLN)\\r\\n{\\r\\nln=0;\\r\\nif (exp_nl)\\r\\n{\\r\\nexp_nl=0;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nexp_nl=0;\\r\\nif (((i+1) == inl) && (((n&3) == 0) || eof))\\r\\n{\\r\\nv=B64_EOF;\\r\\neof = 0;\\r\\nif (d[n-1] == '=') eof++;\\r\\nif (d[n-2] == '=') eof++;\\r\\n}\\r\\nif ((v == B64_EOF && (n&3) == 0) || (n >= 64))\\r\\n{\\r\\nif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\\r\\ntmp2=v;\\r\\nif (n > 0)\\r\\n{\\r\\nv=EVP_DecodeBlock(out,d,n);\\r\\nn=0;\\r\\nif (v < 0) { rv=0; goto end; }\\r\\nret+=(v-eof);\\r\\n}\\r\\nelse\\r\\n{\\r\\neof=1;\\r\\nv=0;\\r\\n}\\r\\nif ((v < ctx->length) && eof)\\r\\n{\\r\\nrv=0;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\nctx->length=v;\\r\\nif (seof >= 0) { rv=0; goto end; }\\r\\nout+=v;\\r\\n}\\r\\n}\\r\\nrv=1;\\r\\nend:\\r\\n*outl=ret;\\r\\nctx->num=n;\\r\\nctx->line_num=ln;\\r\\nctx->expect_nl=exp_nl;\\r\\nreturn(rv);\\r\\n}\\r\\nint EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n)\\r\\n{\\r\\nint i,ret=0,a,b,c,d;\\r\\nunsigned long l;\\r\\nwhile ((conv_ascii2bin(*f) == B64_WS) && (n > 0))\\r\\n{\\r\\nf++;\\r\\nn--;\\r\\n}\\r\\nwhile ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n-1]))))\\r\\nn--;\\r\\nif (n%4 != 0) return(-1);\\r\\nfor (i=0; i<n; i+=4)\\r\\n{\\r\\na=conv_ascii2bin(*(f++));\\r\\nb=conv_ascii2bin(*(f++));\\r\\nc=conv_ascii2bin(*(f++));\\r\\nd=conv_ascii2bin(*(f++));\\r\\nif ( (a & 0x80) || (b & 0x80) ||\\r\\n(c & 0x80) || (d & 0x80))\\r\\nreturn(-1);\\r\\nl=( (((unsigned long)a)<<18L)|\\r\\n(((unsigned long)b)<<12L)|\\r\\n(((unsigned long)c)<< 6L)|\\r\\n(((unsigned long)d) ));\\r\\n*(t++)=(unsigned char)(l>>16L)&0xff;\\r\\n*(t++)=(unsigned char)(l>> 8L)&0xff;\\r\\n*(t++)=(unsigned char)(l )&0xff;\\r\\nret+=3;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\n*outl=0;\\r\\nif (ctx->num != 0)\\r\\n{\\r\\ni=EVP_DecodeBlock(out,ctx->enc_data,ctx->num);\\r\\nif (i < 0) return(-1);\\r\\nctx->num=0;\\r\\n*outl=i;\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint EVP_DecodeValid(unsigned char *buf, int len)\\r\\n{\\r\\nint i,num=0,bad=0;\\r\\nif (len == 0) return(-1);\\r\\nwhile (conv_ascii2bin(*buf) == B64_WS)\\r\\n{\\r\\nbuf++;\\r\\nlen--;\\r\\nif (len == 0) return(-1);\\r\\n}\\r\\nfor (i=len; i >= 4; i-=4)\\r\\n{\\r\\nif ( (conv_ascii2bin(buf[0]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[1]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[2]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[3]) >= 0x40))\\r\\nreturn(-1);\\r\\nbuf+=4;\\r\\nnum+=1+(buf[2] != '=')+(buf[3] != '=');\\r\\n}\\r\\nif ((i == 1) && (conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn(num);\\r\\nif ((i == 2) && (conv_ascii2bin(buf[0]) == B64_EOLN) &&\\r\\n(conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn(num);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_file_c", "target": 0, "func": "BIO *BIO_new_file(const char *filename, const char *mode)\\r\\n{\\r\\nBIO *ret;\\r\\nFILE *file;\\r\\nif ((file=fopen(filename,mode)) == NULL)\\r\\n{\\r\\nSYSerr(SYS_F_FOPEN,get_last_sys_error());\\r\\nERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\\r\\nif (errno == ENOENT)\\r\\nBIOerr(BIO_F_BIO_NEW_FILE,BIO_R_NO_SUCH_FILE);\\r\\nelse\\r\\nBIOerr(BIO_F_BIO_NEW_FILE,ERR_R_SYS_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nif ((ret=BIO_new(BIO_s_file_internal())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_clear_flags(ret,BIO_FLAGS_UPLINK);\\r\\nBIO_set_fp(ret,file,BIO_CLOSE);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_fp(FILE *stream, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nif ((ret=BIO_new(BIO_s_file())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_set_flags(ret,BIO_FLAGS_UPLINK);\\r\\nBIO_set_fp(ret,stream,close_flag);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO_METHOD *BIO_s_file(void)\\r\\n{\\r\\nreturn(&methods_filep);\\r\\n}\\r\\nstatic int MS_CALLBACK file_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=0;\\r\\nbi->ptr=NULL;\\r\\nbi->flags=BIO_FLAGS_UPLINK;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif ((a->init) && (a->ptr != NULL))\\r\\n{\\r\\nif (a->flags&BIO_FLAGS_UPLINK)\\r\\nUP_fclose (a->ptr);\\r\\nelse\\r\\nfclose (a->ptr);\\r\\na->ptr=NULL;\\r\\na->flags=BIO_FLAGS_UPLINK;\\r\\n}\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (b->init && (out != NULL))\\r\\n{\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nret=UP_fread(out,1,(int)outl,b->ptr);\\r\\nelse\\r\\nret=fread(out,1,(int)outl,(FILE *)b->ptr);\\r\\nif(ret == 0 && (b->flags&BIO_FLAGS_UPLINK)?UP_ferror((FILE *)b->ptr):ferror((FILE *)b->ptr))\\r\\n{\\r\\nSYSerr(SYS_F_FREAD,get_last_sys_error());\\r\\nBIOerr(BIO_F_FILE_READ,ERR_R_SYS_LIB);\\r\\nret=-1;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nif (b->init && (in != NULL))\\r\\n{\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nret=UP_fwrite(in,(int)inl,1,b->ptr);\\r\\nelse\\r\\nret=fwrite(in,(int)inl,1,(FILE *)b->ptr);\\r\\nif (ret)\\r\\nret=inl;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nFILE *fp=(FILE *)b->ptr;\\r\\nFILE **fpp;\\r\\nchar p[4];\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_FILE_SEEK:\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nret=(long)UP_fseek(b->ptr,num,0);\\r\\nelse\\r\\nret=(long)fseek(fp,num,0);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nret=(long)UP_feof(fp);\\r\\nelse\\r\\nret=(long)feof(fp);\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nret=UP_ftell(b->ptr);\\r\\nelse\\r\\nret=ftell(fp);\\r\\nbreak;\\r\\ncase BIO_C_SET_FILE_PTR:\\r\\nfile_free(b);\\r\\nb->shutdown=(int)num&BIO_CLOSE;\\r\\nb->ptr=ptr;\\r\\nb->init=1;\\r\\n#if BIO_FLAGS_UPLINK!=0\\r\\n#if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\\r\\n#define _IOB_ENTRIES 20\\r\\n#endif\\r\\n#if defined(_IOB_ENTRIES)\\r\\nif ((size_t)ptr >= (size_t)stdin &&\\r\\n(size_t)ptr < (size_t)(stdin+_IOB_ENTRIES))\\r\\nBIO_clear_flags(b,BIO_FLAGS_UPLINK);\\r\\n#endif\\r\\n#endif\\r\\n#ifdef UP_fsetmode\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nUP_fsetmode(b->ptr,num&BIO_FP_TEXT?'t':'b');\\r\\nelse\\r\\n#endif\\r\\n{\\r\\n#if defined(OPENSSL_SYS_WINDOWS)\\r\\nint fd = fileno((FILE*)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fd,_O_TEXT);\\r\\nelse\\r\\n_setmode(fd,_O_BINARY);\\r\\n#elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\\r\\nint fd = fileno((FILE*)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fd,O_TEXT);\\r\\nelse\\r\\n_setmode(fd,O_BINARY);\\r\\n#elif defined(OPENSSL_SYS_MSDOS)\\r\\nint fd = fileno((FILE*)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fd,_O_TEXT);\\r\\nelse\\r\\n{\\r\\nif (fd == STDIN_FILENO || fd == STDOUT_FILENO)\\r\\n{\\r\\nif (isatty(fd) <= 0)\\r\\n_setmode(fd,_O_BINARY);\\r\\n}\\r\\nelse\\r\\n_setmode(fd,_O_BINARY);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_OS2)\\r\\nint fd = fileno((FILE*)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\nsetmode(fd, O_TEXT);\\r\\nelse\\r\\nsetmode(fd, O_BINARY);\\r\\n#endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_FILENAME:\\r\\nfile_free(b);\\r\\nb->shutdown=(int)num&BIO_CLOSE;\\r\\nif (num & BIO_FP_APPEND)\\r\\n{\\r\\nif (num & BIO_FP_READ)\\r\\nBUF_strlcpy(p,\"a+\",sizeof p);\\r\\nelse BUF_strlcpy(p,\"a\",sizeof p);\\r\\n}\\r\\nelse if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))\\r\\nBUF_strlcpy(p,\"r+\",sizeof p);\\r\\nelse if (num & BIO_FP_WRITE)\\r\\nBUF_strlcpy(p,\"w\",sizeof p);\\r\\nelse if (num & BIO_FP_READ)\\r\\nBUF_strlcpy(p,\"r\",sizeof p);\\r\\nelse\\r\\n{\\r\\nBIOerr(BIO_F_FILE_CTRL,BIO_R_BAD_FOPEN_MODE);\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\n#if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\\r\\nif (!(num & BIO_FP_TEXT))\\r\\nstrcat(p,\"b\");\\r\\nelse\\r\\nstrcat(p,\"t\");\\r\\n#endif\\r\\n#if defined(OPENSSL_SYS_NETWARE)\\r\\nif (!(num & BIO_FP_TEXT))\\r\\nstrcat(p,\"b\");\\r\\nelse\\r\\nstrcat(p,\"t\");\\r\\n#endif\\r\\nfp=fopen(ptr,p);\\r\\nif (fp == NULL)\\r\\n{\\r\\nSYSerr(SYS_F_FOPEN,get_last_sys_error());\\r\\nERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\\r\\nBIOerr(BIO_F_FILE_CTRL,ERR_R_SYS_LIB);\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nb->ptr=fp;\\r\\nb->init=1;\\r\\nBIO_clear_flags(b,BIO_FLAGS_UPLINK);\\r\\nbreak;\\r\\ncase BIO_C_GET_FILE_PTR:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nfpp=(FILE **)ptr;\\r\\n*fpp=(FILE *)b->ptr;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=(long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->flags&BIO_FLAGS_UPLINK)\\r\\nUP_fflush(b->ptr);\\r\\nelse\\r\\nfflush((FILE *)b->ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,size,(FILE *)bp->ptr);\\r\\nif (buf[0] != '\\0')\\r\\nret=strlen(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=file_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_mod_c", "target": 0, "func": "int CONF_modules_load(const CONF *cnf, const char *appname,\\r\\nunsigned long flags)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *values;\\r\\nCONF_VALUE *vl;\\r\\nchar *vsection;\\r\\nint ret, i;\\r\\nif (!cnf)\\r\\nreturn 1;\\r\\nif (appname == NULL)\\r\\nappname = \"openssl_conf\";\\r\\nvsection = NCONF_get_string(cnf, NULL, appname);\\r\\nif (!vsection)\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nvalues = NCONF_get_section(cnf, vsection);\\r\\nif (!values)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(values); i++)\\r\\n{\\r\\nvl = sk_CONF_VALUE_value(values, i);\\r\\nret = module_run(cnf, vl->name, vl->value, flags);\\r\\nif (ret <= 0)\\r\\nif(!(flags & CONF_MFLAGS_IGNORE_ERRORS))\\r\\nreturn ret;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint CONF_modules_load_file(const char *filename, const char *appname,\\r\\nunsigned long flags)\\r\\n{\\r\\nchar *file = NULL;\\r\\nCONF *conf = NULL;\\r\\nint ret = 0;\\r\\nconf = NCONF_new(NULL);\\r\\nif (!conf)\\r\\ngoto err;\\r\\nif (filename == NULL)\\r\\n{\\r\\nfile = CONF_get1_default_config_file();\\r\\nif (!file)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nfile = (char *)filename;\\r\\nif (NCONF_load(conf, file, NULL) <= 0)\\r\\n{\\r\\nif ((flags & CONF_MFLAGS_IGNORE_MISSING_FILE) &&\\r\\n(ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE))\\r\\n{\\r\\nERR_clear_error();\\r\\nret = 1;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nret = CONF_modules_load(conf, appname, flags);\\r\\nerr:\\r\\nif (filename == NULL)\\r\\nOPENSSL_free(file);\\r\\nNCONF_free(conf);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int module_run(const CONF *cnf, char *name, char *value,\\r\\nunsigned long flags)\\r\\n{\\r\\nCONF_MODULE *md;\\r\\nint ret;\\r\\nmd = module_find(name);\\r\\nif (!md && !(flags & CONF_MFLAGS_NO_DSO))\\r\\nmd = module_load_dso(cnf, name, value, flags);\\r\\nif (!md)\\r\\n{\\r\\nif (!(flags & CONF_MFLAGS_SILENT))\\r\\n{\\r\\nCONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);\\r\\nERR_add_error_data(2, \"module=\", name);\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nret = module_init(md, name, value, cnf);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (!(flags & CONF_MFLAGS_SILENT))\\r\\n{\\r\\nchar rcode[DECIMAL_SIZE(ret)+1];\\r\\nCONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);\\r\\nBIO_snprintf(rcode, sizeof rcode, \"%-8d\", ret);\\r\\nERR_add_error_data(6, \"module=\", name, \", value=\", value, \", retcode=\", rcode);\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic CONF_MODULE *module_load_dso(const CONF *cnf, char *name, char *value,\\r\\nunsigned long flags)\\r\\n{\\r\\nDSO *dso = NULL;\\r\\nconf_init_func *ifunc;\\r\\nconf_finish_func *ffunc;\\r\\nchar *path = NULL;\\r\\nint errcode = 0;\\r\\nCONF_MODULE *md;\\r\\npath = NCONF_get_string(cnf, value, \"path\");\\r\\nif (!path)\\r\\n{\\r\\nERR_clear_error();\\r\\npath = name;\\r\\n}\\r\\ndso = DSO_load(NULL, path, NULL, 0);\\r\\nif (!dso)\\r\\n{\\r\\nerrcode = CONF_R_ERROR_LOADING_DSO;\\r\\ngoto err;\\r\\n}\\r\\nifunc = (conf_init_func *)DSO_bind_func(dso, DSO_mod_init_name);\\r\\nif (!ifunc)\\r\\n{\\r\\nerrcode = CONF_R_MISSING_INIT_FUNCTION;\\r\\ngoto err;\\r\\n}\\r\\nffunc = (conf_finish_func *)DSO_bind_func(dso, DSO_mod_finish_name);\\r\\nmd = module_add(dso, name, ifunc, ffunc);\\r\\nif (!md)\\r\\ngoto err;\\r\\nreturn md;\\r\\nerr:\\r\\nif (dso)\\r\\nDSO_free(dso);\\r\\nCONFerr(CONF_F_MODULE_LOAD_DSO, errcode);\\r\\nERR_add_error_data(4, \"module=\", name, \", path=\", path);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic CONF_MODULE *module_add(DSO *dso, const char *name,\\r\\nconf_init_func *ifunc, conf_finish_func *ffunc)\\r\\n{\\r\\nCONF_MODULE *tmod = NULL;\\r\\nif (supported_modules == NULL)\\r\\nsupported_modules = sk_CONF_MODULE_new_null();\\r\\nif (supported_modules == NULL)\\r\\nreturn NULL;\\r\\ntmod = OPENSSL_malloc(sizeof(CONF_MODULE));\\r\\nif (tmod == NULL)\\r\\nreturn NULL;\\r\\ntmod->dso = dso;\\r\\ntmod->name = BUF_strdup(name);\\r\\ntmod->init = ifunc;\\r\\ntmod->finish = ffunc;\\r\\ntmod->links = 0;\\r\\nif (!sk_CONF_MODULE_push(supported_modules, tmod))\\r\\n{\\r\\nOPENSSL_free(tmod);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn tmod;\\r\\n}\\r\\nstatic CONF_MODULE *module_find(char *name)\\r\\n{\\r\\nCONF_MODULE *tmod;\\r\\nint i, nchar;\\r\\nchar *p;\\r\\np = strrchr(name, '.');\\r\\nif (p)\\r\\nnchar = p - name;\\r\\nelse\\r\\nnchar = strlen(name);\\r\\nfor (i = 0; i < sk_CONF_MODULE_num(supported_modules); i++)\\r\\n{\\r\\ntmod = sk_CONF_MODULE_value(supported_modules, i);\\r\\nif (!strncmp(tmod->name, name, nchar))\\r\\nreturn tmod;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int module_init(CONF_MODULE *pmod, char *name, char *value,\\r\\nconst CONF *cnf)\\r\\n{\\r\\nint ret = 1;\\r\\nint init_called = 0;\\r\\nCONF_IMODULE *imod = NULL;\\r\\nimod = OPENSSL_malloc(sizeof(CONF_IMODULE));\\r\\nif (!imod)\\r\\ngoto err;\\r\\nimod->pmod = pmod;\\r\\nimod->name = BUF_strdup(name);\\r\\nimod->value = BUF_strdup(value);\\r\\nimod->usr_data = NULL;\\r\\nif (!imod->name || !imod->value)\\r\\ngoto memerr;\\r\\nif(pmod->init)\\r\\n{\\r\\nret = pmod->init(imod, cnf);\\r\\ninit_called = 1;\\r\\nif (ret <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (initialized_modules == NULL)\\r\\n{\\r\\ninitialized_modules = sk_CONF_IMODULE_new_null();\\r\\nif (!initialized_modules)\\r\\n{\\r\\nCONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!sk_CONF_IMODULE_push(initialized_modules, imod))\\r\\n{\\r\\nCONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npmod->links++;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (pmod->finish && init_called)\\r\\npmod->finish(imod);\\r\\nmemerr:\\r\\nif (imod)\\r\\n{\\r\\nif (imod->name)\\r\\nOPENSSL_free(imod->name);\\r\\nif (imod->value)\\r\\nOPENSSL_free(imod->value);\\r\\nOPENSSL_free(imod);\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nvoid CONF_modules_unload(int all)\\r\\n{\\r\\nint i;\\r\\nCONF_MODULE *md;\\r\\nCONF_modules_finish();\\r\\nfor (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--)\\r\\n{\\r\\nmd = sk_CONF_MODULE_value(supported_modules, i);\\r\\nif (((md->links > 0) || !md->dso) && !all)\\r\\ncontinue;\\r\\nsk_CONF_MODULE_delete(supported_modules, i);\\r\\nmodule_free(md);\\r\\n}\\r\\nif (sk_CONF_MODULE_num(supported_modules) == 0)\\r\\n{\\r\\nsk_CONF_MODULE_free(supported_modules);\\r\\nsupported_modules = NULL;\\r\\n}\\r\\n}\\r\\nstatic void module_free(CONF_MODULE *md)\\r\\n{\\r\\nif (md->dso)\\r\\nDSO_free(md->dso);\\r\\nOPENSSL_free(md->name);\\r\\nOPENSSL_free(md);\\r\\n}\\r\\nvoid CONF_modules_finish(void)\\r\\n{\\r\\nCONF_IMODULE *imod;\\r\\nwhile (sk_CONF_IMODULE_num(initialized_modules) > 0)\\r\\n{\\r\\nimod = sk_CONF_IMODULE_pop(initialized_modules);\\r\\nmodule_finish(imod);\\r\\n}\\r\\nsk_CONF_IMODULE_free(initialized_modules);\\r\\ninitialized_modules = NULL;\\r\\n}\\r\\nstatic void module_finish(CONF_IMODULE *imod)\\r\\n{\\r\\nif (imod->pmod->finish)\\r\\nimod->pmod->finish(imod);\\r\\nimod->pmod->links--;\\r\\nOPENSSL_free(imod->name);\\r\\nOPENSSL_free(imod->value);\\r\\nOPENSSL_free(imod);\\r\\n}\\r\\nint CONF_module_add(const char *name, conf_init_func *ifunc,\\r\\nconf_finish_func *ffunc)\\r\\n{\\r\\nif (module_add(NULL, name, ifunc, ffunc))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nvoid CONF_modules_free(void)\\r\\n{\\r\\nCONF_modules_finish();\\r\\nCONF_modules_unload(1);\\r\\n}\\r\\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->name;\\r\\n}\\r\\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->value;\\r\\n}\\r\\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->usr_data;\\r\\n}\\r\\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)\\r\\n{\\r\\nmd->usr_data = usr_data;\\r\\n}\\r\\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->pmod;\\r\\n}\\r\\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->flags;\\r\\n}\\r\\nvoid CONF_imodule_set_flags(CONF_IMODULE *md, unsigned long flags)\\r\\n{\\r\\nmd->flags = flags;\\r\\n}\\r\\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\\r\\n{\\r\\nreturn pmod->usr_data;\\r\\n}\\r\\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)\\r\\n{\\r\\npmod->usr_data = usr_data;\\r\\n}\\r\\nchar *CONF_get1_default_config_file(void)\\r\\n{\\r\\nchar *file;\\r\\nint len;\\r\\nfile = getenv(\"OPENSSL_CONF\");\\r\\nif (file)\\r\\nreturn BUF_strdup(file);\\r\\nlen = strlen(X509_get_default_cert_area());\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nlen++;\\r\\n#endif\\r\\nlen += strlen(OPENSSL_CONF);\\r\\nfile = OPENSSL_malloc(len + 1);\\r\\nif (!file)\\r\\nreturn NULL;\\r\\nBUF_strlcpy(file,X509_get_default_cert_area(),len + 1);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(file,\"/\",len + 1);\\r\\n#endif\\r\\nBUF_strlcat(file,OPENSSL_CONF,len + 1);\\r\\nreturn file;\\r\\n}\\r\\nint CONF_parse_list(const char *list_, int sep, int nospc,\\r\\nint (*list_cb)(const char *elem, int len, void *usr), void *arg)\\r\\n{\\r\\nint ret;\\r\\nconst char *lstart, *tmpend, *p;\\r\\nlstart = list_;\\r\\nfor(;;)\\r\\n{\\r\\nif (nospc)\\r\\n{\\r\\nwhile(*lstart && isspace((unsigned char)*lstart))\\r\\nlstart++;\\r\\n}\\r\\np = strchr(lstart, sep);\\r\\nif (p == lstart || !*lstart)\\r\\nret = list_cb(NULL, 0, arg);\\r\\nelse\\r\\n{\\r\\nif (p)\\r\\ntmpend = p - 1;\\r\\nelse\\r\\ntmpend = lstart + strlen(lstart) - 1;\\r\\nif (nospc)\\r\\n{\\r\\nwhile(isspace((unsigned char)*tmpend))\\r\\ntmpend--;\\r\\n}\\r\\nret = list_cb(lstart, tmpend - lstart + 1, arg);\\r\\n}\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nif (p == NULL)\\r\\nreturn 1;\\r\\nlstart = p + 1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_def_c", "target": 0, "func": "CONF_METHOD *NCONF_default()\\r\\n{\\r\\nreturn &default_method;\\r\\n}\\r\\nCONF_METHOD *NCONF_WIN32()\\r\\n{\\r\\nreturn &WIN32_method;\\r\\n}\\r\\nstatic CONF *def_create(CONF_METHOD *meth)\\r\\n{\\r\\nCONF *ret;\\r\\nret = (CONF *)OPENSSL_malloc(sizeof(CONF) + sizeof(unsigned short *));\\r\\nif (ret)\\r\\nif (meth->init(ret) == 0)\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int def_init_default(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\nconf->meth = &default_method;\\r\\nconf->meth_data = (void *)CONF_type_default;\\r\\nconf->data = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_init_WIN32(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\nconf->meth = &WIN32_method;\\r\\nconf->meth_data = (void *)CONF_type_win32;\\r\\nconf->data = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_destroy(CONF *conf)\\r\\n{\\r\\nif (def_destroy_data(conf))\\r\\n{\\r\\nOPENSSL_free(conf);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int def_destroy_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\n_CONF_free_data(conf);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_load(CONF *conf, const char *name, long *line)\\r\\n{\\r\\nint ret;\\r\\nBIO *in=NULL;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nin=BIO_new_file(name, \"r\");\\r\\n#else\\r\\nin=BIO_new_file(name, \"rb\");\\r\\n#endif\\r\\nif (in == NULL)\\r\\n{\\r\\nif (ERR_GET_REASON(ERR_peek_last_error()) == BIO_R_NO_SUCH_FILE)\\r\\nCONFerr(CONF_F_DEF_LOAD,CONF_R_NO_SUCH_FILE);\\r\\nelse\\r\\nCONFerr(CONF_F_DEF_LOAD,ERR_R_SYS_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = def_load_bio(conf, in, line);\\r\\nBIO_free(in);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int def_load_bio(CONF *conf, BIO *in, long *line)\\r\\n{\\r\\n#define CONFBUFSIZE 512\\r\\nint bufnum=0,i,ii;\\r\\nBUF_MEM *buff=NULL;\\r\\nchar *s,*p,*end;\\r\\nint again,n;\\r\\nlong eline=0;\\r\\nchar btmp[DECIMAL_SIZE(eline)+1];\\r\\nCONF_VALUE *v=NULL,*tv;\\r\\nCONF_VALUE *sv=NULL;\\r\\nchar *section=NULL,*buf;\\r\\nSTACK_OF(CONF_VALUE) *section_sk=NULL,*ts;\\r\\nchar *start,*psection,*pname;\\r\\nvoid *h = (void *)(conf->data);\\r\\nif ((buff=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nsection=(char *)OPENSSL_malloc(10);\\r\\nif (section == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(section,\"default\",10);\\r\\nif (_CONF_new_data(conf) == 0)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nsv=_CONF_new_section(conf,section);\\r\\nif (sv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\\r\\nbufnum=0;\\r\\nagain=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BUF_MEM_grow(buff,bufnum+CONFBUFSIZE))\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np= &(buff->data[bufnum]);\\r\\n*p='\\0';\\r\\nBIO_gets(in, p, CONFBUFSIZE-1);\\r\\np[CONFBUFSIZE-1]='\\0';\\r\\nii=i=strlen(p);\\r\\nif (i == 0 && !again) break;\\r\\nagain=0;\\r\\nwhile (i > 0)\\r\\n{\\r\\nif ((p[i-1] != '\\r') && (p[i-1] != '\\n'))\\r\\nbreak;\\r\\nelse\\r\\ni--;\\r\\n}\\r\\nif (ii && i == ii)\\r\\nagain=1;\\r\\nelse\\r\\n{\\r\\np[i]='\\0';\\r\\neline++;\\r\\n}\\r\\nbufnum+=i;\\r\\nv=NULL;\\r\\nif (bufnum >= 1)\\r\\n{\\r\\np= &(buff->data[bufnum-1]);\\r\\nif (IS_ESC(conf,p[0]) &&\\r\\n((bufnum <= 1) || !IS_ESC(conf,p[-1])))\\r\\n{\\r\\nbufnum--;\\r\\nagain=1;\\r\\n}\\r\\n}\\r\\nif (again) continue;\\r\\nbufnum=0;\\r\\nbuf=buff->data;\\r\\nclear_comments(conf, buf);\\r\\nn=strlen(buf);\\r\\ns=eat_ws(conf, buf);\\r\\nif (IS_EOF(conf,*s)) continue;\\r\\nif (*s == '[')\\r\\n{\\r\\nchar *ss;\\r\\ns++;\\r\\nstart=eat_ws(conf, s);\\r\\nss=start;\\r\\nagain:\\r\\nend=eat_alpha_numeric(conf, ss);\\r\\np=eat_ws(conf, end);\\r\\nif (*p != ']')\\r\\n{\\r\\nif (*p != '\\0')\\r\\n{\\r\\nss=p;\\r\\ngoto again;\\r\\n}\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_MISSING_CLOSE_SQUARE_BRACKET);\\r\\ngoto err;\\r\\n}\\r\\n*end='\\0';\\r\\nif (!str_copy(conf,NULL,&section,start)) goto err;\\r\\nif ((sv=_CONF_get_section(conf,section)) == NULL)\\r\\nsv=_CONF_new_section(conf,section);\\r\\nif (sv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\npname=s;\\r\\npsection=NULL;\\r\\nend=eat_alpha_numeric(conf, s);\\r\\nif ((end[0] == ':') && (end[1] == ':'))\\r\\n{\\r\\n*end='\\0';\\r\\nend+=2;\\r\\npsection=pname;\\r\\npname=end;\\r\\nend=eat_alpha_numeric(conf, end);\\r\\n}\\r\\np=eat_ws(conf, end);\\r\\nif (*p != '=')\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_MISSING_EQUAL_SIGN);\\r\\ngoto err;\\r\\n}\\r\\n*end='\\0';\\r\\np++;\\r\\nstart=eat_ws(conf, p);\\r\\nwhile (!IS_EOF(conf,*p))\\r\\np++;\\r\\np--;\\r\\nwhile ((p != start) && (IS_WS(conf,*p)))\\r\\np--;\\r\\np++;\\r\\n*p='\\0';\\r\\nif (!(v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE))))\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (psection == NULL) psection=section;\\r\\nv->name=(char *)OPENSSL_malloc(strlen(pname)+1);\\r\\nv->value=NULL;\\r\\nif (v->name == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(v->name,pname,strlen(pname)+1);\\r\\nif (!str_copy(conf,psection,&(v->value),start)) goto err;\\r\\nif (strcmp(psection,section) != 0)\\r\\n{\\r\\nif ((tv=_CONF_get_section(conf,psection))\\r\\n== NULL)\\r\\ntv=_CONF_new_section(conf,psection);\\r\\nif (tv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nts=(STACK_OF(CONF_VALUE) *)tv->value;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntv=sv;\\r\\nts=section_sk;\\r\\n}\\r\\n#if 1\\r\\nif (_CONF_add_string(conf, tv, v) == 0)\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#else\\r\\nv->section=tv->section;\\r\\nif (!sk_CONF_VALUE_push(ts,v))\\r\\n{\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nvv=(CONF_VALUE *)lh_insert(conf->data,v);\\r\\nif (vv != NULL)\\r\\n{\\r\\nsk_CONF_VALUE_delete_ptr(ts,vv);\\r\\nOPENSSL_free(vv->name);\\r\\nOPENSSL_free(vv->value);\\r\\nOPENSSL_free(vv);\\r\\n}\\r\\n#endif\\r\\nv=NULL;\\r\\n}\\r\\n}\\r\\nif (buff != NULL) BUF_MEM_free(buff);\\r\\nif (section != NULL) OPENSSL_free(section);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (buff != NULL) BUF_MEM_free(buff);\\r\\nif (section != NULL) OPENSSL_free(section);\\r\\nif (line != NULL) *line=eline;\\r\\nBIO_snprintf(btmp,sizeof btmp,\"%ld\",eline);\\r\\nERR_add_error_data(2,\"line \",btmp);\\r\\nif ((h != conf->data) && (conf->data != NULL))\\r\\n{\\r\\nCONF_free(conf->data);\\r\\nconf->data=NULL;\\r\\n}\\r\\nif (v != NULL)\\r\\n{\\r\\nif (v->name != NULL) OPENSSL_free(v->name);\\r\\nif (v->value != NULL) OPENSSL_free(v->value);\\r\\nif (v != NULL) OPENSSL_free(v);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nstatic void clear_comments(CONF *conf, char *p)\\r\\n{\\r\\nchar *to;\\r\\nto=p;\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_FCOMMENT(conf,*p))\\r\\n{\\r\\n*p='\\0';\\r\\nreturn;\\r\\n}\\r\\nif (!IS_WS(conf,*p))\\r\\n{\\r\\nbreak;\\r\\n}\\r\\np++;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_COMMENT(conf,*p))\\r\\n{\\r\\n*p='\\0';\\r\\nreturn;\\r\\n}\\r\\nif (IS_DQUOTE(conf,*p))\\r\\n{\\r\\np=scan_dquote(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_QUOTE(conf,*p))\\r\\n{\\r\\np=scan_quote(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_ESC(conf,*p))\\r\\n{\\r\\np=scan_esc(conf,p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_EOF(conf,*p))\\r\\nreturn;\\r\\nelse\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic int str_copy(CONF *conf, char *section, char **pto, char *from)\\r\\n{\\r\\nint q,r,rr=0,to=0,len=0;\\r\\nchar *s,*e,*rp,*p,*rrp,*np,*cp,v;\\r\\nBUF_MEM *buf;\\r\\nif ((buf=BUF_MEM_new()) == NULL) return(0);\\r\\nlen=strlen(from)+1;\\r\\nif (!BUF_MEM_grow(buf,len)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_QUOTE(conf,*from))\\r\\n{\\r\\nq= *from;\\r\\nfrom++;\\r\\nwhile (!IS_EOF(conf,*from) && (*from != q))\\r\\n{\\r\\nif (IS_ESC(conf,*from))\\r\\n{\\r\\nfrom++;\\r\\nif (IS_EOF(conf,*from)) break;\\r\\n}\\r\\nbuf->data[to++]= *(from++);\\r\\n}\\r\\nif (*from == q) from++;\\r\\n}\\r\\nelse if (IS_DQUOTE(conf,*from))\\r\\n{\\r\\nq= *from;\\r\\nfrom++;\\r\\nwhile (!IS_EOF(conf,*from))\\r\\n{\\r\\nif (*from == q)\\r\\n{\\r\\nif (*(from+1) == q)\\r\\n{\\r\\nfrom++;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf->data[to++]= *(from++);\\r\\n}\\r\\nif (*from == q) from++;\\r\\n}\\r\\nelse if (IS_ESC(conf,*from))\\r\\n{\\r\\nfrom++;\\r\\nv= *(from++);\\r\\nif (IS_EOF(conf,v)) break;\\r\\nelse if (v == 'r') v='\\r';\\r\\nelse if (v == 'n') v='\\n';\\r\\nelse if (v == 'b') v='\\b';\\r\\nelse if (v == 't') v='\\t';\\r\\nbuf->data[to++]= v;\\r\\n}\\r\\nelse if (IS_EOF(conf,*from))\\r\\nbreak;\\r\\nelse if (*from == '$')\\r\\n{\\r\\nrrp=NULL;\\r\\ns= &(from[1]);\\r\\nif (*s == '{')\\r\\nq='}';\\r\\nelse if (*s == '(')\\r\\nq=')';\\r\\nelse q=0;\\r\\nif (q) s++;\\r\\ncp=section;\\r\\ne=np=s;\\r\\nwhile (IS_ALPHA_NUMERIC(conf,*e))\\r\\ne++;\\r\\nif ((e[0] == ':') && (e[1] == ':'))\\r\\n{\\r\\ncp=np;\\r\\nrrp=e;\\r\\nrr= *e;\\r\\n*rrp='\\0';\\r\\ne+=2;\\r\\nnp=e;\\r\\nwhile (IS_ALPHA_NUMERIC(conf,*e))\\r\\ne++;\\r\\n}\\r\\nr= *e;\\r\\n*e='\\0';\\r\\nrp=e;\\r\\nif (q)\\r\\n{\\r\\nif (r != q)\\r\\n{\\r\\nCONFerr(CONF_F_STR_COPY,CONF_R_NO_CLOSE_BRACE);\\r\\ngoto err;\\r\\n}\\r\\ne++;\\r\\n}\\r\\np=_CONF_get_string(conf,cp,np);\\r\\nif (rrp != NULL) *rrp=rr;\\r\\n*rp=r;\\r\\nif (p == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_STR_COPY,CONF_R_VARIABLE_HAS_NO_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_MEM_grow_clean(buf,(strlen(p)+buf->length-(e-from)));\\r\\nwhile (*p)\\r\\nbuf->data[to++]= *(p++);\\r\\nlen -= e-from;\\r\\nfrom=e;\\r\\n}\\r\\nelse\\r\\nbuf->data[to++]= *(from++);\\r\\n}\\r\\nbuf->data[to]='\\0';\\r\\nif (*pto != NULL) OPENSSL_free(*pto);\\r\\n*pto=buf->data;\\r\\nOPENSSL_free(buf);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(0);\\r\\n}\\r\\nstatic char *eat_ws(CONF *conf, char *p)\\r\\n{\\r\\nwhile (IS_WS(conf,*p) && (!IS_EOF(conf,*p)))\\r\\np++;\\r\\nreturn(p);\\r\\n}\\r\\nstatic char *eat_alpha_numeric(CONF *conf, char *p)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_ESC(conf,*p))\\r\\n{\\r\\np=scan_esc(conf,p);\\r\\ncontinue;\\r\\n}\\r\\nif (!IS_ALPHA_NUMERIC_PUNCT(conf,*p))\\r\\nreturn(p);\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic char *scan_quote(CONF *conf, char *p)\\r\\n{\\r\\nint q= *p;\\r\\np++;\\r\\nwhile (!(IS_EOF(conf,*p)) && (*p != q))\\r\\n{\\r\\nif (IS_ESC(conf,*p))\\r\\n{\\r\\np++;\\r\\nif (IS_EOF(conf,*p)) return(p);\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (*p == q) p++;\\r\\nreturn(p);\\r\\n}\\r\\nstatic char *scan_dquote(CONF *conf, char *p)\\r\\n{\\r\\nint q= *p;\\r\\np++;\\r\\nwhile (!(IS_EOF(conf,*p)))\\r\\n{\\r\\nif (*p == q)\\r\\n{\\r\\nif (*(p+1) == q)\\r\\n{\\r\\np++;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbreak;\\r\\n}\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (*p == q) p++;\\r\\nreturn(p);\\r\\n}\\r\\nstatic void dump_value(CONF_VALUE *a, BIO *out)\\r\\n{\\r\\nif (a->name)\\r\\nBIO_printf(out, \"[%s] %s=%s\\n\", a->section, a->name, a->value);\\r\\nelse\\r\\nBIO_printf(out, \"[[%s]]\\n\", a->section);\\r\\n}\\r\\nstatic int def_is_number(const CONF *conf, char c)\\r\\n{\\r\\nreturn IS_NUMBER(conf,c);\\r\\n}\\r\\nstatic int def_to_int(const CONF *conf, char c)\\r\\n{\\r\\nreturn c - '0';\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pcy_node_c", "target": 0, "func": "static int node_cmp(const X509_POLICY_NODE * const *a,\\r\\nconst X509_POLICY_NODE * const *b)\\r\\n{\\r\\nreturn OBJ_cmp((*a)->data->valid_policy, (*b)->data->valid_policy);\\r\\n}\\r\\nX509_POLICY_NODE *level_find_node(const X509_POLICY_LEVEL *level,\\r\\nconst ASN1_OBJECT *id)\\r\\n{\\r\\nreturn tree_find_sk(level->nodes, id);\\r\\n}\\r\\nX509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\\r\\nX509_POLICY_DATA *data,\\r\\nX509_POLICY_NODE *parent,\\r\\nX509_POLICY_TREE *tree)\\r\\n{\\r\\nX509_POLICY_NODE *node;\\r\\nnode = OPENSSL_malloc(sizeof(X509_POLICY_NODE));\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nnode->data = data;\\r\\nnode->parent = parent;\\r\\nnode->nchild = 0;\\r\\nif (level)\\r\\n{\\r\\nif (OBJ_obj2nid(data->valid_policy) == NID_any_policy)\\r\\n{\\r\\nif (level->anyPolicy)\\r\\ngoto node_error;\\r\\nlevel->anyPolicy = node;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!level->nodes)\\r\\nlevel->nodes = policy_node_cmp_new();\\r\\nif (!level->nodes)\\r\\ngoto node_error;\\r\\nif (!sk_X509_POLICY_NODE_push(level->nodes, node))\\r\\ngoto node_error;\\r\\n}\\r\\n}\\r\\nif (tree)\\r\\n{\\r\\nif (!tree->extra_data)\\r\\ntree->extra_data = sk_X509_POLICY_DATA_new_null();\\r\\nif (!tree->extra_data)\\r\\ngoto node_error;\\r\\nif (!sk_X509_POLICY_DATA_push(tree->extra_data, data))\\r\\ngoto node_error;\\r\\n}\\r\\nif (parent)\\r\\nparent->nchild++;\\r\\nreturn node;\\r\\nnode_error:\\r\\npolicy_node_free(node);\\r\\nreturn 0;\\r\\n}\\r\\nvoid policy_node_free(X509_POLICY_NODE *node)\\r\\n{\\r\\nOPENSSL_free(node);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_key_c", "target": 0, "func": "int DSA_generate_key(DSA *dsa)\\r\\n{\\r\\nif(dsa->meth->dsa_keygen)\\r\\nreturn dsa->meth->dsa_keygen(dsa);\\r\\nreturn dsa_builtin_keygen(dsa);\\r\\n}\\r\\nstatic int dsa_builtin_keygen(DSA *dsa)\\r\\n{\\r\\nint ok=0;\\r\\nBN_CTX *ctx=NULL;\\r\\nBIGNUM *pub_key=NULL,*priv_key=NULL;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif (dsa->priv_key == NULL)\\r\\n{\\r\\nif ((priv_key=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npriv_key=dsa->priv_key;\\r\\ndo\\r\\nif (!BN_rand_range(priv_key,dsa->q)) goto err;\\r\\nwhile (BN_is_zero(priv_key));\\r\\nif (dsa->pub_key == NULL)\\r\\n{\\r\\nif ((pub_key=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npub_key=dsa->pub_key;\\r\\n{\\r\\nBIGNUM local_prk;\\r\\nBIGNUM *prk;\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0)\\r\\n{\\r\\nBN_init(&local_prk);\\r\\nprk = &local_prk;\\r\\nBN_with_flags(prk, priv_key, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\nprk = priv_key;\\r\\nif (!BN_mod_exp(pub_key,dsa->g,prk,dsa->p,ctx)) goto err;\\r\\n}\\r\\ndsa->priv_key=priv_key;\\r\\ndsa->pub_key=pub_key;\\r\\nok=1;\\r\\nerr:\\r\\nif ((pub_key != NULL) && (dsa->pub_key == NULL)) BN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dsa->priv_key == NULL)) BN_free(priv_key);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_add_c", "target": 0, "func": "PKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it, int nid1,\\r\\nint nid2)\\r\\n{\\r\\nPKCS12_BAGS *bag;\\r\\nPKCS12_SAFEBAG *safebag;\\r\\nif (!(bag = PKCS12_BAGS_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(nid1);\\r\\nif (!ASN1_item_pack(obj, it, &bag->value.octet)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(safebag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nsafebag->value.bag = bag;\\r\\nsafebag->type = OBJ_nid2obj(nid2);\\r\\nreturn safebag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG(PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nif (!(bag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_KEYBAG,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_keyBag);\\r\\nbag->value.keybag = p8;\\r\\nreturn bag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG(int pbe_nid, const char *pass,\\r\\nint passlen, unsigned char *salt, int saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nif (!(bag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_pkcs8ShroudedKeyBag);\\r\\nif (!(bag->value.shkeybag =\\r\\nPKCS8_encrypt(pbe_nid, NULL, pass, passlen, salt, saltlen, iter,\\r\\np8))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn bag;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i_skey_c", "target": 0, "func": "void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)\\r\\n{\\r\\nint i;\\r\\nregister IDEA_INT *kt,*kf,r0,r1,r2;\\r\\nkt= &(ks->data[0][0]);\\r\\nn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);\\r\\nn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);\\r\\nkf=kt;\\r\\nkt+=8;\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nr2= kf[1];\\r\\nr1= kf[2];\\r\\n*(kt++)= ((r2<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[3];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[4];\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[5];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[6];\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[7];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[0];\\r\\nif (i >= 5) break;\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\n*(kt++)= ((r1<<9) | (r2>>7))&0xffff;\\r\\nkf+=8;\\r\\n}\\r\\n}\\r\\nvoid idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)\\r\\n{\\r\\nint r;\\r\\nregister IDEA_INT *fp,*tp,t;\\r\\ntp= &(dk->data[0][0]);\\r\\nfp= &(ek->data[8][0]);\\r\\nfor (r=0; r<9; r++)\\r\\n{\\r\\n*(tp++)=inverse(fp[0]);\\r\\n*(tp++)=((int)(0x10000L-fp[2])&0xffff);\\r\\n*(tp++)=((int)(0x10000L-fp[1])&0xffff);\\r\\n*(tp++)=inverse(fp[3]);\\r\\nif (r == 8) break;\\r\\nfp-=6;\\r\\n*(tp++)=fp[4];\\r\\n*(tp++)=fp[5];\\r\\n}\\r\\ntp= &(dk->data[0][0]);\\r\\nt=tp[1];\\r\\ntp[1]=tp[2];\\r\\ntp[2]=t;\\r\\nt=tp[49];\\r\\ntp[49]=tp[50];\\r\\ntp[50]=t;\\r\\n}\\r\\nstatic IDEA_INT inverse(unsigned int xin)\\r\\n{\\r\\nlong n1,n2,q,r,b1,b2,t;\\r\\nif (xin == 0)\\r\\nb2=0;\\r\\nelse\\r\\n{\\r\\nn1=0x10001;\\r\\nn2=xin;\\r\\nb2=1;\\r\\nb1=0;\\r\\ndo {\\r\\nr=(n1%n2);\\r\\nq=(n1-r)/n2;\\r\\nif (r == 0)\\r\\n{ if (b2 < 0) b2=0x10001+b2; }\\r\\nelse\\r\\n{\\r\\nn1=n2;\\r\\nn2=r;\\r\\nt=b2;\\r\\nb2=b1-q*b2;\\r\\nb1=t;\\r\\n}\\r\\n} while (r != 0);\\r\\n}\\r\\nreturn((IDEA_INT)b2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_b_dump_c", "target": 0, "func": "int BIO_dump_cb(int (*cb)(const void *data, size_t len, void *u),\\r\\nvoid *u, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(cb, u, s, len, 0);\\r\\n}\\r\\nint BIO_dump_indent_cb(int (*cb)(const void *data, size_t len, void *u),\\r\\nvoid *u, const char *s, int len, int indent)\\r\\n{\\r\\nint ret=0;\\r\\nchar buf[288+1],tmp[20],str[128+1];\\r\\nint i,j,rows,trc;\\r\\nunsigned char ch;\\r\\nint dump_width;\\r\\ntrc=0;\\r\\n#ifdef TRUNCATE\\r\\nfor(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\\0')); len--)\\r\\ntrc++;\\r\\n#endif\\r\\nif (indent < 0)\\r\\nindent = 0;\\r\\nif (indent)\\r\\n{\\r\\nif (indent > 128) indent=128;\\r\\nmemset(str,' ',indent);\\r\\n}\\r\\nstr[indent]='\\0';\\r\\ndump_width=DUMP_WIDTH_LESS_INDENT(indent);\\r\\nrows=(len/dump_width);\\r\\nif ((rows*dump_width)<len)\\r\\nrows++;\\r\\nfor(i=0;i<rows;i++)\\r\\n{\\r\\nbuf[0]='\\0';\\r\\nBUF_strlcpy(buf,str,sizeof buf);\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%04x - \",i*dump_width);\\r\\nBUF_strlcat(buf,tmp,sizeof buf);\\r\\nfor(j=0;j<dump_width;j++)\\r\\n{\\r\\nif (((i*dump_width)+j)>=len)\\r\\n{\\r\\nBUF_strlcat(buf,\" \",sizeof buf);\\r\\n}\\r\\nelse\\r\\n{\\r\\nch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%02x%c\",ch,\\r\\nj==7?'-':' ');\\r\\nBUF_strlcat(buf,tmp,sizeof buf);\\r\\n}\\r\\n}\\r\\nBUF_strlcat(buf,\" \",sizeof buf);\\r\\nfor(j=0;j<dump_width;j++)\\r\\n{\\r\\nif (((i*dump_width)+j)>=len)\\r\\nbreak;\\r\\nch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%c\",\\r\\n((ch>=' ')&&(ch<='~'))?ch:'.');\\r\\n#else\\r\\nBIO_snprintf(tmp,sizeof tmp,\"%c\",\\r\\n((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))\\r\\n? os_toebcdic[ch]\\r\\n: '.');\\r\\n#endif\\r\\nBUF_strlcat(buf,tmp,sizeof buf);\\r\\n}\\r\\nBUF_strlcat(buf,\"\\n\",sizeof buf);\\r\\nret+=cb((void *)buf,strlen(buf),u);\\r\\n}\\r\\n#ifdef TRUNCATE\\r\\nif (trc > 0)\\r\\n{\\r\\nBIO_snprintf(buf,sizeof buf,\"%s%04x - <SPACES/NULS>\\n\",str,\\r\\nlen+trc);\\r\\nret+=cb((void *)buf,strlen(buf),u);\\r\\n}\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int write_fp(const void *data, size_t len, void *fp)\\r\\n{\\r\\nreturn UP_fwrite(data, len, 1, fp);\\r\\n}\\r\\nint BIO_dump_fp(FILE *fp, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_cb(write_fp, fp, s, len);\\r\\n}\\r\\nint BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(write_fp, fp, s, len, indent);\\r\\n}\\r\\nstatic int write_bio(const void *data, size_t len, void *bp)\\r\\n{\\r\\nreturn BIO_write((BIO *)bp, (const char *)data, len);\\r\\n}\\r\\nint BIO_dump(BIO *bp, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_cb(write_bio, bp, s, len);\\r\\n}\\r\\nint BIO_dump_indent(BIO *bp, const char *s, int len, int indent)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(write_bio, bp, s, len, indent);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bnspeed_c", "target": 0, "func": "static double Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret < 1e-3)?1e-3:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret < 0.001)?0.001:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM a,b,c;\\r\\nctx=BN_CTX_new();\\r\\nBN_init(&a);\\r\\nBN_init(&b);\\r\\nBN_init(&c);\\r\\ndo_mul(&a,&b,&c,ctx);\\r\\n}\\r\\nvoid do_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,k;\\r\\ndouble tm;\\r\\nlong num;\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i],1,0);\\r\\nfor (j=i; j<NUM_SIZES; j++)\\r\\n{\\r\\nBN_rand(b,sizes[j],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<num; k++)\\r\\nBN_mul(r,b,a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"mul %4d x %4d -> %8.3fms\\n\",sizes[i],sizes[j],tm*1000.0/num);\\r\\n}\\r\\n}\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<num; k++)\\r\\nBN_sqr(r,a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"sqr %4d x %4d -> %8.3fms\\n\",sizes[i],sizes[i],tm*1000.0/num);\\r\\n}\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM/10;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i]-1,1,0);\\r\\nfor (j=i; j<NUM_SIZES; j++)\\r\\n{\\r\\nBN_rand(b,sizes[j],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<100000; k++)\\r\\nBN_div(r, NULL, b, a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"div %4d / %4d -> %8.3fms\\n\",sizes[j],sizes[i]-1,tm*1000.0/num);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ui_openssl_c", "target": 0, "func": "UI_METHOD *UI_OpenSSL(void)\\r\\n{\\r\\nreturn &ui_openssl;\\r\\n}\\r\\nstatic int write_string(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nswitch (UI_get_string_type(uis))\\r\\n{\\r\\ncase UIT_ERROR:\\r\\ncase UIT_INFO:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int read_string(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nint ok = 0;\\r\\nswitch (UI_get_string_type(uis))\\r\\n{\\r\\ncase UIT_BOOLEAN:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfputs(UI_get0_action_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nreturn read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 0);\\r\\ncase UIT_PROMPT:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nreturn read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 1);\\r\\ncase UIT_VERIFY:\\r\\nfprintf(tty_out,\"Verifying - %s\",\\r\\nUI_get0_output_string(uis));\\r\\nfflush(tty_out);\\r\\nif ((ok = read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO, 1)) <= 0)\\r\\nreturn ok;\\r\\nif (strcmp(UI_get0_result_string(uis),\\r\\nUI_get0_test_string(uis)) != 0)\\r\\n{\\r\\nfprintf(tty_out,\"Verify failure\\n\");\\r\\nfflush(tty_out);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void read_till_nl(FILE *in)\\r\\n{\\r\\n#define SIZE 4\\r\\nchar buf[SIZE+1];\\r\\ndo {\\r\\nfgets(buf,SIZE,in);\\r\\n} while (strchr(buf,'\\n') == NULL);\\r\\n}\\r\\nstatic int read_string_inner(UI *ui, UI_STRING *uis, int echo, int strip_nl)\\r\\n{\\r\\nstatic int ps;\\r\\nint ok;\\r\\nchar result[BUFSIZ];\\r\\nint maxsize = BUFSIZ-1;\\r\\n#if !defined(OPENSSL_SYS_WIN16) && !defined(OPENSSL_SYS_WINCE)\\r\\nchar *p;\\r\\nintr_signal=0;\\r\\nok=0;\\r\\nps=0;\\r\\npushsig();\\r\\nps=1;\\r\\nif (!echo && !noecho_console(ui))\\r\\ngoto error;\\r\\nps=2;\\r\\nresult[0]='\\0';\\r\\n#ifdef OPENSSL_SYS_MSDOS\\r\\nif (!echo)\\r\\n{\\r\\nnoecho_fgets(result,maxsize,tty_in);\\r\\np=result;\\r\\n}\\r\\nelse\\r\\np=fgets(result,maxsize,tty_in);\\r\\n#else\\r\\np=fgets(result,maxsize,tty_in);\\r\\n#endif\\r\\nif(!p)\\r\\ngoto error;\\r\\nif (feof(tty_in)) goto error;\\r\\nif (ferror(tty_in)) goto error;\\r\\nif ((p=(char *)strchr(result,'\\n')) != NULL)\\r\\n{\\r\\nif (strip_nl)\\r\\n*p='\\0';\\r\\n}\\r\\nelse\\r\\nread_till_nl(tty_in);\\r\\nif (UI_set_result(ui, uis, result) >= 0)\\r\\nok=1;\\r\\nerror:\\r\\nif (intr_signal == SIGINT)\\r\\nok=-1;\\r\\nif (!echo) fprintf(tty_out,\"\\n\");\\r\\nif (ps >= 2 && !echo && !echo_console(ui))\\r\\nok=0;\\r\\nif (ps >= 1)\\r\\npopsig();\\r\\n#else\\r\\nok=1;\\r\\n#endif\\r\\nOPENSSL_cleanse(result,BUFSIZ);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int open_console(UI *ui)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_UI);\\r\\nis_a_tty = 1;\\r\\n#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE)\\r\\ntty_in=stdin;\\r\\ntty_out=stderr;\\r\\n#else\\r\\n# ifdef OPENSSL_SYS_MSDOS\\r\\n# define DEV_TTY \"con\"\\r\\n# else\\r\\n# define DEV_TTY \"/dev/tty\"\\r\\n# endif\\r\\nif ((tty_in=fopen(DEV_TTY,\"r\")) == NULL)\\r\\ntty_in=stdin;\\r\\nif ((tty_out=fopen(DEV_TTY,\"w\")) == NULL)\\r\\ntty_out=stderr;\\r\\n#endif\\r\\n#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)\\r\\nif (TTY_get(fileno(tty_in),&tty_orig) == -1)\\r\\n{\\r\\n#ifdef ENOTTY\\r\\nif (errno == ENOTTY)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\n#ifdef EINVAL\\r\\nif (errno == EINVAL)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$assign(&terminal,&channel,0,0);\\r\\nif (status != SS$_NORMAL)\\r\\nreturn 0;\\r\\nstatus=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int noecho_console(UI *ui)\\r\\n{\\r\\n#ifdef TTY_FLAGS\\r\\nmemcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));\\r\\ntty_new.TTY_FLAGS &= ~ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty_in),&tty_new) == -1))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] | TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int echo_console(UI *ui)\\r\\n{\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nmemcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));\\r\\ntty_new.TTY_FLAGS |= ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty_in),&tty_new) == -1))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] & ~TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int close_console(UI *ui)\\r\\n{\\r\\nif (tty_in != stdin) fclose(tty_in);\\r\\nif (tty_out != stderr) fclose(tty_out);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$dassgn(channel);\\r\\n#endif\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_UI);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pushsig(void)\\r\\n{\\r\\nint i;\\r\\n#ifdef SIGACTION\\r\\nstruct sigaction sa;\\r\\nmemset(&sa,0,sizeof sa);\\r\\nsa.sa_handler=recsig;\\r\\n#endif\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGKILL\\r\\nif (i == SIGKILL)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&sa,&savsig[i]);\\r\\n#else\\r\\nsavsig[i]=signal(i,recsig);\\r\\n#endif\\r\\n}\\r\\n#ifdef SIGWINCH\\r\\nsignal(SIGWINCH,SIG_DFL);\\r\\n#endif\\r\\n}\\r\\nstatic void popsig(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&savsig[i],NULL);\\r\\n#else\\r\\nsignal(i,savsig[i]);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void recsig(int i)\\r\\n{\\r\\nintr_signal=i;\\r\\n}\\r\\nstatic int noecho_fgets(char *buf, int size, FILE *tty)\\r\\n{\\r\\nint i;\\r\\nchar *p;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (size == 0)\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\nsize--;\\r\\n#ifdef WIN16TTY\\r\\ni=_inchar();\\r\\n#else\\r\\ni=getch();\\r\\n#endif\\r\\nif (i == '\\r') i='\\n';\\r\\n*(p++)=i;\\r\\nif (i == '\\n')\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#ifdef WIN_CONSOLE_BUG\\r\\n{\\r\\nHANDLE inh;\\r\\ninh = GetStdHandle(STD_INPUT_HANDLE);\\r\\nFlushConsoleInputBuffer(inh);\\r\\n}\\r\\n#endif\\r\\nreturn(strlen(buf));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cryptlib_c", "target": 0, "func": "int CRYPTO_get_new_lockid(char *name)\\r\\n{\\r\\nchar *str;\\r\\nint i;\\r\\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\\r\\nSSLeay_MSVC5_hack=(double)name[0]*(double)name[1];\\r\\n#endif\\r\\nif ((app_locks == NULL) && ((app_locks=sk_new_null()) == NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((str=BUF_strdup(name)) == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\ni=sk_push(app_locks,str);\\r\\nif (!i)\\r\\nOPENSSL_free(str);\\r\\nelse\\r\\ni+=CRYPTO_NUM_LOCKS;\\r\\nreturn(i);\\r\\n}\\r\\nint CRYPTO_num_locks(void)\\r\\n{\\r\\nreturn CRYPTO_NUM_LOCKS;\\r\\n}\\r\\nint CRYPTO_get_new_dynlockid(void)\\r\\n{\\r\\nint i = 0;\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (dynlock_create_callback == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,CRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif ((dyn_locks == NULL)\\r\\n&& ((dyn_locks=sk_CRYPTO_dynlock_new_null()) == NULL))\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\npointer = (CRYPTO_dynlock *)OPENSSL_malloc(sizeof(CRYPTO_dynlock));\\r\\nif (pointer == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\npointer->references = 1;\\r\\npointer->data = dynlock_create_callback(__FILE__,__LINE__);\\r\\nif (pointer->data == NULL)\\r\\n{\\r\\nOPENSSL_free(pointer);\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\ni=sk_CRYPTO_dynlock_find(dyn_locks,NULL);\\r\\nif (i == -1)\\r\\ni=sk_CRYPTO_dynlock_push(dyn_locks,pointer) - 1;\\r\\nelse\\r\\nsk_CRYPTO_dynlock_set(dyn_locks,i,pointer);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (i == -1)\\r\\n{\\r\\ndynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\\r\\nOPENSSL_free(pointer);\\r\\n}\\r\\nelse\\r\\ni += 1;\\r\\nreturn -i;\\r\\n}\\r\\nvoid CRYPTO_destroy_dynlockid(int i)\\r\\n{\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (i)\\r\\ni = -i-1;\\r\\nif (dynlock_destroy_callback == NULL)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks))\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nreturn;\\r\\n}\\r\\npointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\\r\\nif (pointer != NULL)\\r\\n{\\r\\n--pointer->references;\\r\\n#ifdef REF_CHECK\\r\\nif (pointer->references < 0)\\r\\n{\\r\\nfprintf(stderr,\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nif (pointer->references <= 0)\\r\\n{\\r\\nsk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\\r\\n}\\r\\nelse\\r\\npointer = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (pointer)\\r\\n{\\r\\ndynlock_destroy_callback(pointer->data,__FILE__,__LINE__);\\r\\nOPENSSL_free(pointer);\\r\\n}\\r\\n}\\r\\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\\r\\n{\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (i)\\r\\ni = -i-1;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))\\r\\npointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\\r\\nif (pointer)\\r\\npointer->references++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (pointer)\\r\\nreturn pointer->data;\\r\\nreturn NULL;\\r\\n}\\r\\nvoid CRYPTO_set_dynlock_lock_callback(void (*func)(int mode,\\r\\nstruct CRYPTO_dynlock_value *l, const char *file, int line))\\r\\n{\\r\\ndynlock_lock_callback=func;\\r\\n}\\r\\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)\\r\\n(struct CRYPTO_dynlock_value *l, const char *file, int line))\\r\\n{\\r\\ndynlock_destroy_callback=func;\\r\\n}\\r\\nvoid CRYPTO_set_locking_callback(void (*func)(int mode,int type,\\r\\nconst char *file,int line))\\r\\n{\\r\\nlocking_callback=func;\\r\\n}\\r\\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,\\r\\nconst char *file,int line))\\r\\n{\\r\\nadd_lock_callback=func;\\r\\n}\\r\\nunsigned long CRYPTO_thread_id(void)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nif (id_callback == NULL)\\r\\n{\\r\\n#ifdef OPENSSL_SYS_WIN16\\r\\nret=(unsigned long)GetCurrentTask();\\r\\n#elif defined(OPENSSL_SYS_WIN32)\\r\\nret=(unsigned long)GetCurrentThreadId();\\r\\n#elif defined(GETPID_IS_MEANINGLESS)\\r\\nret=1L;\\r\\n#else\\r\\nret=(unsigned long)getpid();\\r\\n#endif\\r\\n}\\r\\nelse\\r\\nret=id_callback();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_lock(int mode, int type, const char *file, int line)\\r\\n{\\r\\n#ifdef LOCK_DEBUG\\r\\n{\\r\\nchar *rw_text,*operation_text;\\r\\nif (mode & CRYPTO_LOCK)\\r\\noperation_text=\"lock \";\\r\\nelse if (mode & CRYPTO_UNLOCK)\\r\\noperation_text=\"unlock\";\\r\\nelse\\r\\noperation_text=\"ERROR \";\\r\\nif (mode & CRYPTO_READ)\\r\\nrw_text=\"r\";\\r\\nelse if (mode & CRYPTO_WRITE)\\r\\nrw_text=\"w\";\\r\\nelse\\r\\nrw_text=\"ERROR\";\\r\\nfprintf(stderr,\"lock:%08lx:(%s)%s %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(), rw_text, operation_text,\\r\\nCRYPTO_get_lock_name(type), file, line);\\r\\n}\\r\\n#endif\\r\\nif (type < 0)\\r\\n{\\r\\nif (dynlock_lock_callback != NULL)\\r\\n{\\r\\nstruct CRYPTO_dynlock_value *pointer\\r\\n= CRYPTO_get_dynlock_value(type);\\r\\nOPENSSL_assert(pointer != NULL);\\r\\ndynlock_lock_callback(mode, pointer, file, line);\\r\\nCRYPTO_destroy_dynlockid(type);\\r\\n}\\r\\n}\\r\\nelse\\r\\nif (locking_callback != NULL)\\r\\nlocking_callback(mode,type,file,line);\\r\\n}\\r\\nint CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\\r\\nint line)\\r\\n{\\r\\nint ret = 0;\\r\\nif (add_lock_callback != NULL)\\r\\n{\\r\\n#ifdef LOCK_DEBUG\\r\\nint before= *pointer;\\r\\n#endif\\r\\nret=add_lock_callback(pointer,amount,type,file,line);\\r\\n#ifdef LOCK_DEBUG\\r\\nfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nbefore,amount,ret,\\r\\nCRYPTO_get_lock_name(type),\\r\\nfile,line);\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,file,line);\\r\\nret= *pointer+amount;\\r\\n#ifdef LOCK_DEBUG\\r\\nfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n*pointer,amount,ret,\\r\\nCRYPTO_get_lock_name(type),\\r\\nfile,line);\\r\\n#endif\\r\\n*pointer=ret;\\r\\nCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,file,line);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nconst char *CRYPTO_get_lock_name(int type)\\r\\n{\\r\\nif (type < 0)\\r\\nreturn(\"dynamic\");\\r\\nelse if (type < CRYPTO_NUM_LOCKS)\\r\\nreturn(lock_names[type]);\\r\\nelse if (type-CRYPTO_NUM_LOCKS > sk_num(app_locks))\\r\\nreturn(\"ERROR\");\\r\\nelse\\r\\nreturn(sk_value(app_locks,type-CRYPTO_NUM_LOCKS));\\r\\n}\\r\\nunsigned long *OPENSSL_ia32cap_loc(void) { return &OPENSSL_ia32cap_P; }\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{ static int trigger=0;\\r\\nunsigned long OPENSSL_ia32_cpuid(void);\\r\\nchar *env;\\r\\nif (trigger) return;\\r\\ntrigger=1;\\r\\nif ((env=getenv(\"OPENSSL_ia32cap\")))\\r\\nOPENSSL_ia32cap_P = strtoul(env,NULL,0)|(1<<10);\\r\\nelse\\r\\nOPENSSL_ia32cap_P = OPENSSL_ia32_cpuid()|(1<<10);\\r\\n}\\r\\nunsigned long *OPENSSL_ia32cap_loc(void) { return NULL; }\\r\\nvoid OPENSSL_cpuid_setup(void) {}\\r\\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason,\\r\\nLPVOID lpvReserved)\\r\\n{\\r\\nswitch(fdwReason)\\r\\n{\\r\\ncase DLL_PROCESS_ATTACH:\\r\\nOPENSSL_cpuid_setup();\\r\\n#if defined(_WIN32_WINNT)\\r\\n{\\r\\nIMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)hinstDLL;\\r\\nIMAGE_NT_HEADERS *nt_headers;\\r\\nif (dos_header->e_magic==IMAGE_DOS_SIGNATURE)\\r\\n{\\r\\nnt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header\\r\\n+ dos_header->e_lfanew);\\r\\nif (nt_headers->Signature==IMAGE_NT_SIGNATURE &&\\r\\nhinstDLL!=(HINSTANCE)(nt_headers->OptionalHeader.ImageBase))\\r\\nOPENSSL_NONPIC_relocated=1;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nbreak;\\r\\ncase DLL_THREAD_ATTACH:\\r\\nbreak;\\r\\ncase DLL_THREAD_DETACH:\\r\\nERR_remove_state(0);\\r\\nbreak;\\r\\ncase DLL_PROCESS_DETACH:\\r\\nbreak;\\r\\n}\\r\\nreturn(TRUE);\\r\\n}\\r\\nint OPENSSL_isservice(void)\\r\\n{ HWINSTA h;\\r\\nDWORD len;\\r\\nWCHAR *name;\\r\\n(void)GetDesktopWindow();\\r\\nh = GetProcessWindowStation();\\r\\nif (h==NULL) return -1;\\r\\nif (GetUserObjectInformationW (h,UOI_NAME,NULL,0,&len) ||\\r\\nGetLastError() != ERROR_INSUFFICIENT_BUFFER)\\r\\nreturn -1;\\r\\nif (len>512) return -1;\\r\\nlen++,len&=~1;\\r\\n#ifdef _MSC_VER\\r\\nname=(WCHAR *)_alloca(len+sizeof(WCHAR));\\r\\n#else\\r\\nname=(WCHAR *)alloca(len+sizeof(WCHAR));\\r\\n#endif\\r\\nif (!GetUserObjectInformationW (h,UOI_NAME,name,len,&len))\\r\\nreturn -1;\\r\\nlen++,len&=~1;\\r\\nname[len/sizeof(WCHAR)]=L'\\0';\\r\\n#if 1\\r\\nif (wcsstr(name,L\"Service-0x\")) return 1;\\r\\n#else\\r\\nif (!wcsstr(name,L\"WinSta0\")) return 1;\\r\\n#endif\\r\\nelse return 0;\\r\\n}\\r\\nvoid OPENSSL_showfatal (const char *fmta,...)\\r\\n{ va_list ap;\\r\\nTCHAR buf[256];\\r\\nconst TCHAR *fmt;\\r\\nHANDLE h;\\r\\nif ((h=GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\\r\\nGetFileType(h)!=FILE_TYPE_UNKNOWN)\\r\\n{\\r\\nva_start (ap,fmta);\\r\\nvfprintf (stderr,fmta,ap);\\r\\nva_end (ap);\\r\\nreturn;\\r\\n}\\r\\nif (sizeof(TCHAR)==sizeof(char))\\r\\nfmt=fmta;\\r\\nelse do\\r\\n{ int keepgoing;\\r\\nsize_t len_0=strlen(fmta)+1,i;\\r\\nWCHAR *fmtw;\\r\\n#ifdef _MSC_VER\\r\\nfmtw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));\\r\\n#else\\r\\nfmtw = (WCHAR *)alloca (len_0*sizeof(WCHAR));\\r\\n#endif\\r\\nif (fmtw == NULL) { fmt=(const TCHAR *)L\"no stack?\"; break; }\\r\\n#ifndef OPENSSL_NO_MULTIBYTE\\r\\nif (!MultiByteToWideChar(CP_ACP,0,fmta,len_0,fmtw,len_0))\\r\\n#endif\\r\\nfor (i=0;i<len_0;i++) fmtw[i]=(WCHAR)fmta[i];\\r\\nfor (i=0;i<len_0;i++)\\r\\n{ if (fmtw[i]==L'%') do\\r\\n{ keepgoing=0;\\r\\nswitch (fmtw[i+1])\\r\\n{ case L'0': case L'1': case L'2': case L'3': case L'4':\\r\\ncase L'5': case L'6': case L'7': case L'8': case L'9':\\r\\ncase L'.': case L'*':\\r\\ncase L'-': i++; keepgoing=1; break;\\r\\ncase L's': fmtw[i+1]=L'S'; break;\\r\\ncase L'S': fmtw[i+1]=L's'; break;\\r\\ncase L'c': fmtw[i+1]=L'C'; break;\\r\\ncase L'C': fmtw[i+1]=L'c'; break;\\r\\n}\\r\\n} while (keepgoing);\\r\\n}\\r\\nfmt = (const TCHAR *)fmtw;\\r\\n} while (0);\\r\\nva_start (ap,fmta);\\r\\n_vsntprintf (buf,sizeof(buf)/sizeof(TCHAR)-1,fmt,ap);\\r\\nbuf [sizeof(buf)/sizeof(TCHAR)-1] = _T('\\0');\\r\\nva_end (ap);\\r\\n#if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\\r\\nif (GetVersion() < 0x80000000 && OPENSSL_isservice())\\r\\n{ HANDLE h = RegisterEventSource(0,_T(\"OPENSSL\"));\\r\\nconst TCHAR *pmsg=buf;\\r\\nReportEvent(h,EVENTLOG_ERROR_TYPE,0,0,0,1,0,&pmsg,0);\\r\\nDeregisterEventSource(h);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{ MSGBOXPARAMS m;\\r\\nm.cbSize = sizeof(m);\\r\\nm.hwndOwner = NULL;\\r\\nm.lpszCaption = _T(\"OpenSSL: FATAL\");\\r\\nm.dwStyle = MB_OK;\\r\\nm.hInstance = NULL;\\r\\nm.lpszIcon = IDI_ERROR;\\r\\nm.dwContextHelpId = 0;\\r\\nm.lpfnMsgBoxCallback = NULL;\\r\\nm.dwLanguageId = MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US);\\r\\nm.lpszText = buf;\\r\\nMessageBoxIndirect (&m);\\r\\n}\\r\\n}\\r\\nvoid OPENSSL_showfatal (const char *fmta,...)\\r\\n{ va_list ap;\\r\\nva_start (ap,fmta);\\r\\nvfprintf (stderr,fmta,ap);\\r\\nva_end (ap);\\r\\n}\\r\\nint OPENSSL_isservice (void) { return 0; }\\r\\nvoid OpenSSLDie(const char *file,int line,const char *assertion)\\r\\n{\\r\\nOPENSSL_showfatal(\\r\\n\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\",\\r\\nfile,line,assertion);\\r\\nabort();\\r\\n}\\r\\nvoid *OPENSSL_stderr(void) { return stderr; }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sess_id_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nSSL_SESSION *x=NULL;\\r\\nint ret=1,i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile=NULL,*outfile=NULL,*context=NULL;\\r\\nint cert=0,noout=0,text=0;\\r\\nconst char **pp;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext= ++num;\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\ncert= ++num;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse if (strcmp(*argv,\"-context\") == 0)\\r\\n{\\r\\nif(--argc < 1) goto bad;\\r\\ncontext=*++argv;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=sess_id_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,\"%s\",*pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nx=load_sess_id(infile,informat);\\r\\nif (x == NULL) { goto end; }\\r\\nif(context)\\r\\n{\\r\\nx->sid_ctx_length=strlen(context);\\r\\nif(x->sid_ctx_length > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nBIO_printf(bio_err,\"Context too long\\n\");\\r\\ngoto end;\\r\\n}\\r\\nmemcpy(x->sid_ctx,context,x->sid_ctx_length);\\r\\n}\\r\\n#ifdef undef\\r\\n{\\r\\nSSL_SESSION *s;\\r\\nchar buf[1024*10],*p;\\r\\nint i;\\r\\ns=SSL_SESSION_new();\\r\\np= &buf;\\r\\ni=i2d_SSL_SESSION(x,&p);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n#endif\\r\\nif (!noout || text)\\r\\n{\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nSSL_SESSION_print(out,x);\\r\\nif (cert)\\r\\n{\\r\\nif (x->peer == NULL)\\r\\nBIO_puts(out,\"No certificate present\\n\");\\r\\nelse\\r\\nX509_print(out,x->peer);\\r\\n}\\r\\n}\\r\\nif (!noout && !cert)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_SSL_SESSION_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_SSL_SESSION(out,x);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err,\"unable to write SSL_SESSION\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (!noout && (x->peer != NULL))\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=(int)i2d_X509_bio(out,x->peer);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509(out,x->peer);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err,\"unable to write X509\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (x != NULL) SSL_SESSION_free(x);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic SSL_SESSION *load_sess_id(char *infile, int format)\\r\\n{\\r\\nSSL_SESSION *x=NULL;\\r\\nBIO *in=NULL;\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_SSL_SESSION_bio(in,NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_SSL_SESSION(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load SSL_SESSION\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_rc4_c", "target": 0, "func": "const EVP_CIPHER *EVP_rc4(void)\\r\\n{\\r\\nreturn(&r4_cipher);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc4_40(void)\\r\\n{\\r\\nreturn(&r4_40_cipher);\\r\\n}\\r\\nstatic int rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC4_set_key(&data(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC4(&data(ctx)->ks,inl,in,out);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha1_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"SHA1(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nSHA_CTX c;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nunsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nSHA1_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nSHA1_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nSHA1_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_err_c", "target": 0, "func": "void ERR_load_PEM_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,PEM_str_functs);\\r\\nERR_load_strings(0,PEM_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_depr_c", "target": 0, "func": "DH *DH_generate_parameters(int prime_len, int generator,\\r\\nvoid (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nDH *ret=NULL;\\r\\nif((ret=DH_new()) == NULL)\\r\\nreturn NULL;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif(DH_generate_parameters_ex(ret, prime_len, generator, &cb))\\r\\nreturn ret;\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dgst_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nunsigned char *buf=NULL;\\r\\nint i,err=0;\\r\\nconst EVP_MD *md=NULL,*m;\\r\\nBIO *in=NULL,*inp;\\r\\nBIO *bmd=NULL;\\r\\nBIO *out = NULL;\\r\\nconst char *name;\\r\\n#define PROG_NAME_SIZE 39\\r\\nchar pname[PROG_NAME_SIZE+1];\\r\\nint separator=0;\\r\\nint debug=0;\\r\\nint keyform=FORMAT_PEM;\\r\\nconst char *outfile = NULL, *keyfile = NULL;\\r\\nconst char *sigfile = NULL, *randfile = NULL;\\r\\nint out_bin = -1, want_pub = 0, do_verify = 0;\\r\\nEVP_PKEY *sigkey = NULL;\\r\\nunsigned char *sigbuf = NULL;\\r\\nint siglen = 0;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif ((buf=(unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprogram_name(argv[0],pname,sizeof pname);\\r\\nmd=EVP_get_digestbyname(pname);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc > 0)\\r\\n{\\r\\nif ((*argv)[0] != '-') break;\\r\\nif (strcmp(*argv,\"-c\") == 0)\\r\\nseparator=1;\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nrandfile=*(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\noutfile=*(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-sign\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nkeyfile=*(++argv);\\r\\n}\\r\\nelse if (!strcmp(*argv,\"-passin\"))\\r\\n{\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\npassargin=*++argv;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nkeyfile=*(++argv);\\r\\nwant_pub = 1;\\r\\ndo_verify = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-prverify\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nkeyfile=*(++argv);\\r\\ndo_verify = 1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-signature\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nsigfile=*(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nkeyform=str2fmt(*(++argv));\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) break;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-hex\") == 0)\\r\\nout_bin = 0;\\r\\nelse if (strcmp(*argv,\"-binary\") == 0)\\r\\nout_bin = 1;\\r\\nelse if (strcmp(*argv,\"-d\") == 0)\\r\\ndebug=1;\\r\\nelse if ((m=EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\nmd=m;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (md == NULL)\\r\\nmd=EVP_md5();\\r\\nif(do_verify && !sigfile) {\\r\\nBIO_printf(bio_err, \"No signature to verify: use the -signature option\\n\");\\r\\nerr = 1;\\r\\ngoto end;\\r\\n}\\r\\nif ((argc > 0) && (argv[0][0] == '-'))\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option '%s'\\n\",*argv);\\r\\nBIO_printf(bio_err,\"options are\\n\");\\r\\nBIO_printf(bio_err,\"-c to output the digest with separating colons\\n\");\\r\\nBIO_printf(bio_err,\"-d to output debug info\\n\");\\r\\nBIO_printf(bio_err,\"-hex output as hex dump\\n\");\\r\\nBIO_printf(bio_err,\"-binary output in binary form\\n\");\\r\\nBIO_printf(bio_err,\"-sign file sign digest using private key in file\\n\");\\r\\nBIO_printf(bio_err,\"-verify file verify a signature using public key in file\\n\");\\r\\nBIO_printf(bio_err,\"-prverify file verify a signature using private key in file\\n\");\\r\\nBIO_printf(bio_err,\"-keyform arg key file format (PEM or ENGINE)\\n\");\\r\\nBIO_printf(bio_err,\"-signature file signature to verify\\n\");\\r\\nBIO_printf(bio_err,\"-binary output in binary form\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm (default)\\n\",\\r\\nLN_md5,LN_md5);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_md4,LN_md4);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_md2,LN_md2);\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha1,LN_sha1);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha,LN_sha);\\r\\n#ifndef OPENSSL_NO_SHA256\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha256,LN_sha256);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA512\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha512,LN_sha512);\\r\\n#endif\\r\\n#endif\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_mdc2,LN_mdc2);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_ripemd160,LN_ripemd160);\\r\\nerr=1;\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nin=BIO_new(BIO_s_file());\\r\\nbmd=BIO_new(BIO_f_md());\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(in,BIO_debug_callback);\\r\\nBIO_set_callback_arg(in,bio_err);\\r\\n}\\r\\nif(!app_passwd(bio_err, passargin, NULL, &passin, NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((in == NULL) || (bmd == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif(out_bin == -1) {\\r\\nif(keyfile) out_bin = 1;\\r\\nelse out_bin = 0;\\r\\n}\\r\\nif(randfile)\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nif(outfile) {\\r\\nif(out_bin)\\r\\nout = BIO_new_file(outfile, \"wb\");\\r\\nelse out = BIO_new_file(outfile, \"w\");\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif(!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file %s\\n\",\\r\\noutfile ? outfile : \"(stdout)\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif(keyfile)\\r\\n{\\r\\nif (want_pub)\\r\\nsigkey = load_pubkey(bio_err, keyfile, keyform, 0, NULL,\\r\\ne, \"key file\");\\r\\nelse\\r\\nsigkey = load_key(bio_err, keyfile, keyform, 0, passin,\\r\\ne, \"key file\");\\r\\nif (!sigkey)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif(sigfile && sigkey) {\\r\\nBIO *sigbio;\\r\\nsigbio = BIO_new_file(sigfile, \"rb\");\\r\\nsiglen = EVP_PKEY_size(sigkey);\\r\\nsigbuf = OPENSSL_malloc(siglen);\\r\\nif(!sigbio) {\\r\\nBIO_printf(bio_err, \"Error opening signature file %s\\n\",\\r\\nsigfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nsiglen = BIO_read(sigbio, sigbuf, siglen);\\r\\nBIO_free(sigbio);\\r\\nif(siglen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading signature file %s\\n\",\\r\\nsigfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BIO_set_md(bmd,md))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error setting digest %s\\n\", pname);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ninp=BIO_push(bmd,in);\\r\\nif (argc == 0)\\r\\n{\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nerr=do_fp(out, buf,inp,separator, out_bin, sigkey, sigbuf,\\r\\nsiglen,\"\",\"(stdin)\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nname=OBJ_nid2sn(md->type);\\r\\nfor (i=0; i<argc; i++)\\r\\n{\\r\\nchar *tmp,*tofree=NULL;\\r\\nint r;\\r\\nif (BIO_read_filename(in,argv[i]) <= 0)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nif(!out_bin)\\r\\n{\\r\\nsize_t len = strlen(name)+strlen(argv[i])+5;\\r\\ntmp=tofree=OPENSSL_malloc(len);\\r\\nBIO_snprintf(tmp,len,\"%s(%s)= \",name,argv[i]);\\r\\n}\\r\\nelse\\r\\ntmp=\"\";\\r\\nr=do_fp(out,buf,inp,separator,out_bin,sigkey,sigbuf,\\r\\nsiglen,tmp,argv[i]);\\r\\nif(r)\\r\\nerr=r;\\r\\nif(tofree)\\r\\nOPENSSL_free(tofree);\\r\\n(void)BIO_reset(bmd);\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,BUFSIZE);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(sigkey);\\r\\nif(sigbuf) OPENSSL_free(sigbuf);\\r\\nif (bmd != NULL) BIO_free(bmd);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(err);\\r\\n}\\r\\nint do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,\\r\\nEVP_PKEY *key, unsigned char *sigin, int siglen, const char *title,\\r\\nconst char *file)\\r\\n{\\r\\nint len;\\r\\nint i;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(bp,(char *)buf,BUFSIZE);\\r\\nif(i < 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"Read Error in %s\\n\",file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\nif (i == 0) break;\\r\\n}\\r\\nif(sigin)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nBIO_get_md_ctx(bp, &ctx);\\r\\ni = EVP_VerifyFinal(ctx, sigin, (unsigned int)siglen, key);\\r\\nif(i > 0)\\r\\nBIO_printf(out, \"Verified OK\\n\");\\r\\nelse if(i == 0)\\r\\n{\\r\\nBIO_printf(out, \"Verification Failure\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Error Verifying Data\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif(key)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nBIO_get_md_ctx(bp, &ctx);\\r\\nif(!EVP_SignFinal(ctx, buf, (unsigned int *)&len, key))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error Signing Data\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nlen=BIO_gets(bp,(char *)buf,BUFSIZE);\\r\\nif(binout) BIO_write(out, buf, len);\\r\\nelse\\r\\n{\\r\\nBIO_write(out,title,strlen(title));\\r\\nfor (i=0; i<len; i++)\\r\\n{\\r\\nif (sep && (i != 0))\\r\\nBIO_printf(out, \":\");\\r\\nBIO_printf(out, \"%02x\",buf[i]);\\r\\n}\\r\\nBIO_printf(out, \"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_str2key_c", "target": 0, "func": "void DES_string_to_key(const char *str, DES_cblock *key)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint i,length;\\r\\nregister unsigned char j;\\r\\nmemset(key,0,8);\\r\\nlength=strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nfor (i=0; i<length; i++)\\r\\n(*key)[i%8]^=(str[i]<<1);\\r\\n#else\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nj=str[i];\\r\\nif ((i%16) < 8)\\r\\n(*key)[i%8]^=(j<<1);\\r\\nelse\\r\\n{\\r\\nj=((j<<4)&0xf0)|((j>>4)&0x0f);\\r\\nj=((j<<2)&0xcc)|((j>>2)&0x33);\\r\\nj=((j<<1)&0xaa)|((j>>1)&0x55);\\r\\n(*key)[7-(i%8)]^=j;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nDES_set_odd_parity(key);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif(DES_is_weak_key(key))\\r\\n(*key)[7] ^= 0xF0;\\r\\nDES_set_key(key,&ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key,&ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char*)str,key,length,&ks,key);\\r\\nOPENSSL_cleanse(&ks,sizeof(ks));\\r\\nDES_set_odd_parity(key);\\r\\n}\\r\\nvoid DES_string_to_2keys(const char *str, DES_cblock *key1, DES_cblock *key2)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint i,length;\\r\\nregister unsigned char j;\\r\\nmemset(key1,0,8);\\r\\nmemset(key2,0,8);\\r\\nlength=strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nif (length <= 8)\\r\\n{\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\n(*key2)[i]=(*key1)[i]=(str[i]<<1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nif ((i/8)&1)\\r\\n(*key2)[i%8]^=(str[i]<<1);\\r\\nelse\\r\\n(*key1)[i%8]^=(str[i]<<1);\\r\\n}\\r\\n}\\r\\n#else\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nj=str[i];\\r\\nif ((i%32) < 16)\\r\\n{\\r\\nif ((i%16) < 8)\\r\\n(*key1)[i%8]^=(j<<1);\\r\\nelse\\r\\n(*key2)[i%8]^=(j<<1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=((j<<4)&0xf0)|((j>>4)&0x0f);\\r\\nj=((j<<2)&0xcc)|((j>>2)&0x33);\\r\\nj=((j<<1)&0xaa)|((j>>1)&0x55);\\r\\nif ((i%16) < 8)\\r\\n(*key1)[7-(i%8)]^=j;\\r\\nelse\\r\\n(*key2)[7-(i%8)]^=j;\\r\\n}\\r\\n}\\r\\nif (length <= 8) memcpy(key2,key1,8);\\r\\n#endif\\r\\nDES_set_odd_parity(key1);\\r\\nDES_set_odd_parity(key2);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif(DES_is_weak_key(key1))\\r\\n(*key1)[7] ^= 0xF0;\\r\\nDES_set_key(key1,&ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key1,&ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char*)str,key1,length,&ks,key1);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif(DES_is_weak_key(key2))\\r\\n(*key2)[7] ^= 0xF0;\\r\\nDES_set_key(key2,&ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key2,&ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char*)str,key2,length,&ks,key2);\\r\\nOPENSSL_cleanse(&ks,sizeof(ks));\\r\\nDES_set_odd_parity(key1);\\r\\nDES_set_odd_parity(key2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sgiccbug_c", "target": 0, "func": "main()\\r\\n{\\r\\nunsigned long r[4];\\r\\nsub(r,a,b);\\r\\nfprintf(stderr,\"input a= %08X %08X %08X %08X\\n\",a[3],a[2],a[1],a[0]);\\r\\nfprintf(stderr,\"input b= %08X %08X %08X %08X\\n\",b[3],b[2],b[1],b[0]);\\r\\nfprintf(stderr,\"output = %08X %08X %08X %08X\\n\",r[3],r[2],r[1],r[0]);\\r\\nfprintf(stderr,\"correct= %08X %08X %08X %08X\\n\",c[3],c[2],c[1],c[0]);\\r\\n}\\r\\nint sub(r,a,b)\\r\\nunsigned long *r,*a,*b;\\r\\n{\\r\\nregister unsigned long t1,t2,*ap,*bp,*rp;\\r\\nint i,carry;\\r\\n#ifdef FIXBUG\\r\\nunsigned long dummy;\\r\\n#endif\\r\\nap=a;\\r\\nbp=b;\\r\\nrp=r;\\r\\ncarry=0;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nt1= *(ap++);\\r\\nt2= *(bp++);\\r\\nt1=(t1-t2);\\r\\n#ifdef FIXBUG\\r\\ndummy=t1;\\r\\n#endif\\r\\n*(rp++)=t1&0xffffffff;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_both_c", "target": 0, "func": "int ssl3_do_write(SSL *s, int type)\\r\\n{\\r\\nint ret;\\r\\nret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],\\r\\ns->init_num);\\r\\nif (ret < 0) return(-1);\\r\\nif (type == SSL3_RT_HANDSHAKE)\\r\\nssl3_finish_mac(s,(unsigned char *)&s->init_buf->data[s->init_off],ret);\\r\\nif (ret == s->init_num)\\r\\n{\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, type, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);\\r\\nreturn(1);\\r\\n}\\r\\ns->init_off+=ret;\\r\\ns->init_num-=ret;\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == a)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\ni=s->method->ssl3_enc->final_finish_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->finish_dgst2),\\r\\nsender,slen,s->s3->tmp.finish_md);\\r\\ns->s3->tmp.finish_md_len = i;\\r\\nmemcpy(p, s->s3->tmp.finish_md, i);\\r\\np+=i;\\r\\nl=i;\\r\\n#ifdef OPENSSL_SYS_WIN16\\r\\nl&=0xffff;\\r\\n#endif\\r\\n*(d++)=SSL3_MT_FINISHED;\\r\\nl2n3(l,d);\\r\\ns->init_num=(int)l+4;\\r\\ns->init_off=0;\\r\\ns->state=b;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_get_finished(SSL *s, int a, int b)\\r\\n{\\r\\nint al,i,ok;\\r\\nlong n;\\r\\nunsigned char *p;\\r\\nn=s->method->ssl_get_message(s,\\r\\na,\\r\\nb,\\r\\nSSL3_MT_FINISHED,\\r\\n64,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (!s->s3->change_cipher_spec)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_GOT_A_FIN_BEFORE_A_CCS);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->change_cipher_spec=0;\\r\\np = (unsigned char *)s->init_msg;\\r\\ni = s->s3->tmp.peer_finish_md_len;\\r\\nif (i != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_BAD_DIGEST_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (memcmp(p, s->s3->tmp.peer_finish_md, i) != 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);\\r\\ngoto f_err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_send_change_cipher_spec(SSL *s, int a, int b)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == a)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*p=SSL3_MT_CCS;\\r\\ns->init_num=1;\\r\\ns->init_off=0;\\r\\ns->state=b;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));\\r\\n}\\r\\nunsigned long ssl3_output_cert_chain(SSL *s, X509 *x)\\r\\n{\\r\\nunsigned char *p;\\r\\nint n,i;\\r\\nunsigned long l=7;\\r\\nBUF_MEM *buf;\\r\\nX509_STORE_CTX xs_ctx;\\r\\nX509_OBJECT obj;\\r\\nint no_chain;\\r\\nif ((s->mode & SSL_MODE_NO_AUTO_CHAIN) || s->ctx->extra_certs)\\r\\nno_chain = 1;\\r\\nelse\\r\\nno_chain = 0;\\r\\nbuf=s->init_buf;\\r\\nif (!BUF_MEM_grow_clean(buf,10))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif(!no_chain && !X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\nif (no_chain)\\r\\nbreak;\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),\\r\\nX509_get_issuer_name(x)) == 0) break;\\r\\ni=X509_STORE_get_by_subject(&xs_ctx,X509_LU_X509,\\r\\nX509_get_issuer_name(x),&obj);\\r\\nif (i <= 0) break;\\r\\nx=obj.data.x509;\\r\\nX509_free(x);\\r\\n}\\r\\nif (!no_chain)\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\n}\\r\\nif (s->ctx->extra_certs != NULL)\\r\\nfor (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)\\r\\n{\\r\\nx=sk_X509_value(s->ctx->extra_certs,i);\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\n}\\r\\nl-=7;\\r\\np=(unsigned char *)&(buf->data[4]);\\r\\nl2n3(l,p);\\r\\nl+=3;\\r\\np=(unsigned char *)&(buf->data[0]);\\r\\n*(p++)=SSL3_MT_CERTIFICATE;\\r\\nl2n3(l,p);\\r\\nl+=4;\\r\\nreturn(l);\\r\\n}\\r\\nlong ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned long l;\\r\\nlong n;\\r\\nint i,al;\\r\\nif (s->s3->tmp.reuse_message)\\r\\n{\\r\\ns->s3->tmp.reuse_message=0;\\r\\nif ((mt >= 0) && (s->s3->tmp.message_type != mt))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n*ok=1;\\r\\ns->init_msg = s->init_buf->data + 4;\\r\\ns->init_num = (int)s->s3->tmp.message_size;\\r\\nreturn s->init_num;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == st1)\\r\\n{\\r\\nint skip_message;\\r\\ndo\\r\\n{\\r\\nwhile (s->init_num < 4)\\r\\n{\\r\\ni=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\\r\\n&p[s->init_num],4 - s->init_num, 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\n*ok = 0;\\r\\nreturn i;\\r\\n}\\r\\ns->init_num+=i;\\r\\n}\\r\\nskip_message = 0;\\r\\nif (!s->server)\\r\\nif (p[0] == SSL3_MT_HELLO_REQUEST)\\r\\nif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\\r\\n{\\r\\ns->init_num = 0;\\r\\nskip_message = 1;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, 4, s, s->msg_callback_arg);\\r\\n}\\r\\n}\\r\\nwhile (skip_message);\\r\\nif ((mt >= 0) && (*p != mt))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\\r\\n(st1 == SSL3_ST_SR_CERT_A) &&\\r\\n(stn == SSL3_ST_SR_CERT_B))\\r\\n{\\r\\nssl3_init_finished_mac(s);\\r\\n}\\r\\ns->s3->tmp.message_type= *(p++);\\r\\nn2l3(p,l);\\r\\nif (l > (unsigned long)max)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (l > (INT_MAX-4))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (l && !BUF_MEM_grow_clean(s->init_buf,(int)l+4))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.message_size=l;\\r\\ns->state=stn;\\r\\ns->init_msg = s->init_buf->data + 4;\\r\\ns->init_num = 0;\\r\\n}\\r\\np = s->init_msg;\\r\\nn = s->s3->tmp.message_size - s->init_num;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n,0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\n*ok = 0;\\r\\nreturn i;\\r\\n}\\r\\ns->init_num += i;\\r\\nn -= i;\\r\\n}\\r\\nssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num + 4);\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data, (size_t)s->init_num + 4, s, s->msg_callback_arg);\\r\\n*ok=1;\\r\\nreturn s->init_num;\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\n*ok=0;\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl_cert_type(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret= -1,i;\\r\\nif (pkey == NULL)\\r\\npk=X509_get_pubkey(x);\\r\\nelse\\r\\npk=pkey;\\r\\nif (pk == NULL) goto err;\\r\\ni=pk->type;\\r\\nif (i == EVP_PKEY_RSA)\\r\\n{\\r\\nret=SSL_PKEY_RSA_ENC;\\r\\n}\\r\\nelse if (i == EVP_PKEY_DSA)\\r\\n{\\r\\nret=SSL_PKEY_DSA_SIGN;\\r\\n}\\r\\n#ifndef OPENSSL_NO_EC\\r\\nelse if (i == EVP_PKEY_EC)\\r\\n{\\r\\nret = SSL_PKEY_ECC;\\r\\n}\\r\\n#endif\\r\\nerr:\\r\\nif(!pkey) EVP_PKEY_free(pk);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl_verify_alarm_type(long type)\\r\\n{\\r\\nint al;\\r\\nswitch(type)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL:\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:\\r\\nal=SSL_AD_UNKNOWN_CA;\\r\\nbreak;\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\\r\\ncase X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\ncase X509_V_ERR_CERT_UNTRUSTED:\\r\\ncase X509_V_ERR_CERT_REJECTED:\\r\\nal=SSL_AD_BAD_CERTIFICATE;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_SIGNATURE_FAILURE:\\r\\ncase X509_V_ERR_CRL_SIGNATURE_FAILURE:\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\nal=SSL_AD_CERTIFICATE_EXPIRED;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_REVOKED:\\r\\nal=SSL_AD_CERTIFICATE_REVOKED;\\r\\nbreak;\\r\\ncase X509_V_ERR_OUT_OF_MEM:\\r\\nal=SSL_AD_INTERNAL_ERROR;\\r\\nbreak;\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\ncase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\\r\\ncase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\\r\\ncase X509_V_ERR_CERT_CHAIN_TOO_LONG:\\r\\ncase X509_V_ERR_PATH_LENGTH_EXCEEDED:\\r\\ncase X509_V_ERR_INVALID_CA:\\r\\nal=SSL_AD_UNKNOWN_CA;\\r\\nbreak;\\r\\ncase X509_V_ERR_APPLICATION_VERIFICATION:\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nbreak;\\r\\ncase X509_V_ERR_INVALID_PURPOSE:\\r\\nal=SSL_AD_UNSUPPORTED_CERTIFICATE;\\r\\nbreak;\\r\\ndefault:\\r\\nal=SSL_AD_CERTIFICATE_UNKNOWN;\\r\\nbreak;\\r\\n}\\r\\nreturn(al);\\r\\n}\\r\\nint ssl3_setup_buffers(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned int extra;\\r\\nsize_t len;\\r\\nif (s->s3->rbuf.buf == NULL)\\r\\n{\\r\\nif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\\r\\nextra=SSL3_RT_MAX_EXTRA;\\r\\nelse\\r\\nextra=0;\\r\\nlen = SSL3_RT_MAX_PACKET_SIZE + extra;\\r\\nif ((p=OPENSSL_malloc(len)) == NULL)\\r\\ngoto err;\\r\\ns->s3->rbuf.buf = p;\\r\\ns->s3->rbuf.len = len;\\r\\n}\\r\\nif (s->s3->wbuf.buf == NULL)\\r\\n{\\r\\nlen = SSL3_RT_MAX_PACKET_SIZE;\\r\\nlen += SSL3_RT_HEADER_LENGTH + 256;\\r\\nif ((p=OPENSSL_malloc(len)) == NULL)\\r\\ngoto err;\\r\\ns->s3->wbuf.buf = p;\\r\\ns->s3->wbuf.len = len;\\r\\n}\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_SETUP_BUFFERS,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_set_c", "target": 0, "func": "static int SetBlobCmp(const void *elem1, const void *elem2 )\\r\\n{\\r\\nconst MYBLOB *b1 = (const MYBLOB *)elem1;\\r\\nconst MYBLOB *b2 = (const MYBLOB *)elem2;\\r\\nint r;\\r\\nr = memcmp(b1->pbData, b2->pbData,\\r\\nb1->cbData < b2->cbData ? b1->cbData : b2->cbData);\\r\\nif(r != 0)\\r\\nreturn r;\\r\\nreturn b1->cbData-b2->cbData;\\r\\n}\\r\\nint i2d_ASN1_SET(STACK *a, unsigned char **pp, i2d_of_void *i2d, int ex_tag,\\r\\nint ex_class, int is_set)\\r\\n{\\r\\nint ret=0,r;\\r\\nint i;\\r\\nunsigned char *p;\\r\\nunsigned char *pStart, *pTempMem;\\r\\nMYBLOB *rgSetBlob;\\r\\nint totSize;\\r\\nif (a == NULL) return(0);\\r\\nfor (i=sk_num(a)-1; i>=0; i--)\\r\\nret+=i2d(sk_value(a,i),NULL);\\r\\nr=ASN1_object_size(1,ret,ex_tag);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,ret,ex_tag,ex_class);\\r\\nif(!is_set || (sk_num(a) < 2))\\r\\n{\\r\\nfor (i=0; i<sk_num(a); i++)\\r\\ni2d(sk_value(a,i),&p);\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\npStart = p;\\r\\nrgSetBlob = (MYBLOB *)OPENSSL_malloc(sk_num(a) * sizeof(MYBLOB));\\r\\nif (rgSetBlob == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_ASN1_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nfor (i=0; i<sk_num(a); i++)\\r\\n{\\r\\nrgSetBlob[i].pbData = p;\\r\\ni2d(sk_value(a,i),&p);\\r\\nrgSetBlob[i].cbData = p - rgSetBlob[i].pbData;\\r\\n}\\r\\n*pp=p;\\r\\ntotSize = p - pStart;\\r\\nqsort( rgSetBlob, sk_num(a), sizeof(MYBLOB), SetBlobCmp);\\r\\nif (!(pTempMem = OPENSSL_malloc(totSize)))\\r\\n{\\r\\nASN1err(ASN1_F_I2D_ASN1_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np = pTempMem;\\r\\nfor(i=0; i<sk_num(a); ++i)\\r\\n{\\r\\nmemcpy(p, rgSetBlob[i].pbData, rgSetBlob[i].cbData);\\r\\np += rgSetBlob[i].cbData;\\r\\n}\\r\\nmemcpy(pStart, pTempMem, totSize);\\r\\nOPENSSL_free(pTempMem);\\r\\nOPENSSL_free(rgSetBlob);\\r\\nreturn(r);\\r\\n}\\r\\nSTACK *d2i_ASN1_SET(STACK **a, const unsigned char **pp, long length,\\r\\nd2i_of_void *d2i, void (*free_func)(void *), int ex_tag,\\r\\nint ex_class)\\r\\n{\\r\\nASN1_const_CTX c;\\r\\nSTACK *ret=NULL;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=sk_new_null()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\nc.p= *pp;\\r\\nc.max=(length == 0)?0:(c.p+length);\\r\\nc.inf=ASN1_get_object(&c.p,&c.slen,&c.tag,&c.xclass,c.max-c.p);\\r\\nif (c.inf & 0x80) goto err;\\r\\nif (ex_class != c.xclass)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_CLASS);\\r\\ngoto err;\\r\\n}\\r\\nif (ex_tag != c.tag)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_TAG);\\r\\ngoto err;\\r\\n}\\r\\nif ((c.slen+c.p) > c.max)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_LENGTH_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (c.inf == (V_ASN1_CONSTRUCTED+1))\\r\\nc.slen=length+ *pp-c.p;\\r\\nc.max=c.p+c.slen;\\r\\nwhile (c.p < c.max)\\r\\n{\\r\\nchar *s;\\r\\nif (M_ASN1_D2I_end_sequence()) break;\\r\\nif ((s=d2i(NULL,&c.p,c.slen)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_ERROR_PARSING_SET_ELEMENT);\\r\\nasn1_add_error(*pp,(int)(c.q- *pp));\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_push(ret,s)) goto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=c.p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\n{\\r\\nif (free_func != NULL)\\r\\nsk_pop_free(ret,free_func);\\r\\nelse\\r\\nsk_free(ret);\\r\\n}\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_null_c", "target": 0, "func": "BIO_METHOD *BIO_f_null(void)\\r\\n{\\r\\nreturn(&methods_nullf);\\r\\n}\\r\\nstatic int nullf_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->ptr=NULL;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nullf_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nullf_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out == NULL) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nullf_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nullf_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nullf_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nullf_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_gets(bp->next_bio,buf,size));\\r\\n}\\r\\nstatic int nullf_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_puts(bp->next_bio,str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md2_dgst_c", "target": 0, "func": "const char *MD2_options(void)\\r\\n{\\r\\nif (sizeof(MD2_INT) == 1)\\r\\nreturn(\"md2(char)\");\\r\\nelse\\r\\nreturn(\"md2(int)\");\\r\\n}\\r\\nint MD2_Init(MD2_CTX *c)\\r\\n{\\r\\nc->num=0;\\r\\nmemset(c->state,0,sizeof c->state);\\r\\nmemset(c->cksm,0,sizeof c->cksm);\\r\\nmemset(c->data,0,sizeof c->data);\\r\\nreturn 1;\\r\\n}\\r\\nint MD2_Update(MD2_CTX *c, const unsigned char *data, size_t len)\\r\\n{\\r\\nregister UCHAR *p;\\r\\nif (len == 0) return 1;\\r\\np=c->data;\\r\\nif (c->num != 0)\\r\\n{\\r\\nif ((c->num+len) >= MD2_BLOCK)\\r\\n{\\r\\nmemcpy(&(p[c->num]),data,MD2_BLOCK-c->num);\\r\\nmd2_block(c,c->data);\\r\\ndata+=(MD2_BLOCK - c->num);\\r\\nlen-=(MD2_BLOCK - c->num);\\r\\nc->num=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(&(p[c->num]),data,len);\\r\\nc->num+=(int)len;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nwhile (len >= MD2_BLOCK)\\r\\n{\\r\\nmd2_block(c,data);\\r\\ndata+=MD2_BLOCK;\\r\\nlen-=MD2_BLOCK;\\r\\n}\\r\\nmemcpy(p,data,len);\\r\\nc->num=(int)len;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void md2_block(MD2_CTX *c, const unsigned char *d)\\r\\n{\\r\\nregister MD2_INT t,*sp1,*sp2;\\r\\nregister int i,j;\\r\\nMD2_INT state[48];\\r\\nsp1=c->state;\\r\\nsp2=c->cksm;\\r\\nj=sp2[MD2_BLOCK-1];\\r\\nfor (i=0; i<16; i++)\\r\\n{\\r\\nstate[i]=sp1[i];\\r\\nstate[i+16]=t=d[i];\\r\\nstate[i+32]=(t^sp1[i]);\\r\\nj=sp2[i]^=S[t^j];\\r\\n}\\r\\nt=0;\\r\\nfor (i=0; i<18; i++)\\r\\n{\\r\\nfor (j=0; j<48; j+=8)\\r\\n{\\r\\nt= state[j+ 0]^=S[t];\\r\\nt= state[j+ 1]^=S[t];\\r\\nt= state[j+ 2]^=S[t];\\r\\nt= state[j+ 3]^=S[t];\\r\\nt= state[j+ 4]^=S[t];\\r\\nt= state[j+ 5]^=S[t];\\r\\nt= state[j+ 6]^=S[t];\\r\\nt= state[j+ 7]^=S[t];\\r\\n}\\r\\nt=(t+i)&0xff;\\r\\n}\\r\\nmemcpy(sp1,state,16*sizeof(MD2_INT));\\r\\nOPENSSL_cleanse(state,48*sizeof(MD2_INT));\\r\\n}\\r\\nint MD2_Final(unsigned char *md, MD2_CTX *c)\\r\\n{\\r\\nint i,v;\\r\\nregister UCHAR *cp;\\r\\nregister MD2_INT *p1,*p2;\\r\\ncp=c->data;\\r\\np1=c->state;\\r\\np2=c->cksm;\\r\\nv=MD2_BLOCK-c->num;\\r\\nfor (i=c->num; i<MD2_BLOCK; i++)\\r\\ncp[i]=(UCHAR)v;\\r\\nmd2_block(c,cp);\\r\\nfor (i=0; i<MD2_BLOCK; i++)\\r\\ncp[i]=(UCHAR)p2[i];\\r\\nmd2_block(c,cp);\\r\\nfor (i=0; i<16; i++)\\r\\nmd[i]=(UCHAR)(p1[i]&0xff);\\r\\nmemset((char *)&c,0,sizeof(c));\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_curve_c", "target": 0, "func": "static EC_GROUP *ec_group_new_from_data(const EC_CURVE_DATA *data)\\r\\n{\\r\\nEC_GROUP *group=NULL;\\r\\nEC_POINT *P=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nBIGNUM *p=NULL, *a=NULL, *b=NULL, *x=NULL, *y=NULL, *order=NULL;\\r\\nint ok=0;\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((p = BN_new()) == NULL || (a = BN_new()) == NULL ||\\r\\n(b = BN_new()) == NULL || (x = BN_new()) == NULL ||\\r\\n(y = BN_new()) == NULL || (order = BN_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_hex2bn(&p, data->p) || !BN_hex2bn(&a, data->a)\\r\\n|| !BN_hex2bn(&b, data->b))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (data->field_type == NID_X9_62_prime_field)\\r\\n{\\r\\nif ((group = EC_GROUP_new_curve_GFp(p, a, b, ctx)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((group = EC_GROUP_new_curve_GF2m(p, a, b, ctx)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((P = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_hex2bn(&x, data->x) || !BN_hex2bn(&y, data->y))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_hex2bn(&order, data->order) || !BN_set_word(x, data->cofactor))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_set_generator(group, P, order, x))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (data->seed)\\r\\n{\\r\\nif (!EC_GROUP_set_seed(group, data->seed, data->seed_len))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nEC_GROUP_free(group);\\r\\ngroup = NULL;\\r\\n}\\r\\nif (P)\\r\\nEC_POINT_free(P);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (x)\\r\\nBN_free(x);\\r\\nif (y)\\r\\nBN_free(y);\\r\\nreturn group;\\r\\n}\\r\\nEC_GROUP *EC_GROUP_new_by_curve_name(int nid)\\r\\n{\\r\\nsize_t i;\\r\\nEC_GROUP *ret = NULL;\\r\\nif (nid <= 0)\\r\\nreturn NULL;\\r\\nfor (i=0; i<curve_list_length; i++)\\r\\nif (curve_list[i].nid == nid)\\r\\n{\\r\\nret = ec_group_new_from_data(curve_list[i].data);\\r\\nbreak;\\r\\n}\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW_BY_CURVE_NAME, EC_R_UNKNOWN_GROUP);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_curve_name(ret, nid);\\r\\nreturn ret;\\r\\n}\\r\\nsize_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems)\\r\\n{\\r\\nsize_t i, min;\\r\\nif (r == NULL || nitems == 0)\\r\\nreturn curve_list_length;\\r\\nmin = nitems < curve_list_length ? nitems : curve_list_length;\\r\\nfor (i = 0; i < min; i++)\\r\\n{\\r\\nr[i].nid = curve_list[i].nid;\\r\\nr[i].comment = curve_list[i].data->comment;\\r\\n}\\r\\nreturn curve_list_length;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_md4_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return MD4_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return MD4_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return MD4_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_md4(void)\\r\\n{\\r\\nreturn(&md4_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_nist_c", "target": 0, "func": "const BIGNUM *BN_get0_nist_prime_192(void)\\r\\n{\\r\\nstatic BIGNUM const_nist_192 = { (BN_ULONG *)_nist_p_192,\\r\\nBN_NIST_192_TOP, BN_NIST_192_TOP, 0, BN_FLG_STATIC_DATA };\\r\\nreturn &const_nist_192;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_224(void)\\r\\n{\\r\\nstatic BIGNUM const_nist_224 = { (BN_ULONG *)_nist_p_224,\\r\\nBN_NIST_224_TOP, BN_NIST_224_TOP, 0, BN_FLG_STATIC_DATA };\\r\\nreturn &const_nist_224;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_256(void)\\r\\n{\\r\\nstatic BIGNUM const_nist_256 = { (BN_ULONG *)_nist_p_256,\\r\\nBN_NIST_256_TOP, BN_NIST_256_TOP, 0, BN_FLG_STATIC_DATA };\\r\\nreturn &const_nist_256;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_384(void)\\r\\n{\\r\\nstatic BIGNUM const_nist_384 = { (BN_ULONG *)_nist_p_384,\\r\\nBN_NIST_384_TOP, BN_NIST_384_TOP, 0, BN_FLG_STATIC_DATA };\\r\\nreturn &const_nist_384;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_521(void)\\r\\n{\\r\\nstatic BIGNUM const_nist_521 = { (BN_ULONG *)_nist_p_521,\\r\\nBN_NIST_521_TOP, BN_NIST_521_TOP, 0, BN_FLG_STATIC_DATA };\\r\\nreturn &const_nist_521;\\r\\n}\\r\\nstatic void nist_cp_bn_0(BN_ULONG *buf, BN_ULONG *a, int top, int max)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *_tmp1 = (buf), *_tmp2 = (a);\\r\\nfor (i = (top); i != 0; i--)\\r\\n*_tmp1++ = *_tmp2++;\\r\\nfor (i = (max) - (top); i != 0; i--)\\r\\n*_tmp1++ = (BN_ULONG) 0;\\r\\n}\\r\\nstatic void nist_cp_bn(BN_ULONG *buf, BN_ULONG *a, int top)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *_tmp1 = (buf), *_tmp2 = (a);\\r\\nfor (i = (top); i != 0; i--)\\r\\n*_tmp1++ = *_tmp2++;\\r\\n}\\r\\nint BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint top = a->top, i;\\r\\nBN_ULONG carry = 0;\\r\\nregister BN_ULONG *r_d, *a_d = a->d;\\r\\nBN_ULONG t_d[BN_NIST_192_TOP],\\r\\nbuf[BN_NIST_192_TOP];\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nelse if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r ,a) != NULL);\\r\\nif (top == BN_NIST_192_TOP)\\r\\nreturn BN_usub(r, a, field);\\r\\nif (r != a)\\r\\n{\\r\\nif (!bn_wexpand(r, BN_NIST_192_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_192_TOP);\\r\\n}\\r\\nelse\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP, BN_NIST_192_TOP);\\r\\n#if defined(OPENSSL_SYS_VMS) && defined(__DECC)\\r\\n# pragma message save\\r\\n# pragma message disable BADSUBSCRIPT\\r\\n#endif\\r\\nnist_set_192(t_d, buf, 0, 3, 3);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP))\\r\\n++carry;\\r\\nnist_set_192(t_d, buf, 4, 4, 0);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP))\\r\\n++carry;\\r\\n#if defined(OPENSSL_SYS_VMS) && defined(__DECC)\\r\\n# pragma message restore\\r\\n#endif\\r\\nnist_set_192(t_d, buf, 5, 5, 5)\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP))\\r\\n++carry;\\r\\nwhile (carry)\\r\\n{\\r\\nif (bn_sub_words(r_d, r_d, _nist_p_192, BN_NIST_192_TOP))\\r\\n--carry;\\r\\n}\\r\\nr->top = BN_NIST_192_TOP;\\r\\nbn_correct_top(r);\\r\\nif (BN_ucmp(r, field) >= 0)\\r\\n{\\r\\nbn_sub_words(r_d, r_d, _nist_p_192, BN_NIST_192_TOP);\\r\\nbn_correct_top(r);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\n#if BN_BITS2 != 64\\r\\nint top = a->top, i;\\r\\nint carry = 0;\\r\\nBN_ULONG *r_d, *a_d = a->d;\\r\\nBN_ULONG t_d[BN_NIST_224_TOP],\\r\\nbuf[BN_NIST_224_TOP];\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nelse if (i > 0)\\r\\nreturn (r == a)? 1 : (BN_copy(r ,a) != NULL);\\r\\nif (top == BN_NIST_224_TOP)\\r\\nreturn BN_usub(r, a, field);\\r\\nif (r != a)\\r\\n{\\r\\nif (!bn_wexpand(r, BN_NIST_224_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\\r\\n}\\r\\nelse\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP, BN_NIST_224_TOP);\\r\\nnist_set_224(t_d, buf, 10, 9, 8, 7, 0, 0, 0);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP))\\r\\n++carry;\\r\\nnist_set_224(t_d, buf, 0, 13, 12, 11, 0, 0, 0);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP))\\r\\n++carry;\\r\\nnist_set_224(t_d, buf, 13, 12, 11, 10, 9, 8, 7);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP))\\r\\n--carry;\\r\\nnist_set_224(t_d, buf, 0, 0, 0, 0, 13, 12, 11);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP))\\r\\n--carry;\\r\\nif (carry > 0)\\r\\nwhile (carry)\\r\\n{\\r\\nif (bn_sub_words(r_d,r_d,_nist_p_224,BN_NIST_224_TOP))\\r\\n--carry;\\r\\n}\\r\\nelse if (carry < 0)\\r\\nwhile (carry)\\r\\n{\\r\\nif (bn_add_words(r_d,r_d,_nist_p_224,BN_NIST_224_TOP))\\r\\n++carry;\\r\\n}\\r\\nr->top = BN_NIST_224_TOP;\\r\\nbn_correct_top(r);\\r\\nif (BN_ucmp(r, field) >= 0)\\r\\n{\\r\\nbn_sub_words(r_d, r_d, _nist_p_224, BN_NIST_224_TOP);\\r\\nbn_correct_top(r);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nstatic void _init_256_data(void)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *tmp1 = _256_data;\\r\\nconst BN_ULONG *tmp2 = tmp1;\\r\\nmemcpy(tmp1, _nist_p_256, BN_NIST_256_TOP * sizeof(BN_ULONG));\\r\\ntmp1 += BN_NIST_256_TOP;\\r\\nfor (i=0; i<5; i++)\\r\\n{\\r\\nbn_add_words(tmp1, _nist_p_256, tmp2, BN_NIST_256_TOP);\\r\\ntmp2 = tmp1;\\r\\ntmp1 += BN_NIST_256_TOP;\\r\\n}\\r\\n_is_set_256_data = 1;\\r\\n}\\r\\nint BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\n#if BN_BITS2 != 64\\r\\nint i, top = a->top;\\r\\nint carry = 0;\\r\\nregister BN_ULONG *a_d = a->d, *r_d;\\r\\nBN_ULONG t_d[BN_NIST_256_TOP],\\r\\nt_d2[BN_NIST_256_TOP],\\r\\nbuf[BN_NIST_256_TOP];\\r\\nif (!_is_set_256_data)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_BN);\\r\\nif (!_is_set_256_data)\\r\\n_init_256_data();\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_BN);\\r\\n}\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nelse if (i > 0)\\r\\nreturn (r == a)? 1 : (BN_copy(r ,a) != NULL);\\r\\nif (top == BN_NIST_256_TOP)\\r\\nreturn BN_usub(r, a, field);\\r\\nif (r != a)\\r\\n{\\r\\nif (!bn_wexpand(r, BN_NIST_256_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_256_TOP);\\r\\n}\\r\\nelse\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf, a_d + BN_NIST_256_TOP, top - BN_NIST_256_TOP, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf, 15, 14, 13, 12, 11, 0, 0, 0);\\r\\nnist_set_256(t_d2,buf, 0, 15, 14, 13, 12, 0, 0, 0);\\r\\nif (bn_add_words(t_d, t_d, t_d2, BN_NIST_256_TOP))\\r\\ncarry = 2;\\r\\n{\\r\\nregister BN_ULONG *ap,t,c;\\r\\nap = t_d;\\r\\nc=0;\\r\\nfor (i = BN_NIST_256_TOP; i != 0; --i)\\r\\n{\\r\\nt= *ap;\\r\\n*(ap++)=((t<<1)|c)&BN_MASK2;\\r\\nc=(t & BN_TBIT)?1:0;\\r\\n}\\r\\nif (c)\\r\\n++carry;\\r\\n}\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n++carry;\\r\\nnist_set_256(t_d, buf, 15, 14, 0, 0, 0, 10, 9, 8);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n++carry;\\r\\nnist_set_256(t_d, buf, 8, 13, 15, 14, 13, 11, 10, 9);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n++carry;\\r\\nnist_set_256(t_d, buf, 10, 8, 0, 0, 0, 13, 12, 11);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n--carry;\\r\\nnist_set_256(t_d, buf, 11, 9, 0, 0, 15, 14, 13, 12);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n--carry;\\r\\nnist_set_256(t_d, buf, 12, 0, 10, 9, 8, 15, 14, 13);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n--carry;\\r\\nnist_set_256(t_d, buf, 13, 0, 11, 10, 9, 0, 15, 14);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP))\\r\\n--carry;\\r\\nif (carry)\\r\\n{\\r\\nif (carry > 0)\\r\\nbn_sub_words(r_d, r_d, _256_data + BN_NIST_256_TOP *\\r\\n--carry, BN_NIST_256_TOP);\\r\\nelse\\r\\n{\\r\\ncarry = -carry;\\r\\nbn_add_words(r_d, r_d, _256_data + BN_NIST_256_TOP *\\r\\n--carry, BN_NIST_256_TOP);\\r\\n}\\r\\n}\\r\\nr->top = BN_NIST_256_TOP;\\r\\nbn_correct_top(r);\\r\\nif (BN_ucmp(r, field) >= 0)\\r\\n{\\r\\nbn_sub_words(r_d, r_d, _nist_p_256, BN_NIST_256_TOP);\\r\\nbn_correct_top(r);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nstatic void _init_384_data(void)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *tmp1 = _384_data;\\r\\nconst BN_ULONG *tmp2 = tmp1;\\r\\nmemcpy(tmp1, _nist_p_384, BN_NIST_384_TOP * sizeof(BN_ULONG));\\r\\ntmp1 += BN_NIST_384_TOP;\\r\\nfor (i=0; i<7; i++)\\r\\n{\\r\\nbn_add_words(tmp1, _nist_p_384, tmp2, BN_NIST_384_TOP);\\r\\ntmp2 = tmp1;\\r\\ntmp1 += BN_NIST_384_TOP;\\r\\n}\\r\\n_is_set_384_data = 1;\\r\\n}\\r\\nint BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\n#if BN_BITS2 != 64\\r\\nint i, top = a->top;\\r\\nint carry = 0;\\r\\nregister BN_ULONG *r_d, *a_d = a->d;\\r\\nBN_ULONG t_d[BN_NIST_384_TOP],\\r\\nbuf[BN_NIST_384_TOP];\\r\\nif (!_is_set_384_data)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_BN);\\r\\nif (!_is_set_384_data)\\r\\n_init_384_data();\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_BN);\\r\\n}\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nelse if (i > 0)\\r\\nreturn (r == a)? 1 : (BN_copy(r ,a) != NULL);\\r\\nif (top == BN_NIST_384_TOP)\\r\\nreturn BN_usub(r, a, field);\\r\\nif (r != a)\\r\\n{\\r\\nif (!bn_wexpand(r, BN_NIST_384_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_384_TOP);\\r\\n}\\r\\nelse\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf, a_d + BN_NIST_384_TOP, top - BN_NIST_384_TOP, BN_NIST_384_TOP);\\r\\nnist_set_256(t_d, buf, 0, 0, 0, 0, 0, 23-4, 22-4, 21-4);\\r\\n{\\r\\nregister BN_ULONG *ap,t,c;\\r\\nap = t_d;\\r\\nc=0;\\r\\nfor (i = BN_NIST_256_TOP; i != 0; --i)\\r\\n{\\r\\nt= *ap;\\r\\n*(ap++)=((t<<1)|c)&BN_MASK2;\\r\\nc=(t & BN_TBIT)?1:0;\\r\\n}\\r\\n}\\r\\nif (bn_add_words(r_d+(128/BN_BITS2), r_d+(128/BN_BITS2),\\r\\nt_d, BN_NIST_256_TOP))\\r\\n++carry;\\r\\nif (bn_add_words(r_d, r_d, buf, BN_NIST_384_TOP))\\r\\n++carry;\\r\\nnist_set_384(t_d,buf,20,19,18,17,16,15,14,13,12,23,22,21);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n++carry;\\r\\nnist_set_384(t_d,buf,19,18,17,16,15,14,13,12,20,0,23,0);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n++carry;\\r\\nnist_set_256(t_d, buf, 0, 0, 0, 0, 23-4, 22-4, 21-4, 20-4);\\r\\nif (bn_add_words(r_d+(128/BN_BITS2), r_d+(128/BN_BITS2),\\r\\nt_d, BN_NIST_256_TOP))\\r\\n++carry;\\r\\nnist_set_384(t_d,buf,0,0,0,0,0,0,23,22,21,0,0,20);\\r\\nif (bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n++carry;\\r\\nnist_set_384(t_d,buf,22,21,20,19,18,17,16,15,14,13,12,23);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n--carry;\\r\\nnist_set_384(t_d,buf,0,0,0,0,0,0,0,23,22,21,20,0);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n--carry;\\r\\nnist_set_384(t_d,buf,0,0,0,0,0,0,0,23,23,0,0,0);\\r\\nif (bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP))\\r\\n--carry;\\r\\nif (carry)\\r\\n{\\r\\nif (carry > 0)\\r\\nbn_sub_words(r_d, r_d, _384_data + BN_NIST_384_TOP *\\r\\n--carry, BN_NIST_384_TOP);\\r\\nelse\\r\\n{\\r\\ncarry = -carry;\\r\\nbn_add_words(r_d, r_d, _384_data + BN_NIST_384_TOP *\\r\\n--carry, BN_NIST_384_TOP);\\r\\n}\\r\\n}\\r\\nr->top = BN_NIST_384_TOP;\\r\\nbn_correct_top(r);\\r\\nif (BN_ucmp(r, field) >= 0)\\r\\n{\\r\\nbn_sub_words(r_d, r_d, _nist_p_384, BN_NIST_384_TOP);\\r\\nbn_correct_top(r);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nint BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\n#if BN_BITS2 == 64\\r\\n#define BN_NIST_521_TOP_MASK (BN_ULONG)0x1FF\\r\\n#elif BN_BITS2 == 32\\r\\n#define BN_NIST_521_TOP_MASK (BN_ULONG)0x1FF\\r\\n#elif BN_BITS2 == 16\\r\\n#define BN_NIST_521_TOP_MASK (BN_ULONG)0x1FF\\r\\n#elif BN_BITS2 == 8\\r\\n#define BN_NIST_521_TOP_MASK (BN_ULONG)0x1\\r\\n#endif\\r\\nint top, ret = 0;\\r\\nBN_ULONG *r_d;\\r\\nBIGNUM *tmp;\\r\\ntop = a->top;\\r\\nif (top < BN_NIST_521_TOP || ( top == BN_NIST_521_TOP &&\\r\\n(!(a->d[BN_NIST_521_TOP-1] & ~(BN_NIST_521_TOP_MASK)))))\\r\\nreturn (r == a)? 1 : (BN_copy(r ,a) != NULL);\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (!tmp)\\r\\ngoto err;\\r\\nif (!bn_wexpand(tmp, BN_NIST_521_TOP))\\r\\ngoto err;\\r\\nnist_cp_bn(tmp->d, a->d, BN_NIST_521_TOP);\\r\\ntmp->top = BN_NIST_521_TOP;\\r\\ntmp->d[BN_NIST_521_TOP-1] &= BN_NIST_521_TOP_MASK;\\r\\nbn_correct_top(tmp);\\r\\nif (!BN_rshift(r, a, 521))\\r\\ngoto err;\\r\\nif (!BN_uadd(r, tmp, r))\\r\\ngoto err;\\r\\ntop = r->top;\\r\\nr_d = r->d;\\r\\nif (top == BN_NIST_521_TOP &&\\r\\n(r_d[BN_NIST_521_TOP-1] & ~(BN_NIST_521_TOP_MASK)))\\r\\n{\\r\\nBN_NIST_ADD_ONE(r_d)\\r\\nr_d[BN_NIST_521_TOP-1] &= BN_NIST_521_TOP_MASK;\\r\\n}\\r\\nbn_correct_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hmac_c", "target": 0, "func": "void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\\r\\nconst EVP_MD *md, ENGINE *impl)\\r\\n{\\r\\nint i,j,reset=0;\\r\\nunsigned char pad[HMAC_MAX_MD_CBLOCK];\\r\\nif (md != NULL)\\r\\n{\\r\\nreset=1;\\r\\nctx->md=md;\\r\\n}\\r\\nelse\\r\\nmd=ctx->md;\\r\\nif (key != NULL)\\r\\n{\\r\\nreset=1;\\r\\nj=EVP_MD_block_size(md);\\r\\nOPENSSL_assert(j <= (int)sizeof(ctx->key));\\r\\nif (j < len)\\r\\n{\\r\\nEVP_DigestInit_ex(&ctx->md_ctx,md, impl);\\r\\nEVP_DigestUpdate(&ctx->md_ctx,key,len);\\r\\nEVP_DigestFinal_ex(&(ctx->md_ctx),ctx->key,\\r\\n&ctx->key_length);\\r\\n}\\r\\nelse\\r\\n{\\r\\nOPENSSL_assert(len>=0 && len<=(int)sizeof(ctx->key));\\r\\nmemcpy(ctx->key,key,len);\\r\\nctx->key_length=len;\\r\\n}\\r\\nif(ctx->key_length != HMAC_MAX_MD_CBLOCK)\\r\\nmemset(&ctx->key[ctx->key_length], 0,\\r\\nHMAC_MAX_MD_CBLOCK - ctx->key_length);\\r\\n}\\r\\nif (reset)\\r\\n{\\r\\nfor (i=0; i<HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i]=0x36^ctx->key[i];\\r\\nEVP_DigestInit_ex(&ctx->i_ctx,md, impl);\\r\\nEVP_DigestUpdate(&ctx->i_ctx,pad,EVP_MD_block_size(md));\\r\\nfor (i=0; i<HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i]=0x5c^ctx->key[i];\\r\\nEVP_DigestInit_ex(&ctx->o_ctx,md, impl);\\r\\nEVP_DigestUpdate(&ctx->o_ctx,pad,EVP_MD_block_size(md));\\r\\n}\\r\\nEVP_MD_CTX_copy_ex(&ctx->md_ctx,&ctx->i_ctx);\\r\\n}\\r\\nvoid HMAC_Init(HMAC_CTX *ctx, const void *key, int len,\\r\\nconst EVP_MD *md)\\r\\n{\\r\\nif(key && md)\\r\\nHMAC_CTX_init(ctx);\\r\\nHMAC_Init_ex(ctx,key,len,md, NULL);\\r\\n}\\r\\nvoid HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len)\\r\\n{\\r\\nEVP_DigestUpdate(&ctx->md_ctx,data,len);\\r\\n}\\r\\nvoid HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len)\\r\\n{\\r\\nint j;\\r\\nunsigned int i;\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\nj=EVP_MD_block_size(ctx->md);\\r\\nEVP_DigestFinal_ex(&ctx->md_ctx,buf,&i);\\r\\nEVP_MD_CTX_copy_ex(&ctx->md_ctx,&ctx->o_ctx);\\r\\nEVP_DigestUpdate(&ctx->md_ctx,buf,i);\\r\\nEVP_DigestFinal_ex(&ctx->md_ctx,md,len);\\r\\n}\\r\\nvoid HMAC_CTX_init(HMAC_CTX *ctx)\\r\\n{\\r\\nEVP_MD_CTX_init(&ctx->i_ctx);\\r\\nEVP_MD_CTX_init(&ctx->o_ctx);\\r\\nEVP_MD_CTX_init(&ctx->md_ctx);\\r\\n}\\r\\nvoid HMAC_CTX_cleanup(HMAC_CTX *ctx)\\r\\n{\\r\\nEVP_MD_CTX_cleanup(&ctx->i_ctx);\\r\\nEVP_MD_CTX_cleanup(&ctx->o_ctx);\\r\\nEVP_MD_CTX_cleanup(&ctx->md_ctx);\\r\\nmemset(ctx,0,sizeof *ctx);\\r\\n}\\r\\nunsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,\\r\\nconst unsigned char *d, size_t n, unsigned char *md,\\r\\nunsigned int *md_len)\\r\\n{\\r\\nHMAC_CTX c;\\r\\nstatic unsigned char m[EVP_MAX_MD_SIZE];\\r\\nif (md == NULL) md=m;\\r\\nHMAC_CTX_init(&c);\\r\\nHMAC_Init(&c,key,key_len,evp_md);\\r\\nHMAC_Update(&c,d,n);\\r\\nHMAC_Final(&c,md,md_len);\\r\\nHMAC_CTX_cleanup(&c);\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t1_clnt_c", "target": 0, "func": "static SSL_METHOD *tls1_get_client_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_client_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_client_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_client_data.ssl_connect=ssl3_connect;\\r\\nTLSv1_client_data.get_ssl_method=tls1_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&TLSv1_client_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_spki_c", "target": 0, "func": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nASN1_IA5STRING *chal;\\r\\nint i, n;\\r\\nchar *s;\\r\\nBIO_printf(out, \"Netscape SPKI:\\n\");\\r\\ni=OBJ_obj2nid(spki->spkac->pubkey->algor->algorithm);\\r\\nBIO_printf(out,\" Public Key Algorithm: %s\\n\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i));\\r\\npkey = X509_PUBKEY_get(spki->spkac->pubkey);\\r\\nif(!pkey) BIO_printf(out, \" Unable to load public key\\n\");\\r\\nelse {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nBIO_printf(out,\" RSA Public Key: (%d bit)\\n\",\\r\\nBN_num_bits(pkey->pkey.rsa->n));\\r\\nRSA_print(out,pkey->pkey.rsa,2);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIO_printf(out,\" DSA Public Key:\\n\");\\r\\nDSA_print(out,pkey->pkey.dsa,2);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nBIO_printf(out, \" EC Public Key:\\n\");\\r\\nEC_KEY_print(out, pkey->pkey.ec,2);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(out,\" Unknown Public Key:\\n\");\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nchal = spki->spkac->challenge;\\r\\nif(chal->length)\\r\\nBIO_printf(out, \" Challenge String: %s\\n\", chal->data);\\r\\ni=OBJ_obj2nid(spki->sig_algor->algorithm);\\r\\nBIO_printf(out,\" Signature Algorithm: %s\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i));\\r\\nn=spki->signature->length;\\r\\ns=(char *)spki->signature->data;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%18) == 0) BIO_write(out,\"\\n \",7);\\r\\nBIO_printf(out,\"%02x%s\",(unsigned char)s[i],\\r\\n((i+1) == n)?\"\":\":\");\\r\\n}\\r\\nBIO_write(out,\"\\n\",1);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_cnf_c", "target": 0, "func": "static char *skip_dot(char *name)\\r\\n{\\r\\nchar *p;\\r\\np = strchr(name, '.');\\r\\nif (p)\\r\\nreturn p + 1;\\r\\nreturn name;\\r\\n}\\r\\nstatic int int_engine_init(ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_init(e))\\r\\nreturn 0;\\r\\nif (!initialized_engines)\\r\\ninitialized_engines = sk_ENGINE_new_null();\\r\\nif (!initialized_engines || !sk_ENGINE_push(initialized_engines, e))\\r\\n{\\r\\nENGINE_finish(e);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_engine_configure(char *name, char *value, const CONF *cnf)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nlong do_init = -1;\\r\\nSTACK_OF(CONF_VALUE) *ecmds;\\r\\nCONF_VALUE *ecmd;\\r\\nchar *ctrlname, *ctrlvalue;\\r\\nENGINE *e = NULL;\\r\\nname = skip_dot(name);\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"Configuring engine %s\\n\", name);\\r\\n#endif\\r\\necmds = NCONF_get_section(cnf, value);\\r\\nif (!ecmds)\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(ecmds); i++)\\r\\n{\\r\\necmd = sk_CONF_VALUE_value(ecmds, i);\\r\\nctrlname = skip_dot(ecmd->name);\\r\\nctrlvalue = ecmd->value;\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"ENGINE conf: doing ctrl(%s,%s)\\n\", ctrlname, ctrlvalue);\\r\\n#endif\\r\\nif (!strcmp(ctrlname, \"engine_id\"))\\r\\nname = ctrlvalue;\\r\\nelse if (!strcmp(ctrlname, \"dynamic_path\"))\\r\\n{\\r\\ne = ENGINE_by_id(\"dynamic\");\\r\\nif (!e)\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"SO_PATH\", ctrlvalue, 0))\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"LIST_ADD\", \"2\", 0))\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"LOAD\", NULL, 0))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!e)\\r\\n{\\r\\ne = ENGINE_by_id(name);\\r\\nif (!e)\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(ctrlvalue, \"EMPTY\"))\\r\\nctrlvalue = NULL;\\r\\nif (!strcmp(ctrlname, \"init\"))\\r\\n{\\r\\nif (!NCONF_get_number_e(cnf, value, \"init\", &do_init))\\r\\ngoto err;\\r\\nif (do_init == 1)\\r\\n{\\r\\nif (!int_engine_init(e))\\r\\ngoto err;\\r\\n}\\r\\nelse if (do_init != 0)\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_INVALID_INIT_VALUE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if (!strcmp(ctrlname, \"default_algorithms\"))\\r\\n{\\r\\nif (!ENGINE_set_default_string(e, ctrlvalue))\\r\\ngoto err;\\r\\n}\\r\\nelse if (!ENGINE_ctrl_cmd_string(e,\\r\\nctrlname, ctrlvalue, 0))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (e && (do_init == -1) && !int_engine_init(e))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (e)\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *elist;\\r\\nCONF_VALUE *cval;\\r\\nint i;\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"Called engine module: name %s, value %s\\n\",\\r\\nCONF_imodule_get_name(md), CONF_imodule_get_value(md));\\r\\n#endif\\r\\nelist = NCONF_get_section(cnf, CONF_imodule_get_value(md));\\r\\nif (!elist)\\r\\n{\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(elist); i++)\\r\\n{\\r\\ncval = sk_CONF_VALUE_value(elist, i);\\r\\nif (!int_engine_configure(cval->name, cval->value, cnf))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_engine_module_finish(CONF_IMODULE *md)\\r\\n{\\r\\nENGINE *e;\\r\\nwhile ((e = sk_ENGINE_pop(initialized_engines)))\\r\\nENGINE_finish(e);\\r\\nsk_ENGINE_free(initialized_engines);\\r\\ninitialized_engines = NULL;\\r\\n}\\r\\nvoid ENGINE_add_conf_module(void)\\r\\n{\\r\\nCONF_module_add(\"engines\",\\r\\nint_engine_module_init,\\r\\nint_engine_module_finish);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_depr_c", "target": 0, "func": "RSA *RSA_generate_key(int bits, unsigned long e_value,\\r\\nvoid (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nint i;\\r\\nRSA *rsa = RSA_new();\\r\\nBIGNUM *e = BN_new();\\r\\nif(!rsa || !e) goto err;\\r\\nfor (i=0; i<sizeof(unsigned long)*8; i++)\\r\\n{\\r\\nif (e_value & (1UL<<i))\\r\\nBN_set_bit(e,i);\\r\\n}\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif(RSA_generate_key_ex(rsa, bits, e, &cb)) {\\r\\nBN_free(e);\\r\\nreturn rsa;\\r\\n}\\r\\nerr:\\r\\nif(e) BN_free(e);\\r\\nif(rsa) RSA_free(rsa);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc4speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC4_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC4_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC4(&sch,8,buf,buf);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC4_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC4_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC4_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC4 on %ld byte blocks for 10 seconds\\n\",BUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC4 %ld times on %ld byte blocks\\n\",cc,BUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC4(&sch,BUFSIZE,buf,buf);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC4's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC4 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC4 bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_atalla_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth2;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_atalla_id) ||\\r\\n!ENGINE_set_name(e, engine_atalla_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &atalla_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &atalla_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &atalla_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_destroy_function(e, atalla_destroy) ||\\r\\n!ENGINE_set_init_function(e, atalla_init) ||\\r\\n!ENGINE_set_finish_function(e, atalla_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, atalla_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, atalla_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\natalla_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\natalla_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\natalla_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\natalla_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth2 = DSA_OpenSSL();\\r\\natalla_dsa.dsa_do_sign = meth2->dsa_do_sign;\\r\\natalla_dsa.dsa_sign_setup = meth2->dsa_sign_setup;\\r\\natalla_dsa.dsa_do_verify = meth2->dsa_do_verify;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth3 = DH_OpenSSL();\\r\\natalla_dh.generate_key = meth3->generate_key;\\r\\natalla_dh.compute_key = meth3->compute_key;\\r\\n#endif\\r\\nERR_load_ATALLA_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_atalla(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_atalla(void)\\r\\n{\\r\\nENGINE *toadd = engine_atalla();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic const char *get_ATALLA_LIBNAME(void)\\r\\n{\\r\\nif(ATALLA_LIBNAME)\\r\\nreturn ATALLA_LIBNAME;\\r\\nreturn \"atasi\";\\r\\n}\\r\\nstatic void free_ATALLA_LIBNAME(void)\\r\\n{\\r\\nif(ATALLA_LIBNAME)\\r\\nOPENSSL_free((void*)ATALLA_LIBNAME);\\r\\nATALLA_LIBNAME = NULL;\\r\\n}\\r\\nstatic long set_ATALLA_LIBNAME(const char *name)\\r\\n{\\r\\nfree_ATALLA_LIBNAME();\\r\\nreturn (((ATALLA_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int atalla_destroy(ENGINE *e)\\r\\n{\\r\\nfree_ATALLA_LIBNAME();\\r\\nERR_unload_ATALLA_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int atalla_init(ENGINE *e)\\r\\n{\\r\\ntfnASI_GetHardwareConfig *p1;\\r\\ntfnASI_RSAPrivateKeyOpFn *p2;\\r\\ntfnASI_GetPerformanceStatistics *p3;\\r\\nunsigned int config_buf[1024];\\r\\nif(atalla_dso != NULL)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_INIT,ATALLA_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\natalla_dso = DSO_load(NULL, get_ATALLA_LIBNAME(), NULL, 0);\\r\\nif(atalla_dso == NULL)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_INIT,ATALLA_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif(!(p1 = (tfnASI_GetHardwareConfig *)DSO_bind_func(\\r\\natalla_dso, ATALLA_F1)) ||\\r\\n!(p2 = (tfnASI_RSAPrivateKeyOpFn *)DSO_bind_func(\\r\\natalla_dso, ATALLA_F2)) ||\\r\\n!(p3 = (tfnASI_GetPerformanceStatistics *)DSO_bind_func(\\r\\natalla_dso, ATALLA_F3)))\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_INIT,ATALLA_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\np_Atalla_GetHardwareConfig = p1;\\r\\np_Atalla_RSAPrivateKeyOpFn = p2;\\r\\np_Atalla_GetPerformanceStatistics = p3;\\r\\nif(p1(0L, config_buf) != 0)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_INIT,ATALLA_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif(atalla_dso)\\r\\nDSO_free(atalla_dso);\\r\\natalla_dso = NULL;\\r\\np_Atalla_GetHardwareConfig = NULL;\\r\\np_Atalla_RSAPrivateKeyOpFn = NULL;\\r\\np_Atalla_GetPerformanceStatistics = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int atalla_finish(ENGINE *e)\\r\\n{\\r\\nfree_ATALLA_LIBNAME();\\r\\nif(atalla_dso == NULL)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_FINISH,ATALLA_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(atalla_dso))\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_FINISH,ATALLA_R_UNIT_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\natalla_dso = NULL;\\r\\np_Atalla_GetHardwareConfig = NULL;\\r\\np_Atalla_RSAPrivateKeyOpFn = NULL;\\r\\np_Atalla_GetPerformanceStatistics = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int atalla_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((atalla_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase ATALLA_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_CTRL,ATALLA_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_ATALLA_LIBNAME((const char *)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nATALLAerr(ATALLA_F_ATALLA_CTRL,ATALLA_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int atalla_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *modulus;\\r\\nBIGNUM *exponent;\\r\\nBIGNUM *argument;\\r\\nBIGNUM *result;\\r\\nRSAPrivateKey keydata;\\r\\nint to_return, numbytes;\\r\\nmodulus = exponent = argument = result = NULL;\\r\\nto_return = 0;\\r\\nif(!atalla_dso)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_MOD_EXP,ATALLA_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nmodulus = BN_CTX_get(ctx);\\r\\nexponent = BN_CTX_get(ctx);\\r\\nargument = BN_CTX_get(ctx);\\r\\nresult = BN_CTX_get(ctx);\\r\\nif (!result)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_MOD_EXP,ATALLA_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(modulus, m->top) || !bn_wexpand(exponent, m->top) ||\\r\\n!bn_wexpand(argument, m->top) || !bn_wexpand(result, m->top))\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_MOD_EXP,ATALLA_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nmemset(&keydata, 0,sizeof keydata);\\r\\nnumbytes = BN_num_bytes(m);\\r\\nmemset(exponent->d, 0, numbytes);\\r\\nmemset(modulus->d, 0, numbytes);\\r\\nBN_bn2bin(p, (unsigned char *)exponent->d + numbytes - BN_num_bytes(p));\\r\\nBN_bn2bin(m, (unsigned char *)modulus->d + numbytes - BN_num_bytes(m));\\r\\nkeydata.privateExponent.data = (unsigned char *)exponent->d;\\r\\nkeydata.privateExponent.len = numbytes;\\r\\nkeydata.modulus.data = (unsigned char *)modulus->d;\\r\\nkeydata.modulus.len = numbytes;\\r\\nmemset(argument->d, 0, numbytes);\\r\\nmemset(result->d, 0, numbytes);\\r\\nBN_bn2bin(a, (unsigned char *)argument->d + numbytes - BN_num_bytes(a));\\r\\nif(p_Atalla_RSAPrivateKeyOpFn(&keydata, (unsigned char *)result->d,\\r\\n(unsigned char *)argument->d,\\r\\nkeydata.modulus.len) != 0)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_MOD_EXP,ATALLA_R_REQUEST_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nBN_bin2bn((unsigned char *)result->d, numbytes, r);\\r\\nto_return = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int atalla_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint to_return = 0;\\r\\nif(!atalla_dso)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_RSA_MOD_EXP,ATALLA_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif(!rsa->d || !rsa->n)\\r\\n{\\r\\nATALLAerr(ATALLA_F_ATALLA_RSA_MOD_EXP,ATALLA_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nto_return = atalla_mod_exp(r0, I, rsa->d, rsa->n, ctx);\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int atalla_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!atalla_mod_exp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!atalla_mod_exp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int atalla_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn atalla_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int atalla_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn atalla_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int atalla_mod_exp_dh(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn atalla_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_atalla_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_enum_c", "target": 0, "func": "char *i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *method,\\r\\nASN1_ENUMERATED *e)\\r\\n{\\r\\nENUMERATED_NAMES *enam;\\r\\nlong strval;\\r\\nstrval = ASN1_ENUMERATED_get(e);\\r\\nfor(enam = method->usr_data; enam->lname; enam++) {\\r\\nif(strval == enam->bitnum) return BUF_strdup(enam->lname);\\r\\n}\\r\\nreturn i2s_ASN1_ENUMERATED(method, e);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ui_util_c", "target": 0, "func": "int UI_UTIL_read_pw_string(char *buf,int length,const char *prompt,int verify)\\r\\n{\\r\\nchar buff[BUFSIZ];\\r\\nint ret;\\r\\nret=UI_UTIL_read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);\\r\\nOPENSSL_cleanse(buff,BUFSIZ);\\r\\nreturn(ret);\\r\\n}\\r\\nint UI_UTIL_read_pw(char *buf,char *buff,int size,const char *prompt,int verify)\\r\\n{\\r\\nint ok = 0;\\r\\nUI *ui;\\r\\nif (size < 1)\\r\\nreturn -1;\\r\\nui = UI_new();\\r\\nif (ui)\\r\\n{\\r\\nok = UI_add_input_string(ui,prompt,0,buf,0,size-1);\\r\\nif (ok >= 0 && verify)\\r\\nok = UI_add_verify_string(ui,prompt,0,buff,0,size-1,\\r\\nbuf);\\r\\nif (ok >= 0)\\r\\nok=UI_process(ui);\\r\\nUI_free(ui);\\r\\n}\\r\\nif (ok > 0)\\r\\nok = 0;\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_cfb_c", "target": 0, "func": "void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc) {\\r\\nunsigned int n;\\r\\nunsigned long l = length;\\r\\nunsigned char c;\\r\\nassert(in && out && key && ivec && num);\\r\\nn = *num;\\r\\nif (enc) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nAES_encrypt(ivec, ivec, key);\\r\\n}\\r\\nivec[n] = *(out++) = *(in++) ^ ivec[n];\\r\\nn = (n+1) % AES_BLOCK_SIZE;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nAES_encrypt(ivec, ivec, key);\\r\\n}\\r\\nc = *(in);\\r\\n*(out++) = *(in++) ^ ivec[n];\\r\\nivec[n] = c;\\r\\nn = (n+1) % AES_BLOCK_SIZE;\\r\\n}\\r\\n}\\r\\n*num=n;\\r\\n}\\r\\nvoid AES_cfbr_encrypt_block(const unsigned char *in,unsigned char *out,\\r\\nconst int nbits,const AES_KEY *key,\\r\\nunsigned char *ivec,const int enc)\\r\\n{\\r\\nint n,rem,num;\\r\\nunsigned char ovec[AES_BLOCK_SIZE*2];\\r\\nif (nbits<=0 || nbits>128) return;\\r\\nmemcpy(ovec,ivec,AES_BLOCK_SIZE);\\r\\nAES_encrypt(ivec,ivec,key);\\r\\nnum = (nbits+7)/8;\\r\\nif (enc)\\r\\nfor(n=0 ; n < num ; ++n)\\r\\nout[n] = (ovec[AES_BLOCK_SIZE+n] = in[n] ^ ivec[n]);\\r\\nelse\\r\\nfor(n=0 ; n < num ; ++n)\\r\\nout[n] = (ovec[AES_BLOCK_SIZE+n] = in[n]) ^ ivec[n];\\r\\nrem = nbits%8;\\r\\nnum = nbits/8;\\r\\nif(rem==0)\\r\\nmemcpy(ivec,ovec+num,AES_BLOCK_SIZE);\\r\\nelse\\r\\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\\r\\nivec[n] = ovec[n+num]<<rem | ovec[n+num+1]>>(8-rem);\\r\\n}\\r\\nvoid AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nunsigned int n;\\r\\nunsigned char c[1],d[1];\\r\\nassert(in && out && key && ivec && num);\\r\\nassert(*num == 0);\\r\\nmemset(out,0,(length+7)/8);\\r\\nfor(n=0 ; n < length ; ++n)\\r\\n{\\r\\nc[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;\\r\\nAES_cfbr_encrypt_block(c,d,1,key,ivec,enc);\\r\\nout[n/8]=(out[n/8]&~(1 << (7-n%8)))|((d[0]&0x80) >> (n%8));\\r\\n}\\r\\n}\\r\\nvoid AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nunsigned int n;\\r\\nassert(in && out && key && ivec && num);\\r\\nassert(*num == 0);\\r\\nfor(n=0 ; n < length ; ++n)\\r\\nAES_cfbr_encrypt_block(&in[n],&out[n],8,key,ivec,enc);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rpw_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nDES_cblock k,k1;\\r\\nint i;\\r\\nprintf(\"read passwd\\n\");\\r\\nif ((i=des_read_password(&k,\"Enter password:\",0)) == 0)\\r\\n{\\r\\nprintf(\"password = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k[i]);\\r\\n}\\r\\nelse\\r\\nprintf(\"error %d\\n\",i);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"read 2passwds and verify\\n\");\\r\\nif ((i=des_read_2passwords(&k,&k1,\\r\\n\"Enter verified password:\",1)) == 0)\\r\\n{\\r\\nprintf(\"password1 = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k[i]);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"password2 = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k1[i]);\\r\\nprintf(\"\\n\");\\r\\nexit(1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"error %d\\n\",i);\\r\\nexit(0);\\r\\n}\\r\\n#ifdef LINT\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn1_err_c", "target": 0, "func": "void ERR_load_ASN1_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,ASN1_str_functs);\\r\\nERR_load_strings(0,ASN1_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_lu_c", "target": 0, "func": "X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)\\r\\n{\\r\\nX509_LOOKUP *ret;\\r\\nret=(X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));\\r\\nif (ret == NULL) return NULL;\\r\\nret->init=0;\\r\\nret->skip=0;\\r\\nret->method=method;\\r\\nret->method_data=NULL;\\r\\nret->store_ctx=NULL;\\r\\nif ((method->new_item != NULL) && !method->new_item(ret))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid X509_LOOKUP_free(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx == NULL) return;\\r\\nif ( (ctx->method != NULL) &&\\r\\n(ctx->method->free != NULL))\\r\\nctx->method->free(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint X509_LOOKUP_init(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL) return 0;\\r\\nif (ctx->method->init != NULL)\\r\\nreturn ctx->method->init(ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_shutdown(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL) return 0;\\r\\nif (ctx->method->shutdown != NULL)\\r\\nreturn ctx->method->shutdown(ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,\\r\\nchar **ret)\\r\\n{\\r\\nif (ctx->method == NULL) return -1;\\r\\nif (ctx->method->ctrl != NULL)\\r\\nreturn ctx->method->ctrl(ctx,cmd,argc,argl,ret);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_subject == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nif (ctx->skip) return 0;\\r\\nreturn ctx->method->get_by_subject(ctx,type,name,ret);\\r\\n}\\r\\nint X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nASN1_INTEGER *serial, X509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) ||\\r\\n(ctx->method->get_by_issuer_serial == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret);\\r\\n}\\r\\nint X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,\\r\\nunsigned char *bytes, int len, X509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_fingerprint == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret);\\r\\n}\\r\\nint X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_alias == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_alias(ctx,type,str,len,ret);\\r\\n}\\r\\nstatic int x509_object_cmp(const X509_OBJECT * const *a, const X509_OBJECT * const *b)\\r\\n{\\r\\nint ret;\\r\\nret=((*a)->type - (*b)->type);\\r\\nif (ret) return ret;\\r\\nswitch ((*a)->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nret=X509_subject_name_cmp((*a)->data.x509,(*b)->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nret=X509_CRL_cmp((*a)->data.crl,(*b)->data.crl);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_STORE *X509_STORE_new(void)\\r\\n{\\r\\nX509_STORE *ret;\\r\\nif ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)\\r\\nreturn NULL;\\r\\nret->objs = sk_X509_OBJECT_new(x509_object_cmp);\\r\\nret->cache=1;\\r\\nret->get_cert_methods=sk_X509_LOOKUP_new_null();\\r\\nret->verify=0;\\r\\nret->verify_cb=0;\\r\\nif ((ret->param = X509_VERIFY_PARAM_new()) == NULL)\\r\\nreturn NULL;\\r\\nret->get_issuer = 0;\\r\\nret->check_issued = 0;\\r\\nret->check_revocation = 0;\\r\\nret->get_crl = 0;\\r\\nret->check_crl = 0;\\r\\nret->cert_crl = 0;\\r\\nret->cleanup = 0;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data);\\r\\nret->references=1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void cleanup(X509_OBJECT *a)\\r\\n{\\r\\nif (a->type == X509_LU_X509)\\r\\n{\\r\\nX509_free(a->data.x509);\\r\\n}\\r\\nelse if (a->type == X509_LU_CRL)\\r\\n{\\r\\nX509_CRL_free(a->data.crl);\\r\\n}\\r\\nelse\\r\\n{\\r\\n}\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid X509_STORE_free(X509_STORE *vfy)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nif (vfy == NULL)\\r\\nreturn;\\r\\nsk=vfy->get_cert_methods;\\r\\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(sk,i);\\r\\nX509_LOOKUP_shutdown(lu);\\r\\nX509_LOOKUP_free(lu);\\r\\n}\\r\\nsk_X509_LOOKUP_free(sk);\\r\\nsk_X509_OBJECT_pop_free(vfy->objs, cleanup);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);\\r\\nif (vfy->param)\\r\\nX509_VERIFY_PARAM_free(vfy->param);\\r\\nOPENSSL_free(vfy);\\r\\n}\\r\\nX509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nsk=v->get_cert_methods;\\r\\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(sk,i);\\r\\nif (m == lu->method)\\r\\n{\\r\\nreturn lu;\\r\\n}\\r\\n}\\r\\nlu=X509_LOOKUP_new(m);\\r\\nif (lu == NULL)\\r\\nreturn NULL;\\r\\nelse\\r\\n{\\r\\nlu->store_ctx=v;\\r\\nif (sk_X509_LOOKUP_push(v->get_cert_methods,lu))\\r\\nreturn lu;\\r\\nelse\\r\\n{\\r\\nX509_LOOKUP_free(lu);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n}\\r\\nint X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nX509_STORE *ctx=vs->ctx;\\r\\nX509_LOOKUP *lu;\\r\\nX509_OBJECT stmp,*tmp;\\r\\nint i,j;\\r\\ntmp=X509_OBJECT_retrieve_by_subject(ctx->objs,type,name);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nfor (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);\\r\\nj=X509_LOOKUP_by_subject(lu,type,name,&stmp);\\r\\nif (j < 0)\\r\\n{\\r\\nvs->current_method=j;\\r\\nreturn j;\\r\\n}\\r\\nelse if (j)\\r\\n{\\r\\ntmp= &stmp;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvs->current_method=0;\\r\\nif (tmp == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nret->type=tmp->type;\\r\\nret->data.ptr=tmp->data.ptr;\\r\\nX509_OBJECT_up_ref_count(ret);\\r\\nreturn 1;\\r\\n}\\r\\nint X509_STORE_add_cert(X509_STORE *ctx, X509 *x)\\r\\n{\\r\\nX509_OBJECT *obj;\\r\\nint ret=1;\\r\\nif (x == NULL) return 0;\\r\\nobj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobj->type=X509_LU_X509;\\r\\nobj->data.x509=x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nif (X509_OBJECT_retrieve_match(ctx->objs, obj))\\r\\n{\\r\\nX509_OBJECT_free_contents(obj);\\r\\nOPENSSL_free(obj);\\r\\nX509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret=0;\\r\\n}\\r\\nelse sk_X509_OBJECT_push(ctx->objs, obj);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)\\r\\n{\\r\\nX509_OBJECT *obj;\\r\\nint ret=1;\\r\\nif (x == NULL) return 0;\\r\\nobj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobj->type=X509_LU_CRL;\\r\\nobj->data.crl=x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nif (X509_OBJECT_retrieve_match(ctx->objs, obj))\\r\\n{\\r\\nX509_OBJECT_free_contents(obj);\\r\\nOPENSSL_free(obj);\\r\\nX509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret=0;\\r\\n}\\r\\nelse sk_X509_OBJECT_push(ctx->objs, obj);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn ret;\\r\\n}\\r\\nvoid X509_OBJECT_up_ref_count(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nCRYPTO_add(&a->data.x509->references,1,CRYPTO_LOCK_X509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nCRYPTO_add(&a->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid X509_OBJECT_free_contents(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nX509_free(a->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nX509_CRL_free(a->data.crl);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\nX509_NAME *xn;\\r\\nX509_OBJECT obj, *pobj;\\r\\nint i, ok, idx;\\r\\nxn=X509_get_issuer_name(x);\\r\\nok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);\\r\\nif (ok != X509_LU_X509)\\r\\n{\\r\\nif (ok == X509_LU_RETRY)\\r\\n{\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nX509err(X509_F_X509_STORE_CTX_GET1_ISSUER,X509_R_SHOULD_RETRY);\\r\\nreturn -1;\\r\\n}\\r\\nelse if (ok != X509_LU_FAIL)\\r\\n{\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->check_issued(ctx, x, obj.data.x509))\\r\\n{\\r\\n*issuer = obj.data.x509;\\r\\nreturn 1;\\r\\n}\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nidx = X509_OBJECT_idx_by_subject(ctx->ctx->objs, X509_LU_X509, xn);\\r\\nif (idx == -1) return 0;\\r\\nfor (i = idx; i < sk_X509_OBJECT_num(ctx->ctx->objs); i++)\\r\\n{\\r\\npobj = sk_X509_OBJECT_value(ctx->ctx->objs, i);\\r\\nif (pobj->type != X509_LU_X509) return 0;\\r\\nif (X509_NAME_cmp(xn, X509_get_subject_name(pobj->data.x509))) return 0;\\r\\nif (ctx->check_issued(ctx, x, pobj->data.x509))\\r\\n{\\r\\n*issuer = pobj->data.x509;\\r\\nX509_OBJECT_up_ref_count(pobj);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_flags(ctx->param, flags);\\r\\n}\\r\\nint X509_STORE_set_depth(X509_STORE *ctx, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\nreturn 1;\\r\\n}\\r\\nint X509_STORE_set_purpose(X509_STORE *ctx, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(ctx->param, purpose);\\r\\n}\\r\\nint X509_STORE_set_trust(X509_STORE *ctx, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(ctx->param, trust);\\r\\n}\\r\\nint X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set1(ctx->param, param);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_md_c", "target": 0, "func": "BIO_METHOD *BIO_f_md(void)\\r\\n{\\r\\nreturn(&methods_md);\\r\\n}\\r\\nstatic int md_new(BIO *bi)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nctx=EVP_MD_CTX_create();\\r\\nif (ctx == NULL) return(0);\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int md_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nEVP_MD_CTX_destroy(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int md_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (b->init)\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,(unsigned char *)out,\\r\\n(unsigned int)ret);\\r\\n}\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int md_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx=b->ptr;\\r\\nif ((ctx != NULL) && (b->next_bio != NULL))\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nif (b->init)\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,(const unsigned char *)in,\\r\\n(unsigned int)ret);\\r\\n}\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long md_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nEVP_MD_CTX *ctx,*dctx,**pctx;\\r\\nconst EVP_MD **ppmd;\\r\\nEVP_MD *md;\\r\\nlong ret=1;\\r\\nBIO *dbio;\\r\\nctx=b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->init)\\r\\nret = EVP_DigestInit_ex(ctx,ctx->digest, NULL);\\r\\nelse\\r\\nret=0;\\r\\nif (ret > 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init)\\r\\n{\\r\\nppmd=ptr;\\r\\n*ppmd=ctx->digest;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD_CTX:\\r\\nif (b->init)\\r\\n{\\r\\npctx=ptr;\\r\\n*pctx=ctx;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd=ptr;\\r\\nret = EVP_DigestInit_ex(ctx,md, NULL);\\r\\nif (ret > 0)\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=ptr;\\r\\ndctx=dbio->ptr;\\r\\nEVP_MD_CTX_copy_ex(dctx,ctx);\\r\\nb->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long md_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int md_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nunsigned int ret;\\r\\nctx=bp->ptr;\\r\\nif (size < ctx->digest->md_size)\\r\\nreturn(0);\\r\\nEVP_DigestFinal_ex(ctx,(unsigned char *)buf,&ret);\\r\\nreturn((int)ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_pkey_c", "target": 0, "func": "int i2d_X509_PKEY(X509_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nX509_PKEY *d2i_X509_PKEY(X509_PKEY **a, const unsigned char **pp, long length)\\r\\n{\\r\\nint i;\\r\\nM_ASN1_D2I_vars(a,X509_PKEY *,X509_PKEY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_x(X509_ALGOR,ret->enc_algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING,ret->enc_pkey,d2i_ASN1_OCTET_STRING);\\r\\nret->cipher.cipher=EVP_get_cipherbyname(\\r\\nOBJ_nid2ln(OBJ_obj2nid(ret->enc_algor->algorithm)));\\r\\nif (ret->cipher.cipher == NULL)\\r\\n{\\r\\nc.error=ASN1_R_UNSUPPORTED_CIPHER;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nif (ret->enc_algor->parameter->type == V_ASN1_OCTET_STRING)\\r\\n{\\r\\ni=ret->enc_algor->parameter->value.octet_string->length;\\r\\nif (i > EVP_MAX_IV_LENGTH)\\r\\n{\\r\\nc.error=ASN1_R_IV_TOO_LARGE;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(ret->cipher.iv,\\r\\nret->enc_algor->parameter->value.octet_string->data,i);\\r\\n}\\r\\nelse\\r\\nmemset(ret->cipher.iv,0,EVP_MAX_IV_LENGTH);\\r\\nM_ASN1_D2I_Finish(a,X509_PKEY_free,ASN1_F_D2I_X509_PKEY);\\r\\n}\\r\\nX509_PKEY *X509_PKEY_new(void)\\r\\n{\\r\\nX509_PKEY *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_PKEY);\\r\\nret->version=0;\\r\\nM_ASN1_New(ret->enc_algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->enc_pkey,M_ASN1_OCTET_STRING_new);\\r\\nret->dec_pkey=NULL;\\r\\nret->key_length=0;\\r\\nret->key_data=NULL;\\r\\nret->key_free=0;\\r\\nret->cipher.cipher=NULL;\\r\\nmemset(ret->cipher.iv,0,EVP_MAX_IV_LENGTH);\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_PKEY_NEW);\\r\\n}\\r\\nvoid X509_PKEY_free(X509_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_PKEY\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->enc_algor != NULL) X509_ALGOR_free(x->enc_algor);\\r\\nif (x->enc_pkey != NULL) M_ASN1_OCTET_STRING_free(x->enc_pkey);\\r\\nif (x->dec_pkey != NULL)EVP_PKEY_free(x->dec_pkey);\\r\\nif ((x->key_data != NULL) && (x->key_free)) OPENSSL_free(x->key_data);\\r\\nOPENSSL_free(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_utl_c", "target": 0, "func": "int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint *sel = offset2ptr(*pval, it->utype);\\r\\nreturn *sel;\\r\\n}\\r\\nint asn1_set_choice_selector(ASN1_VALUE **pval, int value, const ASN1_ITEM *it)\\r\\n{\\r\\nint *sel, ret;\\r\\nsel = offset2ptr(*pval, it->utype);\\r\\nret = *sel;\\r\\n*sel = value;\\r\\nreturn ret;\\r\\n}\\r\\nint asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_AUX *aux;\\r\\nint *lck, ret;\\r\\nif ((it->itype != ASN1_ITYPE_SEQUENCE)\\r\\n&& (it->itype != ASN1_ITYPE_NDEF_SEQUENCE))\\r\\nreturn 0;\\r\\naux = it->funcs;\\r\\nif (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT))\\r\\nreturn 0;\\r\\nlck = offset2ptr(*pval, aux->ref_offset);\\r\\nif (op == 0)\\r\\n{\\r\\n*lck = 1;\\r\\nreturn 1;\\r\\n}\\r\\nret = CRYPTO_add(lck, op, aux->ref_lock);\\r\\n#ifdef REF_PRINT\\r\\nfprintf(stderr, \"%s: Reference Count: %d\\n\", it->sname, *lck);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (ret < 0)\\r\\nfprintf(stderr, \"%s, bad reference count\\n\", it->sname);\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nstatic ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_AUX *aux;\\r\\nif (!pval || !*pval)\\r\\nreturn NULL;\\r\\naux = it->funcs;\\r\\nif (!aux || !(aux->flags & ASN1_AFLG_ENCODING))\\r\\nreturn NULL;\\r\\nreturn offset2ptr(*pval, aux->enc_offset);\\r\\n}\\r\\nvoid asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (enc)\\r\\n{\\r\\nenc->enc = NULL;\\r\\nenc->len = 0;\\r\\nenc->modified = 1;\\r\\n}\\r\\n}\\r\\nvoid asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (enc)\\r\\n{\\r\\nif (enc->enc)\\r\\nOPENSSL_free(enc->enc);\\r\\nenc->enc = NULL;\\r\\nenc->len = 0;\\r\\nenc->modified = 1;\\r\\n}\\r\\n}\\r\\nint asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (!enc)\\r\\nreturn 1;\\r\\nif (enc->enc)\\r\\nOPENSSL_free(enc->enc);\\r\\nenc->enc = OPENSSL_malloc(inlen);\\r\\nif (!enc->enc)\\r\\nreturn 0;\\r\\nmemcpy(enc->enc, in, inlen);\\r\\nenc->len = inlen;\\r\\nenc->modified = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (!enc || enc->modified)\\r\\nreturn 0;\\r\\nif (out)\\r\\n{\\r\\nmemcpy(*out, enc->enc, enc->len);\\r\\n*out += enc->len;\\r\\n}\\r\\nif (len)\\r\\n*len = enc->len;\\r\\nreturn 1;\\r\\n}\\r\\nASN1_VALUE ** asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nASN1_VALUE **pvaltmp;\\r\\nif (tt->flags & ASN1_TFLG_COMBINE)\\r\\nreturn pval;\\r\\npvaltmp = offset2ptr(*pval, tt->offset);\\r\\nreturn pvaltmp;\\r\\n}\\r\\nconst ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,\\r\\nint nullerr)\\r\\n{\\r\\nconst ASN1_ADB *adb;\\r\\nconst ASN1_ADB_TABLE *atbl;\\r\\nlong selector;\\r\\nASN1_VALUE **sfld;\\r\\nint i;\\r\\nif (!(tt->flags & ASN1_TFLG_ADB_MASK))\\r\\nreturn tt;\\r\\nadb = ASN1_ADB_ptr(tt->item);\\r\\nsfld = offset2ptr(*pval, adb->offset);\\r\\nif (!sfld)\\r\\n{\\r\\nif (!adb->null_tt)\\r\\ngoto err;\\r\\nreturn adb->null_tt;\\r\\n}\\r\\nif (tt->flags & ASN1_TFLG_ADB_OID)\\r\\nselector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);\\r\\nelse\\r\\nselector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);\\r\\nfor (atbl = adb->tbl, i = 0; i < adb->tblcount; i++, atbl++)\\r\\nif (atbl->value == selector)\\r\\nreturn &atbl->tt;\\r\\nif (!adb->default_tt)\\r\\ngoto err;\\r\\nreturn adb->default_tt;\\r\\nerr:\\r\\nif (nullerr)\\r\\nASN1err(ASN1_F_ASN1_DO_ADB,\\r\\nASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_sha_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return SHA_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_sha(void)\\r\\n{\\r\\nreturn(&sha_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_state_machine_c", "target": 0, "func": "void SSLStateMachine_print_error(SSLStateMachine *pMachine,const char *szErr)\\r\\n{\\r\\nunsigned long l;\\r\\nfprintf(stderr,\"%s\\n\",szErr);\\r\\nwhile((l=ERR_get_error()))\\r\\n{\\r\\nchar buf[1024];\\r\\nERR_error_string_n(l,buf,sizeof buf);\\r\\nfprintf(stderr,\"Error %lx: %s\\n\",l,buf);\\r\\n}\\r\\n}\\r\\nSSLStateMachine *SSLStateMachine_new(const char *szCertificateFile,\\r\\nconst char *szKeyFile)\\r\\n{\\r\\nSSLStateMachine *pMachine=malloc(sizeof *pMachine);\\r\\nint n;\\r\\ndie_unless(pMachine);\\r\\npMachine->pCtx=SSL_CTX_new(SSLv23_server_method());\\r\\ndie_unless(pMachine->pCtx);\\r\\nn=SSL_CTX_use_certificate_file(pMachine->pCtx,szCertificateFile,\\r\\nSSL_FILETYPE_PEM);\\r\\ndie_unless(n > 0);\\r\\nn=SSL_CTX_use_PrivateKey_file(pMachine->pCtx,szKeyFile,SSL_FILETYPE_PEM);\\r\\ndie_unless(n > 0);\\r\\npMachine->pSSL=SSL_new(pMachine->pCtx);\\r\\ndie_unless(pMachine->pSSL);\\r\\npMachine->pbioRead=BIO_new(BIO_s_mem());\\r\\npMachine->pbioWrite=BIO_new(BIO_s_mem());\\r\\nSSL_set_bio(pMachine->pSSL,pMachine->pbioRead,pMachine->pbioWrite);\\r\\nSSL_set_accept_state(pMachine->pSSL);\\r\\nreturn pMachine;\\r\\n}\\r\\nvoid SSLStateMachine_read_inject(SSLStateMachine *pMachine,\\r\\nconst unsigned char *aucBuf,int nBuf)\\r\\n{\\r\\nint n=BIO_write(pMachine->pbioRead,aucBuf,nBuf);\\r\\nassert(n == nBuf);\\r\\nfprintf(stderr,\"%d bytes of encrypted data fed to state machine\\n\",n);\\r\\n}\\r\\nint SSLStateMachine_read_extract(SSLStateMachine *pMachine,\\r\\nunsigned char *aucBuf,int nBuf)\\r\\n{\\r\\nint n;\\r\\nif(!SSL_is_init_finished(pMachine->pSSL))\\r\\n{\\r\\nfprintf(stderr,\"Doing SSL_accept\\n\");\\r\\nn=SSL_accept(pMachine->pSSL);\\r\\nif(n == 0)\\r\\nfprintf(stderr,\"SSL_accept returned zero\\n\");\\r\\nif(n < 0)\\r\\n{\\r\\nint err;\\r\\nif((err=SSL_get_error(pMachine->pSSL,n)) == SSL_ERROR_WANT_READ)\\r\\n{\\r\\nfprintf(stderr,\"SSL_accept wants more data\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nSSLStateMachine_print_error(pMachine,\"SSL_accept error\");\\r\\nexit(7);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nn=SSL_read(pMachine->pSSL,aucBuf,nBuf);\\r\\nif(n < 0)\\r\\n{\\r\\nint err=SSL_get_error(pMachine->pSSL,n);\\r\\nif(err == SSL_ERROR_WANT_READ)\\r\\n{\\r\\nfprintf(stderr,\"SSL_read wants more data\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nSSLStateMachine_print_error(pMachine,\"SSL_read error\");\\r\\nexit(8);\\r\\n}\\r\\nfprintf(stderr,\"%d bytes of decrypted data read from state machine\\n\",n);\\r\\nreturn n;\\r\\n}\\r\\nint SSLStateMachine_write_can_extract(SSLStateMachine *pMachine)\\r\\n{\\r\\nint n=BIO_pending(pMachine->pbioWrite);\\r\\nif(n)\\r\\nfprintf(stderr,\"There is encrypted data available to write\\n\");\\r\\nelse\\r\\nfprintf(stderr,\"There is no encrypted data available to write\\n\");\\r\\nreturn n;\\r\\n}\\r\\nint SSLStateMachine_write_extract(SSLStateMachine *pMachine,\\r\\nunsigned char *aucBuf,int nBuf)\\r\\n{\\r\\nint n;\\r\\nn=BIO_read(pMachine->pbioWrite,aucBuf,nBuf);\\r\\nfprintf(stderr,\"%d bytes of encrypted data read from state machine\\n\",n);\\r\\nreturn n;\\r\\n}\\r\\nvoid SSLStateMachine_write_inject(SSLStateMachine *pMachine,\\r\\nconst unsigned char *aucBuf,int nBuf)\\r\\n{\\r\\nint n=SSL_write(pMachine->pSSL,aucBuf,nBuf);\\r\\nassert(n == nBuf);\\r\\nfprintf(stderr,\"%d bytes of unencrypted data fed to state machine\\n\",n);\\r\\n}\\r\\nint OpenSocket(int nPort)\\r\\n{\\r\\nint nSocket;\\r\\nstruct sockaddr_in saServer;\\r\\nstruct sockaddr_in saClient;\\r\\nint one=1;\\r\\nint nSize;\\r\\nint nFD;\\r\\nint nLen;\\r\\nnSocket=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\\r\\nif(nSocket < 0)\\r\\n{\\r\\nperror(\"socket\");\\r\\nexit(1);\\r\\n}\\r\\nif(setsockopt(nSocket,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof one) < 0)\\r\\n{\\r\\nperror(\"setsockopt\");\\r\\nexit(2);\\r\\n}\\r\\nmemset(&saServer,0,sizeof saServer);\\r\\nsaServer.sin_family=AF_INET;\\r\\nsaServer.sin_port=htons(nPort);\\r\\nnSize=sizeof saServer;\\r\\nif(bind(nSocket,(struct sockaddr *)&saServer,nSize) < 0)\\r\\n{\\r\\nperror(\"bind\");\\r\\nexit(3);\\r\\n}\\r\\nif(listen(nSocket,512) < 0)\\r\\n{\\r\\nperror(\"listen\");\\r\\nexit(4);\\r\\n}\\r\\nnLen=sizeof saClient;\\r\\nnFD=accept(nSocket,(struct sockaddr *)&saClient,&nLen);\\r\\nif(nFD < 0)\\r\\n{\\r\\nperror(\"accept\");\\r\\nexit(5);\\r\\n}\\r\\nfprintf(stderr,\"Incoming accepted on port %d\\n\",nPort);\\r\\nreturn nFD;\\r\\n}\\r\\nint main(int argc,char **argv)\\r\\n{\\r\\nSSLStateMachine *pMachine;\\r\\nint nPort;\\r\\nint nFD;\\r\\nconst char *szCertificateFile;\\r\\nconst char *szKeyFile;\\r\\nchar rbuf[1];\\r\\nint nrbuf=0;\\r\\nif(argc != 4)\\r\\n{\\r\\nfprintf(stderr,\"%s <port> <certificate file> <key file>\\n\",argv[0]);\\r\\nexit(6);\\r\\n}\\r\\nnPort=atoi(argv[1]);\\r\\nszCertificateFile=argv[2];\\r\\nszKeyFile=argv[3];\\r\\nSSL_library_init();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nSSL_load_error_strings();\\r\\nERR_load_crypto_strings();\\r\\nnFD=OpenSocket(nPort);\\r\\npMachine=SSLStateMachine_new(szCertificateFile,szKeyFile);\\r\\nfor( ; ; )\\r\\n{\\r\\nfd_set rfds,wfds;\\r\\nunsigned char buf[1024];\\r\\nint n;\\r\\nFD_ZERO(&rfds);\\r\\nFD_ZERO(&wfds);\\r\\nFD_SET(nFD,&rfds);\\r\\nif(!nrbuf)\\r\\nnrbuf=SSLStateMachine_read_extract(pMachine,rbuf,1);\\r\\nif(nrbuf)\\r\\nFD_SET(1,&wfds);\\r\\nif(SSLStateMachine_write_can_extract(pMachine))\\r\\nFD_SET(nFD,&wfds);\\r\\nFD_SET(0,&rfds);\\r\\nn=select(nFD+1,&rfds,&wfds,NULL,NULL);\\r\\nassert(n > 0);\\r\\nif(FD_ISSET(nFD,&rfds))\\r\\n{\\r\\nn=read(nFD,buf,sizeof buf);\\r\\nif(n == 0)\\r\\n{\\r\\nfprintf(stderr,\"Got EOF on socket\\n\");\\r\\nexit(0);\\r\\n}\\r\\nassert(n > 0);\\r\\nSSLStateMachine_read_inject(pMachine,buf,n);\\r\\n}\\r\\nif(FD_ISSET(1,&wfds))\\r\\n{\\r\\nassert(nrbuf == 1);\\r\\nbuf[0]=rbuf[0];\\r\\nnrbuf=0;\\r\\nn=SSLStateMachine_read_extract(pMachine,buf+1,sizeof buf-1);\\r\\nif(n < 0)\\r\\n{\\r\\nSSLStateMachine_print_error(pMachine,\"read extract failed\");\\r\\nbreak;\\r\\n}\\r\\nassert(n >= 0);\\r\\n++n;\\r\\nif(n > 0)\\r\\n{\\r\\nint w;\\r\\nw=write(1,buf,n);\\r\\nassert(w == n);\\r\\n}\\r\\n}\\r\\nif(FD_ISSET(nFD,&wfds))\\r\\n{\\r\\nint w;\\r\\nn=SSLStateMachine_write_extract(pMachine,buf,sizeof buf);\\r\\nassert(n > 0);\\r\\nw=write(nFD,buf,n);\\r\\nassert(w == n);\\r\\n}\\r\\nif(FD_ISSET(0,&rfds))\\r\\n{\\r\\nn=read(0,buf,sizeof buf);\\r\\nif(n == 0)\\r\\n{\\r\\nfprintf(stderr,\"Got EOF on stdin\\n\");\\r\\nexit(0);\\r\\n}\\r\\nassert(n > 0);\\r\\nSSLStateMachine_write_inject(pMachine,buf,n);\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_ciph_c", "target": 0, "func": "static void load_ciphers(void)\\r\\n{\\r\\nssl_cipher_methods[SSL_ENC_DES_IDX]=\\r\\nEVP_get_cipherbyname(SN_des_cbc);\\r\\nssl_cipher_methods[SSL_ENC_3DES_IDX]=\\r\\nEVP_get_cipherbyname(SN_des_ede3_cbc);\\r\\nssl_cipher_methods[SSL_ENC_RC4_IDX]=\\r\\nEVP_get_cipherbyname(SN_rc4);\\r\\nssl_cipher_methods[SSL_ENC_RC2_IDX]=\\r\\nEVP_get_cipherbyname(SN_rc2_cbc);\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nssl_cipher_methods[SSL_ENC_IDEA_IDX]=\\r\\nEVP_get_cipherbyname(SN_idea_cbc);\\r\\n#else\\r\\nssl_cipher_methods[SSL_ENC_IDEA_IDX]= NULL;\\r\\n#endif\\r\\nssl_cipher_methods[SSL_ENC_AES128_IDX]=\\r\\nEVP_get_cipherbyname(SN_aes_128_cbc);\\r\\nssl_cipher_methods[SSL_ENC_AES256_IDX]=\\r\\nEVP_get_cipherbyname(SN_aes_256_cbc);\\r\\nssl_digest_methods[SSL_MD_MD5_IDX]=\\r\\nEVP_get_digestbyname(SN_md5);\\r\\nssl_digest_methods[SSL_MD_SHA1_IDX]=\\r\\nEVP_get_digestbyname(SN_sha1);\\r\\ninit_ciphers=0;\\r\\n}\\r\\nstatic int sk_comp_cmp(const SSL_COMP * const *a,\\r\\nconst SSL_COMP * const *b)\\r\\n{\\r\\nreturn((*a)->id-(*b)->id);\\r\\n}\\r\\nstatic void load_builtin_compressions(void)\\r\\n{\\r\\nif (ssl_comp_methods != NULL)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nif (ssl_comp_methods == NULL)\\r\\n{\\r\\nSSL_COMP *comp = NULL;\\r\\nMemCheck_off();\\r\\nssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);\\r\\nif (ssl_comp_methods != NULL)\\r\\n{\\r\\ncomp=(SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));\\r\\nif (comp != NULL)\\r\\n{\\r\\ncomp->method=COMP_zlib();\\r\\nif (comp->method\\r\\n&& comp->method->type == NID_undef)\\r\\nOPENSSL_free(comp);\\r\\nelse\\r\\n{\\r\\ncomp->id=SSL_COMP_ZLIB_IDX;\\r\\ncomp->name=comp->method->name;\\r\\nsk_SSL_COMP_push(ssl_comp_methods,comp);\\r\\n}\\r\\n}\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\n}\\r\\nint ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,\\r\\nconst EVP_MD **md, SSL_COMP **comp)\\r\\n{\\r\\nint i;\\r\\nSSL_CIPHER *c;\\r\\nc=s->cipher;\\r\\nif (c == NULL) return(0);\\r\\nif (comp != NULL)\\r\\n{\\r\\nSSL_COMP ctmp;\\r\\nload_builtin_compressions();\\r\\n*comp=NULL;\\r\\nctmp.id=s->compress_meth;\\r\\nif (ssl_comp_methods != NULL)\\r\\n{\\r\\ni=sk_SSL_COMP_find(ssl_comp_methods,&ctmp);\\r\\nif (i >= 0)\\r\\n*comp=sk_SSL_COMP_value(ssl_comp_methods,i);\\r\\nelse\\r\\n*comp=NULL;\\r\\n}\\r\\n}\\r\\nif ((enc == NULL) || (md == NULL)) return(0);\\r\\nswitch (c->algorithms & SSL_ENC_MASK)\\r\\n{\\r\\ncase SSL_DES:\\r\\ni=SSL_ENC_DES_IDX;\\r\\nbreak;\\r\\ncase SSL_3DES:\\r\\ni=SSL_ENC_3DES_IDX;\\r\\nbreak;\\r\\ncase SSL_RC4:\\r\\ni=SSL_ENC_RC4_IDX;\\r\\nbreak;\\r\\ncase SSL_RC2:\\r\\ni=SSL_ENC_RC2_IDX;\\r\\nbreak;\\r\\ncase SSL_IDEA:\\r\\ni=SSL_ENC_IDEA_IDX;\\r\\nbreak;\\r\\ncase SSL_eNULL:\\r\\ni=SSL_ENC_NULL_IDX;\\r\\nbreak;\\r\\ncase SSL_AES:\\r\\nswitch(c->alg_bits)\\r\\n{\\r\\ncase 128: i=SSL_ENC_AES128_IDX; break;\\r\\ncase 256: i=SSL_ENC_AES256_IDX; break;\\r\\ndefault: i=-1; break;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\ni= -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i > SSL_ENC_NUM_IDX))\\r\\n*enc=NULL;\\r\\nelse\\r\\n{\\r\\nif (i == SSL_ENC_NULL_IDX)\\r\\n*enc=EVP_enc_null();\\r\\nelse\\r\\n*enc=ssl_cipher_methods[i];\\r\\n}\\r\\nswitch (c->algorithms & SSL_MAC_MASK)\\r\\n{\\r\\ncase SSL_MD5:\\r\\ni=SSL_MD_MD5_IDX;\\r\\nbreak;\\r\\ncase SSL_SHA1:\\r\\ni=SSL_MD_SHA1_IDX;\\r\\nbreak;\\r\\ndefault:\\r\\ni= -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i > SSL_MD_NUM_IDX))\\r\\n*md=NULL;\\r\\nelse\\r\\n*md=ssl_digest_methods[i];\\r\\nif ((*enc != NULL) && (*md != NULL))\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nstatic void ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,\\r\\nCIPHER_ORDER **tail)\\r\\n{\\r\\nif (curr == *tail) return;\\r\\nif (curr == *head)\\r\\n*head=curr->next;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next=curr->next;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev=curr->prev;\\r\\n(*tail)->next=curr;\\r\\ncurr->prev= *tail;\\r\\ncurr->next=NULL;\\r\\n*tail=curr;\\r\\n}\\r\\nstatic unsigned long ssl_cipher_get_disabled(void)\\r\\n{\\r\\nunsigned long mask;\\r\\nmask = SSL_kFZA;\\r\\n#ifdef OPENSSL_NO_RSA\\r\\nmask |= SSL_aRSA|SSL_kRSA;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_DSA\\r\\nmask |= SSL_aDSS;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_DH\\r\\nmask |= SSL_kDHr|SSL_kDHd|SSL_kEDH|SSL_aDH;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_KRB5\\r\\nmask |= SSL_kKRB5|SSL_aKRB5;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_ECDH\\r\\nmask |= SSL_kECDH|SSL_kECDHE;\\r\\n#endif\\r\\n#ifdef SSL_FORBID_ENULL\\r\\nmask |= SSL_eNULL;\\r\\n#endif\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_DES_IDX ] == NULL) ? SSL_DES :0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES:0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_RC4_IDX ] == NULL) ? SSL_RC4 :0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_RC2_IDX ] == NULL) ? SSL_RC2 :0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA:0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_eFZA_IDX] == NULL) ? SSL_eFZA:0;\\r\\nmask |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES:0;\\r\\nmask |= (ssl_digest_methods[SSL_MD_MD5_IDX ] == NULL) ? SSL_MD5 :0;\\r\\nmask |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1:0;\\r\\nreturn(mask);\\r\\n}\\r\\nstatic void ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method,\\r\\nint num_of_ciphers, unsigned long mask, CIPHER_ORDER *co_list,\\r\\nCIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)\\r\\n{\\r\\nint i, co_list_num;\\r\\nSSL_CIPHER *c;\\r\\nco_list_num = 0;\\r\\nfor (i = 0; i < num_of_ciphers; i++)\\r\\n{\\r\\nc = ssl_method->get_cipher(i);\\r\\nif ((c != NULL) && c->valid && !(c->algorithms & mask))\\r\\n{\\r\\nco_list[co_list_num].cipher = c;\\r\\nco_list[co_list_num].next = NULL;\\r\\nco_list[co_list_num].prev = NULL;\\r\\nco_list[co_list_num].active = 0;\\r\\nco_list_num++;\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"\\t%d: %s %lx %lx\\n\",i,c->name,c->id,c->algorithms);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nfor (i = 1; i < co_list_num - 1; i++)\\r\\n{\\r\\nco_list[i].prev = &(co_list[i-1]);\\r\\nco_list[i].next = &(co_list[i+1]);\\r\\n}\\r\\nif (co_list_num > 0)\\r\\n{\\r\\n(*head_p) = &(co_list[0]);\\r\\n(*head_p)->prev = NULL;\\r\\n(*head_p)->next = &(co_list[1]);\\r\\n(*tail_p) = &(co_list[co_list_num - 1]);\\r\\n(*tail_p)->prev = &(co_list[co_list_num - 2]);\\r\\n(*tail_p)->next = NULL;\\r\\n}\\r\\n}\\r\\nstatic void ssl_cipher_collect_aliases(SSL_CIPHER **ca_list,\\r\\nint num_of_group_aliases, unsigned long mask,\\r\\nCIPHER_ORDER *head)\\r\\n{\\r\\nCIPHER_ORDER *ciph_curr;\\r\\nSSL_CIPHER **ca_curr;\\r\\nint i;\\r\\nciph_curr = head;\\r\\nca_curr = ca_list;\\r\\nwhile (ciph_curr != NULL)\\r\\n{\\r\\n*ca_curr = ciph_curr->cipher;\\r\\nca_curr++;\\r\\nciph_curr = ciph_curr->next;\\r\\n}\\r\\nfor (i = 0; i < num_of_group_aliases; i++)\\r\\n{\\r\\nif ((i == 0) ||\\r\\n!(cipher_aliases[i].algorithms & mask))\\r\\n{\\r\\n*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);\\r\\nca_curr++;\\r\\n}\\r\\n}\\r\\n*ca_curr = NULL;\\r\\n}\\r\\nstatic void ssl_cipher_apply_rule(unsigned long algorithms, unsigned long mask,\\r\\nunsigned long algo_strength, unsigned long mask_strength,\\r\\nint rule, int strength_bits, CIPHER_ORDER *co_list,\\r\\nCIPHER_ORDER **head_p, CIPHER_ORDER **tail_p)\\r\\n{\\r\\nCIPHER_ORDER *head, *tail, *curr, *curr2, *tail2;\\r\\nSSL_CIPHER *cp;\\r\\nunsigned long ma, ma_s;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"Applying rule %d with %08lx %08lx %08lx %08lx (%d)\\n\",\\r\\nrule, algorithms, mask, algo_strength, mask_strength,\\r\\nstrength_bits);\\r\\n#endif\\r\\ncurr = head = *head_p;\\r\\ncurr2 = head;\\r\\ntail2 = tail = *tail_p;\\r\\nfor (;;)\\r\\n{\\r\\nif ((curr == NULL) || (curr == tail2)) break;\\r\\ncurr = curr2;\\r\\ncurr2 = curr->next;\\r\\ncp = curr->cipher;\\r\\nif (strength_bits == -1)\\r\\n{\\r\\nma = mask & cp->algorithms;\\r\\nma_s = mask_strength & cp->algo_strength;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"\\nName: %s:\\nAlgo = %08lx Algo_strength = %08lx\\nMask = %08lx Mask_strength %08lx\\n\", cp->name, cp->algorithms, cp->algo_strength, mask, mask_strength);\\r\\nprintf(\"ma = %08lx ma_s %08lx, ma&algo=%08lx, ma_s&algos=%08lx\\n\", ma, ma_s, ma&algorithms, ma_s&algo_strength);\\r\\n#endif\\r\\nif (((ma == 0) && (ma_s == 0)) ||\\r\\n((ma & algorithms) != ma) ||\\r\\n((ma_s & algo_strength) != ma_s))\\r\\ncontinue;\\r\\n}\\r\\nelse if (strength_bits != cp->strength_bits)\\r\\ncontinue;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"Action = %d\\n\", rule);\\r\\n#endif\\r\\nif (rule == CIPHER_ADD)\\r\\n{\\r\\nif (!curr->active)\\r\\n{\\r\\nll_append_tail(&head, curr, &tail);\\r\\ncurr->active = 1;\\r\\n}\\r\\n}\\r\\nelse if (rule == CIPHER_ORD)\\r\\n{\\r\\nif (curr->active)\\r\\n{\\r\\nll_append_tail(&head, curr, &tail);\\r\\n}\\r\\n}\\r\\nelse if (rule == CIPHER_DEL)\\r\\ncurr->active = 0;\\r\\nelse if (rule == CIPHER_KILL)\\r\\n{\\r\\nif (head == curr)\\r\\nhead = curr->next;\\r\\nelse\\r\\ncurr->prev->next = curr->next;\\r\\nif (tail == curr)\\r\\ntail = curr->prev;\\r\\ncurr->active = 0;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev = curr->prev;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next = curr->next;\\r\\ncurr->next = NULL;\\r\\ncurr->prev = NULL;\\r\\n}\\r\\n}\\r\\n*head_p = head;\\r\\n*tail_p = tail;\\r\\n}\\r\\nstatic int ssl_cipher_strength_sort(CIPHER_ORDER *co_list,\\r\\nCIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p)\\r\\n{\\r\\nint max_strength_bits, i, *number_uses;\\r\\nCIPHER_ORDER *curr;\\r\\nmax_strength_bits = 0;\\r\\ncurr = *head_p;\\r\\nwhile (curr != NULL)\\r\\n{\\r\\nif (curr->active &&\\r\\n(curr->cipher->strength_bits > max_strength_bits))\\r\\nmax_strength_bits = curr->cipher->strength_bits;\\r\\ncurr = curr->next;\\r\\n}\\r\\nnumber_uses = OPENSSL_malloc((max_strength_bits + 1) * sizeof(int));\\r\\nif (!number_uses)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(number_uses, 0, (max_strength_bits + 1) * sizeof(int));\\r\\ncurr = *head_p;\\r\\nwhile (curr != NULL)\\r\\n{\\r\\nif (curr->active)\\r\\nnumber_uses[curr->cipher->strength_bits]++;\\r\\ncurr = curr->next;\\r\\n}\\r\\nfor (i = max_strength_bits; i >= 0; i--)\\r\\nif (number_uses[i] > 0)\\r\\nssl_cipher_apply_rule(0, 0, 0, 0, CIPHER_ORD, i,\\r\\nco_list, head_p, tail_p);\\r\\nOPENSSL_free(number_uses);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ssl_cipher_process_rulestr(const char *rule_str,\\r\\nCIPHER_ORDER *co_list, CIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p, SSL_CIPHER **ca_list)\\r\\n{\\r\\nunsigned long algorithms, mask, algo_strength, mask_strength;\\r\\nconst char *l, *start, *buf;\\r\\nint j, multi, found, rule, retval, ok, buflen;\\r\\nchar ch;\\r\\nretval = 1;\\r\\nl = rule_str;\\r\\nfor (;;)\\r\\n{\\r\\nch = *l;\\r\\nif (ch == '\\0')\\r\\nbreak;\\r\\nif (ch == '-')\\r\\n{ rule = CIPHER_DEL; l++; }\\r\\nelse if (ch == '+')\\r\\n{ rule = CIPHER_ORD; l++; }\\r\\nelse if (ch == '!')\\r\\n{ rule = CIPHER_KILL; l++; }\\r\\nelse if (ch == '@')\\r\\n{ rule = CIPHER_SPECIAL; l++; }\\r\\nelse\\r\\n{ rule = CIPHER_ADD; }\\r\\nif (ITEM_SEP(ch))\\r\\n{\\r\\nl++;\\r\\ncontinue;\\r\\n}\\r\\nalgorithms = mask = algo_strength = mask_strength = 0;\\r\\nstart=l;\\r\\nfor (;;)\\r\\n{\\r\\nch = *l;\\r\\nbuf = l;\\r\\nbuflen = 0;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nwhile ( ((ch >= 'A') && (ch <= 'Z')) ||\\r\\n((ch >= '0') && (ch <= '9')) ||\\r\\n((ch >= 'a') && (ch <= 'z')) ||\\r\\n(ch == '-'))\\r\\n#else\\r\\nwhile ( isalnum(ch) || (ch == '-'))\\r\\n#endif\\r\\n{\\r\\nch = *(++l);\\r\\nbuflen++;\\r\\n}\\r\\nif (buflen == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,\\r\\nSSL_R_INVALID_COMMAND);\\r\\nretval = found = 0;\\r\\nl++;\\r\\nbreak;\\r\\n}\\r\\nif (rule == CIPHER_SPECIAL)\\r\\n{\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\nif (ch == '+')\\r\\n{\\r\\nmulti=1;\\r\\nl++;\\r\\n}\\r\\nelse\\r\\nmulti=0;\\r\\nj = found = 0;\\r\\nwhile (ca_list[j])\\r\\n{\\r\\nif (!strncmp(buf, ca_list[j]->name, buflen) &&\\r\\n(ca_list[j]->name[buflen] == '\\0'))\\r\\n{\\r\\nfound = 1;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\nj++;\\r\\n}\\r\\nif (!found)\\r\\nbreak;\\r\\nalgorithms = (algorithms & ~ca_list[j]->mask) |\\r\\n(ca_list[j]->algorithms & ~mask) |\\r\\n(algorithms & ca_list[j]->algorithms);\\r\\nmask |= ca_list[j]->mask;\\r\\nalgo_strength = (algo_strength & ~ca_list[j]->mask_strength) |\\r\\n(ca_list[j]->algo_strength & ~mask_strength) |\\r\\n(algo_strength & ca_list[j]->algo_strength);\\r\\nmask_strength |= ca_list[j]->mask_strength;\\r\\nif (!multi) break;\\r\\n}\\r\\nif (rule == CIPHER_SPECIAL)\\r\\n{\\r\\nok = 0;\\r\\nif ((buflen == 8) &&\\r\\n!strncmp(buf, \"STRENGTH\", 8))\\r\\nok = ssl_cipher_strength_sort(co_list,\\r\\nhead_p, tail_p);\\r\\nelse\\r\\nSSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,\\r\\nSSL_R_INVALID_COMMAND);\\r\\nif (ok == 0)\\r\\nretval = 0;\\r\\nwhile ((*l != '\\0') && ITEM_SEP(*l))\\r\\nl++;\\r\\n}\\r\\nelse if (found)\\r\\n{\\r\\nssl_cipher_apply_rule(algorithms, mask,\\r\\nalgo_strength, mask_strength, rule, -1,\\r\\nco_list, head_p, tail_p);\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile ((*l != '\\0') && ITEM_SEP(*l))\\r\\nl++;\\r\\n}\\r\\nif (*l == '\\0') break;\\r\\n}\\r\\nreturn(retval);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_gendh_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nBN_GENCB cb;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nDH *dh=NULL;\\r\\nint ret=1,num=DEFBITS;\\r\\nint g=2;\\r\\nchar *outfile=NULL;\\r\\nchar *inrand=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nBIO *out=NULL;\\r\\napps_startup();\\r\\nBN_GENCB_set(&cb, dh_cb, bio_err);\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-2\") == 0)\\r\\ng=2;\\r\\nelse if (strcmp(*argv,\"-5\") == 0)\\r\\ng=5;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: gendh [args] [numbits]\\n\");\\r\\nBIO_printf(bio_err,\" -out file - output the key to 'file\\n\");\\r\\nBIO_printf(bio_err,\" -2 - use 2 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\" -5 - use 5 as the generator value\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e - use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nBIO_printf(bio_err,\"Generating DH parameters, %d bit long safe prime, generator %d\\n\",num,g);\\r\\nBIO_printf(bio_err,\"This is going to take a long time\\n\");\\r\\nif(((dh = DH_new()) == NULL) || !DH_generate_parameters_ex(dh, num, g, &cb))\\r\\ngoto end;\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (!PEM_write_bio_DHparams(out,dh))\\r\\ngoto end;\\r\\nret=0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (dh != NULL) DH_free(dh);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK dh_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write(cb->arg,&c,1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_ripemd_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return RIPEMD160_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return RIPEMD160_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return RIPEMD160_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_ripemd160(void)\\r\\n{\\r\\nreturn(&ripemd160_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mkcert_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *bio_err;\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\nbio_err=BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nmkcert(&x509,&pkey,512,0,365);\\r\\nRSA_print_fp(stdout,pkey->pkey.rsa,0);\\r\\nX509_print_fp(stdout,x509);\\r\\nPEM_write_PrivateKey(stdout,pkey,NULL,NULL,0,NULL, NULL);\\r\\nPEM_write_X509(stdout,x509);\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_cleanup();\\r\\n#endif\\r\\nCRYPTO_cleanup_all_ex_data();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nBIO_free(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void callback(int p, int n, void *arg)\\r\\n{\\r\\nchar c='B';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nfputc(c,stderr);\\r\\n}\\r\\nint mkcert(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int days)\\r\\n{\\r\\nX509 *x;\\r\\nEVP_PKEY *pk;\\r\\nRSA *rsa;\\r\\nX509_NAME *name=NULL;\\r\\nif ((pkeyp == NULL) || (*pkeyp == NULL))\\r\\n{\\r\\nif ((pk=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nabort();\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\npk= *pkeyp;\\r\\nif ((x509p == NULL) || (*x509p == NULL))\\r\\n{\\r\\nif ((x=X509_new()) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nx= *x509p;\\r\\nrsa=RSA_generate_key(bits,RSA_F4,callback,NULL);\\r\\nif (!EVP_PKEY_assign_RSA(pk,rsa))\\r\\n{\\r\\nabort();\\r\\ngoto err;\\r\\n}\\r\\nrsa=NULL;\\r\\nX509_set_version(x,2);\\r\\nASN1_INTEGER_set(X509_get_serialNumber(x),serial);\\r\\nX509_gmtime_adj(X509_get_notBefore(x),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);\\r\\nX509_set_pubkey(x,pk);\\r\\nname=X509_get_subject_name(x);\\r\\nX509_NAME_add_entry_by_txt(name,\"C\",\\r\\nMBSTRING_ASC, \"UK\", -1, -1, 0);\\r\\nX509_NAME_add_entry_by_txt(name,\"CN\",\\r\\nMBSTRING_ASC, \"OpenSSL Group\", -1, -1, 0);\\r\\nX509_set_issuer_name(x,name);\\r\\nadd_ext(x, NID_basic_constraints, \"critical,CA:TRUE\");\\r\\nadd_ext(x, NID_key_usage, \"critical,keyCertSign,cRLSign\");\\r\\nadd_ext(x, NID_subject_key_identifier, \"hash\");\\r\\nadd_ext(x, NID_netscape_cert_type, \"sslCA\");\\r\\nadd_ext(x, NID_netscape_comment, \"example comment extension\");\\r\\n#ifdef CUSTOM_EXT\\r\\n{\\r\\nint nid;\\r\\nnid = OBJ_create(\"1.2.3.4\", \"MyAlias\", \"My Test Alias Extension\");\\r\\nX509V3_EXT_add_alias(nid, NID_netscape_comment);\\r\\nadd_ext(x, nid, \"example comment alias\");\\r\\n}\\r\\n#endif\\r\\nif (!X509_sign(x,pk,EVP_md5()))\\r\\ngoto err;\\r\\n*x509p=x;\\r\\n*pkeyp=pk;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint add_ext(X509 *cert, int nid, char *value)\\r\\n{\\r\\nX509_EXTENSION *ex;\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_nodb(&ctx);\\r\\nX509V3_set_ctx(&ctx, cert, cert, NULL, NULL, 0);\\r\\nex = X509V3_EXT_conf_nid(NULL, &ctx, nid, value);\\r\\nif (!ex)\\r\\nreturn 0;\\r\\nX509_add_ext(cert,ex,-1);\\r\\nX509_EXTENSION_free(ex);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_err_c", "target": 0, "func": "void ERR_load_EC_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,EC_str_functs);\\r\\nERR_load_strings(0,EC_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s23_lib_c", "target": 0, "func": "static long ssl23_default_timeout(void)\\r\\n{\\r\\nreturn(300);\\r\\n}\\r\\nSSL_METHOD *sslv23_base_method(void)\\r\\n{\\r\\nreturn(&SSLv23_data);\\r\\n}\\r\\nstatic int ssl23_num_ciphers(void)\\r\\n{\\r\\nreturn(ssl3_num_ciphers()\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\n+ ssl2_num_ciphers()\\r\\n#endif\\r\\n);\\r\\n}\\r\\nstatic SSL_CIPHER *ssl23_get_cipher(unsigned int u)\\r\\n{\\r\\nunsigned int uu=ssl3_num_ciphers();\\r\\nif (u < uu)\\r\\nreturn(ssl3_get_cipher(u));\\r\\nelse\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nreturn(ssl2_get_cipher(u-uu));\\r\\n#else\\r\\nreturn(NULL);\\r\\n#endif\\r\\n}\\r\\nstatic SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nSSL_CIPHER c,*cp;\\r\\nunsigned long id;\\r\\nint n;\\r\\nn=ssl3_num_ciphers();\\r\\nid=0x03000000|((unsigned long)p[0]<<16L)|\\r\\n((unsigned long)p[1]<<8L)|(unsigned long)p[2];\\r\\nc.id=id;\\r\\ncp=ssl3_get_cipher_by_char(p);\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nif (cp == NULL)\\r\\ncp=ssl2_get_cipher_by_char(p);\\r\\n#endif\\r\\nreturn(cp);\\r\\n}\\r\\nstatic int ssl23_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\np[0]=((unsigned char)(l>>16L))&0xFF;\\r\\np[1]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[2]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(3);\\r\\n}\\r\\nstatic int ssl23_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nint n;\\r\\nclear_sys_error();\\r\\nif (SSL_in_init(s) && (!s->in_handshake))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_READ,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(SSL_read(s,buf,len));\\r\\n}\\r\\nelse\\r\\n{\\r\\nssl_undefined_function(s);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstatic int ssl23_peek(SSL *s, void *buf, int len)\\r\\n{\\r\\nint n;\\r\\nclear_sys_error();\\r\\nif (SSL_in_init(s) && (!s->in_handshake))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_PEEK,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(SSL_peek(s,buf,len));\\r\\n}\\r\\nelse\\r\\n{\\r\\nssl_undefined_function(s);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstatic int ssl23_write(SSL *s, const void *buf, int len)\\r\\n{\\r\\nint n;\\r\\nclear_sys_error();\\r\\nif (SSL_in_init(s) && (!s->in_handshake))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_WRITE,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(SSL_write(s,buf,len));\\r\\n}\\r\\nelse\\r\\n{\\r\\nssl_undefined_function(s);\\r\\nreturn(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsautl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nchar *infile = NULL, *outfile = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nchar *keyfile = NULL;\\r\\nchar rsa_mode = RSA_VERIFY, key_type = KEY_PRIVKEY;\\r\\nint keyform = FORMAT_PEM;\\r\\nchar need_priv = 0, badarg = 0, rev = 0;\\r\\nchar hexdump = 0, asn1parse = 0;\\r\\nX509 *x;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nRSA *rsa = NULL;\\r\\nunsigned char *rsa_in = NULL, *rsa_out = NULL, pad;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nint rsa_inlen, rsa_outlen = 0;\\r\\nint keysize;\\r\\nint ret = 1;\\r\\nargc--;\\r\\nargv++;\\r\\nif(!bio_err) bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\npad = RSA_PKCS1_PADDING;\\r\\nwhile(argc >= 1)\\r\\n{\\r\\nif (!strcmp(*argv,\"-in\")) {\\r\\nif (--argc < 1) badarg = 1;\\r\\ninfile= *(++argv);\\r\\n} else if (!strcmp(*argv,\"-out\")) {\\r\\nif (--argc < 1) badarg = 1;\\r\\noutfile= *(++argv);\\r\\n} else if(!strcmp(*argv, \"-inkey\")) {\\r\\nif (--argc < 1) badarg = 1;\\r\\nkeyfile = *(++argv);\\r\\n} else if (!strcmp(*argv,\"-passin\")) {\\r\\nif (--argc < 1) badarg = 1;\\r\\npassargin= *(++argv);\\r\\n} else if (strcmp(*argv,\"-keyform\") == 0) {\\r\\nif (--argc < 1) badarg = 1;\\r\\nkeyform=str2fmt(*(++argv));\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\n} else if(!strcmp(*argv, \"-engine\")) {\\r\\nif (--argc < 1) badarg = 1;\\r\\nengine = *(++argv);\\r\\n#endif\\r\\n} else if(!strcmp(*argv, \"-pubin\")) {\\r\\nkey_type = KEY_PUBKEY;\\r\\n} else if(!strcmp(*argv, \"-certin\")) {\\r\\nkey_type = KEY_CERT;\\r\\n}\\r\\nelse if(!strcmp(*argv, \"-asn1parse\")) asn1parse = 1;\\r\\nelse if(!strcmp(*argv, \"-hexdump\")) hexdump = 1;\\r\\nelse if(!strcmp(*argv, \"-raw\")) pad = RSA_NO_PADDING;\\r\\nelse if(!strcmp(*argv, \"-oaep\")) pad = RSA_PKCS1_OAEP_PADDING;\\r\\nelse if(!strcmp(*argv, \"-ssl\")) pad = RSA_SSLV23_PADDING;\\r\\nelse if(!strcmp(*argv, \"-pkcs\")) pad = RSA_PKCS1_PADDING;\\r\\nelse if(!strcmp(*argv, \"-x931\")) pad = RSA_X931_PADDING;\\r\\nelse if(!strcmp(*argv, \"-sign\")) {\\r\\nrsa_mode = RSA_SIGN;\\r\\nneed_priv = 1;\\r\\n} else if(!strcmp(*argv, \"-verify\")) rsa_mode = RSA_VERIFY;\\r\\nelse if(!strcmp(*argv, \"-rev\")) rev = 1;\\r\\nelse if(!strcmp(*argv, \"-encrypt\")) rsa_mode = RSA_ENCRYPT;\\r\\nelse if(!strcmp(*argv, \"-decrypt\")) {\\r\\nrsa_mode = RSA_DECRYPT;\\r\\nneed_priv = 1;\\r\\n} else badarg = 1;\\r\\nif(badarg) {\\r\\nusage();\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif(need_priv && (key_type != KEY_PRIVKEY)) {\\r\\nBIO_printf(bio_err, \"A private key is needed for this operation\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nswitch(key_type) {\\r\\ncase KEY_PRIVKEY:\\r\\npkey = load_key(bio_err, keyfile, keyform, 0,\\r\\npassin, e, \"Private Key\");\\r\\nbreak;\\r\\ncase KEY_PUBKEY:\\r\\npkey = load_pubkey(bio_err, keyfile, keyform, 0,\\r\\nNULL, e, \"Public Key\");\\r\\nbreak;\\r\\ncase KEY_CERT:\\r\\nx = load_cert(bio_err, keyfile, keyform,\\r\\nNULL, e, \"Certificate\");\\r\\nif(x) {\\r\\npkey = X509_get_pubkey(x);\\r\\nX509_free(x);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif(!pkey) {\\r\\nreturn 1;\\r\\n}\\r\\nrsa = EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif(!rsa) {\\r\\nBIO_printf(bio_err, \"Error getting RSA key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif(infile) {\\r\\nif(!(in = BIO_new_file(infile, \"rb\"))) {\\r\\nBIO_printf(bio_err, \"Error Reading Input File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif(outfile) {\\r\\nif(!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Error Reading Output File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nkeysize = RSA_size(rsa);\\r\\nrsa_in = OPENSSL_malloc(keysize * 2);\\r\\nrsa_out = OPENSSL_malloc(keysize);\\r\\nrsa_inlen = BIO_read(in, rsa_in, keysize * 2);\\r\\nif(rsa_inlen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading input Data\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif(rev) {\\r\\nint i;\\r\\nunsigned char ctmp;\\r\\nfor(i = 0; i < rsa_inlen/2; i++) {\\r\\nctmp = rsa_in[i];\\r\\nrsa_in[i] = rsa_in[rsa_inlen - 1 - i];\\r\\nrsa_in[rsa_inlen - 1 - i] = ctmp;\\r\\n}\\r\\n}\\r\\nswitch(rsa_mode) {\\r\\ncase RSA_VERIFY:\\r\\nrsa_outlen = RSA_public_decrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_SIGN:\\r\\nrsa_outlen = RSA_private_encrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_ENCRYPT:\\r\\nrsa_outlen = RSA_public_encrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_DECRYPT:\\r\\nrsa_outlen = RSA_private_decrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\n}\\r\\nif(rsa_outlen <= 0) {\\r\\nBIO_printf(bio_err, \"RSA operation error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif(asn1parse) {\\r\\nif(!ASN1_parse_dump(out, rsa_out, rsa_outlen, 1, -1)) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n} else if(hexdump) BIO_dump(out, (char *)rsa_out, rsa_outlen);\\r\\nelse BIO_write(out, rsa_out, rsa_outlen);\\r\\nend:\\r\\nRSA_free(rsa);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nif(rsa_in) OPENSSL_free(rsa_in);\\r\\nif(rsa_out) OPENSSL_free(rsa_out);\\r\\nif(passin) OPENSSL_free(passin);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void usage()\\r\\n{\\r\\nBIO_printf(bio_err, \"Usage: rsautl [options]\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err, \"-inkey file input key\\n\");\\r\\nBIO_printf(bio_err, \"-keyform arg private key format - default PEM\\n\");\\r\\nBIO_printf(bio_err, \"-pubin input is an RSA public\\n\");\\r\\nBIO_printf(bio_err, \"-certin input is a certificate carrying an RSA public key\\n\");\\r\\nBIO_printf(bio_err, \"-ssl use SSL v2 padding\\n\");\\r\\nBIO_printf(bio_err, \"-raw use no padding\\n\");\\r\\nBIO_printf(bio_err, \"-pkcs use PKCS#1 v1.5 padding (default)\\n\");\\r\\nBIO_printf(bio_err, \"-oaep use PKCS#1 OAEP\\n\");\\r\\nBIO_printf(bio_err, \"-sign sign with private key\\n\");\\r\\nBIO_printf(bio_err, \"-verify verify with public key\\n\");\\r\\nBIO_printf(bio_err, \"-encrypt encrypt with public key\\n\");\\r\\nBIO_printf(bio_err, \"-decrypt decrypt with private key\\n\");\\r\\nBIO_printf(bio_err, \"-hexdump hex dump output\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err, \"-engine e use engine e, possibly a hardware device.\\n\");\\r\\nBIO_printf (bio_err, \"-passin arg pass phrase source\\n\");\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_ecb_c", "target": 0, "func": "void AES_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key, const int enc) {\\r\\nassert(in && out && key);\\r\\nassert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));\\r\\nif (AES_ENCRYPT == enc)\\r\\nAES_encrypt(in, out, key);\\r\\nelse\\r\\nAES_decrypt(in, out, key);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc4_enc_c", "target": 0, "func": "void RC4(RC4_KEY *key, unsigned long len, const unsigned char *indata,\\r\\nunsigned char *outdata)\\r\\n{\\r\\nregister RC4_INT *d;\\r\\nregister RC4_INT x,y,tx,ty;\\r\\nint i;\\r\\nx=key->x;\\r\\ny=key->y;\\r\\nd=key->data;\\r\\n#if defined(RC4_CHUNK)\\r\\n# define RC4_STEP ( \\\\r\\nx=(x+1) &0xff, \\\\r\\ntx=d[x], \\\\r\\ny=(tx+y)&0xff, \\\\r\\nty=d[y], \\\\r\\nd[y]=tx, \\\\r\\nd[x]=ty, \\\\r\\n(RC4_CHUNK)d[(tx+ty)&0xff]\\\\r\\n)\\r\\nif ( ( ((unsigned long)indata & (sizeof(RC4_CHUNK)-1)) |\\r\\n((unsigned long)outdata & (sizeof(RC4_CHUNK)-1)) ) == 0 )\\r\\n{\\r\\nRC4_CHUNK ichunk,otp;\\r\\nconst union { long one; char little; } is_endian = {1};\\r\\nif (!is_endian.little)\\r\\n{\\r\\n# define BESHFT(c) (((sizeof(RC4_CHUNK)-(c)-1)*8)&(sizeof(RC4_CHUNK)*8-1))\\r\\nfor (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))\\r\\n{\\r\\nichunk = *(RC4_CHUNK *)indata;\\r\\notp = RC4_STEP<<BESHFT(0);\\r\\notp |= RC4_STEP<<BESHFT(1);\\r\\notp |= RC4_STEP<<BESHFT(2);\\r\\notp |= RC4_STEP<<BESHFT(3);\\r\\nif (sizeof(RC4_CHUNK)==8)\\r\\n{\\r\\notp |= RC4_STEP<<BESHFT(4);\\r\\notp |= RC4_STEP<<BESHFT(5);\\r\\notp |= RC4_STEP<<BESHFT(6);\\r\\notp |= RC4_STEP<<BESHFT(7);\\r\\n}\\r\\n*(RC4_CHUNK *)outdata = otp^ichunk;\\r\\nindata += sizeof(RC4_CHUNK);\\r\\noutdata += sizeof(RC4_CHUNK);\\r\\n}\\r\\nif (len)\\r\\n{\\r\\nRC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;\\r\\nichunk = *(RC4_CHUNK *)indata;\\r\\nochunk = *(RC4_CHUNK *)outdata;\\r\\notp = 0;\\r\\ni = BESHFT(0);\\r\\nmask <<= (sizeof(RC4_CHUNK)-len)<<3;\\r\\nswitch (len&(sizeof(RC4_CHUNK)-1))\\r\\n{\\r\\ncase 7: otp = RC4_STEP<<i, i-=8;\\r\\ncase 6: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 5: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 4: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 3: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 2: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 1: otp |= RC4_STEP<<i, i-=8;\\r\\ncase 0: ;\\r\\n}\\r\\nochunk &= ~mask;\\r\\nochunk |= (otp^ichunk) & mask;\\r\\n*(RC4_CHUNK *)outdata = ochunk;\\r\\n}\\r\\nkey->x=x;\\r\\nkey->y=y;\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\n{\\r\\n# define LESHFT(c) (((c)*8)&(sizeof(RC4_CHUNK)*8-1))\\r\\nfor (;len&~(sizeof(RC4_CHUNK)-1);len-=sizeof(RC4_CHUNK))\\r\\n{\\r\\nichunk = *(RC4_CHUNK *)indata;\\r\\notp = RC4_STEP;\\r\\notp |= RC4_STEP<<8;\\r\\notp |= RC4_STEP<<16;\\r\\notp |= RC4_STEP<<24;\\r\\nif (sizeof(RC4_CHUNK)==8)\\r\\n{\\r\\notp |= RC4_STEP<<LESHFT(4);\\r\\notp |= RC4_STEP<<LESHFT(5);\\r\\notp |= RC4_STEP<<LESHFT(6);\\r\\notp |= RC4_STEP<<LESHFT(7);\\r\\n}\\r\\n*(RC4_CHUNK *)outdata = otp^ichunk;\\r\\nindata += sizeof(RC4_CHUNK);\\r\\noutdata += sizeof(RC4_CHUNK);\\r\\n}\\r\\nif (len)\\r\\n{\\r\\nRC4_CHUNK mask=(RC4_CHUNK)-1, ochunk;\\r\\nichunk = *(RC4_CHUNK *)indata;\\r\\nochunk = *(RC4_CHUNK *)outdata;\\r\\notp = 0;\\r\\ni = 0;\\r\\nmask >>= (sizeof(RC4_CHUNK)-len)<<3;\\r\\nswitch (len&(sizeof(RC4_CHUNK)-1))\\r\\n{\\r\\ncase 7: otp = RC4_STEP, i+=8;\\r\\ncase 6: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 5: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 4: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 3: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 2: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 1: otp |= RC4_STEP<<i, i+=8;\\r\\ncase 0: ;\\r\\n}\\r\\nochunk &= ~mask;\\r\\nochunk |= (otp^ichunk) & mask;\\r\\n*(RC4_CHUNK *)outdata = ochunk;\\r\\n}\\r\\nkey->x=x;\\r\\nkey->y=y;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#define LOOP(in,out) \\\\r\\nx=((x+1)&0xff); \\\\r\\ntx=d[x]; \\\\r\\ny=(tx+y)&0xff; \\\\r\\nd[x]=ty=d[y]; \\\\r\\nd[y]=tx; \\\\r\\n(out) = d[(tx+ty)&0xff]^ (in);\\r\\n#ifndef RC4_INDEX\\r\\n#define RC4_LOOP(a,b,i) LOOP(*((a)++),*((b)++))\\r\\n#else\\r\\n#define RC4_LOOP(a,b,i) LOOP(a[i],b[i])\\r\\n#endif\\r\\ni=(int)(len>>3L);\\r\\nif (i)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nRC4_LOOP(indata,outdata,0);\\r\\nRC4_LOOP(indata,outdata,1);\\r\\nRC4_LOOP(indata,outdata,2);\\r\\nRC4_LOOP(indata,outdata,3);\\r\\nRC4_LOOP(indata,outdata,4);\\r\\nRC4_LOOP(indata,outdata,5);\\r\\nRC4_LOOP(indata,outdata,6);\\r\\nRC4_LOOP(indata,outdata,7);\\r\\n#ifdef RC4_INDEX\\r\\nindata+=8;\\r\\noutdata+=8;\\r\\n#endif\\r\\nif (--i == 0) break;\\r\\n}\\r\\n}\\r\\ni=(int)len&0x07;\\r\\nif (i)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nRC4_LOOP(indata,outdata,0); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,1); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,2); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,3); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,4); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,5); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,6); if (--i == 0) break;\\r\\n}\\r\\n}\\r\\nkey->x=x;\\r\\nkey->y=y;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_depr_c", "target": 0, "func": "BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe,\\r\\nconst BIGNUM *add, const BIGNUM *rem,\\r\\nvoid (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBIGNUM *rnd=NULL;\\r\\nint found = 0;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif (ret == NULL)\\r\\n{\\r\\nif ((rnd=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nrnd=ret;\\r\\nif(!BN_generate_prime_ex(rnd, bits, safe, add, rem, &cb))\\r\\ngoto err;\\r\\nfound = 1;\\r\\nerr:\\r\\nif (!found && (ret == NULL) && (rnd != NULL)) BN_free(rnd);\\r\\nreturn(found ? rnd : NULL);\\r\\n}\\r\\nint BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int,int,void *),\\r\\nBN_CTX *ctx_passed, void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nreturn BN_is_prime_ex(a, checks, ctx_passed, &cb);\\r\\n}\\r\\nint BN_is_prime_fasttest(const BIGNUM *a, int checks,\\r\\nvoid (*callback)(int,int,void *),\\r\\nBN_CTX *ctx_passed, void *cb_arg,\\r\\nint do_trial_division)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nreturn BN_is_prime_fasttest_ex(a, checks, ctx_passed,\\r\\ndo_trial_division, &cb);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_loadkeys_c", "target": 0, "func": "EVP_PKEY * ReadPublicKey(const char *certfile)\\r\\n{\\r\\nFILE *fp = fopen (certfile, \"r\");\\r\\nX509 *x509;\\r\\nEVP_PKEY *pkey;\\r\\nif (!fp)\\r\\nreturn NULL;\\r\\nx509 = PEM_read_X509(fp, NULL, 0, NULL);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn NULL;\\r\\n}\\r\\nfclose (fp);\\r\\npkey=X509_extract_key(x509);\\r\\nX509_free(x509);\\r\\nif (pkey == NULL)\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn pkey;\\r\\n}\\r\\nEVP_PKEY *ReadPrivateKey(const char *keyfile)\\r\\n{\\r\\nFILE *fp = fopen(keyfile, \"r\");\\r\\nEVP_PKEY *pkey;\\r\\nif (!fp)\\r\\nreturn NULL;\\r\\npkey = PEM_read_PrivateKey(fp, NULL, 0, NULL);\\r\\nfclose (fp);\\r\\nif (pkey == NULL)\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn pkey;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ech_ossl_c", "target": 0, "func": "const ECDH_METHOD *ECDH_OpenSSL(void)\\r\\n{\\r\\nreturn &openssl_ecdh_meth;\\r\\n}\\r\\nstatic int ecdh_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,\\r\\nEC_KEY *ecdh,\\r\\nvoid *(*KDF)(const void *in, size_t inlen, void *out, size_t *outlen))\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nEC_POINT *tmp=NULL;\\r\\nBIGNUM *x=NULL, *y=NULL;\\r\\nconst BIGNUM *priv_key;\\r\\nconst EC_GROUP* group;\\r\\nint ret= -1;\\r\\nsize_t buflen, len;\\r\\nunsigned char *buf=NULL;\\r\\nif (outlen > INT_MAX)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nif ((ctx = BN_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\npriv_key = EC_KEY_get0_private_key(ecdh);\\r\\nif (priv_key == NULL)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_NO_PRIVATE_VALUE);\\r\\ngoto err;\\r\\n}\\r\\ngroup = EC_KEY_get0_group(ecdh);\\r\\nif ((tmp=EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(group, tmp, NULL, pub_key, priv_key, ctx))\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_POINT_ARITHMETIC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group, tmp, x, y, ctx))\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_POINT_ARITHMETIC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, tmp, x, y, ctx))\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_POINT_ARITHMETIC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nbuflen = (EC_GROUP_get_degree(group) + 7)/8;\\r\\nlen = BN_num_bytes(x);\\r\\nif (len > buflen)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((buf = OPENSSL_malloc(buflen)) == NULL)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemset(buf, 0, buflen - len);\\r\\nif (len != (size_t)BN_bn2bin(x, buf + buflen - len))\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (KDF != 0)\\r\\n{\\r\\nif (KDF(buf, buflen, out, &outlen) == NULL)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_COMPUTE_KEY,ECDH_R_KDF_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nret = outlen;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (outlen > buflen)\\r\\noutlen = buflen;\\r\\nmemcpy(out, buf, outlen);\\r\\nret = outlen;\\r\\n}\\r\\nerr:\\r\\nif (tmp) EC_POINT_free(tmp);\\r\\nif (ctx) BN_CTX_end(ctx);\\r\\nif (ctx) BN_CTX_free(ctx);\\r\\nif (buf) OPENSSL_free(buf);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pk7_lib_c", "target": 0, "func": "long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)\\r\\n{\\r\\nint nid;\\r\\nlong ret;\\r\\nnid=OBJ_obj2nid(p7->type);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase PKCS7_OP_SET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed)\\r\\n{\\r\\nret=p7->detached=(int)larg;\\r\\nif (ret && PKCS7_type_is_data(p7->d.sign->contents))\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nos=p7->d.sign->contents->d.data;\\r\\nASN1_OCTET_STRING_free(os);\\r\\np7->d.sign->contents->d.data = NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret=0;\\r\\n}\\r\\nbreak;\\r\\ncase PKCS7_OP_GET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed)\\r\\n{\\r\\nif(!p7->d.sign || !p7->d.sign->contents->d.ptr)\\r\\nret = 1;\\r\\nelse ret = 0;\\r\\np7->detached = ret;\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret=0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_UNKNOWN_OPERATION);\\r\\nret=0;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint PKCS7_content_new(PKCS7 *p7, int type)\\r\\n{\\r\\nPKCS7 *ret=NULL;\\r\\nif ((ret=PKCS7_new()) == NULL) goto err;\\r\\nif (!PKCS7_set_type(ret,type)) goto err;\\r\\nif (!PKCS7_set_content(p7,ret)) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (ret != NULL) PKCS7_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)\\r\\n{\\r\\nint i;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nif (p7->d.sign->contents != NULL)\\r\\nPKCS7_free(p7->d.sign->contents);\\r\\np7->d.sign->contents=p7_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nif (p7->d.digest->contents != NULL)\\r\\nPKCS7_free(p7->d.digest->contents);\\r\\np7->d.digest->contents=p7_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncase NID_pkcs7_encrypted:\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CONTENT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_set_type(PKCS7 *p7, int type)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(type);\\r\\nswitch (type)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\np7->type=obj;\\r\\nif ((p7->d.sign=PKCS7_SIGNED_new()) == NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.sign->version,1))\\r\\n{\\r\\nPKCS7_SIGNED_free(p7->d.sign);\\r\\np7->d.sign=NULL;\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\np7->type=obj;\\r\\nif ((p7->d.data=M_ASN1_OCTET_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\np7->type=obj;\\r\\nif ((p7->d.signed_and_enveloped=PKCS7_SIGN_ENVELOPE_new())\\r\\n== NULL) goto err;\\r\\nASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1);\\r\\nif (!ASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1))\\r\\ngoto err;\\r\\np7->d.signed_and_enveloped->enc_data->content_type\\r\\n= OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\np7->type=obj;\\r\\nif ((p7->d.enveloped=PKCS7_ENVELOPE_new())\\r\\n== NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.enveloped->version,0))\\r\\ngoto err;\\r\\np7->d.enveloped->enc_data->content_type\\r\\n= OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\np7->type=obj;\\r\\nif ((p7->d.encrypted=PKCS7_ENCRYPT_new())\\r\\n== NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.encrypted->version,0))\\r\\ngoto err;\\r\\np7->d.encrypted->enc_data->content_type\\r\\n= OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\np7->type=obj;\\r\\nif ((p7->d.digest=PKCS7_DIGEST_new())\\r\\n== NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.digest->version,0))\\r\\ngoto err;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_TYPE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)\\r\\n{\\r\\np7->type = OBJ_nid2obj(type);\\r\\np7->d.other = other;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)\\r\\n{\\r\\nint i,j,nid;\\r\\nX509_ALGOR *alg;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *signer_sk;\\r\\nSTACK_OF(X509_ALGOR) *md_sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsigner_sk= p7->d.sign->signer_info;\\r\\nmd_sk= p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsigner_sk= p7->d.signed_and_enveloped->signer_info;\\r\\nmd_sk= p7->d.signed_and_enveloped->md_algs;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nnid=OBJ_obj2nid(psi->digest_alg->algorithm);\\r\\nj=0;\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\n{\\r\\nalg=sk_X509_ALGOR_value(md_sk,i);\\r\\nif (OBJ_obj2nid(alg->algorithm) == nid)\\r\\n{\\r\\nj=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!j)\\r\\n{\\r\\nif(!(alg=X509_ALGOR_new())\\r\\n|| !(alg->parameter = ASN1_TYPE_new())) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nalg->algorithm=OBJ_nid2obj(nid);\\r\\nalg->parameter->type = V_ASN1_NULL;\\r\\nsk_X509_ALGOR_push(md_sk,alg);\\r\\n}\\r\\nsk_PKCS7_SIGNER_INFO_push(signer_sk,psi);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_add_certificate(PKCS7 *p7, X509 *x509)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509) **sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsk= &(p7->d.sign->cert);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk= &(p7->d.signed_and_enveloped->cert);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk=sk_X509_new_null();\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\nsk_X509_push(*sk,x509);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_CRL) **sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsk= &(p7->d.sign->crl);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk= &(p7->d.signed_and_enveloped->crl);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CRL,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk=sk_X509_CRL_new_null();\\r\\nCRYPTO_add(&crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\nsk_X509_CRL_push(*sk,crl);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,\\r\\nconst EVP_MD *dgst)\\r\\n{\\r\\nint nid;\\r\\nchar is_dsa;\\r\\nif (pkey->type == EVP_PKEY_DSA || pkey->type == EVP_PKEY_EC)\\r\\nis_dsa = 1;\\r\\nelse\\r\\nis_dsa = 0;\\r\\nif (!ASN1_INTEGER_set(p7i->version,1))\\r\\ngoto err;\\r\\nif (!X509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509)))\\r\\ngoto err;\\r\\nM_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\nif (!(p7i->issuer_and_serial->serial=\\r\\nM_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))\\r\\ngoto err;\\r\\nCRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\np7i->pkey=pkey;\\r\\nif (is_dsa) p7i->digest_alg->algorithm=OBJ_nid2obj(NID_sha1);\\r\\nelse\\r\\np7i->digest_alg->algorithm=OBJ_nid2obj(EVP_MD_type(dgst));\\r\\nif (p7i->digest_alg->parameter != NULL)\\r\\nASN1_TYPE_free(p7i->digest_alg->parameter);\\r\\nif ((p7i->digest_alg->parameter=ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\np7i->digest_alg->parameter->type=V_ASN1_NULL;\\r\\nif (p7i->digest_enc_alg->parameter != NULL)\\r\\nASN1_TYPE_free(p7i->digest_enc_alg->parameter);\\r\\nnid = EVP_PKEY_type(pkey->type);\\r\\nif (nid == EVP_PKEY_RSA)\\r\\n{\\r\\np7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_rsaEncryption);\\r\\nif (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))\\r\\ngoto err;\\r\\np7i->digest_enc_alg->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\nelse if (nid == EVP_PKEY_DSA)\\r\\n{\\r\\n#if 1\\r\\np7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsa);\\r\\n#else\\r\\np7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_dsaWithSHA1);\\r\\n#endif\\r\\np7i->digest_enc_alg->parameter = NULL;\\r\\n}\\r\\nelse if (nid == EVP_PKEY_EC)\\r\\n{\\r\\np7i->digest_enc_alg->algorithm=OBJ_nid2obj(NID_ecdsa_with_SHA1);\\r\\nif (!(p7i->digest_enc_alg->parameter=ASN1_TYPE_new()))\\r\\ngoto err;\\r\\np7i->digest_enc_alg->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nPKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,\\r\\nconst EVP_MD *dgst)\\r\\n{\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nif ((si=PKCS7_SIGNER_INFO_new()) == NULL) goto err;\\r\\nif (!PKCS7_SIGNER_INFO_set(si,x509,pkey,dgst)) goto err;\\r\\nif (!PKCS7_add_signer(p7,si)) goto err;\\r\\nreturn(si);\\r\\nerr:\\r\\nreturn(NULL);\\r\\n}\\r\\nint PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)\\r\\n{\\r\\nif (PKCS7_type_is_digest(p7))\\r\\n{\\r\\nif(!(p7->d.digest->md->parameter = ASN1_TYPE_new()))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_DIGEST,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np7->d.digest->md->parameter->type = V_ASN1_NULL;\\r\\np7->d.digest->md->algorithm = OBJ_nid2obj(EVP_MD_nid(md));\\r\\nreturn 1;\\r\\n}\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_DIGEST,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)\\r\\n{\\r\\nif (!ASN1_INTEGER_set(p7i->version,0))\\r\\nreturn 0;\\r\\nif (!X509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509)))\\r\\nreturn 0;\\r\\nM_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\nif (!(p7i->issuer_and_serial->serial=\\r\\nM_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))\\r\\nreturn 0;\\r\\nX509_ALGOR_free(p7i->key_enc_algor);\\r\\nif (!(p7i->key_enc_algor= X509_ALGOR_dup(x509->cert_info->key->algor)))\\r\\nreturn 0;\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\np7i->cert=x509;\\r\\nreturn(1);\\r\\n}\\r\\nX509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nif (PKCS7_type_is_signed(p7))\\r\\nreturn(X509_find_by_issuer_and_serial(p7->d.sign->cert,\\r\\nsi->issuer_and_serial->issuer,\\r\\nsi->issuer_and_serial->serial));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)\\r\\n{\\r\\nint i;\\r\\nASN1_OBJECT *objtmp;\\r\\nPKCS7_ENC_CONTENT *ec;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nec=p7->d.signed_and_enveloped->enc_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nec=p7->d.enveloped->enc_data;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\ni = EVP_CIPHER_type(cipher);\\r\\nif(i == NID_undef) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);\\r\\nreturn(0);\\r\\n}\\r\\nobjtmp = OBJ_nid2obj(i);\\r\\nec->cipher = cipher;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_verify_c", "target": 0, "func": "int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\\r\\nchar *data, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nconst EVP_MD *type;\\r\\nunsigned char *p,*buf_in=NULL;\\r\\nint ret= -1,i,inl;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\ni=OBJ_obj2nid(a->algorithm);\\r\\ntype=EVP_get_digestbyname(OBJ_nid2sn(i));\\r\\nif (type == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\ninl=i2d(data,NULL);\\r\\nbuf_in=OPENSSL_malloc((unsigned int)inl);\\r\\nif (buf_in == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf_in;\\r\\ni2d(data,&p);\\r\\nEVP_VerifyInit_ex(&ctx,type, NULL);\\r\\nEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nOPENSSL_cleanse(buf_in,(unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\nif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\\r\\n(unsigned int)signature->length,pkey) <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\\r\\nvoid *asn, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nconst EVP_MD *type;\\r\\nunsigned char *buf_in=NULL;\\r\\nint ret= -1,i,inl;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\ni=OBJ_obj2nid(a->algorithm);\\r\\ntype=EVP_get_digestbyname(OBJ_nid2sn(i));\\r\\nif (type == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_VerifyInit_ex(&ctx,type, NULL))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\ninl = ASN1_item_i2d(asn, &buf_in, it);\\r\\nif (buf_in == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nOPENSSL_cleanse(buf_in,(unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\nif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\\r\\n(unsigned int)signature->length,pkey) <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkcs12_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar *infile=NULL, *outfile=NULL, *keyname = NULL;\\r\\nchar *certfile=NULL;\\r\\nBIO *in=NULL, *out = NULL;\\r\\nchar **args;\\r\\nchar *name = NULL;\\r\\nchar *csp_name = NULL;\\r\\nPKCS12 *p12 = NULL;\\r\\nchar pass[50], macpass[50];\\r\\nint export_cert = 0;\\r\\nint options = 0;\\r\\nint chain = 0;\\r\\nint badarg = 0;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint maciter = PKCS12_DEFAULT_ITER;\\r\\nint twopass = 0;\\r\\nint keytype = 0;\\r\\nint cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;\\r\\nint key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nint ret = 1;\\r\\nint macver = 1;\\r\\nint noprompt = 0;\\r\\nSTACK *canames = NULL;\\r\\nchar *cpass = NULL, *mpass = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL, *passarg = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nchar *inrand = NULL;\\r\\nchar *CApath = NULL, *CAfile = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nenc = EVP_des_ede3_cbc();\\r\\nif (bio_err == NULL ) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargs = argv + 1;\\r\\nwhile (*args) {\\r\\nif (*args[0] == '-') {\\r\\nif (!strcmp (*args, \"-nokeys\")) options |= NOKEYS;\\r\\nelse if (!strcmp (*args, \"-keyex\")) keytype = KEY_EX;\\r\\nelse if (!strcmp (*args, \"-keysig\")) keytype = KEY_SIG;\\r\\nelse if (!strcmp (*args, \"-nocerts\")) options |= NOCERTS;\\r\\nelse if (!strcmp (*args, \"-clcerts\")) options |= CLCERTS;\\r\\nelse if (!strcmp (*args, \"-cacerts\")) options |= CACERTS;\\r\\nelse if (!strcmp (*args, \"-noout\")) options |= (NOKEYS|NOCERTS);\\r\\nelse if (!strcmp (*args, \"-info\")) options |= INFO;\\r\\nelse if (!strcmp (*args, \"-chain\")) chain = 1;\\r\\nelse if (!strcmp (*args, \"-twopass\")) twopass = 1;\\r\\nelse if (!strcmp (*args, \"-nomacver\")) macver = 0;\\r\\nelse if (!strcmp (*args, \"-descert\"))\\r\\ncert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nelse if (!strcmp (*args, \"-export\")) export_cert = 1;\\r\\nelse if (!strcmp (*args, \"-des\")) enc=EVP_des_cbc();\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nelse if (!strcmp (*args, \"-idea\")) enc=EVP_idea_cbc();\\r\\n#endif\\r\\nelse if (!strcmp (*args, \"-des3\")) enc = EVP_des_ede3_cbc();\\r\\n#ifndef OPENSSL_NO_AES\\r\\nelse if (!strcmp(*args,\"-aes128\")) enc=EVP_aes_128_cbc();\\r\\nelse if (!strcmp(*args,\"-aes192\")) enc=EVP_aes_192_cbc();\\r\\nelse if (!strcmp(*args,\"-aes256\")) enc=EVP_aes_256_cbc();\\r\\n#endif\\r\\nelse if (!strcmp (*args, \"-noiter\")) iter = 1;\\r\\nelse if (!strcmp (*args, \"-maciter\"))\\r\\nmaciter = PKCS12_DEFAULT_ITER;\\r\\nelse if (!strcmp (*args, \"-nomaciter\"))\\r\\nmaciter = 1;\\r\\nelse if (!strcmp (*args, \"-nomac\"))\\r\\nmaciter = -1;\\r\\nelse if (!strcmp (*args, \"-nodes\")) enc=NULL;\\r\\nelse if (!strcmp (*args, \"-certpbe\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!strcmp(*args, \"NONE\"))\\r\\ncert_pbe = -1;\\r\\ncert_pbe=OBJ_txt2nid(*args);\\r\\nif(cert_pbe == NID_undef) {\\r\\nBIO_printf(bio_err,\\r\\n\"Unknown PBE algorithm %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-keypbe\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!strcmp(*args, \"NONE\"))\\r\\nkey_pbe = -1;\\r\\nelse\\r\\nkey_pbe=OBJ_txt2nid(*args);\\r\\nif(key_pbe == NID_undef) {\\r\\nBIO_printf(bio_err,\\r\\n\"Unknown PBE algorithm %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-rand\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninrand = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-inkey\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nkeyname = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-certfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncertfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-name\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nname = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-CSP\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncsp_name = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-caname\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!canames) canames = sk_new_null();\\r\\nsk_push(canames, *args);\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-passin\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassargin = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-passout\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassargout = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-password\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassarg = *args;\\r\\nnoprompt = 1;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-CApath\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCApath = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-CAfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCAfile = *args;\\r\\n} else badarg = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\n} else if (!strcmp(*args,\"-engine\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nengine = *args;\\r\\n} else badarg = 1;\\r\\n#endif\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf (bio_err, \"Usage: pkcs12 [options]\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-export output PKCS12 file\\n\");\\r\\nBIO_printf (bio_err, \"-chain add certificate chain\\n\");\\r\\nBIO_printf (bio_err, \"-inkey file private key if not infile\\n\");\\r\\nBIO_printf (bio_err, \"-certfile f add all certs in f\\n\");\\r\\nBIO_printf (bio_err, \"-CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf (bio_err, \"-CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf (bio_err, \"-name \\\"name\\\" use name as friendly name\\n\");\\r\\nBIO_printf (bio_err, \"-caname \\\"nm\\\" use nm as CA friendly name (can be used more than once).\\n\");\\r\\nBIO_printf (bio_err, \"-in infile input filename\\n\");\\r\\nBIO_printf (bio_err, \"-out outfile output filename\\n\");\\r\\nBIO_printf (bio_err, \"-noout don't output anything, just verify.\\n\");\\r\\nBIO_printf (bio_err, \"-nomacver don't verify MAC.\\n\");\\r\\nBIO_printf (bio_err, \"-nocerts don't output certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-clcerts only output client certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-cacerts only output CA certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-nokeys don't output private keys.\\n\");\\r\\nBIO_printf (bio_err, \"-info give info about PKCS#12 structure.\\n\");\\r\\nBIO_printf (bio_err, \"-des encrypt private keys with DES\\n\");\\r\\nBIO_printf (bio_err, \"-des3 encrypt private keys with triple DES (default)\\n\");\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf (bio_err, \"-idea encrypt private keys with idea\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf (bio_err, \"-aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf (bio_err, \" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\nBIO_printf (bio_err, \"-nodes don't encrypt private keys\\n\");\\r\\nBIO_printf (bio_err, \"-noiter don't use encryption iteration\\n\");\\r\\nBIO_printf (bio_err, \"-maciter use MAC iteration\\n\");\\r\\nBIO_printf (bio_err, \"-twopass separate MAC, encryption passwords\\n\");\\r\\nBIO_printf (bio_err, \"-descert encrypt PKCS#12 certificates with triple DES (default RC2-40)\\n\");\\r\\nBIO_printf (bio_err, \"-certpbe alg specify certificate PBE algorithm (default RC2-40)\\n\");\\r\\nBIO_printf (bio_err, \"-keypbe alg specify private key PBE algorithm (default 3DES)\\n\");\\r\\nBIO_printf (bio_err, \"-keyex set MS key exchange type\\n\");\\r\\nBIO_printf (bio_err, \"-keysig set MS key signature type\\n\");\\r\\nBIO_printf (bio_err, \"-password p set import/export password source\\n\");\\r\\nBIO_printf (bio_err, \"-passin p input file pass phrase source\\n\");\\r\\nBIO_printf (bio_err, \"-passout p output file pass phrase source\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf (bio_err, \"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(passarg) {\\r\\nif(export_cert) passargout = passarg;\\r\\nelse passargin = passarg;\\r\\n}\\r\\nif(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif(!cpass) {\\r\\nif(export_cert) cpass = passout;\\r\\nelse cpass = passin;\\r\\n}\\r\\nif(cpass) {\\r\\nmpass = cpass;\\r\\nnoprompt = 1;\\r\\n} else {\\r\\ncpass = pass;\\r\\nmpass = macpass;\\r\\n}\\r\\nif(export_cert || inrand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read files\");\\r\\n#endif\\r\\nif (!infile) in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nelse in = BIO_new_file(infile, \"rb\");\\r\\nif (!in) {\\r\\nBIO_printf(bio_err, \"Error opening input file %s\\n\",\\r\\ninfile ? infile : \"<stdin>\");\\r\\nperror (infile);\\r\\ngoto end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"write files\");\\r\\n#endif\\r\\nif (!outfile) {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else out = BIO_new_file(outfile, \"wb\");\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file %s\\n\",\\r\\noutfile ? outfile : \"<stdout>\");\\r\\nperror (outfile);\\r\\ngoto end;\\r\\n}\\r\\nif (twopass) {\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read MAC password\");\\r\\n#endif\\r\\nif(EVP_read_pw_string (macpass, sizeof macpass, \"Enter MAC Password:\", export_cert))\\r\\n{\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\n}\\r\\nif (export_cert) {\\r\\nEVP_PKEY *key = NULL;\\r\\nX509 *ucert = NULL, *x = NULL;\\r\\nSTACK_OF(X509) *certs=NULL;\\r\\nunsigned char *catmp = NULL;\\r\\nint i;\\r\\nif ((options & (NOCERTS|NOKEYS)) == (NOCERTS|NOKEYS))\\r\\n{\\r\\nBIO_printf(bio_err, \"Nothing to do!\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (options & NOCERTS)\\r\\nchain = 0;\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"process -export_cert\");\\r\\nCRYPTO_push_info(\"reading private key\");\\r\\n#endif\\r\\nif (!(options & NOKEYS))\\r\\n{\\r\\nkey = load_key(bio_err, keyname ? keyname : infile,\\r\\nFORMAT_PEM, 1, passin, e, \"private key\");\\r\\nif (!key)\\r\\ngoto export_end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from input\");\\r\\n#endif\\r\\nif(!(options & NOCERTS))\\r\\n{\\r\\ncerts = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,\\r\\n\"certificates\");\\r\\nif (!certs)\\r\\ngoto export_end;\\r\\nif (key)\\r\\n{\\r\\nfor(i = 0; i < sk_X509_num(certs); i++)\\r\\n{\\r\\nx = sk_X509_value(certs, i);\\r\\nif(X509_check_private_key(x, key))\\r\\n{\\r\\nucert = x;\\r\\nX509_keyid_set1(ucert, NULL, 0);\\r\\nX509_alias_set1(ucert, NULL, 0);\\r\\nsk_X509_delete(certs, i);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ucert)\\r\\n{\\r\\nBIO_printf(bio_err, \"No certificate matches private key\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\n}\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from input 2\");\\r\\n#endif\\r\\nif(certfile)\\r\\n{\\r\\nSTACK_OF(X509) *morecerts=NULL;\\r\\nif(!(morecerts = load_certs(bio_err, certfile, FORMAT_PEM,\\r\\nNULL, e,\\r\\n\"certificates from certfile\")))\\r\\ngoto export_end;\\r\\nwhile(sk_X509_num(morecerts) > 0)\\r\\nsk_X509_push(certs, sk_X509_shift(morecerts));\\r\\nsk_X509_free(morecerts);\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from certfile\");\\r\\n#endif\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"building chain\");\\r\\n#endif\\r\\nif (chain) {\\r\\nint vret;\\r\\nSTACK_OF(X509) *chain2;\\r\\nX509_STORE *store = X509_STORE_new();\\r\\nif (!store)\\r\\n{\\r\\nBIO_printf (bio_err, \"Memory allocation error\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (!X509_STORE_load_locations(store, CAfile, CApath))\\r\\nX509_STORE_set_default_paths (store);\\r\\nvret = get_cert_chain (ucert, store, &chain2);\\r\\nX509_STORE_free(store);\\r\\nif (!vret) {\\r\\nfor (i = 1; i < sk_X509_num (chain2) ; i++)\\r\\nsk_X509_push(certs, sk_X509_value (chain2, i));\\r\\nX509_free(sk_X509_value(chain2, 0));\\r\\nsk_X509_free(chain2);\\r\\n} else {\\r\\nBIO_printf (bio_err, \"Error %s getting chain.\\n\",\\r\\nX509_verify_cert_error_string(vret));\\r\\ngoto export_end;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_num(canames); i++)\\r\\n{\\r\\ncatmp = (unsigned char *)sk_value(canames, i);\\r\\nX509_alias_set1(sk_X509_value(certs, i), catmp, -1);\\r\\n}\\r\\nif (csp_name && key)\\r\\nEVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name,\\r\\nMBSTRING_ASC, (unsigned char *)csp_name, -1);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading password\");\\r\\n#endif\\r\\nif(!noprompt &&\\r\\nEVP_read_pw_string(pass, sizeof pass, \"Enter Export Password:\", 1))\\r\\n{\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"creating PKCS#12 structure\");\\r\\n#endif\\r\\np12 = PKCS12_create(cpass, name, key, ucert, certs,\\r\\nkey_pbe, cert_pbe, iter, -1, keytype);\\r\\nif (!p12)\\r\\n{\\r\\nERR_print_errors (bio_err);\\r\\ngoto export_end;\\r\\n}\\r\\nif (maciter != -1)\\r\\nPKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, NULL);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"writing pkcs12\");\\r\\n#endif\\r\\ni2d_PKCS12_bio(out, p12);\\r\\nret = 0;\\r\\nexport_end:\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"process -export_cert: freeing\");\\r\\n#endif\\r\\nif (key) EVP_PKEY_free(key);\\r\\nif (certs) sk_X509_pop_free(certs, X509_free);\\r\\nif (ucert) X509_free(ucert);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nif (!(p12 = d2i_PKCS12_bio (in, NULL))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read import password\");\\r\\n#endif\\r\\nif(!noprompt && EVP_read_pw_string(pass, sizeof pass, \"Enter Import Password:\", 0)) {\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nif (!twopass) BUF_strlcpy(macpass, pass, sizeof macpass);\\r\\nif (options & INFO) BIO_printf (bio_err, \"MAC Iteration %ld\\n\", p12->mac->iter ? ASN1_INTEGER_get (p12->mac->iter) : 1);\\r\\nif(macver) {\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"verify MAC\");\\r\\n#endif\\r\\nif(!mpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {\\r\\nif(!twopass) cpass = NULL;\\r\\n} else if (!PKCS12_verify_mac(p12, mpass, -1)) {\\r\\nBIO_printf (bio_err, \"Mac verify error: invalid password?\\n\");\\r\\nERR_print_errors (bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf (bio_err, \"MAC verified OK\\n\");\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"output keys and certificates\");\\r\\n#endif\\r\\nif (!dump_certs_keys_p12 (out, p12, cpass, -1, options, passout)) {\\r\\nBIO_printf(bio_err, \"Error outputting keys and certificates\\n\");\\r\\nERR_print_errors (bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nret = 0;\\r\\nend:\\r\\nif (p12) PKCS12_free(p12);\\r\\nif(export_cert || inrand) app_RAND_write_file(NULL, bio_err);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_remove_all_info();\\r\\n#endif\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nif (canames) sk_free(canames);\\r\\nif(passin) OPENSSL_free(passin);\\r\\nif(passout) OPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nint dump_certs_keys_p12 (BIO *out, PKCS12 *p12, char *pass,\\r\\nint passlen, int options, char *pempass)\\r\\n{\\r\\nSTACK_OF(PKCS7) *asafes = NULL;\\r\\nSTACK_OF(PKCS12_SAFEBAG) *bags;\\r\\nint i, bagnid;\\r\\nint ret = 0;\\r\\nPKCS7 *p7;\\r\\nif (!( asafes = PKCS12_unpack_authsafes(p12))) return 0;\\r\\nfor (i = 0; i < sk_PKCS7_num (asafes); i++) {\\r\\np7 = sk_PKCS7_value (asafes, i);\\r\\nbagnid = OBJ_obj2nid (p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = PKCS12_unpack_p7data(p7);\\r\\nif (options & INFO) BIO_printf (bio_err, \"PKCS7 Data\\n\");\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nif (options & INFO) {\\r\\nBIO_printf(bio_err, \"PKCS7 Encrypted data: \");\\r\\nalg_print(bio_err,\\r\\np7->d.encrypted->enc_data->algorithm);\\r\\n}\\r\\nbags = PKCS12_unpack_p7encdata(p7, pass, passlen);\\r\\n} else continue;\\r\\nif (!bags) goto err;\\r\\nif (!dump_certs_pkeys_bags (out, bags, pass, passlen,\\r\\noptions, pempass)) {\\r\\nsk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\ngoto err;\\r\\n}\\r\\nsk_PKCS12_SAFEBAG_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\nbags = NULL;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (asafes)\\r\\nsk_PKCS7_pop_free (asafes, PKCS7_free);\\r\\nreturn ret;\\r\\n}\\r\\nint dump_certs_pkeys_bag (BIO *out, PKCS12_SAFEBAG *bag, char *pass,\\r\\nint passlen, int options, char *pempass)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509 *x509;\\r\\nswitch (M_PKCS12_bag_type(bag))\\r\\n{\\r\\ncase NID_keyBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Key bag\\n\");\\r\\nif (options & NOKEYS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\np8 = bag->value.keybag;\\r\\nif (!(pkey = EVP_PKCS82PKEY (p8))) return 0;\\r\\nprint_attribs (out, p8->attributes, \"Key Attributes\");\\r\\nPEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nif (options & INFO) {\\r\\nBIO_printf (bio_err, \"Shrouded Keybag: \");\\r\\nalg_print (bio_err, bag->value.shkeybag->algor);\\r\\n}\\r\\nif (options & NOKEYS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nif (!(p8 = PKCS12_decrypt_skey(bag, pass, passlen)))\\r\\nreturn 0;\\r\\nif (!(pkey = EVP_PKCS82PKEY (p8))) {\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nreturn 0;\\r\\n}\\r\\nprint_attribs (out, p8->attributes, \"Key Attributes\");\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nPEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, pempass);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Certificate bag\\n\");\\r\\nif (options & NOCERTS) return 1;\\r\\nif (PKCS12_get_attr(bag, NID_localKeyID)) {\\r\\nif (options & CACERTS) return 1;\\r\\n} else if (options & CLCERTS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate )\\r\\nreturn 1;\\r\\nif (!(x509 = PKCS12_certbag2x509(bag))) return 0;\\r\\ndump_cert_text (out, x509);\\r\\nPEM_write_bio_X509 (out, x509);\\r\\nX509_free(x509);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Safe Contents bag\\n\");\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nreturn dump_certs_pkeys_bags (out, bag->value.safes, pass,\\r\\npasslen, options, pempass);\\r\\ndefault:\\r\\nBIO_printf (bio_err, \"Warning unsupported bag type: \");\\r\\ni2a_ASN1_OBJECT (bio_err, bag->type);\\r\\nBIO_printf (bio_err, \"\\n\");\\r\\nreturn 1;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint alg_print (BIO *x, X509_ALGOR *alg)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nconst unsigned char *p;\\r\\np = alg->parameter->value.sequence->data;\\r\\npbe = d2i_PBEPARAM (NULL, &p, alg->parameter->value.sequence->length);\\r\\nBIO_printf (bio_err, \"%s, Iteration %ld\\n\",\\r\\nOBJ_nid2ln(OBJ_obj2nid(alg->algorithm)),\\r\\nASN1_INTEGER_get(pbe->iter));\\r\\nPBEPARAM_free (pbe);\\r\\nreturn 0;\\r\\n}\\r\\nvoid hex_prin(BIO *out, unsigned char *buf, int len)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < len; i++) BIO_printf (out, \"%02X \", buf[i]);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_exp_c", "target": 0, "func": "int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint i,bits,ret=0;\\r\\nBIGNUM *v,*rr;\\r\\nif (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)\\r\\n{\\r\\nBNerr(BN_F_BN_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((r == a) || (r == p))\\r\\nrr = BN_CTX_get(ctx);\\r\\nelse\\r\\nrr = r;\\r\\nif ((v = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (BN_copy(v,a) == NULL) goto err;\\r\\nbits=BN_num_bits(p);\\r\\nif (BN_is_odd(p))\\r\\n{ if (BN_copy(rr,a) == NULL) goto err; }\\r\\nelse { if (!BN_one(rr)) goto err; }\\r\\nfor (i=1; i<bits; i++)\\r\\n{\\r\\nif (!BN_sqr(v,v,ctx)) goto err;\\r\\nif (BN_is_bit_set(p,i))\\r\\n{\\r\\nif (!BN_mul(rr,rr,v,ctx)) goto err;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (r != rr) BN_copy(r,rr);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\n#define MONT_MUL_MOD\\r\\n#define MONT_EXP_WORD\\r\\n#define RECP_MUL_MOD\\r\\n#ifdef MONT_MUL_MOD\\r\\nif (BN_is_odd(m))\\r\\n{\\r\\n# ifdef MONT_EXP_WORD\\r\\nif (a->top == 1 && !a->neg && (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) == 0))\\r\\n{\\r\\nBN_ULONG A = a->d[0];\\r\\nret=BN_mod_exp_mont_word(r,A,p,m,ctx,NULL);\\r\\n}\\r\\nelse\\r\\n# endif\\r\\nret=BN_mod_exp_mont(r,a,p,m,ctx,NULL);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifdef RECP_MUL_MOD\\r\\n{ ret=BN_mod_exp_recp(r,a,p,m,ctx); }\\r\\n#else\\r\\n{ ret=BN_mod_exp_simple(r,a,p,m,ctx); }\\r\\n#endif\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue;\\r\\nint start=1;\\r\\nBIGNUM *aa;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nBN_RECP_CTX recp;\\r\\nif (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_RECP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nret = BN_one(r);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\naa = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif(!aa || !val[0]) goto err;\\r\\nBN_RECP_CTX_init(&recp);\\r\\nif (m->neg)\\r\\n{\\r\\nif (!BN_copy(aa, m)) goto err;\\r\\naa->neg = 0;\\r\\nif (BN_RECP_CTX_set(&recp,aa,ctx) <= 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_RECP_CTX_set(&recp,m,ctx) <= 0) goto err;\\r\\n}\\r\\nif (!BN_nnmod(val[0],a,m,ctx)) goto err;\\r\\nif (BN_is_zero(val[0]))\\r\\n{\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1)\\r\\n{\\r\\nif (!BN_mod_mul_reciprocal(aa,val[0],val[0],&recp,ctx))\\r\\ngoto err;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nif(((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_reciprocal(val[i],val[i-1],\\r\\naa,&recp,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_one(r)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\nif (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))\\r\\ngoto err;\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_reciprocal(r,r,val[wvalue>>1],&recp,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nBN_RECP_CTX_free(&recp);\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue;\\r\\nint start=1;\\r\\nBIGNUM *d,*r;\\r\\nconst BIGNUM *aa;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nif (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)\\r\\n{\\r\\nreturn BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\nif (!BN_is_odd(m))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif (!d || !r || !val[0]) goto err;\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n{\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,m,ctx)) goto err;\\r\\n}\\r\\nif (a->neg || BN_ucmp(a,m) >= 0)\\r\\n{\\r\\nif (!BN_nnmod(val[0],a,m,ctx))\\r\\ngoto err;\\r\\naa= val[0];\\r\\n}\\r\\nelse\\r\\naa=a;\\r\\nif (BN_is_zero(aa))\\r\\n{\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val[0],aa,mont,ctx)) goto err;\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(d,val[0],val[0],mont,ctx)) goto err;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nif(((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val[i],val[i-1],\\r\\nd,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_montgomery(r,r,val[wvalue>>1],mont,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nif (!BN_from_montgomery(rr,r,mont,ctx)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MOD_EXP_CTIME_COPY_TO_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)\\r\\n{\\r\\nsize_t i, j;\\r\\nif (bn_wexpand(b, top) == NULL)\\r\\nreturn 0;\\r\\nwhile (b->top < top)\\r\\n{\\r\\nb->d[b->top++] = 0;\\r\\n}\\r\\nfor (i = 0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)\\r\\n{\\r\\nbuf[j] = ((unsigned char*)b->d)[i];\\r\\n}\\r\\nbn_correct_top(b);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top, unsigned char *buf, int idx, int width)\\r\\n{\\r\\nsize_t i, j;\\r\\nif (bn_wexpand(b, top) == NULL)\\r\\nreturn 0;\\r\\nfor (i=0, j=idx; i < top * sizeof b->d[0]; i++, j+=width)\\r\\n{\\r\\n((unsigned char*)b->d)[i] = buf[j];\\r\\n}\\r\\nb->top = top;\\r\\nbn_correct_top(b);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i,bits,ret=0,idx,window,wvalue;\\r\\nint top;\\r\\nBIGNUM *r;\\r\\nconst BIGNUM *aa;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nint numPowers;\\r\\nunsigned char *powerbufFree=NULL;\\r\\nint powerbufLen = 0;\\r\\nunsigned char *powerbuf=NULL;\\r\\nBIGNUM *computeTemp=NULL, *am=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\ntop = m->top;\\r\\nif (!(m->d[0] & 1))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nif (r == NULL) goto err;\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n{\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,m,ctx)) goto err;\\r\\n}\\r\\nwindow = BN_window_bits_for_ctime_exponent_size(bits);\\r\\nnumPowers = 1 << window;\\r\\npowerbufLen = sizeof(m->d[0])*top*numPowers;\\r\\nif ((powerbufFree=(unsigned char*)OPENSSL_malloc(powerbufLen+MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH)) == NULL)\\r\\ngoto err;\\r\\npowerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\\r\\nmemset(powerbuf, 0, powerbufLen);\\r\\nif (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(r, top, powerbuf, 0, numPowers)) goto err;\\r\\ncomputeTemp = BN_CTX_get(ctx);\\r\\nam = BN_CTX_get(ctx);\\r\\nif (computeTemp==NULL || am==NULL) goto err;\\r\\nif (a->neg || BN_ucmp(a,m) >= 0)\\r\\n{\\r\\nif (!BN_mod(am,a,m,ctx))\\r\\ngoto err;\\r\\naa= am;\\r\\n}\\r\\nelse\\r\\naa=a;\\r\\nif (!BN_to_montgomery(am,aa,mont,ctx)) goto err;\\r\\nif (!BN_copy(computeTemp, am)) goto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(am, top, powerbuf, 1, numPowers)) goto err;\\r\\nif (window > 1)\\r\\n{\\r\\nfor (i=2; i<numPowers; i++)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(computeTemp,am,computeTemp,mont,ctx))\\r\\ngoto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(computeTemp, top, powerbuf, i, numPowers)) goto err;\\r\\n}\\r\\n}\\r\\nbits = ((bits+window-1)/window)*window;\\r\\nidx=bits-1;\\r\\nwhile (idx >= 0)\\r\\n{\\r\\nwvalue=0;\\r\\nfor (i=0; i<window; i++,idx--)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx)) goto err;\\r\\nwvalue = (wvalue<<1)+BN_is_bit_set(p,idx);\\r\\n}\\r\\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF(computeTemp, top, powerbuf, wvalue, numPowers)) goto err;\\r\\nif (!BN_mod_mul_montgomery(r,r,computeTemp,mont,ctx)) goto err;\\r\\n}\\r\\nif (!BN_from_montgomery(rr,r,mont,ctx)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nif (powerbuf!=NULL)\\r\\n{\\r\\nOPENSSL_cleanse(powerbuf,powerbufLen);\\r\\nOPENSSL_free(powerbufFree);\\r\\n}\\r\\nif (am!=NULL) BN_clear(am);\\r\\nif (computeTemp!=NULL) BN_clear(computeTemp);\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint b, bits, ret=0;\\r\\nint r_is_one;\\r\\nBN_ULONG w, next_w;\\r\\nBIGNUM *d, *r, *t;\\r\\nBIGNUM *swap_tmp;\\r\\n#define BN_MOD_MUL_WORD(r, w, m) \\\\r\\n(BN_mul_word(r, (w)) && \\\\r\\n( \\\\r\\n(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\\r\\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\\r\\n(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\\r\\nif (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\nif (!BN_is_odd(m))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nif (m->top == 1)\\r\\na %= m->d[0];\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nif (a == 0)\\r\\n{\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif (d == NULL || r == NULL || t == NULL) goto err;\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n{\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont, m, ctx)) goto err;\\r\\n}\\r\\nr_is_one = 1;\\r\\nw = a;\\r\\nfor (b = bits-2; b >= 0; b--)\\r\\n{\\r\\nnext_w = w*w;\\r\\nif ((next_w/w) != w)\\r\\n{\\r\\nif (r_is_one)\\r\\n{\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;\\r\\nr_is_one = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_MOD_MUL_WORD(r, w, m)) goto err;\\r\\n}\\r\\nnext_w = 1;\\r\\n}\\r\\nw = next_w;\\r\\nif (!r_is_one)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err;\\r\\n}\\r\\nif (BN_is_bit_set(p, b))\\r\\n{\\r\\nnext_w = w*a;\\r\\nif ((next_w/a) != w)\\r\\n{\\r\\nif (r_is_one)\\r\\n{\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;\\r\\nr_is_one = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_MOD_MUL_WORD(r, w, m)) goto err;\\r\\n}\\r\\nnext_w = a;\\r\\n}\\r\\nw = next_w;\\r\\n}\\r\\n}\\r\\nif (w != 1)\\r\\n{\\r\\nif (r_is_one)\\r\\n{\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err;\\r\\nr_is_one = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_MOD_MUL_WORD(r, w, m)) goto err;\\r\\n}\\r\\n}\\r\\nif (r_is_one)\\r\\n{\\r\\nif (!BN_one(rr)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_from_montgomery(rr, r, mont, ctx)) goto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue;\\r\\nint start=1;\\r\\nBIGNUM *d;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nif (BN_get_flags(p, BN_FLG_EXP_CONSTTIME) != 0)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_SIMPLE,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nret = BN_one(r);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif(!d || !val[0]) goto err;\\r\\nif (!BN_nnmod(val[0],a,m,ctx)) goto err;\\r\\nif (BN_is_zero(val[0]))\\r\\n{\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1)\\r\\n{\\r\\nif (!BN_mod_mul(d,val[0],val[0],m,ctx))\\r\\ngoto err;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nif(((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul(val[i],val[i-1],d,m,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_one(r)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\nif (!BN_mod_mul(r,r,r,m,ctx))\\r\\ngoto err;\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul(r,r,r,m,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(r,r,val[wvalue>>1],m,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_cpols_c", "target": 0, "func": "static void print_notice(BIO *out, USERNOTICE *notice, int indent)\\r\\n{\\r\\nint i;\\r\\nif(notice->noticeref) {\\r\\nNOTICEREF *ref;\\r\\nref = notice->noticeref;\\r\\nBIO_printf(out, \"%*sOrganization: %s\\n\", indent, \"\",\\r\\nref->organization->data);\\r\\nBIO_printf(out, \"%*sNumber%s: \", indent, \"\",\\r\\nsk_ASN1_INTEGER_num(ref->noticenos) > 1 ? \"s\" : \"\");\\r\\nfor(i = 0; i < sk_ASN1_INTEGER_num(ref->noticenos); i++) {\\r\\nASN1_INTEGER *num;\\r\\nchar *tmp;\\r\\nnum = sk_ASN1_INTEGER_value(ref->noticenos, i);\\r\\nif(i) BIO_puts(out, \", \");\\r\\ntmp = i2s_ASN1_INTEGER(NULL, num);\\r\\nBIO_puts(out, tmp);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\nif(notice->exptext)\\r\\nBIO_printf(out, \"%*sExplicit Text: %s\\n\", indent, \"\",\\r\\nnotice->exptext->data);\\r\\n}\\r\\nvoid X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent)\\r\\n{\\r\\nconst X509_POLICY_DATA *dat = node->data;\\r\\nBIO_printf(out, \"%*sPolicy: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(out, dat->valid_policy);\\r\\nBIO_puts(out, \"\\n\");\\r\\nBIO_printf(out, \"%*s%s\\n\", indent + 2, \"\",\\r\\nnode_data_critical(dat) ? \"Critical\" : \"Non Critical\");\\r\\nif (dat->qualifier_set)\\r\\nprint_qualifiers(out, dat->qualifier_set, indent + 2);\\r\\nelse\\r\\nBIO_printf(out, \"%*sNo Qualifiers\\n\", indent + 2, \"\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_LPdir_vms_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nint status;\\r\\nchar *p, *r;\\r\\nsize_t l;\\r\\nunsigned long flags = 0;\\r\\n#ifdef NAML$C_MAXRSS\\r\\nflags |= LIB$M_FIL_LONG_NAMES;\\r\\n#endif\\r\\nif (ctx == NULL || directory == NULL)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL)\\r\\n{\\r\\nsize_t filespeclen = strlen(directory);\\r\\nchar *filespec = NULL;\\r\\nif (directory[filespeclen-1] != ']'\\r\\n&& directory[filespeclen-1] != '>'\\r\\n&& directory[filespeclen-1] != ':')\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nfilespeclen += 4;\\r\\nif (filespeclen >\\r\\n#ifdef NAML$C_MAXRSS\\r\\nNAML$C_MAXRSS\\r\\n#else\\r\\n255\\r\\n#endif\\r\\n)\\r\\n{\\r\\nerrno = ENAMETOOLONG;\\r\\nreturn 0;\\r\\n}\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL)\\r\\n{\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\nstrcpy((*ctx)->filespec,directory);\\r\\nstrcat((*ctx)->filespec,\"*.*;\");\\r\\n(*ctx)->filespec_dsc.dsc$w_length = filespeclen;\\r\\n(*ctx)->filespec_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\n(*ctx)->filespec_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\n(*ctx)->filespec_dsc.dsc$a_pointer = (*ctx)->filespec;\\r\\n(*ctx)->result_dsc.dsc$w_length = 0;\\r\\n(*ctx)->result_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\n(*ctx)->result_dsc.dsc$b_class = DSC$K_CLASS_D;\\r\\n(*ctx)->result_dsc.dsc$a_pointer = 0;\\r\\n}\\r\\n(*ctx)->result_dsc.dsc$w_length = 0;\\r\\n(*ctx)->result_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\n(*ctx)->result_dsc.dsc$b_class = DSC$K_CLASS_D;\\r\\n(*ctx)->result_dsc.dsc$a_pointer = 0;\\r\\nstatus = lib$find_file(&(*ctx)->filespec_dsc, &(*ctx)->result_dsc,\\r\\n&(*ctx)->VMS_context, 0, 0, 0, &flags);\\r\\nif (status == RMS$_NMF)\\r\\n{\\r\\nerrno = 0;\\r\\nvaxc$errno = status;\\r\\nreturn NULL;\\r\\n}\\r\\nif(!$VMS_STATUS_SUCCESS(status))\\r\\n{\\r\\nerrno = EVMSERR;\\r\\nvaxc$errno = status;\\r\\nreturn NULL;\\r\\n}\\r\\nl = (*ctx)->result_dsc.dsc$w_length;\\r\\np = (*ctx)->result_dsc.dsc$a_pointer;\\r\\nr = p;\\r\\nfor (; *p; p++)\\r\\n{\\r\\nif (*p == '^' && p[1] != '\\0')\\r\\n{\\r\\np++;\\r\\n}\\r\\nelse if (*p == ':' || *p == '>' || *p == ']')\\r\\n{\\r\\nl -= p + 1 - r;\\r\\nr = p + 1;\\r\\n}\\r\\nelse if (*p == ';')\\r\\n{\\r\\nl = p - r;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nstrncpy((*ctx)->result, r, l);\\r\\n(*ctx)->result[l] = '\\0';\\r\\nstr$free1_dx(&(*ctx)->result_dsc);\\r\\nreturn (*ctx)->result;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL)\\r\\n{\\r\\nint status = lib$find_file_end(&(*ctx)->VMS_context);\\r\\nfree(*ctx);\\r\\nif(!$VMS_STATUS_SUCCESS(status))\\r\\n{\\r\\nerrno = EVMSERR;\\r\\nvaxc$errno = status;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecs_vrf_c", "target": 0, "func": "int ECDSA_do_verify(const unsigned char *dgst, int dgst_len,\\r\\nconst ECDSA_SIG *sig, EC_KEY *eckey)\\r\\n{\\r\\nECDSA_DATA *ecdsa = ecdsa_check(eckey);\\r\\nif (ecdsa == NULL)\\r\\nreturn 0;\\r\\nreturn ecdsa->meth->ecdsa_do_verify(dgst, dgst_len, sig, eckey);\\r\\n}\\r\\nint ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\\r\\nconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\\r\\n{\\r\\nECDSA_SIG *s;\\r\\nint ret=-1;\\r\\ns = ECDSA_SIG_new();\\r\\nif (s == NULL) return(ret);\\r\\nif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\\r\\nret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\\r\\nerr:\\r\\nECDSA_SIG_free(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_list_c", "target": 0, "func": "static void engine_list_cleanup(void)\\r\\n{\\r\\nENGINE *iterator = engine_list_head;\\r\\nwhile(iterator != NULL)\\r\\n{\\r\\nENGINE_remove(iterator);\\r\\niterator = engine_list_head;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic int engine_list_add(ENGINE *e)\\r\\n{\\r\\nint conflict = 0;\\r\\nENGINE *iterator = NULL;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\niterator = engine_list_head;\\r\\nwhile(iterator && !conflict)\\r\\n{\\r\\nconflict = (strcmp(iterator->id, e->id) == 0);\\r\\niterator = iterator->next;\\r\\n}\\r\\nif(conflict)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD,\\r\\nENGINE_R_CONFLICTING_ENGINE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nif(engine_list_head == NULL)\\r\\n{\\r\\nif(engine_list_tail)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nengine_list_head = e;\\r\\ne->prev = NULL;\\r\\nengine_cleanup_add_last(engine_list_cleanup);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif((engine_list_tail == NULL) ||\\r\\n(engine_list_tail->next != NULL))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nengine_list_tail->next = e;\\r\\ne->prev = engine_list_tail;\\r\\n}\\r\\ne->struct_ref++;\\r\\nengine_ref_debug(e, 0, 1)\\r\\nengine_list_tail = e;\\r\\ne->next = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int engine_list_remove(ENGINE *e)\\r\\n{\\r\\nENGINE *iterator;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\niterator = engine_list_head;\\r\\nwhile(iterator && (iterator != e))\\r\\niterator = iterator->next;\\r\\nif(iterator == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE,\\r\\nENGINE_R_ENGINE_IS_NOT_IN_LIST);\\r\\nreturn 0;\\r\\n}\\r\\nif(e->next)\\r\\ne->next->prev = e->prev;\\r\\nif(e->prev)\\r\\ne->prev->next = e->next;\\r\\nif(engine_list_head == e)\\r\\nengine_list_head = e->next;\\r\\nif(engine_list_tail == e)\\r\\nengine_list_tail = e->prev;\\r\\nengine_free_util(e, 0);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_first(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_list_head;\\r\\nif(ret)\\r\\n{\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_last(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_list_tail;\\r\\nif(ret)\\r\\n{\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_next(ENGINE *e)\\r\\n{\\r\\nENGINE *ret = NULL;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_NEXT,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = e->next;\\r\\nif(ret)\\r\\n{\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_prev(ENGINE *e)\\r\\n{\\r\\nENGINE *ret = NULL;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_PREV,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = e->prev;\\r\\nif(ret)\\r\\n{\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nint ENGINE_add(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif((e->id == NULL) || (e->name == NULL))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD,\\r\\nENGINE_R_ID_OR_NAME_MISSING);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(!engine_list_add(e))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nto_return = 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn to_return;\\r\\n}\\r\\nint ENGINE_remove(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_REMOVE,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(!engine_list_remove(e))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_REMOVE,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nto_return = 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic void engine_cpy(ENGINE *dest, const ENGINE *src)\\r\\n{\\r\\ndest->id = src->id;\\r\\ndest->name = src->name;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ndest->rsa_meth = src->rsa_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ndest->dsa_meth = src->dsa_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ndest->dh_meth = src->dh_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ndest->ecdh_meth = src->ecdh_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\ndest->ecdsa_meth = src->ecdsa_meth;\\r\\n#endif\\r\\ndest->rand_meth = src->rand_meth;\\r\\ndest->store_meth = src->store_meth;\\r\\ndest->ciphers = src->ciphers;\\r\\ndest->digests = src->digests;\\r\\ndest->destroy = src->destroy;\\r\\ndest->init = src->init;\\r\\ndest->finish = src->finish;\\r\\ndest->ctrl = src->ctrl;\\r\\ndest->load_privkey = src->load_privkey;\\r\\ndest->load_pubkey = src->load_pubkey;\\r\\ndest->cmd_defns = src->cmd_defns;\\r\\ndest->flags = src->flags;\\r\\n}\\r\\nENGINE *ENGINE_by_id(const char *id)\\r\\n{\\r\\nENGINE *iterator;\\r\\nchar *load_dir = NULL;\\r\\nif(id == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\niterator = engine_list_head;\\r\\nwhile(iterator && (strcmp(id, iterator->id) != 0))\\r\\niterator = iterator->next;\\r\\nif(iterator)\\r\\n{\\r\\nif(iterator->flags & ENGINE_FLAGS_BY_ID_COPY)\\r\\n{\\r\\nENGINE *cp = ENGINE_new();\\r\\nif(!cp)\\r\\niterator = NULL;\\r\\nelse\\r\\n{\\r\\nengine_cpy(cp, iterator);\\r\\niterator = cp;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\niterator->struct_ref++;\\r\\nengine_ref_debug(iterator, 0, 1)\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\n#if 0\\r\\nif(iterator == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID,\\r\\nENGINE_R_NO_SUCH_ENGINE);\\r\\nERR_add_error_data(2, \"id=\", id);\\r\\n}\\r\\nreturn iterator;\\r\\n#else\\r\\nif(iterator) return iterator;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nif((load_dir = getenv(\"OPENSSL_ENGINES\")) == 0) load_dir = \"SSLROOT:[ENGINES]\";\\r\\n#else\\r\\nif((load_dir = getenv(\"OPENSSL_ENGINES\")) == 0) load_dir = ENGINESDIR;\\r\\n#endif\\r\\niterator = ENGINE_by_id(\"dynamic\");\\r\\nif(!iterator || !ENGINE_ctrl_cmd_string(iterator, \"ID\", id, 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"DIR_LOAD\", \"2\", 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"DIR_ADD\",\\r\\nload_dir, 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"LOAD\", NULL, 0))\\r\\ngoto notfound;\\r\\nreturn iterator;\\r\\nnotfound:\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID,ENGINE_R_NO_SUCH_ENGINE);\\r\\nERR_add_error_data(2, \"id=\", id);\\r\\nreturn NULL;\\r\\n#endif\\r\\n}\\r\\nint ENGINE_up_ref(ENGINE *e)\\r\\n{\\r\\nif (e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_UP_REF,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&e->struct_ref,1,CRYPTO_LOCK_ENGINE);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_zencod_c", "target": 0, "func": "static inline void esrever ( unsigned char *d, int l )\\r\\n{\\r\\nfor(;--l>0;--l,d++){*d^=*(d+l);*(d+l)^=*d;*d^=*(d+l);}\\r\\n}\\r\\nstatic inline void ypcmem ( unsigned char *d, const unsigned char *s, int l )\\r\\n{\\r\\nfor(d+=l;l--;)*--d=*s++;\\r\\n}\\r\\nstatic __inline void esrever ( unsigned char *d, int l )\\r\\n{\\r\\nfor(;--l>0;--l,d++){*d^=*(d+l);*(d+l)^=*d;*d^=*(d+l);}\\r\\n}\\r\\nstatic __inline void ypcmem ( unsigned char *d, const unsigned char *s, int l )\\r\\n{\\r\\nfor(d+=l;l--;)*--d=*s++;\\r\\n}\\r\\nstatic int bind_helper ( ENGINE *e )\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth_rsa ;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth_dsa ;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth_dh ;\\r\\n#endif\\r\\nconst RAND_METHOD *meth_rand ;\\r\\nif ( !ENGINE_set_id ( e, engine_zencod_id ) ||\\r\\n!ENGINE_set_name ( e, engine_zencod_name ) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA ( e, &zencod_rsa ) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA ( e, &zencod_dsa ) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH ( e, &zencod_dh ) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND ( e, &zencod_rand ) ||\\r\\n!ENGINE_set_destroy_function ( e, zencod_destroy ) ||\\r\\n!ENGINE_set_init_function ( e, zencod_init ) ||\\r\\n!ENGINE_set_finish_function ( e, zencod_finish ) ||\\r\\n!ENGINE_set_ctrl_function ( e, zencod_ctrl ) ||\\r\\n!ENGINE_set_cmd_defns ( e, zencod_cmd_defns ) ||\\r\\n!ENGINE_set_digests ( e, engine_digests ) ||\\r\\n!ENGINE_set_ciphers ( e, engine_ciphers ) ) {\\r\\nreturn 0 ;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth_rsa = RSA_PKCS1_SSLeay () ;\\r\\nzencod_rsa.rsa_pub_enc = meth_rsa->rsa_pub_enc ;\\r\\nzencod_rsa.rsa_pub_dec = meth_rsa->rsa_pub_dec ;\\r\\nzencod_rsa.rsa_priv_enc = meth_rsa->rsa_priv_enc ;\\r\\nzencod_rsa.rsa_priv_dec = meth_rsa->rsa_priv_dec ;\\r\\nzencod_rsa.init = meth_rsa->init ;\\r\\nzencod_rsa.finish = meth_rsa->finish ;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth_dsa = DSA_OpenSSL () ;\\r\\nzencod_dsa.dsa_sign_setup = meth_dsa->dsa_sign_setup ;\\r\\nzencod_dsa.dsa_mod_exp = meth_dsa->dsa_mod_exp ;\\r\\nzencod_dsa.init = meth_dsa->init ;\\r\\nzencod_dsa.finish = meth_dsa->finish ;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth_dh = DH_OpenSSL () ;\\r\\nzencod_dh.init = meth_dh->init ;\\r\\nzencod_dh.finish = meth_dh->finish ;\\r\\n#endif\\r\\nmeth_rand = RAND_SSLeay () ;\\r\\nzencod_rand.cleanup = meth_rand->cleanup ;\\r\\nzencod_rand.add = meth_rand->add ;\\r\\nERR_load_ZENCOD_strings () ;\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic ENGINE *ENGINE_zencod ( void )\\r\\n{\\r\\nENGINE *eng = ENGINE_new () ;\\r\\nif ( !eng ) {\\r\\nreturn NULL ;\\r\\n}\\r\\nif ( !bind_helper ( eng ) ) {\\r\\nENGINE_free ( eng ) ;\\r\\nreturn NULL ;\\r\\n}\\r\\nreturn eng ;\\r\\n}\\r\\nstatic\\r\\n#endif\\r\\nvoid ENGINE_load_zencod ( void )\\r\\n{\\r\\nENGINE *toadd = ENGINE_zencod ( ) ;\\r\\nif ( !toadd ) return ;\\r\\nENGINE_add ( toadd ) ;\\r\\nENGINE_free ( toadd ) ;\\r\\nERR_clear_error ( ) ;\\r\\n}\\r\\nstatic int zencod_destroy (ENGINE *e )\\r\\n{\\r\\nERR_unload_ZENCOD_strings () ;\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int zencod_init ( ENGINE *e )\\r\\n{\\r\\nt_zencod_test *ptr_0 ;\\r\\nt_zencod_bytes2bits *ptr_1 ;\\r\\nt_zencod_bits2bytes *ptr_2 ;\\r\\nt_zencod_new_number *ptr_3 ;\\r\\nt_zencod_init_number *ptr_4 ;\\r\\nt_zencod_rsa_mod_exp *ptr_exp_1 ;\\r\\nt_zencod_rsa_mod_exp_crt *ptr_exp_2 ;\\r\\nt_zencod_dsa_do_sign *ptr_dsa_1 ;\\r\\nt_zencod_dsa_do_verify *ptr_dsa_2 ;\\r\\nt_zencod_dh_generate_key *ptr_dh_1 ;\\r\\nt_zencod_dh_compute_key *ptr_dh_2 ;\\r\\nt_zencod_rand_bytes *ptr_rand_1 ;\\r\\nt_zencod_math_mod_exp *ptr_math_1 ;\\r\\nt_zencod_md5_init *ptr_md5_1 ;\\r\\nt_zencod_md5_update *ptr_md5_2 ;\\r\\nt_zencod_md5_do_final *ptr_md5_3 ;\\r\\nt_zencod_sha1_init *ptr_sha1_1 ;\\r\\nt_zencod_sha1_update *ptr_sha1_2 ;\\r\\nt_zencod_sha1_do_final *ptr_sha1_3 ;\\r\\nt_zencod_xdes_cipher *ptr_xdes_1 ;\\r\\nt_zencod_rc4_cipher *ptr_rc4_1 ;\\r\\nCHEESE () ;\\r\\nif ( zencod_dso != NULL ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_ALREADY_LOADED ) ;\\r\\ngoto err ;\\r\\n}\\r\\nzencod_dso = DSO_load ( NULL, ZENCOD_LIBNAME, NULL, 0 ) ;\\r\\nif ( zencod_dso == NULL ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE ) ;\\r\\ngoto err ;\\r\\n}\\r\\nif ( ! ( ptr_1 = (t_zencod_bytes2bits*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_1 ) ) ||\\r\\n! ( ptr_2 = (t_zencod_bits2bytes*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_2 ) ) ||\\r\\n! ( ptr_3 = (t_zencod_new_number*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_3 ) ) ||\\r\\n! ( ptr_4 = (t_zencod_init_number*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_4 ) ) ||\\r\\n! ( ptr_exp_1 = (t_zencod_rsa_mod_exp*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_exp_1 ) ) ||\\r\\n! ( ptr_exp_2 = (t_zencod_rsa_mod_exp_crt*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_exp_2 ) ) ||\\r\\n! ( ptr_dsa_1 = (t_zencod_dsa_do_sign*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dsa_1 ) ) ||\\r\\n! ( ptr_dsa_2 = (t_zencod_dsa_do_verify*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dsa_2 ) ) ||\\r\\n! ( ptr_dh_1 = (t_zencod_dh_generate_key*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dh_1 ) ) ||\\r\\n! ( ptr_dh_2 = (t_zencod_dh_compute_key*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dh_2 ) ) ||\\r\\n! ( ptr_rand_1 = (t_zencod_rand_bytes*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_rand_1 ) ) ||\\r\\n! ( ptr_math_1 = (t_zencod_math_mod_exp*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_math_1 ) ) ||\\r\\n! ( ptr_0 = (t_zencod_test *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_0 ) ) ||\\r\\n! ( ptr_md5_1 = (t_zencod_md5_init *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_1 ) ) ||\\r\\n! ( ptr_md5_2 = (t_zencod_md5_update *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_2 ) ) ||\\r\\n! ( ptr_md5_3 = (t_zencod_md5_do_final *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_3 ) ) ||\\r\\n! ( ptr_sha1_1 = (t_zencod_sha1_init *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_1 ) ) ||\\r\\n! ( ptr_sha1_2 = (t_zencod_sha1_update *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_2 ) ) ||\\r\\n! ( ptr_sha1_3 = (t_zencod_sha1_do_final *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_3 ) ) ||\\r\\n! ( ptr_xdes_1 = (t_zencod_xdes_cipher *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_xdes_1 ) ) ||\\r\\n! ( ptr_rc4_1 = (t_zencod_rc4_cipher *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_rc4_1 ) ) ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE ) ;\\r\\ngoto err ;\\r\\n}\\r\\nptr_zencod_test = ptr_0 ;\\r\\nptr_zencod_bytes2bits = ptr_1 ;\\r\\nptr_zencod_bits2bytes = ptr_2 ;\\r\\nptr_zencod_new_number = ptr_3 ;\\r\\nptr_zencod_init_number = ptr_4 ;\\r\\nptr_zencod_rsa_mod_exp = ptr_exp_1 ;\\r\\nptr_zencod_rsa_mod_exp_crt = ptr_exp_2 ;\\r\\nptr_zencod_dsa_do_sign = ptr_dsa_1 ;\\r\\nptr_zencod_dsa_do_verify = ptr_dsa_2 ;\\r\\nptr_zencod_dh_generate_key = ptr_dh_1 ;\\r\\nptr_zencod_dh_compute_key = ptr_dh_2 ;\\r\\nptr_zencod_rand_bytes = ptr_rand_1 ;\\r\\nptr_zencod_math_mod_exp = ptr_math_1 ;\\r\\nptr_zencod_test = ptr_0 ;\\r\\nptr_zencod_md5_init = ptr_md5_1 ;\\r\\nptr_zencod_md5_update = ptr_md5_2 ;\\r\\nptr_zencod_md5_do_final = ptr_md5_3 ;\\r\\nptr_zencod_sha1_init = ptr_sha1_1 ;\\r\\nptr_zencod_sha1_update = ptr_sha1_2 ;\\r\\nptr_zencod_sha1_do_final = ptr_sha1_3 ;\\r\\nptr_zencod_xdes_cipher = ptr_xdes_1 ;\\r\\nptr_zencod_rc4_cipher = ptr_rc4_1 ;\\r\\nif ( ptr_zencod_test () != 0 ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_UNIT_FAILURE ) ;\\r\\ngoto err ;\\r\\n}\\r\\nreturn 1 ;\\r\\nerr :\\r\\nif ( zencod_dso ) {\\r\\nDSO_free ( zencod_dso ) ;\\r\\n}\\r\\nzencod_dso = NULL ;\\r\\nptr_zencod_bytes2bits = NULL ;\\r\\nptr_zencod_bits2bytes = NULL ;\\r\\nptr_zencod_new_number = NULL ;\\r\\nptr_zencod_init_number = NULL ;\\r\\nptr_zencod_rsa_mod_exp = NULL ;\\r\\nptr_zencod_rsa_mod_exp_crt = NULL ;\\r\\nptr_zencod_dsa_do_sign = NULL ;\\r\\nptr_zencod_dsa_do_verify = NULL ;\\r\\nptr_zencod_dh_generate_key = NULL ;\\r\\nptr_zencod_dh_compute_key = NULL ;\\r\\nptr_zencod_rand_bytes = NULL ;\\r\\nptr_zencod_math_mod_exp = NULL ;\\r\\nptr_zencod_test = NULL ;\\r\\nptr_zencod_md5_init = NULL ;\\r\\nptr_zencod_md5_update = NULL ;\\r\\nptr_zencod_md5_do_final = NULL ;\\r\\nptr_zencod_sha1_init = NULL ;\\r\\nptr_zencod_sha1_update = NULL ;\\r\\nptr_zencod_sha1_do_final = NULL ;\\r\\nptr_zencod_xdes_cipher = NULL ;\\r\\nptr_zencod_rc4_cipher = NULL ;\\r\\nreturn 0 ;\\r\\n}\\r\\nstatic int zencod_finish ( ENGINE *e )\\r\\n{\\r\\nCHEESE () ;\\r\\nif ( zencod_dso == NULL ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_NOT_LOADED ) ;\\r\\nreturn 0 ;\\r\\n}\\r\\nif ( !DSO_free ( zencod_dso ) ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_DSO_FAILURE ) ;\\r\\nreturn 0 ;\\r\\n}\\r\\nzencod_dso = NULL ;\\r\\nptr_zencod_bytes2bits = NULL ;\\r\\nptr_zencod_bits2bytes = NULL ;\\r\\nptr_zencod_new_number = NULL ;\\r\\nptr_zencod_init_number = NULL ;\\r\\nptr_zencod_rsa_mod_exp = NULL ;\\r\\nptr_zencod_rsa_mod_exp_crt = NULL ;\\r\\nptr_zencod_dsa_do_sign = NULL ;\\r\\nptr_zencod_dsa_do_verify = NULL ;\\r\\nptr_zencod_dh_generate_key = NULL ;\\r\\nptr_zencod_dh_compute_key = NULL ;\\r\\nptr_zencod_rand_bytes = NULL ;\\r\\nptr_zencod_math_mod_exp = NULL ;\\r\\nptr_zencod_test = NULL ;\\r\\nptr_zencod_md5_init = NULL ;\\r\\nptr_zencod_md5_update = NULL ;\\r\\nptr_zencod_md5_do_final = NULL ;\\r\\nptr_zencod_sha1_init = NULL ;\\r\\nptr_zencod_sha1_update = NULL ;\\r\\nptr_zencod_sha1_do_final = NULL ;\\r\\nptr_zencod_xdes_cipher = NULL ;\\r\\nptr_zencod_rc4_cipher = NULL ;\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int zencod_ctrl ( ENGINE *e, int cmd, long i, void *p, void (*f) () )\\r\\n{\\r\\nint initialised = ( ( zencod_dso == NULL ) ? 0 : 1 ) ;\\r\\nCHEESE () ;\\r\\nswitch ( cmd ) {\\r\\ncase ZENCOD_CMD_SO_PATH :\\r\\nif ( p == NULL ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ERR_R_PASSED_NULL_PARAMETER ) ;\\r\\nreturn 0 ;\\r\\n}\\r\\nif ( initialised ) {\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_ALREADY_LOADED ) ;\\r\\nreturn 0 ;\\r\\n}\\r\\nZENCOD_LIBNAME = (const char *) p ;\\r\\nreturn 1 ;\\r\\ndefault :\\r\\nbreak ;\\r\\n}\\r\\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED ) ;\\r\\nreturn 0 ;\\r\\n}\\r\\nstatic int zencod_bn_mod_exp ( BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx )\\r\\n{\\r\\nzen_nb_t y, x, e, n;\\r\\nint ret;\\r\\nCHEESE () ;\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( !bn_wexpand(r, m->top + 1) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);\\r\\nreturn 0;\\r\\n}\\r\\nmemset(r->d, 0, BN_num_bytes(m));\\r\\nptr_zencod_init_number ( &y, (r->dmax - 1) * sizeof (BN_ULONG) * 8, (unsigned char *) r->d ) ;\\r\\nBIGNUM2ZEN ( &x, a ) ;\\r\\nBIGNUM2ZEN ( &e, p ) ;\\r\\nBIGNUM2ZEN ( &n, m ) ;\\r\\nret = ptr_zencod_math_mod_exp ( &y, &e, &x, &n ) ;\\r\\nif ( ret ) {\\r\\nPERROR(\"zenbridge_math_mod_exp\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nr->top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int RSA_zencod_rsa_mod_exp ( BIGNUM *r0, const BIGNUM *i, RSA *rsa )\\r\\n{\\r\\nCHEESE () ;\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( !rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_BAD_KEY_COMPONENTS);\\r\\nreturn 0;\\r\\n}\\r\\nif ( RSA_size(rsa) * 8 > ZENBRIDGE_MAX_KEYSIZE_RSA_CRT ) {\\r\\nconst RSA_METHOD *meth;\\r\\nmeth = RSA_PKCS1_SSLeay();\\r\\nreturn meth->rsa_mod_exp(r0, i, rsa);\\r\\n} else {\\r\\nzen_nb_t y, x, p, q, dmp1, dmq1, iqmp;\\r\\nif ( !bn_expand(r0, RSA_size(rsa) * 8) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_BN_EXPAND_FAIL);\\r\\nreturn 0;\\r\\n}\\r\\nr0->top = (RSA_size(rsa) * 8 + BN_BITS2 - 1) / BN_BITS2;\\r\\nBIGNUM2ZEN ( &x, i ) ;\\r\\nBIGNUM2ZEN ( &y, r0 ) ;\\r\\nBIGNUM2ZEN ( &p, rsa->p ) ;\\r\\nBIGNUM2ZEN ( &q, rsa->q ) ;\\r\\nBIGNUM2ZEN ( &dmp1, rsa->dmp1 ) ;\\r\\nBIGNUM2ZEN ( &dmq1, rsa->dmq1 ) ;\\r\\nBIGNUM2ZEN ( &iqmp, rsa->iqmp ) ;\\r\\nif ( ptr_zencod_rsa_mod_exp_crt ( &y, &x, &p, &q, &dmp1, &dmq1, &iqmp ) < 0 ) {\\r\\nPERROR(\"zenbridge_rsa_mod_exp_crt\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nstatic int RSA_zencod_bn_mod_exp ( BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx )\\r\\n{\\r\\nCHEESE () ;\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( BN_num_bits(m) > ZENBRIDGE_MAX_KEYSIZE_RSA ) {\\r\\nconst RSA_METHOD *meth;\\r\\nmeth = RSA_PKCS1_SSLeay();\\r\\nreturn meth->bn_mod_exp(r, a, p, m, ctx, m_ctx);\\r\\n} else {\\r\\nzen_nb_t y, x, e, n;\\r\\nif ( !bn_expand(r, BN_num_bits(m)) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);\\r\\nreturn 0;\\r\\n}\\r\\nr->top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;\\r\\nBIGNUM2ZEN ( &x, a ) ;\\r\\nBIGNUM2ZEN ( &y, r ) ;\\r\\nBIGNUM2ZEN ( &e, p ) ;\\r\\nBIGNUM2ZEN ( &n, m ) ;\\r\\nif ( ptr_zencod_rsa_mod_exp ( &y, &x, &n, &e ) < 0 ) {\\r\\nPERROR(\"zenbridge_rsa_mod_exp\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nstatic DSA_SIG *DSA_zencod_do_sign ( const unsigned char *dgst, int dlen, DSA *dsa )\\r\\n{\\r\\nzen_nb_t p, q, g, x, y, r, s, data;\\r\\nDSA_SIG *sig;\\r\\nBIGNUM *bn_r = NULL;\\r\\nBIGNUM *bn_s = NULL;\\r\\nchar msg[20];\\r\\nCHEESE();\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_NOT_LOADED);\\r\\ngoto FAILED;\\r\\n}\\r\\nif ( dlen > 160 ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\\r\\ngoto FAILED;\\r\\n}\\r\\nif ( BN_num_bits(dsa->p) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||\\r\\nBN_num_bits(dsa->g) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ) {\\r\\nconst DSA_METHOD *meth;\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\\r\\nmeth = DSA_OpenSSL();\\r\\nreturn meth->dsa_do_sign(dgst, dlen, dsa);\\r\\n}\\r\\nif ( !(bn_s = BN_new()) || !(bn_r = BN_new()) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\\r\\ngoto FAILED;\\r\\n}\\r\\nif ( !bn_expand(bn_r, 160) || !bn_expand(bn_s, 160) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BN_EXPAND_FAIL);\\r\\ngoto FAILED;\\r\\n}\\r\\nbn_r->top = bn_s->top = (160 + BN_BITS2 - 1) / BN_BITS2;\\r\\nBIGNUM2ZEN ( &p, dsa->p ) ;\\r\\nBIGNUM2ZEN ( &q, dsa->q ) ;\\r\\nBIGNUM2ZEN ( &g, dsa->g ) ;\\r\\nBIGNUM2ZEN ( &x, dsa->priv_key ) ;\\r\\nBIGNUM2ZEN ( &y, dsa->pub_key ) ;\\r\\nBIGNUM2ZEN ( &r, bn_r ) ;\\r\\nBIGNUM2ZEN ( &s, bn_s ) ;\\r\\nq.len = x.len = 160;\\r\\nypcmem(msg, dgst, 20);\\r\\nptr_zencod_init_number ( &data, 160, msg ) ;\\r\\nif ( ptr_zencod_dsa_do_sign ( 0, &data, &y, &p, &q, &g, &x, &r, &s ) < 0 ) {\\r\\nPERROR(\"zenbridge_dsa_do_sign\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\\r\\ngoto FAILED;\\r\\n}\\r\\nif ( !( sig = DSA_SIG_new () ) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\\r\\ngoto FAILED;\\r\\n}\\r\\nsig->r = bn_r;\\r\\nsig->s = bn_s;\\r\\nreturn sig;\\r\\nFAILED:\\r\\nif (bn_r)\\r\\nBN_free(bn_r);\\r\\nif (bn_s)\\r\\nBN_free(bn_s);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int DSA_zencod_do_verify ( const unsigned char *dgst, int dlen, DSA_SIG *sig, DSA *dsa )\\r\\n{\\r\\nzen_nb_t data, p, q, g, y, r, s, v;\\r\\nchar msg[20];\\r\\nchar v_data[20];\\r\\nint ret;\\r\\nCHEESE();\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( dlen > 160 ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( BN_num_bits(dsa->p) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||\\r\\nBN_num_bits(dsa->g) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ) {\\r\\nconst DSA_METHOD *meth;\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\\r\\nmeth = DSA_OpenSSL();\\r\\nreturn meth->dsa_do_verify(dgst, dlen, sig, dsa);\\r\\n}\\r\\nBIGNUM2ZEN ( &p, dsa->p ) ;\\r\\nBIGNUM2ZEN ( &q, dsa->q ) ;\\r\\nBIGNUM2ZEN ( &g, dsa->g ) ;\\r\\nBIGNUM2ZEN ( &y, dsa->pub_key ) ;\\r\\nBIGNUM2ZEN ( &r, sig->r ) ;\\r\\nBIGNUM2ZEN ( &s, sig->s ) ;\\r\\nptr_zencod_init_number ( &v, 160, v_data ) ;\\r\\nypcmem(msg, dgst, 20);\\r\\nptr_zencod_init_number ( &data, 160, msg ) ;\\r\\nif ( ( ret = ptr_zencod_dsa_do_verify ( 0, &data, &p, &q, &g, &y, &r, &s, &v ) ) < 0 ) {\\r\\nPERROR(\"zenbridge_dsa_do_verify\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ( ( ret == 0 ) ? 1 : ret ) ;\\r\\n}\\r\\nstatic int DSA_zencod_bn_mod_exp ( DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *m_ctx )\\r\\n{\\r\\nCHEESE () ;\\r\\nreturn zencod_bn_mod_exp ( r, a, p, m, ctx ) ;\\r\\n}\\r\\nstatic int DH_zencod_generate_key ( DH *dh )\\r\\n{\\r\\nBIGNUM *bn_prv = NULL;\\r\\nBIGNUM *bn_pub = NULL;\\r\\nzen_nb_t y, x, g, p;\\r\\nint generate_x;\\r\\nCHEESE();\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( dh->priv_key ) {\\r\\nbn_prv = dh->priv_key;\\r\\ngenerate_x = 0;\\r\\n} else {\\r\\nif (!(bn_prv = BN_new())) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\\r\\ngoto FAILED;\\r\\n}\\r\\ngenerate_x = 1;\\r\\n}\\r\\nif ( dh->pub_key )\\r\\nbn_pub = dh->pub_key;\\r\\nelse\\r\\nif ( !( bn_pub = BN_new () ) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\\r\\ngoto FAILED;\\r\\n}\\r\\nif ( !bn_wexpand ( bn_prv, dh->p->dmax ) ||\\r\\n!bn_wexpand ( bn_pub, dh->p->dmax ) ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\\r\\ngoto FAILED;\\r\\n}\\r\\nbn_prv->top = dh->p->top;\\r\\nbn_pub->top = dh->p->top;\\r\\nBIGNUM2ZEN ( &p, dh->p ) ;\\r\\nBIGNUM2ZEN ( &g, dh->g ) ;\\r\\nBIGNUM2ZEN ( &y, bn_pub ) ;\\r\\nBIGNUM2ZEN ( &x, bn_prv ) ;\\r\\nx.len = DH_size(dh) * 8;\\r\\np.len = ptr_zencod_bytes2bits ( p.data, ZEN_BYTES ( p.len ) ) ;\\r\\ng.len = ptr_zencod_bytes2bits ( g.data, ZEN_BYTES ( g.len ) ) ;\\r\\nif ( ptr_zencod_dh_generate_key ( &y, &x, &g, &p, generate_x ) < 0 ) {\\r\\nperror(\"zenbridge_dh_generate_key\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_REQUEST_FAILED);\\r\\ngoto FAILED;\\r\\n}\\r\\ndh->priv_key = bn_prv;\\r\\ndh->pub_key = bn_pub;\\r\\nreturn 1;\\r\\nFAILED:\\r\\nif (!dh->priv_key && bn_prv)\\r\\nBN_free(bn_prv);\\r\\nif (!dh->pub_key && bn_pub)\\r\\nBN_free(bn_pub);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int DH_zencod_compute_key ( unsigned char *key, const BIGNUM *pub_key, DH *dh )\\r\\n{\\r\\nzen_nb_t y, x, p, k;\\r\\nCHEESE();\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif ( !dh->priv_key ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_BAD_KEY_COMPONENTS);\\r\\nreturn 0;\\r\\n}\\r\\nBIGNUM2ZEN ( &y, pub_key ) ;\\r\\nBIGNUM2ZEN ( &x, dh->priv_key ) ;\\r\\nBIGNUM2ZEN ( &p, dh->p ) ;\\r\\nptr_zencod_init_number ( &k, p.len, key ) ;\\r\\np.len = ptr_zencod_bytes2bits ( p.data, ZEN_BYTES ( p.len ) ) ;\\r\\ny.len = ptr_zencod_bytes2bits ( y.data, ZEN_BYTES ( y.len ) ) ;\\r\\nx.len = ptr_zencod_bytes2bits ( x.data, ZEN_BYTES ( x.len ) ) ;\\r\\nif ( ptr_zencod_dh_compute_key ( &k, &y, &x, &p ) < 0 ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nk.len = ptr_zencod_bytes2bits ( k.data, ZEN_BYTES ( k.len ) ) ;\\r\\nesrever ( key, ZEN_BYTES ( k.len ) ) ;\\r\\nreturn ZEN_BYTES ( k.len ) ;\\r\\n}\\r\\nstatic int DH_zencod_bn_mod_exp ( const DH *dh, BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx )\\r\\n{\\r\\nCHEESE () ;\\r\\nreturn zencod_bn_mod_exp ( r, a, p, m, ctx ) ;\\r\\n}\\r\\nstatic void RAND_zencod_seed ( const void *buf, int num )\\r\\n{\\r\\n}\\r\\nstatic int RAND_zencod_rand_bytes ( unsigned char *buf, int num )\\r\\n{\\r\\nzen_nb_t r;\\r\\nCHEESE();\\r\\nif ( !zencod_dso ) {\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nptr_zencod_init_number ( &r, num * 8, buf ) ;\\r\\nif ( ptr_zencod_rand_bytes ( &r, ZENBRIDGE_RNG_DIRECT ) < 0 ) {\\r\\nPERROR(\"zenbridge_rand_bytes\");\\r\\nENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_REQUEST_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int RAND_zencod_rand_status ( void )\\r\\n{\\r\\nCHEESE () ;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_fn ( ENGINE *e, const char *id )\\r\\n{\\r\\nif ( id && ( strcmp ( id, engine_zencod_id ) != 0 ) ) {\\r\\nreturn 0 ;\\r\\n}\\r\\nif ( !bind_helper ( e ) ) {\\r\\nreturn 0 ;\\r\\n}\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int engine_digests ( ENGINE *e, const EVP_MD **digest, const int **nids, int nid )\\r\\n{\\r\\n#ifdef DEBUG_ZENCOD_MD\\r\\nfprintf ( stderr, \"\\t=>Function : static int engine_digests () called !\\n\" ) ;\\r\\n#endif\\r\\nif ( !digest ) {\\r\\n*nids = engine_digest_nids ;\\r\\nreturn engine_digest_nids_num ;\\r\\n}\\r\\nif ( nid == NID_md5 ) {\\r\\n*digest = &engine_md5_md ;\\r\\n}\\r\\nelse if ( nid == NID_sha1 ) {\\r\\n*digest = &engine_sha1_md ;\\r\\n}\\r\\nelse {\\r\\n*digest = NULL ;\\r\\nreturn 0 ;\\r\\n}\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int engine_sha1_init ( EVP_MD_CTX *ctx )\\r\\n{\\r\\nint to_return = 0 ;\\r\\nto_return = ptr_zencod_sha1_init ( (ZEN_MD_DATA *) ctx->md_data ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_sha1_update ( EVP_MD_CTX *ctx, const void *data, unsigned long count )\\r\\n{\\r\\nzen_nb_t input ;\\r\\nint to_return = 0 ;\\r\\ninput.len = count ;\\r\\ninput.data = (unsigned char *) data ;\\r\\nto_return = ptr_zencod_sha1_update ( (ZEN_MD_DATA *) ctx->md_data, (const zen_nb_t *) &input ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_sha1_final ( EVP_MD_CTX *ctx, unsigned char *md )\\r\\n{\\r\\nzen_nb_t output ;\\r\\nint to_return = 0 ;\\r\\noutput.len = SHA_DIGEST_LENGTH ;\\r\\noutput.data = md ;\\r\\nto_return = ptr_zencod_sha1_do_final ( (ZEN_MD_DATA *) ctx->md_data, (zen_nb_t *) &output ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_md5_init ( EVP_MD_CTX *ctx )\\r\\n{\\r\\nint to_return = 0 ;\\r\\nto_return = ptr_zencod_md5_init ( (ZEN_MD_DATA *) ctx->md_data ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_md5_update ( EVP_MD_CTX *ctx, const void *data, unsigned long count )\\r\\n{\\r\\nzen_nb_t input ;\\r\\nint to_return = 0 ;\\r\\ninput.len = count ;\\r\\ninput.data = (unsigned char *) data ;\\r\\nto_return = ptr_zencod_md5_update ( (ZEN_MD_DATA *) ctx->md_data, (const zen_nb_t *) &input ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_md5_final ( EVP_MD_CTX *ctx, unsigned char *md )\\r\\n{\\r\\nzen_nb_t output ;\\r\\nint to_return = 0 ;\\r\\noutput.len = MD5_DIGEST_LENGTH ;\\r\\noutput.data = md ;\\r\\nto_return = ptr_zencod_md5_do_final ( (ZEN_MD_DATA *) ctx->md_data, (zen_nb_t *) &output ) ;\\r\\nto_return = !to_return ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_md_cleanup ( EVP_MD_CTX *ctx )\\r\\n{\\r\\nZEN_MD_DATA *zen_md_data = (ZEN_MD_DATA *) ctx->md_data ;\\r\\nif ( zen_md_data->HashBuffer != NULL ) {\\r\\nOPENSSL_free ( zen_md_data->HashBuffer ) ;\\r\\nzen_md_data->HashBufferSize = 0 ;\\r\\nctx->md_data = NULL ;\\r\\n}\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int engine_md_copy ( EVP_MD_CTX *to, const EVP_MD_CTX *from )\\r\\n{\\r\\nconst ZEN_MD_DATA *from_md = (ZEN_MD_DATA *) from->md_data ;\\r\\nZEN_MD_DATA *to_md = (ZEN_MD_DATA *) to->md_data ;\\r\\nto_md->HashBuffer = OPENSSL_malloc ( from_md->HashBufferSize ) ;\\r\\nmemcpy ( to_md->HashBuffer, from_md->HashBuffer, from_md->HashBufferSize ) ;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int engine_ciphers ( ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid )\\r\\n{\\r\\nif ( !cipher ) {\\r\\n*nids = engine_cipher_nids ;\\r\\nreturn engine_cipher_nids_num ;\\r\\n}\\r\\nif ( nid == NID_rc4 ) {\\r\\n*cipher = &engine_rc4 ;\\r\\n}\\r\\nelse if ( nid == NID_rc4_40 ) {\\r\\n*cipher = &engine_rc4_40 ;\\r\\n}\\r\\nelse if ( nid == NID_des_cbc ) {\\r\\n*cipher = &engine_des_cbc ;\\r\\n}\\r\\nelse if ( nid == NID_des_ede3_cbc ) {\\r\\n*cipher = &engine_des_ede3_cbc ;\\r\\n}\\r\\nelse {\\r\\n*cipher = NULL ;\\r\\nreturn 0 ;\\r\\n}\\r\\nreturn 1 ;\\r\\n}\\r\\nstatic int engine_rc4_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\\r\\n{\\r\\nint to_return = 0 ;\\r\\nint i = 0 ;\\r\\nint nb = 0 ;\\r\\nNEW_ZEN_RC4_KEY *tmp_rc4_key = NULL ;\\r\\ntmp_rc4_key = (NEW_ZEN_RC4_KEY *) ( ctx->cipher_data ) ;\\r\\ntmp_rc4_key->first = 0 ;\\r\\ntmp_rc4_key->len = ctx->key_len ;\\r\\ntmp_rc4_key->rc4_state [ 0 ] = 0x00 ;\\r\\ntmp_rc4_key->rc4_state [ 2 ] = 0x00 ;\\r\\nnb = 256 / ctx->key_len ;\\r\\nfor ( i = 0; i < nb ; i++ ) {\\r\\nmemcpy ( &( tmp_rc4_key->rc4_state [ 4 + i*ctx->key_len ] ), key, ctx->key_len ) ;\\r\\n}\\r\\nto_return = 1 ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_rc4_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int in_len )\\r\\n{\\r\\nzen_nb_t output, input ;\\r\\nzen_nb_t rc4key ;\\r\\nint to_return = 0 ;\\r\\nNEW_ZEN_RC4_KEY *tmp_rc4_key = NULL ;\\r\\ninput.len = in_len ;\\r\\ninput.data = (unsigned char *) in ;\\r\\noutput.len = in_len ;\\r\\noutput.data = (unsigned char *) out ;\\r\\ntmp_rc4_key = ( (NEW_ZEN_RC4_KEY *) ( ctx->cipher_data ) ) ;\\r\\nrc4key.len = 260 ;\\r\\nrc4key.data = &( tmp_rc4_key->rc4_state [ 0 ] ) ;\\r\\nto_return = ptr_zencod_rc4_cipher ( &output, &input, (const zen_nb_t *) &rc4key, &( tmp_rc4_key->rc4_state [0] ), &( tmp_rc4_key->rc4_state [3] ), !tmp_rc4_key->first ) ;\\r\\nto_return = !to_return ;\\r\\ntmp_rc4_key->first = 1 ;\\r\\ntmp_rc4_key = NULL ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_des_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\\r\\n{\\r\\nZEN_DES_KEY *tmp_des_key = NULL ;\\r\\nint to_return = 0 ;\\r\\ntmp_des_key = (ZEN_DES_KEY *) ( ctx->cipher_data ) ;\\r\\nmemcpy ( &( tmp_des_key->des_key [ 0 ] ), key, 8 ) ;\\r\\nmemcpy ( &( tmp_des_key->des_key [ 8 ] ), key, 8 ) ;\\r\\nmemcpy ( &( tmp_des_key->des_key [ 16 ] ), key, 8 ) ;\\r\\nmemcpy ( &( tmp_des_key->des_iv [ 0 ] ), iv, 8 ) ;\\r\\nto_return = 1 ;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_des_cbc_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl )\\r\\n{\\r\\nzen_nb_t output, input ;\\r\\nzen_nb_t deskey_1, deskey_2, deskey_3, iv ;\\r\\nint to_return = 0 ;\\r\\ninput.len = inl ;\\r\\ninput.data = (unsigned char *) in ;\\r\\noutput.len = inl ;\\r\\noutput.data = out ;\\r\\ndeskey_1.len = 8 ;\\r\\ndeskey_2.len = 8 ;\\r\\ndeskey_3.len = 8 ;\\r\\ndeskey_1.data = (unsigned char *) ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key ;\\r\\ndeskey_2.data = (unsigned char *) &( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key [ 8 ] ;\\r\\ndeskey_3.data = (unsigned char *) &( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key [ 16 ] ;\\r\\nmemcpy ( ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_iv, ctx->iv, 8 ) ;\\r\\niv.len = 8 ;\\r\\niv.data = (unsigned char *) ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_iv ;\\r\\nif ( ctx->encrypt == 0 ) {\\r\\nmemcpy ( ctx->iv, &( input.data [ input.len - 8 ] ), 8 ) ;\\r\\n}\\r\\nto_return = ptr_zencod_xdes_cipher ( &output, &input,\\r\\n(zen_nb_t *) &deskey_1, (zen_nb_t *) &deskey_2, (zen_nb_t *) &deskey_3, &iv, ctx->encrypt ) ;\\r\\nto_return = !to_return ;\\r\\nif ( ctx->encrypt == 1 ) {\\r\\nmemcpy ( ctx->iv, &( output.data [ output.len - 8 ] ), 8 ) ;\\r\\n}\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_des_ede3_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\\r\\n{\\r\\nZEN_3DES_KEY *tmp_3des_key = NULL ;\\r\\nint to_return = 0 ;\\r\\ntmp_3des_key = (ZEN_3DES_KEY *) ( ctx->cipher_data ) ;\\r\\nmemcpy ( &( tmp_3des_key->des3_key [ 0 ] ), key, 24 ) ;\\r\\nmemcpy ( &( tmp_3des_key->des3_iv [ 0 ] ), iv, 8 ) ;\\r\\nto_return = 1;\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_des_ede3_cbc_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in,\\r\\nunsigned int in_len )\\r\\n{\\r\\nzen_nb_t output, input ;\\r\\nzen_nb_t deskey_1, deskey_2, deskey_3, iv ;\\r\\nint to_return = 0 ;\\r\\ninput.len = in_len ;\\r\\ninput.data = (unsigned char *) in ;\\r\\noutput.len = in_len ;\\r\\noutput.data = out ;\\r\\ndeskey_1.len = 8 ;\\r\\ndeskey_2.len = 8 ;\\r\\ndeskey_3.len = 8 ;\\r\\ndeskey_1.data = (unsigned char *) ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key ;\\r\\ndeskey_2.data = (unsigned char *) &( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key [ 8 ] ;\\r\\ndeskey_3.data = (unsigned char *) &( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key [ 16 ] ;\\r\\nmemcpy ( ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_iv, ctx->iv, 8 ) ;\\r\\niv.len = 8 ;\\r\\niv.data = (unsigned char *) ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_iv ;\\r\\nif ( ctx->encrypt == 0 ) {\\r\\nmemcpy ( ctx->iv, &( input.data [ input.len - 8 ] ), 8 ) ;\\r\\n}\\r\\nto_return = ptr_zencod_xdes_cipher ( &output, &input,\\r\\n(zen_nb_t *) &deskey_1, (zen_nb_t *) &deskey_2, (zen_nb_t *) &deskey_3, &iv, ctx->encrypt ) ;\\r\\nto_return = !to_return ;\\r\\nif ( ctx->encrypt == 1 ) {\\r\\nmemcpy ( ctx->iv, &( output.data [ output.len - 8 ] ), 8 ) ;\\r\\n}\\r\\nreturn to_return ;\\r\\n}\\r\\nstatic int engine_cipher_cleanup ( EVP_CIPHER_CTX *ctx )\\r\\n{\\r\\nif ( ctx->cipher->nid == NID_rc4 || ctx->cipher->nid == NID_rc4_40 ) {\\r\\n}\\r\\nelse if ( ctx->cipher->nid == NID_des_cbc ) {\\r\\n}\\r\\nelse if ( ctx->cipher->nid == NID_des_ede3_cbc ) {\\r\\n}\\r\\nreturn 1 ;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha256t_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nprintf(\"No SHA256 support\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nint main ()\\r\\n{ unsigned char md[SHA256_DIGEST_LENGTH];\\r\\nint i;\\r\\nEVP_MD_CTX evp;\\r\\nfprintf(stdout,\"Testing SHA-256 \");\\r\\nEVP_Digest (\"abc\",3,md,NULL,EVP_sha256(),NULL);\\r\\nif (memcmp(md,app_b1,sizeof(app_b1)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 1 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_Digest (\"abcdbcde\"\"cdefdefg\"\"efghfghi\"\"ghijhijk\"\\r\\n\"ijkljklm\"\"klmnlmno\"\"mnopnopq\",56,md,NULL,EVP_sha256(),NULL);\\r\\nif (memcmp(md,app_b2,sizeof(app_b2)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 2 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_MD_CTX_init (&evp);\\r\\nEVP_DigestInit_ex (&evp,EVP_sha256(),NULL);\\r\\nfor (i=0;i<1000000;i+=160)\\r\\nEVP_DigestUpdate (&evp, \"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\",\\r\\n(1000000-i)<160?1000000-i:160);\\r\\nEVP_DigestFinal_ex (&evp,md,NULL);\\r\\nEVP_MD_CTX_cleanup (&evp);\\r\\nif (memcmp(md,app_b3,sizeof(app_b3)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 3 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nfprintf(stdout,\" passed.\\n\"); fflush(stdout);\\r\\nfprintf(stdout,\"Testing SHA-224 \");\\r\\nEVP_Digest (\"abc\",3,md,NULL,EVP_sha224(),NULL);\\r\\nif (memcmp(md,addenum_1,sizeof(addenum_1)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 1 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_Digest (\"abcdbcde\"\"cdefdefg\"\"efghfghi\"\"ghijhijk\"\\r\\n\"ijkljklm\"\"klmnlmno\"\"mnopnopq\",56,md,NULL,EVP_sha224(),NULL);\\r\\nif (memcmp(md,addenum_2,sizeof(addenum_2)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 2 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_MD_CTX_init (&evp);\\r\\nEVP_DigestInit_ex (&evp,EVP_sha224(),NULL);\\r\\nfor (i=0;i<1000000;i+=64)\\r\\nEVP_DigestUpdate (&evp, \"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\",\\r\\n(1000000-i)<64?1000000-i:64);\\r\\nEVP_DigestFinal_ex (&evp,md,NULL);\\r\\nEVP_MD_CTX_cleanup (&evp);\\r\\nif (memcmp(md,addenum_3,sizeof(addenum_3)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 3 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nfprintf(stdout,\" passed.\\n\""
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_asn1_c", "target": 0, "func": "static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(operation == ASN1_OP_NEW_PRE) {\\r\\nDSA_SIG *sig;\\r\\nsig = OPENSSL_malloc(sizeof(DSA_SIG));\\r\\nsig->r = NULL;\\r\\nsig->s = NULL;\\r\\n*pval = (ASN1_VALUE *)sig;\\r\\nif(sig) return 2;\\r\\nDSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_4758cca_c", "target": 0, "func": "static const char *get_CCA4758_LIB_NAME(void)\\r\\n{\\r\\nif(CCA4758_LIB_NAME)\\r\\nreturn CCA4758_LIB_NAME;\\r\\nreturn CCA_LIB_NAME;\\r\\n}\\r\\nstatic void free_CCA4758_LIB_NAME(void)\\r\\n{\\r\\nif(CCA4758_LIB_NAME)\\r\\nOPENSSL_free((void*)CCA4758_LIB_NAME);\\r\\nCCA4758_LIB_NAME = NULL;\\r\\n}\\r\\nstatic long set_CCA4758_LIB_NAME(const char *name)\\r\\n{\\r\\nfree_CCA4758_LIB_NAME();\\r\\nreturn (((CCA4758_LIB_NAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e)\\r\\n{\\r\\nif(!ENGINE_set_id(e, engine_4758_cca_id) ||\\r\\n!ENGINE_set_name(e, engine_4758_cca_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &ibm_4758_cca_rsa) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &ibm_4758_cca_rand) ||\\r\\n!ENGINE_set_destroy_function(e, ibm_4758_cca_destroy) ||\\r\\n!ENGINE_set_init_function(e, ibm_4758_cca_init) ||\\r\\n!ENGINE_set_finish_function(e, ibm_4758_cca_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, ibm_4758_cca_ctrl) ||\\r\\n!ENGINE_set_load_privkey_function(e, ibm_4758_load_privkey) ||\\r\\n!ENGINE_set_load_pubkey_function(e, ibm_4758_load_pubkey) ||\\r\\n!ENGINE_set_cmd_defns(e, cca4758_cmd_defns))\\r\\nreturn 0;\\r\\nERR_load_CCA4758_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_4758_cca(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_4758cca(void)\\r\\n{\\r\\nENGINE *e_4758 = engine_4758_cca();\\r\\nif (!e_4758) return;\\r\\nENGINE_add(e_4758);\\r\\nENGINE_free(e_4758);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int ibm_4758_cca_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_CCA4758_strings();\\r\\nfree_CCA4758_LIB_NAME();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ibm_4758_cca_init(ENGINE *e)\\r\\n{\\r\\nif(dso)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\ndso = DSO_load(NULL, get_CCA4758_LIB_NAME(), NULL, 0);\\r\\nif(!dso)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif(!(keyRecordRead = (F_KEYRECORDREAD)\\r\\nDSO_bind_func(dso, n_keyRecordRead)) ||\\r\\n!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)\\r\\nDSO_bind_func(dso, n_randomNumberGenerate)) ||\\r\\n!(digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)\\r\\nDSO_bind_func(dso, n_digitalSignatureGenerate)) ||\\r\\n!(digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)\\r\\nDSO_bind_func(dso, n_digitalSignatureVerify)) ||\\r\\n!(publicKeyExtract = (F_PUBLICKEYEXTRACT)\\r\\nDSO_bind_func(dso, n_publicKeyExtract)) ||\\r\\n!(pkaEncrypt = (F_PKAENCRYPT)\\r\\nDSO_bind_func(dso, n_pkaEncrypt)) ||\\r\\n!(pkaDecrypt = (F_PKADECRYPT)\\r\\nDSO_bind_func(dso, n_pkaDecrypt)))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#else\\r\\nif(!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)\\r\\nDSO_bind_func(dso, n_randomNumberGenerate)))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nhndidx = RSA_get_ex_new_index(0, \"IBM 4758 CCA RSA key handle\",\\r\\nNULL, NULL, cca_ex_free);\\r\\nreturn 1;\\r\\nerr:\\r\\nif(dso)\\r\\nDSO_free(dso);\\r\\ndso = NULL;\\r\\nkeyRecordRead = (F_KEYRECORDREAD)0;\\r\\nrandomNumberGenerate = (F_RANDOMNUMBERGENERATE)0;\\r\\ndigitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)0;\\r\\ndigitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;\\r\\npublicKeyExtract = (F_PUBLICKEYEXTRACT)0;\\r\\npkaEncrypt = (F_PKAENCRYPT)0;\\r\\npkaDecrypt = (F_PKADECRYPT)0;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ibm_4758_cca_finish(ENGINE *e)\\r\\n{\\r\\nfree_CCA4758_LIB_NAME();\\r\\nif(!dso)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_FINISH,\\r\\nCCA4758_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(dso))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_FINISH,\\r\\nCCA4758_R_UNIT_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ndso = NULL;\\r\\nkeyRecordRead = (F_KEYRECORDREAD)0;\\r\\nrandomNumberGenerate = (F_RANDOMNUMBERGENERATE)0;\\r\\ndigitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)0;\\r\\ndigitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;\\r\\npublicKeyExtract = (F_PUBLICKEYEXTRACT)0;\\r\\npkaEncrypt = (F_PKAENCRYPT)0;\\r\\npkaDecrypt = (F_PKADECRYPT)0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ibm_4758_cca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase CCA4758_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\\r\\nCCA4758_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_CCA4758_LIB_NAME((const char *)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\\r\\nCCA4758_R_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic EVP_PKEY *ibm_4758_load_privkey(ENGINE* e, const char* key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nRSA *rtmp = NULL;\\r\\nEVP_PKEY *res = NULL;\\r\\nunsigned char* keyToken = NULL;\\r\\nunsigned char pubKeyToken[MAX_CCA_PKA_TOKEN_SIZE];\\r\\nlong pubKeyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\\r\\nlong keyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong exitDataLength = 0;\\r\\nlong ruleArrayLength = 0;\\r\\nunsigned char exitData[8];\\r\\nunsigned char ruleArray[8];\\r\\nunsigned char keyLabel[64];\\r\\nunsigned long keyLabelLength = strlen(key_id);\\r\\nunsigned char modulus[256];\\r\\nlong modulusFieldLength = sizeof(modulus);\\r\\nlong modulusLength = 0;\\r\\nunsigned char exponent[256];\\r\\nlong exponentLength = sizeof(exponent);\\r\\nif (keyLabelLength > sizeof(keyLabel))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(keyLabel,' ', sizeof(keyLabel));\\r\\nmemcpy(keyLabel, key_id, keyLabelLength);\\r\\nkeyToken = OPENSSL_malloc(MAX_CCA_PKA_TOKEN_SIZE + sizeof(long));\\r\\nif (!keyToken)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nkeyRecordRead(&returnCode, &reasonCode, &exitDataLength,\\r\\nexitData, &ruleArrayLength, ruleArray, keyLabel,\\r\\n&keyTokenLength, keyToken+sizeof(long));\\r\\nif (returnCode)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\\r\\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\npublicKeyExtract(&returnCode, &reasonCode, &exitDataLength,\\r\\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\\r\\nkeyToken+sizeof(long), &pubKeyTokenLength, pubKeyToken);\\r\\nif (returnCode)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\\r\\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!getModulusAndExponent(pubKeyToken, &exponentLength,\\r\\nexponent, &modulusLength, &modulusFieldLength,\\r\\nmodulus))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\\r\\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\n(*(long*)keyToken) = keyTokenLength;\\r\\nrtmp = RSA_new_method(e);\\r\\nRSA_set_ex_data(rtmp, hndidx, (char *)keyToken);\\r\\nrtmp->e = BN_bin2bn(exponent, exponentLength, NULL);\\r\\nrtmp->n = BN_bin2bn(modulus, modulusFieldLength, NULL);\\r\\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_RSA(res, rtmp);\\r\\nreturn res;\\r\\nerr:\\r\\nif (keyToken)\\r\\nOPENSSL_free(keyToken);\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\nif (rtmp)\\r\\nRSA_free(rtmp);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic EVP_PKEY *ibm_4758_load_pubkey(ENGINE* e, const char* key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nRSA *rtmp = NULL;\\r\\nEVP_PKEY *res = NULL;\\r\\nunsigned char* keyToken = NULL;\\r\\nlong keyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong exitDataLength = 0;\\r\\nlong ruleArrayLength = 0;\\r\\nunsigned char exitData[8];\\r\\nunsigned char ruleArray[8];\\r\\nunsigned char keyLabel[64];\\r\\nunsigned long keyLabelLength = strlen(key_id);\\r\\nunsigned char modulus[512];\\r\\nlong modulusFieldLength = sizeof(modulus);\\r\\nlong modulusLength = 0;\\r\\nunsigned char exponent[512];\\r\\nlong exponentLength = sizeof(exponent);\\r\\nif (keyLabelLength > sizeof(keyLabel))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(keyLabel,' ', sizeof(keyLabel));\\r\\nmemcpy(keyLabel, key_id, keyLabelLength);\\r\\nkeyToken = OPENSSL_malloc(MAX_CCA_PKA_TOKEN_SIZE + sizeof(long));\\r\\nif (!keyToken)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nkeyRecordRead(&returnCode, &reasonCode, &exitDataLength, exitData,\\r\\n&ruleArrayLength, ruleArray, keyLabel, &keyTokenLength,\\r\\nkeyToken+sizeof(long));\\r\\nif (returnCode)\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!getModulusAndExponent(keyToken+sizeof(long), &exponentLength,\\r\\nexponent, &modulusLength, &modulusFieldLength, modulus))\\r\\n{\\r\\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\\r\\nCCA4758_R_FAILED_LOADING_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\n(*(long*)keyToken) = keyTokenLength;\\r\\nrtmp = RSA_new_method(e);\\r\\nRSA_set_ex_data(rtmp, hndidx, (char *)keyToken);\\r\\nrtmp->e = BN_bin2bn(exponent, exponentLength, NULL);\\r\\nrtmp->n = BN_bin2bn(modulus, modulusFieldLength, NULL);\\r\\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_RSA(res, rtmp);\\r\\nreturn res;\\r\\nerr:\\r\\nif (keyToken)\\r\\nOPENSSL_free(keyToken);\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\nif (rtmp)\\r\\nRSA_free(rtmp);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int cca_rsa_pub_enc(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa,int padding)\\r\\n{\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong lflen = flen;\\r\\nlong exitDataLength = 0;\\r\\nunsigned char exitData[8];\\r\\nlong ruleArrayLength = 1;\\r\\nunsigned char ruleArray[8] = \"PKCS-1.2\";\\r\\nlong dataStructureLength = 0;\\r\\nunsigned char dataStructure[8];\\r\\nlong outputLength = RSA_size(rsa);\\r\\nlong keyTokenLength;\\r\\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\\r\\nkeyTokenLength = *(long*)keyToken;\\r\\nkeyToken+=sizeof(long);\\r\\npkaEncrypt(&returnCode, &reasonCode, &exitDataLength, exitData,\\r\\n&ruleArrayLength, ruleArray, &lflen, (unsigned char*)from,\\r\\n&dataStructureLength, dataStructure, &keyTokenLength,\\r\\nkeyToken, &outputLength, to);\\r\\nif (returnCode || reasonCode)\\r\\nreturn -(returnCode << 16 | reasonCode);\\r\\nreturn outputLength;\\r\\n}\\r\\nstatic int cca_rsa_priv_dec(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa,int padding)\\r\\n{\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong lflen = flen;\\r\\nlong exitDataLength = 0;\\r\\nunsigned char exitData[8];\\r\\nlong ruleArrayLength = 1;\\r\\nunsigned char ruleArray[8] = \"PKCS-1.2\";\\r\\nlong dataStructureLength = 0;\\r\\nunsigned char dataStructure[8];\\r\\nlong outputLength = RSA_size(rsa);\\r\\nlong keyTokenLength;\\r\\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\\r\\nkeyTokenLength = *(long*)keyToken;\\r\\nkeyToken+=sizeof(long);\\r\\npkaDecrypt(&returnCode, &reasonCode, &exitDataLength, exitData,\\r\\n&ruleArrayLength, ruleArray, &lflen, (unsigned char*)from,\\r\\n&dataStructureLength, dataStructure, &keyTokenLength,\\r\\nkeyToken, &outputLength, to);\\r\\nreturn (returnCode | reasonCode) ? 0 : 1;\\r\\n}\\r\\nstatic int cca_rsa_verify(int type, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigbuf, unsigned int siglen, const RSA *rsa)\\r\\n{\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong lsiglen = siglen;\\r\\nlong exitDataLength = 0;\\r\\nunsigned char exitData[8];\\r\\nlong ruleArrayLength = 1;\\r\\nunsigned char ruleArray[8] = \"PKCS-1.1\";\\r\\nlong keyTokenLength;\\r\\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\\r\\nlong length = SSL_SIG_LEN;\\r\\nlong keyLength ;\\r\\nunsigned char *hashBuffer = NULL;\\r\\nX509_SIG sig;\\r\\nASN1_TYPE parameter;\\r\\nX509_ALGOR algorithm;\\r\\nASN1_OCTET_STRING digest;\\r\\nkeyTokenLength = *(long*)keyToken;\\r\\nkeyToken+=sizeof(long);\\r\\nif (type == NID_md5 || type == NID_sha1)\\r\\n{\\r\\nsig.algor = &algorithm;\\r\\nalgorithm.algorithm = OBJ_nid2obj(type);\\r\\nif (!algorithm.algorithm)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nCCA4758_R_UNKNOWN_ALGORITHM_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!algorithm.algorithm->length)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nCCA4758_R_ASN1_OID_UNKNOWN_FOR_MD);\\r\\nreturn 0;\\r\\n}\\r\\nparameter.type = V_ASN1_NULL;\\r\\nparameter.value.ptr = NULL;\\r\\nalgorithm.parameter = &parameter;\\r\\nsig.digest = &digest;\\r\\nsig.digest->data = (unsigned char*)m;\\r\\nsig.digest->length = m_len;\\r\\nlength = i2d_X509_SIG(&sig, NULL);\\r\\n}\\r\\nkeyLength = RSA_size(rsa);\\r\\nif (length - RSA_PKCS1_PADDING > keyLength)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nswitch (type)\\r\\n{\\r\\ncase NID_md5_sha1 :\\r\\nif (m_len != SSL_SIG_LEN)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nhashBuffer = (unsigned char *)m;\\r\\nlength = m_len;\\r\\nbreak;\\r\\ncase NID_md5 :\\r\\n{\\r\\nunsigned char *ptr;\\r\\nptr = hashBuffer = OPENSSL_malloc(\\r\\n(unsigned int)keyLength+1);\\r\\nif (!hashBuffer)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ni2d_X509_SIG(&sig, &ptr);\\r\\n}\\r\\nbreak;\\r\\ncase NID_sha1 :\\r\\n{\\r\\nunsigned char *ptr;\\r\\nptr = hashBuffer = OPENSSL_malloc(\\r\\n(unsigned int)keyLength+1);\\r\\nif (!hashBuffer)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ni2d_X509_SIG(&sig, &ptr);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\ndigitalSignatureVerify(&returnCode, &reasonCode, &exitDataLength,\\r\\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\\r\\nkeyToken, &length, hashBuffer, &lsiglen, sigbuf);\\r\\nif (type == NID_sha1 || type == NID_md5)\\r\\n{\\r\\nOPENSSL_cleanse(hashBuffer, keyLength+1);\\r\\nOPENSSL_free(hashBuffer);\\r\\n}\\r\\nreturn ((returnCode || reasonCode) ? 0 : 1);\\r\\n}\\r\\nstatic int cca_rsa_sign(int type, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, const RSA *rsa)\\r\\n{\\r\\nlong returnCode;\\r\\nlong reasonCode;\\r\\nlong exitDataLength = 0;\\r\\nunsigned char exitData[8];\\r\\nlong ruleArrayLength = 1;\\r\\nunsigned char ruleArray[8] = \"PKCS-1.1\";\\r\\nlong outputLength=256;\\r\\nlong outputBitLength;\\r\\nlong keyTokenLength;\\r\\nunsigned char *hashBuffer = NULL;\\r\\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\\r\\nlong length = SSL_SIG_LEN;\\r\\nlong keyLength ;\\r\\nX509_SIG sig;\\r\\nASN1_TYPE parameter;\\r\\nX509_ALGOR algorithm;\\r\\nASN1_OCTET_STRING digest;\\r\\nkeyTokenLength = *(long*)keyToken;\\r\\nkeyToken+=sizeof(long);\\r\\nif (type == NID_md5 || type == NID_sha1)\\r\\n{\\r\\nsig.algor = &algorithm;\\r\\nalgorithm.algorithm = OBJ_nid2obj(type);\\r\\nif (!algorithm.algorithm)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nCCA4758_R_UNKNOWN_ALGORITHM_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!algorithm.algorithm->length)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nCCA4758_R_ASN1_OID_UNKNOWN_FOR_MD);\\r\\nreturn 0;\\r\\n}\\r\\nparameter.type = V_ASN1_NULL;\\r\\nparameter.value.ptr = NULL;\\r\\nalgorithm.parameter = &parameter;\\r\\nsig.digest = &digest;\\r\\nsig.digest->data = (unsigned char*)m;\\r\\nsig.digest->length = m_len;\\r\\nlength = i2d_X509_SIG(&sig, NULL);\\r\\n}\\r\\nkeyLength = RSA_size(rsa);\\r\\nif (length - RSA_PKCS1_PADDING > keyLength)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nswitch (type)\\r\\n{\\r\\ncase NID_md5_sha1 :\\r\\nif (m_len != SSL_SIG_LEN)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nhashBuffer = (unsigned char*)m;\\r\\nlength = m_len;\\r\\nbreak;\\r\\ncase NID_md5 :\\r\\n{\\r\\nunsigned char *ptr;\\r\\nptr = hashBuffer = OPENSSL_malloc(\\r\\n(unsigned int)keyLength+1);\\r\\nif (!hashBuffer)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ni2d_X509_SIG(&sig, &ptr);\\r\\n}\\r\\nbreak;\\r\\ncase NID_sha1 :\\r\\n{\\r\\nunsigned char *ptr;\\r\\nptr = hashBuffer = OPENSSL_malloc(\\r\\n(unsigned int)keyLength+1);\\r\\nif (!hashBuffer)\\r\\n{\\r\\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ni2d_X509_SIG(&sig, &ptr);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\ndigitalSignatureGenerate(&returnCode, &reasonCode, &exitDataLength,\\r\\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\\r\\nkeyToken, &length, hashBuffer, &outputLength, &outputBitLength,\\r\\nsigret);\\r\\nif (type == NID_sha1 || type == NID_md5)\\r\\n{\\r\\nOPENSSL_cleanse(hashBuffer, keyLength+1);\\r\\nOPENSSL_free(hashBuffer);\\r\\n}\\r\\n*siglen = outputLength;\\r\\nreturn ((returnCode || reasonCode) ? 0 : 1);\\r\\n}\\r\\nstatic int getModulusAndExponent(const unsigned char*token, long *exponentLength,\\r\\nunsigned char *exponent, long *modulusLength, long *modulusFieldLength,\\r\\nunsigned char *modulus)\\r\\n{\\r\\nunsigned long len;\\r\\nif (*token++ != (char)0x1E)\\r\\nreturn 0;\\r\\nif (*token++)\\r\\nreturn 0;\\r\\nlen = *token++;\\r\\nlen = len << 8;\\r\\nlen |= (unsigned char)*token++;\\r\\ntoken += 4;\\r\\nif (*token++ == (char)0x04)\\r\\n{\\r\\nif (*token++)\\r\\nreturn 0;\\r\\nlen = *token++;\\r\\nlen = len << 8;\\r\\nlen |= (unsigned char)*token++;\\r\\ntoken+=2;\\r\\nlen = *token++;\\r\\nlen = len << 8;\\r\\nlen |= (unsigned char)*token++;\\r\\n*exponentLength = len;\\r\\nlen = *token++;\\r\\nlen = len << 8;\\r\\nlen |= (unsigned char)*token++;\\r\\n*modulusLength = len;\\r\\nlen = *token++;\\r\\nlen = len << 8;\\r\\nlen |= (unsigned char)*token++;\\r\\n*modulusFieldLength = len;\\r\\nmemcpy(exponent, token, *exponentLength);\\r\\ntoken+= *exponentLength;\\r\\nmemcpy(modulus, token, *modulusFieldLength);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int cca_random_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cca_get_random_bytes(unsigned char* buf, int num)\\r\\n{\\r\\nlong ret_code;\\r\\nlong reason_code;\\r\\nlong exit_data_length;\\r\\nunsigned char exit_data[4];\\r\\nunsigned char form[] = \"RANDOM \";\\r\\nunsigned char rand_buf[8];\\r\\nwhile(num >= (int)sizeof(rand_buf))\\r\\n{\\r\\nrandomNumberGenerate(&ret_code, &reason_code, &exit_data_length,\\r\\nexit_data, form, rand_buf);\\r\\nif (ret_code)\\r\\nreturn 0;\\r\\nnum -= sizeof(rand_buf);\\r\\nmemcpy(buf, rand_buf, sizeof(rand_buf));\\r\\nbuf += sizeof(rand_buf);\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nrandomNumberGenerate(&ret_code, &reason_code, NULL, NULL,\\r\\nform, rand_buf);\\r\\nif (ret_code)\\r\\nreturn 0;\\r\\nmemcpy(buf, rand_buf, num);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void cca_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad, int idx,\\r\\nlong argl, void *argp)\\r\\n{\\r\\nif (item)\\r\\nOPENSSL_free(item);\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_4758_cca_id) != 0) &&\\r\\n(strcmp(id, engine_4758_cca_id_alt) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5cfb64_c", "target": 0, "func": "void RC5_32_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *schedule,\\r\\nunsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_enum_c", "target": 0, "func": "int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v)\\r\\n{\\r\\nint j,k;\\r\\nunsigned int i;\\r\\nunsigned char buf[sizeof(long)+1];\\r\\nlong d;\\r\\na->type=V_ASN1_ENUMERATED;\\r\\nif (a->length < (int)(sizeof(long)+1))\\r\\n{\\r\\nif (a->data != NULL)\\r\\nOPENSSL_free(a->data);\\r\\nif ((a->data=(unsigned char *)OPENSSL_malloc(sizeof(long)+1)) != NULL)\\r\\nmemset((char *)a->data,0,sizeof(long)+1);\\r\\n}\\r\\nif (a->data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ENUMERATED_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nd=v;\\r\\nif (d < 0)\\r\\n{\\r\\nd= -d;\\r\\na->type=V_ASN1_NEG_ENUMERATED;\\r\\n}\\r\\nfor (i=0; i<sizeof(long); i++)\\r\\n{\\r\\nif (d == 0) break;\\r\\nbuf[i]=(int)d&0xff;\\r\\nd>>=8;\\r\\n}\\r\\nj=0;\\r\\nfor (k=i-1; k >=0; k--)\\r\\na->data[j++]=buf[k];\\r\\na->length=j;\\r\\nreturn(1);\\r\\n}\\r\\nlong ASN1_ENUMERATED_get(ASN1_ENUMERATED *a)\\r\\n{\\r\\nint neg=0,i;\\r\\nlong r=0;\\r\\nif (a == NULL) return(0L);\\r\\ni=a->type;\\r\\nif (i == V_ASN1_NEG_ENUMERATED)\\r\\nneg=1;\\r\\nelse if (i != V_ASN1_ENUMERATED)\\r\\nreturn -1;\\r\\nif (a->length > (int)sizeof(long))\\r\\n{\\r\\nreturn(0xffffffffL);\\r\\n}\\r\\nif (a->data == NULL)\\r\\nreturn 0;\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nr<<=8;\\r\\nr|=(unsigned char)a->data[i];\\r\\n}\\r\\nif (neg) r= -r;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)\\r\\n{\\r\\nASN1_ENUMERATED *ret;\\r\\nint len,j;\\r\\nif (ai == NULL)\\r\\nret=M_ASN1_ENUMERATED_new();\\r\\nelse\\r\\nret=ai;\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_ENUMERATED,ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif(BN_is_negative(bn)) ret->type = V_ASN1_NEG_ENUMERATED;\\r\\nelse ret->type=V_ASN1_ENUMERATED;\\r\\nj=BN_num_bits(bn);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (ret->length < len+4)\\r\\n{\\r\\nunsigned char *new_data=OPENSSL_realloc(ret->data, len+4);\\r\\nif (!new_data)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nret->data=new_data;\\r\\n}\\r\\nret->length=BN_bn2bin(bn,ret->data);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != ai) M_ASN1_ENUMERATED_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=BN_bin2bn(ai->data,ai->length,bn)) == NULL)\\r\\nASN1err(ASN1_F_ASN1_ENUMERATED_TO_BN,ASN1_R_BN_LIB);\\r\\nelse if(ai->type == V_ASN1_NEG_ENUMERATED) BN_set_negative(ret,1);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cfb64ede_c", "target": 0, "func": "void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3,\\r\\nDES_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister long l=length;\\r\\nregister int n= *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=&(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt3(ti,ks1,ks2,ks3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt3(ti,ks1,ks2,ks3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=c=cc=0;\\r\\n*num=n;\\r\\n}\\r\\nvoid DES_ede3_cfb_encrypt(const unsigned char *in,unsigned char *out,\\r\\nint numbits,long length,DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2,DES_key_schedule *ks3,\\r\\nDES_cblock *ivec,int enc)\\r\\n{\\r\\nregister DES_LONG d0,d1,v0,v1;\\r\\nregister unsigned long l=length,n=((unsigned int)numbits+7)/8;\\r\\nregister int num=numbits,i;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nunsigned char ovec[16];\\r\\nif (num > 64) return;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nif (enc)\\r\\n{\\r\\nwhile (l >= n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt3(ti,ks1,ks2,ks3);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nd0^=ti[0];\\r\\nd1^=ti[1];\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (num == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse\\r\\n{\\r\\niv=&ovec[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nl2c(d0,iv);\\r\\nl2c(d1,iv);\\r\\nmemmove(ovec,ovec+num/8,8+(num%8 ? 1 : 0));\\r\\nif(num%8 != 0)\\r\\nfor(i=0 ; i < 8 ; ++i)\\r\\n{\\r\\novec[i]<<=num%8;\\r\\novec[i]|=ovec[i+1]>>(8-num%8);\\r\\n}\\r\\niv=&ovec[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l >= n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nDES_encrypt3(ti,ks1,ks2,ks3);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (num == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse\\r\\n{\\r\\niv=&ovec[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nl2c(d0,iv);\\r\\nl2c(d1,iv);\\r\\nmemmove(ovec,ovec+num/8,8+(num%8 ? 1 : 0));\\r\\nif(num%8 != 0)\\r\\nfor(i=0 ; i < 8 ; ++i)\\r\\n{\\r\\novec[i]<<=num%8;\\r\\novec[i]|=ovec[i+1]>>(8-num%8);\\r\\n}\\r\\niv=&ovec[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\n}\\r\\nd0^=ti[0];\\r\\nd1^=ti[1];\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nv0=v1=d0=d1=ti[0]=ti[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_pkey_c", "target": 0, "func": "int ENGINE_set_load_privkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpriv_f)\\r\\n{\\r\\ne->load_privkey = loadpriv_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f)\\r\\n{\\r\\ne->load_pubkey = loadpub_f;\\r\\nreturn 1;\\r\\n}\\r\\nENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->load_privkey;\\r\\n}\\r\\nENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->load_pubkey;\\r\\n}\\r\\nEVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(e->funct_ref == 0)\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nENGINE_R_NOT_INITIALISED);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (!e->load_privkey)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nENGINE_R_NO_LOAD_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\npkey = e->load_privkey(e, key_id, ui_method, callback_data);\\r\\nif (!pkey)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nENGINE_R_FAILED_LOADING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn pkey;\\r\\n}\\r\\nEVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif(e == NULL)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(e->funct_ref == 0)\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nENGINE_R_NOT_INITIALISED);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (!e->load_pubkey)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nENGINE_R_NO_LOAD_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\npkey = e->load_pubkey(e, key_id, ui_method, callback_data);\\r\\nif (!pkey)\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nENGINE_R_FAILED_LOADING_PUBLIC_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn pkey;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_asn1_c", "target": 0, "func": "int EC_GROUP_get_basis_type(const EC_GROUP *group)\\r\\n{\\r\\nint i=0;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\\r\\nNID_X9_62_characteristic_two_field)\\r\\nreturn 0;\\r\\nwhile (group->poly[i] != 0)\\r\\ni++;\\r\\nif (i == 4)\\r\\nreturn NID_X9_62_ppBasis;\\r\\nelse if (i == 2)\\r\\nreturn NID_X9_62_tpBasis;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)\\r\\n{\\r\\nif (group == NULL)\\r\\nreturn 0;\\r\\nif (EC_GROUP_method_of(group)->group_set_curve != ec_GF2m_simple_group_set_curve\\r\\n|| !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] == 0)))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (k)\\r\\n*k = group->poly[1];\\r\\nreturn 1;\\r\\n}\\r\\nint EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,\\r\\nunsigned int *k2, unsigned int *k3)\\r\\n{\\r\\nif (group == NULL)\\r\\nreturn 0;\\r\\nif (EC_GROUP_method_of(group)->group_set_curve != ec_GF2m_simple_group_set_curve\\r\\n|| !((group->poly[0] != 0) && (group->poly[1] != 0) && (group->poly[2] != 0) && (group->poly[3] != 0) && (group->poly[4] == 0)))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (k1)\\r\\n*k1 = group->poly[3];\\r\\nif (k2)\\r\\n*k2 = group->poly[2];\\r\\nif (k3)\\r\\n*k3 = group->poly[1];\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)\\r\\n{\\r\\nint ok=0, nid;\\r\\nBIGNUM *tmp = NULL;\\r\\nif (group == NULL || field == NULL)\\r\\nreturn 0;\\r\\nif (field->fieldType != NULL)\\r\\nASN1_OBJECT_free(field->fieldType);\\r\\nif (field->p.other != NULL)\\r\\nASN1_TYPE_free(field->p.other);\\r\\nnid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));\\r\\nif ((field->fieldType = OBJ_nid2obj(nid)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (nid == NID_X9_62_prime_field)\\r\\n{\\r\\nif ((tmp = BN_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_curve_GFp(group, tmp, NULL, NULL, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfield->p.prime = BN_to_ASN1_INTEGER(tmp,NULL);\\r\\nif (field->p.prime == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nint field_type;\\r\\nX9_62_CHARACTERISTIC_TWO *char_two;\\r\\nfield->p.char_two = X9_62_CHARACTERISTIC_TWO_new();\\r\\nchar_two = field->p.char_two;\\r\\nif (char_two == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nchar_two->m = (long)EC_GROUP_get_degree(group);\\r\\nfield_type = EC_GROUP_get_basis_type(group);\\r\\nif (field_type == 0)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((char_two->type = OBJ_nid2obj(field_type)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (field_type == NID_X9_62_tpBasis)\\r\\n{\\r\\nunsigned int k;\\r\\nif (!EC_GROUP_get_trinomial_basis(group, &k))\\r\\ngoto err;\\r\\nchar_two->p.tpBasis = ASN1_INTEGER_new();\\r\\nif (!char_two->p.tpBasis)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_INTEGER_set(char_two->p.tpBasis, (long)k))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID,\\r\\nERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if (field_type == NID_X9_62_ppBasis)\\r\\n{\\r\\nunsigned int k1, k2, k3;\\r\\nif (!EC_GROUP_get_pentanomial_basis(group, &k1, &k2, &k3))\\r\\ngoto err;\\r\\nchar_two->p.ppBasis = X9_62_PENTANOMIAL_new();\\r\\nif (!char_two->p.ppBasis)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nchar_two->p.ppBasis->k1 = (long)k1;\\r\\nchar_two->p.ppBasis->k2 = (long)k2;\\r\\nchar_two->p.ppBasis->k3 = (long)k3;\\r\\n}\\r\\nelse\\r\\n{\\r\\nchar_two->p.onBasis = ASN1_NULL_new();\\r\\nif (!char_two->p.onBasis)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr : if (tmp)\\r\\nBN_free(tmp);\\r\\nreturn(ok);\\r\\n}\\r\\nstatic int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)\\r\\n{\\r\\nint ok=0, nid;\\r\\nBIGNUM *tmp_1=NULL, *tmp_2=NULL;\\r\\nunsigned char *buffer_1=NULL, *buffer_2=NULL,\\r\\n*a_buf=NULL, *b_buf=NULL;\\r\\nsize_t len_1, len_2;\\r\\nunsigned char char_zero = 0;\\r\\nif (!group || !curve || !curve->a || !curve->b)\\r\\nreturn 0;\\r\\nif ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nnid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));\\r\\nif (nid == NID_X9_62_prime_field)\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GFp(group, NULL, tmp_1, tmp_2, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GF2m(group, NULL, tmp_1, tmp_2, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nlen_1 = (size_t)BN_num_bytes(tmp_1);\\r\\nlen_2 = (size_t)BN_num_bytes(tmp_2);\\r\\nif (len_1 == 0)\\r\\n{\\r\\na_buf = &char_zero;\\r\\nlen_1 = 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((buffer_1 = OPENSSL_malloc(len_1)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ( (len_1 = BN_bn2bin(tmp_1, buffer_1)) == 0)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\na_buf = buffer_1;\\r\\n}\\r\\nif (len_2 == 0)\\r\\n{\\r\\nb_buf = &char_zero;\\r\\nlen_2 = 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((buffer_2 = OPENSSL_malloc(len_2)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ( (len_2 = BN_bn2bin(tmp_2, buffer_2)) == 0)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nb_buf = buffer_2;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(curve->a, a_buf, len_1) ||\\r\\n!M_ASN1_OCTET_STRING_set(curve->b, b_buf, len_2))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (group->seed)\\r\\n{\\r\\nif (!curve->seed)\\r\\nif ((curve->seed = ASN1_BIT_STRING_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_BIT_STRING_set(curve->seed, group->seed,\\r\\n(int)group->seed_len))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (curve->seed)\\r\\n{\\r\\nASN1_BIT_STRING_free(curve->seed);\\r\\ncurve->seed = NULL;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr: if (buffer_1)\\r\\nOPENSSL_free(buffer_1);\\r\\nif (buffer_2)\\r\\nOPENSSL_free(buffer_2);\\r\\nif (tmp_1)\\r\\nBN_free(tmp_1);\\r\\nif (tmp_2)\\r\\nBN_free(tmp_2);\\r\\nreturn(ok);\\r\\n}\\r\\nstatic ECPARAMETERS *ec_asn1_group2parameters(const EC_GROUP *group,\\r\\nECPARAMETERS *param)\\r\\n{\\r\\nint ok=0;\\r\\nsize_t len=0;\\r\\nECPARAMETERS *ret=NULL;\\r\\nBIGNUM *tmp=NULL;\\r\\nunsigned char *buffer=NULL;\\r\\nconst EC_POINT *point=NULL;\\r\\npoint_conversion_form_t form;\\r\\nif ((tmp = BN_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (param == NULL)\\r\\n{\\r\\nif ((ret = ECPARAMETERS_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret = param;\\r\\nret->version = (long)0x1;\\r\\nif (!ec_asn1_group2fieldid(group, ret->fieldID))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!ec_asn1_group2curve(group, ret->curve))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(group)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nform = EC_GROUP_get_point_conversion_form(group);\\r\\nlen = EC_POINT_point2oct(group, point, form, NULL, len, NULL);\\r\\nif (len == 0)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((buffer = OPENSSL_malloc(len)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_point2oct(group, point, form, buffer, len, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_OCTET_STRING_set(ret->base, buffer, len))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, tmp, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->order = BN_to_ASN1_INTEGER(tmp, ret->order);\\r\\nif (ret->order == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_GROUP_get_cofactor(group, tmp, NULL))\\r\\n{\\r\\nret->cofactor = BN_to_ASN1_INTEGER(tmp, ret->cofactor);\\r\\nif (ret->cofactor == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr : if(!ok)\\r\\n{\\r\\nif (ret && !param)\\r\\nECPARAMETERS_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (tmp)\\r\\nBN_free(tmp);\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nreturn(ret);\\r\\n}\\r\\nECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group,\\r\\nECPKPARAMETERS *params)\\r\\n{\\r\\nint ok = 1, tmp;\\r\\nECPKPARAMETERS *ret = params;\\r\\nif (ret == NULL)\\r\\n{\\r\\nif ((ret = ECPKPARAMETERS_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (ret->type == 0 && ret->value.named_curve)\\r\\nASN1_OBJECT_free(ret->value.named_curve);\\r\\nelse if (ret->type == 1 && ret->value.parameters)\\r\\nECPARAMETERS_free(ret->value.parameters);\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(group))\\r\\n{\\r\\ntmp = EC_GROUP_get_curve_name(group);\\r\\nif (tmp)\\r\\n{\\r\\nret->type = 0;\\r\\nif ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)\\r\\nok = 0;\\r\\n}\\r\\nelse\\r\\nok = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->type = 1;\\r\\nif ((ret->value.parameters = ec_asn1_group2parameters(\\r\\ngroup, NULL)) == NULL)\\r\\nok = 0;\\r\\n}\\r\\nif (!ok)\\r\\n{\\r\\nECPKPARAMETERS_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic EC_GROUP *ec_asn1_parameters2group(const ECPARAMETERS *params)\\r\\n{\\r\\nint ok = 0, tmp;\\r\\nEC_GROUP *ret = NULL;\\r\\nBIGNUM *p = NULL, *a = NULL, *b = NULL;\\r\\nEC_POINT *point=NULL;\\r\\nif (!params->fieldID || !params->fieldID->fieldType ||\\r\\n!params->fieldID->p.ptr)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!params->curve || !params->curve->a ||\\r\\n!params->curve->a->data || !params->curve->b ||\\r\\n!params->curve->b->data)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\na = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\\r\\nif (a == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nb = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\\r\\nif (b == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\ntmp = OBJ_obj2nid(params->fieldID->fieldType);\\r\\nif (tmp == NID_X9_62_characteristic_two_field)\\r\\n{\\r\\nX9_62_CHARACTERISTIC_TWO *char_two;\\r\\nchar_two = params->fieldID->p.char_two;\\r\\nif ((p = BN_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntmp = OBJ_obj2nid(char_two->type);\\r\\nif (tmp == NID_X9_62_tpBasis)\\r\\n{\\r\\nlong tmp_long;\\r\\nif (!char_two->p.tpBasis)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\\r\\nif (!BN_set_bit(p, (int)char_two->m))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, (int)tmp_long))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, 0))\\r\\ngoto err;\\r\\n}\\r\\nelse if (tmp == NID_X9_62_ppBasis)\\r\\n{\\r\\nX9_62_PENTANOMIAL *penta;\\r\\npenta = char_two->p.ppBasis;\\r\\nif (!penta)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_set_bit(p, (int)char_two->m)) goto err;\\r\\nif (!BN_set_bit(p, (int)penta->k1)) goto err;\\r\\nif (!BN_set_bit(p, (int)penta->k2)) goto err;\\r\\nif (!BN_set_bit(p, (int)penta->k3)) goto err;\\r\\nif (!BN_set_bit(p, 0)) goto err;\\r\\n}\\r\\nelse if (tmp == NID_X9_62_onBasis)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_NOT_IMPLEMENTED);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if (tmp == NID_X9_62_prime_field)\\r\\n{\\r\\nif (!params->fieldID->p.prime)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\np = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\\r\\nif (p == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (params->curve->seed != NULL)\\r\\n{\\r\\nif (ret->seed != NULL)\\r\\nOPENSSL_free(ret->seed);\\r\\nif (!(ret->seed = OPENSSL_malloc(params->curve->seed->length)))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(ret->seed, params->curve->seed->data,\\r\\nparams->curve->seed->length);\\r\\nret->seed_len = params->curve->seed->length;\\r\\n}\\r\\nif (!params->order || !params->base || !params->base->data)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_POINT_new(ret)) == NULL) goto err;\\r\\nEC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\\r\\n(params->base->data[0] & ~0x01));\\r\\nif (!EC_POINT_oct2point(ret, point, params->base->data,\\r\\nparams->base->length, NULL))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (params->cofactor == NULL)\\r\\n{\\r\\nif (b)\\r\\n{\\r\\nBN_free(b);\\r\\nb = NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\nif ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_set_generator(ret, point, a, b))\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nok = 1;\\r\\nerr: if (!ok)\\r\\n{\\r\\nif (ret)\\r\\nEC_GROUP_clear_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn(ret);\\r\\n}\\r\\nEC_GROUP *ec_asn1_pkparameters2group(const ECPKPARAMETERS *params)\\r\\n{\\r\\nEC_GROUP *ret=NULL;\\r\\nint tmp=0;\\r\\nif (params == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP,\\r\\nEC_R_MISSING_PARAMETERS);\\r\\nreturn NULL;\\r\\n}\\r\\nif (params->type == 0)\\r\\n{\\r\\ntmp = OBJ_obj2nid(params->value.named_curve);\\r\\nif ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP,\\r\\nEC_R_EC_GROUP_NEW_BY_NAME_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(ret, OPENSSL_EC_NAMED_CURVE);\\r\\n}\\r\\nelse if (params->type == 1)\\r\\n{\\r\\nret = ec_asn1_parameters2group(params->value.parameters);\\r\\nif (!ret)\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(ret, 0x0);\\r\\n}\\r\\nelse if (params->type == 2)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_GROUP *group = NULL;\\r\\nECPKPARAMETERS *params = NULL;\\r\\nif ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\\r\\nECPKPARAMETERS_free(params);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((group = ec_asn1_pkparameters2group(params)) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a && *a)\\r\\nEC_GROUP_clear_free(*a);\\r\\nif (a)\\r\\n*a = group;\\r\\nECPKPARAMETERS_free(params);\\r\\nreturn(group);\\r\\n}\\r\\nint i2d_ECPKParameters(const EC_GROUP *a, unsigned char **out)\\r\\n{\\r\\nint ret=0;\\r\\nECPKPARAMETERS *tmp = ec_asn1_group2pkparameters(a, NULL);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_GROUP2PKPARAMETERS_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_I2D_ECPKPARAMETERS_FAILURE);\\r\\nECPKPARAMETERS_free(tmp);\\r\\nreturn 0;\\r\\n}\\r\\nECPKPARAMETERS_free(tmp);\\r\\nreturn(ret);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nint ok=0;\\r\\nEC_KEY *ret=NULL;\\r\\nEC_PRIVATEKEY *priv_key=NULL;\\r\\nif ((priv_key = EC_PRIVATEKEY_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((priv_key = d2i_EC_PRIVATEKEY(&priv_key, in, len)) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a == NULL || *a == NULL)\\r\\n{\\r\\nif ((ret = EC_KEY_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (a)\\r\\n*a = ret;\\r\\n}\\r\\nelse\\r\\nret = *a;\\r\\nif (priv_key->parameters)\\r\\n{\\r\\nif (ret->group)\\r\\nEC_GROUP_clear_free(ret->group);\\r\\nret->group = ec_asn1_pkparameters2group(priv_key->parameters);\\r\\n}\\r\\nif (ret->group == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->version = priv_key->version;\\r\\nif (priv_key->privateKey)\\r\\n{\\r\\nret->priv_key = BN_bin2bn(\\r\\nM_ASN1_STRING_data(priv_key->privateKey),\\r\\nM_ASN1_STRING_length(priv_key->privateKey),\\r\\nret->priv_key);\\r\\nif (ret->priv_key == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY,\\r\\nERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY,\\r\\nEC_R_MISSING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (priv_key->publicKey)\\r\\n{\\r\\nconst unsigned char *pub_oct;\\r\\nsize_t pub_oct_len;\\r\\nif (ret->pub_key)\\r\\nEC_POINT_clear_free(ret->pub_key);\\r\\nret->pub_key = EC_POINT_new(ret->group);\\r\\nif (ret->pub_key == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\npub_oct = M_ASN1_STRING_data(priv_key->publicKey);\\r\\npub_oct_len = M_ASN1_STRING_length(priv_key->publicKey);\\r\\nret->conv_form = (point_conversion_form_t)(pub_oct[0] & ~0x01);\\r\\nif (!EC_POINT_oct2point(ret->group, ret->pub_key,\\r\\npub_oct, pub_oct_len, NULL))\\r\\n{\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nif (ret)\\r\\nEC_KEY_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (priv_key)\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn(ret);\\r\\n}\\r\\nint i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nint ret=0, ok=0;\\r\\nunsigned char *buffer=NULL;\\r\\nsize_t buf_len=0, tmp_len;\\r\\nEC_PRIVATEKEY *priv_key=NULL;\\r\\nif (a == NULL || a->group == NULL || a->priv_key == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif ((priv_key = EC_PRIVATEKEY_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npriv_key->version = a->version;\\r\\nbuf_len = (size_t)BN_num_bytes(a->priv_key);\\r\\nbuffer = OPENSSL_malloc(buf_len);\\r\\nif (buffer == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_bn2bin(a->priv_key, buffer))\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(priv_key->privateKey, buffer, buf_len))\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!(a->enc_flag & EC_PKEY_NO_PARAMETERS))\\r\\n{\\r\\nif ((priv_key->parameters = ec_asn1_group2pkparameters(\\r\\na->group, priv_key->parameters)) == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(a->enc_flag & EC_PKEY_NO_PUBKEY))\\r\\n{\\r\\npriv_key->publicKey = M_ASN1_BIT_STRING_new();\\r\\nif (priv_key->publicKey == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntmp_len = EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, NULL, 0, NULL);\\r\\nif (tmp_len > buf_len)\\r\\n{\\r\\nunsigned char *tmp_buffer = OPENSSL_realloc(buffer, tmp_len);\\r\\nif (!tmp_buffer)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nbuffer = tmp_buffer;\\r\\nbuf_len = tmp_len;\\r\\n}\\r\\nif (!EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, buffer, buf_len, NULL))\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!M_ASN1_BIT_STRING_set(priv_key->publicKey, buffer,\\r\\nbuf_len))\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nif (priv_key)\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn(ok?ret:0);\\r\\n}\\r\\nint i2d_ECParameters(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nif (a == NULL)\\r\\n{\\r\\nECerr(EC_F_I2D_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i2d_ECPKParameters(a->group, out);\\r\\n}\\r\\nEC_KEY *d2i_ECParameters(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_KEY *ret;\\r\\nif (in == NULL || *in == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a == NULL || *a == NULL)\\r\\n{\\r\\nif ((ret = EC_KEY_new()) == NULL)\\r\\n{\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a)\\r\\n*a = ret;\\r\\n}\\r\\nelse\\r\\nret = *a;\\r\\nif (!d2i_ECPKParameters(&ret->group, in, len))\\r\\n{\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_EC_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *o2i_ECPublicKey(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_KEY *ret=NULL;\\r\\nif (a == NULL || (*a) == NULL || (*a)->group == NULL)\\r\\n{\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nret = *a;\\r\\nif (ret->pub_key == NULL &&\\r\\n(ret->pub_key = EC_POINT_new(ret->group)) == NULL)\\r\\n{\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!EC_POINT_oct2point(ret->group, ret->pub_key, *in, len, NULL))\\r\\n{\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret->conv_form = (point_conversion_form_t)(*in[0] & ~0x01);\\r\\n*in += len;\\r\\nreturn ret;\\r\\n}\\r\\nint i2o_ECPublicKey(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nsize_t buf_len=0;\\r\\nint new_buffer = 0;\\r\\nif (a == NULL)\\r\\n{\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nbuf_len = EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, NULL, 0, NULL);\\r\\nif (out == NULL || buf_len == 0)\\r\\nreturn buf_len;\\r\\nif (*out == NULL)\\r\\n{\\r\\nif ((*out = OPENSSL_malloc(buf_len)) == NULL)\\r\\n{\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nnew_buffer = 1;\\r\\n}\\r\\nif (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,\\r\\n*out, buf_len, NULL))\\r\\n{\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);\\r\\nOPENSSL_free(*out);\\r\\n*out = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nif (!new_buffer)\\r\\n*out += buf_len;\\r\\nreturn buf_len;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_des_old2_c", "target": 0, "func": "void _ossl_096_des_random_seed(DES_cblock *key)\\r\\n{\\r\\nRAND_seed(key, sizeof(DES_cblock));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_by_file_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_file(void)\\r\\n{\\r\\nreturn(&x509_file_lookup);\\r\\n}\\r\\nstatic int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\\r\\nchar **ret)\\r\\n{\\r\\nint ok=0;\\r\\nchar *file;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase X509_L_FILE_LOAD:\\r\\nif (argl == X509_FILETYPE_DEFAULT)\\r\\n{\\r\\nfile = (char *)Getenv(X509_get_default_cert_file_env());\\r\\nif (file)\\r\\nok = (X509_load_cert_crl_file(ctx,file,\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nelse\\r\\nok = (X509_load_cert_crl_file(ctx,X509_get_default_cert_file(),\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nif (!ok)\\r\\n{\\r\\nX509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif(argl == X509_FILETYPE_PEM)\\r\\nok = (X509_load_cert_crl_file(ctx,argp,\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nelse\\r\\nok = (X509_load_cert_file(ctx,argp,(int)argl) != 0);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn(ok);\\r\\n}\\r\\nint X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *in=NULL;\\r\\nint i,count=0;\\r\\nX509 *x=NULL;\\r\\nif (file == NULL) return(1);\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in,file) <= 0))\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nx=PEM_read_bio_X509_AUX(in,NULL,NULL,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_last_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0))\\r\\n{\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,\\r\\nERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni=X509_STORE_add_cert(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\ncount++;\\r\\nX509_free(x);\\r\\nx=NULL;\\r\\n}\\r\\nret=count;\\r\\n}\\r\\nelse if (type == X509_FILETYPE_ASN1)\\r\\n{\\r\\nx=d2i_X509_bio(in,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=X509_STORE_add_cert(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\nret=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *in=NULL;\\r\\nint i,count=0;\\r\\nX509_CRL *x=NULL;\\r\\nif (file == NULL) return(1);\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in,file) <= 0))\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nx=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_last_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0))\\r\\n{\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,\\r\\nERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni=X509_STORE_add_crl(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\ncount++;\\r\\nX509_CRL_free(x);\\r\\nx=NULL;\\r\\n}\\r\\nret=count;\\r\\n}\\r\\nelse if (type == X509_FILETYPE_ASN1)\\r\\n{\\r\\nx=d2i_X509_CRL_bio(in,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=X509_STORE_add_crl(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\nret=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_CRL_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nSTACK_OF(X509_INFO) *inf;\\r\\nX509_INFO *itmp;\\r\\nBIO *in;\\r\\nint i, count = 0;\\r\\nif(type != X509_FILETYPE_PEM)\\r\\nreturn X509_load_cert_file(ctx, file, type);\\r\\nin = BIO_new_file(file, \"r\");\\r\\nif(!in) {\\r\\nX509err(X509_F_X509_LOAD_CERT_CRL_FILE,ERR_R_SYS_LIB);\\r\\nreturn 0;\\r\\n}\\r\\ninf = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);\\r\\nBIO_free(in);\\r\\nif(!inf) {\\r\\nX509err(X509_F_X509_LOAD_CERT_CRL_FILE,ERR_R_PEM_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < sk_X509_INFO_num(inf); i++) {\\r\\nitmp = sk_X509_INFO_value(inf, i);\\r\\nif(itmp->x509) {\\r\\nX509_STORE_add_cert(ctx->store_ctx, itmp->x509);\\r\\ncount++;\\r\\n}\\r\\nif(itmp->crl) {\\r\\nX509_STORE_add_crl(ctx->store_ctx, itmp->crl);\\r\\ncount++;\\r\\n}\\r\\n}\\r\\nsk_X509_INFO_pop_free(inf, X509_INFO_free);\\r\\nreturn count;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rmd160_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"RIPEMD160(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nRIPEMD160_CTX c;\\r\\nunsigned char md[RIPEMD160_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nRIPEMD160_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nRIPEMD160_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nRIPEMD160_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<RIPEMD160_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_breakage_c", "target": 0, "func": "int int_strtoul(const char *str, unsigned long *val)\\r\\n{\\r\\n#ifdef HAVE_STRTOUL\\r\\nchar *tmp;\\r\\nunsigned long ret = strtoul(str, &tmp, 10);\\r\\nif((str == tmp) || (*tmp != '\\0'))\\r\\nreturn 0;\\r\\nif(ret == ULONG_MAX)\\r\\nreturn 0;\\r\\n*val = ret;\\r\\nreturn 1;\\r\\n#else\\r\\nchar buf[2];\\r\\nunsigned long ret = 0;\\r\\nbuf[1] = '\\0';\\r\\nif(str == '\\0')\\r\\nreturn 0;\\r\\nwhile(*str != '\\0') {\\r\\nif(ret && (((ULONG_MAX + 10) / ret) < 10))\\r\\nreturn 0;\\r\\nret *= 10;\\r\\nif(!isdigit(*str))\\r\\nreturn 0;\\r\\nbuf[0] = *str;\\r\\nret += atoi(buf);\\r\\nstr++;\\r\\n}\\r\\n*val = ret;\\r\\nreturn 1;\\r\\n#endif\\r\\n}\\r\\nchar *int_strstr(const char *haystack, const char *needle)\\r\\n{\\r\\nconst char *sub_haystack = haystack, *sub_needle = needle;\\r\\nunsigned int offset = 0;\\r\\nif(!needle)\\r\\nreturn haystack;\\r\\nif(!haystack)\\r\\nreturn NULL;\\r\\nwhile((*sub_haystack != '\\0') && (*sub_needle != '\\0')) {\\r\\nif(sub_haystack[offset] == sub_needle) {\\r\\noffset++;\\r\\nsub_needle++;\\r\\n} else {\\r\\nsub_haystack++;\\r\\noffset = 0;\\r\\nsub_needle = needle;\\r\\n}\\r\\n}\\r\\nif(*sub_haystack == '\\0')\\r\\nreturn NULL;\\r\\nreturn sub_haystack;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_ecdsa_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return SHA1_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA1_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA1_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_ecdsa(void)\\r\\n{\\r\\nreturn(&ecdsa_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkcs8_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint topk8 = 0;\\r\\nint pbe_nid = -1;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint informat, outformat;\\r\\nint p8_broken = PKCS8_OK;\\r\\nint nocrypt = 0;\\r\\nX509_SIG *p8;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nchar pass[50], *passin = NULL, *passout = NULL, *p8pass = NULL;\\r\\nint badarg = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-')\\r\\n{\\r\\nif (!strcmp(*args,\"-v2\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ncipher=EVP_get_cipherbyname(*args);\\r\\nif (!cipher)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Unknown cipher %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp(*args,\"-v1\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\npbe_nid=OBJ_txt2nid(*args);\\r\\nif (pbe_nid == NID_undef)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Unknown PBE algorithm %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbadarg = 1;\\r\\n}\\r\\nelse if (!strcmp(*args,\"-inform\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ninformat=str2fmt(*args);\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse if (!strcmp(*args,\"-outform\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\noutformat=str2fmt(*args);\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-topk8\"))\\r\\ntopk8 = 1;\\r\\nelse if (!strcmp (*args, \"-noiter\"))\\r\\niter = 1;\\r\\nelse if (!strcmp (*args, \"-nocrypt\"))\\r\\nnocrypt = 1;\\r\\nelse if (!strcmp (*args, \"-nooct\"))\\r\\np8_broken = PKCS8_NO_OCTET;\\r\\nelse if (!strcmp (*args, \"-nsdb\"))\\r\\np8_broken = PKCS8_NS_DB;\\r\\nelse if (!strcmp (*args, \"-embed\"))\\r\\np8_broken = PKCS8_EMBEDDED_PARAM;\\r\\nelse if (!strcmp(*args,\"-passin\"))\\r\\n{\\r\\nif (!args[1]) goto bad;\\r\\npassargin= *(++args);\\r\\n}\\r\\nelse if (!strcmp(*args,\"-passout\"))\\r\\n{\\r\\nif (!args[1]) goto bad;\\r\\npassargout= *(++args);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*args,\"-engine\") == 0)\\r\\n{\\r\\nif (!args[1]) goto bad;\\r\\nengine= *(++args);\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp (*args, \"-in\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\ninfile = *args;\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse if (!strcmp (*args, \"-out\"))\\r\\n{\\r\\nif (args[1])\\r\\n{\\r\\nargs++;\\r\\noutfile = *args;\\r\\n}\\r\\nelse badarg = 1;\\r\\n}\\r\\nelse badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err, \"Usage pkcs8 [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-inform X input format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-outform X output format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err, \"-passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-topk8 output PKCS8 file\\n\");\\r\\nBIO_printf(bio_err, \"-nooct use (nonstandard) no octet format\\n\");\\r\\nBIO_printf(bio_err, \"-embed use (nonstandard) embedded DSA parameters format\\n\");\\r\\nBIO_printf(bio_err, \"-nsdb use (nonstandard) DSA Netscape DB format\\n\");\\r\\nBIO_printf(bio_err, \"-noiter use 1 as iteration count\\n\");\\r\\nBIO_printf(bio_err, \"-nocrypt use or expect unencrypted private key\\n\");\\r\\nBIO_printf(bio_err, \"-v2 alg use PKCS#5 v2.0 and cipher \\\"alg\\\"\\n\");\\r\\nBIO_printf(bio_err, \"-v1 obj use PKCS#5 v1.5 and cipher \\\"alg\\\"\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nif ((pbe_nid == -1) && !cipher)\\r\\npbe_nid = NID_pbeWithMD5AndDES_CBC;\\r\\nif (infile)\\r\\n{\\r\\nif (!(in = BIO_new_file(infile, \"rb\")))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Can't open input file %s\\n\", infile);\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\nelse\\r\\nin = BIO_new_fp (stdin, BIO_NOCLOSE);\\r\\nif (outfile)\\r\\n{\\r\\nif (!(out = BIO_new_file (outfile, \"wb\")))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Can't open output file %s\\n\", outfile);\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nout = BIO_new_fp (stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (topk8)\\r\\n{\\r\\nBIO_free(in);\\r\\npkey = load_key(bio_err, infile, informat, 1,\\r\\npassin, e, \"key\");\\r\\nif (!pkey)\\r\\n{\\r\\nBIO_free_all(out);\\r\\nreturn 1;\\r\\n}\\r\\nif (!(p8inf = EVP_PKEY2PKCS8_broken(pkey, p8_broken)))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error converting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nreturn 1;\\r\\n}\\r\\nif (nocrypt)\\r\\n{\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8_PRIV_KEY_INFO(out, p8inf);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_PRIV_KEY_INFO_bio(out, p8inf);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (passout)\\r\\np8pass = passout;\\r\\nelse\\r\\n{\\r\\np8pass = pass;\\r\\nif (EVP_read_pw_string(pass, sizeof pass, \"Enter Encryption Password:\", 1))\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nif (!(p8 = PKCS8_encrypt(pbe_nid, cipher,\\r\\np8pass, strlen(p8pass),\\r\\nNULL, 0, iter, p8inf)))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error encrypting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nreturn (1);\\r\\n}\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8(out, p8);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_bio(out, p8);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nreturn (1);\\r\\n}\\r\\nX509_SIG_free(p8);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free (p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\nreturn (0);\\r\\n}\\r\\nif (nocrypt)\\r\\n{\\r\\nif (informat == FORMAT_PEM)\\r\\np8inf = PEM_read_bio_PKCS8_PRIV_KEY_INFO(in,NULL,NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np8inf = d2i_PKCS8_PRIV_KEY_INFO_bio(in, NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (informat == FORMAT_PEM)\\r\\np8 = PEM_read_bio_PKCS8(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np8 = d2i_PKCS8_bio(in, NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nif (!p8)\\r\\n{\\r\\nBIO_printf (bio_err, \"Error reading key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif (passin)\\r\\np8pass = passin;\\r\\nelse\\r\\n{\\r\\np8pass = pass;\\r\\nEVP_read_pw_string(pass, sizeof pass, \"Enter Password:\", 0);\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, p8pass, strlen(p8pass));\\r\\nX509_SIG_free(p8);\\r\\n}\\r\\nif (!p8inf)\\r\\n{\\r\\nBIO_printf(bio_err, \"Error decrypting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif (!(pkey = EVP_PKCS82PKEY(p8inf)))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error converting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif (p8inf->broken)\\r\\n{\\r\\nBIO_printf(bio_err, \"Warning: broken key encoding: \");\\r\\nswitch (p8inf->broken)\\r\\n{\\r\\ncase PKCS8_NO_OCTET:\\r\\nBIO_printf(bio_err, \"No Octet String in PrivateKey\\n\");\\r\\nbreak;\\r\\ncase PKCS8_EMBEDDED_PARAM:\\r\\nBIO_printf(bio_err, \"DSA parameters included in PrivateKey\\n\");\\r\\nbreak;\\r\\ncase PKCS8_NS_DB:\\r\\nBIO_printf(bio_err, \"DSA public key include in PrivateKey\\n\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(bio_err, \"Unknown broken type\\n\");\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PrivateKey(out, pkey, NULL, NULL, 0, NULL, passout);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PrivateKey_bio(out, pkey);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nBIO_free(in);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_ext_c", "target": 0, "func": "int OCSP_REQUEST_get_ext_count(OCSP_REQUEST *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->tbsRequest->requestExtensions));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_NID(OCSP_REQUEST *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->tbsRequest->requestExtensions,nid,lastpos));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_OBJ(OCSP_REQUEST *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->tbsRequest->requestExtensions,obj,lastpos));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_critical(OCSP_REQUEST *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->tbsRequest->requestExtensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_REQUEST_get_ext(OCSP_REQUEST *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->tbsRequest->requestExtensions,loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_REQUEST_delete_ext(OCSP_REQUEST *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->tbsRequest->requestExtensions,loc));\\r\\n}\\r\\nvoid *OCSP_REQUEST_get1_ext_d2i(OCSP_REQUEST *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->tbsRequest->requestExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->tbsRequest->requestExtensions, nid, value, crit, flags);\\r\\n}\\r\\nint OCSP_REQUEST_add_ext(OCSP_REQUEST *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->tbsRequest->requestExtensions),ex,loc) != NULL);\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->singleRequestExtensions));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_NID(OCSP_ONEREQ *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->singleRequestExtensions,nid,lastpos));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_OBJ(OCSP_ONEREQ *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->singleRequestExtensions,obj,lastpos));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_critical(OCSP_ONEREQ *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->singleRequestExtensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_ONEREQ_get_ext(OCSP_ONEREQ *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->singleRequestExtensions,loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_ONEREQ_delete_ext(OCSP_ONEREQ *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->singleRequestExtensions,loc));\\r\\n}\\r\\nvoid *OCSP_ONEREQ_get1_ext_d2i(OCSP_ONEREQ *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->singleRequestExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_ONEREQ_add1_ext_i2d(OCSP_ONEREQ *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->singleRequestExtensions, nid, value, crit, flags);\\r\\n}\\r\\nint OCSP_ONEREQ_add_ext(OCSP_ONEREQ *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->singleRequestExtensions),ex,loc) != NULL);\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->tbsResponseData->responseExtensions));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_NID(OCSP_BASICRESP *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->tbsResponseData->responseExtensions,nid,lastpos));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_OBJ(OCSP_BASICRESP *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->tbsResponseData->responseExtensions,obj,lastpos));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_critical(OCSP_BASICRESP *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->tbsResponseData->responseExtensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_BASICRESP_get_ext(OCSP_BASICRESP *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->tbsResponseData->responseExtensions,loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_BASICRESP_delete_ext(OCSP_BASICRESP *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->tbsResponseData->responseExtensions,loc));\\r\\n}\\r\\nvoid *OCSP_BASICRESP_get1_ext_d2i(OCSP_BASICRESP *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->tbsResponseData->responseExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->tbsResponseData->responseExtensions, nid, value, crit, flags);\\r\\n}\\r\\nint OCSP_BASICRESP_add_ext(OCSP_BASICRESP *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->tbsResponseData->responseExtensions),ex,loc) != NULL);\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->singleExtensions));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_NID(OCSP_SINGLERESP *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->singleExtensions,nid,lastpos));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_OBJ(OCSP_SINGLERESP *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->singleExtensions,obj,lastpos));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_critical(OCSP_SINGLERESP *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->singleExtensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->singleExtensions,loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_SINGLERESP_delete_ext(OCSP_SINGLERESP *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->singleExtensions,loc));\\r\\n}\\r\\nvoid *OCSP_SINGLERESP_get1_ext_d2i(OCSP_SINGLERESP *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->singleExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_SINGLERESP_add1_ext_i2d(OCSP_SINGLERESP *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->singleExtensions, nid, value, crit, flags);\\r\\n}\\r\\nint OCSP_SINGLERESP_add_ext(OCSP_SINGLERESP *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->singleExtensions),ex,loc) != NULL);\\r\\n}\\r\\nint OCSP_request_add1_nonce(OCSP_REQUEST *req, unsigned char *val, int len)\\r\\n{\\r\\nreturn ocsp_add1_nonce(&req->tbsRequest->requestExtensions, val, len);\\r\\n}\\r\\nint OCSP_basic_add1_nonce(OCSP_BASICRESP *resp, unsigned char *val, int len)\\r\\n{\\r\\nreturn ocsp_add1_nonce(&resp->tbsResponseData->responseExtensions, val, len);\\r\\n}\\r\\nint OCSP_check_nonce(OCSP_REQUEST *req, OCSP_BASICRESP *bs)\\r\\n{\\r\\nint req_idx, resp_idx;\\r\\nX509_EXTENSION *req_ext, *resp_ext;\\r\\nreq_idx = OCSP_REQUEST_get_ext_by_NID(req, NID_id_pkix_OCSP_Nonce, -1);\\r\\nresp_idx = OCSP_BASICRESP_get_ext_by_NID(bs, NID_id_pkix_OCSP_Nonce, -1);\\r\\nif((req_idx < 0) && (resp_idx < 0))\\r\\nreturn 2;\\r\\nif((req_idx >= 0) && (resp_idx < 0))\\r\\nreturn -1;\\r\\nif((req_idx < 0) && (resp_idx >= 0))\\r\\nreturn 3;\\r\\nreq_ext = OCSP_REQUEST_get_ext(req, req_idx);\\r\\nresp_ext = OCSP_BASICRESP_get_ext(bs, resp_idx);\\r\\nif(ASN1_OCTET_STRING_cmp(req_ext->value, resp_ext->value))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_copy_nonce(OCSP_BASICRESP *resp, OCSP_REQUEST *req)\\r\\n{\\r\\nX509_EXTENSION *req_ext;\\r\\nint req_idx;\\r\\nreq_idx = OCSP_REQUEST_get_ext_by_NID(req, NID_id_pkix_OCSP_Nonce, -1);\\r\\nif (req_idx < 0) return 2;\\r\\nreq_ext = OCSP_REQUEST_get_ext(req, req_idx);\\r\\nreturn OCSP_BASICRESP_add_ext(resp, req_ext, -1);\\r\\n}\\r\\nX509_EXTENSION *OCSP_crlID_new(char *url, long *n, char *tim)\\r\\n{\\r\\nX509_EXTENSION *x = NULL;\\r\\nOCSP_CRLID *cid = NULL;\\r\\nif (!(cid = OCSP_CRLID_new())) goto err;\\r\\nif (url)\\r\\n{\\r\\nif (!(cid->crlUrl = ASN1_IA5STRING_new())) goto err;\\r\\nif (!(ASN1_STRING_set(cid->crlUrl, url, -1))) goto err;\\r\\n}\\r\\nif (n)\\r\\n{\\r\\nif (!(cid->crlNum = ASN1_INTEGER_new())) goto err;\\r\\nif (!(ASN1_INTEGER_set(cid->crlNum, *n))) goto err;\\r\\n}\\r\\nif (tim)\\r\\n{\\r\\nif (!(cid->crlTime = ASN1_GENERALIZEDTIME_new())) goto err;\\r\\nif (!(ASN1_GENERALIZEDTIME_set_string(cid->crlTime, tim)))\\r\\ngoto err;\\r\\n}\\r\\nif (!(x = X509_EXTENSION_new())) goto err;\\r\\nif (!(x->object = OBJ_nid2obj(NID_id_pkix_OCSP_CrlID))) goto err;\\r\\nif (!(ASN1_STRING_encode_of(OCSP_CRLID,x->value,i2d_OCSP_CRLID,cid,\\r\\nNULL)))\\r\\ngoto err;\\r\\nOCSP_CRLID_free(cid);\\r\\nreturn x;\\r\\nerr:\\r\\nif (x) X509_EXTENSION_free(x);\\r\\nif (cid) OCSP_CRLID_free(cid);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *OCSP_accept_responses_new(char **oids)\\r\\n{\\r\\nint nid;\\r\\nSTACK_OF(ASN1_OBJECT) *sk = NULL;\\r\\nASN1_OBJECT *o = NULL;\\r\\nX509_EXTENSION *x = NULL;\\r\\nif (!(sk = sk_ASN1_OBJECT_new_null())) goto err;\\r\\nwhile (oids && *oids)\\r\\n{\\r\\nif ((nid=OBJ_txt2nid(*oids))!=NID_undef&&(o=OBJ_nid2obj(nid)))\\r\\nsk_ASN1_OBJECT_push(sk, o);\\r\\noids++;\\r\\n}\\r\\nif (!(x = X509_EXTENSION_new())) goto err;\\r\\nif (!(x->object = OBJ_nid2obj(NID_id_pkix_OCSP_acceptableResponses)))\\r\\ngoto err;\\r\\nif (!(ASN1_STRING_encode_of(ASN1_OBJECT,x->value,i2d_ASN1_OBJECT,NULL,\\r\\nsk)))\\r\\ngoto err;\\r\\nsk_ASN1_OBJECT_pop_free(sk, ASN1_OBJECT_free);\\r\\nreturn x;\\r\\nerr:\\r\\nif (x) X509_EXTENSION_free(x);\\r\\nif (sk) sk_ASN1_OBJECT_pop_free(sk, ASN1_OBJECT_free);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *OCSP_archive_cutoff_new(char* tim)\\r\\n{\\r\\nX509_EXTENSION *x=NULL;\\r\\nASN1_GENERALIZEDTIME *gt = NULL;\\r\\nif (!(gt = ASN1_GENERALIZEDTIME_new())) goto err;\\r\\nif (!(ASN1_GENERALIZEDTIME_set_string(gt, tim))) goto err;\\r\\nif (!(x = X509_EXTENSION_new())) goto err;\\r\\nif (!(x->object=OBJ_nid2obj(NID_id_pkix_OCSP_archiveCutoff)))goto err;\\r\\nif (!(ASN1_STRING_encode_of(ASN1_GENERALIZEDTIME,x->value,\\r\\ni2d_ASN1_GENERALIZEDTIME,gt,NULL))) goto err;\\r\\nASN1_GENERALIZEDTIME_free(gt);\\r\\nreturn x;\\r\\nerr:\\r\\nif (gt) ASN1_GENERALIZEDTIME_free(gt);\\r\\nif (x) X509_EXTENSION_free(x);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *OCSP_url_svcloc_new(X509_NAME* issuer, char **urls)\\r\\n{\\r\\nX509_EXTENSION *x = NULL;\\r\\nASN1_IA5STRING *ia5 = NULL;\\r\\nOCSP_SERVICELOC *sloc = NULL;\\r\\nACCESS_DESCRIPTION *ad = NULL;\\r\\nif (!(sloc = OCSP_SERVICELOC_new())) goto err;\\r\\nif (!(sloc->issuer = X509_NAME_dup(issuer))) goto err;\\r\\nif (urls && *urls && !(sloc->locator = sk_ACCESS_DESCRIPTION_new_null())) goto err;\\r\\nwhile (urls && *urls)\\r\\n{\\r\\nif (!(ad = ACCESS_DESCRIPTION_new())) goto err;\\r\\nif (!(ad->method=OBJ_nid2obj(NID_ad_OCSP))) goto err;\\r\\nif (!(ad->location = GENERAL_NAME_new())) goto err;\\r\\nif (!(ia5 = ASN1_IA5STRING_new())) goto err;\\r\\nif (!ASN1_STRING_set((ASN1_STRING*)ia5, *urls, -1)) goto err;\\r\\nad->location->type = GEN_URI;\\r\\nad->location->d.ia5 = ia5;\\r\\nif (!sk_ACCESS_DESCRIPTION_push(sloc->locator, ad)) goto err;\\r\\nurls++;\\r\\n}\\r\\nif (!(x = X509_EXTENSION_new())) goto err;\\r\\nif (!(x->object = OBJ_nid2obj(NID_id_pkix_OCSP_serviceLocator)))\\r\\ngoto err;\\r\\nif (!(ASN1_STRING_encode_of(OCSP_SERVICELOC,x->value,\\r\\ni2d_OCSP_SERVICELOC,sloc,NULL))) goto err;\\r\\nOCSP_SERVICELOC_free(sloc);\\r\\nreturn x;\\r\\nerr:\\r\\nif (x) X509_EXTENSION_free(x);\\r\\nif (sloc) OCSP_SERVICELOC_free(sloc);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_dh_c", "target": 0, "func": "void ENGINE_unregister_DH(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&dh_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_DH(void)\\r\\n{\\r\\nengine_table_cleanup(&dh_table);\\r\\n}\\r\\nint ENGINE_register_DH(ENGINE *e)\\r\\n{\\r\\nif(e->dh_meth)\\r\\nreturn engine_table_register(&dh_table,\\r\\nengine_unregister_all_DH, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_DH()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_DH(e);\\r\\n}\\r\\nint ENGINE_set_default_DH(ENGINE *e)\\r\\n{\\r\\nif(e->dh_meth)\\r\\nreturn engine_table_register(&dh_table,\\r\\nengine_unregister_all_DH, e, &dummy_nid, 1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_DH(void)\\r\\n{\\r\\nreturn engine_table_select(&dh_table, dummy_nid);\\r\\n}\\r\\nconst DH_METHOD *ENGINE_get_DH(const ENGINE *e)\\r\\n{\\r\\nreturn e->dh_meth;\\r\\n}\\r\\nint ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth)\\r\\n{\\r\\ne->dh_meth = dh_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_digest_c", "target": 0, "func": "void ENGINE_unregister_digests(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&digest_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_digests(void)\\r\\n{\\r\\nengine_table_cleanup(&digest_table);\\r\\n}\\r\\nint ENGINE_register_digests(ENGINE *e)\\r\\n{\\r\\nif(e->digests)\\r\\n{\\r\\nconst int *nids;\\r\\nint num_nids = e->digests(e, NULL, &nids, 0);\\r\\nif(num_nids > 0)\\r\\nreturn engine_table_register(&digest_table,\\r\\nengine_unregister_all_digests, e, nids,\\r\\nnum_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_digests()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_digests(e);\\r\\n}\\r\\nint ENGINE_set_default_digests(ENGINE *e)\\r\\n{\\r\\nif(e->digests)\\r\\n{\\r\\nconst int *nids;\\r\\nint num_nids = e->digests(e, NULL, &nids, 0);\\r\\nif(num_nids > 0)\\r\\nreturn engine_table_register(&digest_table,\\r\\nengine_unregister_all_digests, e, nids,\\r\\nnum_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_digest_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&digest_table, nid);\\r\\n}\\r\\nconst EVP_MD *ENGINE_get_digest(ENGINE *e, int nid)\\r\\n{\\r\\nconst EVP_MD *ret;\\r\\nENGINE_DIGESTS_PTR fn = ENGINE_get_digests(e);\\r\\nif(!fn || !fn(e, &ret, NULL, nid))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_DIGEST,\\r\\nENGINE_R_UNIMPLEMENTED_DIGEST);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e)\\r\\n{\\r\\nreturn e->digests;\\r\\n}\\r\\nint ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f)\\r\\n{\\r\\ne->digests = f;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_lib_c", "target": 0, "func": "RSA *RSA_new(void)\\r\\n{\\r\\nRSA *r=RSA_new_method(NULL);\\r\\nreturn r;\\r\\n}\\r\\nvoid RSA_set_default_method(const RSA_METHOD *meth)\\r\\n{\\r\\ndefault_RSA_meth = meth;\\r\\n}\\r\\nconst RSA_METHOD *RSA_get_default_method(void)\\r\\n{\\r\\nif (default_RSA_meth == NULL)\\r\\n{\\r\\n#ifdef RSA_NULL\\r\\ndefault_RSA_meth=RSA_null_method();\\r\\n#else\\r\\n#if 0\\r\\ndefault_RSA_meth=RSA_PKCS1_RSAref();\\r\\n#else\\r\\ndefault_RSA_meth=RSA_PKCS1_SSLeay();\\r\\n#endif\\r\\n#endif\\r\\n}\\r\\nreturn default_RSA_meth;\\r\\n}\\r\\nconst RSA_METHOD *RSA_get_method(const RSA *rsa)\\r\\n{\\r\\nreturn rsa->meth;\\r\\n}\\r\\nint RSA_set_method(RSA *rsa, const RSA_METHOD *meth)\\r\\n{\\r\\nconst RSA_METHOD *mtmp;\\r\\nmtmp = rsa->meth;\\r\\nif (mtmp->finish) mtmp->finish(rsa);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (rsa->engine)\\r\\n{\\r\\nENGINE_finish(rsa->engine);\\r\\nrsa->engine = NULL;\\r\\n}\\r\\n#endif\\r\\nrsa->meth = meth;\\r\\nif (meth->init) meth->init(rsa);\\r\\nreturn 1;\\r\\n}\\r\\nRSA *RSA_new_method(ENGINE *engine)\\r\\n{\\r\\nRSA *ret;\\r\\nret=(RSA *)OPENSSL_malloc(sizeof(RSA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = RSA_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine)\\r\\n{\\r\\nif (!ENGINE_init(engine))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n}\\r\\nelse\\r\\nret->engine = ENGINE_get_default_RSA();\\r\\nif(ret->engine)\\r\\n{\\r\\nret->meth = ENGINE_get_RSA(ret->engine);\\r\\nif(!ret->meth)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD,\\r\\nERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->n=NULL;\\r\\nret->e=NULL;\\r\\nret->d=NULL;\\r\\nret->p=NULL;\\r\\nret->q=NULL;\\r\\nret->dmp1=NULL;\\r\\nret->dmq1=NULL;\\r\\nret->iqmp=NULL;\\r\\nret->references=1;\\r\\nret->_method_mod_n=NULL;\\r\\nret->_method_mod_p=NULL;\\r\\nret->_method_mod_q=NULL;\\r\\nret->blinding=NULL;\\r\\nret->mt_blinding=NULL;\\r\\nret->bignum_data=NULL;\\r\\nret->flags=ret->meth->flags;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid RSA_free(RSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL) return;\\r\\ni=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"RSA\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"RSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, r, &r->ex_data);\\r\\nif (r->n != NULL) BN_clear_free(r->n);\\r\\nif (r->e != NULL) BN_clear_free(r->e);\\r\\nif (r->d != NULL) BN_clear_free(r->d);\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->q != NULL) BN_clear_free(r->q);\\r\\nif (r->dmp1 != NULL) BN_clear_free(r->dmp1);\\r\\nif (r->dmq1 != NULL) BN_clear_free(r->dmq1);\\r\\nif (r->iqmp != NULL) BN_clear_free(r->iqmp);\\r\\nif (r->blinding != NULL) BN_BLINDING_free(r->blinding);\\r\\nif (r->mt_blinding != NULL) BN_BLINDING_free(r->mt_blinding);\\r\\nif (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint RSA_up_ref(RSA *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_RSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"RSA\",r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2)\\r\\n{\\r\\nfprintf(stderr, \"RSA_up_ref, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint RSA_set_ex_data(RSA *r, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\\r\\n}\\r\\nvoid *RSA_get_ex_data(const RSA *r, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\\r\\n}\\r\\nint RSA_size(const RSA *r)\\r\\n{\\r\\nreturn(BN_num_bytes(r->n));\\r\\n}\\r\\nint RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_flags(const RSA *r)\\r\\n{\\r\\nreturn((r == NULL)?0:r->meth->flags);\\r\\n}\\r\\nvoid RSA_blinding_off(RSA *rsa)\\r\\n{\\r\\nif (rsa->blinding != NULL)\\r\\n{\\r\\nBN_BLINDING_free(rsa->blinding);\\r\\nrsa->blinding=NULL;\\r\\n}\\r\\nrsa->flags &= ~RSA_FLAG_BLINDING;\\r\\nrsa->flags |= RSA_FLAG_NO_BLINDING;\\r\\n}\\r\\nint RSA_blinding_on(RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nif (rsa->blinding != NULL)\\r\\nRSA_blinding_off(rsa);\\r\\nrsa->blinding = RSA_setup_blinding(rsa, ctx);\\r\\nif (rsa->blinding == NULL)\\r\\ngoto err;\\r\\nrsa->flags |= RSA_FLAG_BLINDING;\\r\\nrsa->flags &= ~RSA_FLAG_NO_BLINDING;\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,\\r\\nconst BIGNUM *q, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret = NULL, *r0, *r1, *r2;\\r\\nif (d == NULL || p == NULL || q == NULL)\\r\\nreturn NULL;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\nr1 = BN_CTX_get(ctx);\\r\\nr2 = BN_CTX_get(ctx);\\r\\nif (r2 == NULL)\\r\\ngoto err;\\r\\nif (!BN_sub(r1, p, BN_value_one())) goto err;\\r\\nif (!BN_sub(r2, q, BN_value_one())) goto err;\\r\\nif (!BN_mul(r0, r1, r2, ctx)) goto err;\\r\\nret = BN_mod_inverse(NULL, d, r0, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nBN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)\\r\\n{\\r\\nBIGNUM *e;\\r\\nBN_CTX *ctx;\\r\\nBN_BLINDING *ret = NULL;\\r\\nif (in_ctx == NULL)\\r\\n{\\r\\nif ((ctx = BN_CTX_new()) == NULL) return 0;\\r\\n}\\r\\nelse\\r\\nctx = in_ctx;\\r\\nBN_CTX_start(ctx);\\r\\ne = BN_CTX_get(ctx);\\r\\nif (e == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (rsa->e == NULL)\\r\\n{\\r\\ne = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);\\r\\nif (e == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\ne = rsa->e;\\r\\nif ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)\\r\\n{\\r\\nRAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);\\r\\n}\\r\\nret = BN_BLINDING_create_param(NULL, e, rsa->n, ctx,\\r\\nrsa->meth->bn_mod_exp, rsa->_method_mod_n);\\r\\nif (ret == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBN_BLINDING_set_thread_id(ret, CRYPTO_thread_id());\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (in_ctx == NULL)\\r\\nBN_CTX_free(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint RSA_memory_lock(RSA *r)\\r\\n{\\r\\nint i,j,k,off;\\r\\nchar *p;\\r\\nBIGNUM *bn,**t[6],*b;\\r\\nBN_ULONG *ul;\\r\\nif (r->d == NULL) return(1);\\r\\nt[0]= &r->d;\\r\\nt[1]= &r->p;\\r\\nt[2]= &r->q;\\r\\nt[3]= &r->dmp1;\\r\\nt[4]= &r->dmq1;\\r\\nt[5]= &r->iqmp;\\r\\nk=sizeof(BIGNUM)*6;\\r\\noff=k/sizeof(BN_ULONG)+1;\\r\\nj=1;\\r\\nfor (i=0; i<6; i++)\\r\\nj+= (*t[i])->top;\\r\\nif ((p=OPENSSL_malloc_locked((off+j)*sizeof(BN_ULONG))) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_MEMORY_LOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nbn=(BIGNUM *)p;\\r\\nul=(BN_ULONG *)&(p[off]);\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nb= *(t[i]);\\r\\n*(t[i])= &(bn[i]);\\r\\nmemcpy((char *)&(bn[i]),(char *)b,sizeof(BIGNUM));\\r\\nbn[i].flags=BN_FLG_STATIC_DATA;\\r\\nbn[i].d=ul;\\r\\nmemcpy((char *)ul,b->d,sizeof(BN_ULONG)*b->top);\\r\\nul+=b->top;\\r\\nBN_clear_free(b);\\r\\n}\\r\\nr->flags&= ~(RSA_FLAG_CACHE_PRIVATE|RSA_FLAG_CACHE_PUBLIC);\\r\\nr->bignum_data=p;\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha512_c", "target": 0, "func": "int SHA384_Init (SHA512_CTX *c)\\r\\n{\\r\\nc->h[0]=U64(0xcbbb9d5dc1059ed8);\\r\\nc->h[1]=U64(0x629a292a367cd507);\\r\\nc->h[2]=U64(0x9159015a3070dd17);\\r\\nc->h[3]=U64(0x152fecd8f70e5939);\\r\\nc->h[4]=U64(0x67332667ffc00b31);\\r\\nc->h[5]=U64(0x8eb44a8768581511);\\r\\nc->h[6]=U64(0xdb0c2e0d64f98fa7);\\r\\nc->h[7]=U64(0x47b5481dbefa4fa4);\\r\\nc->Nl=0; c->Nh=0;\\r\\nc->num=0; c->md_len=SHA384_DIGEST_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nint SHA512_Init (SHA512_CTX *c)\\r\\n{\\r\\nc->h[0]=U64(0x6a09e667f3bcc908);\\r\\nc->h[1]=U64(0xbb67ae8584caa73b);\\r\\nc->h[2]=U64(0x3c6ef372fe94f82b);\\r\\nc->h[3]=U64(0xa54ff53a5f1d36f1);\\r\\nc->h[4]=U64(0x510e527fade682d1);\\r\\nc->h[5]=U64(0x9b05688c2b3e6c1f);\\r\\nc->h[6]=U64(0x1f83d9abfb41bd6b);\\r\\nc->h[7]=U64(0x5be0cd19137e2179);\\r\\nc->Nl=0; c->Nh=0;\\r\\nc->num=0; c->md_len=SHA512_DIGEST_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nint SHA512_Final (unsigned char *md, SHA512_CTX *c)\\r\\n{\\r\\nunsigned char *p=(unsigned char *)c->u.p;\\r\\nsize_t n=c->num;\\r\\np[n]=0x80;\\r\\nn++;\\r\\nif (n > (sizeof(c->u)-16))\\r\\nmemset (p+n,0,sizeof(c->u)-n), n=0,\\r\\nsha512_block (c,p,1);\\r\\nmemset (p+n,0,sizeof(c->u)-16-n);\\r\\n#ifdef B_ENDIAN\\r\\nc->u.d[SHA_LBLOCK-2] = c->Nh;\\r\\nc->u.d[SHA_LBLOCK-1] = c->Nl;\\r\\n#else\\r\\np[sizeof(c->u)-1] = (unsigned char)(c->Nl);\\r\\np[sizeof(c->u)-2] = (unsigned char)(c->Nl>>8);\\r\\np[sizeof(c->u)-3] = (unsigned char)(c->Nl>>16);\\r\\np[sizeof(c->u)-4] = (unsigned char)(c->Nl>>24);\\r\\np[sizeof(c->u)-5] = (unsigned char)(c->Nl>>32);\\r\\np[sizeof(c->u)-6] = (unsigned char)(c->Nl>>40);\\r\\np[sizeof(c->u)-7] = (unsigned char)(c->Nl>>48);\\r\\np[sizeof(c->u)-8] = (unsigned char)(c->Nl>>56);\\r\\np[sizeof(c->u)-9] = (unsigned char)(c->Nh);\\r\\np[sizeof(c->u)-10] = (unsigned char)(c->Nh>>8);\\r\\np[sizeof(c->u)-11] = (unsigned char)(c->Nh>>16);\\r\\np[sizeof(c->u)-12] = (unsigned char)(c->Nh>>24);\\r\\np[sizeof(c->u)-13] = (unsigned char)(c->Nh>>32);\\r\\np[sizeof(c->u)-14] = (unsigned char)(c->Nh>>40);\\r\\np[sizeof(c->u)-15] = (unsigned char)(c->Nh>>48);\\r\\np[sizeof(c->u)-16] = (unsigned char)(c->Nh>>56);\\r\\n#endif\\r\\nsha512_block (c,p,1);\\r\\nif (md==0) return 0;\\r\\nswitch (c->md_len)\\r\\n{\\r\\ncase SHA384_DIGEST_LENGTH:\\r\\nfor (n=0;n<SHA384_DIGEST_LENGTH/8;n++)\\r\\n{\\r\\nSHA_LONG64 t = c->h[n];\\r\\n*(md++) = (unsigned char)(t>>56);\\r\\n*(md++) = (unsigned char)(t>>48);\\r\\n*(md++) = (unsigned char)(t>>40);\\r\\n*(md++) = (unsigned char)(t>>32);\\r\\n*(md++) = (unsigned char)(t>>24);\\r\\n*(md++) = (unsigned char)(t>>16);\\r\\n*(md++) = (unsigned char)(t>>8);\\r\\n*(md++) = (unsigned char)(t);\\r\\n}\\r\\nbreak;\\r\\ncase SHA512_DIGEST_LENGTH:\\r\\nfor (n=0;n<SHA512_DIGEST_LENGTH/8;n++)\\r\\n{\\r\\nSHA_LONG64 t = c->h[n];\\r\\n*(md++) = (unsigned char)(t>>56);\\r\\n*(md++) = (unsigned char)(t>>48);\\r\\n*(md++) = (unsigned char)(t>>40);\\r\\n*(md++) = (unsigned char)(t>>32);\\r\\n*(md++) = (unsigned char)(t>>24);\\r\\n*(md++) = (unsigned char)(t>>16);\\r\\n*(md++) = (unsigned char)(t>>8);\\r\\n*(md++) = (unsigned char)(t);\\r\\n}\\r\\nbreak;\\r\\ndefault: return 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SHA384_Final (unsigned char *md,SHA512_CTX *c)\\r\\n{ return SHA512_Final (md,c); }\\r\\nint SHA512_Update (SHA512_CTX *c, const void *_data, size_t len)\\r\\n{\\r\\nSHA_LONG64 l;\\r\\nunsigned char *p=c->u.p;\\r\\nconst unsigned char *data=(const unsigned char *)_data;\\r\\nif (len==0) return 1;\\r\\nl = (c->Nl+(((SHA_LONG64)len)<<3))&U64(0xffffffffffffffff);\\r\\nif (l < c->Nl) c->Nh++;\\r\\nif (sizeof(len)>=8) c->Nh+=(((SHA_LONG64)len)>>61);\\r\\nc->Nl=l;\\r\\nif (c->num != 0)\\r\\n{\\r\\nsize_t n = sizeof(c->u) - c->num;\\r\\nif (len < n)\\r\\n{\\r\\nmemcpy (p+c->num,data,len), c->num += len;\\r\\nreturn 1;\\r\\n}\\r\\nelse {\\r\\nmemcpy (p+c->num,data,n), c->num = 0;\\r\\nlen-=n, data+=n;\\r\\nsha512_block (c,p,1);\\r\\n}\\r\\n}\\r\\nif (len >= sizeof(c->u))\\r\\n{\\r\\n#ifndef SHA512_BLOCK_CAN_MANAGE_UNALIGNED_DATA\\r\\nif ((size_t)data%sizeof(c->u.d[0]) != 0)\\r\\nwhile (len >= sizeof(c->u))\\r\\nmemcpy (p,data,sizeof(c->u)),\\r\\nsha512_block (c,p,1),\\r\\nlen -= sizeof(c->u),\\r\\ndata += sizeof(c->u);\\r\\nelse\\r\\n#endif\\r\\nsha512_block (c,data,len/sizeof(c->u)),\\r\\ndata += len,\\r\\nlen %= sizeof(c->u),\\r\\ndata -= len;\\r\\n}\\r\\nif (len != 0) memcpy (p,data,len), c->num = (int)len;\\r\\nreturn 1;\\r\\n}\\r\\nint SHA384_Update (SHA512_CTX *c, const void *data, size_t len)\\r\\n{ return SHA512_Update (c,data,len); }\\r\\nvoid SHA512_Transform (SHA512_CTX *c, const unsigned char *data)\\r\\n{ sha512_block (c,data,1); }\\r\\nunsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA512_CTX c;\\r\\nstatic unsigned char m[SHA384_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA384_Init(&c);\\r\\nSHA512_Update(&c,d,n);\\r\\nSHA512_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}\\r\\nunsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA512_CTX c;\\r\\nstatic unsigned char m[SHA512_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA512_Init(&c);\\r\\nSHA512_Update(&c,d,n);\\r\\nSHA512_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}\\r\\nstatic void sha512_block (SHA512_CTX *ctx, const void *in, size_t num)\\r\\n{\\r\\nconst SHA_LONG64 *W=in;\\r\\nSHA_LONG64 a,b,c,d,e,f,g,h,s0,s1,T1,T2;\\r\\nSHA_LONG64 X[16];\\r\\nint i;\\r\\n#ifdef GO_FOR_SSE2\\r\\nGO_FOR_SSE2(ctx,in,num);\\r\\n#endif\\r\\nwhile (num--) {\\r\\na = ctx->h[0]; b = ctx->h[1]; c = ctx->h[2]; d = ctx->h[3];\\r\\ne = ctx->h[4]; f = ctx->h[5]; g = ctx->h[6]; h = ctx->h[7];\\r\\nfor (i=0;i<16;i++)\\r\\n{\\r\\n#ifdef B_ENDIAN\\r\\nT1 = X[i] = W[i];\\r\\n#else\\r\\nT1 = X[i] = PULL64(W[i]);\\r\\n#endif\\r\\nT1 += h + Sigma1(e) + Ch(e,f,g) + K512[i];\\r\\nT2 = Sigma0(a) + Maj(a,b,c);\\r\\nh = g; g = f; f = e; e = d + T1;\\r\\nd = c; c = b; b = a; a = T1 + T2;\\r\\n}\\r\\nfor (;i<80;i++)\\r\\n{\\r\\ns0 = X[(i+1)&0x0f]; s0 = sigma0(s0);\\r\\ns1 = X[(i+14)&0x0f]; s1 = sigma1(s1);\\r\\nT1 = X[i&0xf] += s0 + s1 + X[(i+9)&0xf];\\r\\nT1 += h + Sigma1(e) + Ch(e,f,g) + K512[i];\\r\\nT2 = Sigma0(a) + Maj(a,b,c);\\r\\nh = g; g = f; f = e; e = d + T1;\\r\\nd = c; c = b; b = a; a = T1 + T2;\\r\\n}\\r\\nctx->h[0] += a; ctx->h[1] += b; ctx->h[2] += c; ctx->h[3] += d;\\r\\nctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;\\r\\nW+=SHA_LBLOCK;\\r\\n}\\r\\n}\\r\\nstatic void sha512_block (SHA512_CTX *ctx, const void *in, size_t num)\\r\\n{\\r\\nconst SHA_LONG64 *W=in;\\r\\nSHA_LONG64 a,b,c,d,e,f,g,h,s0,s1,T1;\\r\\nSHA_LONG64 X[16];\\r\\nint i;\\r\\n#ifdef GO_FOR_SSE2\\r\\nGO_FOR_SSE2(ctx,in,num);\\r\\n#endif\\r\\nwhile (num--) {\\r\\na = ctx->h[0]; b = ctx->h[1]; c = ctx->h[2]; d = ctx->h[3];\\r\\ne = ctx->h[4]; f = ctx->h[5]; g = ctx->h[6]; h = ctx->h[7];\\r\\n#ifdef B_ENDIAN\\r\\nT1 = X[0] = W[0]; ROUND_00_15(0,a,b,c,d,e,f,g,h);\\r\\nT1 = X[1] = W[1]; ROUND_00_15(1,h,a,b,c,d,e,f,g);\\r\\nT1 = X[2] = W[2]; ROUND_00_15(2,g,h,a,b,c,d,e,f);\\r\\nT1 = X[3] = W[3]; ROUND_00_15(3,f,g,h,a,b,c,d,e);\\r\\nT1 = X[4] = W[4]; ROUND_00_15(4,e,f,g,h,a,b,c,d);\\r\\nT1 = X[5] = W[5]; ROUND_00_15(5,d,e,f,g,h,a,b,c);\\r\\nT1 = X[6] = W[6]; ROUND_00_15(6,c,d,e,f,g,h,a,b);\\r\\nT1 = X[7] = W[7]; ROUND_00_15(7,b,c,d,e,f,g,h,a);\\r\\nT1 = X[8] = W[8]; ROUND_00_15(8,a,b,c,d,e,f,g,h);\\r\\nT1 = X[9] = W[9]; ROUND_00_15(9,h,a,b,c,d,e,f,g);\\r\\nT1 = X[10] = W[10]; ROUND_00_15(10,g,h,a,b,c,d,e,f);\\r\\nT1 = X[11] = W[11]; ROUND_00_15(11,f,g,h,a,b,c,d,e);\\r\\nT1 = X[12] = W[12]; ROUND_00_15(12,e,f,g,h,a,b,c,d);\\r\\nT1 = X[13] = W[13]; ROUND_00_15(13,d,e,f,g,h,a,b,c);\\r\\nT1 = X[14] = W[14]; ROUND_00_15(14,c,d,e,f,g,h,a,b);\\r\\nT1 = X[15] = W[15]; ROUND_00_15(15,b,c,d,e,f,g,h,a);\\r\\n#else\\r\\nT1 = X[0] = PULL64(W[0]); ROUND_00_15(0,a,b,c,d,e,f,g,h);\\r\\nT1 = X[1] = PULL64(W[1]); ROUND_00_15(1,h,a,b,c,d,e,f,g);\\r\\nT1 = X[2] = PULL64(W[2]); ROUND_00_15(2,g,h,a,b,c,d,e,f);\\r\\nT1 = X[3] = PULL64(W[3]); ROUND_00_15(3,f,g,h,a,b,c,d,e);\\r\\nT1 = X[4] = PULL64(W[4]); ROUND_00_15(4,e,f,g,h,a,b,c,d);\\r\\nT1 = X[5] = PULL64(W[5]); ROUND_00_15(5,d,e,f,g,h,a,b,c);\\r\\nT1 = X[6] = PULL64(W[6]); ROUND_00_15(6,c,d,e,f,g,h,a,b);\\r\\nT1 = X[7] = PULL64(W[7]); ROUND_00_15(7,b,c,d,e,f,g,h,a);\\r\\nT1 = X[8] = PULL64(W[8]); ROUND_00_15(8,a,b,c,d,e,f,g,h);\\r\\nT1 = X[9] = PULL64(W[9]); ROUND_00_15(9,h,a,b,c,d,e,f,g);\\r\\nT1 = X[10] = PULL64(W[10]); ROUND_00_15(10,g,h,a,b,c,d,e,f);\\r\\nT1 = X[11] = PULL64(W[11]); ROUND_00_15(11,f,g,h,a,b,c,d,e);\\r\\nT1 = X[12] = PULL64(W[12]); ROUND_00_15(12,e,f,g,h,a,b,c,d);\\r\\nT1 = X[13] = PULL64(W[13]); ROUND_00_15(13,d,e,f,g,h,a,b,c);\\r\\nT1 = X[14] = PULL64(W[14]); ROUND_00_15(14,c,d,e,f,g,h,a,b);\\r\\nT1 = X[15] = PULL64(W[15]); ROUND_00_15(15,b,c,d,e,f,g,h,a);\\r\\n#endif\\r\\nfor (i=16;i<80;i+=8)\\r\\n{\\r\\nROUND_16_80(i+0,a,b,c,d,e,f,g,h,X);\\r\\nROUND_16_80(i+1,h,a,b,c,d,e,f,g,X);\\r\\nROUND_16_80(i+2,g,h,a,b,c,d,e,f,X);\\r\\nROUND_16_80(i+3,f,g,h,a,b,c,d,e,X);\\r\\nROUND_16_80(i+4,e,f,g,h,a,b,c,d,X);\\r\\nROUND_16_80(i+5,d,e,f,g,h,a,b,c,X);\\r\\nROUND_16_80(i+6,c,d,e,f,g,h,a,b,X);\\r\\nROUND_16_80(i+7,b,c,d,e,f,g,h,a,X);\\r\\n}\\r\\nctx->h[0] += a; ctx->h[1] += b; ctx->h[2] += c; ctx->h[3] += d;\\r\\nctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;\\r\\nW+=SHA_LBLOCK;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_gen_c", "target": 0, "func": "int DSA_generate_parameters_ex(DSA *ret, int bits,\\r\\nunsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret, BN_GENCB *cb)\\r\\n{\\r\\nif(ret->meth->dsa_paramgen)\\r\\nreturn ret->meth->dsa_paramgen(ret, bits, seed_in, seed_len,\\r\\ncounter_ret, h_ret, cb);\\r\\nreturn dsa_builtin_paramgen(ret, bits, seed_in, seed_len,\\r\\ncounter_ret, h_ret, cb);\\r\\n}\\r\\nstatic int dsa_builtin_paramgen(DSA *ret, int bits,\\r\\nunsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret, BN_GENCB *cb)\\r\\n{\\r\\nint ok=0;\\r\\nunsigned char seed[SHA_DIGEST_LENGTH];\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nunsigned char buf[SHA_DIGEST_LENGTH],buf2[SHA_DIGEST_LENGTH];\\r\\nBIGNUM *r0,*W,*X,*c,*test;\\r\\nBIGNUM *g=NULL,*q=NULL,*p=NULL;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nint k,n=0,i,b,m=0;\\r\\nint counter=0;\\r\\nint r=0;\\r\\nBN_CTX *ctx=NULL;\\r\\nunsigned int h=2;\\r\\nif (bits < 512) bits=512;\\r\\nbits=(bits+63)/64*64;\\r\\nif (seed_len < 20)\\r\\nseed_in = NULL;\\r\\nif (seed_len > 20)\\r\\nseed_len = 20;\\r\\nif ((seed_in != NULL) && (seed_len == 20))\\r\\nmemcpy(seed,seed_in,seed_len);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\ng = BN_CTX_get(ctx);\\r\\nW = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nc = BN_CTX_get(ctx);\\r\\np = BN_CTX_get(ctx);\\r\\ntest = BN_CTX_get(ctx);\\r\\nif (!BN_lshift(test,BN_value_one(),bits-1))\\r\\ngoto err;\\r\\nfor (;;)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nint seed_is_random;\\r\\nif(!BN_GENCB_call(cb, 0, m++))\\r\\ngoto err;\\r\\nif (!seed_len)\\r\\n{\\r\\nRAND_pseudo_bytes(seed,SHA_DIGEST_LENGTH);\\r\\nseed_is_random = 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nseed_is_random = 0;\\r\\nseed_len=0;\\r\\n}\\r\\nmemcpy(buf,seed,SHA_DIGEST_LENGTH);\\r\\nmemcpy(buf2,seed,SHA_DIGEST_LENGTH);\\r\\nfor (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)\\r\\n{\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0) break;\\r\\n}\\r\\nEVP_Digest(seed,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);\\r\\nEVP_Digest(buf,SHA_DIGEST_LENGTH,buf2,NULL,HASH, NULL);\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nmd[i]^=buf2[i];\\r\\nmd[0]|=0x80;\\r\\nmd[SHA_DIGEST_LENGTH-1]|=0x01;\\r\\nif (!BN_bin2bn(md,SHA_DIGEST_LENGTH,q)) goto err;\\r\\nr = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx,\\r\\nseed_is_random, cb);\\r\\nif (r > 0)\\r\\nbreak;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 2, 0)) goto err;\\r\\nif(!BN_GENCB_call(cb, 3, 0)) goto err;\\r\\ncounter=0;\\r\\nn=(bits-1)/160;\\r\\nb=(bits-1)-n*160;\\r\\nfor (;;)\\r\\n{\\r\\nif ((counter != 0) && !BN_GENCB_call(cb, 0, counter))\\r\\ngoto err;\\r\\nBN_zero(W);\\r\\nfor (k=0; k<=n; k++)\\r\\n{\\r\\nfor (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)\\r\\n{\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0) break;\\r\\n}\\r\\nEVP_Digest(buf,SHA_DIGEST_LENGTH,md,NULL,HASH, NULL);\\r\\nif (!BN_bin2bn(md,SHA_DIGEST_LENGTH,r0))\\r\\ngoto err;\\r\\nif (!BN_lshift(r0,r0,160*k)) goto err;\\r\\nif (!BN_add(W,W,r0)) goto err;\\r\\n}\\r\\nif (!BN_mask_bits(W,bits-1)) goto err;\\r\\nif (!BN_copy(X,W)) goto err;\\r\\nif (!BN_add(X,X,test)) goto err;\\r\\nif (!BN_lshift1(r0,q)) goto err;\\r\\nif (!BN_mod(c,X,r0,ctx)) goto err;\\r\\nif (!BN_sub(r0,c,BN_value_one())) goto err;\\r\\nif (!BN_sub(p,X,r0)) goto err;\\r\\nif (BN_cmp(p,test) >= 0)\\r\\n{\\r\\nr = BN_is_prime_fasttest_ex(p, DSS_prime_checks,\\r\\nctx, 1, cb);\\r\\nif (r > 0)\\r\\ngoto end;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\n}\\r\\ncounter++;\\r\\nif (counter >= 4096) break;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif(!BN_GENCB_call(cb, 2, 1))\\r\\ngoto err;\\r\\nif (!BN_sub(test,p,BN_value_one())) goto err;\\r\\nif (!BN_div(r0,NULL,test,q,ctx)) goto err;\\r\\nif (!BN_set_word(test,h)) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,p,ctx)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BN_mod_exp_mont(g,test,r0,p,ctx,mont)) goto err;\\r\\nif (!BN_is_one(g)) break;\\r\\nif (!BN_add(test,test,BN_value_one())) goto err;\\r\\nh++;\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 3, 1))\\r\\ngoto err;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok)\\r\\n{\\r\\nif(ret->p) BN_free(ret->p);\\r\\nif(ret->q) BN_free(ret->q);\\r\\nif(ret->g) BN_free(ret->g);\\r\\nret->p=BN_dup(p);\\r\\nret->q=BN_dup(q);\\r\\nret->g=BN_dup(g);\\r\\nif (ret->p == NULL || ret->q == NULL || ret->g == NULL)\\r\\n{\\r\\nok=0;\\r\\ngoto err;\\r\\n}\\r\\nif ((m > 1) && (seed_in != NULL)) memcpy(seed_in,seed,20);\\r\\nif (counter_ret != NULL) *counter_ret=counter;\\r\\nif (h_ret != NULL) *h_ret=h;\\r\\n}\\r\\nif(ctx)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (mont != NULL) BN_MONT_CTX_free(mont);\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_dec_c", "target": 0, "func": "int EVP_PKEY_decrypt(unsigned char *key, const unsigned char *ek, int ekl,\\r\\nEVP_PKEY *priv)\\r\\n{\\r\\nint ret= -1;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret=RSA_private_decrypt(ekl,ek,key,priv->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_xcbc_d_c", "target": 0, "func": "const EVP_CIPHER *EVP_desx_cbc(void)\\r\\n{\\r\\nreturn(&d_xcbc_cipher);\\r\\n}\\r\\nstatic int desx_cbc_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\nDES_set_key_unchecked(deskey,&data(ctx)->ks);\\r\\nmemcpy(&data(ctx)->inw[0],&key[8],8);\\r\\nmemcpy(&data(ctx)->outw[0],&key[16],8);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int desx_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_xcbc_encrypt(in,out,inl,&data(ctx)->ks,\\r\\n(DES_cblock *)&(ctx->iv[0]),\\r\\n&data(ctx)->inw,\\r\\n&data(ctx)->outw,\\r\\nctx->encrypt);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pkcs7err_c", "target": 0, "func": "void ERR_load_PKCS7_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,PKCS7_str_functs);\\r\\nERR_load_strings(0,PKCS7_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_mul_c", "target": 0, "func": "BN_ULONG bn_sub_part_words(BN_ULONG *r,\\r\\nconst BN_ULONG *a, const BN_ULONG *b,\\r\\nint cl, int dl)\\r\\n{\\r\\nBN_ULONG c, t;\\r\\nassert(cl >= 0);\\r\\nc = bn_sub_words(r, a, b, cl);\\r\\nif (dl == 0)\\r\\nreturn c;\\r\\nr += cl;\\r\\na += cl;\\r\\nb += cl;\\r\\nif (dl < 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl < 0, c = %d)\\n\", cl, dl, c);\\r\\n#endif\\r\\nfor (;;)\\r\\n{\\r\\nt = b[0];\\r\\nr[0] = (0-t-c)&BN_MASK2;\\r\\nif (t != 0) c=1;\\r\\nif (++dl >= 0) break;\\r\\nt = b[1];\\r\\nr[1] = (0-t-c)&BN_MASK2;\\r\\nif (t != 0) c=1;\\r\\nif (++dl >= 0) break;\\r\\nt = b[2];\\r\\nr[2] = (0-t-c)&BN_MASK2;\\r\\nif (t != 0) c=1;\\r\\nif (++dl >= 0) break;\\r\\nt = b[3];\\r\\nr[3] = (0-t-c)&BN_MASK2;\\r\\nif (t != 0) c=1;\\r\\nif (++dl >= 0) break;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nint save_dl = dl;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, c = %d)\\n\", cl, dl, c);\\r\\n#endif\\r\\nwhile(c)\\r\\n{\\r\\nt = a[0];\\r\\nr[0] = (t-c)&BN_MASK2;\\r\\nif (t != 0) c=0;\\r\\nif (--dl <= 0) break;\\r\\nt = a[1];\\r\\nr[1] = (t-c)&BN_MASK2;\\r\\nif (t != 0) c=0;\\r\\nif (--dl <= 0) break;\\r\\nt = a[2];\\r\\nr[2] = (t-c)&BN_MASK2;\\r\\nif (t != 0) c=0;\\r\\nif (--dl <= 0) break;\\r\\nt = a[3];\\r\\nr[3] = (t-c)&BN_MASK2;\\r\\nif (t != 0) c=0;\\r\\nif (--dl <= 0) break;\\r\\nsave_dl = dl;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\nif (dl > 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, c == 0)\\n\", cl, dl);\\r\\n#endif\\r\\nif (save_dl > dl)\\r\\n{\\r\\nswitch (save_dl - dl)\\r\\n{\\r\\ncase 1:\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0) break;\\r\\ncase 2:\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0) break;\\r\\ncase 3:\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0) break;\\r\\n}\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl > 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, copy)\\n\", cl, dl);\\r\\n#endif\\r\\nfor(;;)\\r\\n{\\r\\nr[0] = a[0];\\r\\nif (--dl <= 0) break;\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0) break;\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0) break;\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0) break;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn c;\\r\\n}\\r\\nBN_ULONG bn_add_part_words(BN_ULONG *r,\\r\\nconst BN_ULONG *a, const BN_ULONG *b,\\r\\nint cl, int dl)\\r\\n{\\r\\nBN_ULONG c, l, t;\\r\\nassert(cl >= 0);\\r\\nc = bn_add_words(r, a, b, cl);\\r\\nif (dl == 0)\\r\\nreturn c;\\r\\nr += cl;\\r\\na += cl;\\r\\nb += cl;\\r\\nif (dl < 0)\\r\\n{\\r\\nint save_dl = dl;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, c = %d)\\n\", cl, dl, c);\\r\\n#endif\\r\\nwhile (c)\\r\\n{\\r\\nl=(c+b[0])&BN_MASK2;\\r\\nc=(l < c);\\r\\nr[0]=l;\\r\\nif (++dl >= 0) break;\\r\\nl=(c+b[1])&BN_MASK2;\\r\\nc=(l < c);\\r\\nr[1]=l;\\r\\nif (++dl >= 0) break;\\r\\nl=(c+b[2])&BN_MASK2;\\r\\nc=(l < c);\\r\\nr[2]=l;\\r\\nif (++dl >= 0) break;\\r\\nl=(c+b[3])&BN_MASK2;\\r\\nc=(l < c);\\r\\nr[3]=l;\\r\\nif (++dl >= 0) break;\\r\\nsave_dl = dl;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nif (dl < 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, c == 0)\\n\", cl, dl);\\r\\n#endif\\r\\nif (save_dl < dl)\\r\\n{\\r\\nswitch (dl - save_dl)\\r\\n{\\r\\ncase 1:\\r\\nr[1] = b[1];\\r\\nif (++dl >= 0) break;\\r\\ncase 2:\\r\\nr[2] = b[2];\\r\\nif (++dl >= 0) break;\\r\\ncase 3:\\r\\nr[3] = b[3];\\r\\nif (++dl >= 0) break;\\r\\n}\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl < 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, copy)\\n\", cl, dl);\\r\\n#endif\\r\\nfor(;;)\\r\\n{\\r\\nr[0] = b[0];\\r\\nif (++dl >= 0) break;\\r\\nr[1] = b[1];\\r\\nif (++dl >= 0) break;\\r\\nr[2] = b[2];\\r\\nif (++dl >= 0) break;\\r\\nr[3] = b[3];\\r\\nif (++dl >= 0) break;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nint save_dl = dl;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0)\\n\", cl, dl);\\r\\n#endif\\r\\nwhile (c)\\r\\n{\\r\\nt=(a[0]+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nr[0]=t;\\r\\nif (--dl <= 0) break;\\r\\nt=(a[1]+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nr[1]=t;\\r\\nif (--dl <= 0) break;\\r\\nt=(a[2]+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nr[2]=t;\\r\\nif (--dl <= 0) break;\\r\\nt=(a[3]+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nr[3]=t;\\r\\nif (--dl <= 0) break;\\r\\nsave_dl = dl;\\r\\na+=4;\\r\\nr+=4;\\r\\n}\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0, c == 0)\\n\", cl, dl);\\r\\n#endif\\r\\nif (dl > 0)\\r\\n{\\r\\nif (save_dl > dl)\\r\\n{\\r\\nswitch (save_dl - dl)\\r\\n{\\r\\ncase 1:\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0) break;\\r\\ncase 2:\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0) break;\\r\\ncase 3:\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0) break;\\r\\n}\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl > 0)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0, copy)\\n\", cl, dl);\\r\\n#endif\\r\\nfor(;;)\\r\\n{\\r\\nr[0] = a[0];\\r\\nif (--dl <= 0) break;\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0) break;\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0) break;\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0) break;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn c;\\r\\n}\\r\\nvoid bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nint dna, int dnb, BN_ULONG *t)\\r\\n{\\r\\nint n=n2/2,c1,c2;\\r\\nint tna=n+dna, tnb=n+dnb;\\r\\nunsigned int neg,zero;\\r\\nBN_ULONG ln,lo,*p;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_recursive %d * %d\\n\",n2,n2);\\r\\n# endif\\r\\n# ifdef BN_MUL_COMBA\\r\\n# if 0\\r\\nif (n2 == 4)\\r\\n{\\r\\nbn_mul_comba4(r,a,b);\\r\\nreturn;\\r\\n}\\r\\n# endif\\r\\nif (n2 == 8 && dna == 0 && dnb == 0)\\r\\n{\\r\\nbn_mul_comba8(r,a,b);\\r\\nreturn;\\r\\n}\\r\\n# endif\\r\\nif (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_normal(r,a,n2+dna,b,n2+dnb);\\r\\nif ((dna + dnb) < 0)\\r\\nmemset(&r[2*n2 + dna + dnb], 0,\\r\\nsizeof(BN_ULONG) * -(dna + dnb));\\r\\nreturn;\\r\\n}\\r\\nc1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);\\r\\nc2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);\\r\\nzero=neg=0;\\r\\nswitch (c1*3+c2)\\r\\n{\\r\\ncase -4:\\r\\nbn_sub_part_words(t, &(a[n]),a, tna,tna-n);\\r\\nbn_sub_part_words(&(t[n]),b, &(b[n]),tnb,n-tnb);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_part_words(t, &(a[n]),a, tna,tna-n);\\r\\nbn_sub_part_words(&(t[n]),&(b[n]),b, tnb,tnb-n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_part_words(t, a, &(a[n]),tna,n-tna);\\r\\nbn_sub_part_words(&(t[n]),b, &(b[n]),tnb,n-tnb);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_part_words(t, a, &(a[n]),tna,n-tna);\\r\\nbn_sub_part_words(&(t[n]),&(b[n]),b, tnb,tnb-n);\\r\\nbreak;\\r\\n}\\r\\n# ifdef BN_MUL_COMBA\\r\\nif (n == 4 && dna == 0 && dnb == 0)\\r\\n{\\r\\nif (!zero)\\r\\nbn_mul_comba4(&(t[n2]),t,&(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]),0,8*sizeof(BN_ULONG));\\r\\nbn_mul_comba4(r,a,b);\\r\\nbn_mul_comba4(&(r[n2]),&(a[n]),&(b[n]));\\r\\n}\\r\\nelse if (n == 8 && dna == 0 && dnb == 0)\\r\\n{\\r\\nif (!zero)\\r\\nbn_mul_comba8(&(t[n2]),t,&(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]),0,16*sizeof(BN_ULONG));\\r\\nbn_mul_comba8(r,a,b);\\r\\nbn_mul_comba8(&(r[n2]),&(a[n]),&(b[n]));\\r\\n}\\r\\nelse\\r\\n# endif\\r\\n{\\r\\np= &(t[n2*2]);\\r\\nif (!zero)\\r\\nbn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);\\r\\nelse\\r\\nmemset(&(t[n2]),0,n2*sizeof(BN_ULONG));\\r\\nbn_mul_recursive(r,a,b,n,0,0,p);\\r\\nbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,dna,dnb,p);\\r\\n}\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nif (neg)\\r\\n{\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\n}\\r\\nelse\\r\\n{\\r\\nc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\\r\\n}\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < (BN_ULONG)c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,\\r\\nint tna, int tnb, BN_ULONG *t)\\r\\n{\\r\\nint i,j,n2=n*2;\\r\\nint c1,c2,neg,zero;\\r\\nBN_ULONG ln,lo,*p;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_part_recursive (%d+%d) * (%d+%d)\\n\",\\r\\ntna, n, tnb, n);\\r\\n# endif\\r\\nif (n < 8)\\r\\n{\\r\\nbn_mul_normal(r,a,n+tna,b,n+tnb);\\r\\nreturn;\\r\\n}\\r\\nc1=bn_cmp_part_words(a,&(a[n]),tna,n-tna);\\r\\nc2=bn_cmp_part_words(&(b[n]),b,tnb,tnb-n);\\r\\nzero=neg=0;\\r\\nswitch (c1*3+c2)\\r\\n{\\r\\ncase -4:\\r\\nbn_sub_part_words(t, &(a[n]),a, tna,tna-n);\\r\\nbn_sub_part_words(&(t[n]),b, &(b[n]),tnb,n-tnb);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero=1;\\r\\ncase -2:\\r\\nbn_sub_part_words(t, &(a[n]),a, tna,tna-n);\\r\\nbn_sub_part_words(&(t[n]),&(b[n]),b, tnb,tnb-n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero=1;\\r\\ncase 2:\\r\\nbn_sub_part_words(t, a, &(a[n]),tna,n-tna);\\r\\nbn_sub_part_words(&(t[n]),b, &(b[n]),tnb,n-tnb);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero=1;\\r\\ncase 4:\\r\\nbn_sub_part_words(t, a, &(a[n]),tna,n-tna);\\r\\nbn_sub_part_words(&(t[n]),&(b[n]),b, tnb,tnb-n);\\r\\nbreak;\\r\\n}\\r\\n# if 0\\r\\nif (n == 4)\\r\\n{\\r\\nbn_mul_comba4(&(t[n2]),t,&(t[n]));\\r\\nbn_mul_comba4(r,a,b);\\r\\nbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\\r\\nmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\\r\\n}\\r\\nelse\\r\\n# endif\\r\\nif (n == 8)\\r\\n{\\r\\nbn_mul_comba8(&(t[n2]),t,&(t[n]));\\r\\nbn_mul_comba8(r,a,b);\\r\\nbn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);\\r\\nmemset(&(r[n2+tna+tnb]),0,sizeof(BN_ULONG)*(n2-tna-tnb));\\r\\n}\\r\\nelse\\r\\n{\\r\\np= &(t[n2*2]);\\r\\nbn_mul_recursive(&(t[n2]),t,&(t[n]),n,0,0,p);\\r\\nbn_mul_recursive(r,a,b,n,0,0,p);\\r\\ni=n/2;\\r\\nif (tna > tnb)\\r\\nj = tna - i;\\r\\nelse\\r\\nj = tnb - i;\\r\\nif (j == 0)\\r\\n{\\r\\nbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),\\r\\ni,tna-i,tnb-i,p);\\r\\nmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\\r\\n}\\r\\nelse if (j > 0)\\r\\n{\\r\\nbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\\r\\ni,tna-i,tnb-i,p);\\r\\nmemset(&(r[n2+tna+tnb]),0,\\r\\nsizeof(BN_ULONG)*(n2-tna-tnb));\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\\r\\nif (tna < BN_MUL_RECURSIVE_SIZE_NORMAL\\r\\n&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_normal(&(r[n2]),&(a[n]),tna,&(b[n]),tnb);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni/=2;\\r\\nif (i < tna && i < tnb)\\r\\n{\\r\\nbn_mul_part_recursive(&(r[n2]),\\r\\n&(a[n]),&(b[n]),\\r\\ni,tna-i,tnb-i,p);\\r\\nbreak;\\r\\n}\\r\\nelse if (i <= tna && i <= tnb)\\r\\n{\\r\\nbn_mul_recursive(&(r[n2]),\\r\\n&(a[n]),&(b[n]),\\r\\ni,tna-i,tnb-i,p);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nif (neg)\\r\\n{\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\n}\\r\\nelse\\r\\n{\\r\\nc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\\r\\n}\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < (BN_ULONG)c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint n=n2/2;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_low_recursive %d * %d\\n\",n2,n2);\\r\\n# endif\\r\\nbn_mul_recursive(r,a,b,n,0,0,&(t[0]));\\r\\nif (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_low_recursive(&(t[0]),&(a[0]),&(b[n]),n,&(t[n2]));\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\nbn_mul_low_recursive(&(t[0]),&(a[n]),&(b[0]),n,&(t[n2]));\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbn_mul_low_normal(&(t[0]),&(a[0]),&(b[n]),n);\\r\\nbn_mul_low_normal(&(t[n]),&(a[n]),&(b[0]),n);\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[n]),n);\\r\\n}\\r\\n}\\r\\nvoid bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint i,n;\\r\\nint c1,c2;\\r\\nint neg,oneg,zero;\\r\\nBN_ULONG ll,lc,*lp,*mp;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_high %d * %d\\n\",n2,n2);\\r\\n# endif\\r\\nn=n2/2;\\r\\nneg=zero=0;\\r\\nc1=bn_cmp_words(&(a[0]),&(a[n]),n);\\r\\nc2=bn_cmp_words(&(b[n]),&(b[0]),n);\\r\\nswitch (c1*3+c2)\\r\\n{\\r\\ncase -4:\\r\\nbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\\r\\nbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\\r\\nbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\\r\\nbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\\r\\nbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\\r\\nbreak;\\r\\n}\\r\\noneg=neg;\\r\\n# ifdef BN_MUL_COMBA\\r\\nif (n == 8)\\r\\n{\\r\\nbn_mul_comba8(&(t[0]),&(r[0]),&(r[n]));\\r\\nbn_mul_comba8(r,&(a[n]),&(b[n]));\\r\\n}\\r\\nelse\\r\\n# endif\\r\\n{\\r\\nbn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,0,0,&(t[n2]));\\r\\nbn_mul_recursive(r,&(a[n]),&(b[n]),n,0,0,&(t[n2]));\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nc1=(int)(bn_add_words(lp,&(r[0]),&(l[0]),n));\\r\\n}\\r\\nelse\\r\\n{\\r\\nc1=0;\\r\\nlp= &(r[0]);\\r\\n}\\r\\nif (neg)\\r\\nneg=(int)(bn_sub_words(&(t[n2]),lp,&(t[0]),n));\\r\\nelse\\r\\n{\\r\\nbn_add_words(&(t[n2]),lp,&(t[0]),n);\\r\\nneg=0;\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nbn_sub_words(&(t[n2+n]),&(l[n]),&(t[n2]),n);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nmp= &(t[n2]);\\r\\nfor (i=0; i<n; i++)\\r\\nlp[i]=((~mp[i])+1)&BN_MASK2;\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nlp= &(t[n2]);\\r\\nc1= (int)(bn_add_words(lp,&(t[n2+n]),&(l[0]),n));\\r\\n}\\r\\nelse\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nc1=0;\\r\\n}\\r\\nc1+=(int)(bn_add_words(&(t[n2]),lp, &(r[0]),n));\\r\\nif (oneg)\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),&(t[n2]),&(t[0]),n));\\r\\nelse\\r\\nc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),&(t[0]),n));\\r\\nc2 =(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n2+n]),n));\\r\\nc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(r[n]),n));\\r\\nif (oneg)\\r\\nc2-=(int)(bn_sub_words(&(r[0]),&(r[0]),&(t[n]),n));\\r\\nelse\\r\\nc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n]),n));\\r\\nif (c1 != 0)\\r\\n{\\r\\ni=0;\\r\\nif (c1 > 0)\\r\\n{\\r\\nlc=c1;\\r\\ndo {\\r\\nll=(r[i]+lc)&BN_MASK2;\\r\\nr[i++]=ll;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlc= -c1;\\r\\ndo {\\r\\nll=r[i];\\r\\nr[i++]=(ll-lc)&BN_MASK2;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\nif (c2 != 0)\\r\\n{\\r\\ni=n;\\r\\nif (c2 > 0)\\r\\n{\\r\\nlc=c2;\\r\\ndo {\\r\\nll=(r[i]+lc)&BN_MASK2;\\r\\nr[i++]=ll;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlc= -c2;\\r\\ndo {\\r\\nll=r[i];\\r\\nr[i++]=(ll-lc)&BN_MASK2;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nint top,al,bl;\\r\\nBIGNUM *rr;\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nint i;\\r\\n#endif\\r\\n#ifdef BN_RECURSION\\r\\nBIGNUM *t=NULL;\\r\\nint j=0,k;\\r\\n#endif\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\"BN_mul %d * %d\\n\",a->top,b->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(r);\\r\\nal=a->top;\\r\\nbl=b->top;\\r\\nif ((al == 0) || (bl == 0))\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\ntop=al+bl;\\r\\nBN_CTX_start(ctx);\\r\\nif ((r == a) || (r == b))\\r\\n{\\r\\nif ((rr = BN_CTX_get(ctx)) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nrr = r;\\r\\nrr->neg=a->neg^b->neg;\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\ni = al-bl;\\r\\n#endif\\r\\n#ifdef BN_MUL_COMBA\\r\\nif (i == 0)\\r\\n{\\r\\n# if 0\\r\\nif (al == 4)\\r\\n{\\r\\nif (bn_wexpand(rr,8) == NULL) goto err;\\r\\nrr->top=8;\\r\\nbn_mul_comba4(rr->d,a->d,b->d);\\r\\ngoto end;\\r\\n}\\r\\n# endif\\r\\nif (al == 8)\\r\\n{\\r\\nif (bn_wexpand(rr,16) == NULL) goto err;\\r\\nrr->top=16;\\r\\nbn_mul_comba8(rr->d,a->d,b->d);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef BN_RECURSION\\r\\nif ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL))\\r\\n{\\r\\nif (i >= -1 && i <= 1)\\r\\n{\\r\\nint sav_j =0;\\r\\nif (i >= 0)\\r\\n{\\r\\nj = BN_num_bits_word((BN_ULONG)al);\\r\\n}\\r\\nif (i == -1)\\r\\n{\\r\\nj = BN_num_bits_word((BN_ULONG)bl);\\r\\n}\\r\\nsav_j = j;\\r\\nj = 1<<(j-1);\\r\\nassert(j <= al || j <= bl);\\r\\nk = j+j;\\r\\nt = BN_CTX_get(ctx);\\r\\nif (al > j || bl > j)\\r\\n{\\r\\nbn_wexpand(t,k*4);\\r\\nbn_wexpand(rr,k*4);\\r\\nbn_mul_part_recursive(rr->d,a->d,b->d,\\r\\nj,al-j,bl-j,t->d);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbn_wexpand(t,k*2);\\r\\nbn_wexpand(rr,k*2);\\r\\nbn_mul_recursive(rr->d,a->d,b->d,\\r\\nj,al-j,bl-j,t->d);\\r\\n}\\r\\nrr->top=top;\\r\\ngoto end;\\r\\n}\\r\\n#if 0\\r\\nif (i == 1 && !BN_get_flags(b,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nBIGNUM *tmp_bn = (BIGNUM *)b;\\r\\nif (bn_wexpand(tmp_bn,al) == NULL) goto err;\\r\\ntmp_bn->d[bl]=0;\\r\\nbl++;\\r\\ni--;\\r\\n}\\r\\nelse if (i == -1 && !BN_get_flags(a,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nBIGNUM *tmp_bn = (BIGNUM *)a;\\r\\nif (bn_wexpand(tmp_bn,bl) == NULL) goto err;\\r\\ntmp_bn->d[al]=0;\\r\\nal++;\\r\\ni++;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nj=BN_num_bits_word((BN_ULONG)al);\\r\\nj=1<<(j-1);\\r\\nk=j+j;\\r\\nt = BN_CTX_get(ctx);\\r\\nif (al == j)\\r\\n{\\r\\nif (bn_wexpand(t,k*2) == NULL) goto err;\\r\\nif (bn_wexpand(rr,k*2) == NULL) goto err;\\r\\nbn_mul_recursive(rr->d,a->d,b->d,al,t->d);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bn_wexpand(t,k*4) == NULL) goto err;\\r\\nif (bn_wexpand(rr,k*4) == NULL) goto err;\\r\\nbn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);\\r\\n}\\r\\nrr->top=top;\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#endif\\r\\nif (bn_wexpand(rr,top) == NULL) goto err;\\r\\nrr->top=top;\\r\\nbn_mul_normal(rr->d,a->d,al,b->d,bl);\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nend:\\r\\n#endif\\r\\nbn_correct_top(rr);\\r\\nif (r != rr) BN_copy(r,rr);\\r\\nret=1;\\r\\nerr:\\r\\nbn_check_top(r);\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)\\r\\n{\\r\\nBN_ULONG *rr;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_normal %d * %d\\n\",na,nb);\\r\\n#endif\\r\\nif (na < nb)\\r\\n{\\r\\nint itmp;\\r\\nBN_ULONG *ltmp;\\r\\nitmp=na; na=nb; nb=itmp;\\r\\nltmp=a; a=b; b=ltmp;\\r\\n}\\r\\nrr= &(r[na]);\\r\\nif (nb <= 0)\\r\\n{\\r\\n(void)bn_mul_words(r,a,na,0);\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\nrr[0]=bn_mul_words(r,a,na,b[0]);\\r\\nfor (;;)\\r\\n{\\r\\nif (--nb <= 0) return;\\r\\nrr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);\\r\\nif (--nb <= 0) return;\\r\\nrr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);\\r\\nif (--nb <= 0) return;\\r\\nrr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);\\r\\nif (--nb <= 0) return;\\r\\nrr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);\\r\\nrr+=4;\\r\\nr+=4;\\r\\nb+=4;\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\" bn_mul_low_normal %d * %d\\n\",n,n);\\r\\n#endif\\r\\nbn_mul_words(r,a,n,b[0]);\\r\\nfor (;;)\\r\\n{\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[1]),a,n,b[1]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[2]),a,n,b[2]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[3]),a,n,b[3]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[4]),a,n,b[4]);\\r\\nr+=4;\\r\\nb+=4;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_key_c", "target": 0, "func": "int DES_random_key(DES_cblock *ret)\\r\\n{\\r\\ndo\\r\\n{\\r\\nif (RAND_bytes((unsigned char *)ret, sizeof(DES_cblock)) != 1)\\r\\nreturn (0);\\r\\n} while (DES_is_weak_key(ret));\\r\\nDES_set_odd_parity(ret);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2_cbc_c", "target": 0, "func": "void RC2_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nRC2_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC2_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC2_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC2_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC2_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid RC2_encrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i,n;\\r\\nregister RC2_INT *p0,*p1;\\r\\nregister RC2_INT x0,x1,x2,x3,t;\\r\\nunsigned long l;\\r\\nl=d[0];\\r\\nx0=(RC2_INT)l&0xffff;\\r\\nx1=(RC2_INT)(l>>16L);\\r\\nl=d[1];\\r\\nx2=(RC2_INT)l&0xffff;\\r\\nx3=(RC2_INT)(l>>16L);\\r\\nn=3;\\r\\ni=5;\\r\\np0=p1= &(key->data[0]);\\r\\nfor (;;)\\r\\n{\\r\\nt=(x0+(x1& ~x3)+(x2&x3)+ *(p0++))&0xffff;\\r\\nx0=(t<<1)|(t>>15);\\r\\nt=(x1+(x2& ~x0)+(x3&x0)+ *(p0++))&0xffff;\\r\\nx1=(t<<2)|(t>>14);\\r\\nt=(x2+(x3& ~x1)+(x0&x1)+ *(p0++))&0xffff;\\r\\nx2=(t<<3)|(t>>13);\\r\\nt=(x3+(x0& ~x2)+(x1&x2)+ *(p0++))&0xffff;\\r\\nx3=(t<<5)|(t>>11);\\r\\nif (--i == 0)\\r\\n{\\r\\nif (--n == 0) break;\\r\\ni=(n == 2)?6:5;\\r\\nx0+=p1[x3&0x3f];\\r\\nx1+=p1[x0&0x3f];\\r\\nx2+=p1[x1&0x3f];\\r\\nx3+=p1[x2&0x3f];\\r\\n}\\r\\n}\\r\\nd[0]=(unsigned long)(x0&0xffff)|((unsigned long)(x1&0xffff)<<16L);\\r\\nd[1]=(unsigned long)(x2&0xffff)|((unsigned long)(x3&0xffff)<<16L);\\r\\n}\\r\\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i,n;\\r\\nregister RC2_INT *p0,*p1;\\r\\nregister RC2_INT x0,x1,x2,x3,t;\\r\\nunsigned long l;\\r\\nl=d[0];\\r\\nx0=(RC2_INT)l&0xffff;\\r\\nx1=(RC2_INT)(l>>16L);\\r\\nl=d[1];\\r\\nx2=(RC2_INT)l&0xffff;\\r\\nx3=(RC2_INT)(l>>16L);\\r\\nn=3;\\r\\ni=5;\\r\\np0= &(key->data[63]);\\r\\np1= &(key->data[0]);\\r\\nfor (;;)\\r\\n{\\r\\nt=((x3<<11)|(x3>>5))&0xffff;\\r\\nx3=(t-(x0& ~x2)-(x1&x2)- *(p0--))&0xffff;\\r\\nt=((x2<<13)|(x2>>3))&0xffff;\\r\\nx2=(t-(x3& ~x1)-(x0&x1)- *(p0--))&0xffff;\\r\\nt=((x1<<14)|(x1>>2))&0xffff;\\r\\nx1=(t-(x2& ~x0)-(x3&x0)- *(p0--))&0xffff;\\r\\nt=((x0<<15)|(x0>>1))&0xffff;\\r\\nx0=(t-(x1& ~x3)-(x2&x3)- *(p0--))&0xffff;\\r\\nif (--i == 0)\\r\\n{\\r\\nif (--n == 0) break;\\r\\ni=(n == 2)?6:5;\\r\\nx3=(x3-p1[x2&0x3f])&0xffff;\\r\\nx2=(x2-p1[x1&0x3f])&0xffff;\\r\\nx1=(x1-p1[x0&0x3f])&0xffff;\\r\\nx0=(x0-p1[x3&0x3f])&0xffff;\\r\\n}\\r\\n}\\r\\nd[0]=(unsigned long)(x0&0xffff)|((unsigned long)(x1&0xffff)<<16L);\\r\\nd[1]=(unsigned long)(x2&0xffff)|((unsigned long)(x3&0xffff)<<16L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_read_pwd_c", "target": 0, "func": "int des_read_pw_string(char *buf, int length, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nchar buff[BUFSIZ];\\r\\nint ret;\\r\\nret=des_read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);\\r\\nOPENSSL_cleanse(buff,BUFSIZ);\\r\\nreturn(ret);\\r\\n}\\r\\nint des_read_pw(char *buf, char *buff, int size, const char *prompt, int verify)\\r\\n{\\r\\nmemset(buf,0,size);\\r\\nmemset(buff,0,size);\\r\\nreturn(0);\\r\\n}\\r\\nint des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)\\r\\n{\\r\\nmemset(buf,0,size);\\r\\nmemset(buff,0,size);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void read_till_nl(FILE *in)\\r\\n{\\r\\n#define SIZE 4\\r\\nchar buf[SIZE+1];\\r\\ndo {\\r\\nfgets(buf,SIZE,in);\\r\\n} while (strchr(buf,'\\n') == NULL);\\r\\n}\\r\\nint des_read_pw(char *buf, char *buff, int size, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstruct IOSB iosb;\\r\\n$DESCRIPTOR(terminal,\"TT\");\\r\\nlong tty_orig[3], tty_new[3];\\r\\nlong status;\\r\\nunsigned short channel = 0;\\r\\n#else\\r\\n#if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__)\\r\\nTTY_STRUCT tty_orig,tty_new;\\r\\n#endif\\r\\n#endif\\r\\nint number;\\r\\nint ok;\\r\\nstatic int ps;\\r\\nint is_a_tty;\\r\\nstatic FILE *tty;\\r\\nchar *p;\\r\\nif (setjmp(save))\\r\\n{\\r\\nok=0;\\r\\ngoto error;\\r\\n}\\r\\nnumber=5;\\r\\nok=0;\\r\\nps=0;\\r\\nis_a_tty=1;\\r\\ntty=NULL;\\r\\n#ifdef OPENSSL_SYS_MSDOS\\r\\nif ((tty=fopen(\"con\",\"r\")) == NULL)\\r\\ntty=stdin;\\r\\n#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VXWORKS)\\r\\ntty=stdin;\\r\\n#else\\r\\n#ifndef OPENSSL_SYS_MPE\\r\\nif ((tty=fopen(\"/dev/tty\",\"r\")) == NULL)\\r\\n#endif\\r\\ntty=stdin;\\r\\n#endif\\r\\n#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)\\r\\nif (TTY_get(fileno(tty),&tty_orig) == -1)\\r\\n{\\r\\n#ifdef ENOTTY\\r\\nif (errno == ENOTTY)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\n#ifdef EINVAL\\r\\nif (errno == EINVAL)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nmemcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$assign(&terminal,&channel,0,0);\\r\\nif (status != SS$_NORMAL)\\r\\nreturn(-1);\\r\\nstatus=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn(-1);\\r\\n#endif\\r\\npushsig();\\r\\nps=1;\\r\\n#ifdef TTY_FLAGS\\r\\ntty_new.TTY_FLAGS &= ~ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty),&tty_new) == -1))\\r\\n#ifdef OPENSSL_SYS_MPE\\r\\n;\\r\\n#else\\r\\nreturn(-1);\\r\\n#endif\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] | TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn(-1);\\r\\n#endif\\r\\nps=2;\\r\\nwhile ((!ok) && (number--))\\r\\n{\\r\\nfputs(prompt,stderr);\\r\\nfflush(stderr);\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,size,tty);\\r\\nif (feof(tty)) goto error;\\r\\nif (ferror(tty)) goto error;\\r\\nif ((p=(char *)strchr(buf,'\\n')) != NULL)\\r\\n*p='\\0';\\r\\nelse read_till_nl(tty);\\r\\nif (verify)\\r\\n{\\r\\nfprintf(stderr,\"\\nVerifying password - %s\",prompt);\\r\\nfflush(stderr);\\r\\nbuff[0]='\\0';\\r\\nfgets(buff,size,tty);\\r\\nif (feof(tty)) goto error;\\r\\nif ((p=(char *)strchr(buff,'\\n')) != NULL)\\r\\n*p='\\0';\\r\\nelse read_till_nl(tty);\\r\\nif (strcmp(buf,buff) != 0)\\r\\n{\\r\\nfprintf(stderr,\"\\nVerify failure\");\\r\\nfflush(stderr);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nok=1;\\r\\n}\\r\\nerror:\\r\\nfprintf(stderr,\"\\n\");\\r\\n#if 0\\r\\nperror(\"fgets(tty)\");\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (ps >= 2) TTY_set(fileno(tty),&tty_orig);\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nif (ps >= 2)\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0\\r\\n,tty_orig,12,0,0,0,0);\\r\\n#endif\\r\\nif (ps >= 1) popsig();\\r\\nif (stdin != tty) fclose(tty);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$dassgn(channel);\\r\\n#endif\\r\\nreturn(!ok);\\r\\n}\\r\\nstatic void pushsig(void)\\r\\n{\\r\\nint i;\\r\\n#ifdef SIGACTION\\r\\nstruct sigaction sa;\\r\\nmemset(&sa,0,sizeof sa);\\r\\nsa.sa_handler=recsig;\\r\\n#endif\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&sa,&savsig[i]);\\r\\n#else\\r\\nsavsig[i]=signal(i,recsig);\\r\\n#endif\\r\\n}\\r\\n#ifdef SIGWINCH\\r\\nsignal(SIGWINCH,SIG_DFL);\\r\\n#endif\\r\\n}\\r\\nstatic void popsig(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&savsig[i],NULL);\\r\\n#else\\r\\nsignal(i,savsig[i]);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void recsig(int i)\\r\\n{\\r\\nlongjmp(save,1);\\r\\n#ifdef LINT\\r\\ni=i;\\r\\n#endif\\r\\n}\\r\\nstatic int noecho_fgets(char *buf, int size, FILE *tty)\\r\\n{\\r\\nint i;\\r\\nchar *p;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (size == 0)\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\nsize--;\\r\\n#ifdef WIN16TTY\\r\\ni=_inchar();\\r\\n#else\\r\\ni=getch();\\r\\n#endif\\r\\nif (i == '\\r') i='\\n';\\r\\n*(p++)=i;\\r\\nif (i == '\\n')\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#ifdef WIN_CONSOLE_BUG\\r\\n{\\r\\nHANDLE inh;\\r\\ninh = GetStdHandle(STD_INPUT_HANDLE);\\r\\nFlushConsoleInputBuffer(inh);\\r\\n}\\r\\n#endif\\r\\nreturn(strlen(buf));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_mont_c", "target": 0, "func": "int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nBN_MONT_CTX *mont, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *tmp;\\r\\nint ret=0;\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (tmp == NULL) goto err;\\r\\nbn_check_top(tmp);\\r\\nif (a == b)\\r\\n{\\r\\nif (!BN_sqr(tmp,a,ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mul(tmp,a,b,ctx)) goto err;\\r\\n}\\r\\nif (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;\\r\\nbn_check_top(r);\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint retn=0;\\r\\n#ifdef MONT_WORD\\r\\nBIGNUM *n,*r;\\r\\nBN_ULONG *ap,*np,*rp,n0,v,*nrp;\\r\\nint al,nl,max,i,x,ri;\\r\\nBN_CTX_start(ctx);\\r\\nif ((r = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_copy(r,a)) goto err;\\r\\nn= &(mont->N);\\r\\nap=a->d;\\r\\nal=ri=mont->ri/BN_BITS2;\\r\\nnl=n->top;\\r\\nif ((al == 0) || (nl == 0)) { r->top=0; return(1); }\\r\\nmax=(nl+al+1);\\r\\nif (bn_wexpand(r,max) == NULL) goto err;\\r\\nif (bn_wexpand(ret,max) == NULL) goto err;\\r\\nr->neg=a->neg^n->neg;\\r\\nnp=n->d;\\r\\nrp=r->d;\\r\\nnrp= &(r->d[nl]);\\r\\n#if 1\\r\\nfor (i=r->top; i<max; i++)\\r\\nr->d[i]=0;\\r\\n#else\\r\\nmemset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG));\\r\\n#endif\\r\\nr->top=max;\\r\\nn0=mont->n0;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr,\"word BN_from_montgomery %d * %d\\n\",nl,nl);\\r\\n#endif\\r\\nfor (i=0; i<nl; i++)\\r\\n{\\r\\n#ifdef __TANDEM\\r\\n{\\r\\nlong long t1;\\r\\nlong long t2;\\r\\nlong long t3;\\r\\nt1 = rp[0] * (n0 & 0177777);\\r\\nt2 = 037777600000l;\\r\\nt2 = n0 & t2;\\r\\nt3 = rp[0] & 0177777;\\r\\nt2 = (t3 * t2) & BN_MASK2;\\r\\nt1 = t1 + t2;\\r\\nv=bn_mul_add_words(rp,np,nl,(BN_ULONG) t1);\\r\\n}\\r\\n#else\\r\\nv=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);\\r\\n#endif\\r\\nnrp++;\\r\\nrp++;\\r\\nif (((nrp[-1]+=v)&BN_MASK2) >= v)\\r\\ncontinue;\\r\\nelse\\r\\n{\\r\\nif (((++nrp[0])&BN_MASK2) != 0) continue;\\r\\nif (((++nrp[1])&BN_MASK2) != 0) continue;\\r\\nfor (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;\\r\\n}\\r\\n}\\r\\nbn_correct_top(r);\\r\\n#if 0\\r\\nBN_rshift(ret,r,mont->ri);\\r\\n#else\\r\\nret->neg = r->neg;\\r\\nx=ri;\\r\\nrp=ret->d;\\r\\nap= &(r->d[x]);\\r\\nif (r->top < x)\\r\\nal=0;\\r\\nelse\\r\\nal=r->top-x;\\r\\nret->top=al;\\r\\nal-=4;\\r\\nfor (i=0; i<al; i+=4)\\r\\n{\\r\\nBN_ULONG t1,t2,t3,t4;\\r\\nt1=ap[i+0];\\r\\nt2=ap[i+1];\\r\\nt3=ap[i+2];\\r\\nt4=ap[i+3];\\r\\nrp[i+0]=t1;\\r\\nrp[i+1]=t2;\\r\\nrp[i+2]=t3;\\r\\nrp[i+3]=t4;\\r\\n}\\r\\nal+=4;\\r\\nfor (; i<al; i++)\\r\\nrp[i]=ap[i];\\r\\n#endif\\r\\n#else\\r\\nBIGNUM *t1,*t2;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL || t2 == NULL) goto err;\\r\\nif (!BN_copy(t1,a)) goto err;\\r\\nBN_mask_bits(t1,mont->ri);\\r\\nif (!BN_mul(t2,t1,&mont->Ni,ctx)) goto err;\\r\\nBN_mask_bits(t2,mont->ri);\\r\\nif (!BN_mul(t1,t2,&mont->N,ctx)) goto err;\\r\\nif (!BN_add(t2,a,t1)) goto err;\\r\\nif (!BN_rshift(ret,t2,mont->ri)) goto err;\\r\\n#endif\\r\\nif (BN_ucmp(ret, &(mont->N)) >= 0)\\r\\n{\\r\\nif (!BN_usub(ret,ret,&(mont->N))) goto err;\\r\\n}\\r\\nretn=1;\\r\\nbn_check_top(ret);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn(retn);\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_new(void)\\r\\n{\\r\\nBN_MONT_CTX *ret;\\r\\nif ((ret=(BN_MONT_CTX *)OPENSSL_malloc(sizeof(BN_MONT_CTX))) == NULL)\\r\\nreturn(NULL);\\r\\nBN_MONT_CTX_init(ret);\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BN_MONT_CTX_init(BN_MONT_CTX *ctx)\\r\\n{\\r\\nctx->ri=0;\\r\\nBN_init(&(ctx->RR));\\r\\nBN_init(&(ctx->N));\\r\\nBN_init(&(ctx->Ni));\\r\\nctx->flags=0;\\r\\n}\\r\\nvoid BN_MONT_CTX_free(BN_MONT_CTX *mont)\\r\\n{\\r\\nif(mont == NULL)\\r\\nreturn;\\r\\nBN_free(&(mont->RR));\\r\\nBN_free(&(mont->N));\\r\\nBN_free(&(mont->Ni));\\r\\nif (mont->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(mont);\\r\\n}\\r\\nint BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *Ri,*R;\\r\\nBN_CTX_start(ctx);\\r\\nif((Ri = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nR= &(mont->RR);\\r\\nif (!BN_copy(&(mont->N),mod)) goto err;\\r\\nmont->N.neg = 0;\\r\\n#ifdef MONT_WORD\\r\\n{\\r\\nBIGNUM tmod;\\r\\nBN_ULONG buf[2];\\r\\nmont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;\\r\\nBN_zero(R);\\r\\nif (!(BN_set_bit(R,BN_BITS2))) goto err;\\r\\nbuf[0]=mod->d[0];\\r\\nbuf[1]=0;\\r\\ntmod.d=buf;\\r\\ntmod.top=1;\\r\\ntmod.dmax=2;\\r\\ntmod.neg=0;\\r\\nif ((BN_mod_inverse(Ri,R,&tmod,ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_lshift(Ri,Ri,BN_BITS2)) goto err;\\r\\nif (!BN_is_zero(Ri))\\r\\n{\\r\\nif (!BN_sub_word(Ri,1)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_set_word(Ri,BN_MASK2)) goto err;\\r\\n}\\r\\nif (!BN_div(Ri,NULL,Ri,&tmod,ctx)) goto err;\\r\\nmont->n0 = (Ri->top > 0) ? Ri->d[0] : 0;\\r\\n}\\r\\n#else\\r\\n{\\r\\nmont->ri=BN_num_bits(&mont->N);\\r\\nBN_zero(R);\\r\\nif (!BN_set_bit(R,mont->ri)) goto err;\\r\\nif ((BN_mod_inverse(Ri,R,&mont->N,ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_lshift(Ri,Ri,mont->ri)) goto err;\\r\\nif (!BN_sub_word(Ri,1)) goto err;\\r\\nif (!BN_div(&(mont->Ni),NULL,Ri,&mont->N,ctx)) goto err;\\r\\n}\\r\\n#endif\\r\\nBN_zero(&(mont->RR));\\r\\nif (!BN_set_bit(&(mont->RR),mont->ri*2)) goto err;\\r\\nif (!BN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)\\r\\n{\\r\\nif (to == from) return(to);\\r\\nif (!BN_copy(&(to->RR),&(from->RR))) return NULL;\\r\\nif (!BN_copy(&(to->N),&(from->N))) return NULL;\\r\\nif (!BN_copy(&(to->Ni),&(from->Ni))) return NULL;\\r\\nto->ri=from->ri;\\r\\nto->n0=from->n0;\\r\\nreturn(to);\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,\\r\\nconst BIGNUM *mod, BN_CTX *ctx)\\r\\n{\\r\\nif (*pmont)\\r\\nreturn *pmont;\\r\\nCRYPTO_w_lock(lock);\\r\\nif (!*pmont)\\r\\n{\\r\\n*pmont = BN_MONT_CTX_new();\\r\\nif (*pmont && !BN_MONT_CTX_set(*pmont, mod, ctx))\\r\\n{\\r\\nBN_MONT_CTX_free(*pmont);\\r\\n*pmont = NULL;\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(lock);\\r\\nreturn *pmont;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_unix_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nu_int32_t rnd = 0, i;\\r\\nunsigned char buf[ENTROPY_NEEDED];\\r\\nfor (i = 0; i < sizeof(buf); i++) {\\r\\nif (i % 4 == 0)\\r\\nrnd = arc4random();\\r\\nbuf[i] = rnd;\\r\\nrnd >>= 8;\\r\\n}\\r\\nRAND_add(buf, sizeof(buf), ENTROPY_NEEDED);\\r\\nmemset(buf, 0, sizeof(buf));\\r\\nreturn 1;\\r\\n}\\r\\nint RAND_poll(void)\\r\\n{\\r\\nunsigned long l;\\r\\npid_t curr_pid = getpid();\\r\\n#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nunsigned char tmpbuf[ENTROPY_NEEDED];\\r\\nint n = 0;\\r\\n#endif\\r\\n#ifdef DEVRANDOM\\r\\nstatic const char *randomfiles[] = { DEVRANDOM };\\r\\nstruct stat randomstats[sizeof(randomfiles)/sizeof(randomfiles[0])];\\r\\nint fd,i;\\r\\n#endif\\r\\n#ifdef DEVRANDOM_EGD\\r\\nstatic const char *egdsockets[] = { DEVRANDOM_EGD, NULL };\\r\\nconst char **egdsocket = NULL;\\r\\n#endif\\r\\n#ifdef DEVRANDOM\\r\\nmemset(randomstats,0,sizeof(randomstats));\\r\\nfor (i=0; i<sizeof(randomfiles)/sizeof(randomfiles[0]) && n < ENTROPY_NEEDED; i++)\\r\\n{\\r\\nif ((fd = open(randomfiles[i], O_RDONLY\\r\\n#ifdef O_NONBLOCK\\r\\n|O_NONBLOCK\\r\\n#endif\\r\\n#ifdef O_BINARY\\r\\n|O_BINARY\\r\\n#endif\\r\\n#ifdef O_NOCTTY\\r\\n|O_NOCTTY\\r\\n#endif\\r\\n)) >= 0)\\r\\n{\\r\\nstruct timeval t = { 0, 10*1000 };\\r\\nint r,j;\\r\\nfd_set fset;\\r\\nstruct stat *st=&randomstats[i];\\r\\nif (fstat(fd,st) != 0) { close(fd); continue; }\\r\\nfor (j=0;j<i;j++)\\r\\n{\\r\\nif (randomstats[j].st_ino==st->st_ino &&\\r\\nrandomstats[j].st_dev==st->st_dev)\\r\\nbreak;\\r\\n}\\r\\nif (j<i) { close(fd); continue; }\\r\\ndo\\r\\n{\\r\\nFD_ZERO(&fset);\\r\\nFD_SET(fd, &fset);\\r\\nr = -1;\\r\\nif (select(fd+1,&fset,NULL,NULL,&t) < 0)\\r\\nt.tv_usec=0;\\r\\nelse if (FD_ISSET(fd, &fset))\\r\\n{\\r\\nr=read(fd,(unsigned char *)tmpbuf+n,\\r\\nENTROPY_NEEDED-n);\\r\\nif (r > 0)\\r\\nn += r;\\r\\n}\\r\\nif (t.tv_usec == 10*1000)\\r\\nt.tv_usec=0;\\r\\n}\\r\\nwhile ((r > 0 || (errno == EINTR || errno == EAGAIN))\\r\\n&& t.tv_usec != 0 && n < ENTROPY_NEEDED);\\r\\nclose(fd);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef DEVRANDOM_EGD\\r\\nfor (egdsocket = egdsockets; *egdsocket && n < ENTROPY_NEEDED; egdsocket++)\\r\\n{\\r\\nint r;\\r\\nr = RAND_query_egd_bytes(*egdsocket, (unsigned char *)tmpbuf+n,\\r\\nENTROPY_NEEDED-n);\\r\\nif (r > 0)\\r\\nn += r;\\r\\n}\\r\\n#endif\\r\\n#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nif (n > 0)\\r\\n{\\r\\nRAND_add(tmpbuf,sizeof tmpbuf,(double)n);\\r\\nOPENSSL_cleanse(tmpbuf,n);\\r\\n}\\r\\n#endif\\r\\nl=curr_pid;\\r\\nRAND_add(&l,sizeof(l),0.0);\\r\\nl=getuid();\\r\\nRAND_add(&l,sizeof(l),0.0);\\r\\nl=time(NULL);\\r\\nRAND_add(&l,sizeof(l),0.0);\\r\\n#if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nreturn 1;\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nint RAND_poll(void)\\r\\n{\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_acnf_c", "target": 0, "func": "void OPENSSL_add_all_algorithms_conf(void)\\r\\n{\\r\\nOPENSSL_add_all_algorithms_noconf();\\r\\nOPENSSL_config(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_enc_c", "target": 0, "func": "void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(ctx,0,sizeof(EVP_CIPHER_CTX));\\r\\n}\\r\\nint EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv, int enc)\\r\\n{\\r\\nif (cipher)\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nreturn EVP_CipherInit_ex(ctx,cipher,NULL,key,iv,enc);\\r\\n}\\r\\nint EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,\\r\\nconst unsigned char *key, const unsigned char *iv, int enc)\\r\\n{\\r\\nif (enc == -1)\\r\\nenc = ctx->encrypt;\\r\\nelse\\r\\n{\\r\\nif (enc)\\r\\nenc = 1;\\r\\nctx->encrypt = enc;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine && ctx->cipher && (!cipher ||\\r\\n(cipher && (cipher->nid == ctx->cipher->nid))))\\r\\ngoto skip_to_init;\\r\\n#endif\\r\\nif (cipher)\\r\\n{\\r\\nEVP_CIPHER_CTX_cleanup(ctx);\\r\\nctx->encrypt = enc;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif(impl)\\r\\n{\\r\\nif (!ENGINE_init(impl))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse\\r\\nimpl = ENGINE_get_cipher_engine(cipher->nid);\\r\\nif(impl)\\r\\n{\\r\\nconst EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);\\r\\nif(!c)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\ncipher = c;\\r\\nctx->engine = impl;\\r\\n}\\r\\nelse\\r\\nctx->engine = NULL;\\r\\n#endif\\r\\nctx->cipher=cipher;\\r\\nif (ctx->cipher->ctx_size)\\r\\n{\\r\\nctx->cipher_data=OPENSSL_malloc(ctx->cipher->ctx_size);\\r\\nif (!ctx->cipher_data)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->cipher_data = NULL;\\r\\n}\\r\\nctx->key_len = cipher->key_len;\\r\\nctx->flags = 0;\\r\\nif(ctx->cipher->flags & EVP_CIPH_CTRL_INIT)\\r\\n{\\r\\nif(!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse if(!ctx->cipher)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nskip_to_init:\\r\\n#endif\\r\\nOPENSSL_assert(ctx->cipher->block_size == 1\\r\\n|| ctx->cipher->block_size == 8\\r\\n|| ctx->cipher->block_size == 16);\\r\\nif(!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {\\r\\nswitch(EVP_CIPHER_CTX_mode(ctx)) {\\r\\ncase EVP_CIPH_STREAM_CIPHER:\\r\\ncase EVP_CIPH_ECB_MODE:\\r\\nbreak;\\r\\ncase EVP_CIPH_CFB_MODE:\\r\\ncase EVP_CIPH_OFB_MODE:\\r\\nctx->num = 0;\\r\\ncase EVP_CIPH_CBC_MODE:\\r\\nOPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=\\r\\n(int)sizeof(ctx->iv));\\r\\nif(iv) memcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nmemcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif(key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {\\r\\nif(!ctx->cipher->init(ctx,key,iv,enc)) return 0;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->final_used=0;\\r\\nctx->block_mask=ctx->cipher->block_size-1;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptUpdate(ctx,out,outl,in,inl);\\r\\nelse return EVP_DecryptUpdate(ctx,out,outl,in,inl);\\r\\n}\\r\\nint EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptFinal_ex(ctx,out,outl);\\r\\nelse return EVP_DecryptFinal_ex(ctx,out,outl);\\r\\n}\\r\\nint EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptFinal(ctx,out,outl);\\r\\nelse return EVP_DecryptFinal(ctx,out,outl);\\r\\n}\\r\\nint EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit(ctx, cipher, key, iv, 1);\\r\\n}\\r\\nint EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,const EVP_CIPHER *cipher, ENGINE *impl,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);\\r\\n}\\r\\nint EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit(ctx, cipher, key, iv, 0);\\r\\n}\\r\\nint EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);\\r\\n}\\r\\nint EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint i,j,bl;\\r\\nOPENSSL_assert(inl > 0);\\r\\nif(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)\\r\\n{\\r\\nif(ctx->cipher->do_cipher(ctx,out,in,inl))\\r\\n{\\r\\n*outl=inl;\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*outl=0;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\ni=ctx->buf_len;\\r\\nbl=ctx->cipher->block_size;\\r\\nOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\\r\\nif (i != 0)\\r\\n{\\r\\nif (i+inl < bl)\\r\\n{\\r\\nmemcpy(&(ctx->buf[i]),in,inl);\\r\\nctx->buf_len+=inl;\\r\\n*outl=0;\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=bl-i;\\r\\nmemcpy(&(ctx->buf[i]),in,j);\\r\\nif(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;\\r\\ninl-=j;\\r\\nin+=j;\\r\\nout+=bl;\\r\\n*outl=bl;\\r\\n}\\r\\n}\\r\\nelse\\r\\n*outl = 0;\\r\\ni=inl&(bl-1);\\r\\ninl-=i;\\r\\nif (inl > 0)\\r\\n{\\r\\nif(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;\\r\\n*outl+=inl;\\r\\n}\\r\\nif (i != 0)\\r\\nmemcpy(ctx->buf,&(in[inl]),i);\\r\\nctx->buf_len=i;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_EncryptFinal_ex(ctx, out, outl);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint n,ret;\\r\\nunsigned int i, b, bl;\\r\\nb=ctx->cipher->block_size;\\r\\nOPENSSL_assert(b <= sizeof ctx->buf);\\r\\nif (b == 1)\\r\\n{\\r\\n*outl=0;\\r\\nreturn 1;\\r\\n}\\r\\nbl=ctx->buf_len;\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING)\\r\\n{\\r\\nif(bl)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n}\\r\\nn=b-bl;\\r\\nfor (i=bl; i<b; i++)\\r\\nctx->buf[i]=n;\\r\\nret=ctx->cipher->do_cipher(ctx,out,ctx->buf,b);\\r\\nif(ret)\\r\\n*outl=b;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint fix_len;\\r\\nunsigned int b;\\r\\nif (inl == 0)\\r\\n{\\r\\n*outl=0;\\r\\nreturn 1;\\r\\n}\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING)\\r\\nreturn EVP_EncryptUpdate(ctx, out, outl, in, inl);\\r\\nb=ctx->cipher->block_size;\\r\\nOPENSSL_assert(b <= sizeof ctx->final);\\r\\nif(ctx->final_used)\\r\\n{\\r\\nmemcpy(out,ctx->final,b);\\r\\nout+=b;\\r\\nfix_len = 1;\\r\\n}\\r\\nelse\\r\\nfix_len = 0;\\r\\nif(!EVP_EncryptUpdate(ctx,out,outl,in,inl))\\r\\nreturn 0;\\r\\nif (b > 1 && !ctx->buf_len)\\r\\n{\\r\\n*outl-=b;\\r\\nctx->final_used=1;\\r\\nmemcpy(ctx->final,&out[*outl],b);\\r\\n}\\r\\nelse\\r\\nctx->final_used = 0;\\r\\nif (fix_len)\\r\\n*outl += b;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_DecryptFinal_ex(ctx, out, outl);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i,n;\\r\\nunsigned int b;\\r\\n*outl=0;\\r\\nb=ctx->cipher->block_size;\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING)\\r\\n{\\r\\nif(ctx->buf_len)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (b > 1)\\r\\n{\\r\\nif (ctx->buf_len || !ctx->final_used)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\nOPENSSL_assert(b <= sizeof ctx->final);\\r\\nn=ctx->final[b-1];\\r\\nif (n > (int)b)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif (ctx->final[--b] != n)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nn=ctx->cipher->block_size-n;\\r\\nfor (i=0; i<n; i++)\\r\\nout[i]=ctx->final[i];\\r\\n*outl=n;\\r\\n}\\r\\nelse\\r\\n*outl=0;\\r\\nreturn(1);\\r\\n}\\r\\nint EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)\\r\\n{\\r\\nif (c->cipher != NULL)\\r\\n{\\r\\nif(c->cipher->cleanup && !c->cipher->cleanup(c))\\r\\nreturn 0;\\r\\nif (c->cipher_data)\\r\\nOPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);\\r\\n}\\r\\nif (c->cipher_data)\\r\\nOPENSSL_free(c->cipher_data);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (c->engine)\\r\\nENGINE_finish(c->engine);\\r\\n#endif\\r\\nmemset(c,0,sizeof(EVP_CIPHER_CTX));\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)\\r\\n{\\r\\nif(c->cipher->flags & EVP_CIPH_CUSTOM_KEY_LENGTH)\\r\\nreturn EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);\\r\\nif(c->key_len == keylen) return 1;\\r\\nif((keylen > 0) && (c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH))\\r\\n{\\r\\nc->key_len = keylen;\\r\\nreturn 1;\\r\\n}\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH,EVP_R_INVALID_KEY_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)\\r\\n{\\r\\nif (pad) ctx->flags &= ~EVP_CIPH_NO_PADDING;\\r\\nelse ctx->flags |= EVP_CIPH_NO_PADDING;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)\\r\\n{\\r\\nint ret;\\r\\nif(!ctx->cipher) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);\\r\\nreturn 0;\\r\\n}\\r\\nif(!ctx->cipher->ctrl) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nret = ctx->cipher->ctrl(ctx, type, arg, ptr);\\r\\nif(ret == -1) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)\\r\\n{\\r\\nif (ctx->cipher->flags & EVP_CIPH_RAND_KEY)\\r\\nreturn EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);\\r\\nif (RAND_bytes(key, ctx->key_len) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_ctr_c", "target": 0, "func": "static void AES_ctr128_inc(unsigned char *counter) {\\r\\nunsigned long c;\\r\\nc = GETU32(counter + 12);\\r\\nc++; c &= 0xFFFFFFFF;\\r\\nPUTU32(counter + 12, c);\\r\\nif (c)\\r\\nreturn;\\r\\nc = GETU32(counter + 8);\\r\\nc++; c &= 0xFFFFFFFF;\\r\\nPUTU32(counter + 8, c);\\r\\nif (c)\\r\\nreturn;\\r\\nc = GETU32(counter + 4);\\r\\nc++; c &= 0xFFFFFFFF;\\r\\nPUTU32(counter + 4, c);\\r\\nif (c)\\r\\nreturn;\\r\\nc = GETU32(counter + 0);\\r\\nc++; c &= 0xFFFFFFFF;\\r\\nPUTU32(counter + 0, c);\\r\\n}\\r\\nvoid AES_ctr128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char ivec[AES_BLOCK_SIZE],\\r\\nunsigned char ecount_buf[AES_BLOCK_SIZE],\\r\\nunsigned int *num) {\\r\\nunsigned int n;\\r\\nunsigned long l=length;\\r\\nassert(in && out && key && counter && num);\\r\\nassert(*num < AES_BLOCK_SIZE);\\r\\nn = *num;\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nAES_encrypt(ivec, ecount_buf, key);\\r\\nAES_ctr128_inc(ivec);\\r\\n}\\r\\n*(out++) = *(in++) ^ ecount_buf[n];\\r\\nn = (n+1) % AES_BLOCK_SIZE;\\r\\n}\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_nw_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nunsigned long l;\\r\\nunsigned long tsc;\\r\\nint i;\\r\\nl = GetProcessSwitchCount();\\r\\nRAND_add(&l,sizeof(l),1);\\r\\nl=RunningProcess;\\r\\nRAND_add(&l,sizeof(l),1);\\r\\nfor( i=2; i<ENTROPY_NEEDED; i++)\\r\\n{\\r\\n#ifdef __MWERKS__\\r\\nasm\\r\\n{\\r\\nrdtsc\\r\\nmov tsc, eax\\r\\n}\\r\\n#else\\r\\nasm volatile(\"rdtsc\":\"=A\" (tsc));\\r\\n#endif\\r\\nRAND_add(&tsc, sizeof(tsc), 1);\\r\\nl = GetSuperHighResolutionTimer();\\r\\nRAND_add(&l, sizeof(l), 0);\\r\\n# if defined(NETWARE_LIBC)\\r\\nNXThreadYield();\\r\\n# else\\r\\nThreadSwitchWithDelay();\\r\\n# endif\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_example1_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nERR_load_crypto_strings();\\r\\nif ((argc == 1))\\r\\n{\\r\\nmain_encrypt();\\r\\n}\\r\\nelse if ((argc == 2) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\nmain_decrypt();\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"%s\",usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid main_encrypt(void)\\r\\n{\\r\\nunsigned int ebuflen;\\r\\nEVP_CIPHER_CTX ectx;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *ekey[1];\\r\\nint readlen;\\r\\nint ekeylen, net_ekeylen;\\r\\nEVP_PKEY *pubKey[1];\\r\\nchar buf[512];\\r\\nchar ebuf[512];\\r\\nmemset(iv, '\\0', sizeof(iv));\\r\\npubKey[0] = ReadPublicKey(PUBFILE);\\r\\nif(!pubKey[0])\\r\\n{\\r\\nfprintf(stderr,\"Error: can't load public key\");\\r\\nexit(1);\\r\\n}\\r\\nekey[0] = malloc(EVP_PKEY_size(pubKey[0]));\\r\\nif (!ekey[0])\\r\\n{\\r\\nEVP_PKEY_free(pubKey[0]);\\r\\nperror(\"malloc\");\\r\\nexit(1);\\r\\n}\\r\\nEVP_SealInit(&ectx,\\r\\nEVP_des_ede3_cbc(),\\r\\nekey,\\r\\n&ekeylen,\\r\\niv,\\r\\npubKey,\\r\\n1);\\r\\nnet_ekeylen = htonl(ekeylen);\\r\\nwrite(STDOUT, (char*)&net_ekeylen, sizeof(net_ekeylen));\\r\\nwrite(STDOUT, ekey[0], ekeylen);\\r\\nwrite(STDOUT, iv, sizeof(iv));\\r\\nwhile(1)\\r\\n{\\r\\nreadlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (readlen < 0)\\r\\nperror(\"read\");\\r\\nbreak;\\r\\n}\\r\\nEVP_SealUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_SealFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\nEVP_PKEY_free(pubKey[0]);\\r\\nfree(ekey[0]);\\r\\n}\\r\\nvoid main_decrypt(void)\\r\\n{\\r\\nchar buf[520];\\r\\nchar ebuf[512];\\r\\nunsigned int buflen;\\r\\nEVP_CIPHER_CTX ectx;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *encryptKey;\\r\\nunsigned int ekeylen;\\r\\nEVP_PKEY *privateKey;\\r\\nmemset(iv, '\\0', sizeof(iv));\\r\\nprivateKey = ReadPrivateKey(PRIVFILE);\\r\\nif (!privateKey)\\r\\n{\\r\\nfprintf(stderr, \"Error: can't load private key\");\\r\\nexit(1);\\r\\n}\\r\\nread(STDIN, &ekeylen, sizeof(ekeylen));\\r\\nekeylen = ntohl(ekeylen);\\r\\nif (ekeylen != EVP_PKEY_size(privateKey))\\r\\n{\\r\\nEVP_PKEY_free(privateKey);\\r\\nfprintf(stderr, \"keylength mismatch\");\\r\\nexit(1);\\r\\n}\\r\\nencryptKey = malloc(sizeof(char) * ekeylen);\\r\\nif (!encryptKey)\\r\\n{\\r\\nEVP_PKEY_free(privateKey);\\r\\nperror(\"malloc\");\\r\\nexit(1);\\r\\n}\\r\\nread(STDIN, encryptKey, ekeylen);\\r\\nread(STDIN, iv, sizeof(iv));\\r\\nEVP_OpenInit(&ectx,\\r\\nEVP_des_ede3_cbc(),\\r\\nencryptKey,\\r\\nekeylen,\\r\\niv,\\r\\nprivateKey);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, ebuf, sizeof(ebuf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (readlen < 0)\\r\\nperror(\"read\");\\r\\nbreak;\\r\\n}\\r\\nEVP_OpenUpdate(&ectx, buf, &buflen, ebuf, readlen);\\r\\nwrite(STDOUT, buf, buflen);\\r\\n}\\r\\nEVP_OpenFinal(&ectx, buf, &buflen);\\r\\nwrite(STDOUT, buf, buflen);\\r\\nEVP_PKEY_free(privateKey);\\r\\nfree(encryptKey);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_des3_c", "target": 0, "func": "static int des_ede_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nDES_ecb3_encrypt((const_DES_cblock *)(in + i),\\r\\n(DES_cblock *)(out + i),\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3,\\r\\nctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_ede3_ofb64_encrypt(in, out, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\\r\\n(DES_cblock *)ctx->iv, &ctx->num);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nchar *cp;\\r\\nprintf(\"des_ede_cbc_cipher(ctx=%lx, buflen=%d)\\n\", ctx, ctx->buf_len);\\r\\nprintf(\"\\t iv= \");\\r\\nfor(i=0;i<8;i++)\\r\\nprintf(\"%02X\",ctx->iv[i]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nDES_ede3_cbc_encrypt(in, out, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_ede3_cfb64_encrypt(in, out, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2, &data(ctx)->ks3,\\r\\n(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int n;\\r\\nunsigned char c[1],d[1];\\r\\nfor(n=0 ; n < inl ; ++n)\\r\\n{\\r\\nc[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;\\r\\nDES_ede3_cfb_encrypt(c,d,1,1,\\r\\n&data(ctx)->ks1,&data(ctx)->ks2,&data(ctx)->ks3,\\r\\n(DES_cblock *)ctx->iv,ctx->encrypt);\\r\\nout[n/8]=(out[n/8]&~(0x80 >> (n%8)))|((d[0]&0x80) >> (n%8));\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_ede3_cfb_encrypt(in,out,8,inl,\\r\\n&data(ctx)->ks1,&data(ctx)->ks2,&data(ctx)->ks3,\\r\\n(DES_cblock *)ctx->iv,ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\n#ifdef EVP_CHECK_DES_KEY\\r\\nif (DES_set_key_checked(&deskey[0],&data(ctx)->ks1)\\r\\n!! DES_set_key_checked(&deskey[1],&data(ctx)->ks2))\\r\\nreturn 0;\\r\\n#else\\r\\nDES_set_key_unchecked(&deskey[0],&data(ctx)->ks1);\\r\\nDES_set_key_unchecked(&deskey[1],&data(ctx)->ks2);\\r\\n#endif\\r\\nmemcpy(&data(ctx)->ks3,&data(ctx)->ks1,\\r\\nsizeof(data(ctx)->ks1));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nprintf(\"des_ede3_init_key(ctx=%lx)\\n\", ctx);\\r\\nprintf(\"\\tKEY= \");\\r\\nfor(i=0;i<24;i++) printf(\"%02X\",key[i]); printf(\"\\n\");\\r\\nprintf(\"\\t IV= \");\\r\\nfor(i=0;i<8;i++) printf(\"%02X\",iv[i]); printf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\n#ifdef EVP_CHECK_DES_KEY\\r\\nif (DES_set_key_checked(&deskey[0],&data(ctx)->ks1)\\r\\n|| DES_set_key_checked(&deskey[1],&data(ctx)->ks2)\\r\\n|| DES_set_key_checked(&deskey[2],&data(ctx)->ks3))\\r\\nreturn 0;\\r\\n#else\\r\\nDES_set_key_unchecked(&deskey[0],&data(ctx)->ks1);\\r\\nDES_set_key_unchecked(&deskey[1],&data(ctx)->ks2);\\r\\nDES_set_key_unchecked(&deskey[2],&data(ctx)->ks3);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des3_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nDES_cblock *deskey = ptr;\\r\\nswitch(type)\\r\\n{\\r\\ncase EVP_CTRL_RAND_KEY:\\r\\nif (RAND_bytes(ptr, c->key_len) <= 0)\\r\\nreturn 0;\\r\\nDES_set_odd_parity(deskey);\\r\\nif (c->key_len >= 16)\\r\\nDES_set_odd_parity(deskey + 1);\\r\\nif (c->key_len >= 24)\\r\\nDES_set_odd_parity(deskey + 2);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede(void)\\r\\n{\\r\\nreturn &des_ede_ecb;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede3(void)\\r\\n{\\r\\nreturn &des_ede3_ecb;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t_bitst_c", "target": 0, "func": "int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,\\r\\nBIT_STRING_BITNAME *tbl, int indent)\\r\\n{\\r\\nBIT_STRING_BITNAME *bnam;\\r\\nchar first = 1;\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nfor(bnam = tbl; bnam->lname; bnam++) {\\r\\nif(ASN1_BIT_STRING_get_bit(bs, bnam->bitnum)) {\\r\\nif(!first) BIO_puts(out, \", \");\\r\\nBIO_puts(out, bnam->lname);\\r\\nfirst = 0;\\r\\n}\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,\\r\\nBIT_STRING_BITNAME *tbl)\\r\\n{\\r\\nint bitnum;\\r\\nbitnum = ASN1_BIT_STRING_num_asc(name, tbl);\\r\\nif(bitnum < 0) return 0;\\r\\nif(bs) {\\r\\nif(!ASN1_BIT_STRING_set_bit(bs, bitnum, value))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl)\\r\\n{\\r\\nBIT_STRING_BITNAME *bnam;\\r\\nfor(bnam = tbl; bnam->lname; bnam++) {\\r\\nif(!strcmp(bnam->sname, name) ||\\r\\n!strcmp(bnam->lname, name) ) return bnam->bitnum;\\r\\n}\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mem_c", "target": 0, "func": "static void *default_malloc_ex(size_t num, const char *file, int line)\\r\\n{ return malloc_func(num); }\\r\\nstatic void *default_realloc_ex(void *str, size_t num,\\r\\nconst char *file, int line)\\r\\n{ return realloc_func(str,num); }\\r\\nstatic void *default_malloc_locked_ex(size_t num, const char *file, int line)\\r\\n{ return malloc_locked_func(num); }\\r\\nint CRYPTO_set_mem_functions(void *(*m)(size_t), void *(*r)(void *, size_t),\\r\\nvoid (*f)(void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == 0) || (r == 0) || (f == 0))\\r\\nreturn 0;\\r\\nmalloc_func=m; malloc_ex_func=default_malloc_ex;\\r\\nrealloc_func=r; realloc_ex_func=default_realloc_ex;\\r\\nfree_func=f;\\r\\nmalloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;\\r\\nfree_locked_func=f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_mem_ex_functions(\\r\\nvoid *(*m)(size_t,const char *,int),\\r\\nvoid *(*r)(void *, size_t,const char *,int),\\r\\nvoid (*f)(void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == 0) || (r == 0) || (f == 0))\\r\\nreturn 0;\\r\\nmalloc_func=0; malloc_ex_func=m;\\r\\nrealloc_func=0; realloc_ex_func=r;\\r\\nfree_func=f;\\r\\nmalloc_locked_func=0; malloc_locked_ex_func=m;\\r\\nfree_locked_func=f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_locked_mem_functions(void *(*m)(size_t), void (*f)(void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == NULL) || (f == NULL))\\r\\nreturn 0;\\r\\nmalloc_locked_func=m; malloc_locked_ex_func=default_malloc_locked_ex;\\r\\nfree_locked_func=f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_locked_mem_ex_functions(\\r\\nvoid *(*m)(size_t,const char *,int),\\r\\nvoid (*f)(void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == NULL) || (f == NULL))\\r\\nreturn 0;\\r\\nmalloc_locked_func=0; malloc_locked_ex_func=m;\\r\\nfree_func=f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_mem_debug_functions(void (*m)(void *,int,const char *,int,int),\\r\\nvoid (*r)(void *,void *,int,const char *,int,int),\\r\\nvoid (*f)(void *,int),\\r\\nvoid (*so)(long),\\r\\nlong (*go)(void))\\r\\n{\\r\\nif (!allow_customize_debug)\\r\\nreturn 0;\\r\\nmalloc_debug_func=m;\\r\\nrealloc_debug_func=r;\\r\\nfree_debug_func=f;\\r\\nset_debug_options_func=so;\\r\\nget_debug_options_func=go;\\r\\nreturn 1;\\r\\n}\\r\\nvoid CRYPTO_get_mem_functions(void *(**m)(size_t), void *(**r)(void *, size_t),\\r\\nvoid (**f)(void *))\\r\\n{\\r\\nif (m != NULL) *m = (malloc_ex_func == default_malloc_ex) ?\\r\\nmalloc_func : 0;\\r\\nif (r != NULL) *r = (realloc_ex_func == default_realloc_ex) ?\\r\\nrealloc_func : 0;\\r\\nif (f != NULL) *f=free_func;\\r\\n}\\r\\nvoid CRYPTO_get_mem_ex_functions(\\r\\nvoid *(**m)(size_t,const char *,int),\\r\\nvoid *(**r)(void *, size_t,const char *,int),\\r\\nvoid (**f)(void *))\\r\\n{\\r\\nif (m != NULL) *m = (malloc_ex_func != default_malloc_ex) ?\\r\\nmalloc_ex_func : 0;\\r\\nif (r != NULL) *r = (realloc_ex_func != default_realloc_ex) ?\\r\\nrealloc_ex_func : 0;\\r\\nif (f != NULL) *f=free_func;\\r\\n}\\r\\nvoid CRYPTO_get_locked_mem_functions(void *(**m)(size_t), void (**f)(void *))\\r\\n{\\r\\nif (m != NULL) *m = (malloc_locked_ex_func == default_malloc_locked_ex) ?\\r\\nmalloc_locked_func : 0;\\r\\nif (f != NULL) *f=free_locked_func;\\r\\n}\\r\\nvoid CRYPTO_get_locked_mem_ex_functions(\\r\\nvoid *(**m)(size_t,const char *,int),\\r\\nvoid (**f)(void *))\\r\\n{\\r\\nif (m != NULL) *m = (malloc_locked_ex_func != default_malloc_locked_ex) ?\\r\\nmalloc_locked_ex_func : 0;\\r\\nif (f != NULL) *f=free_locked_func;\\r\\n}\\r\\nvoid CRYPTO_get_mem_debug_functions(void (**m)(void *,int,const char *,int,int),\\r\\nvoid (**r)(void *,void *,int,const char *,int,int),\\r\\nvoid (**f)(void *,int),\\r\\nvoid (**so)(long),\\r\\nlong (**go)(void))\\r\\n{\\r\\nif (m != NULL) *m=malloc_debug_func;\\r\\nif (r != NULL) *r=realloc_debug_func;\\r\\nif (f != NULL) *f=free_debug_func;\\r\\nif (so != NULL) *so=set_debug_options_func;\\r\\nif (go != NULL) *go=get_debug_options_func;\\r\\n}\\r\\nvoid *CRYPTO_malloc_locked(int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nextern unsigned char cleanse_ctr;\\r\\nif (num <= 0) return NULL;\\r\\nallow_customize = 0;\\r\\nif (malloc_debug_func != NULL)\\r\\n{\\r\\nallow_customize_debug = 0;\\r\\nmalloc_debug_func(NULL, num, file, line, 0);\\r\\n}\\r\\nret = malloc_locked_ex_func(num,file,line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: > 0x%p (%d)\\n\", ret, num);\\r\\n#endif\\r\\nif (malloc_debug_func != NULL)\\r\\nmalloc_debug_func(ret, num, file, line, 1);\\r\\nif(ret && (num > 2048))\\r\\n((unsigned char *)ret)[0] = cleanse_ctr;\\r\\nreturn ret;\\r\\n}\\r\\nvoid CRYPTO_free_locked(void *str)\\r\\n{\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(str, 0);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: < 0x%p\\n\", str);\\r\\n#endif\\r\\nfree_locked_func(str);\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(NULL, 1);\\r\\n}\\r\\nvoid *CRYPTO_malloc(int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nextern unsigned char cleanse_ctr;\\r\\nif (num <= 0) return NULL;\\r\\nallow_customize = 0;\\r\\nif (malloc_debug_func != NULL)\\r\\n{\\r\\nallow_customize_debug = 0;\\r\\nmalloc_debug_func(NULL, num, file, line, 0);\\r\\n}\\r\\nret = malloc_ex_func(num,file,line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: > 0x%p (%d)\\n\", ret, num);\\r\\n#endif\\r\\nif (malloc_debug_func != NULL)\\r\\nmalloc_debug_func(ret, num, file, line, 1);\\r\\nif(ret && (num > 2048))\\r\\n((unsigned char *)ret)[0] = cleanse_ctr;\\r\\nreturn ret;\\r\\n}\\r\\nvoid *CRYPTO_realloc(void *str, int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (str == NULL)\\r\\nreturn CRYPTO_malloc(num, file, line);\\r\\nif (num <= 0) return NULL;\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, NULL, num, file, line, 0);\\r\\nret = realloc_ex_func(str,num,file,line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: | 0x%p -> 0x%p (%d)\\n\", str, ret, num);\\r\\n#endif\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, ret, num, file, line, 1);\\r\\nreturn ret;\\r\\n}\\r\\nvoid *CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,\\r\\nint line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (str == NULL)\\r\\nreturn CRYPTO_malloc(num, file, line);\\r\\nif (num <= 0) return NULL;\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, NULL, num, file, line, 0);\\r\\nret=malloc_ex_func(num,file,line);\\r\\nif(ret)\\r\\n{\\r\\nmemcpy(ret,str,old_len);\\r\\nOPENSSL_cleanse(str,old_len);\\r\\nfree_func(str);\\r\\n}\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr,\\r\\n\"LEVITTE_DEBUG_MEM: | 0x%p -> 0x%p (%d)\\n\",\\r\\nstr, ret, num);\\r\\n#endif\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, ret, num, file, line, 1);\\r\\nreturn ret;\\r\\n}\\r\\nvoid CRYPTO_free(void *str)\\r\\n{\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(str, 0);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: < 0x%p\\n\", str);\\r\\n#endif\\r\\nfree_func(str);\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(NULL, 1);\\r\\n}\\r\\nvoid *CRYPTO_remalloc(void *a, int num, const char *file, int line)\\r\\n{\\r\\nif (a != NULL) OPENSSL_free(a);\\r\\na=(char *)OPENSSL_malloc(num);\\r\\nreturn(a);\\r\\n}\\r\\nvoid CRYPTO_set_mem_debug_options(long bits)\\r\\n{\\r\\nif (set_debug_options_func != NULL)\\r\\nset_debug_options_func(bits);\\r\\n}\\r\\nlong CRYPTO_get_mem_debug_options(void)\\r\\n{\\r\\nif (get_debug_options_func != NULL)\\r\\nreturn get_debug_options_func();\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_ofb_c", "target": 0, "func": "void AES_ofb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num) {\\r\\nunsigned int n;\\r\\nunsigned long l=length;\\r\\nassert(in && out && key && ivec && num);\\r\\nn = *num;\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nAES_encrypt(ivec, ivec, key);\\r\\n}\\r\\n*(out++) = *(in++) ^ ivec[n];\\r\\nn = (n+1) % AES_BLOCK_SIZE;\\r\\n}\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cpt_err_c", "target": 0, "func": "void ERR_load_CRYPTO_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,CRYPTO_str_functs);\\r\\nERR_load_strings(0,CRYPTO_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_o_time_c", "target": 0, "func": "struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result)\\r\\n{\\r\\nstruct tm *ts = NULL;\\r\\n#if defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_OS2) && !defined(__CYGWIN32__) && (!defined(OPENSSL_SYS_VMS) || defined(gmtime_r)) && !defined(OPENSSL_SYS_MACOSX) && !defined(OPENSSL_SYS_SUNOS)\\r\\ngmtime_r(timer,result);\\r\\nts = result;\\r\\n#elif !defined(OPENSSL_SYS_VMS)\\r\\nts = gmtime(timer);\\r\\nif (ts == NULL)\\r\\nreturn NULL;\\r\\nmemcpy(result, ts, sizeof(struct tm));\\r\\nts = result;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nif (ts == NULL)\\r\\n{\\r\\nstatic $DESCRIPTOR(tabnam,\"LNM$DCL_LOGICAL\");\\r\\nstatic $DESCRIPTOR(lognam,\"SYS$TIMEZONE_DIFFERENTIAL\");\\r\\nchar logvalue[256];\\r\\nunsigned int reslen = 0;\\r\\nstruct {\\r\\nshort buflen;\\r\\nshort code;\\r\\nvoid *bufaddr;\\r\\nunsigned int *reslen;\\r\\n} itemlist[] = {\\r\\n{ 0, LNM$_STRING, 0, 0 },\\r\\n{ 0, 0, 0, 0 },\\r\\n};\\r\\nint status;\\r\\ntime_t t;\\r\\nitemlist[0].buflen = sizeof(logvalue);\\r\\nitemlist[0].bufaddr = logvalue;\\r\\nitemlist[0].reslen = &reslen;\\r\\nstatus = sys$trnlnm(0, &tabnam, &lognam, 0, itemlist);\\r\\nif (!(status & 1))\\r\\nreturn NULL;\\r\\nlogvalue[reslen] = '\\0';\\r\\nt = *timer;\\r\\n#if __CRTL_VER < 70000000 || defined _VMS_V6_SOURCE\\r\\nstatus = atoi(logvalue);\\r\\nt -= status;\\r\\n#endif\\r\\n{\\r\\nunsigned long unix_epoch[2] = { 1273708544, 8164711 };\\r\\nunsigned long deltatime[2];\\r\\nunsigned long systime[2];\\r\\nstruct vms_vectime\\r\\n{\\r\\nshort year, month, day, hour, minute, second,\\r\\ncenti_second;\\r\\n} time_values;\\r\\nlong operation;\\r\\noperation = LIB$K_DELTA_SECONDS;\\r\\nstatus = lib$cvt_to_internal_time(&operation,\\r\\n&t, deltatime);\\r\\nstatus = lib$add_times(unix_epoch, deltatime, systime);\\r\\nstatus = sys$numtim(&time_values, systime);\\r\\nresult->tm_sec = time_values.second;\\r\\nresult->tm_min = time_values.minute;\\r\\nresult->tm_hour = time_values.hour;\\r\\nresult->tm_mday = time_values.day;\\r\\nresult->tm_mon = time_values.month - 1;\\r\\nresult->tm_year = time_values.year - 1900;\\r\\noperation = LIB$K_DAY_OF_WEEK;\\r\\nstatus = lib$cvt_from_internal_time(&operation,\\r\\n&result->tm_wday, systime);\\r\\nresult->tm_wday %= 7;\\r\\noperation = LIB$K_DAY_OF_YEAR;\\r\\nstatus = lib$cvt_from_internal_time(&operation,\\r\\n&result->tm_yday, systime);\\r\\nresult->tm_yday--;\\r\\nresult->tm_isdst = 0;\\r\\nts = result;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn ts;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_key_c", "target": 0, "func": "int DH_generate_key(DH *dh)\\r\\n{\\r\\nreturn dh->meth->generate_key(dh);\\r\\n}\\r\\nint DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nreturn dh->meth->compute_key(key, pub_key, dh);\\r\\n}\\r\\nconst DH_METHOD *DH_OpenSSL(void)\\r\\n{\\r\\nreturn &dh_ossl;\\r\\n}\\r\\nstatic int generate_key(DH *dh)\\r\\n{\\r\\nint ok=0;\\r\\nint generate_new_key=0;\\r\\nunsigned l;\\r\\nBN_CTX *ctx;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nBIGNUM *pub_key=NULL,*priv_key=NULL;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nif (dh->priv_key == NULL)\\r\\n{\\r\\npriv_key=BN_new();\\r\\nif (priv_key == NULL) goto err;\\r\\ngenerate_new_key=1;\\r\\n}\\r\\nelse\\r\\npriv_key=dh->priv_key;\\r\\nif (dh->pub_key == NULL)\\r\\n{\\r\\npub_key=BN_new();\\r\\nif (pub_key == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npub_key=dh->pub_key;\\r\\nif (dh->flags & DH_FLAG_CACHE_MONT_P)\\r\\n{\\r\\nmont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\\r\\nCRYPTO_LOCK_DH, dh->p, ctx);\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nif (generate_new_key)\\r\\n{\\r\\nl = dh->length ? dh->length : BN_num_bits(dh->p)-1;\\r\\nif (!BN_rand(priv_key, l, 0, 0)) goto err;\\r\\n}\\r\\n{\\r\\nBIGNUM local_prk;\\r\\nBIGNUM *prk;\\r\\nif ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0)\\r\\n{\\r\\nBN_init(&local_prk);\\r\\nprk = &local_prk;\\r\\nBN_with_flags(prk, priv_key, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\nprk = priv_key;\\r\\nif (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont)) goto err;\\r\\n}\\r\\ndh->pub_key=pub_key;\\r\\ndh->priv_key=priv_key;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok != 1)\\r\\nDHerr(DH_F_GENERATE_KEY,ERR_R_BN_LIB);\\r\\nif ((pub_key != NULL) && (dh->pub_key == NULL)) BN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dh->priv_key == NULL)) BN_free(priv_key);\\r\\nBN_CTX_free(ctx);\\r\\nreturn(ok);\\r\\n}\\r\\nstatic int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nBIGNUM *tmp;\\r\\nint ret= -1;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (dh->priv_key == NULL)\\r\\n{\\r\\nDHerr(DH_F_COMPUTE_KEY,DH_R_NO_PRIVATE_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nif (dh->flags & DH_FLAG_CACHE_MONT_P)\\r\\n{\\r\\nmont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\\r\\nCRYPTO_LOCK_DH, dh->p, ctx);\\r\\nif ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0)\\r\\n{\\r\\nBN_set_flags(dh->priv_key, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nif (!dh->meth->bn_mod_exp(dh, tmp, pub_key, dh->priv_key,dh->p,ctx,mont))\\r\\n{\\r\\nDHerr(DH_F_COMPUTE_KEY,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret=BN_bn2bin(tmp,key);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dh_bn_mod_exp(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nif (a->top == 1 && ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) != 0))\\r\\n{\\r\\nBN_ULONG A = a->d[0];\\r\\nreturn BN_mod_exp_mont_word(r,A,p,m,ctx,m_ctx);\\r\\n}\\r\\nelse\\r\\nreturn BN_mod_exp_mont(r,a,p,m,ctx,m_ctx);\\r\\n}\\r\\nstatic int dh_init(DH *dh)\\r\\n{\\r\\ndh->flags |= DH_FLAG_CACHE_MONT_P;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int dh_finish(DH *dh)\\r\\n{\\r\\nif(dh->method_mont_p)\\r\\nBN_MONT_CTX_free(dh->method_mont_p);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsaref_err_c", "target": 0, "func": "static void ERR_load_RSAREF_strings(void)\\r\\n{\\r\\nif (RSAREF_lib_error_code == 0)\\r\\nRSAREF_lib_error_code=ERR_get_next_error_library();\\r\\nif (RSAREF_error_init)\\r\\n{\\r\\nRSAREF_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(RSAREF_lib_error_code,RSAREF_str_functs);\\r\\nERR_load_strings(RSAREF_lib_error_code,RSAREF_str_reasons);\\r\\n#endif\\r\\n#ifdef RSAREF_LIB_NAME\\r\\nRSAREF_lib_name->error = ERR_PACK(RSAREF_lib_error_code,0,0);\\r\\nERR_load_strings(0,RSAREF_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_RSAREF_strings(void)\\r\\n{\\r\\nif (RSAREF_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(RSAREF_lib_error_code,RSAREF_str_functs);\\r\\nERR_unload_strings(RSAREF_lib_error_code,RSAREF_str_reasons);\\r\\n#endif\\r\\n#ifdef RSAREF_LIB_NAME\\r\\nERR_unload_strings(0,RSAREF_lib_name);\\r\\n#endif\\r\\nRSAREF_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_RSAREF_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (RSAREF_lib_error_code == 0)\\r\\nRSAREF_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(RSAREF_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_saccept_c", "target": 0, "func": "void close_up()\\r\\n{\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\n}\\r\\nint main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *port=NULL;\\r\\nBIO *ssl_bio,*tmp;\\r\\nSSL_CTX *ctx;\\r\\nSSL *ssl;\\r\\nchar buf[512];\\r\\nint ret=1,i;\\r\\nif (argc <= 1)\\r\\nport=\"*:4433\";\\r\\nelse\\r\\nport=argv[1];\\r\\nsignal(SIGINT,close_up);\\r\\nSSL_load_error_strings();\\r\\n#ifdef WATT32\\r\\ndbug_init();\\r\\nsock_init();\\r\\n#endif\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(SSLv23_server_method());\\r\\nif (!SSL_CTX_use_certificate_file(ctx,CERT_FILE,SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_use_PrivateKey_file(ctx,CERT_FILE,SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\ngoto err;\\r\\nssl=SSL_new(ctx);\\r\\nssl_bio=BIO_new_ssl(ctx,0);\\r\\nif ((in=BIO_new_accept(port)) == NULL) goto err;\\r\\nBIO_set_accept_bios(in,ssl_bio);\\r\\nagain:\\r\\nif (BIO_do_accept(in) <= 0) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(in,buf,512);\\r\\nif (i == 0)\\r\\n{\\r\\nprintf(\"Done\\n\");\\r\\ntmp=BIO_pop(in);\\r\\nBIO_free_all(tmp);\\r\\ngoto again;\\r\\n}\\r\\nif (i < 0) goto err;\\r\\nfwrite(buf,1,i,stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\nret=0;\\r\\nerr:\\r\\nif (ret)\\r\\n{\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (in != NULL) BIO_free(in);\\r\\nexit(ret);\\r\\nreturn(!ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_gen_c", "target": 0, "func": "int DH_generate_parameters_ex(DH *ret, int prime_len, int generator, BN_GENCB *cb)\\r\\n{\\r\\nif(ret->meth->generate_params)\\r\\nreturn ret->meth->generate_params(ret, prime_len, generator, cb);\\r\\nreturn dh_builtin_genparams(ret, prime_len, generator, cb);\\r\\n}\\r\\nstatic int dh_builtin_genparams(DH *ret, int prime_len, int generator, BN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *t1,*t2;\\r\\nint g,ok= -1;\\r\\nBN_CTX *ctx=NULL;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL || t2 == NULL) goto err;\\r\\nif(!ret->p && ((ret->p = BN_new()) == NULL)) goto err;\\r\\nif(!ret->g && ((ret->g = BN_new()) == NULL)) goto err;\\r\\nif (generator <= 1)\\r\\n{\\r\\nDHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_BAD_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (generator == DH_GENERATOR_2)\\r\\n{\\r\\nif (!BN_set_word(t1,24)) goto err;\\r\\nif (!BN_set_word(t2,11)) goto err;\\r\\ng=2;\\r\\n}\\r\\n#if 0\\r\\nelse if (generator == DH_GENERATOR_3)\\r\\n{\\r\\nif (!BN_set_word(t1,12)) goto err;\\r\\nif (!BN_set_word(t2,5)) goto err;\\r\\ng=3;\\r\\n}\\r\\n#endif\\r\\nelse if (generator == DH_GENERATOR_5)\\r\\n{\\r\\nif (!BN_set_word(t1,10)) goto err;\\r\\nif (!BN_set_word(t2,3)) goto err;\\r\\ng=5;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_set_word(t1,2)) goto err;\\r\\nif (!BN_set_word(t2,1)) goto err;\\r\\ng=generator;\\r\\n}\\r\\nif(!BN_generate_prime_ex(ret->p,prime_len,1,t1,t2,cb)) goto err;\\r\\nif(!BN_GENCB_call(cb, 3, 0)) goto err;\\r\\nif (!BN_set_word(ret->g,g)) goto err;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok == -1)\\r\\n{\\r\\nDHerr(DH_F_DH_BUILTIN_GENPARAMS,ERR_R_BN_LIB);\\r\\nok=0;\\r\\n}\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecb_enc_c", "target": 0, "func": "const char *DES_options(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic char buf[32];\\r\\nif (init)\\r\\n{\\r\\nconst char *ptr,*unroll,*risc,*size;\\r\\n#ifdef DES_PTR\\r\\nptr=\"ptr\";\\r\\n#else\\r\\nptr=\"idx\";\\r\\n#endif\\r\\n#if defined(DES_RISC1) || defined(DES_RISC2)\\r\\n#ifdef DES_RISC1\\r\\nrisc=\"risc1\";\\r\\n#endif\\r\\n#ifdef DES_RISC2\\r\\nrisc=\"risc2\";\\r\\n#endif\\r\\n#else\\r\\nrisc=\"cisc\";\\r\\n#endif\\r\\n#ifdef DES_UNROLL\\r\\nunroll=\"16\";\\r\\n#else\\r\\nunroll=\"4\";\\r\\n#endif\\r\\nif (sizeof(DES_LONG) != sizeof(long))\\r\\nsize=\"int\";\\r\\nelse\\r\\nsize=\"long\";\\r\\nBIO_snprintf(buf,sizeof buf,\"des(%s,%s,%s,%s)\",ptr,risc,unroll,\\r\\nsize);\\r\\ninit=0;\\r\\n}\\r\\nreturn(buf);\\r\\n}\\r\\nvoid DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,\\r\\nDES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in,l); ll[0]=l;\\r\\nc2l(in,l); ll[1]=l;\\r\\nDES_encrypt1(ll,ks,enc);\\r\\nl=ll[0]; l2c(l,out);\\r\\nl=ll[1]; l2c(l,out);\\r\\nl=ll[0]=ll[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dec_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *keyfile=NULL;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *x509;\\r\\nPKCS7 *p7;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nX509_STORE_CTX cert_ctx;\\r\\nX509_STORE *cert_store=NULL;\\r\\nBIO *data,*detached=NULL,*p7bio=NULL;\\r\\nchar buf[1024*4];\\r\\nunsigned char *pp;\\r\\nint i,printit=0;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *sk;\\r\\nOpenSSL_add_all_algorithms();\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\ndata=BIO_new(BIO_s_file());\\r\\npp=NULL;\\r\\nwhile (argc > 1)\\r\\n{\\r\\nargc--;\\r\\nargv++;\\r\\nif (strcmp(argv[0],\"-p\") == 0)\\r\\n{\\r\\nprintit=1;\\r\\n}\\r\\nelse if ((strcmp(argv[0],\"-k\") == 0) && (argc >= 2)) {\\r\\nkeyfile = argv[1];\\r\\nargc-=1;\\r\\nargv+=1;\\r\\n} else if ((strcmp(argv[0],\"-d\") == 0) && (argc >= 2))\\r\\n{\\r\\ndetached=BIO_new(BIO_s_file());\\r\\nif (!BIO_read_filename(detached,argv[1]))\\r\\ngoto err;\\r\\nargc-=1;\\r\\nargv+=1;\\r\\n}\\r\\nelse break;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[0])) goto err;\\r\\nif(!keyfile) {\\r\\nfprintf(stderr, \"No private key file specified\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((in=BIO_new_file(keyfile,\"r\")) == NULL) goto err;\\r\\nif ((x509=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL) goto err;\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL)) == NULL)\\r\\ngoto err;\\r\\nBIO_free(in);\\r\\nif (pp == NULL)\\r\\nBIO_set_fp(data,stdin,BIO_NOCLOSE);\\r\\nif ((p7=PEM_read_bio_PKCS7(data,NULL,NULL,NULL)) == NULL) goto err;\\r\\ncert_store=X509_STORE_new();\\r\\nX509_STORE_set_default_paths(cert_store);\\r\\nX509_STORE_load_locations(cert_store,NULL,\"../../certs\");\\r\\nX509_STORE_set_verify_cb_func(cert_store,verify_callback);\\r\\nERR_clear_error();\\r\\np7bio=PKCS7_dataDecode(p7,pkey,detached,x509);\\r\\nif (p7bio == NULL)\\r\\n{\\r\\nprintf(\"problems decoding\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(p7bio,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nfwrite(buf,1, i, stdout);\\r\\n}\\r\\nsk=PKCS7_get_signer_info(p7);\\r\\nif (sk == NULL)\\r\\n{\\r\\nfprintf(stderr, \"there are no signatures on this data\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nERR_clear_error();\\r\\nfor (i=0; i<sk_PKCS7_SIGNER_INFO_num(sk); i++)\\r\\n{\\r\\nsi=sk_PKCS7_SIGNER_INFO_value(sk,i);\\r\\ni=PKCS7_dataVerify(cert_store,&cert_ctx,p7bio,p7,si);\\r\\nif (i <= 0)\\r\\ngoto err;\\r\\nelse\\r\\nfprintf(stderr,\"Signature verified\\n\");\\r\\n}\\r\\n}\\r\\nX509_STORE_free(cert_store);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nint verify_callback(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nX509 *err_cert;\\r\\nint err,depth;\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr= X509_STORE_CTX_get_error(ctx);\\r\\ndepth= X509_STORE_CTX_get_error_depth(ctx);\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);\\r\\nBIO_printf(bio_err,\"depth=%d %s\\n\",depth,buf);\\r\\nif (!ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:num=%d:%s\\n\",err,\\r\\nX509_verify_cert_error_string(err));\\r\\nif (depth < 6)\\r\\n{\\r\\nok=1;\\r\\nX509_STORE_CTX_set_error(ctx,X509_V_OK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nok=0;\\r\\nX509_STORE_CTX_set_error(ctx,X509_V_ERR_CERT_CHAIN_TOO_LONG);\\r\\n}\\r\\n}\\r\\nswitch (ctx->error)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256);\\r\\nBIO_printf(bio_err,\"issuer= %s\\n\",buf);\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nBIO_printf(bio_err,\"notBefore=\");\\r\\nASN1_UTCTIME_print(bio_err,X509_get_notBefore(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nBIO_printf(bio_err,\"notAfter=\");\\r\\nASN1_UTCTIME_print(bio_err,X509_get_notAfter(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\n}\\r\\nBIO_printf(bio_err,\"verify return:%d\\n\",ok);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_x931_c", "target": 0, "func": "int RSA_padding_add_X931(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint j;\\r\\nunsigned char *p;\\r\\nj = tlen - flen - 2;\\r\\nif (j < 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_X931,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn -1;\\r\\n}\\r\\np=(unsigned char *)to;\\r\\nif (j == 0)\\r\\n*p++ = 0x6A;\\r\\nelse\\r\\n{\\r\\n*p++ = 0x6B;\\r\\nif (j > 1)\\r\\n{\\r\\nmemset(p, 0xBB, j - 1);\\r\\np += j - 1;\\r\\n}\\r\\n*p++ = 0xBA;\\r\\n}\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\np += flen;\\r\\n*p = 0xCC;\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_X931(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i = 0,j;\\r\\nconst unsigned char *p;\\r\\np=from;\\r\\nif ((num != flen) || ((*p != 0x6A) && (*p != 0x6B)))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931,RSA_R_INVALID_HEADER);\\r\\nreturn -1;\\r\\n}\\r\\nif (*p++ == 0x6B)\\r\\n{\\r\\nj=flen-3;\\r\\nfor (i = 0; i < j; i++)\\r\\n{\\r\\nunsigned char c = *p++;\\r\\nif (c == 0xBA)\\r\\nbreak;\\r\\nif (c != 0xBB)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931,\\r\\nRSA_R_INVALID_PADDING);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nj -= i;\\r\\nif (i == 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nelse j = flen - 2;\\r\\nif (p[j] != 0xCC)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_TRAILER);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}\\r\\nint RSA_X931_hash_id(int nid)\\r\\n{\\r\\nswitch (nid)\\r\\n{\\r\\ncase NID_sha1:\\r\\nreturn 0x33;\\r\\ncase NID_sha256:\\r\\nreturn 0x34;\\r\\ncase NID_sha384:\\r\\nreturn 0x36;\\r\\ncase NID_sha512:\\r\\nreturn 0x35;\\r\\n}\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nint i, r, ret = 1;\\r\\nint badopt;\\r\\nchar *outfile = NULL;\\r\\nchar *inrand = NULL;\\r\\nint base64 = 0;\\r\\nBIO *out = NULL;\\r\\nint num = -1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nbadopt = 0;\\r\\ni = 0;\\r\\nwhile (!badopt && argv[++i] != NULL)\\r\\n{\\r\\nif (strcmp(argv[i], \"-out\") == 0)\\r\\n{\\r\\nif ((argv[i+1] != NULL) && (outfile == NULL))\\r\\noutfile = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(argv[i], \"-engine\") == 0)\\r\\n{\\r\\nif ((argv[i+1] != NULL) && (engine == NULL))\\r\\nengine = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(argv[i], \"-rand\") == 0)\\r\\n{\\r\\nif ((argv[i+1] != NULL) && (inrand == NULL))\\r\\ninrand = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse if (strcmp(argv[i], \"-base64\") == 0)\\r\\n{\\r\\nif (!base64)\\r\\nbase64 = 1;\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse if (isdigit((unsigned char)argv[i][0]))\\r\\n{\\r\\nif (num < 0)\\r\\n{\\r\\nr = sscanf(argv[i], \"%d\", &num);\\r\\nif (r == 0 || num < 0)\\r\\nbadopt = 1;\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\nif (num < 0)\\r\\nbadopt = 1;\\r\\nif (badopt)\\r\\n{\\r\\nBIO_printf(bio_err, \"Usage: rand [options] num\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-out file - write to file\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err, \"-engine e - use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c... - seed PRNG from files\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \"-base64 - encode output\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\ngoto err;\\r\\nif (outfile != NULL)\\r\\nr = BIO_write_filename(out, outfile);\\r\\nelse\\r\\n{\\r\\nr = BIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (r <= 0)\\r\\ngoto err;\\r\\nif (base64)\\r\\n{\\r\\nBIO *b64 = BIO_new(BIO_f_base64());\\r\\nif (b64 == NULL)\\r\\ngoto err;\\r\\nout = BIO_push(b64, out);\\r\\n}\\r\\nwhile (num > 0)\\r\\n{\\r\\nunsigned char buf[4096];\\r\\nint chunk;\\r\\nchunk = num;\\r\\nif (chunk > (int)sizeof(buf))\\r\\nchunk = sizeof buf;\\r\\nr = RAND_bytes(buf, chunk);\\r\\nif (r <= 0)\\r\\ngoto err;\\r\\nBIO_write(out, buf, chunk);\\r\\nnum -= chunk;\\r\\n}\\r\\nBIO_flush(out);\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret = 0;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_dss1_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return SHA1_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA1_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA1_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_dss1(void)\\r\\n{\\r\\nreturn(&dss1_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_asn1_c", "target": 0, "func": "int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)\\r\\n{\\r\\nASN1_STRING *os;\\r\\nif ((os=M_ASN1_OCTET_STRING_new()) == NULL) return(0);\\r\\nif (!M_ASN1_OCTET_STRING_set(os,data,len)) return(0);\\r\\nASN1_TYPE_set(a,V_ASN1_OCTET_STRING,os);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned char *data,\\r\\nint max_len)\\r\\n{\\r\\nint ret,num;\\r\\nunsigned char *p;\\r\\nif ((a->type != V_ASN1_OCTET_STRING) || (a->value.octet_string == NULL))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING,ASN1_R_DATA_IS_WRONG);\\r\\nreturn(-1);\\r\\n}\\r\\np=M_ASN1_STRING_data(a->value.octet_string);\\r\\nret=M_ASN1_STRING_length(a->value.octet_string);\\r\\nif (ret < max_len)\\r\\nnum=ret;\\r\\nelse\\r\\nnum=max_len;\\r\\nmemcpy(data,p,num);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,\\r\\nint len)\\r\\n{\\r\\nint n,size;\\r\\nASN1_OCTET_STRING os,*osp;\\r\\nASN1_INTEGER in;\\r\\nunsigned char *p;\\r\\nunsigned char buf[32];\\r\\nin.data=buf;\\r\\nin.length=32;\\r\\nos.data=data;\\r\\nos.type=V_ASN1_OCTET_STRING;\\r\\nos.length=len;\\r\\nASN1_INTEGER_set(&in,num);\\r\\nn = i2d_ASN1_INTEGER(&in,NULL);\\r\\nn+=M_i2d_ASN1_OCTET_STRING(&os,NULL);\\r\\nsize=ASN1_object_size(1,n,V_ASN1_SEQUENCE);\\r\\nif ((osp=ASN1_STRING_new()) == NULL) return(0);\\r\\nif (!ASN1_STRING_set(osp,NULL,size))\\r\\n{\\r\\nASN1_STRING_free(osp);\\r\\nreturn(0);\\r\\n}\\r\\nM_ASN1_STRING_length_set(osp, size);\\r\\np=M_ASN1_STRING_data(osp);\\r\\nASN1_put_object(&p,1,n,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&in,&p);\\r\\nM_i2d_ASN1_OCTET_STRING(&os,&p);\\r\\nASN1_TYPE_set(a,V_ASN1_SEQUENCE,osp);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num, unsigned char *data,\\r\\nint max_len)\\r\\n{\\r\\nint ret= -1,n;\\r\\nASN1_INTEGER *ai=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nconst unsigned char *p;\\r\\nlong length;\\r\\nASN1_const_CTX c;\\r\\nif ((a->type != V_ASN1_SEQUENCE) || (a->value.sequence == NULL))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\np=M_ASN1_STRING_data(a->value.sequence);\\r\\nlength=M_ASN1_STRING_length(a->value.sequence);\\r\\nc.pp= &p;\\r\\nc.p=p;\\r\\nc.max=p+length;\\r\\nc.error=ASN1_R_DATA_IS_WRONG;\\r\\nM_ASN1_D2I_start_sequence();\\r\\nc.q=c.p;\\r\\nif ((ai=d2i_ASN1_INTEGER(NULL,&c.p,c.slen)) == NULL) goto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nc.q=c.p;\\r\\nif ((os=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL) goto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nif (!M_ASN1_D2I_end_sequence()) goto err;\\r\\nif (num != NULL)\\r\\n*num=ASN1_INTEGER_get(ai);\\r\\nret=M_ASN1_STRING_length(os);\\r\\nif (max_len > ret)\\r\\nn=ret;\\r\\nelse\\r\\nn=max_len;\\r\\nif (data != NULL)\\r\\nmemcpy(data,M_ASN1_STRING_data(os),n);\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING,ASN1_R_DATA_IS_WRONG);\\r\\n}\\r\\nif (os != NULL) M_ASN1_OCTET_STRING_free(os);\\r\\nif (ai != NULL) M_ASN1_INTEGER_free(ai);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecs_lib_c", "target": 0, "func": "void ECDSA_set_default_method(const ECDSA_METHOD *meth)\\r\\n{\\r\\ndefault_ECDSA_method = meth;\\r\\n}\\r\\nconst ECDSA_METHOD *ECDSA_get_default_method(void)\\r\\n{\\r\\nif(!default_ECDSA_method)\\r\\ndefault_ECDSA_method = ECDSA_OpenSSL();\\r\\nreturn default_ECDSA_method;\\r\\n}\\r\\nint ECDSA_set_method(EC_KEY *eckey, const ECDSA_METHOD *meth)\\r\\n{\\r\\nconst ECDSA_METHOD *mtmp;\\r\\nECDSA_DATA *ecdsa;\\r\\necdsa = ecdsa_check(eckey);\\r\\nif (ecdsa == NULL)\\r\\nreturn 0;\\r\\nmtmp = ecdsa->meth;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ecdsa->engine)\\r\\n{\\r\\nENGINE_finish(ecdsa->engine);\\r\\necdsa->engine = NULL;\\r\\n}\\r\\n#endif\\r\\necdsa->meth = meth;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ECDSA_DATA *ECDSA_DATA_new_method(ENGINE *engine)\\r\\n{\\r\\nECDSA_DATA *ret;\\r\\nret=(ECDSA_DATA *)OPENSSL_malloc(sizeof(ECDSA_DATA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DATA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->init = NULL;\\r\\nret->meth = ECDSA_get_default_method();\\r\\nret->engine = engine;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (!ret->engine)\\r\\nret->engine = ENGINE_get_default_ECDSA();\\r\\nif (ret->engine)\\r\\n{\\r\\nret->meth = ENGINE_get_ECDSA(ret->engine);\\r\\nif (!ret->meth)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DATA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->flags = ret->meth->flags;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_ECDSA, ret, &ret->ex_data);\\r\\n#if 0\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ECDSA, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void *ecdsa_data_new(void)\\r\\n{\\r\\nreturn (void *)ECDSA_DATA_new_method(NULL);\\r\\n}\\r\\nstatic void *ecdsa_data_dup(void *data)\\r\\n{\\r\\nECDSA_DATA *r = (ECDSA_DATA *)data;\\r\\nif (r == NULL)\\r\\nreturn NULL;\\r\\nreturn ecdsa_data_new();\\r\\n}\\r\\nstatic void ecdsa_data_free(void *data)\\r\\n{\\r\\nECDSA_DATA *r = (ECDSA_DATA *)data;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ECDSA, r, &r->ex_data);\\r\\nOPENSSL_cleanse((void *)r, sizeof(ECDSA_DATA));\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nECDSA_DATA *ecdsa_check(EC_KEY *key)\\r\\n{\\r\\nECDSA_DATA *ecdsa_data;\\r\\nvoid *data = EC_KEY_get_key_method_data(key, ecdsa_data_dup,\\r\\necdsa_data_free, ecdsa_data_free);\\r\\nif (data == NULL)\\r\\n{\\r\\necdsa_data = (ECDSA_DATA *)ecdsa_data_new();\\r\\nif (ecdsa_data == NULL)\\r\\nreturn NULL;\\r\\nEC_KEY_insert_key_method_data(key, (void *)ecdsa_data,\\r\\necdsa_data_dup, ecdsa_data_free, ecdsa_data_free);\\r\\n}\\r\\nelse\\r\\necdsa_data = (ECDSA_DATA *)data;\\r\\nreturn ecdsa_data;\\r\\n}\\r\\nint ECDSA_size(const EC_KEY *r)\\r\\n{\\r\\nint ret,i;\\r\\nASN1_INTEGER bs;\\r\\nBIGNUM *order=NULL;\\r\\nunsigned char buf[4];\\r\\nconst EC_GROUP *group = EC_KEY_get0_group(r);\\r\\nif (r == NULL || group == NULL)\\r\\nreturn 0;\\r\\nif ((order = BN_new()) == NULL) return 0;\\r\\nif (!EC_GROUP_get_order(group,order,NULL))\\r\\n{\\r\\nBN_clear_free(order);\\r\\nreturn 0;\\r\\n}\\r\\ni=BN_num_bits(order);\\r\\nbs.length=(i+7)/8;\\r\\nbs.data=buf;\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbuf[0]=0xff;\\r\\ni=i2d_ASN1_INTEGER(&bs,NULL);\\r\\ni+=i;\\r\\nret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\nBN_clear_free(order);\\r\\nreturn(ret);\\r\\n}\\r\\nint ECDSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ECDSA, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg)\\r\\n{\\r\\nECDSA_DATA *ecdsa;\\r\\necdsa = ecdsa_check(d);\\r\\nif (ecdsa == NULL)\\r\\nreturn 0;\\r\\nreturn(CRYPTO_set_ex_data(&ecdsa->ex_data,idx,arg));\\r\\n}\\r\\nvoid *ECDSA_get_ex_data(EC_KEY *d, int idx)\\r\\n{\\r\\nECDSA_DATA *ecdsa;\\r\\necdsa = ecdsa_check(d);\\r\\nif (ecdsa == NULL)\\r\\nreturn NULL;\\r\\nreturn(CRYPTO_get_ex_data(&ecdsa->ex_data,idx));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_seal_c", "target": 0, "func": "int PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,\\r\\nunsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk,\\r\\nint npubk)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nint ret= -1;\\r\\nint i,j,max=0;\\r\\nchar *s=NULL;\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nif (pubk[i]->type != EVP_PKEY_RSA)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALINIT,PEM_R_PUBLIC_KEY_NO_RSA);\\r\\ngoto err;\\r\\n}\\r\\nj=RSA_size(pubk[i]->pkey.rsa);\\r\\nif (j > max) max=j;\\r\\n}\\r\\ns=(char *)OPENSSL_malloc(max*2);\\r\\nif (s == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_EncodeInit(&ctx->encode);\\r\\nEVP_MD_CTX_init(&ctx->md);\\r\\nEVP_SignInit(&ctx->md,md_type);\\r\\nEVP_CIPHER_CTX_init(&ctx->cipher);\\r\\nret=EVP_SealInit(&ctx->cipher,type,ek,ekl,iv,pubk,npubk);\\r\\nif (!ret) goto err;\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nj=EVP_EncodeBlock((unsigned char *)s,ek[i],\\r\\nRSA_size(pubk[i]->pkey.rsa));\\r\\nekl[i]=j;\\r\\nmemcpy(ek[i],s,j+1);\\r\\n}\\r\\nret=npubk;\\r\\nerr:\\r\\nif (s != NULL) OPENSSL_free(s);\\r\\nOPENSSL_cleanse(key,EVP_MAX_KEY_LENGTH);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nunsigned char buffer[1600];\\r\\nint i,j;\\r\\n*outl=0;\\r\\nEVP_SignUpdate(&ctx->md,in,inl);\\r\\nfor (;;)\\r\\n{\\r\\nif (inl <= 0) break;\\r\\nif (inl > 1200)\\r\\ni=1200;\\r\\nelse\\r\\ni=inl;\\r\\nEVP_EncryptUpdate(&ctx->cipher,buffer,&j,in,i);\\r\\nEVP_EncodeUpdate(&ctx->encode,out,&j,buffer,j);\\r\\n*outl+=j;\\r\\nout+=j;\\r\\nin+=i;\\r\\ninl-=i;\\r\\n}\\r\\n}\\r\\nint PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,\\r\\nunsigned char *out, int *outl, EVP_PKEY *priv)\\r\\n{\\r\\nunsigned char *s=NULL;\\r\\nint ret=0,j;\\r\\nunsigned int i;\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALFINAL,PEM_R_PUBLIC_KEY_NO_RSA);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_size(priv->pkey.rsa);\\r\\nif (i < 100) i=100;\\r\\ns=(unsigned char *)OPENSSL_malloc(i*2);\\r\\nif (s == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_EncryptFinal_ex(&ctx->cipher,s,(int *)&i);\\r\\nEVP_EncodeUpdate(&ctx->encode,out,&j,s,i);\\r\\n*outl=j;\\r\\nout+=j;\\r\\nEVP_EncodeFinal(&ctx->encode,out,&j);\\r\\n*outl+=j;\\r\\nif (!EVP_SignFinal(&ctx->md,s,&i,priv)) goto err;\\r\\n*sigl=EVP_EncodeBlock(sig,s,i);\\r\\nret=1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx->md);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx->cipher);\\r\\nif (s != NULL) OPENSSL_free(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_ok_c", "target": 0, "func": "BIO_METHOD *BIO_f_reliable(void)\\r\\n{\\r\\nreturn(&methods_ok);\\r\\n}\\r\\nstatic int ok_new(BIO *bi)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nctx=(BIO_OK_CTX *)OPENSSL_malloc(sizeof(BIO_OK_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->buf_len_save=0;\\r\\nctx->buf_off_save=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->blockout= 0;\\r\\nctx->sigio=1;\\r\\nEVP_MD_CTX_init(&ctx->md);\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ok_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nEVP_MD_CTX_cleanup(&((BIO_OK_CTX *)a->ptr)->md);\\r\\nOPENSSL_cleanse(a->ptr,sizeof(BIO_OK_CTX));\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ok_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,n;\\r\\nBIO_OK_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\\r\\nwhile(outl > 0)\\r\\n{\\r\\nif (ctx->blockout)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret+=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_off=0;\\r\\nif(ctx->buf_len_save- ctx->buf_off_save > 0)\\r\\n{\\r\\nctx->buf_len= ctx->buf_len_save- ctx->buf_off_save;\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off_save]),\\r\\nctx->buf_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->buf_len=0;\\r\\n}\\r\\nctx->blockout= 0;\\r\\n}\\r\\n}\\r\\nif (outl == 0) break;\\r\\nn=IOBS- ctx->buf_len;\\r\\ni=BIO_read(b->next_bio,&(ctx->buf[ctx->buf_len]),n);\\r\\nif (i <= 0) break;\\r\\nctx->buf_len+= i;\\r\\nif (ctx->sigio == 1) sig_in(b);\\r\\nif (ctx->sigio == 0) block_in(b);\\r\\nif (ctx->cont <= 0) break;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ok_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_OK_CTX *ctx;\\r\\nif (inl <= 0) return inl;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nret=inl;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\\r\\nif(ctx->sigio) sig_out(b);\\r\\ndo{\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (ctx->blockout && n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif(!BIO_should_retry(b))\\r\\nctx->cont= 0;\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nctx->blockout= 0;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=OK_BLOCK_BLOCK;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nn= (inl+ ctx->buf_len > OK_BLOCK_SIZE+ OK_BLOCK_BLOCK) ?\\r\\n(int)(OK_BLOCK_SIZE+OK_BLOCK_BLOCK-ctx->buf_len) : inl;\\r\\nmemcpy((unsigned char *)(&(ctx->buf[ctx->buf_len])),(unsigned char *)in,n);\\r\\nctx->buf_len+= n;\\r\\ninl-=n;\\r\\nin+=n;\\r\\nif(ctx->buf_len >= OK_BLOCK_SIZE+ OK_BLOCK_BLOCK)\\r\\n{\\r\\nblock_out(b);\\r\\n}\\r\\n}while(inl > 0);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ok_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD *md;\\r\\nconst EVP_MD **ppmd;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->buf_len_save=0;\\r\\nctx->buf_off_save=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->blockout= 0;\\r\\nctx->sigio=1;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->blockout ? ctx->buf_len-ctx->buf_off : 0;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif(ctx->blockout == 0)\\r\\nblock_out(b);\\r\\nwhile (ctx->blockout)\\r\\n{\\r\\ni=ok_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nctx->finished=1;\\r\\nctx->buf_off=ctx->buf_len=0;\\r\\nctx->cont=(int)ret;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)ctx->cont;\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd=ptr;\\r\\nEVP_DigestInit_ex(&ctx->md, md, NULL);\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init)\\r\\n{\\r\\nppmd=ptr;\\r\\n*ppmd=ctx->md.digest;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ok_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void longswap(void *_ptr, size_t len)\\r\\n{ const union { long one; char little; } is_endian = {1};\\r\\nif (is_endian.little) {\\r\\nsize_t i;\\r\\nunsigned char *p=_ptr,c;\\r\\nfor(i= 0;i < len;i+= 4) {\\r\\nc=p[0],p[0]=p[3],p[3]=c;\\r\\nc=p[1],p[1]=p[2],p[2]=c;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void sig_out(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nctx=b->ptr;\\r\\nmd=&ctx->md;\\r\\nif(ctx->buf_len+ 2* md->digest->md_size > OK_BLOCK_SIZE) return;\\r\\nEVP_DigestInit_ex(md, md->digest, NULL);\\r\\nRAND_pseudo_bytes(md->md_data, md->digest->md_size);\\r\\nmemcpy(&(ctx->buf[ctx->buf_len]), md->md_data, md->digest->md_size);\\r\\nlongswap(&(ctx->buf[ctx->buf_len]), md->digest->md_size);\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nEVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN));\\r\\nEVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL);\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nctx->blockout= 1;\\r\\nctx->sigio= 0;\\r\\n}\\r\\nstatic void sig_in(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nint ret= 0;\\r\\nctx=b->ptr;\\r\\nmd=&ctx->md;\\r\\nif((int)(ctx->buf_len-ctx->buf_off) < 2*md->digest->md_size) return;\\r\\nEVP_DigestInit_ex(md, md->digest, NULL);\\r\\nmemcpy(md->md_data, &(ctx->buf[ctx->buf_off]), md->digest->md_size);\\r\\nlongswap(md->md_data, md->digest->md_size);\\r\\nctx->buf_off+= md->digest->md_size;\\r\\nEVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN));\\r\\nEVP_DigestFinal_ex(md, tmp, NULL);\\r\\nret= memcmp(&(ctx->buf[ctx->buf_off]), tmp, md->digest->md_size) == 0;\\r\\nctx->buf_off+= md->digest->md_size;\\r\\nif(ret == 1)\\r\\n{\\r\\nctx->sigio= 0;\\r\\nif(ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off]), ctx->buf_len- ctx->buf_off);\\r\\n}\\r\\nctx->buf_len-= ctx->buf_off;\\r\\nctx->buf_off= 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->cont= 0;\\r\\n}\\r\\n}\\r\\nstatic void block_out(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned long tl;\\r\\nctx=b->ptr;\\r\\nmd=&ctx->md;\\r\\ntl= ctx->buf_len- OK_BLOCK_BLOCK;\\r\\nctx->buf[0]=(unsigned char)(tl>>24);\\r\\nctx->buf[1]=(unsigned char)(tl>>16);\\r\\nctx->buf[2]=(unsigned char)(tl>>8);\\r\\nctx->buf[3]=(unsigned char)(tl);\\r\\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\\r\\nEVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL);\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nctx->blockout= 1;\\r\\n}\\r\\nstatic void block_in(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned long tl= 0;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nctx=b->ptr;\\r\\nmd=&ctx->md;\\r\\nassert(sizeof(tl)>=OK_BLOCK_BLOCK);\\r\\ntl =ctx->buf[0]; tl<<=8;\\r\\ntl|=ctx->buf[1]; tl<<=8;\\r\\ntl|=ctx->buf[2]; tl<<=8;\\r\\ntl|=ctx->buf[3];\\r\\nif (ctx->buf_len < tl+ OK_BLOCK_BLOCK+ md->digest->md_size) return;\\r\\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\\r\\nEVP_DigestFinal_ex(md, tmp, NULL);\\r\\nif(memcmp(&(ctx->buf[tl+ OK_BLOCK_BLOCK]), tmp, md->digest->md_size) == 0)\\r\\n{\\r\\nctx->buf_off_save= tl+ OK_BLOCK_BLOCK+ md->digest->md_size;\\r\\nctx->buf_len_save= ctx->buf_len;\\r\\nctx->buf_off= OK_BLOCK_BLOCK;\\r\\nctx->buf_len= tl+ OK_BLOCK_BLOCK;\\r\\nctx->blockout= 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->cont= 0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_aes_c", "target": 0, "func": "static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret;\\r\\nif ((ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_CFB_MODE\\r\\n|| (ctx->cipher->flags & EVP_CIPH_MODE) == EVP_CIPH_OFB_MODE\\r\\n|| enc)\\r\\nret=AES_set_encrypt_key(key, ctx->key_len * 8, ctx->cipher_data);\\r\\nelse\\r\\nret=AES_set_decrypt_key(key, ctx->key_len * 8, ctx->cipher_data);\\r\\nif(ret < 0)\\r\\n{\\r\\nEVPerr(EVP_F_AES_INIT_KEY,EVP_R_AES_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn1pars_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,badops=0,offset=0,ret=1,j;\\r\\nunsigned int length=0;\\r\\nlong num,tmplen;\\r\\nBIO *in=NULL,*out=NULL,*b64=NULL, *derout = NULL;\\r\\nint informat,indent=0, noout = 0, dump = 0;\\r\\nchar *infile=NULL,*str=NULL,*prog,*oidfile=NULL, *derfile=NULL;\\r\\nchar *genstr=NULL, *genconf=NULL;\\r\\nunsigned char *tmpbuf;\\r\\nconst unsigned char *ctmpbuf;\\r\\nBUF_MEM *buf=NULL;\\r\\nSTACK *osk=NULL;\\r\\nASN1_TYPE *at=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nif ((osk=sk_new_null()) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nderfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-i\") == 0)\\r\\n{\\r\\nindent=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0) noout = 1;\\r\\nelse if (strcmp(*argv,\"-oid\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noidfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-offset\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noffset= atoi(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-length\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nlength= atoi(*(++argv));\\r\\nif (length == 0) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dump\") == 0)\\r\\n{\\r\\ndump= -1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dlimit\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndump= atoi(*(++argv));\\r\\nif (dump <= 0) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-strparse\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsk_push(osk,*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-genstr\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ngenstr= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-genconf\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ngenconf= *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file (output format is always DER\\n\");\\r\\nBIO_printf(bio_err,\" -noout arg don't produce any output\\n\");\\r\\nBIO_printf(bio_err,\" -offset arg offset into file\\n\");\\r\\nBIO_printf(bio_err,\" -length arg length of section in file\\n\");\\r\\nBIO_printf(bio_err,\" -i indent entries\\n\");\\r\\nBIO_printf(bio_err,\" -dump dump unknown data in hex form\\n\");\\r\\nBIO_printf(bio_err,\" -dlimit arg dump the first arg bytes of unknown data in hex form\\n\");\\r\\nBIO_printf(bio_err,\" -oid file file of extra oid definitions\\n\");\\r\\nBIO_printf(bio_err,\" -strparse offset\\n\");\\r\\nBIO_printf(bio_err,\" a series of these can be used to 'dig' into multiple\\n\");\\r\\nBIO_printf(bio_err,\" ASN1 blob wrappings\\n\");\\r\\nBIO_printf(bio_err,\" -genstr str string to generate ASN1 structure from\\n\");\\r\\nBIO_printf(bio_err,\" -genconf file file to generate ASN1 structure from\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nif (oidfile != NULL)\\r\\n{\\r\\nif (BIO_read_filename(in,oidfile) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"problems opening %s\\n\",oidfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nOBJ_create_objects(in);\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (derfile) {\\r\\nif(!(derout = BIO_new_file(derfile, \"wb\"))) {\\r\\nBIO_printf(bio_err,\"problems opening %s\\n\",derfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((buf=BUF_MEM_new()) == NULL) goto end;\\r\\nif (!BUF_MEM_grow(buf,BUFSIZ*8)) goto end;\\r\\nif (genstr || genconf)\\r\\n{\\r\\nnum = do_generate(bio_err, genstr, genconf, buf);\\r\\nif (num < 0)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (informat == FORMAT_PEM)\\r\\n{\\r\\nBIO *tmp;\\r\\nif ((b64=BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nBIO_push(b64,in);\\r\\ntmp=in;\\r\\nin=b64;\\r\\nb64=tmp;\\r\\n}\\r\\nnum=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BUF_MEM_grow(buf,(int)num+BUFSIZ)) goto end;\\r\\ni=BIO_read(in,&(buf->data[num]),BUFSIZ);\\r\\nif (i <= 0) break;\\r\\nnum+=i;\\r\\n}\\r\\n}\\r\\nstr=buf->data;\\r\\nif (sk_num(osk))\\r\\n{\\r\\ntmpbuf=(unsigned char *)str;\\r\\ntmplen=num;\\r\\nfor (i=0; i<sk_num(osk); i++)\\r\\n{\\r\\nASN1_TYPE *atmp;\\r\\nint typ;\\r\\nj=atoi(sk_value(osk,i));\\r\\nif (j == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"'%s' is an invalid number\\n\",sk_value(osk,i));\\r\\ncontinue;\\r\\n}\\r\\ntmpbuf+=j;\\r\\ntmplen-=j;\\r\\natmp = at;\\r\\nctmpbuf = tmpbuf;\\r\\nat = d2i_ASN1_TYPE(NULL,&ctmpbuf,tmplen);\\r\\nASN1_TYPE_free(atmp);\\r\\nif(!at)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error parsing structure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ntyp = ASN1_TYPE_get(at);\\r\\nif ((typ == V_ASN1_OBJECT)\\r\\n|| (typ == V_ASN1_NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"Can't parse %s type\\n\",\\r\\ntyp == V_ASN1_NULL ? \"NULL\" : \"OBJECT\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ntmpbuf=at->value.asn1_string->data;\\r\\ntmplen=at->value.asn1_string->length;\\r\\n}\\r\\nstr=(char *)tmpbuf;\\r\\nnum=tmplen;\\r\\n}\\r\\nif (offset >= num)\\r\\n{\\r\\nBIO_printf(bio_err, \"Error: offset too large\\n\");\\r\\ngoto end;\\r\\n}\\r\\nnum -= offset;\\r\\nif ((length == 0) || ((long)length > num)) length=(unsigned int)num;\\r\\nif(derout) {\\r\\nif(BIO_write(derout, str + offset, length) != (int)length) {\\r\\nBIO_printf(bio_err, \"Error writing output\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!noout &&\\r\\n!ASN1_parse_dump(out,(unsigned char *)&(str[offset]),length,\\r\\nindent,dump))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nBIO_free(derout);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (b64 != NULL) BIO_free(b64);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nif (at != NULL) ASN1_TYPE_free(at);\\r\\nif (osk != NULL) sk_free(osk);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int do_generate(BIO *bio, char *genstr, char *genconf, BUF_MEM *buf)\\r\\n{\\r\\nCONF *cnf = NULL;\\r\\nint len;\\r\\nlong errline;\\r\\nunsigned char *p;\\r\\nASN1_TYPE *atyp = NULL;\\r\\nif (genconf)\\r\\n{\\r\\ncnf = NCONF_new(NULL);\\r\\nif (!NCONF_load(cnf, genconf, &errline))\\r\\ngoto conferr;\\r\\nif (!genstr)\\r\\ngenstr = NCONF_get_string(cnf, \"default\", \"asn1\");\\r\\nif (!genstr)\\r\\n{\\r\\nBIO_printf(bio, \"Can't find 'asn1' in '%s'\\n\", genconf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\natyp = ASN1_generate_nconf(genstr, cnf);\\r\\nNCONF_free(cnf);\\r\\nif (!atyp)\\r\\nreturn -1;\\r\\nlen = i2d_ASN1_TYPE(atyp, NULL);\\r\\nif (len <= 0)\\r\\ngoto err;\\r\\nif (!BUF_MEM_grow(buf,len))\\r\\ngoto err;\\r\\np=(unsigned char *)buf->data;\\r\\ni2d_ASN1_TYPE(atyp, &p);\\r\\nASN1_TYPE_free(atyp);\\r\\nreturn len;\\r\\nconferr:\\r\\nif (errline > 0)\\r\\nBIO_printf(bio, \"Error on line %ld of config file '%s'\\n\",\\r\\nerrline, genconf);\\r\\nelse\\r\\nBIO_printf(bio, \"Error loading config file '%s'\\n\", genconf);\\r\\nerr:\\r\\nNCONF_free(cnf);\\r\\nASN1_TYPE_free(atyp);\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_all_c", "target": 0, "func": "void OPENSSL_add_all_algorithms_noconf(void)\\r\\n{\\r\\nOPENSSL_cpuid_setup();\\r\\nOpenSSL_add_all_ciphers();\\r\\nOpenSSL_add_all_digests();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\n# if defined(__OpenBSD__) || defined(__FreeBSD__)\\r\\nENGINE_setup_bsd_cryptodev();\\r\\n# endif\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_buff_c", "target": 0, "func": "BIO_METHOD *BIO_f_buffer(void)\\r\\n{\\r\\nreturn(&methods_buffer);\\r\\n}\\r\\nstatic int buffer_new(BIO *bi)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nctx=(BIO_F_BUFFER_CTX *)OPENSSL_malloc(sizeof(BIO_F_BUFFER_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->ibuf=(char *)OPENSSL_malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->ibuf == NULL) { OPENSSL_free(ctx); return(0); }\\r\\nctx->obuf=(char *)OPENSSL_malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->obuf == NULL) { OPENSSL_free(ctx->ibuf); OPENSSL_free(ctx); return(0); }\\r\\nctx->ibuf_size=DEFAULT_BUFFER_SIZE;\\r\\nctx->obuf_size=DEFAULT_BUFFER_SIZE;\\r\\nctx->ibuf_len=0;\\r\\nctx->ibuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nbi->init=1;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int buffer_free(BIO *a)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_F_BUFFER_CTX *)a->ptr;\\r\\nif (b->ibuf != NULL) OPENSSL_free(b->ibuf);\\r\\nif (b->obuf != NULL) OPENSSL_free(b->obuf);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int buffer_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint i,num=0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nnum=0;\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni=ctx->ibuf_len;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->ibuf[ctx->ibuf_off]),i);\\r\\nctx->ibuf_off+=i;\\r\\nctx->ibuf_len-=i;\\r\\nnum+=i;\\r\\nif (outl == i) return(num);\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nif (outl > ctx->ibuf_size)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(b->next_bio,out,outl);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nnum+=i;\\r\\nif (outl == i) return(num);\\r\\nout+=i;\\r\\noutl-=i;\\r\\n}\\r\\n}\\r\\ni=BIO_read(b->next_bio,ctx->ibuf,ctx->ibuf_size);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=i;\\r\\ngoto start;\\r\\n}\\r\\nstatic int buffer_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint i,num=0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni=ctx->obuf_size-(ctx->obuf_len+ctx->obuf_off);\\r\\nif (i >= inl)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),in,inl);\\r\\nctx->obuf_len+=inl;\\r\\nreturn(num+inl);\\r\\n}\\r\\nif (ctx->obuf_len != 0)\\r\\n{\\r\\nif (i > 0)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),in,i);\\r\\nin+=i;\\r\\ninl-=i;\\r\\nnum+=i;\\r\\nctx->obuf_len+=i;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->obuf[ctx->obuf_off]),\\r\\nctx->obuf_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->obuf_off+=i;\\r\\nctx->obuf_len-=i;\\r\\nif (ctx->obuf_len == 0) break;\\r\\n}\\r\\n}\\r\\nctx->obuf_off=0;\\r\\nwhile (inl >= ctx->obuf_size)\\r\\n{\\r\\ni=BIO_write(b->next_bio,in,inl);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nnum+=i;\\r\\nin+=i;\\r\\ninl-=i;\\r\\nif (inl == 0) return(num);\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nstatic long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nlong ret=1;\\r\\nchar *p1,*p2;\\r\\nint r,i,*ip;\\r\\nint ibs,obs;\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)ctx->obuf_len;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUFF_NUM_LINES:\\r\\nret=0;\\r\\np1=ctx->ibuf;\\r\\nfor (i=ctx->ibuf_off; i<ctx->ibuf_len; i++)\\r\\n{\\r\\nif (p1[i] == '\\n') ret++;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=(long)ctx->obuf_len;\\r\\nif (ret == 0)\\r\\n{\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=(long)ctx->ibuf_len;\\r\\nif (ret == 0)\\r\\n{\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_READ_DATA:\\r\\nif (num > ctx->ibuf_size)\\r\\n{\\r\\np1=OPENSSL_malloc((int)num);\\r\\nif (p1 == NULL) goto malloc_error;\\r\\nif (ctx->ibuf != NULL) OPENSSL_free(ctx->ibuf);\\r\\nctx->ibuf=p1;\\r\\n}\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=(int)num;\\r\\nmemcpy(ctx->ibuf,ptr,(int)num);\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (*ip == 0)\\r\\n{\\r\\nibs=(int)num;\\r\\nobs=ctx->obuf_size;\\r\\n}\\r\\nelse\\r\\n{\\r\\nibs=ctx->ibuf_size;\\r\\nobs=(int)num;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nibs=(int)num;\\r\\nobs=(int)num;\\r\\n}\\r\\np1=ctx->ibuf;\\r\\np2=ctx->obuf;\\r\\nif ((ibs > DEFAULT_BUFFER_SIZE) && (ibs != ctx->ibuf_size))\\r\\n{\\r\\np1=(char *)OPENSSL_malloc((int)num);\\r\\nif (p1 == NULL) goto malloc_error;\\r\\n}\\r\\nif ((obs > DEFAULT_BUFFER_SIZE) && (obs != ctx->obuf_size))\\r\\n{\\r\\np2=(char *)OPENSSL_malloc((int)num);\\r\\nif (p2 == NULL)\\r\\n{\\r\\nif (p1 != ctx->ibuf) OPENSSL_free(p1);\\r\\ngoto malloc_error;\\r\\n}\\r\\n}\\r\\nif (ctx->ibuf != p1)\\r\\n{\\r\\nOPENSSL_free(ctx->ibuf);\\r\\nctx->ibuf=p1;\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=0;\\r\\nctx->ibuf_size=ibs;\\r\\n}\\r\\nif (ctx->obuf != p2)\\r\\n{\\r\\nOPENSSL_free(ctx->obuf);\\r\\nctx->obuf=p2;\\r\\nctx->obuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_size=obs;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nif (ctx->obuf_len <= 0)\\r\\n{\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->obuf_len > ctx->obuf_off)\\r\\n{\\r\\nr=BIO_write(b->next_bio,\\r\\n&(ctx->obuf[ctx->obuf_off]),\\r\\nctx->obuf_len-ctx->obuf_off);\\r\\n#if 0\\r\\nfprintf(stderr,\"FLUSH [%3d] %3d -> %3d\\n\",ctx->obuf_off,ctx->obuf_len-ctx->obuf_off,r);\\r\\n#endif\\r\\nBIO_copy_next_retry(b);\\r\\nif (r <= 0) return((long)r);\\r\\nctx->obuf_off+=r;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nret=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif ( !BIO_set_read_buffer_size(dbio,ctx->ibuf_size) ||\\r\\n!BIO_set_write_buffer_size(dbio,ctx->obuf_size))\\r\\nret=0;\\r\\nbreak;\\r\\ndefault:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\nmalloc_error:\\r\\nBIOerr(BIO_F_BUFFER_CTRL,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nstatic long buffer_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int buffer_gets(BIO *b, char *buf, int size)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nint num=0,i,flag;\\r\\nchar *p;\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nsize--;\\r\\nBIO_clear_retry_flags(b);\\r\\nfor (;;)\\r\\n{\\r\\nif (ctx->ibuf_len > 0)\\r\\n{\\r\\np= &(ctx->ibuf[ctx->ibuf_off]);\\r\\nflag=0;\\r\\nfor (i=0; (i<ctx->ibuf_len) && (i<size); i++)\\r\\n{\\r\\n*(buf++)=p[i];\\r\\nif (p[i] == '\\n')\\r\\n{\\r\\nflag=1;\\r\\ni++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nsize-=i;\\r\\nctx->ibuf_len-=i;\\r\\nctx->ibuf_off+=i;\\r\\nif (flag || size == 0)\\r\\n{\\r\\n*buf='\\0';\\r\\nreturn(num);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=BIO_read(b->next_bio,ctx->ibuf,ctx->ibuf_size);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\n*buf='\\0';\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->ibuf_len=i;\\r\\nctx->ibuf_off=0;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int buffer_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn(buffer_write(b,str,strlen(str)));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_f_string_c", "target": 0, "func": "int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"0\",1) != 1) goto err;\\r\\nn=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1)\\r\\n{\\r\\nif (first)\\r\\nbreak;\\r\\nelse\\r\\ngoto err_sl;\\r\\n}\\r\\nfirst=0;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=i-1; j>0; j--)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)OPENSSL_malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=(unsigned char *)OPENSSL_realloc(s,\\r\\n(unsigned int)num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) OPENSSL_free(s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_nuron_c", "target": 0, "func": "static const char *get_NURON_LIBNAME(void)\\r\\n{\\r\\nif(NURON_LIBNAME)\\r\\nreturn NURON_LIBNAME;\\r\\nreturn \"nuronssl\";\\r\\n}\\r\\nstatic void free_NURON_LIBNAME(void)\\r\\n{\\r\\nif(NURON_LIBNAME)\\r\\nOPENSSL_free((void*)NURON_LIBNAME);\\r\\nNURON_LIBNAME = NULL;\\r\\n}\\r\\nstatic long set_NURON_LIBNAME(const char *name)\\r\\n{\\r\\nfree_NURON_LIBNAME();\\r\\nreturn (((NURON_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int nuron_destroy(ENGINE *e)\\r\\n{\\r\\nfree_NURON_LIBNAME();\\r\\nERR_unload_NURON_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int nuron_init(ENGINE *e)\\r\\n{\\r\\nif(pvDSOHandle != NULL)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_INIT,NURON_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\npvDSOHandle = DSO_load(NULL, get_NURON_LIBNAME(), NULL,\\r\\nDSO_FLAG_NAME_TRANSLATION_EXT_ONLY);\\r\\nif(!pvDSOHandle)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_INIT,NURON_R_DSO_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\npfnModExp = (tfnModExp *)DSO_bind_func(pvDSOHandle, NURON_F1);\\r\\nif(!pfnModExp)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_INIT,NURON_R_DSO_FUNCTION_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int nuron_finish(ENGINE *e)\\r\\n{\\r\\nfree_NURON_LIBNAME();\\r\\nif(pvDSOHandle == NULL)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_FINISH,NURON_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(pvDSOHandle))\\r\\n{\\r\\nNURONerr(NURON_F_NURON_FINISH,NURON_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npvDSOHandle=NULL;\\r\\npfnModExp=NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int nuron_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((pvDSOHandle == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase NURON_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_CTRL,NURON_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_NURON_LIBNAME((const char *)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nNURONerr(NURON_F_NURON_CTRL,NURON_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int nuron_mod_exp(BIGNUM *r,const BIGNUM *a,const BIGNUM *p,\\r\\nconst BIGNUM *m,BN_CTX *ctx)\\r\\n{\\r\\nif(!pvDSOHandle)\\r\\n{\\r\\nNURONerr(NURON_F_NURON_MOD_EXP,NURON_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn pfnModExp(r,a,p,m);\\r\\n}\\r\\nstatic int nuron_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nreturn nuron_mod_exp(r0,I,rsa->d,rsa->n,ctx);\\r\\n}\\r\\nstatic int nuron_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint to_return = 0;\\r\\nBN_init(&t);\\r\\nif (!nuron_mod_exp(rr,a1,p1,m,ctx))\\r\\ngoto end;\\r\\nif (!nuron_mod_exp(&t,a2,p2,m,ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx))\\r\\ngoto end;\\r\\nto_return = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int nuron_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn nuron_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int nuron_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn nuron_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int nuron_mod_exp_dh(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn nuron_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nconst DSA_METHOD *meth2;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth3;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_nuron_id) ||\\r\\n!ENGINE_set_name(e, engine_nuron_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &nuron_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &nuron_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &nuron_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_destroy_function(e, nuron_destroy) ||\\r\\n!ENGINE_set_init_function(e, nuron_init) ||\\r\\n!ENGINE_set_finish_function(e, nuron_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, nuron_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, nuron_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1=RSA_PKCS1_SSLeay();\\r\\nnuron_rsa.rsa_pub_enc=meth1->rsa_pub_enc;\\r\\nnuron_rsa.rsa_pub_dec=meth1->rsa_pub_dec;\\r\\nnuron_rsa.rsa_priv_enc=meth1->rsa_priv_enc;\\r\\nnuron_rsa.rsa_priv_dec=meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nmeth2=DSA_OpenSSL();\\r\\nnuron_dsa.dsa_do_sign=meth2->dsa_do_sign;\\r\\nnuron_dsa.dsa_sign_setup=meth2->dsa_sign_setup;\\r\\nnuron_dsa.dsa_do_verify=meth2->dsa_do_verify;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth3=DH_OpenSSL();\\r\\nnuron_dh.generate_key=meth3->generate_key;\\r\\nnuron_dh.compute_key=meth3->compute_key;\\r\\n#endif\\r\\nERR_load_NURON_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_nuron(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_nuron(void)\\r\\n{\\r\\nENGINE *toadd = engine_nuron();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_nuron_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_sign_c", "target": 0, "func": "void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit_ex(ctx, type, NULL);\\r\\n}\\r\\nvoid PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,\\r\\nunsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,data,count);\\r\\n}\\r\\nint PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\\r\\nEVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char *m;\\r\\nint i,ret=0;\\r\\nunsigned int m_len;\\r\\nm=(unsigned char *)OPENSSL_malloc(EVP_PKEY_size(pkey)+2);\\r\\nif (m == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_SignFinal(ctx,m,&m_len,pkey) <= 0) goto err;\\r\\ni=EVP_EncodeBlock(sigret,m,m_len);\\r\\n*siglen=i;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) OPENSSL_free(m);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_err_c", "target": 0, "func": "void ERR_load_RSA_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,RSA_str_functs);\\r\\nERR_load_strings(0,RSA_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_eay_c", "target": 0, "func": "const RSA_METHOD *RSA_PKCS1_SSLeay(void)\\r\\n{\\r\\nreturn(&rsa_pkcs1_eay_meth);\\r\\n}\\r\\nstatic int RSA_eay_public_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM *f,*ret;\\r\\nint i,j,k,num=0,r= -1;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nf = BN_CTX_get(ctx);\\r\\nret = BN_CTX_get(ctx);\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nbuf = OPENSSL_malloc(num);\\r\\nif (!f || !ret || !buf)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\ni=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_SHA\\r\\ncase RSA_PKCS1_OAEP_PADDING:\\r\\ni=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);\\r\\nbreak;\\r\\n#endif\\r\\ncase RSA_SSLV23_PADDING:\\r\\ni=RSA_padding_add_SSLv23(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\ni=RSA_padding_add_none(buf,num,from,flen);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (i <= 0) goto err;\\r\\nif (BN_bin2bn(buf,num,f) == NULL) goto err;\\r\\nif (BN_ucmp(f, rsa->n) >= 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\\r\\ngoto err;\\r\\n}\\r\\nMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\\r\\nif (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\nj=BN_num_bytes(ret);\\r\\ni=BN_bn2bin(ret,&(to[num-j]));\\r\\nfor (k=0; k<(num-i); k++)\\r\\nto[k]=0;\\r\\nr=num;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,num);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic BN_BLINDING *rsa_get_blinding(RSA *rsa, BIGNUM **r, int *local, BN_CTX *ctx)\\r\\n{\\r\\nBN_BLINDING *ret;\\r\\nif (rsa->blinding == NULL)\\r\\n{\\r\\nif (rsa->blinding == NULL)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RSA);\\r\\nif (rsa->blinding == NULL)\\r\\nrsa->blinding = RSA_setup_blinding(rsa, ctx);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RSA);\\r\\n}\\r\\n}\\r\\nret = rsa->blinding;\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (BN_BLINDING_get_thread_id(ret) != CRYPTO_thread_id())\\r\\n{\\r\\n*local = 0;\\r\\nif (rsa->mt_blinding == NULL)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RSA);\\r\\nif (rsa->mt_blinding == NULL)\\r\\nrsa->mt_blinding = RSA_setup_blinding(rsa, ctx);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RSA);\\r\\n}\\r\\nret = rsa->mt_blinding;\\r\\n}\\r\\nelse\\r\\n*local = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,\\r\\nBIGNUM *r, BN_CTX *ctx)\\r\\n{\\r\\nif (local)\\r\\nreturn BN_BLINDING_convert_ex(f, NULL, b, ctx);\\r\\nelse\\r\\n{\\r\\nint ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);\\r\\nret = BN_BLINDING_convert_ex(f, r, b, ctx);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nstatic int rsa_blinding_invert(BN_BLINDING *b, int local, BIGNUM *f,\\r\\nBIGNUM *r, BN_CTX *ctx)\\r\\n{\\r\\nif (local)\\r\\nreturn BN_BLINDING_invert_ex(f, NULL, b, ctx);\\r\\nelse\\r\\n{\\r\\nint ret;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);\\r\\nret = BN_BLINDING_invert_ex(f, r, b, ctx);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nstatic int RSA_eay_private_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM *f, *ret, *br, *res;\\r\\nint i,j,k,num=0,r= -1;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nint local_blinding = 0;\\r\\nBN_BLINDING *blinding = NULL;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nf = BN_CTX_get(ctx);\\r\\nbr = BN_CTX_get(ctx);\\r\\nret = BN_CTX_get(ctx);\\r\\nnum = BN_num_bytes(rsa->n);\\r\\nbuf = OPENSSL_malloc(num);\\r\\nif(!f || !ret || !buf)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\ni=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_X931_PADDING:\\r\\ni=RSA_padding_add_X931(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\ni=RSA_padding_add_none(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_SSLV23_PADDING:\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (i <= 0) goto err;\\r\\nif (BN_bin2bn(buf,num,f) == NULL) goto err;\\r\\nif (BN_ucmp(f, rsa->n) >= 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\\r\\ngoto err;\\r\\n}\\r\\nif (!(rsa->flags & RSA_FLAG_NO_BLINDING))\\r\\n{\\r\\nblinding = rsa_get_blinding(rsa, &br, &local_blinding, ctx);\\r\\nif (blinding == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (blinding != NULL)\\r\\nif (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))\\r\\ngoto err;\\r\\nif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\\r\\n((rsa->p != NULL) &&\\r\\n(rsa->q != NULL) &&\\r\\n(rsa->dmp1 != NULL) &&\\r\\n(rsa->dmq1 != NULL) &&\\r\\n(rsa->iqmp != NULL)) )\\r\\n{\\r\\nif (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIGNUM local_d;\\r\\nBIGNUM *d = NULL;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))\\r\\n{\\r\\nBN_init(&local_d);\\r\\nd = &local_d;\\r\\nBN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\nd = rsa->d;\\r\\nMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\\r\\nif (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\n}\\r\\nif (blinding)\\r\\nif (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))\\r\\ngoto err;\\r\\nif (padding == RSA_X931_PADDING)\\r\\n{\\r\\nBN_sub(f, rsa->n, ret);\\r\\nif (BN_cmp(ret, f))\\r\\nres = f;\\r\\nelse\\r\\nres = ret;\\r\\n}\\r\\nelse\\r\\nres = ret;\\r\\nj=BN_num_bytes(res);\\r\\ni=BN_bn2bin(res,&(to[num-j]));\\r\\nfor (k=0; k<(num-i); k++)\\r\\nto[k]=0;\\r\\nr=num;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,num);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_private_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM *f, *ret, *br;\\r\\nint j,num=0,r= -1;\\r\\nunsigned char *p;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nint local_blinding = 0;\\r\\nBN_BLINDING *blinding = NULL;\\r\\nif((ctx = BN_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nf = BN_CTX_get(ctx);\\r\\nbr = BN_CTX_get(ctx);\\r\\nret = BN_CTX_get(ctx);\\r\\nnum = BN_num_bytes(rsa->n);\\r\\nbuf = OPENSSL_malloc(num);\\r\\nif(!f || !ret || !buf)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (flen > num)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_bin2bn(from,(int)flen,f) == NULL) goto err;\\r\\nif (BN_ucmp(f, rsa->n) >= 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\\r\\ngoto err;\\r\\n}\\r\\nif (!(rsa->flags & RSA_FLAG_NO_BLINDING))\\r\\n{\\r\\nblinding = rsa_get_blinding(rsa, &br, &local_blinding, ctx);\\r\\nif (blinding == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (blinding != NULL)\\r\\nif (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))\\r\\ngoto err;\\r\\nif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\\r\\n((rsa->p != NULL) &&\\r\\n(rsa->q != NULL) &&\\r\\n(rsa->dmp1 != NULL) &&\\r\\n(rsa->dmq1 != NULL) &&\\r\\n(rsa->iqmp != NULL)) )\\r\\n{\\r\\nif (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIGNUM local_d;\\r\\nBIGNUM *d = NULL;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))\\r\\n{\\r\\nd = &local_d;\\r\\nBN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\nd = rsa->d;\\r\\nMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\\r\\nif (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,\\r\\nrsa->_method_mod_n))\\r\\ngoto err;\\r\\n}\\r\\nif (blinding)\\r\\nif (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))\\r\\ngoto err;\\r\\np=buf;\\r\\nj=BN_bn2bin(ret,p);\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\nr=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_SHA\\r\\ncase RSA_PKCS1_OAEP_PADDING:\\r\\nr=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);\\r\\nbreak;\\r\\n#endif\\r\\ncase RSA_SSLV23_PADDING:\\r\\nr=RSA_padding_check_SSLv23(to,num,buf,j,num);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\nr=RSA_padding_check_none(to,num,buf,j,num);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (r < 0)\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,num);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_public_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM *f,*ret;\\r\\nint i,num=0,r= -1;\\r\\nunsigned char *p;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nif((ctx = BN_CTX_new()) == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nf = BN_CTX_get(ctx);\\r\\nret = BN_CTX_get(ctx);\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nbuf = OPENSSL_malloc(num);\\r\\nif(!f || !ret || !buf)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (flen > num)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_bin2bn(from,flen,f) == NULL) goto err;\\r\\nif (BN_ucmp(f, rsa->n) >= 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);\\r\\ngoto err;\\r\\n}\\r\\nMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\\r\\nif (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\nif ((padding == RSA_X931_PADDING) && ((ret->d[0] & 0xf) != 12))\\r\\nBN_sub(ret, rsa->n, ret);\\r\\np=buf;\\r\\ni=BN_bn2bin(ret,p);\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\nr=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);\\r\\nbreak;\\r\\ncase RSA_X931_PADDING:\\r\\nr=RSA_padding_check_X931(to,num,buf,i,num);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\nr=RSA_padding_check_none(to,num,buf,i,num);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (r < 0)\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,num);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *r1,*m1,*vrfy;\\r\\nBIGNUM local_dmp1, local_dmq1;\\r\\nBIGNUM *dmp1, *dmq1;\\r\\nint ret=0;\\r\\nBN_CTX_start(ctx);\\r\\nr1 = BN_CTX_get(ctx);\\r\\nm1 = BN_CTX_get(ctx);\\r\\nvrfy = BN_CTX_get(ctx);\\r\\nMONT_HELPER(rsa, ctx, p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);\\r\\nMONT_HELPER(rsa, ctx, q, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);\\r\\nMONT_HELPER(rsa, ctx, n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);\\r\\nif (!BN_mod(r1,I,rsa->q,ctx)) goto err;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))\\r\\n{\\r\\ndmq1 = &local_dmq1;\\r\\nBN_with_flags(dmq1, rsa->dmq1, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\ndmq1 = rsa->dmq1;\\r\\nif (!rsa->meth->bn_mod_exp(m1,r1,dmq1,rsa->q,ctx,\\r\\nrsa->_method_mod_q)) goto err;\\r\\nif (!BN_mod(r1,I,rsa->p,ctx)) goto err;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))\\r\\n{\\r\\ndmp1 = &local_dmp1;\\r\\nBN_with_flags(dmp1, rsa->dmp1, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\ndmp1 = rsa->dmp1;\\r\\nif (!rsa->meth->bn_mod_exp(r0,r1,dmp1,rsa->p,ctx,\\r\\nrsa->_method_mod_p)) goto err;\\r\\nif (!BN_sub(r0,r0,m1)) goto err;\\r\\nif (BN_is_negative(r0))\\r\\nif (!BN_add(r0,r0,rsa->p)) goto err;\\r\\nif (!BN_mul(r1,r0,rsa->iqmp,ctx)) goto err;\\r\\nif (!BN_mod(r0,r1,rsa->p,ctx)) goto err;\\r\\nif (BN_is_negative(r0))\\r\\nif (!BN_add(r0,r0,rsa->p)) goto err;\\r\\nif (!BN_mul(r1,r0,rsa->q,ctx)) goto err;\\r\\nif (!BN_add(r0,r1,m1)) goto err;\\r\\nif (rsa->e && rsa->n)\\r\\n{\\r\\nif (!rsa->meth->bn_mod_exp(vrfy,r0,rsa->e,rsa->n,ctx,rsa->_method_mod_n)) goto err;\\r\\nif (!BN_sub(vrfy, vrfy, I)) goto err;\\r\\nif (!BN_mod(vrfy, vrfy, rsa->n, ctx)) goto err;\\r\\nif (BN_is_negative(vrfy))\\r\\nif (!BN_add(vrfy, vrfy, rsa->n)) goto err;\\r\\nif (!BN_is_zero(vrfy))\\r\\n{\\r\\nBIGNUM local_d;\\r\\nBIGNUM *d = NULL;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))\\r\\n{\\r\\nd = &local_d;\\r\\nBN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);\\r\\n}\\r\\nelse\\r\\nd = rsa->d;\\r\\nif (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int RSA_eay_init(RSA *rsa)\\r\\n{\\r\\nrsa->flags|=RSA_FLAG_CACHE_PUBLIC|RSA_FLAG_CACHE_PRIVATE;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSA_eay_finish(RSA *rsa)\\r\\n{\\r\\nif (rsa->_method_mod_n != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_n);\\r\\nif (rsa->_method_mod_p != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_p);\\r\\nif (rsa->_method_mod_q != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_q);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_prn_c", "target": 0, "func": "int ASN1_item_print(BIO *out, void *fld, int indent, const ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_print_nm(out, fld, indent, it, it->sname);\\r\\n}\\r\\nstatic int asn1_item_print_nm(BIO *out, void *fld, int indent, const ASN1_ITEM *it, const char *name)\\r\\n{\\r\\nASN1_STRING *str;\\r\\nconst ASN1_TEMPLATE *tt;\\r\\nvoid *tmpfld;\\r\\nint i;\\r\\nif(!fld) {\\r\\nBIO_printf(out, \"%*s%s ABSENT\\n\", indent, \"\", name);\\r\\nreturn 1;\\r\\n}\\r\\nswitch(it->itype) {\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif(it->templates)\\r\\nreturn ASN1_template_print(out, fld, indent, it->templates);\\r\\nreturn asn1_primitive_print(out, fld, it->utype, indent, name);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nstr = fld;\\r\\nreturn asn1_primitive_print(out, fld, str->type, indent, name);\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nBIO_printf(out, \"%*s%s:EXTERNAL TYPE %s %s\\n\", indent, \"\", name, it->sname, fld ? \"\" : \"ABSENT\");\\r\\nreturn 1;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\nBIO_printf(out, \"%*s%s:COMPATIBLE TYPE %s %s\\n\", indent, \"\", name, it->sname, fld ? \"\" : \"ABSENT\");\\r\\nreturn 1;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\ni = asn1_get_choice_selector(fld, it);\\r\\nif((i < 0) || (i >= it->tcount)) {\\r\\nBIO_printf(out, \"%s selector [%d] out of range\\n\", it->sname, i);\\r\\nreturn 1;\\r\\n}\\r\\ntt = it->templates + i;\\r\\ntmpfld = asn1_get_field(fld, tt);\\r\\nreturn ASN1_template_print(out, tmpfld, indent, tt);\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\nBIO_printf(out, \"%*s%s {\\n\", indent, \"\", name);\\r\\nfor(i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\\r\\ntmpfld = asn1_get_field(fld, tt);\\r\\nASN1_template_print(out, tmpfld, indent + 2, tt);\\r\\n}\\r\\nBIO_printf(out, \"%*s}\\n\", indent, \"\");\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint ASN1_template_print(BIO *out, void *fld, int indent, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nint i, flags;\\r\\n#if 0\\r\\nif(!fld) return 0;\\r\\n#endif\\r\\nflags = tt->flags;\\r\\nif(flags & ASN1_TFLG_SK_MASK) {\\r\\nchar *tname;\\r\\nvoid *skitem;\\r\\nif(flags & ASN1_TFLG_SET_OF) tname = \"SET\";\\r\\nelse tname = \"SEQUENCE\";\\r\\nif(fld) {\\r\\nBIO_printf(out, \"%*s%s OF %s {\\n\", indent, \"\", tname, tt->field_name);\\r\\nfor(i = 0; i < sk_num(fld); i++) {\\r\\nskitem = sk_value(fld, i);\\r\\nasn1_item_print_nm(out, skitem, indent + 2, tt->item, \"\");\\r\\n}\\r\\nBIO_printf(out, \"%*s}\\n\", indent, \"\");\\r\\n} else\\r\\nBIO_printf(out, \"%*s%s OF %s ABSENT\\n\", indent, \"\", tname, tt->field_name);\\r\\nreturn 1;\\r\\n}\\r\\nreturn asn1_item_print_nm(out, fld, indent, tt->item, tt->field_name);\\r\\n}\\r\\nstatic int asn1_primitive_print(BIO *out, void *fld, long utype, int indent, const char *name)\\r\\n{\\r\\nASN1_STRING *str = fld;\\r\\nif(fld) {\\r\\nif(utype == V_ASN1_BOOLEAN) {\\r\\nint *bool = fld;\\r\\nif(*bool == -1) printf(\"BOOL MISSING\\n\");\\r\\nBIO_printf(out, \"%*s%s:%s\", indent, \"\", \"BOOLEAN\", *bool ? \"TRUE\" : \"FALSE\");\\r\\n} else if((utype == V_ASN1_INTEGER)\\r\\n|| (utype == V_ASN1_ENUMERATED)) {\\r\\nchar *s, *nm;\\r\\ns = i2s_ASN1_INTEGER(NULL, fld);\\r\\nif(utype == V_ASN1_INTEGER) nm = \"INTEGER\";\\r\\nelse nm = \"ENUMERATED\";\\r\\nBIO_printf(out, \"%*s%s:%s\", indent, \"\", nm, s);\\r\\nOPENSSL_free(s);\\r\\n} else if(utype == V_ASN1_NULL) {\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", \"NULL\");\\r\\n} else if(utype == V_ASN1_UTCTIME) {\\r\\nBIO_printf(out, \"%*s%s:%s:\", indent, \"\", name, \"UTCTIME\");\\r\\nASN1_UTCTIME_print(out, str);\\r\\n} else if(utype == V_ASN1_GENERALIZEDTIME) {\\r\\nBIO_printf(out, \"%*s%s:%s:\", indent, \"\", name, \"GENERALIZEDTIME\");\\r\\nASN1_GENERALIZEDTIME_print(out, str);\\r\\n} else if(utype == V_ASN1_OBJECT) {\\r\\nchar objbuf[80], *ln;\\r\\nln = OBJ_nid2ln(OBJ_obj2nid(fld));\\r\\nif(!ln) ln = \"\";\\r\\nOBJ_obj2txt(objbuf, sizeof objbuf, fld, 1);\\r\\nBIO_printf(out, \"%*s%s:%s (%s)\", indent, \"\", \"OBJECT\", ln, objbuf);\\r\\n} else {\\r\\nBIO_printf(out, \"%*s%s:\", indent, \"\", name);\\r\\nASN1_STRING_print_ex(out, str, ASN1_STRFLGS_DUMP_UNKNOWN|ASN1_STRFLGS_SHOW_TYPE);\\r\\n}\\r\\nBIO_printf(out, \"\\n\");\\r\\n} else BIO_printf(out, \"%*s%s [ABSENT]\\n\", indent, \"\", name);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_utl_c", "target": 0, "func": "unsigned char *asc2uni(const char *asc, int asclen, unsigned char **uni, int *unilen)\\r\\n{\\r\\nint ulen, i;\\r\\nunsigned char *unitmp;\\r\\nif (asclen == -1) asclen = strlen(asc);\\r\\nulen = asclen*2 + 2;\\r\\nif (!(unitmp = OPENSSL_malloc(ulen))) return NULL;\\r\\nfor (i = 0; i < ulen - 2; i+=2) {\\r\\nunitmp[i] = 0;\\r\\nunitmp[i + 1] = asc[i>>1];\\r\\n}\\r\\nunitmp[ulen - 2] = 0;\\r\\nunitmp[ulen - 1] = 0;\\r\\nif (unilen) *unilen = ulen;\\r\\nif (uni) *uni = unitmp;\\r\\nreturn unitmp;\\r\\n}\\r\\nchar *uni2asc(unsigned char *uni, int unilen)\\r\\n{\\r\\nint asclen, i;\\r\\nchar *asctmp;\\r\\nasclen = unilen / 2;\\r\\nif (!unilen || uni[unilen - 1]) asclen++;\\r\\nuni++;\\r\\nif (!(asctmp = OPENSSL_malloc(asclen))) return NULL;\\r\\nfor (i = 0; i < unilen; i+=2) asctmp[i>>1] = uni[i];\\r\\nasctmp[asclen - 1] = 0;\\r\\nreturn asctmp;\\r\\n}\\r\\nint i2d_PKCS12_bio(BIO *bp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(PKCS12), bp, p12);\\r\\n}\\r\\nint i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(PKCS12), fp, p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_bio(BIO *bp, PKCS12 **p12)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(PKCS12), bp, p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(PKCS12), fp, p12);\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_x5092certbag(X509 *x509)\\r\\n{\\r\\nreturn PKCS12_item_pack_safebag(x509, ASN1_ITEM_rptr(X509),\\r\\nNID_x509Certificate, NID_certBag);\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_x509crl2certbag(X509_CRL *crl)\\r\\n{\\r\\nreturn PKCS12_item_pack_safebag(crl, ASN1_ITEM_rptr(X509_CRL),\\r\\nNID_x509Crl, NID_crlBag);\\r\\n}\\r\\nX509 *PKCS12_certbag2x509(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nif(M_PKCS12_bag_type(bag) != NID_certBag) return NULL;\\r\\nif(M_PKCS12_cert_bag_type(bag) != NID_x509Certificate) return NULL;\\r\\nreturn ASN1_item_unpack(bag->value.bag->value.octet, ASN1_ITEM_rptr(X509));\\r\\n}\\r\\nX509_CRL *PKCS12_certbag2x509crl(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nif(M_PKCS12_bag_type(bag) != NID_crlBag) return NULL;\\r\\nif(M_PKCS12_cert_bag_type(bag) != NID_x509Crl) return NULL;\\r\\nreturn ASN1_item_unpack(bag->value.bag->value.octet,\\r\\nASN1_ITEM_rptr(X509_CRL));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_req_c", "target": 0, "func": "static int rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nX509_REQ_INFO *rinf = (X509_REQ_INFO *)*pval;\\r\\nif(operation == ASN1_OP_NEW_POST) {\\r\\nrinf->attributes = sk_X509_ATTRIBUTE_new_null();\\r\\nif(!rinf->attributes) return 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_pkt_c", "target": 0, "func": "static int ssl2_read_internal(SSL *s, void *buf, int len, int peek)\\r\\n{\\r\\nint n;\\r\\nunsigned char mac[MAX_MAC_SIZE];\\r\\nunsigned char *p;\\r\\nint i;\\r\\nunsigned int mac_size;\\r\\nssl2_read_again:\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nclear_sys_error();\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (len <= 0) return(len);\\r\\nif (s->s2->ract_data_length != 0)\\r\\n{\\r\\nif (len > s->s2->ract_data_length)\\r\\nn=s->s2->ract_data_length;\\r\\nelse\\r\\nn=len;\\r\\nmemcpy(buf,s->s2->ract_data,(unsigned int)n);\\r\\nif (!peek)\\r\\n{\\r\\ns->s2->ract_data_length-=n;\\r\\ns->s2->ract_data+=n;\\r\\nif (s->s2->ract_data_length == 0)\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\nif (s->rstate == SSL_ST_READ_HEADER)\\r\\n{\\r\\nif (s->first_packet)\\r\\n{\\r\\nn=read_n(s,5,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\\r\\nif (n <= 0) return(n);\\r\\ns->first_packet=0;\\r\\np=s->packet;\\r\\nif (!((p[0] & 0x80) && (\\r\\n(p[2] == SSL2_MT_CLIENT_HELLO) ||\\r\\n(p[2] == SSL2_MT_SERVER_HELLO))))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_NON_SSLV2_INITIAL_PACKET);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=read_n(s,2,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\\r\\nif (n <= 0) return(n);\\r\\n}\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\np=s->packet;\\r\\ns->s2->escape=0;\\r\\ns->s2->rlength=(((unsigned int)p[0])<<8)|((unsigned int)p[1]);\\r\\nif ((p[0] & TWO_BYTE_BIT))\\r\\n{\\r\\ns->s2->three_byte_header=0;\\r\\ns->s2->rlength&=TWO_BYTE_MASK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s2->three_byte_header=1;\\r\\ns->s2->rlength&=THREE_BYTE_MASK;\\r\\ns->s2->escape=((p[0] & SEC_ESC_BIT))?1:0;\\r\\n}\\r\\n}\\r\\nif (s->rstate == SSL_ST_READ_BODY)\\r\\n{\\r\\nn=s->s2->rlength+2+s->s2->three_byte_header;\\r\\nif (n > (int)s->packet_length)\\r\\n{\\r\\nn-=s->packet_length;\\r\\ni=read_n(s,(unsigned int)n,(unsigned int)n,1);\\r\\nif (i <= 0) return(i);\\r\\n}\\r\\np= &(s->packet[2]);\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nif (s->s2->three_byte_header)\\r\\ns->s2->padding= *(p++);\\r\\nelse s->s2->padding=0;\\r\\nif (s->s2->clear_text)\\r\\n{\\r\\nmac_size = 0;\\r\\ns->s2->mac_data=p;\\r\\ns->s2->ract_data=p;\\r\\nif (s->s2->padding)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_ILLEGAL_PADDING);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmac_size=EVP_MD_size(s->read_hash);\\r\\nOPENSSL_assert(mac_size <= MAX_MAC_SIZE);\\r\\ns->s2->mac_data=p;\\r\\ns->s2->ract_data= &p[mac_size];\\r\\nif (s->s2->padding + mac_size > s->s2->rlength)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_ILLEGAL_PADDING);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\ns->s2->ract_data_length=s->s2->rlength;\\r\\nif ((!s->s2->clear_text) &&\\r\\n(s->s2->rlength >= mac_size))\\r\\n{\\r\\nssl2_enc(s,0);\\r\\ns->s2->ract_data_length-=mac_size;\\r\\nssl2_mac(s,mac,0);\\r\\ns->s2->ract_data_length-=s->s2->padding;\\r\\nif ( (memcmp(mac,s->s2->mac_data,\\r\\n(unsigned int)mac_size) != 0) ||\\r\\n(s->s2->rlength%EVP_CIPHER_CTX_block_size(s->enc_read_ctx) != 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_BAD_MAC_DECODE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nINC32(s->s2->read_sequence);\\r\\ngoto ssl2_read_again;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ_INTERNAL,SSL_R_BAD_STATE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nint ssl2_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl2_read_internal(s, buf, len, 0);\\r\\n}\\r\\nint ssl2_peek(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl2_read_internal(s, buf, len, 1);\\r\\n}\\r\\nstatic int read_n(SSL *s, unsigned int n, unsigned int max,\\r\\nunsigned int extend)\\r\\n{\\r\\nint i,off,newb;\\r\\nif (s->s2->rbuf_left >= (int)n)\\r\\n{\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\n{\\r\\ns->packet= &(s->s2->rbuf[s->s2->rbuf_offs]);\\r\\ns->packet_length=n;\\r\\n}\\r\\ns->s2->rbuf_left-=n;\\r\\ns->s2->rbuf_offs+=n;\\r\\nreturn(n);\\r\\n}\\r\\nif (!s->read_ahead) max=n;\\r\\nif (max > (unsigned int)(SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2))\\r\\nmax=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2;\\r\\noff=0;\\r\\nif ((s->s2->rbuf_left != 0) || ((s->packet_length != 0) && extend))\\r\\n{\\r\\nnewb=s->s2->rbuf_left;\\r\\nif (extend)\\r\\n{\\r\\noff=s->packet_length;\\r\\nif (s->packet != s->s2->rbuf)\\r\\nmemcpy(s->s2->rbuf,s->packet,\\r\\n(unsigned int)newb+off);\\r\\n}\\r\\nelse if (s->s2->rbuf_offs != 0)\\r\\n{\\r\\nmemcpy(s->s2->rbuf,&(s->s2->rbuf[s->s2->rbuf_offs]),\\r\\n(unsigned int)newb);\\r\\ns->s2->rbuf_offs=0;\\r\\n}\\r\\ns->s2->rbuf_left=0;\\r\\n}\\r\\nelse\\r\\nnewb=0;\\r\\ns->packet=s->s2->rbuf;\\r\\nwhile (newb < (int)n)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\ni=BIO_read(s->rbio,(char *)&(s->s2->rbuf[off+newb]),\\r\\nmax-newb);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_READ_N,SSL_R_READ_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\n#ifdef PKT_DEBUG\\r\\nif (s->debug & 0x01) sleep(1);\\r\\n#endif\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s2->rbuf_left+=newb;\\r\\nreturn(i);\\r\\n}\\r\\nnewb+=i;\\r\\n}\\r\\nif (newb > (int)n)\\r\\n{\\r\\ns->s2->rbuf_offs=n+off;\\r\\ns->s2->rbuf_left=newb-n;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s2->rbuf_offs=0;\\r\\ns->s2->rbuf_left=0;\\r\\n}\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\ns->packet_length=n;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(n);\\r\\n}\\r\\nint ssl2_write(SSL *s, const void *_buf, int len)\\r\\n{\\r\\nconst unsigned char *buf=_buf;\\r\\nunsigned int n,tot;\\r\\nint i;\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_WRITE,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (s->error)\\r\\n{\\r\\nssl2_write_error(s);\\r\\nif (s->error)\\r\\nreturn(-1);\\r\\n}\\r\\nclear_sys_error();\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (len <= 0) return(len);\\r\\ntot=s->s2->wnum;\\r\\ns->s2->wnum=0;\\r\\nn=(len-tot);\\r\\nfor (;;)\\r\\n{\\r\\ni=do_ssl_write(s,&(buf[tot]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s2->wnum=tot;\\r\\nreturn(i);\\r\\n}\\r\\nif ((i == (int)n) ||\\r\\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))\\r\\n{\\r\\nreturn(tot+i);\\r\\n}\\r\\nn-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nstatic int write_pending(SSL *s, const unsigned char *buf, unsigned int len)\\r\\n{\\r\\nint i;\\r\\nif ((s->s2->wpend_tot > (int)len) ||\\r\\n((s->s2->wpend_buf != buf) &&\\r\\n!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)))\\r\\n{\\r\\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,\\r\\n(char *)&(s->s2->write_ptr[s->s2->wpend_off]),\\r\\n(unsigned int)s->s2->wpend_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_WRITE_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\n#ifdef PKT_DEBUG\\r\\nif (s->debug & 0x01) sleep(1);\\r\\n#endif\\r\\nif (i == s->s2->wpend_len)\\r\\n{\\r\\ns->s2->wpend_len=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(s->s2->wpend_ret);\\r\\n}\\r\\nelse if (i <= 0)\\r\\nreturn(i);\\r\\ns->s2->wpend_off+=i;\\r\\ns->s2->wpend_len-=i;\\r\\n}\\r\\n}\\r\\nstatic int do_ssl_write(SSL *s, const unsigned char *buf, unsigned int len)\\r\\n{\\r\\nunsigned int j,k,olen,p,mac_size,bs;\\r\\nregister unsigned char *pp;\\r\\nolen=len;\\r\\nif (s->s2->wpend_len != 0) return(write_pending(s,buf,len));\\r\\nif (s->s2->clear_text)\\r\\nmac_size=0;\\r\\nelse\\r\\nmac_size=EVP_MD_size(s->write_hash);\\r\\nif (s->s2->clear_text)\\r\\n{\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\\r\\nlen=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\\r\\np=0;\\r\\ns->s2->three_byte_header=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbs=EVP_CIPHER_CTX_block_size(s->enc_read_ctx);\\r\\nj=len+mac_size;\\r\\nif ((j > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) &&\\r\\n(!s->s2->escape))\\r\\n{\\r\\nif (j > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\\r\\nj=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\\r\\nk=j-(j%bs);\\r\\nlen=k-mac_size;\\r\\ns->s2->three_byte_header=0;\\r\\np=0;\\r\\n}\\r\\nelse if ((bs <= 1) && (!s->s2->escape))\\r\\n{\\r\\ns->s2->three_byte_header=0;\\r\\np=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\np=(j%bs);\\r\\np=(p == 0)?0:(bs-p);\\r\\nif (s->s2->escape)\\r\\n{\\r\\ns->s2->three_byte_header=1;\\r\\nif (j > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\nj=SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER;\\r\\n}\\r\\nelse\\r\\ns->s2->three_byte_header=(p == 0)?0:1;\\r\\n}\\r\\n}\\r\\ns->s2->wlength=len;\\r\\ns->s2->padding=p;\\r\\ns->s2->mac_data= &(s->s2->wbuf[3]);\\r\\ns->s2->wact_data= &(s->s2->wbuf[3+mac_size]);\\r\\nmemcpy(s->s2->wact_data,buf,len);\\r\\nif (p)\\r\\nmemset(&(s->s2->wact_data[len]),0,p);\\r\\nif (!s->s2->clear_text)\\r\\n{\\r\\ns->s2->wact_data_length=len+p;\\r\\nssl2_mac(s,s->s2->mac_data,1);\\r\\ns->s2->wlength+=p+mac_size;\\r\\nssl2_enc(s,1);\\r\\n}\\r\\ns->s2->wpend_len=s->s2->wlength;\\r\\nif (s->s2->three_byte_header)\\r\\n{\\r\\npp=s->s2->mac_data;\\r\\npp-=3;\\r\\npp[0]=(s->s2->wlength>>8)&(THREE_BYTE_MASK>>8);\\r\\nif (s->s2->escape) pp[0]|=SEC_ESC_BIT;\\r\\npp[1]=s->s2->wlength&0xff;\\r\\npp[2]=s->s2->padding;\\r\\ns->s2->wpend_len+=3;\\r\\n}\\r\\nelse\\r\\n{\\r\\npp=s->s2->mac_data;\\r\\npp-=2;\\r\\npp[0]=((s->s2->wlength>>8)&(TWO_BYTE_MASK>>8))|TWO_BYTE_BIT;\\r\\npp[1]=s->s2->wlength&0xff;\\r\\ns->s2->wpend_len+=2;\\r\\n}\\r\\ns->s2->write_ptr=pp;\\r\\nINC32(s->s2->write_sequence);\\r\\ns->s2->wpend_tot=olen;\\r\\ns->s2->wpend_buf=buf;\\r\\ns->s2->wpend_ret=len;\\r\\ns->s2->wpend_off=0;\\r\\nreturn(write_pending(s,buf,olen));\\r\\n}\\r\\nint ssl2_part_read(SSL *s, unsigned long f, int i)\\r\\n{\\r\\nunsigned char *p;\\r\\nint j;\\r\\nif (i < 0)\\r\\n{\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->init_num+=i;\\r\\nif (s->init_num >= 3)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (p[0] == SSL2_MT_ERROR)\\r\\n{\\r\\nj=(p[1]<<8)|p[2];\\r\\nSSLerr((int)f,ssl_mt_error(j));\\r\\ns->init_num -= 3;\\r\\nif (s->init_num > 0)\\r\\nmemmove(p, p+3, s->init_num);\\r\\n}\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nint ssl2_do_write(SSL *s)\\r\\n{\\r\\nint ret;\\r\\nret=ssl2_write(s,&s->init_buf->data[s->init_off],s->init_num);\\r\\nif (ret == s->init_num)\\r\\n{\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, 0, s->init_buf->data, (size_t)(s->init_off + s->init_num), s, s->msg_callback_arg);\\r\\nreturn(1);\\r\\n}\\r\\nif (ret < 0)\\r\\nreturn(-1);\\r\\ns->init_off+=ret;\\r\\ns->init_num-=ret;\\r\\nreturn(0);\\r\\n}\\r\\nstatic int ssl_mt_error(int n)\\r\\n{\\r\\nint ret;\\r\\nswitch (n)\\r\\n{\\r\\ncase SSL2_PE_NO_CIPHER:\\r\\nret=SSL_R_PEER_ERROR_NO_CIPHER;\\r\\nbreak;\\r\\ncase SSL2_PE_NO_CERTIFICATE:\\r\\nret=SSL_R_PEER_ERROR_NO_CERTIFICATE;\\r\\nbreak;\\r\\ncase SSL2_PE_BAD_CERTIFICATE:\\r\\nret=SSL_R_PEER_ERROR_CERTIFICATE;\\r\\nbreak;\\r\\ncase SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE:\\r\\nret=SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE;\\r\\nbreak;\\r\\ndefault:\\r\\nret=SSL_R_UNKNOWN_REMOTE_ERROR_TYPE;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_sign_c", "target": 0, "func": "DSA_SIG * DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nreturn dsa->meth->dsa_do_sign(dgst, dlen, dsa);\\r\\n}\\r\\nint DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,\\r\\nunsigned int *siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\ns=DSA_do_sign(dgst,dlen,dsa);\\r\\nif (s == NULL)\\r\\n{\\r\\n*siglen=0;\\r\\nreturn(0);\\r\\n}\\r\\n*siglen=i2d_DSA_SIG(s,&sig);\\r\\nDSA_SIG_free(s);\\r\\nreturn(1);\\r\\n}\\r\\nint DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)\\r\\n{\\r\\nreturn dsa->meth->dsa_sign_setup(dsa, ctx_in, kinvp, rp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_r2x_c", "target": 0, "func": "X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey)\\r\\n{\\r\\nX509 *ret=NULL;\\r\\nX509_CINF *xi=NULL;\\r\\nX509_NAME *xn;\\r\\nif ((ret=X509_new()) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_TO_X509,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nxi=ret->cert_info;\\r\\nif (sk_X509_ATTRIBUTE_num(r->req_info->attributes) != 0)\\r\\n{\\r\\nif ((xi->version=M_ASN1_INTEGER_new()) == NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(xi->version,2)) goto err;\\r\\n}\\r\\nxn=X509_REQ_get_subject_name(r);\\r\\nX509_set_subject_name(ret,X509_NAME_dup(xn));\\r\\nX509_set_issuer_name(ret,X509_NAME_dup(xn));\\r\\nif (X509_gmtime_adj(xi->validity->notBefore,0) == NULL)\\r\\ngoto err;\\r\\nif (X509_gmtime_adj(xi->validity->notAfter,(long)60*60*24*days) == NULL)\\r\\ngoto err;\\r\\nX509_set_pubkey(ret,X509_REQ_get_pubkey(r));\\r\\nif (!X509_sign(ret,pkey,EVP_md5()))\\r\\ngoto err;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nX509_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_d2i_fp_c", "target": 0, "func": "void *ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x)\\r\\n{\\r\\nBIO *b;\\r\\nvoid *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_FP,ERR_R_BUF_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO_set_fp(b,in,BIO_NOCLOSE);\\r\\nret=ASN1_d2i_bio(xnew,d2i,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x)\\r\\n{\\r\\nBUF_MEM *b = NULL;\\r\\nconst unsigned char *p;\\r\\nvoid *ret=NULL;\\r\\nint len;\\r\\nlen = asn1_d2i_read_bio(in, &b);\\r\\nif(len < 0) goto err;\\r\\np=(unsigned char *)b->data;\\r\\nret=d2i(x,&p,len);\\r\\nerr:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)\\r\\n{\\r\\nBUF_MEM *b = NULL;\\r\\nconst unsigned char *p;\\r\\nvoid *ret=NULL;\\r\\nint len;\\r\\nlen = asn1_d2i_read_bio(in, &b);\\r\\nif(len < 0) goto err;\\r\\np=(const unsigned char *)b->data;\\r\\nret=ASN1_item_d2i(x,&p,len, it);\\r\\nerr:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nchar *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ITEM_D2I_FP,ERR_R_BUF_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO_set_fp(b,in,BIO_NOCLOSE);\\r\\nret=ASN1_item_d2i_bio(it,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nint ret=-1;\\r\\nASN1_const_CTX c;\\r\\nint want=HEADER_SIZE;\\r\\nint eos=0;\\r\\n#if defined(__GNUC__) && defined(__ia64)\\r\\nlong off=0;\\r\\n#else\\r\\nint off=0;\\r\\n#endif\\r\\nint len=0;\\r\\nb=BUF_MEM_new();\\r\\nif (b == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nERR_clear_error();\\r\\nfor (;;)\\r\\n{\\r\\nif (want >= (len-off))\\r\\n{\\r\\nwant-=(len-off);\\r\\nif (!BUF_MEM_grow_clean(b,len+want))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=BIO_read(in,&(b->data[len]),want);\\r\\nif ((i < 0) && ((len-off) == 0))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nif (i > 0)\\r\\nlen+=i;\\r\\n}\\r\\np=(unsigned char *)&(b->data[off]);\\r\\nc.p=p;\\r\\nc.inf=ASN1_get_object(&(c.p),&(c.slen),&(c.tag),&(c.xclass),\\r\\nlen-off);\\r\\nif (c.inf & 0x80)\\r\\n{\\r\\nunsigned long e;\\r\\ne=ERR_GET_REASON(ERR_peek_error());\\r\\nif (e != ASN1_R_TOO_LONG)\\r\\ngoto err;\\r\\nelse\\r\\nERR_clear_error();\\r\\n}\\r\\ni=c.p-p;\\r\\noff+=i;\\r\\nif (c.inf & 1)\\r\\n{\\r\\neos++;\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\nelse if (eos && (c.slen == 0) && (c.tag == V_ASN1_EOC))\\r\\n{\\r\\neos--;\\r\\nif (eos <= 0)\\r\\nbreak;\\r\\nelse\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\nelse\\r\\n{\\r\\nwant=(int)c.slen;\\r\\nif (want > (len-off))\\r\\n{\\r\\nwant-=(len-off);\\r\\nif (!BUF_MEM_grow_clean(b,len+want))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwhile (want > 0)\\r\\n{\\r\\ni=BIO_read(in,&(b->data[len]),want);\\r\\nif (i <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,\\r\\nASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nlen+=i;\\r\\nwant -= i;\\r\\n}\\r\\n}\\r\\noff+=(int)c.slen;\\r\\nif (eos <= 0)\\r\\n{\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\n}\\r\\n*pb = b;\\r\\nreturn off;\\r\\nerr:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i2d_pr_c", "target": 0, "func": "int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (a->type == EVP_PKEY_RSA)\\r\\n{\\r\\nreturn(i2d_RSAPrivateKey(a->pkey.rsa,pp));\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (a->type == EVP_PKEY_DSA)\\r\\n{\\r\\nreturn(i2d_DSAPrivateKey(a->pkey.dsa,pp));\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (a->type == EVP_PKEY_EC)\\r\\n{\\r\\nreturn(i2d_ECPrivateKey(a->pkey.ec, pp));\\r\\n}\\r\\n#endif\\r\\nASN1err(ASN1_F_I2D_PRIVATEKEY,ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x86_64-gcc_c", "target": 0, "func": "BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nif (num <= 0) return(c1);\\r\\nwhile (num&~3)\\r\\n{\\r\\nmul_add(rp[0],ap[0],w,c1);\\r\\nmul_add(rp[1],ap[1],w,c1);\\r\\nmul_add(rp[2],ap[2],w,c1);\\r\\nmul_add(rp[3],ap[3],w,c1);\\r\\nap+=4; rp+=4; num-=4;\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nmul_add(rp[0],ap[0],w,c1); if (--num==0) return c1;\\r\\nmul_add(rp[1],ap[1],w,c1); if (--num==0) return c1;\\r\\nmul_add(rp[2],ap[2],w,c1); return c1;\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nif (num <= 0) return(c1);\\r\\nwhile (num&~3)\\r\\n{\\r\\nmul(rp[0],ap[0],w,c1);\\r\\nmul(rp[1],ap[1],w,c1);\\r\\nmul(rp[2],ap[2],w,c1);\\r\\nmul(rp[3],ap[3],w,c1);\\r\\nap+=4; rp+=4; num-=4;\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nmul(rp[0],ap[0],w,c1); if (--num == 0) return c1;\\r\\nmul(rp[1],ap[1],w,c1); if (--num == 0) return c1;\\r\\nmul(rp[2],ap[2],w,c1);\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)\\r\\n{\\r\\nif (n <= 0) return;\\r\\nwhile (n&~3)\\r\\n{\\r\\nsqr(r[0],r[1],a[0]);\\r\\nsqr(r[2],r[3],a[1]);\\r\\nsqr(r[4],r[5],a[2]);\\r\\nsqr(r[6],r[7],a[3]);\\r\\na+=4; r+=8; n-=4;\\r\\n}\\r\\nif (n)\\r\\n{\\r\\nsqr(r[0],r[1],a[0]); if (--n == 0) return;\\r\\nsqr(r[2],r[3],a[1]); if (--n == 0) return;\\r\\nsqr(r[4],r[5],a[2]);\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{ BN_ULONG ret,waste;\\r\\nasm (\"divq %4\"\\r\\n: \"=a\"(ret),\"=d\"(waste)\\r\\n: \"a\"(l),\"d\"(h),\"g\"(d)\\r\\n: \"cc\");\\r\\nreturn ret;\\r\\n}\\r\\nBN_ULONG bn_add_words (BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,int n)\\r\\n{ BN_ULONG ret=0,i=0;\\r\\nif (n <= 0) return 0;\\r\\nasm (\\r\\n\" subq %2,%2 \\n\"\\r\\n\".align 16 \\n\"\\r\\n\"1: movq (%4,%2,8),%0 \\n\"\\r\\n\" adcq (%5,%2,8),%0 \\n\"\\r\\n\" movq %0,(%3,%2,8) \\n\"\\r\\n\" leaq 1(%2),%2 \\n\"\\r\\n\" loop 1b \\n\"\\r\\n\" sbbq %0,%0 \\n\"\\r\\n: \"=&a\"(ret),\"+c\"(n),\"=&r\"(i)\\r\\n: \"r\"(rp),\"r\"(ap),\"r\"(bp)\\r\\n: \"cc\"\\r\\n);\\r\\nreturn ret&1;\\r\\n}\\r\\nBN_ULONG bn_sub_words (BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,int n)\\r\\n{ BN_ULONG ret=0,i=0;\\r\\nif (n <= 0) return 0;\\r\\nasm (\\r\\n\" subq %2,%2 \\n\"\\r\\n\".align 16 \\n\"\\r\\n\"1: movq (%4,%2,8),%0 \\n\"\\r\\n\" sbbq (%5,%2,8),%0 \\n\"\\r\\n\" movq %0,(%3,%2,8) \\n\"\\r\\n\" leaq 1(%2),%2 \\n\"\\r\\n\" loop 1b \\n\"\\r\\n\" sbbq %0,%0 \\n\"\\r\\n: \"=&a\"(ret),\"+c\"(n),\"=&r\"(i)\\r\\n: \"r\"(rp),\"r\"(ap),\"r\"(bp)\\r\\n: \"cc\"\\r\\n);\\r\\nreturn ret&1;\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nint c=0;\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nfor (;;)\\r\\n{\\r\\nt1=a[0]; t2=b[0];\\r\\nr[0]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[1]; t2=b[1];\\r\\nr[1]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[2]; t2=b[2];\\r\\nr[2]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[3]; t2=b[3];\\r\\nr[3]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn(c);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[4],b[0],c2,c3,c1);\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nmul_add_c(a[0],b[4],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[0],b[5],c3,c1,c2);\\r\\nmul_add_c(a[1],b[4],c3,c1,c2);\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nmul_add_c(a[4],b[1],c3,c1,c2);\\r\\nmul_add_c(a[5],b[0],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[6],b[0],c1,c2,c3);\\r\\nmul_add_c(a[5],b[1],c1,c2,c3);\\r\\nmul_add_c(a[4],b[2],c1,c2,c3);\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nmul_add_c(a[2],b[4],c1,c2,c3);\\r\\nmul_add_c(a[1],b[5],c1,c2,c3);\\r\\nmul_add_c(a[0],b[6],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[7],c2,c3,c1);\\r\\nmul_add_c(a[1],b[6],c2,c3,c1);\\r\\nmul_add_c(a[2],b[5],c2,c3,c1);\\r\\nmul_add_c(a[3],b[4],c2,c3,c1);\\r\\nmul_add_c(a[4],b[3],c2,c3,c1);\\r\\nmul_add_c(a[5],b[2],c2,c3,c1);\\r\\nmul_add_c(a[6],b[1],c2,c3,c1);\\r\\nmul_add_c(a[7],b[0],c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[1],c3,c1,c2);\\r\\nmul_add_c(a[6],b[2],c3,c1,c2);\\r\\nmul_add_c(a[5],b[3],c3,c1,c2);\\r\\nmul_add_c(a[4],b[4],c3,c1,c2);\\r\\nmul_add_c(a[3],b[5],c3,c1,c2);\\r\\nmul_add_c(a[2],b[6],c3,c1,c2);\\r\\nmul_add_c(a[1],b[7],c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[2],b[7],c1,c2,c3);\\r\\nmul_add_c(a[3],b[6],c1,c2,c3);\\r\\nmul_add_c(a[4],b[5],c1,c2,c3);\\r\\nmul_add_c(a[5],b[4],c1,c2,c3);\\r\\nmul_add_c(a[6],b[3],c1,c2,c3);\\r\\nmul_add_c(a[7],b[2],c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[7],b[3],c2,c3,c1);\\r\\nmul_add_c(a[6],b[4],c2,c3,c1);\\r\\nmul_add_c(a[5],b[5],c2,c3,c1);\\r\\nmul_add_c(a[4],b[6],c2,c3,c1);\\r\\nmul_add_c(a[3],b[7],c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[4],b[7],c3,c1,c2);\\r\\nmul_add_c(a[5],b[6],c3,c1,c2);\\r\\nmul_add_c(a[6],b[5],c3,c1,c2);\\r\\nmul_add_c(a[7],b[4],c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[7],b[5],c1,c2,c3);\\r\\nmul_add_c(a[6],b[6],c1,c2,c3);\\r\\nmul_add_c(a[5],b[7],c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[6],b[7],c2,c3,c1);\\r\\nmul_add_c(a[7],b[6],c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[7],c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nsqr_add_c2(a,4,0,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,5,0,c3,c1,c2);\\r\\nsqr_add_c2(a,4,1,c3,c1,c2);\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nsqr_add_c2(a,4,2,c1,c2,c3);\\r\\nsqr_add_c2(a,5,1,c1,c2,c3);\\r\\nsqr_add_c2(a,6,0,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,0,c2,c3,c1);\\r\\nsqr_add_c2(a,6,1,c2,c3,c1);\\r\\nsqr_add_c2(a,5,2,c2,c3,c1);\\r\\nsqr_add_c2(a,4,3,c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,4,c3,c1,c2);\\r\\nsqr_add_c2(a,5,3,c3,c1,c2);\\r\\nsqr_add_c2(a,6,2,c3,c1,c2);\\r\\nsqr_add_c2(a,7,1,c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,7,2,c1,c2,c3);\\r\\nsqr_add_c2(a,6,3,c1,c2,c3);\\r\\nsqr_add_c2(a,5,4,c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,5,c2,c3,c1);\\r\\nsqr_add_c2(a,6,4,c2,c3,c1);\\r\\nsqr_add_c2(a,7,3,c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,7,4,c3,c1,c2);\\r\\nsqr_add_c2(a,6,5,c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,6,c1,c2,c3);\\r\\nsqr_add_c2(a,7,5,c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,6,c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,7,c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_lib_c", "target": 0, "func": "int SSL_clear(SSL *s)\\r\\n{\\r\\nif (s->method == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CLEAR,SSL_R_NO_METHOD_SPECIFIED);\\r\\nreturn(0);\\r\\n}\\r\\nif (ssl_clear_bad_session(s))\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\ns->error=0;\\r\\ns->hit=0;\\r\\ns->shutdown=0;\\r\\n#if 0\\r\\nif (s->new_session) return(1);\\r\\n#else\\r\\nif (s->new_session)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CLEAR,ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\ns->type=0;\\r\\ns->state=SSL_ST_BEFORE|((s->server)?SSL_ST_ACCEPT:SSL_ST_CONNECT);\\r\\ns->version=s->method->version;\\r\\ns->client_version=s->version;\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\n#if 0\\r\\ns->read_ahead=s->ctx->read_ahead;\\r\\n#endif\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\ns->first_packet=0;\\r\\n#if 1\\r\\nif (!s->in_handshake && (s->session == NULL) && (s->method != s->ctx->method))\\r\\n{\\r\\ns->method->ssl_free(s);\\r\\ns->method=s->ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_CTX_set_ssl_version(SSL_CTX *ctx,SSL_METHOD *meth)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nctx->method=meth;\\r\\nsk=ssl_create_cipher_list(ctx->method,&(ctx->cipher_list),\\r\\n&(ctx->cipher_list_by_id),SSL_DEFAULT_CIPHER_LIST);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSSL *SSL_new(SSL_CTX *ctx)\\r\\n{\\r\\nSSL *s;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_NEW,SSL_R_NULL_SSL_CTX);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (ctx->method == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_NEW,SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);\\r\\nreturn(NULL);\\r\\n}\\r\\ns=(SSL *)OPENSSL_malloc(sizeof(SSL));\\r\\nif (s == NULL) goto err;\\r\\nmemset(s,0,sizeof(SSL));\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\ns->kssl_ctx = kssl_ctx_new();\\r\\n#endif\\r\\ns->options=ctx->options;\\r\\ns->mode=ctx->mode;\\r\\ns->max_cert_list=ctx->max_cert_list;\\r\\nif (ctx->cert != NULL)\\r\\n{\\r\\ns->cert = ssl_cert_dup(ctx->cert);\\r\\nif (s->cert == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\ns->cert=NULL;\\r\\ns->read_ahead=ctx->read_ahead;\\r\\ns->msg_callback=ctx->msg_callback;\\r\\ns->msg_callback_arg=ctx->msg_callback_arg;\\r\\ns->verify_mode=ctx->verify_mode;\\r\\n#if 0\\r\\ns->verify_depth=ctx->verify_depth;\\r\\n#endif\\r\\ns->sid_ctx_length=ctx->sid_ctx_length;\\r\\nOPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);\\r\\nmemcpy(&s->sid_ctx,&ctx->sid_ctx,sizeof(s->sid_ctx));\\r\\ns->verify_callback=ctx->default_verify_callback;\\r\\ns->generate_session_id=ctx->generate_session_id;\\r\\ns->param = X509_VERIFY_PARAM_new();\\r\\nif (!s->param)\\r\\ngoto err;\\r\\nX509_VERIFY_PARAM_inherit(s->param, ctx->param);\\r\\n#if 0\\r\\ns->purpose = ctx->purpose;\\r\\ns->trust = ctx->trust;\\r\\n#endif\\r\\ns->quiet_shutdown=ctx->quiet_shutdown;\\r\\nCRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);\\r\\ns->ctx=ctx;\\r\\ns->verify_result=X509_V_OK;\\r\\ns->method=ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\ngoto err;\\r\\ns->references=1;\\r\\ns->server=(ctx->method->ssl_accept == ssl_undefined_function)?0:1;\\r\\nSSL_clear(s);\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\\r\\nreturn(s);\\r\\nerr:\\r\\nif (s != NULL)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nssl_cert_free(s->cert);\\r\\nif (s->ctx != NULL)\\r\\nSSL_CTX_free(s->ctx);\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nSSLerr(SSL_F_SSL_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nint SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif(sid_ctx_len > sizeof ctx->sid_ctx)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nctx->sid_ctx_length=sid_ctx_len;\\r\\nmemcpy(ctx->sid_ctx,sid_ctx,sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nssl->sid_ctx_length=sid_ctx_len;\\r\\nmemcpy(ssl->sid_ctx,sid_ctx,sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nctx->generate_session_id = cb;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nssl->generate_session_id = cb;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,\\r\\nunsigned int id_len)\\r\\n{\\r\\nSSL_SESSION r, *p;\\r\\nif(id_len > sizeof r.session_id)\\r\\nreturn 0;\\r\\nr.ssl_version = ssl->version;\\r\\nr.session_id_length = id_len;\\r\\nmemcpy(r.session_id, id, id_len);\\r\\nif((r.ssl_version == SSL2_VERSION) &&\\r\\n(id_len < SSL2_SSL_SESSION_ID_LENGTH))\\r\\n{\\r\\nmemset(r.session_id + id_len, 0,\\r\\nSSL2_SSL_SESSION_ID_LENGTH - id_len);\\r\\nr.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\np = (SSL_SESSION *)lh_retrieve(ssl->ctx->sessions, &r);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn (p != NULL);\\r\\n}\\r\\nint SSL_CTX_set_purpose(SSL_CTX *s, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(s->param, purpose);\\r\\n}\\r\\nint SSL_set_purpose(SSL *s, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(s->param, purpose);\\r\\n}\\r\\nint SSL_CTX_set_trust(SSL_CTX *s, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(s->param, trust);\\r\\n}\\r\\nint SSL_set_trust(SSL *s, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(s->param, trust);\\r\\n}\\r\\nvoid SSL_free(SSL *s)\\r\\n{\\r\\nint i;\\r\\nif(s == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&s->references,-1,CRYPTO_LOCK_SSL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL\",s);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"SSL_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (s->param)\\r\\nX509_VERIFY_PARAM_free(s->param);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\\r\\nif (s->bbio != NULL)\\r\\n{\\r\\nif (s->bbio == s->wbio)\\r\\n{\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio=NULL;\\r\\n}\\r\\nif (s->rbio != NULL)\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != s->rbio))\\r\\nBIO_free_all(s->wbio);\\r\\nif (s->init_buf != NULL) BUF_MEM_free(s->init_buf);\\r\\nif (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);\\r\\nif (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);\\r\\nif (s->session != NULL)\\r\\n{\\r\\nssl_clear_bad_session(s);\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\nif (s->cert != NULL) ssl_cert_free(s->cert);\\r\\nif (s->ctx) SSL_CTX_free(s->ctx);\\r\\nif (s->client_CA != NULL)\\r\\nsk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);\\r\\nif (s->method != NULL) s->method->ssl_free(s);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (s->kssl_ctx != NULL)\\r\\nkssl_ctx_free(s->kssl_ctx);\\r\\n#endif\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nvoid SSL_set_bio(SSL *s,BIO *rbio,BIO *wbio)\\r\\n{\\r\\nif (s->bbio != NULL)\\r\\n{\\r\\nif (s->wbio == s->bbio)\\r\\n{\\r\\ns->wbio=s->wbio->next_bio;\\r\\ns->bbio->next_bio=NULL;\\r\\n}\\r\\n}\\r\\nif ((s->rbio != NULL) && (s->rbio != rbio))\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))\\r\\nBIO_free_all(s->wbio);\\r\\ns->rbio=rbio;\\r\\ns->wbio=wbio;\\r\\n}\\r\\nBIO *SSL_get_rbio(const SSL *s)\\r\\n{ return(s->rbio); }\\r\\nBIO *SSL_get_wbio(const SSL *s)\\r\\n{ return(s->wbio); }\\r\\nint SSL_get_fd(const SSL *s)\\r\\n{\\r\\nreturn(SSL_get_rfd(s));\\r\\n}\\r\\nint SSL_get_rfd(const SSL *s)\\r\\n{\\r\\nint ret= -1;\\r\\nBIO *b,*r;\\r\\nb=SSL_get_rbio(s);\\r\\nr=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);\\r\\nif (r != NULL)\\r\\nBIO_get_fd(r,&ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_get_wfd(const SSL *s)\\r\\n{\\r\\nint ret= -1;\\r\\nBIO *b,*r;\\r\\nb=SSL_get_wbio(s);\\r\\nr=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);\\r\\nif (r != NULL)\\r\\nBIO_get_fd(r,&ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_fd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_FD,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,bio,bio);\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_wfd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nif ((s->rbio == NULL) || (BIO_method_type(s->rbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->rbio,NULL) != fd))\\r\\n{\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{ SSLerr(SSL_F_SSL_SET_WFD,ERR_R_BUF_LIB); goto err; }\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,SSL_get_rbio(s),bio);\\r\\n}\\r\\nelse\\r\\nSSL_set_bio(s,SSL_get_rbio(s),SSL_get_rbio(s));\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_rfd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nif ((s->wbio == NULL) || (BIO_method_type(s->wbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->wbio,NULL) != fd))\\r\\n{\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_RFD,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,bio,SSL_get_wbio(s));\\r\\n}\\r\\nelse\\r\\nSSL_set_bio(s,SSL_get_wbio(s),SSL_get_wbio(s));\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nsize_t SSL_get_finished(const SSL *s, void *buf, size_t count)\\r\\n{\\r\\nsize_t ret = 0;\\r\\nif (s->s3 != NULL)\\r\\n{\\r\\nret = s->s3->tmp.finish_md_len;\\r\\nif (count > ret)\\r\\ncount = ret;\\r\\nmemcpy(buf, s->s3->tmp.finish_md, count);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nsize_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count)\\r\\n{\\r\\nsize_t ret = 0;\\r\\nif (s->s3 != NULL)\\r\\n{\\r\\nret = s->s3->tmp.peer_finish_md_len;\\r\\nif (count > ret)\\r\\ncount = ret;\\r\\nmemcpy(buf, s->s3->tmp.peer_finish_md, count);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint SSL_get_verify_mode(const SSL *s)\\r\\n{\\r\\nreturn(s->verify_mode);\\r\\n}\\r\\nint SSL_get_verify_depth(const SSL *s)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_get_depth(s->param);\\r\\n}\\r\\nint SSL_CTX_get_verify_mode(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->verify_mode);\\r\\n}\\r\\nint SSL_CTX_get_verify_depth(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_get_depth(ctx->param);\\r\\n}\\r\\nvoid SSL_set_verify(SSL *s,int mode,\\r\\nint (*callback)(int ok,X509_STORE_CTX *ctx))\\r\\n{\\r\\ns->verify_mode=mode;\\r\\nif (callback != NULL)\\r\\ns->verify_callback=callback;\\r\\n}\\r\\nvoid SSL_set_verify_depth(SSL *s,int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(s->param, depth);\\r\\n}\\r\\nvoid SSL_set_read_ahead(SSL *s,int yes)\\r\\n{\\r\\ns->read_ahead=yes;\\r\\n}\\r\\nint SSL_get_read_ahead(const SSL *s)\\r\\n{\\r\\nreturn(s->read_ahead);\\r\\n}\\r\\nint SSL_pending(const SSL *s)\\r\\n{\\r\\nreturn(s->method->ssl_pending(s));\\r\\n}\\r\\nX509 *SSL_get_peer_certificate(const SSL *s)\\r\\n{\\r\\nX509 *r;\\r\\nif ((s == NULL) || (s->session == NULL))\\r\\nr=NULL;\\r\\nelse\\r\\nr=s->session->peer;\\r\\nif (r == NULL) return(r);\\r\\nCRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);\\r\\nreturn(r);\\r\\n}\\r\\nint SSL_CTX_check_private_key(const SSL_CTX *ctx)\\r\\n{\\r\\nif ( (ctx == NULL) ||\\r\\n(ctx->cert == NULL) ||\\r\\n(ctx->cert->key->x509 == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nif (ctx->cert->key->privatekey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));\\r\\n}\\r\\nint SSL_check_private_key(const SSL *ssl)\\r\\n{\\r\\nif (ssl == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (ssl->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn 0;\\r\\n}\\r\\nif (ssl->cert->key->x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nif (ssl->cert->key->privatekey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(X509_check_private_key(ssl->cert->key->x509,\\r\\nssl->cert->key->privatekey));\\r\\n}\\r\\nint SSL_accept(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_accept_state(s);\\r\\nreturn(s->method->ssl_accept(s));\\r\\n}\\r\\nint SSL_connect(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_connect_state(s);\\r\\nreturn(s->method->ssl_connect(s));\\r\\n}\\r\\nlong SSL_get_default_timeout(const SSL *s)\\r\\n{\\r\\nreturn(s->method->get_timeout());\\r\\n}\\r\\nint SSL_read(SSL *s,void *buf,int num)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\nreturn(s->method->ssl_read(s,buf,num));\\r\\n}\\r\\nint SSL_peek(SSL *s,void *buf,int num)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nreturn(s->method->ssl_peek(s,buf,num));\\r\\n}\\r\\nint SSL_write(SSL *s,const void *buf,int num)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nSSLerr(SSL_F_SSL_WRITE,SSL_R_PROTOCOL_IS_SHUTDOWN);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(s->method->ssl_write(s,buf,num));\\r\\n}\\r\\nint SSL_shutdown(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif ((s != NULL) && !SSL_in_init(s))\\r\\nreturn(s->method->ssl_shutdown(s));\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_renegotiate(SSL *s)\\r\\n{\\r\\nif (s->new_session == 0)\\r\\n{\\r\\ns->new_session=1;\\r\\n}\\r\\nreturn(s->method->ssl_renegotiate(s));\\r\\n}\\r\\nint SSL_renegotiate_pending(SSL *s)\\r\\n{\\r\\nreturn (s->new_session != 0);\\r\\n}\\r\\nlong SSL_ctrl(SSL *s,int cmd,long larg,void *parg)\\r\\n{\\r\\nlong l;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn(s->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl=s->read_ahead;\\r\\ns->read_ahead=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK_ARG:\\r\\ns->msg_callback_arg = parg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn(s->options|=larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn(s->mode|=larg);\\r\\ncase SSL_CTRL_GET_MAX_CERT_LIST:\\r\\nreturn(s->max_cert_list);\\r\\ncase SSL_CTRL_SET_MAX_CERT_LIST:\\r\\nl=s->max_cert_list;\\r\\ns->max_cert_list=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_SET_MTU:\\r\\nif (SSL_version(s) == DTLS1_VERSION)\\r\\n{\\r\\ns->d1->mtu = larg;\\r\\nreturn larg;\\r\\n}\\r\\nreturn 0;\\r\\ndefault:\\r\\nreturn(s->method->ssl_ctrl(s,cmd,larg,parg));\\r\\n}\\r\\n}\\r\\nlong SSL_callback_ctrl(SSL *s, int cmd, void (*fp)(void))\\r\\n{\\r\\nswitch(cmd)\\r\\n{\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK:\\r\\ns->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn(s->method->ssl_callback_ctrl(s,cmd,fp));\\r\\n}\\r\\n}\\r\\nstruct lhash_st *SSL_CTX_sessions(SSL_CTX *ctx)\\r\\n{\\r\\nreturn ctx->sessions;\\r\\n}\\r\\nlong SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,void *parg)\\r\\n{\\r\\nlong l;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn(ctx->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl=ctx->read_ahead;\\r\\nctx->read_ahead=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK_ARG:\\r\\nctx->msg_callback_arg = parg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_GET_MAX_CERT_LIST:\\r\\nreturn(ctx->max_cert_list);\\r\\ncase SSL_CTRL_SET_MAX_CERT_LIST:\\r\\nl=ctx->max_cert_list;\\r\\nctx->max_cert_list=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_SIZE:\\r\\nl=ctx->session_cache_size;\\r\\nctx->session_cache_size=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_SIZE:\\r\\nreturn(ctx->session_cache_size);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_MODE:\\r\\nl=ctx->session_cache_mode;\\r\\nctx->session_cache_mode=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_MODE:\\r\\nreturn(ctx->session_cache_mode);\\r\\ncase SSL_CTRL_SESS_NUMBER:\\r\\nreturn(ctx->sessions->num_items);\\r\\ncase SSL_CTRL_SESS_CONNECT:\\r\\nreturn(ctx->stats.sess_connect);\\r\\ncase SSL_CTRL_SESS_CONNECT_GOOD:\\r\\nreturn(ctx->stats.sess_connect_good);\\r\\ncase SSL_CTRL_SESS_CONNECT_RENEGOTIATE:\\r\\nreturn(ctx->stats.sess_connect_renegotiate);\\r\\ncase SSL_CTRL_SESS_ACCEPT:\\r\\nreturn(ctx->stats.sess_accept);\\r\\ncase SSL_CTRL_SESS_ACCEPT_GOOD:\\r\\nreturn(ctx->stats.sess_accept_good);\\r\\ncase SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:\\r\\nreturn(ctx->stats.sess_accept_renegotiate);\\r\\ncase SSL_CTRL_SESS_HIT:\\r\\nreturn(ctx->stats.sess_hit);\\r\\ncase SSL_CTRL_SESS_CB_HIT:\\r\\nreturn(ctx->stats.sess_cb_hit);\\r\\ncase SSL_CTRL_SESS_MISSES:\\r\\nreturn(ctx->stats.sess_miss);\\r\\ncase SSL_CTRL_SESS_TIMEOUTS:\\r\\nreturn(ctx->stats.sess_timeout);\\r\\ncase SSL_CTRL_SESS_CACHE_FULL:\\r\\nreturn(ctx->stats.sess_cache_full);\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn(ctx->options|=larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn(ctx->mode|=larg);\\r\\ndefault:\\r\\nreturn(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));\\r\\n}\\r\\n}\\r\\nlong SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))\\r\\n{\\r\\nswitch(cmd)\\r\\n{\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK:\\r\\nctx->msg_callback = (void (*)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))(fp);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn(ctx->method->ssl_ctx_callback_ctrl(ctx,cmd,fp));\\r\\n}\\r\\n}\\r\\nint ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)\\r\\n{\\r\\nlong l;\\r\\nl=a->id-b->id;\\r\\nif (l == 0L)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((l > 0)?1:-1);\\r\\n}\\r\\nint ssl_cipher_ptr_id_cmp(const SSL_CIPHER * const *ap,\\r\\nconst SSL_CIPHER * const *bp)\\r\\n{\\r\\nlong l;\\r\\nl=(*ap)->id-(*bp)->id;\\r\\nif (l == 0L)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((l > 0)?1:-1);\\r\\n}\\r\\nchar *SSL_get_cipher_list(const SSL *s,int n)\\r\\n{\\r\\nSSL_CIPHER *c;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nif (s == NULL) return(NULL);\\r\\nsk=SSL_get_ciphers(s);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\\r\\nreturn(NULL);\\r\\nc=sk_SSL_CIPHER_value(sk,n);\\r\\nif (c == NULL) return(NULL);\\r\\nreturn(c->name);\\r\\n}\\r\\nint SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk=ssl_create_cipher_list(ctx->method,&ctx->cipher_list,\\r\\n&ctx->cipher_list_by_id,str);\\r\\nif (sk == NULL)\\r\\nreturn 0;\\r\\nelse if (sk_SSL_CIPHER_num(sk) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_cipher_list(SSL *s,const char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk=ssl_create_cipher_list(s->ctx->method,&s->cipher_list,\\r\\n&s->cipher_list_by_id,str);\\r\\nif (sk == NULL)\\r\\nreturn 0;\\r\\nelse if (sk_SSL_CIPHER_num(sk) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)\\r\\n{\\r\\nchar *p;\\r\\nconst char *cp;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nint i;\\r\\nif ((s->session == NULL) || (s->session->ciphers == NULL) ||\\r\\n(len < 2))\\r\\nreturn(NULL);\\r\\np=buf;\\r\\nsk=s->session->ciphers;\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nlen--;\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nfor (cp=c->name; *cp; )\\r\\n{\\r\\nif (len-- == 0)\\r\\n{\\r\\n*p='\\0';\\r\\nreturn(buf);\\r\\n}\\r\\nelse\\r\\n*(p++)= *(cp++);\\r\\n}\\r\\n*(p++)=':';\\r\\n}\\r\\np[-1]='\\0';\\r\\nreturn(buf);\\r\\n}\\r\\nlong SSL_SESSION_hash(const SSL_SESSION *a)\\r\\n{\\r\\nunsigned long l;\\r\\nl=(unsigned long)\\r\\n((unsigned int) a->session_id[0] )|\\r\\n((unsigned int) a->session_id[1]<< 8L)|\\r\\n((unsigned long)a->session_id[2]<<16L)|\\r\\n((unsigned long)a->session_id[3]<<24L);\\r\\nreturn(l);\\r\\n}\\r\\nint SSL_SESSION_cmp(const SSL_SESSION *a,const SSL_SESSION *b)\\r\\n{\\r\\nif (a->ssl_version != b->ssl_version)\\r\\nreturn(1);\\r\\nif (a->session_id_length != b->session_id_length)\\r\\nreturn(1);\\r\\nreturn(memcmp(a->session_id,b->session_id,a->session_id_length));\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)\\r\\n{\\r\\nctx->default_passwd_callback=cb;\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx,void *u)\\r\\n{\\r\\nctx->default_passwd_callback_userdata=u;\\r\\n}\\r\\nvoid SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx, int (*cb)(X509_STORE_CTX *,void *), void *arg)\\r\\n{\\r\\nctx->app_verify_callback=cb;\\r\\nctx->app_verify_arg=arg;\\r\\n}\\r\\nvoid SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*cb)(int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_mode=mode;\\r\\nctx->default_verify_callback=cb;\\r\\n}\\r\\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\n}\\r\\nvoid ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher)\\r\\n{\\r\\nCERT_PKEY *cpk;\\r\\nint rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;\\r\\nint rsa_enc_export,dh_rsa_export,dh_dsa_export;\\r\\nint rsa_tmp_export,dh_tmp_export,kl;\\r\\nunsigned long mask,emask;\\r\\nint have_ecc_cert, have_ecdh_tmp, ecdh_ok, ecdsa_ok, ecc_pkey_size;\\r\\nX509 *x = NULL;\\r\\nEVP_PKEY *ecc_pkey = NULL;\\r\\nint signature_nid = 0;\\r\\nif (c == NULL) return;\\r\\nkl=SSL_C_EXPORT_PKEYLENGTH(cipher);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nrsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);\\r\\nrsa_tmp_export=(c->rsa_tmp_cb != NULL ||\\r\\n(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));\\r\\n#else\\r\\nrsa_tmp=rsa_tmp_export=0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ndh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);\\r\\ndh_tmp_export=(c->dh_tmp_cb != NULL ||\\r\\n(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));\\r\\n#else\\r\\ndh_tmp=dh_tmp_export=0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nhave_ecdh_tmp=(c->ecdh_tmp != NULL || c->ecdh_tmp_cb != NULL);\\r\\n#endif\\r\\ncpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nrsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\nrsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\ncpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);\\r\\nrsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);\\r\\ndsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DH_RSA]);\\r\\ndh_rsa= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ndh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DH_DSA]);\\r\\ndh_dsa= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ndh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\ncpk= &(c->pkeys[SSL_PKEY_ECC]);\\r\\nhave_ecc_cert= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\nmask=0;\\r\\nemask=0;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"rt=%d rte=%d dht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\\n\",\\r\\nrsa_tmp,rsa_tmp_export,dh_tmp,\\r\\nrsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);\\r\\n#endif\\r\\nif (rsa_enc || (rsa_tmp && rsa_sign))\\r\\nmask|=SSL_kRSA;\\r\\nif (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))\\r\\nemask|=SSL_kRSA;\\r\\n#if 0\\r\\nif ( (dh_tmp || dh_rsa || dh_dsa) &&\\r\\n(rsa_enc || rsa_sign || dsa_sign))\\r\\nmask|=SSL_kEDH;\\r\\nif ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&\\r\\n(rsa_enc || rsa_sign || dsa_sign))\\r\\nemask|=SSL_kEDH;\\r\\n#endif\\r\\nif (dh_tmp_export)\\r\\nemask|=SSL_kEDH;\\r\\nif (dh_tmp)\\r\\nmask|=SSL_kEDH;\\r\\nif (dh_rsa) mask|=SSL_kDHr;\\r\\nif (dh_rsa_export) emask|=SSL_kDHr;\\r\\nif (dh_dsa) mask|=SSL_kDHd;\\r\\nif (dh_dsa_export) emask|=SSL_kDHd;\\r\\nif (rsa_enc || rsa_sign)\\r\\n{\\r\\nmask|=SSL_aRSA;\\r\\nemask|=SSL_aRSA;\\r\\n}\\r\\nif (dsa_sign)\\r\\n{\\r\\nmask|=SSL_aDSS;\\r\\nemask|=SSL_aDSS;\\r\\n}\\r\\nmask|=SSL_aNULL;\\r\\nemask|=SSL_aNULL;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nmask|=SSL_kKRB5|SSL_aKRB5;\\r\\nemask|=SSL_kKRB5|SSL_aKRB5;\\r\\n#endif\\r\\nif (have_ecc_cert)\\r\\n{\\r\\nx = (c->pkeys[SSL_PKEY_ECC]).x509;\\r\\nX509_check_purpose(x, -1, 0);\\r\\necdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\\r\\n(x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;\\r\\necdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\\r\\n(x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;\\r\\necc_pkey = X509_get_pubkey(x);\\r\\necc_pkey_size = (ecc_pkey != NULL) ?\\r\\nEVP_PKEY_bits(ecc_pkey) : 0;\\r\\nEVP_PKEY_free(ecc_pkey);\\r\\nif ((x->sig_alg) && (x->sig_alg->algorithm))\\r\\nsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (ecdh_ok)\\r\\n{\\r\\nif ((signature_nid == NID_md5WithRSAEncryption) ||\\r\\n(signature_nid == NID_md4WithRSAEncryption) ||\\r\\n(signature_nid == NID_md2WithRSAEncryption))\\r\\n{\\r\\nmask|=SSL_kECDH|SSL_aRSA;\\r\\nif (ecc_pkey_size <= 163)\\r\\nemask|=SSL_kECDH|SSL_aRSA;\\r\\n}\\r\\nif (signature_nid == NID_ecdsa_with_SHA1)\\r\\n{\\r\\nmask|=SSL_kECDH|SSL_aECDSA;\\r\\nif (ecc_pkey_size <= 163)\\r\\nemask|=SSL_kECDH|SSL_aECDSA;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (ecdsa_ok)\\r\\n{\\r\\nmask|=SSL_aECDSA;\\r\\nemask|=SSL_aECDSA;\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (have_ecdh_tmp)\\r\\n{\\r\\nmask|=SSL_kECDHE;\\r\\nemask|=SSL_kECDHE;\\r\\n}\\r\\n#endif\\r\\nc->mask=mask;\\r\\nc->export_mask=emask;\\r\\nc->valid=1;\\r\\n}\\r\\nint check_srvr_ecc_cert_and_alg(X509 *x, SSL_CIPHER *cs)\\r\\n{\\r\\nunsigned long alg = cs->algorithms;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint keysize = 0;\\r\\nint signature_nid = 0;\\r\\nif (SSL_C_IS_EXPORT(cs))\\r\\n{\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL) return 0;\\r\\nkeysize = EVP_PKEY_bits(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (keysize > 163) return 0;\\r\\n}\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif ((x->sig_alg) && (x->sig_alg->algorithm))\\r\\nsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nif (alg & SSL_kECDH)\\r\\n{\\r\\nif (ku_reject(x, X509v3_KU_KEY_AGREEMENT))\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nif (alg & SSL_aECDSA)\\r\\n{\\r\\nif (signature_nid != NID_ecdsa_with_SHA1)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (alg & SSL_aRSA)\\r\\n{\\r\\nif ((signature_nid != NID_md5WithRSAEncryption) &&\\r\\n(signature_nid != NID_md4WithRSAEncryption) &&\\r\\n(signature_nid != NID_md2WithRSAEncryption))\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse if (alg & SSL_aECDSA)\\r\\n{\\r\\nif (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nX509 *ssl_get_server_send_cert(SSL *s)\\r\\n{\\r\\nunsigned long alg,mask,kalg;\\r\\nCERT *c;\\r\\nint i,is_export;\\r\\nc=s->cert;\\r\\nssl_set_cert_masks(c, s->s3->tmp.new_cipher);\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\nis_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nmask=is_export?c->export_mask:c->mask;\\r\\nkalg=alg&(SSL_MKEY_MASK|SSL_AUTH_MASK);\\r\\nif (kalg & SSL_kECDH)\\r\\n{\\r\\ni=SSL_PKEY_ECC;\\r\\n}\\r\\nelse if (kalg & SSL_aECDSA)\\r\\n{\\r\\ni=SSL_PKEY_ECC;\\r\\n}\\r\\nelse if (kalg & SSL_kDHr)\\r\\ni=SSL_PKEY_DH_RSA;\\r\\nelse if (kalg & SSL_kDHd)\\r\\ni=SSL_PKEY_DH_DSA;\\r\\nelse if (kalg & SSL_aDSS)\\r\\ni=SSL_PKEY_DSA_SIGN;\\r\\nelse if (kalg & SSL_aRSA)\\r\\n{\\r\\nif (c->pkeys[SSL_PKEY_RSA_ENC].x509 == NULL)\\r\\ni=SSL_PKEY_RSA_SIGN;\\r\\nelse\\r\\ni=SSL_PKEY_RSA_ENC;\\r\\n}\\r\\nelse if (kalg & SSL_aKRB5)\\r\\n{\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_SERVER_SEND_CERT,ERR_R_INTERNAL_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (c->pkeys[i].x509 == NULL) return(NULL);\\r\\nreturn(c->pkeys[i].x509);\\r\\n}\\r\\nEVP_PKEY *ssl_get_sign_pkey(SSL *s,SSL_CIPHER *cipher)\\r\\n{\\r\\nunsigned long alg;\\r\\nCERT *c;\\r\\nalg=cipher->algorithms;\\r\\nc=s->cert;\\r\\nif ((alg & SSL_aDSS) &&\\r\\n(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))\\r\\nreturn(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey);\\r\\nelse if (alg & SSL_aRSA)\\r\\n{\\r\\nif (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)\\r\\nreturn(c->pkeys[SSL_PKEY_RSA_SIGN].privatekey);\\r\\nelse if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)\\r\\nreturn(c->pkeys[SSL_PKEY_RSA_ENC].privatekey);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nelse if ((alg & SSL_aECDSA) &&\\r\\n(c->pkeys[SSL_PKEY_ECC].privatekey != NULL))\\r\\nreturn(c->pkeys[SSL_PKEY_ECC].privatekey);\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_SIGN_PKEY,ERR_R_INTERNAL_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nvoid ssl_update_cache(SSL *s,int mode)\\r\\n{\\r\\nint i;\\r\\nif (s->session->session_id_length == 0) return;\\r\\ni=s->ctx->session_cache_mode;\\r\\nif ((i & mode) && (!s->hit)\\r\\n&& ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)\\r\\n|| SSL_CTX_add_session(s->ctx,s->session))\\r\\n&& (s->ctx->new_session_cb != NULL))\\r\\n{\\r\\nCRYPTO_add(&s->session->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nif (!s->ctx->new_session_cb(s,s->session))\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\nif ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&\\r\\n((i & mode) == mode))\\r\\n{\\r\\nif ( (((mode & SSL_SESS_CACHE_CLIENT)\\r\\n?s->ctx->stats.sess_connect_good\\r\\n:s->ctx->stats.sess_accept_good) & 0xff) == 0xff)\\r\\n{\\r\\nSSL_CTX_flush_sessions(s->ctx,time(NULL));\\r\\n}\\r\\n}\\r\\n}\\r\\nSSL_METHOD *SSL_get_ssl_method(SSL *s)\\r\\n{\\r\\nreturn(s->method);\\r\\n}\\r\\nint SSL_set_ssl_method(SSL *s,SSL_METHOD *meth)\\r\\n{\\r\\nint conn= -1;\\r\\nint ret=1;\\r\\nif (s->method != meth)\\r\\n{\\r\\nif (s->handshake_func != NULL)\\r\\nconn=(s->handshake_func == s->method->ssl_connect);\\r\\nif (s->method->version == meth->version)\\r\\ns->method=meth;\\r\\nelse\\r\\n{\\r\\ns->method->ssl_free(s);\\r\\ns->method=meth;\\r\\nret=s->method->ssl_new(s);\\r\\n}\\r\\nif (conn == 1)\\r\\ns->handshake_func=meth->ssl_connect;\\r\\nelse if (conn == 0)\\r\\ns->handshake_func=meth->ssl_accept;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_get_error(const SSL *s,int i)\\r\\n{\\r\\nint reason;\\r\\nunsigned long l;\\r\\nBIO *bio;\\r\\nif (i > 0) return(SSL_ERROR_NONE);\\r\\nif ((l=ERR_peek_error()) != 0)\\r\\n{\\r\\nif (ERR_GET_LIB(l) == ERR_LIB_SYS)\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\nelse\\r\\nreturn(SSL_ERROR_SSL);\\r\\n}\\r\\nif ((i < 0) && SSL_want_read(s))\\r\\n{\\r\\nbio=SSL_get_rbio(s);\\r\\nif (BIO_should_read(bio))\\r\\nreturn(SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_write(bio))\\r\\nreturn(SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_io_special(bio))\\r\\n{\\r\\nreason=BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn(SSL_ERROR_WANT_CONNECT);\\r\\nelse if (reason == BIO_RR_ACCEPT)\\r\\nreturn(SSL_ERROR_WANT_ACCEPT);\\r\\nelse\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_write(s))\\r\\n{\\r\\nbio=SSL_get_wbio(s);\\r\\nif (BIO_should_write(bio))\\r\\nreturn(SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_read(bio))\\r\\nreturn(SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_io_special(bio))\\r\\n{\\r\\nreason=BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn(SSL_ERROR_WANT_CONNECT);\\r\\nelse if (reason == BIO_RR_ACCEPT)\\r\\nreturn(SSL_ERROR_WANT_ACCEPT);\\r\\nelse\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_x509_lookup(s))\\r\\n{\\r\\nreturn(SSL_ERROR_WANT_X509_LOOKUP);\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nif (s->version == SSL2_VERSION)\\r\\n{\\r\\nreturn(SSL_ERROR_ZERO_RETURN);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&\\r\\n(s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))\\r\\nreturn(SSL_ERROR_ZERO_RETURN);\\r\\n}\\r\\n}\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\nint SSL_do_handshake(SSL *s)\\r\\n{\\r\\nint ret=1;\\r\\nif (s->handshake_func == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_DO_HANDSHAKE,SSL_R_CONNECTION_TYPE_NOT_SET);\\r\\nreturn(-1);\\r\\n}\\r\\ns->method->ssl_renegotiate_check(s);\\r\\nif (SSL_in_init(s) || SSL_in_before(s))\\r\\n{\\r\\nret=s->handshake_func(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid SSL_set_accept_state(SSL *s)\\r\\n{\\r\\ns->server=1;\\r\\ns->shutdown=0;\\r\\ns->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\nssl_clear_cipher_ctx(s);\\r\\n}\\r\\nvoid SSL_set_connect_state(SSL *s)\\r\\n{\\r\\ns->server=0;\\r\\ns->shutdown=0;\\r\\ns->state=SSL_ST_CONNECT|SSL_ST_BEFORE;\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\nssl_clear_cipher_ctx(s);\\r\\n}\\r\\nint ssl_undefined_function(SSL *s)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nint ssl_undefined_void_function(void)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nint ssl_undefined_const_function(const SSL *s)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nSSL_METHOD *ssl_bad_method(int ver)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_BAD_METHOD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(NULL);\\r\\n}\\r\\nconst char *SSL_get_version(const SSL *s)\\r\\n{\\r\\nif (s->version == TLS1_VERSION)\\r\\nreturn(\"TLSv1\");\\r\\nelse if (s->version == SSL3_VERSION)\\r\\nreturn(\"SSLv3\");\\r\\nelse if (s->version == SSL2_VERSION)\\r\\nreturn(\"SSLv2\");\\r\\nelse\\r\\nreturn(\"unknown\");\\r\\n}\\r\\nSSL *SSL_dup(SSL *s)\\r\\n{\\r\\nSTACK_OF(X509_NAME) *sk;\\r\\nX509_NAME *xn;\\r\\nSSL *ret;\\r\\nint i;\\r\\nif ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL)\\r\\nreturn(NULL);\\r\\nret->version = s->version;\\r\\nret->type = s->type;\\r\\nret->method = s->method;\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_copy_session_id(ret,s);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->method->ssl_free(ret);\\r\\nret->method = s->method;\\r\\nret->method->ssl_new(ret);\\r\\nif (s->cert != NULL)\\r\\n{\\r\\nif (ret->cert != NULL)\\r\\n{\\r\\nssl_cert_free(ret->cert);\\r\\n}\\r\\nret->cert = ssl_cert_dup(s->cert);\\r\\nif (ret->cert == NULL)\\r\\ngoto err;\\r\\n}\\r\\nSSL_set_session_id_context(ret,\\r\\ns->sid_ctx, s->sid_ctx_length);\\r\\n}\\r\\nret->options=s->options;\\r\\nret->mode=s->mode;\\r\\nSSL_set_max_cert_list(ret,SSL_get_max_cert_list(s));\\r\\nSSL_set_read_ahead(ret,SSL_get_read_ahead(s));\\r\\nret->msg_callback = s->msg_callback;\\r\\nret->msg_callback_arg = s->msg_callback_arg;\\r\\nSSL_set_verify(ret,SSL_get_verify_mode(s),\\r\\nSSL_get_verify_callback(s));\\r\\nSSL_set_verify_depth(ret,SSL_get_verify_depth(s));\\r\\nret->generate_session_id = s->generate_session_id;\\r\\nSSL_set_info_callback(ret,SSL_get_info_callback(s));\\r\\nret->debug=s->debug;\\r\\nif (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL, &ret->ex_data, &s->ex_data))\\r\\ngoto err;\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\nif (!BIO_dup_state(s->rbio,(char *)&ret->rbio))\\r\\ngoto err;\\r\\n}\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\nif (s->wbio != s->rbio)\\r\\n{\\r\\nif (!BIO_dup_state(s->wbio,(char *)&ret->wbio))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nret->wbio=ret->rbio;\\r\\n}\\r\\nret->rwstate = s->rwstate;\\r\\nret->in_handshake = s->in_handshake;\\r\\nret->handshake_func = s->handshake_func;\\r\\nret->server = s->server;\\r\\nret->new_session = s->new_session;\\r\\nret->quiet_shutdown = s->quiet_shutdown;\\r\\nret->shutdown=s->shutdown;\\r\\nret->state=s->state;\\r\\nret->rstate=s->rstate;\\r\\nret->init_num = 0;\\r\\nret->hit=s->hit;\\r\\nX509_VERIFY_PARAM_inherit(ret->param, s->param);\\r\\nif (s->cipher_list != NULL)\\r\\n{\\r\\nif ((ret->cipher_list=sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (s->cipher_list_by_id != NULL)\\r\\nif ((ret->cipher_list_by_id=sk_SSL_CIPHER_dup(s->cipher_list_by_id))\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (s->client_CA != NULL)\\r\\n{\\r\\nif ((sk=sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;\\r\\nret->client_CA=sk;\\r\\nfor (i=0; i<sk_X509_NAME_num(sk); i++)\\r\\n{\\r\\nxn=sk_X509_NAME_value(sk,i);\\r\\nif (sk_X509_NAME_set(sk,i,X509_NAME_dup(xn)) == NULL)\\r\\n{\\r\\nX509_NAME_free(xn);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ret != NULL) SSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ssl_clear_cipher_ctx(SSL *s)\\r\\n{\\r\\nif (s->enc_read_ctx != NULL)\\r\\n{\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_read_ctx);\\r\\nOPENSSL_free(s->enc_read_ctx);\\r\\ns->enc_read_ctx=NULL;\\r\\n}\\r\\nif (s->enc_write_ctx != NULL)\\r\\n{\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_write_ctx);\\r\\nOPENSSL_free(s->enc_write_ctx);\\r\\ns->enc_write_ctx=NULL;\\r\\n}\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\n}\\r\\nX509 *SSL_get_certificate(const SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn(s->cert->key->x509);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nEVP_PKEY *SSL_get_privatekey(SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn(s->cert->key->privatekey);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_CIPHER *SSL_get_current_cipher(const SSL *s)\\r\\n{\\r\\nif ((s->session != NULL) && (s->session->cipher != NULL))\\r\\nreturn(s->session->cipher);\\r\\nreturn(NULL);\\r\\n}\\r\\nconst COMP_METHOD *SSL_get_current_compression(SSL *s)\\r\\n{\\r\\nif (s->compress != NULL)\\r\\nreturn(s->compress->meth);\\r\\nreturn(NULL);\\r\\n}\\r\\nconst COMP_METHOD *SSL_get_current_expansion(SSL *s)\\r\\n{\\r\\nif (s->expand != NULL)\\r\\nreturn(s->expand->meth);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl_init_wbio_buffer(SSL *s,int push)\\r\\n{\\r\\nBIO *bbio;\\r\\nif (s->bbio == NULL)\\r\\n{\\r\\nbbio=BIO_new(BIO_f_buffer());\\r\\nif (bbio == NULL) return(0);\\r\\ns->bbio=bbio;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbbio=s->bbio;\\r\\nif (s->bbio == s->wbio)\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\n}\\r\\n(void)BIO_reset(bbio);\\r\\nif (!BIO_set_read_buffer_size(bbio,1))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_INIT_WBIO_BUFFER,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nif (push)\\r\\n{\\r\\nif (s->wbio != bbio)\\r\\ns->wbio=BIO_push(bbio,s->wbio);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->wbio == bbio)\\r\\ns->wbio=BIO_pop(bbio);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nvoid ssl_free_wbio_buffer(SSL *s)\\r\\n{\\r\\nif (s->bbio == NULL) return;\\r\\nif (s->bbio == s->wbio)\\r\\n{\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\n#ifdef REF_CHECK\\r\\nassert(s->wbio != NULL);\\r\\n#endif\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio=NULL;\\r\\n}\\r\\nvoid SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode)\\r\\n{\\r\\nctx->quiet_shutdown=mode;\\r\\n}\\r\\nint SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_quiet_shutdown(SSL *s,int mode)\\r\\n{\\r\\ns->quiet_shutdown=mode;\\r\\n}\\r\\nint SSL_get_quiet_shutdown(const SSL *s)\\r\\n{\\r\\nreturn(s->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_shutdown(SSL *s,int mode)\\r\\n{\\r\\ns->shutdown=mode;\\r\\n}\\r\\nint SSL_get_shutdown(const SSL *s)\\r\\n{\\r\\nreturn(s->shutdown);\\r\\n}\\r\\nint SSL_version(const SSL *s)\\r\\n{\\r\\nreturn(s->version);\\r\\n}\\r\\nSSL_CTX *SSL_get_SSL_CTX(const SSL *ssl)\\r\\n{\\r\\nreturn(ssl->ctx);\\r\\n}\\r\\nint SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(X509_STORE_set_default_paths(ctx->cert_store));\\r\\n}\\r\\nint SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\\r\\nconst char *CApath)\\r\\n{\\r\\nreturn(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));\\r\\n}\\r\\nvoid SSL_set_info_callback(SSL *ssl,\\r\\nvoid (*cb)(const SSL *ssl,int type,int val))\\r\\n{\\r\\nssl->info_callback=cb;\\r\\n}\\r\\nint SSL_state(const SSL *ssl)\\r\\n{\\r\\nreturn(ssl->state);\\r\\n}\\r\\nvoid SSL_set_verify_result(SSL *ssl,long arg)\\r\\n{\\r\\nssl->verify_result=arg;\\r\\n}\\r\\nlong SSL_get_verify_result(const SSL *ssl)\\r\\n{\\r\\nreturn(ssl->verify_result);\\r\\n}\\r\\nint SSL_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_set_ex_data(SSL *s,int idx,void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_get_ex_data(const SSL *s,int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nint SSL_CTX_get_ex_new_index(long argl,void *argp,CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_CTX_set_ex_data(SSL_CTX *s,int idx,void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_CTX_get_ex_data(const SSL_CTX *s,int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nint ssl_ok(SSL *s)\\r\\n{\\r\\nreturn(1);\\r\\n}\\r\\nX509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->cert_store);\\r\\n}\\r\\nvoid SSL_CTX_set_cert_store(SSL_CTX *ctx,X509_STORE *store)\\r\\n{\\r\\nif (ctx->cert_store != NULL)\\r\\nX509_STORE_free(ctx->cert_store);\\r\\nctx->cert_store=store;\\r\\n}\\r\\nint SSL_want(const SSL *s)\\r\\n{\\r\\nreturn(s->rwstate);\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,RSA *(*cb)(SSL *ssl,\\r\\nint is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);\\r\\n}\\r\\nvoid SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,\\r\\nint is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,(void (*)(void))cb);\\r\\n}\\r\\nRSA *cb(SSL *ssl,int is_export,int keylength)\\r\\n{}\\r\\nvoid SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,DH *(*dh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);\\r\\n}\\r\\nvoid SSL_set_tmp_dh_callback(SSL *ssl,DH *(*dh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,(void (*)(void))dh);\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,EC_KEY *(*ecdh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);\\r\\n}\\r\\nvoid SSL_set_tmp_ecdh_callback(SSL *ssl,EC_KEY *(*ecdh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl,SSL_CTRL_SET_TMP_ECDH_CB,(void (*)(void))ecdh);\\r\\n}\\r\\nvoid SSL_CTX_set_msg_callback(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);\\r\\n}\\r\\nvoid SSL_set_msg_callback(SSL *ssl, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg))\\r\\n{\\r\\nSSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_ssl_c", "target": 0, "func": "BIO_METHOD *BIO_f_ssl(void)\\r\\n{\\r\\nreturn(&methods_sslp);\\r\\n}\\r\\nstatic int ssl_new(BIO *bi)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nbs=(BIO_SSL *)OPENSSL_malloc(sizeof(BIO_SSL));\\r\\nif (bs == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_SSL_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(bs,0,sizeof(BIO_SSL));\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)bs;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ssl_free(BIO *a)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nif (a == NULL) return(0);\\r\\nbs=(BIO_SSL *)a->ptr;\\r\\nif (bs->ssl != NULL) SSL_shutdown(bs->ssl);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif (a->init && (bs->ssl != NULL))\\r\\nSSL_free(bs->ssl);\\r\\na->init=0;\\r\\na->flags=0;\\r\\n}\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ssl_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=1;\\r\\nBIO_SSL *sb;\\r\\nSSL *ssl;\\r\\nint retry_reason=0;\\r\\nint r=0;\\r\\nif (out == NULL) return(0);\\r\\nsb=(BIO_SSL *)b->ptr;\\r\\nssl=sb->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 0\\r\\nif (!SSL_is_init_finished(ssl))\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\noutflags=(BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret=SSL_read(ssl,out,outl);\\r\\nswitch (SSL_get_error(ssl,ret))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0) break;\\r\\nif (sb->renegotiate_count > 0)\\r\\n{\\r\\nsb->byte_count+=ret;\\r\\nif (sb->byte_count > sb->renegotiate_count)\\r\\n{\\r\\nsb->byte_count=0;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr=1;\\r\\n}\\r\\n}\\r\\nif ((sb->renegotiate_timeout > 0) && (!r))\\r\\n{\\r\\nunsigned long tm;\\r\\ntm=(unsigned long)time(NULL);\\r\\nif (tm > sb->last_time+sb->renegotiate_timeout)\\r\\n{\\r\\nsb->last_time=tm;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_ACCEPT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_ACCEPT;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_CONNECT;\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason=retry_reason;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_write(BIO *b, const char *out, int outl)\\r\\n{\\r\\nint ret,r=0;\\r\\nint retry_reason=0;\\r\\nSSL *ssl;\\r\\nBIO_SSL *bs;\\r\\nif (out == NULL) return(0);\\r\\nbs=(BIO_SSL *)b->ptr;\\r\\nssl=bs->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\nret=SSL_write(ssl,out,outl);\\r\\nswitch (SSL_get_error(ssl,ret))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0) break;\\r\\nif (bs->renegotiate_count > 0)\\r\\n{\\r\\nbs->byte_count+=ret;\\r\\nif (bs->byte_count > bs->renegotiate_count)\\r\\n{\\r\\nbs->byte_count=0;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr=1;\\r\\n}\\r\\n}\\r\\nif ((bs->renegotiate_timeout > 0) && (!r))\\r\\n{\\r\\nunsigned long tm;\\r\\ntm=(unsigned long)time(NULL);\\r\\nif (tm > bs->last_time+bs->renegotiate_timeout)\\r\\n{\\r\\nbs->last_time=tm;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_CONNECT;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason=retry_reason;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ssl_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nSSL **sslp,*ssl;\\r\\nBIO_SSL *bs;\\r\\nBIO *dbio,*bio;\\r\\nlong ret=1;\\r\\nbs=(BIO_SSL *)b->ptr;\\r\\nssl=bs->ssl;\\r\\nif ((ssl == NULL) && (cmd != BIO_C_SET_SSL))\\r\\nreturn(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nSSL_shutdown(ssl);\\r\\nif (ssl->handshake_func == ssl->method->ssl_connect)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse if (ssl->handshake_func == ssl->method->ssl_accept)\\r\\nSSL_set_accept_state(ssl);\\r\\nSSL_clear(ssl);\\r\\nif (b->next_bio != NULL)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nelse if (ssl->rbio != NULL)\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nelse\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_SSL_MODE:\\r\\nif (num)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT:\\r\\nret=bs->renegotiate_timeout;\\r\\nif (num < 60) num=5;\\r\\nbs->renegotiate_timeout=(unsigned long)num;\\r\\nbs->last_time=(unsigned long)time(NULL);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_BYTES:\\r\\nret=bs->renegotiate_count;\\r\\nif ((long)num >=512)\\r\\nbs->renegotiate_count=(unsigned long)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL_NUM_RENEGOTIATES:\\r\\nret=bs->num_renegotiates;\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL:\\r\\nif (ssl != NULL)\\r\\nssl_free(b);\\r\\nb->shutdown=(int)num;\\r\\nssl=(SSL *)ptr;\\r\\n((BIO_SSL *)b->ptr)->ssl=ssl;\\r\\nbio=SSL_get_rbio(ssl);\\r\\nif (bio != NULL)\\r\\n{\\r\\nif (b->next_bio != NULL)\\r\\nBIO_push(bio,b->next_bio);\\r\\nb->next_bio=bio;\\r\\nCRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO);\\r\\n}\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nsslp=(SSL **)ptr;\\r\\n*sslp=ssl;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=SSL_pending(ssl);\\r\\nif (ret == 0)\\r\\nret=BIO_pending(ssl->rbio);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\nif ((b->next_bio != NULL) && (b->next_bio != ssl->rbio))\\r\\n{\\r\\nSSL_set_bio(ssl,b->next_bio,b->next_bio);\\r\\nCRYPTO_add(&b->next_bio->references,1,CRYPTO_LOCK_BIO);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_POP:\\r\\nif (ssl->rbio != ssl->wbio)\\r\\n{\\r\\nBIO_free_all(ssl->wbio);\\r\\n}\\r\\nif (b->next_bio != NULL)\\r\\n{\\r\\nCRYPTO_add(&b->next_bio->references,1,CRYPTO_LOCK_BIO);\\r\\n}\\r\\nssl->wbio=NULL;\\r\\nssl->rbio=NULL;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nb->retry_reason=0;\\r\\nret=(int)SSL_do_handshake(ssl);\\r\\nswitch (SSL_get_error(ssl,(int)ret))\\r\\n{\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_WRITE|BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_IO_SPECIAL|BIO_FLAGS_SHOULD_RETRY);\\r\\nb->retry_reason=b->next_bio->retry_reason;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif (((BIO_SSL *)dbio->ptr)->ssl != NULL)\\r\\nSSL_free(((BIO_SSL *)dbio->ptr)->ssl);\\r\\n((BIO_SSL *)dbio->ptr)->ssl=SSL_dup(ssl);\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_count=\\r\\n((BIO_SSL *)b->ptr)->renegotiate_count;\\r\\n((BIO_SSL *)dbio->ptr)->byte_count=\\r\\n((BIO_SSL *)b->ptr)->byte_count;\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_timeout=\\r\\n((BIO_SSL *)b->ptr)->renegotiate_timeout;\\r\\n((BIO_SSL *)dbio->ptr)->last_time=\\r\\n((BIO_SSL *)b->ptr)->last_time;\\r\\nret=(((BIO_SSL *)dbio->ptr)->ssl != NULL);\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\n#if 0\\r\\nSSLerr(SSL_F_SSL_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nret = -1;\\r\\n#else\\r\\nret=0;\\r\\n#endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nvoid (**fptr)(const SSL *xssl,int type,int val);\\r\\nfptr=(void (**)(const SSL *xssl,int type,int val))ptr;\\r\\n*fptr=SSL_get_info_callback(ssl);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ssl_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nSSL *ssl;\\r\\nBIO_SSL *bs;\\r\\nlong ret=1;\\r\\nbs=(BIO_SSL *)b->ptr;\\r\\nssl=bs->ssl;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\nSSL_set_info_callback(ssl,(void (*)(const SSL *,int,int))fp);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(ssl->rbio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=BIO_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SOCK\\r\\nBIO *ret=NULL,*buf=NULL,*ssl=NULL;\\r\\nif ((buf=BIO_new(BIO_f_buffer())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=BIO_new_ssl_connect(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((ret=BIO_push(buf,ssl)) == NULL)\\r\\ngoto err;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (buf != NULL) BIO_free(buf);\\r\\nif (ssl != NULL) BIO_free(ssl);\\r\\n#endif\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\nBIO *ret=NULL,*con=NULL,*ssl=NULL;\\r\\nif ((con=BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=BIO_new_ssl(ctx,1)) == NULL)\\r\\ngoto err;\\r\\nif ((ret=BIO_push(ssl,con)) == NULL)\\r\\ngoto err;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (con != NULL) BIO_free(con);\\r\\nif (ret != NULL) BIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl(SSL_CTX *ctx, int client)\\r\\n{\\r\\nBIO *ret;\\r\\nSSL *ssl;\\r\\nif ((ret=BIO_new(BIO_f_ssl())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=SSL_new(ctx)) == NULL)\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (client)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nBIO_set_ssl(ret,ssl,BIO_CLOSE);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_ssl_copy_session_id(BIO *t, BIO *f)\\r\\n{\\r\\nt=BIO_find_type(t,BIO_TYPE_SSL);\\r\\nf=BIO_find_type(f,BIO_TYPE_SSL);\\r\\nif ((t == NULL) || (f == NULL))\\r\\nreturn(0);\\r\\nif ( (((BIO_SSL *)t->ptr)->ssl == NULL) ||\\r\\n(((BIO_SSL *)f->ptr)->ssl == NULL))\\r\\nreturn(0);\\r\\nSSL_copy_session_id(((BIO_SSL *)t->ptr)->ssl,((BIO_SSL *)f->ptr)->ssl);\\r\\nreturn(1);\\r\\n}\\r\\nvoid BIO_ssl_shutdown(BIO *b)\\r\\n{\\r\\nSSL *s;\\r\\nwhile (b != NULL)\\r\\n{\\r\\nif (b->method->type == BIO_TYPE_SSL)\\r\\n{\\r\\ns=((BIO_SSL *)b->ptr)->ssl;\\r\\nSSL_shutdown(s);\\r\\nbreak;\\r\\n}\\r\\nb=b->next_bio;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_dgram_c", "target": 0, "func": "BIO_METHOD *BIO_s_datagram(void)\\r\\n{\\r\\nreturn(&methods_dgramp);\\r\\n}\\r\\nBIO *BIO_new_dgram(int fd, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_datagram());\\r\\nif (ret == NULL) return(NULL);\\r\\nBIO_set_fd(ret,fd,close_flag);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dgram_new(BIO *bi)\\r\\n{\\r\\nbio_dgram_data *data = NULL;\\r\\nbi->init=0;\\r\\nbi->num=0;\\r\\ndata = OPENSSL_malloc(sizeof(bio_dgram_data));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\nmemset(data, 0x00, sizeof(bio_dgram_data));\\r\\nbi->ptr = data;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int dgram_free(BIO *a)\\r\\n{\\r\\nbio_dgram_data *data;\\r\\nif (a == NULL) return(0);\\r\\nif ( ! dgram_clear(a))\\r\\nreturn 0;\\r\\ndata = (bio_dgram_data *)a->ptr;\\r\\nif(data != NULL) OPENSSL_free(data);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int dgram_clear(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif (a->init)\\r\\n{\\r\\nSHUTDOWN2(a->num);\\r\\n}\\r\\na->init=0;\\r\\na->flags=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int dgram_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nstruct sockaddr peer;\\r\\nint peerlen = sizeof(peer);\\r\\nif (out != NULL)\\r\\n{\\r\\nclear_socket_error();\\r\\nmemset(&peer, 0x00, peerlen);\\r\\nret=recvfrom(b->num,out,outl,0,&peer,(void *)&peerlen);\\r\\nif ( ! data->connected && ret > 0)\\r\\nBIO_ctrl(b, BIO_CTRL_DGRAM_CONNECT, 0, &peer);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_dgram_should_retry(ret))\\r\\n{\\r\\nBIO_set_retry_read(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dgram_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nclear_socket_error();\\r\\nif ( data->connected )\\r\\nret=send(b->num,in,inl,0);\\r\\nelse\\r\\nret=sendto(b->num, in, inl, 0, &data->peer, sizeof(data->peer));\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\n{\\r\\nBIO_set_retry_write(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n#if 0\\r\\nif ( data->_errno == EMSGSIZE)\\r\\nBIO_ctrl(b, BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long dgram_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nint *ip;\\r\\nstruct sockaddr *to = NULL;\\r\\nbio_dgram_data *data = NULL;\\r\\nlong sockopt_val = 0;\\r\\nunsigned int sockopt_len = 0;\\r\\ndata = (bio_dgram_data *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nnum=0;\\r\\ncase BIO_C_FILE_SEEK:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\ndgram_clear(b);\\r\\nb->num= *((int *)ptr);\\r\\nb->shutdown=(int)num;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL) *ip=b->num;\\r\\nret=b->num;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_CONNECT:\\r\\nto = (struct sockaddr *)ptr;\\r\\n#if 0\\r\\nif (connect(b->num, to, sizeof(struct sockaddr)) < 0)\\r\\n{ perror(\"connect\"); ret = 0; }\\r\\nelse\\r\\n{\\r\\n#endif\\r\\nmemcpy(&(data->peer),to, sizeof(struct sockaddr));\\r\\n#if 0\\r\\n}\\r\\n#endif\\r\\nbreak;\\r\\n#ifdef IP_MTU_DISCOVER\\r\\ncase BIO_CTRL_DGRAM_MTU_DISCOVER:\\r\\nsockopt_val = IP_PMTUDISC_DO;\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0)\\r\\nperror(\"setsockopt\");\\r\\nbreak;\\r\\n#endif\\r\\ncase BIO_CTRL_DGRAM_QUERY_MTU:\\r\\nsockopt_len = sizeof(sockopt_val);\\r\\nif ((ret = getsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val,\\r\\n&sockopt_len)) < 0 || sockopt_val < 0)\\r\\n{ ret = 0; }\\r\\nelse\\r\\n{\\r\\ndata->mtu = sockopt_val;\\r\\nret = data->mtu;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_MTU:\\r\\nreturn data->mtu;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_MTU:\\r\\ndata->mtu = num;\\r\\nret = num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_CONNECTED:\\r\\nto = (struct sockaddr *)ptr;\\r\\nif ( to != NULL)\\r\\n{\\r\\ndata->connected = 1;\\r\\nmemcpy(&(data->peer),to, sizeof(struct sockaddr));\\r\\n}\\r\\nelse\\r\\n{\\r\\ndata->connected = 0;\\r\\nmemset(&(data->peer), 0x00, sizeof(struct sockaddr));\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_PEER:\\r\\nto = (struct sockaddr *) ptr;\\r\\nmemcpy(&(data->peer), to, sizeof(struct sockaddr));\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_RECV_TIMEOUT:\\r\\nif ( setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr,\\r\\nsizeof(struct timeval)) < 0)\\r\\n{ perror(\"setsockopt\"); ret = -1; }\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_RECV_TIMEOUT:\\r\\nif ( getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\nptr, (void *)&ret) < 0)\\r\\n{ perror(\"getsockopt\"); ret = -1; }\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_SEND_TIMEOUT:\\r\\nif ( setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr,\\r\\nsizeof(struct timeval)) < 0)\\r\\n{ perror(\"setsockopt\"); ret = -1; }\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_SEND_TIMEOUT:\\r\\nif ( getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,\\r\\nptr, (void *)&ret) < 0)\\r\\n{ perror(\"getsockopt\"); ret = -1; }\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP:\\r\\ncase BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP:\\r\\nif ( data->_errno == EAGAIN)\\r\\n{\\r\\nret = 1;\\r\\ndata->_errno = 0;\\r\\n}\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\n#ifdef EMSGSIZE\\r\\ncase BIO_CTRL_DGRAM_MTU_EXCEEDED:\\r\\nif ( data->_errno == EMSGSIZE)\\r\\n{\\r\\nret = 1;\\r\\ndata->_errno = 0;\\r\\n}\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int dgram_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=dgram_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_dgram_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1))\\r\\n{\\r\\nerr=get_last_socket_error();\\r\\n#if defined(OPENSSL_SYS_WINDOWS) && 0\\r\\nif ((i == -1) && (err == 0))\\r\\nreturn(1);\\r\\n#endif\\r\\nreturn(BIO_dgram_non_fatal_error(err));\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BIO_dgram_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err)\\r\\n{\\r\\n#if defined(OPENSSL_SYS_WINDOWS)\\r\\n# if defined(WSAEWOULDBLOCK)\\r\\ncase WSAEWOULDBLOCK:\\r\\n# endif\\r\\n# if 0\\r\\n# if defined(WSAENOTCONN)\\r\\ncase WSAENOTCONN:\\r\\n# endif\\r\\n# endif\\r\\n#endif\\r\\n#ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n#endif\\r\\n#if defined(ENOTCONN)\\r\\ncase ENOTCONN:\\r\\n#endif\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\n#if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n#endif\\r\\n#ifdef EPROTO\\r\\ncase EPROTO:\\r\\n#endif\\r\\n#ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n#endif\\r\\n#ifdef EALREADY\\r\\ncase EALREADY:\\r\\n#endif\\r\\n#ifdef EMSGSIZE\\r\\ncase EMSGSIZE:\\r\\n#endif\\r\\nreturn(1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_verify_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint i,ret=1, badarg = 0;\\r\\nint purpose = -1;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nchar *untfile = NULL, *trustfile = NULL;\\r\\nSTACK_OF(X509) *untrusted = NULL, *trusted = NULL;\\r\\nX509_STORE *cert_ctx=NULL;\\r\\nX509_LOOKUP *lookup=NULL;\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\ncert_ctx=X509_STORE_new();\\r\\nif (cert_ctx == NULL) goto end;\\r\\nX509_STORE_set_verify_cb_func(cert_ctx,cb);\\r\\nERR_load_crypto_strings();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargc--;\\r\\nargv++;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\nelse if (args_verify(&argv, &argc, &badarg, bio_err,\\r\\n&vpm))\\r\\n{\\r\\nif (badarg)\\r\\ngoto end;\\r\\ncontinue;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-untrusted\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\nuntfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-trusted\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\ntrustfile= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto end;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-help\") == 0)\\r\\ngoto end;\\r\\nelse if (strcmp(*argv,\"-verbose\") == 0)\\r\\nv_verbose=1;\\r\\nelse if (argv[0][0] == '-')\\r\\ngoto end;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(cert_ctx, vpm);\\r\\nlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) abort();\\r\\nif (CAfile) {\\r\\ni=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM);\\r\\nif(!i) {\\r\\nBIO_printf(bio_err, \"Error loading file %s\\n\", CAfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) abort();\\r\\nif (CApath) {\\r\\ni=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM);\\r\\nif(!i) {\\r\\nBIO_printf(bio_err, \"Error loading directory %s\\n\", CApath);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nif(untfile) {\\r\\nif(!(untrusted = load_untrusted(untfile))) {\\r\\nBIO_printf(bio_err, \"Error loading untrusted file %s\\n\", untfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif(trustfile) {\\r\\nif(!(trusted = load_untrusted(trustfile))) {\\r\\nBIO_printf(bio_err, \"Error loading untrusted file %s\\n\", trustfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (argc < 1) check(cert_ctx, NULL, untrusted, trusted, purpose, e);\\r\\nelse\\r\\nfor (i=0; i<argc; i++)\\r\\ncheck(cert_ctx,argv[i], untrusted, trusted, purpose, e);\\r\\nret=0;\\r\\nend:\\r\\nif (ret == 1) {\\r\\nBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] [-crl_check]\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" [-engine e]\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" cert1 cert2 ...\\n\");\\r\\nBIO_printf(bio_err,\"recognized usages:\\n\");\\r\\nfor(i = 0; i < X509_PURPOSE_get_count(); i++) {\\r\\nX509_PURPOSE *ptmp;\\r\\nptmp = X509_PURPOSE_get0(i);\\r\\nBIO_printf(bio_err, \"\\t%-10s\\t%s\\n\", X509_PURPOSE_get0_sname(ptmp),\\r\\nX509_PURPOSE_get0_name(ptmp));\\r\\n}\\r\\n}\\r\\nif (vpm) X509_VERIFY_PARAM_free(vpm);\\r\\nif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\\r\\nsk_X509_pop_free(untrusted, X509_free);\\r\\nsk_X509_pop_free(trusted, X509_free);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nint MS_CALLBACK cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nif (!ok)\\r\\n{\\r\\nif (ctx->current_cert)\\r\\n{\\r\\nX509_NAME_oneline(\\r\\nX509_get_subject_name(ctx->current_cert),buf,\\r\\nsizeof buf);\\r\\nprintf(\"%s\\n\",buf);\\r\\n}\\r\\nprintf(\"error %d at %d depth lookup:%s\\n\",ctx->error,\\r\\nctx->error_depth,\\r\\nX509_verify_cert_error_string(ctx->error));\\r\\nif (ctx->error == X509_V_ERR_CERT_HAS_EXPIRED) ok=1;\\r\\nif (ctx->error == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) ok=1;\\r\\nif (ctx->error == X509_V_ERR_INVALID_CA) ok=1;\\r\\nif (ctx->error == X509_V_ERR_INVALID_NON_CA) ok=1;\\r\\nif (ctx->error == X509_V_ERR_PATH_LENGTH_EXCEEDED) ok=1;\\r\\nif (ctx->error == X509_V_ERR_INVALID_PURPOSE) ok=1;\\r\\nif (ctx->error == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) ok=1;\\r\\nif (ctx->error == X509_V_ERR_CRL_HAS_EXPIRED) ok=1;\\r\\nif (ctx->error == X509_V_ERR_CRL_NOT_YET_VALID) ok=1;\\r\\nif (ctx->error == X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION) ok=1;\\r\\nif (ctx->error == X509_V_ERR_NO_EXPLICIT_POLICY)\\r\\npolicies_print(NULL, ctx);\\r\\nreturn ok;\\r\\n}\\r\\nif ((ctx->error == X509_V_OK) && (ok == 2))\\r\\npolicies_print(NULL, ctx);\\r\\nif (!v_verbose)\\r\\nERR_clear_error();\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_cluster_labs_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\nif(!ENGINE_set_id(e, engine_cluster_labs_id) ||\\r\\n!ENGINE_set_name(e, engine_cluster_labs_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &cluster_labs_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &cluster_labs_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &cluster_labs_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &cluster_labs_rand) ||\\r\\n!ENGINE_set_destroy_function(e, cluster_labs_destroy) ||\\r\\n!ENGINE_set_init_function(e, cluster_labs_init) ||\\r\\n!ENGINE_set_finish_function(e, cluster_labs_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, cluster_labs_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, cluster_labs_cmd_defns))\\r\\nreturn 0;\\r\\nERR_load_CL_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_cluster_labs(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic\\r\\n#endif\\r\\nvoid ENGINE_load_cluster_labs(void)\\r\\n{\\r\\nENGINE *cluster_labs = engine_cluster_labs();\\r\\nif(!cluster_labs) return;\\r\\nENGINE_add(cluster_labs);\\r\\nENGINE_free(cluster_labs);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int cluster_labs_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_CL_strings();\\r\\nreturn 1;\\r\\n}\\r\\nint cluster_labs_init(ENGINE *e)\\r\\n{\\r\\ncl_engine_init *p1;\\r\\ncl_mod_exp *p2;\\r\\ncl_mod_exp_crt *p3;\\r\\ncl_rsa_mod_exp *p4;\\r\\ncl_rsa_priv_enc *p5;\\r\\ncl_rsa_priv_dec *p6;\\r\\ncl_rsa_pub_enc *p7;\\r\\ncl_rsa_pub_dec *p8;\\r\\ncl_rand_bytes *p20;\\r\\ncl_dsa_sign *p30;\\r\\ncl_dsa_verify *p31;\\r\\nif(cluster_labs_dso != NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_INIT,CL_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\ncluster_labs_dso = DSO_load(NULL, CLUSTER_LABS_LIB_NAME, NULL,0);\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_INIT,CL_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif( !(p1 = (cl_engine_init *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F1)) ||\\r\\n!(p2 = (cl_mod_exp *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F2)) ||\\r\\n!(p3 = (cl_mod_exp_crt *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F3)) ||\\r\\n!(p4 = (cl_rsa_mod_exp *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F4)) ||\\r\\n!(p5 = (cl_rsa_priv_enc *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F5)) ||\\r\\n!(p6 = (cl_rsa_priv_dec *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F6)) ||\\r\\n!(p7 = (cl_rsa_pub_enc *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F7)) ||\\r\\n!(p8 = (cl_rsa_pub_dec *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F8)) ||\\r\\n!(p20= (cl_rand_bytes *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F20)) ||\\r\\n!(p30= (cl_dsa_sign *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F30)) ||\\r\\n!(p31= (cl_dsa_verify *)DSO_bind_func(\\r\\ncluster_labs_dso, CLUSTER_LABS_F31)))\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_INIT,CL_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_cl_engine_init = p1;\\r\\np_cl_mod_exp = p2;\\r\\np_cl_mod_exp_crt = p3;\\r\\np_cl_rsa_mod_exp = p4;\\r\\np_cl_rsa_priv_enc = p5;\\r\\np_cl_rsa_priv_dec = p6;\\r\\np_cl_rsa_pub_enc = p7;\\r\\np_cl_rsa_pub_dec = p8;\\r\\np_cl_rand_bytes = p20;\\r\\np_cl_dsa_sign = p30;\\r\\np_cl_dsa_verify = p31;\\r\\nif(p_cl_engine_init()== 0){\\r\\nCLerr(CL_F_CLUSTER_LABS_INIT,CL_R_INIT_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nif(cluster_labs_dso)\\r\\nDSO_free(cluster_labs_dso);\\r\\ncluster_labs_dso = NULL;\\r\\np_cl_engine_init = NULL;\\r\\np_cl_mod_exp = NULL;\\r\\np_cl_mod_exp_crt = NULL;\\r\\np_cl_rsa_mod_exp = NULL;\\r\\np_cl_rsa_priv_enc = NULL;\\r\\np_cl_rsa_priv_dec = NULL;\\r\\np_cl_rsa_pub_enc = NULL;\\r\\np_cl_rsa_pub_dec = NULL;\\r\\np_cl_rand_bytes = NULL;\\r\\np_cl_dsa_sign = NULL;\\r\\np_cl_dsa_verify = NULL;\\r\\nreturn(0);\\r\\n}\\r\\nstatic int cluster_labs_finish(ENGINE *e)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_FINISH,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(cluster_labs_dso))\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_FINISH,CL_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ncluster_labs_dso = NULL;\\r\\np_cl_engine_init = NULL;\\r\\np_cl_mod_exp = NULL;\\r\\np_cl_rsa_mod_exp = NULL;\\r\\np_cl_mod_exp_crt = NULL;\\r\\np_cl_rsa_priv_enc = NULL;\\r\\np_cl_rsa_priv_dec = NULL;\\r\\np_cl_rsa_pub_enc = NULL;\\r\\np_cl_rsa_pub_dec = NULL;\\r\\np_cl_rand_bytes = NULL;\\r\\np_cl_dsa_sign = NULL;\\r\\np_cl_dsa_verify = NULL;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int cluster_labs_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())\\r\\n{\\r\\nint initialised = ((cluster_labs_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase CLUSTER_LABS_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_CTRL,CL_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nCLUSTER_LABS_LIB_NAME = (const char *)p;\\r\\nreturn 1;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCLerr(CL_F_CLUSTER_LABS_CTRL,CL_R_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int cluster_labs_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_MOD_EXP,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_mod_exp == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_MOD_EXP,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int cluster_labs_mod_exp_crt(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *q, const BIGNUM *dmp1, const BIGNUM *dmq1,\\r\\nconst BIGNUM *iqmp, BN_CTX *ctx)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_MOD_EXP_CRT,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_mod_exp_crt == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_MOD_EXP_CRT,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_mod_exp_crt(r, a, p, q,dmp1, dmq1, iqmp, ctx);\\r\\n}\\r\\nstatic int cluster_labs_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_MOD_EXP,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_rsa_mod_exp == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_MOD_EXP,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rsa_mod_exp(r0, I, rsa);\\r\\n}\\r\\nstatic DSA_SIG *cluster_labs_dsa_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_DSA_SIGN,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_dsa_sign == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_DSA_SIGN,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_dsa_sign(dgst, dlen, dsa);\\r\\n}\\r\\nstatic int cluster_labs_dsa_verify(const unsigned char *dgst, int dgst_len,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_DSA_VERIFY,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_dsa_verify == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_DSA_VERIFY,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_dsa_verify(dgst, dgst_len, sig, dsa);\\r\\n}\\r\\nstatic int cluster_labs_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\\r\\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBIGNUM t;\\r\\nint status = 0;\\r\\nBN_init(&t);\\r\\nif (!cluster_labs_mod_exp(rr,a1,p1,m,ctx)) goto end;\\r\\nif (!cluster_labs_mod_exp(&t,a2,p2,m,ctx)) goto end;\\r\\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\\r\\nstatus = 1;\\r\\nend:\\r\\nBN_free(&t);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int cluster_labs_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn cluster_labs_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int cluster_labs_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn cluster_labs_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int cluster_labs_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn cluster_labs_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int cluster_labs_rsa_pub_enc(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PUB_ENC,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_rsa_priv_enc == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PUB_ENC,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rsa_pub_enc(flen, from, to, rsa, padding);\\r\\n}\\r\\nstatic int cluster_labs_rsa_pub_dec(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PUB_DEC,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_rsa_priv_enc == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PUB_DEC,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rsa_pub_dec(flen, from, to, rsa, padding);\\r\\n}\\r\\nstatic int cluster_labs_rsa_priv_enc(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PRIV_ENC,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_rsa_priv_enc == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PRIV_ENC,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rsa_priv_enc(flen, from, to, rsa, padding);\\r\\n}\\r\\nstatic int cluster_labs_rsa_priv_dec(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PRIV_DEC,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_rsa_priv_dec == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RSA_PRIV_DEC,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rsa_priv_dec(flen, from, to, rsa, padding);\\r\\n}\\r\\nstatic int cluster_labs_rand_bytes(unsigned char *buf, int num){\\r\\nif(cluster_labs_dso == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RAND_BYTES,CL_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p_cl_mod_exp_crt == NULL)\\r\\n{\\r\\nCLerr(CL_F_CLUSTER_LABS_RAND_BYTES,CL_R_FUNCTION_NOT_BINDED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn p_cl_rand_bytes(buf, num);\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nfprintf(stderr, \"bind_fn CLUSTER_LABS\\n\");\\r\\nif(id && (strcmp(id, engine_cluster_labs_id) != 0)) {\\r\\nfprintf(stderr, \"bind_fn return(0) first\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nif(!bind_helper(e)) {\\r\\nfprintf(stderr, \"bind_fn return(1) first\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nfprintf(stderr, \"bind_fn return(1)\\n\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_pci_c", "target": 0, "func": "static int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\\r\\nBIO *out, int indent)\\r\\n{\\r\\nBIO_printf(out, \"%*sPath Length Constraint: \", indent, \"\");\\r\\nif (pci->pcPathLengthConstraint)\\r\\ni2a_ASN1_INTEGER(out, pci->pcPathLengthConstraint);\\r\\nelse\\r\\nBIO_printf(out, \"infinite\");\\r\\nBIO_puts(out, \"\\n\");\\r\\nBIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(out, pci->proxyPolicy->policyLanguage);\\r\\nBIO_puts(out, \"\\n\");\\r\\nif (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\\r\\nBIO_printf(out, \"%*sPolicy Text: %s\\n\", indent, \"\",\\r\\npci->proxyPolicy->policy->data);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int process_pci_value(CONF_VALUE *val,\\r\\nASN1_OBJECT **language, ASN1_INTEGER **pathlen,\\r\\nASN1_OCTET_STRING **policy)\\r\\n{\\r\\nint free_policy = 0;\\r\\nif (strcmp(val->name, \"language\") == 0)\\r\\n{\\r\\nif (*language)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,X509V3_R_POLICY_LANGUAGE_ALREADTY_DEFINED);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(*language = OBJ_txt2obj(val->value, 0)))\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,X509V3_R_INVALID_OBJECT_IDENTIFIER);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse if (strcmp(val->name, \"pathlen\") == 0)\\r\\n{\\r\\nif (*pathlen)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,X509V3_R_POLICY_PATH_LENGTH_ALREADTY_DEFINED);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nif (!X509V3_get_value_int(val, pathlen))\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,X509V3_R_POLICY_PATH_LENGTH);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse if (strcmp(val->name, \"policy\") == 0)\\r\\n{\\r\\nunsigned char *tmp_data = NULL;\\r\\nlong val_len;\\r\\nif (!*policy)\\r\\n{\\r\\n*policy = ASN1_OCTET_STRING_new();\\r\\nif (!*policy)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nfree_policy = 1;\\r\\n}\\r\\nif (strncmp(val->value, \"hex:\", 4) == 0)\\r\\n{\\r\\nunsigned char *tmp_data2 =\\r\\nstring_to_hex(val->value + 4, &val_len);\\r\\nif (!tmp_data2) goto err;\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + val_len + 1);\\r\\nif (tmp_data)\\r\\n{\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length],\\r\\ntmp_data2, val_len);\\r\\n(*policy)->length += val_len;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n}\\r\\n}\\r\\nelse if (strncmp(val->value, \"file:\", 5) == 0)\\r\\n{\\r\\nunsigned char buf[2048];\\r\\nint n;\\r\\nBIO *b = BIO_new_file(val->value + 5, \"r\");\\r\\nif (!b)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,ERR_R_BIO_LIB);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\nwhile((n = BIO_read(b, buf, sizeof(buf))) > 0\\r\\n|| (n == 0 && BIO_should_retry(b)))\\r\\n{\\r\\nif (!n) continue;\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + n + 1);\\r\\nif (!tmp_data)\\r\\nbreak;\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length],\\r\\nbuf, n);\\r\\n(*policy)->length += n;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n}\\r\\nif (n < 0)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,ERR_R_BIO_LIB);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse if (strncmp(val->value, \"text:\", 5) == 0)\\r\\n{\\r\\nval_len = strlen(val->value + 5);\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + val_len + 1);\\r\\nif (tmp_data)\\r\\n{\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length],\\r\\nval->value + 5, val_len);\\r\\n(*policy)->length += val_len;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,X509V3_R_INCORRECT_POLICY_SYNTAX_TAG);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\nif (!tmp_data)\\r\\n{\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (free_policy)\\r\\n{\\r\\nASN1_OCTET_STRING_free(*policy);\\r\\n*policy = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic PROXY_CERT_INFO_EXTENSION *r2i_pci(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *value)\\r\\n{\\r\\nPROXY_CERT_INFO_EXTENSION *pci = NULL;\\r\\nSTACK_OF(CONF_VALUE) *vals;\\r\\nASN1_OBJECT *language = NULL;\\r\\nASN1_INTEGER *pathlen = NULL;\\r\\nASN1_OCTET_STRING *policy = NULL;\\r\\nint i, j;\\r\\nvals = X509V3_parse_list(value);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(vals); i++)\\r\\n{\\r\\nCONF_VALUE *cnf = sk_CONF_VALUE_value(vals, i);\\r\\nif (!cnf->name || (*cnf->name != '@' && !cnf->value))\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,X509V3_R_INVALID_PROXY_POLICY_SETTING);\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\nif (*cnf->name == '@')\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *sect;\\r\\nint success_p = 1;\\r\\nsect = X509V3_get_section(ctx, cnf->name + 1);\\r\\nif (!sect)\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,X509V3_R_INVALID_SECTION);\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\nfor (j = 0; success_p && j < sk_CONF_VALUE_num(sect); j++)\\r\\n{\\r\\nsuccess_p =\\r\\nprocess_pci_value(sk_CONF_VALUE_value(sect, j),\\r\\n&language, &pathlen, &policy);\\r\\n}\\r\\nX509V3_section_free(ctx, sect);\\r\\nif (!success_p)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!process_pci_value(cnf,\\r\\n&language, &pathlen, &policy))\\r\\n{\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!language)\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,X509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED);\\r\\ngoto err;\\r\\n}\\r\\ni = OBJ_obj2nid(language);\\r\\nif ((i == NID_Independent || i == NID_id_ppl_inheritAll) && policy)\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,X509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY);\\r\\ngoto err;\\r\\n}\\r\\npci = PROXY_CERT_INFO_EXTENSION_new();\\r\\nif (!pci)\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npci->proxyPolicy = PROXY_POLICY_new();\\r\\nif (!pci->proxyPolicy)\\r\\n{\\r\\nX509V3err(X509V3_F_R2I_PCI,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npci->proxyPolicy->policyLanguage = language; language = NULL;\\r\\npci->proxyPolicy->policy = policy; policy = NULL;\\r\\npci->pcPathLengthConstraint = pathlen; pathlen = NULL;\\r\\ngoto end;\\r\\nerr:\\r\\nif (language) { ASN1_OBJECT_free(language); language = NULL; }\\r\\nif (pathlen) { ASN1_INTEGER_free(pathlen); pathlen = NULL; }\\r\\nif (policy) { ASN1_OCTET_STRING_free(policy); policy = NULL; }\\r\\nif (pci && pci->proxyPolicy)\\r\\n{\\r\\nPROXY_POLICY_free(pci->proxyPolicy);\\r\\npci->proxyPolicy = NULL;\\r\\n}\\r\\nif (pci) { PROXY_CERT_INFO_EXTENSION_free(pci); pci = NULL; }\\r\\nend:\\r\\nsk_CONF_VALUE_pop_free(vals, X509V3_conf_free);\\r\\nreturn pci;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_sess_c", "target": 0, "func": "SSL_SESSION *SSL_get_session(const SSL *ssl)\\r\\n{\\r\\nreturn(ssl->session);\\r\\n}\\r\\nSSL_SESSION *SSL_get1_session(SSL *ssl)\\r\\n{\\r\\nSSL_SESSION *sess;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_SESSION);\\r\\nsess = ssl->session;\\r\\nif(sess)\\r\\nsess->references++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_SESSION);\\r\\nreturn(sess);\\r\\n}\\r\\nint SSL_SESSION_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nSSL_SESSION *SSL_SESSION_new(void)\\r\\n{\\r\\nSSL_SESSION *ss;\\r\\nss=(SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));\\r\\nif (ss == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(ss,0,sizeof(SSL_SESSION));\\r\\nss->verify_result = 1;\\r\\nss->references=1;\\r\\nss->timeout=60*5+4;\\r\\nss->time=time(NULL);\\r\\nss->prev=NULL;\\r\\nss->next=NULL;\\r\\nss->compress_meth=0;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\\r\\nreturn(ss);\\r\\n}\\r\\nconst unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s, unsigned int *len)\\r\\n{\\r\\nif(len)\\r\\n*len = s->session_id_length;\\r\\nreturn s->session_id;\\r\\n}\\r\\nstatic int def_generate_session_id(const SSL *ssl, unsigned char *id,\\r\\nunsigned int *id_len)\\r\\n{\\r\\nunsigned int retry = 0;\\r\\ndo\\r\\nif (RAND_pseudo_bytes(id, *id_len) <= 0)\\r\\nreturn 0;\\r\\nwhile(SSL_has_matching_session_id(ssl, id, *id_len) &&\\r\\n(++retry < MAX_SESS_ID_ATTEMPTS));\\r\\nif(retry < MAX_SESS_ID_ATTEMPTS)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_get_new_session(SSL *s, int session)\\r\\n{\\r\\nunsigned int tmp;\\r\\nSSL_SESSION *ss=NULL;\\r\\nGEN_SESSION_CB cb = def_generate_session_id;\\r\\nif ((ss=SSL_SESSION_new()) == NULL) return(0);\\r\\nif (s->ctx->session_timeout == 0)\\r\\nss->timeout=SSL_get_default_timeout(s);\\r\\nelse\\r\\nss->timeout=s->ctx->session_timeout;\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\nif (session)\\r\\n{\\r\\nif (s->version == SSL2_VERSION)\\r\\n{\\r\\nss->ssl_version=SSL2_VERSION;\\r\\nss->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse if (s->version == SSL3_VERSION)\\r\\n{\\r\\nss->ssl_version=SSL3_VERSION;\\r\\nss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse if (s->version == TLS1_VERSION)\\r\\n{\\r\\nss->ssl_version=TLS1_VERSION;\\r\\nss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse if (s->version == DTLS1_VERSION)\\r\\n{\\r\\nss->ssl_version=DTLS1_VERSION;\\r\\nss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,SSL_R_UNSUPPORTED_SSL_VERSION);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif(s->generate_session_id)\\r\\ncb = s->generate_session_id;\\r\\nelse if(s->ctx->generate_session_id)\\r\\ncb = s->ctx->generate_session_id;\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\ntmp = ss->session_id_length;\\r\\nif(!cb(s, ss->session_id, &tmp))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,\\r\\nSSL_R_SSL_SESSION_ID_CALLBACK_FAILED);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn(0);\\r\\n}\\r\\nif(!tmp || (tmp > ss->session_id_length))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,\\r\\nSSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn(0);\\r\\n}\\r\\nif((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))\\r\\nmemset(ss->session_id + tmp, 0, ss->session_id_length - tmp);\\r\\nelse\\r\\nss->session_id_length = tmp;\\r\\nif(SSL_has_matching_session_id(s, ss->session_id,\\r\\nss->session_id_length))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,\\r\\nSSL_R_SSL_SESSION_ID_CONFLICT);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nss->session_id_length=0;\\r\\n}\\r\\nif (s->sid_ctx_length > sizeof ss->sid_ctx)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(ss->sid_ctx,s->sid_ctx,s->sid_ctx_length);\\r\\nss->sid_ctx_length=s->sid_ctx_length;\\r\\ns->session=ss;\\r\\nss->ssl_version=s->version;\\r\\nss->verify_result = X509_V_OK;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl_get_prev_session(SSL *s, unsigned char *session_id, int len)\\r\\n{\\r\\nSSL_SESSION *ret=NULL,data;\\r\\nint fatal = 0;\\r\\ndata.ssl_version=s->version;\\r\\ndata.session_id_length=len;\\r\\nif (len > SSL_MAX_SSL_SESSION_ID_LENGTH)\\r\\ngoto err;\\r\\nmemcpy(data.session_id,session_id,len);\\r\\nif (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))\\r\\n{\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nret=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,&data);\\r\\nif (ret != NULL)\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\n}\\r\\nif (ret == NULL)\\r\\n{\\r\\nint copy=1;\\r\\ns->ctx->stats.sess_miss++;\\r\\nret=NULL;\\r\\nif (s->ctx->get_session_cb != NULL\\r\\n&& (ret=s->ctx->get_session_cb(s,session_id,len,&copy))\\r\\n!= NULL)\\r\\n{\\r\\ns->ctx->stats.sess_cb_hit++;\\r\\nif (copy)\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nif(!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE))\\r\\nSSL_CTX_add_session(s->ctx,ret);\\r\\n}\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif((s->verify_mode&SSL_VERIFY_PEER)\\r\\n&& (!s->sid_ctx_length || ret->sid_ctx_length != s->sid_ctx_length\\r\\n|| memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length)))\\r\\n{\\r\\nif (s->sid_ctx_length == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\\r\\nfatal = 1;\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if 0\\r\\nSSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\\r\\n#endif\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ret->cipher == NULL)\\r\\n{\\r\\nunsigned char buf[5],*p;\\r\\nunsigned long l;\\r\\np=buf;\\r\\nl=ret->cipher_id;\\r\\nl2n(l,p);\\r\\nif ((ret->ssl_version>>8) == SSL3_VERSION_MAJOR)\\r\\nret->cipher=ssl_get_cipher_by_char(s,&(buf[2]));\\r\\nelse\\r\\nret->cipher=ssl_get_cipher_by_char(s,&(buf[1]));\\r\\nif (ret->cipher == NULL)\\r\\ngoto err;\\r\\n}\\r\\n#if 0\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\n#endif\\r\\nif ((long)(ret->time+ret->timeout) < (long)time(NULL))\\r\\n{\\r\\ns->ctx->stats.sess_timeout++;\\r\\nSSL_CTX_remove_session(s->ctx,ret);\\r\\ngoto err;\\r\\n}\\r\\ns->ctx->stats.sess_hit++;\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=ret;\\r\\ns->verify_result = s->session->verify_result;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nSSL_SESSION_free(ret);\\r\\nif (fatal)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nint ret=0;\\r\\nSSL_SESSION *s;\\r\\nCRYPTO_add(&c->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\ns=(SSL_SESSION *)lh_insert(ctx->sessions,c);\\r\\nif (s != NULL && s != c)\\r\\n{\\r\\nSSL_SESSION_list_remove(ctx,s);\\r\\nSSL_SESSION_free(s);\\r\\ns = NULL;\\r\\n}\\r\\nif (s == NULL)\\r\\nSSL_SESSION_list_add(ctx,c);\\r\\nif (s != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s);\\r\\nret=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=1;\\r\\nif (SSL_CTX_sess_get_cache_size(ctx) > 0)\\r\\n{\\r\\nwhile (SSL_CTX_sess_number(ctx) >\\r\\nSSL_CTX_sess_get_cache_size(ctx))\\r\\n{\\r\\nif (!remove_session_lock(ctx,\\r\\nctx->session_cache_tail, 0))\\r\\nbreak;\\r\\nelse\\r\\nctx->stats.sess_cache_full++;\\r\\n}\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nreturn remove_session_lock(ctx, c, 1);\\r\\n}\\r\\nstatic int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)\\r\\n{\\r\\nSSL_SESSION *r;\\r\\nint ret=0;\\r\\nif ((c != NULL) && (c->session_id_length != 0))\\r\\n{\\r\\nif(lck) CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif ((r = (SSL_SESSION *)lh_retrieve(ctx->sessions,c)) == c)\\r\\n{\\r\\nret=1;\\r\\nr=(SSL_SESSION *)lh_delete(ctx->sessions,c);\\r\\nSSL_SESSION_list_remove(ctx,c);\\r\\n}\\r\\nif(lck) CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ret)\\r\\n{\\r\\nr->not_resumable=1;\\r\\nif (ctx->remove_session_cb != NULL)\\r\\nctx->remove_session_cb(ctx,r);\\r\\nSSL_SESSION_free(r);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid SSL_SESSION_free(SSL_SESSION *ss)\\r\\n{\\r\\nint i;\\r\\nif(ss == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL_SESSION\",ss);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"SSL_SESSION_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\\r\\nOPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg);\\r\\nOPENSSL_cleanse(ss->master_key,sizeof ss->master_key);\\r\\nOPENSSL_cleanse(ss->session_id,sizeof ss->session_id);\\r\\nif (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);\\r\\nif (ss->peer != NULL) X509_free(ss->peer);\\r\\nif (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);\\r\\nOPENSSL_cleanse(ss,sizeof(*ss));\\r\\nOPENSSL_free(ss);\\r\\n}\\r\\nint SSL_set_session(SSL *s, SSL_SESSION *session)\\r\\n{\\r\\nint ret=0;\\r\\nSSL_METHOD *meth;\\r\\nif (session != NULL)\\r\\n{\\r\\nmeth=s->ctx->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL)\\r\\nmeth=s->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_SESSION,SSL_R_UNABLE_TO_FIND_SSL_METHOD);\\r\\nreturn(0);\\r\\n}\\r\\nif (meth != s->method)\\r\\n{\\r\\nif (!SSL_set_ssl_method(s,meth))\\r\\nreturn(0);\\r\\nif (s->ctx->session_timeout == 0)\\r\\nsession->timeout=SSL_get_default_timeout(s);\\r\\nelse\\r\\nsession->timeout=s->ctx->session_timeout;\\r\\n}\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (s->kssl_ctx && !s->kssl_ctx->client_princ &&\\r\\nsession->krb5_client_princ_len > 0)\\r\\n{\\r\\ns->kssl_ctx->client_princ = (char *)malloc(session->krb5_client_princ_len + 1);\\r\\nmemcpy(s->kssl_ctx->client_princ,session->krb5_client_princ,\\r\\nsession->krb5_client_princ_len);\\r\\ns->kssl_ctx->client_princ[session->krb5_client_princ_len] = '\\0';\\r\\n}\\r\\n#endif\\r\\nCRYPTO_add(&session->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=session;\\r\\ns->verify_result = s->session->verify_result;\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\nmeth=s->ctx->method;\\r\\nif (meth != s->method)\\r\\n{\\r\\nif (!SSL_set_ssl_method(s,meth))\\r\\nreturn(0);\\r\\n}\\r\\nret=1;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong SSL_SESSION_set_timeout(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\ns->timeout=t;\\r\\nreturn(1);\\r\\n}\\r\\nlong SSL_SESSION_get_timeout(const SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->timeout);\\r\\n}\\r\\nlong SSL_SESSION_get_time(const SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->time);\\r\\n}\\r\\nlong SSL_SESSION_set_time(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\ns->time=t;\\r\\nreturn(t);\\r\\n}\\r\\nlong SSL_CTX_set_timeout(SSL_CTX *s, long t)\\r\\n{\\r\\nlong l;\\r\\nif (s == NULL) return(0);\\r\\nl=s->session_timeout;\\r\\ns->session_timeout=t;\\r\\nreturn(l);\\r\\n}\\r\\nlong SSL_CTX_get_timeout(const SSL_CTX *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->session_timeout);\\r\\n}\\r\\nstatic void timeout(SSL_SESSION *s, TIMEOUT_PARAM *p)\\r\\n{\\r\\nif ((p->time == 0) || (p->time > (s->time+s->timeout)))\\r\\n{\\r\\nlh_delete(p->cache,s);\\r\\nSSL_SESSION_list_remove(p->ctx,s);\\r\\ns->not_resumable=1;\\r\\nif (p->ctx->remove_session_cb != NULL)\\r\\np->ctx->remove_session_cb(p->ctx,s);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n}\\r\\nstatic void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next == NULL) || (s->prev == NULL)) return;\\r\\nif (s->next == (SSL_SESSION *)&(ctx->session_cache_tail))\\r\\n{\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))\\r\\n{\\r\\nctx->session_cache_head=NULL;\\r\\nctx->session_cache_tail=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->session_cache_tail=s->prev;\\r\\ns->prev->next=(SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))\\r\\n{\\r\\nctx->session_cache_head=s->next;\\r\\ns->next->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->next->prev=s->prev;\\r\\ns->prev->next=s->next;\\r\\n}\\r\\n}\\r\\ns->prev=s->next=NULL;\\r\\n}\\r\\nstatic void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next != NULL) && (s->prev != NULL))\\r\\nSSL_SESSION_list_remove(ctx,s);\\r\\nif (ctx->session_cache_head == NULL)\\r\\n{\\r\\nctx->session_cache_head=s;\\r\\nctx->session_cache_tail=s;\\r\\ns->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\ns->next=(SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->next=ctx->session_cache_head;\\r\\ns->next->prev=s;\\r\\ns->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\nctx->session_cache_head=s;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conn_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nPROXY *pxy;\\r\\nchar *host;\\r\\nchar buf[1024*10],*p;\\r\\nBIO *bio;\\r\\nint i,len,off,ret=1;\\r\\nif (argc <= 1)\\r\\nhost=\"localhost:4433\";\\r\\nelse\\r\\nhost=argv[1];\\r\\nERR_load_crypto_strings();\\r\\npxy=PROXY_new();\\r\\nPROXY_add_server(pxy,PROXY_PROTOCOL_SOCKS,\"gromit:1080\");\\r\\nbio=BIO_new(BIO_s_socks4a_connect());\\r\\nBIO_set_conn_hostname(bio,host);\\r\\nBIO_set_proxies(bio,pxy);\\r\\nBIO_set_socks_userid(bio,\"eay\");\\r\\nBIO_set_nbio(bio,1);\\r\\np=\"GET / HTTP/1.0\\r\\n\\r\\n\";\\r\\nlen=strlen(p);\\r\\noff=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(bio,&(p[off]),len);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (BIO_should_retry(bio))\\r\\n{\\r\\nfprintf(stderr,\"write DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\noff+=i;\\r\\nlen-=i;\\r\\nif (len <= 0) break;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(bio,buf,sizeof(buf));\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nif (BIO_should_retry(bio))\\r\\n{\\r\\nfprintf(stderr,\"read DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf,1,i,stdout);\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ERR_peek_error() == 0)\\r\\n{\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"error\");\\r\\n}\\r\\nelse\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nBIO_free_all(bio);\\r\\nif (pxy != NULL) PROXY_free(pxy);\\r\\nexit(!ret);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dggccbug_c", "target": 0, "func": "void inc(a)\\r\\nint *a;\\r\\n{\\r\\n(*a)++;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nint p=0;\\r\\n#ifdef FIXBUG\\r\\nint dummy;\\r\\n#endif\\r\\nwhile (p<3)\\r\\n{\\r\\nfprintf(stderr,\"%08X\\n\",p);\\r\\ninc(&p);\\r\\n#ifdef FIXBUG\\r\\ndummy+=p;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_skey_c", "target": 0, "func": "char *i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,\\r\\nASN1_OCTET_STRING *oct)\\r\\n{\\r\\nreturn hex_to_string(oct->data, oct->length);\\r\\n}\\r\\nASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nlong length;\\r\\nif(!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(oct->data = string_to_hex(str, &length))) {\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}\\r\\noct->length = length;\\r\\nreturn oct;\\r\\n}\\r\\nstatic ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nASN1_BIT_STRING *pk;\\r\\nunsigned char pkey_dig[EVP_MAX_MD_SIZE];\\r\\nunsigned int diglen;\\r\\nif(strcmp(str, \"hash\")) return s2i_ASN1_OCTET_STRING(method, ctx, str);\\r\\nif(!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(ctx && (ctx->flags == CTX_TEST)) return oct;\\r\\nif(!ctx || (!ctx->subject_req && !ctx->subject_cert)) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID,X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif(ctx->subject_req)\\r\\npk = ctx->subject_req->req_info->pubkey->public_key;\\r\\nelse pk = ctx->subject_cert->cert_info->key->public_key;\\r\\nif(!pk) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID,X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nEVP_Digest(pk->data, pk->length, pkey_dig, &diglen, EVP_sha1(), NULL);\\r\\nif(!M_ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nreturn oct;\\r\\nerr:\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_sureware_err_c", "target": 0, "func": "static void ERR_load_SUREWARE_strings(void)\\r\\n{\\r\\nif (SUREWARE_lib_error_code == 0)\\r\\nSUREWARE_lib_error_code=ERR_get_next_error_library();\\r\\nif (SUREWARE_error_init)\\r\\n{\\r\\nSUREWARE_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(SUREWARE_lib_error_code,SUREWARE_str_functs);\\r\\nERR_load_strings(SUREWARE_lib_error_code,SUREWARE_str_reasons);\\r\\n#endif\\r\\n#ifdef SUREWARE_LIB_NAME\\r\\nSUREWARE_lib_name->error = ERR_PACK(SUREWARE_lib_error_code,0,0);\\r\\nERR_load_strings(0,SUREWARE_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_SUREWARE_strings(void)\\r\\n{\\r\\nif (SUREWARE_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(SUREWARE_lib_error_code,SUREWARE_str_functs);\\r\\nERR_unload_strings(SUREWARE_lib_error_code,SUREWARE_str_reasons);\\r\\n#endif\\r\\n#ifdef SUREWARE_LIB_NAME\\r\\nERR_unload_strings(0,SUREWARE_lib_name);\\r\\n#endif\\r\\nSUREWARE_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_SUREWARE_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (SUREWARE_lib_error_code == 0)\\r\\nSUREWARE_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(SUREWARE_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_asm_c", "target": 0, "func": "BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nassert(num >= 0);\\r\\nif (num <= 0) return(c1);\\r\\nwhile (num&~3)\\r\\n{\\r\\nmul_add(rp[0],ap[0],w,c1);\\r\\nmul_add(rp[1],ap[1],w,c1);\\r\\nmul_add(rp[2],ap[2],w,c1);\\r\\nmul_add(rp[3],ap[3],w,c1);\\r\\nap+=4; rp+=4; num-=4;\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nmul_add(rp[0],ap[0],w,c1); if (--num==0) return c1;\\r\\nmul_add(rp[1],ap[1],w,c1); if (--num==0) return c1;\\r\\nmul_add(rp[2],ap[2],w,c1); return c1;\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nassert(num >= 0);\\r\\nif (num <= 0) return(c1);\\r\\nwhile (num&~3)\\r\\n{\\r\\nmul(rp[0],ap[0],w,c1);\\r\\nmul(rp[1],ap[1],w,c1);\\r\\nmul(rp[2],ap[2],w,c1);\\r\\nmul(rp[3],ap[3],w,c1);\\r\\nap+=4; rp+=4; num-=4;\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nmul(rp[0],ap[0],w,c1); if (--num == 0) return c1;\\r\\nmul(rp[1],ap[1],w,c1); if (--num == 0) return c1;\\r\\nmul(rp[2],ap[2],w,c1);\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\\r\\n{\\r\\nassert(n >= 0);\\r\\nif (n <= 0) return;\\r\\nwhile (n&~3)\\r\\n{\\r\\nsqr(r[0],r[1],a[0]);\\r\\nsqr(r[2],r[3],a[1]);\\r\\nsqr(r[4],r[5],a[2]);\\r\\nsqr(r[6],r[7],a[3]);\\r\\na+=4; r+=8; n-=4;\\r\\n}\\r\\nif (n)\\r\\n{\\r\\nsqr(r[0],r[1],a[0]); if (--n == 0) return;\\r\\nsqr(r[2],r[3],a[1]); if (--n == 0) return;\\r\\nsqr(r[4],r[5],a[2]);\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c=0;\\r\\nBN_ULONG bl,bh;\\r\\nassert(num >= 0);\\r\\nif (num <= 0) return((BN_ULONG)0);\\r\\nbl=LBITS(w);\\r\\nbh=HBITS(w);\\r\\nfor (;;)\\r\\n{\\r\\nmul_add(rp[0],ap[0],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[1],ap[1],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[2],ap[2],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[3],ap[3],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(c);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG carry=0;\\r\\nBN_ULONG bl,bh;\\r\\nassert(num >= 0);\\r\\nif (num <= 0) return((BN_ULONG)0);\\r\\nbl=LBITS(w);\\r\\nbh=HBITS(w);\\r\\nfor (;;)\\r\\n{\\r\\nmul(rp[0],ap[0],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[1],ap[1],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[2],ap[2],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[3],ap[3],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(carry);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\\r\\n{\\r\\nassert(n >= 0);\\r\\nif (n <= 0) return;\\r\\nfor (;;)\\r\\n{\\r\\nsqr64(r[0],r[1],a[0]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[2],r[3],a[1]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[4],r[5],a[2]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[6],r[7],a[3]);\\r\\nif (--n == 0) break;\\r\\na+=4;\\r\\nr+=8;\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nreturn((BN_ULONG)(((((BN_ULLONG)h)<<BN_BITS2)|l)/(BN_ULLONG)d));\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nBN_ULONG dh,dl,q,ret=0,th,tl,t;\\r\\nint i,count=2;\\r\\nif (d == 0) return(BN_MASK2);\\r\\ni=BN_num_bits_word(d);\\r\\nassert((i == BN_BITS2) || (h <= (BN_ULONG)1<<i));\\r\\ni=BN_BITS2-i;\\r\\nif (h >= d) h-=d;\\r\\nif (i)\\r\\n{\\r\\nd<<=i;\\r\\nh=(h<<i)|(l>>(BN_BITS2-i));\\r\\nl<<=i;\\r\\n}\\r\\ndh=(d&BN_MASK2h)>>BN_BITS4;\\r\\ndl=(d&BN_MASK2l);\\r\\nfor (;;)\\r\\n{\\r\\nif ((h>>BN_BITS4) == dh)\\r\\nq=BN_MASK2l;\\r\\nelse\\r\\nq=h/dh;\\r\\nth=q*dh;\\r\\ntl=dl*q;\\r\\nfor (;;)\\r\\n{\\r\\nt=h-th;\\r\\nif ((t&BN_MASK2h) ||\\r\\n((tl) <= (\\r\\n(t<<BN_BITS4)|\\r\\n((l&BN_MASK2h)>>BN_BITS4))))\\r\\nbreak;\\r\\nq--;\\r\\nth-=dh;\\r\\ntl-=dl;\\r\\n}\\r\\nt=(tl>>BN_BITS4);\\r\\ntl=(tl<<BN_BITS4)&BN_MASK2h;\\r\\nth+=t;\\r\\nif (l < tl) th++;\\r\\nl-=tl;\\r\\nif (h < th)\\r\\n{\\r\\nh+=d;\\r\\nq--;\\r\\n}\\r\\nh-=th;\\r\\nif (--count == 0) break;\\r\\nret=q<<BN_BITS4;\\r\\nh=((h<<BN_BITS4)|(l>>BN_BITS4))&BN_MASK2;\\r\\nl=(l&BN_MASK2l)<<BN_BITS4;\\r\\n}\\r\\nret|=q;\\r\\nreturn(ret);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULLONG ll=0;\\r\\nassert(n >= 0);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nfor (;;)\\r\\n{\\r\\nll+=(BN_ULLONG)a[0]+b[0];\\r\\nr[0]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[1]+b[1];\\r\\nr[1]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[2]+b[2];\\r\\nr[2]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[3]+b[3];\\r\\nr[3]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn((BN_ULONG)ll);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG c,l,t;\\r\\nassert(n >= 0);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nc=0;\\r\\nfor (;;)\\r\\n{\\r\\nt=a[0];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[0])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[0]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[1];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[1])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[1]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[2];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[2])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[2]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[3];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[3])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[3]=l;\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn((BN_ULONG)c);\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nint c=0;\\r\\nassert(n >= 0);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nfor (;;)\\r\\n{\\r\\nt1=a[0]; t2=b[0];\\r\\nr[0]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[1]; t2=b[1];\\r\\nr[1]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[2]; t2=b[2];\\r\\nr[2]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[3]; t2=b[3];\\r\\nr[3]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn(c);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[4],b[0],c2,c3,c1);\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nmul_add_c(a[0],b[4],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[0],b[5],c3,c1,c2);\\r\\nmul_add_c(a[1],b[4],c3,c1,c2);\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nmul_add_c(a[4],b[1],c3,c1,c2);\\r\\nmul_add_c(a[5],b[0],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[6],b[0],c1,c2,c3);\\r\\nmul_add_c(a[5],b[1],c1,c2,c3);\\r\\nmul_add_c(a[4],b[2],c1,c2,c3);\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nmul_add_c(a[2],b[4],c1,c2,c3);\\r\\nmul_add_c(a[1],b[5],c1,c2,c3);\\r\\nmul_add_c(a[0],b[6],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[7],c2,c3,c1);\\r\\nmul_add_c(a[1],b[6],c2,c3,c1);\\r\\nmul_add_c(a[2],b[5],c2,c3,c1);\\r\\nmul_add_c(a[3],b[4],c2,c3,c1);\\r\\nmul_add_c(a[4],b[3],c2,c3,c1);\\r\\nmul_add_c(a[5],b[2],c2,c3,c1);\\r\\nmul_add_c(a[6],b[1],c2,c3,c1);\\r\\nmul_add_c(a[7],b[0],c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[1],c3,c1,c2);\\r\\nmul_add_c(a[6],b[2],c3,c1,c2);\\r\\nmul_add_c(a[5],b[3],c3,c1,c2);\\r\\nmul_add_c(a[4],b[4],c3,c1,c2);\\r\\nmul_add_c(a[3],b[5],c3,c1,c2);\\r\\nmul_add_c(a[2],b[6],c3,c1,c2);\\r\\nmul_add_c(a[1],b[7],c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[2],b[7],c1,c2,c3);\\r\\nmul_add_c(a[3],b[6],c1,c2,c3);\\r\\nmul_add_c(a[4],b[5],c1,c2,c3);\\r\\nmul_add_c(a[5],b[4],c1,c2,c3);\\r\\nmul_add_c(a[6],b[3],c1,c2,c3);\\r\\nmul_add_c(a[7],b[2],c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[7],b[3],c2,c3,c1);\\r\\nmul_add_c(a[6],b[4],c2,c3,c1);\\r\\nmul_add_c(a[5],b[5],c2,c3,c1);\\r\\nmul_add_c(a[4],b[6],c2,c3,c1);\\r\\nmul_add_c(a[3],b[7],c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[4],b[7],c3,c1,c2);\\r\\nmul_add_c(a[5],b[6],c3,c1,c2);\\r\\nmul_add_c(a[6],b[5],c3,c1,c2);\\r\\nmul_add_c(a[7],b[4],c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[7],b[5],c1,c2,c3);\\r\\nmul_add_c(a[6],b[6],c1,c2,c3);\\r\\nmul_add_c(a[5],b[7],c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[6],b[7],c2,c3,c1);\\r\\nmul_add_c(a[7],b[6],c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[7],c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t,tt;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nsqr_add_c2(a,4,0,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,5,0,c3,c1,c2);\\r\\nsqr_add_c2(a,4,1,c3,c1,c2);\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nsqr_add_c2(a,4,2,c1,c2,c3);\\r\\nsqr_add_c2(a,5,1,c1,c2,c3);\\r\\nsqr_add_c2(a,6,0,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,0,c2,c3,c1);\\r\\nsqr_add_c2(a,6,1,c2,c3,c1);\\r\\nsqr_add_c2(a,5,2,c2,c3,c1);\\r\\nsqr_add_c2(a,4,3,c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,4,c3,c1,c2);\\r\\nsqr_add_c2(a,5,3,c3,c1,c2);\\r\\nsqr_add_c2(a,6,2,c3,c1,c2);\\r\\nsqr_add_c2(a,7,1,c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,7,2,c1,c2,c3);\\r\\nsqr_add_c2(a,6,3,c1,c2,c3);\\r\\nsqr_add_c2(a,5,4,c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,5,c2,c3,c1);\\r\\nsqr_add_c2(a,6,4,c2,c3,c1);\\r\\nsqr_add_c2(a,7,3,c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,7,4,c3,c1,c2);\\r\\nsqr_add_c2(a,6,5,c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,6,c1,c2,c3);\\r\\nsqr_add_c2(a,7,5,c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,6,c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,7,c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t,tt;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(r,a,4,t);\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(r,a,8,t);\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[4]=bn_mul_words( &(r[0]),a,4,b[0]);\\r\\nr[5]=bn_mul_add_words(&(r[1]),a,4,b[1]);\\r\\nr[6]=bn_mul_add_words(&(r[2]),a,4,b[2]);\\r\\nr[7]=bn_mul_add_words(&(r[3]),a,4,b[3]);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[ 8]=bn_mul_words( &(r[0]),a,8,b[0]);\\r\\nr[ 9]=bn_mul_add_words(&(r[1]),a,8,b[1]);\\r\\nr[10]=bn_mul_add_words(&(r[2]),a,8,b[2]);\\r\\nr[11]=bn_mul_add_words(&(r[3]),a,8,b[3]);\\r\\nr[12]=bn_mul_add_words(&(r[4]),a,8,b[4]);\\r\\nr[13]=bn_mul_add_words(&(r[5]),a,8,b[5]);\\r\\nr[14]=bn_mul_add_words(&(r[6]),a,8,b[6]);\\r\\nr[15]=bn_mul_add_words(&(r[7]),a,8,b[7]);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_err_c", "target": 0, "func": "void ERR_load_ENGINE_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,ENGINE_str_functs);\\r\\nERR_load_strings(0,ENGINE_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_bitstr_c", "target": 0, "func": "int ASN1_BIT_STRING_set(ASN1_BIT_STRING *x, unsigned char *d, int len)\\r\\n{ return M_ASN1_BIT_STRING_set(x, d, len); }\\r\\nint i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp)\\r\\n{\\r\\nint ret,j,bits,len;\\r\\nunsigned char *p,*d;\\r\\nif (a == NULL) return(0);\\r\\nlen=a->length;\\r\\nif (len > 0)\\r\\n{\\r\\nif (a->flags & ASN1_STRING_FLAG_BITS_LEFT)\\r\\n{\\r\\nbits=(int)a->flags&0x07;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor ( ; len > 0; len--)\\r\\n{\\r\\nif (a->data[len-1]) break;\\r\\n}\\r\\nj=a->data[len-1];\\r\\nif (j & 0x01) bits=0;\\r\\nelse if (j & 0x02) bits=1;\\r\\nelse if (j & 0x04) bits=2;\\r\\nelse if (j & 0x08) bits=3;\\r\\nelse if (j & 0x10) bits=4;\\r\\nelse if (j & 0x20) bits=5;\\r\\nelse if (j & 0x40) bits=6;\\r\\nelse if (j & 0x80) bits=7;\\r\\nelse bits=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbits=0;\\r\\nret=1+len;\\r\\nif (pp == NULL) return(ret);\\r\\np= *pp;\\r\\n*(p++)=(unsigned char)bits;\\r\\nd=a->data;\\r\\nmemcpy(p,d,len);\\r\\np+=len;\\r\\nif (len > 0) p[-1]&=(0xff<<bits);\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\n}\\r\\nASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,\\r\\nconst unsigned char **pp, long len)\\r\\n{\\r\\nASN1_BIT_STRING *ret=NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *s;\\r\\nint i;\\r\\nif (len < 1)\\r\\n{\\r\\ni=ASN1_R_STRING_TOO_SHORT;\\r\\ngoto err;\\r\\n}\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=M_ASN1_BIT_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ni= *(p++);\\r\\nret->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nret->flags|=(ASN1_STRING_FLAG_BITS_LEFT|(i&0x07));\\r\\nif (len-- > 1)\\r\\n{\\r\\ns=(unsigned char *)OPENSSL_malloc((int)len);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\ns[len-1]&=(0xff<<i);\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nret->length=(int)len;\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\nret->data=s;\\r\\nret->type=V_ASN1_BIT_STRING;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_BIT_STRING,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_BIT_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)\\r\\n{\\r\\nint w,v,iv;\\r\\nunsigned char *c;\\r\\nw=n/8;\\r\\nv=1<<(7-(n&0x07));\\r\\niv= ~v;\\r\\nif (!value) v=0;\\r\\na->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nif (a == NULL) return(0);\\r\\nif ((a->length < (w+1)) || (a->data == NULL))\\r\\n{\\r\\nif (!value) return(1);\\r\\nif (a->data == NULL)\\r\\nc=(unsigned char *)OPENSSL_malloc(w+1);\\r\\nelse\\r\\nc=(unsigned char *)OPENSSL_realloc_clean(a->data,\\r\\na->length,\\r\\nw+1);\\r\\nif (c == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_BIT_STRING_SET_BIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (w+1-a->length > 0) memset(c+a->length, 0, w+1-a->length);\\r\\na->data=c;\\r\\na->length=w+1;\\r\\n}\\r\\na->data[w]=((a->data[w])&iv)|v;\\r\\nwhile ((a->length > 0) && (a->data[a->length-1] == 0))\\r\\na->length--;\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)\\r\\n{\\r\\nint w,v;\\r\\nw=n/8;\\r\\nv=1<<(7-(n&0x07));\\r\\nif ((a == NULL) || (a->length < (w+1)) || (a->data == NULL))\\r\\nreturn(0);\\r\\nreturn((a->data[w]&v) != 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_old_c", "target": 0, "func": "const EVP_CIPHER *EVP_bf_cfb(void) { return EVP_bf_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_des_cfb(void) { return EVP_des_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_des_ede3_cfb(void) { return EVP_des_ede3_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_des_ede_cfb(void) { return EVP_des_ede_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_idea_cfb(void) { return EVP_idea_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_rc2_cfb(void) { return EVP_rc2_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_cast5_cfb(void) { return EVP_cast5_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_rc5_32_12_16_cfb(void) { return EVP_rc5_32_12_16_cfb64(); }\\r\\nconst EVP_CIPHER *EVP_aes_128_cfb(void) { return EVP_aes_128_cfb128(); }\\r\\nconst EVP_CIPHER *EVP_aes_192_cfb(void) { return EVP_aes_192_cfb128(); }\\r\\nconst EVP_CIPHER *EVP_aes_256_cfb(void) { return EVP_aes_256_cfb128(); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_lib_c", "target": 0, "func": "EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)\\r\\n{\\r\\nEC_GROUP *ret;\\r\\nif (meth == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (meth->group_init == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn NULL;\\r\\n}\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = meth;\\r\\nret->extra_data = NULL;\\r\\nret->generator = NULL;\\r\\nBN_init(&ret->order);\\r\\nBN_init(&ret->cofactor);\\r\\nret->curve_name = 0;\\r\\nret->asn1_flag = 0;\\r\\nret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nret->seed = NULL;\\r\\nret->seed_len = 0;\\r\\nif (!meth->group_init(ret))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_GROUP_free(EC_GROUP *group)\\r\\n{\\r\\nif (!group) return;\\r\\nif (group->meth->group_finish != 0)\\r\\ngroup->meth->group_finish(group);\\r\\nEC_EX_DATA_free_all_data(&group->extra_data);\\r\\nif (group->generator != NULL)\\r\\nEC_POINT_free(group->generator);\\r\\nBN_free(&group->order);\\r\\nBN_free(&group->cofactor);\\r\\nif (group->seed)\\r\\nOPENSSL_free(group->seed);\\r\\nOPENSSL_free(group);\\r\\n}\\r\\nvoid EC_GROUP_clear_free(EC_GROUP *group)\\r\\n{\\r\\nif (!group) return;\\r\\nif (group->meth->group_clear_finish != 0)\\r\\ngroup->meth->group_clear_finish(group);\\r\\nelse if (group->meth != NULL && group->meth->group_finish != 0)\\r\\ngroup->meth->group_finish(group);\\r\\nEC_EX_DATA_clear_free_all_data(&group->extra_data);\\r\\nif (group->generator != NULL)\\r\\nEC_POINT_clear_free(group->generator);\\r\\nBN_clear_free(&group->order);\\r\\nBN_clear_free(&group->cofactor);\\r\\nif (group->seed)\\r\\n{\\r\\nOPENSSL_cleanse(group->seed, group->seed_len);\\r\\nOPENSSL_free(group->seed);\\r\\n}\\r\\nOPENSSL_cleanse(group, sizeof *group);\\r\\nOPENSSL_free(group);\\r\\n}\\r\\nint EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (dest->meth->group_copy == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest->meth != src->meth)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest == src)\\r\\nreturn 1;\\r\\nEC_EX_DATA_free_all_data(&dest->extra_data);\\r\\nfor (d = src->extra_data; d != NULL; d = d->next)\\r\\n{\\r\\nvoid *t = d->dup_func(d->data);\\r\\nif (t == NULL)\\r\\nreturn 0;\\r\\nif (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func))\\r\\nreturn 0;\\r\\n}\\r\\nif (src->generator != NULL)\\r\\n{\\r\\nif (dest->generator == NULL)\\r\\n{\\r\\ndest->generator = EC_POINT_new(dest);\\r\\nif (dest->generator == NULL) return 0;\\r\\n}\\r\\nif (!EC_POINT_copy(dest->generator, src->generator)) return 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (dest->generator != NULL)\\r\\n{\\r\\nEC_POINT_clear_free(dest->generator);\\r\\ndest->generator = NULL;\\r\\n}\\r\\n}\\r\\nif (!BN_copy(&dest->order, &src->order)) return 0;\\r\\nif (!BN_copy(&dest->cofactor, &src->cofactor)) return 0;\\r\\ndest->curve_name = src->curve_name;\\r\\ndest->asn1_flag = src->asn1_flag;\\r\\ndest->asn1_form = src->asn1_form;\\r\\nif (src->seed)\\r\\n{\\r\\nif (dest->seed)\\r\\nOPENSSL_free(dest->seed);\\r\\ndest->seed = OPENSSL_malloc(src->seed_len);\\r\\nif (dest->seed == NULL)\\r\\nreturn 0;\\r\\nif (!memcpy(dest->seed, src->seed, src->seed_len))\\r\\nreturn 0;\\r\\ndest->seed_len = src->seed_len;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (dest->seed)\\r\\nOPENSSL_free(dest->seed);\\r\\ndest->seed = NULL;\\r\\ndest->seed_len = 0;\\r\\n}\\r\\nreturn dest->meth->group_copy(dest, src);\\r\\n}\\r\\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *a)\\r\\n{\\r\\nEC_GROUP *t = NULL;\\r\\nint ok = 0;\\r\\nif (a == NULL) return NULL;\\r\\nif ((t = EC_GROUP_new(a->meth)) == NULL) return(NULL);\\r\\nif (!EC_GROUP_copy(t, a)) goto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nif (t) EC_GROUP_free(t);\\r\\nreturn NULL;\\r\\n}\\r\\nelse return t;\\r\\n}\\r\\nconst EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->meth;\\r\\n}\\r\\nint EC_METHOD_get_field_type(const EC_METHOD *meth)\\r\\n{\\r\\nreturn meth->field_type;\\r\\n}\\r\\nint EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)\\r\\n{\\r\\nif (generator == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0 ;\\r\\n}\\r\\nif (group->generator == NULL)\\r\\n{\\r\\ngroup->generator = EC_POINT_new(group);\\r\\nif (group->generator == NULL) return 0;\\r\\n}\\r\\nif (!EC_POINT_copy(group->generator, generator)) return 0;\\r\\nif (order != NULL)\\r\\n{ if (!BN_copy(&group->order, order)) return 0; }\\r\\nelse\\r\\nBN_zero(&group->order);\\r\\nif (cofactor != NULL)\\r\\n{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }\\r\\nelse\\r\\nBN_zero(&group->cofactor);\\r\\nreturn 1;\\r\\n}\\r\\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->generator;\\r\\n}\\r\\nint EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(order, &group->order))\\r\\nreturn 0;\\r\\nreturn !BN_is_zero(order);\\r\\n}\\r\\nint EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(cofactor, &group->cofactor))\\r\\nreturn 0;\\r\\nreturn !BN_is_zero(&group->cofactor);\\r\\n}\\r\\nvoid EC_GROUP_set_curve_name(EC_GROUP *group, int nid)\\r\\n{\\r\\ngroup->curve_name = nid;\\r\\n}\\r\\nint EC_GROUP_get_curve_name(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->curve_name;\\r\\n}\\r\\nvoid EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag)\\r\\n{\\r\\ngroup->asn1_flag = flag;\\r\\n}\\r\\nint EC_GROUP_get_asn1_flag(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->asn1_flag;\\r\\n}\\r\\nvoid EC_GROUP_set_point_conversion_form(EC_GROUP *group,\\r\\npoint_conversion_form_t form)\\r\\n{\\r\\ngroup->asn1_form = form;\\r\\n}\\r\\npoint_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->asn1_form;\\r\\n}\\r\\nsize_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)\\r\\n{\\r\\nif (group->seed)\\r\\n{\\r\\nOPENSSL_free(group->seed);\\r\\ngroup->seed = NULL;\\r\\ngroup->seed_len = 0;\\r\\n}\\r\\nif (!len || !p)\\r\\nreturn 1;\\r\\nif ((group->seed = OPENSSL_malloc(len)) == NULL)\\r\\nreturn 0;\\r\\nmemcpy(group->seed, p, len);\\r\\ngroup->seed_len = len;\\r\\nreturn len;\\r\\n}\\r\\nunsigned char *EC_GROUP_get0_seed(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->seed;\\r\\n}\\r\\nsize_t EC_GROUP_get_seed_len(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->seed_len;\\r\\n}\\r\\nint EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_set_curve == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_SET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_set_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_get_curve == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_GET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_set_curve == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_SET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_set_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_get_curve == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_GET_CURVE_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nif (group->meth->group_get_degree == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_degree(group);\\r\\n}\\r\\nint EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_check_discriminant == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK_DISCRIMINANT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_check_discriminant(group, ctx);\\r\\n}\\r\\nint EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)\\r\\n{\\r\\nint r = 0;\\r\\nBIGNUM *a1, *a2, *a3, *b1, *b2, *b3;\\r\\nBN_CTX *ctx_new = NULL;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=\\r\\nEC_METHOD_get_field_type(EC_GROUP_method_of(b)))\\r\\nreturn 1;\\r\\nif (EC_GROUP_get_curve_name(a) && EC_GROUP_get_curve_name(b) &&\\r\\nEC_GROUP_get_curve_name(a) == EC_GROUP_get_curve_name(b))\\r\\nreturn 0;\\r\\nif (!ctx)\\r\\nctx_new = ctx = BN_CTX_new();\\r\\nif (!ctx)\\r\\nreturn -1;\\r\\nBN_CTX_start(ctx);\\r\\na1 = BN_CTX_get(ctx);\\r\\na2 = BN_CTX_get(ctx);\\r\\na3 = BN_CTX_get(ctx);\\r\\nb1 = BN_CTX_get(ctx);\\r\\nb2 = BN_CTX_get(ctx);\\r\\nb3 = BN_CTX_get(ctx);\\r\\nif (!b3)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn -1;\\r\\n}\\r\\nif (!a->meth->group_get_curve(a, a1, a2, a3, ctx) ||\\r\\n!b->meth->group_get_curve(b, b1, b2, b3, ctx))\\r\\nr = 1;\\r\\nif (r || BN_cmp(a1, b1) || BN_cmp(a2, b2) || BN_cmp(a3, b3))\\r\\nr = 1;\\r\\nif (r || EC_POINT_cmp(a, EC_GROUP_get0_generator(a),\\r\\nEC_GROUP_get0_generator(b), ctx))\\r\\nr = 1;\\r\\nif (!r)\\r\\n{\\r\\nif (!EC_GROUP_get_order(a, a1, ctx) ||\\r\\n!EC_GROUP_get_order(b, b1, ctx) ||\\r\\n!EC_GROUP_get_cofactor(a, a2, ctx) ||\\r\\n!EC_GROUP_get_cofactor(b, b2, ctx))\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn -1;\\r\\n}\\r\\nif (BN_cmp(a1, b1) || BN_cmp(a2, b2))\\r\\nr = 1;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn r;\\r\\n}\\r\\nint EC_EX_DATA_set_data(EC_EXTRA_DATA **ex_data, void *data,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn 0;\\r\\nfor (d = *ex_data; d != NULL; d = d->next)\\r\\n{\\r\\nif (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_SET_EXTRA_DATA, EC_R_SLOT_FULL);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (data == NULL)\\r\\nreturn 1;\\r\\nd = OPENSSL_malloc(sizeof *d);\\r\\nif (d == NULL)\\r\\nreturn 0;\\r\\nd->data = data;\\r\\nd->dup_func = dup_func;\\r\\nd->free_func = free_func;\\r\\nd->clear_free_func = clear_free_func;\\r\\nd->next = *ex_data;\\r\\n*ex_data = d;\\r\\nreturn 1;\\r\\n}\\r\\nvoid *EC_EX_DATA_get_data(const EC_EXTRA_DATA *ex_data,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nconst EC_EXTRA_DATA *d;\\r\\nfor (d = ex_data; d != NULL; d = d->next)\\r\\n{\\r\\nif (d->dup_func == dup_func && d->free_func == free_func && d->clear_free_func == clear_free_func)\\r\\nreturn d->data;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid EC_EX_DATA_free_data(EC_EXTRA_DATA **ex_data,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nEC_EXTRA_DATA **p;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nfor (p = ex_data; *p != NULL; p = &((*p)->next))\\r\\n{\\r\\nif ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)\\r\\n{\\r\\nEC_EXTRA_DATA *next = (*p)->next;\\r\\n(*p)->free_func((*p)->data);\\r\\nOPENSSL_free(*p);\\r\\n*p = next;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid EC_EX_DATA_clear_free_data(EC_EXTRA_DATA **ex_data,\\r\\nvoid *(*dup_func)(void *), void (*free_func)(void *), void (*clear_free_func)(void *))\\r\\n{\\r\\nEC_EXTRA_DATA **p;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nfor (p = ex_data; *p != NULL; p = &((*p)->next))\\r\\n{\\r\\nif ((*p)->dup_func == dup_func && (*p)->free_func == free_func && (*p)->clear_free_func == clear_free_func)\\r\\n{\\r\\nEC_EXTRA_DATA *next = (*p)->next;\\r\\n(*p)->clear_free_func((*p)->data);\\r\\nOPENSSL_free(*p);\\r\\n*p = next;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid EC_EX_DATA_free_all_data(EC_EXTRA_DATA **ex_data)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nd = *ex_data;\\r\\nwhile (d)\\r\\n{\\r\\nEC_EXTRA_DATA *next = d->next;\\r\\nd->free_func(d->data);\\r\\nOPENSSL_free(d);\\r\\nd = next;\\r\\n}\\r\\n*ex_data = NULL;\\r\\n}\\r\\nvoid EC_EX_DATA_clear_free_all_data(EC_EXTRA_DATA **ex_data)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nd = *ex_data;\\r\\nwhile (d)\\r\\n{\\r\\nEC_EXTRA_DATA *next = d->next;\\r\\nd->clear_free_func(d->data);\\r\\nOPENSSL_free(d);\\r\\nd = next;\\r\\n}\\r\\n*ex_data = NULL;\\r\\n}\\r\\nEC_POINT *EC_POINT_new(const EC_GROUP *group)\\r\\n{\\r\\nEC_POINT *ret;\\r\\nif (group == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (group->meth->point_init == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn NULL;\\r\\n}\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = group->meth;\\r\\nif (!ret->meth->point_init(ret))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_POINT_free(EC_POINT *point)\\r\\n{\\r\\nif (!point) return;\\r\\nif (point->meth->point_finish != 0)\\r\\npoint->meth->point_finish(point);\\r\\nOPENSSL_free(point);\\r\\n}\\r\\nvoid EC_POINT_clear_free(EC_POINT *point)\\r\\n{\\r\\nif (!point) return;\\r\\nif (point->meth->point_clear_finish != 0)\\r\\npoint->meth->point_clear_finish(point);\\r\\nelse if (point->meth != NULL && point->meth->point_finish != 0)\\r\\npoint->meth->point_finish(point);\\r\\nOPENSSL_cleanse(point, sizeof *point);\\r\\nOPENSSL_free(point);\\r\\n}\\r\\nint EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (dest->meth->point_copy == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest->meth != src->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_COPY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest == src)\\r\\nreturn 1;\\r\\nreturn dest->meth->point_copy(dest, src);\\r\\n}\\r\\nEC_POINT *EC_POINT_dup(const EC_POINT *a, const EC_GROUP *group)\\r\\n{\\r\\nEC_POINT *t;\\r\\nint r;\\r\\nif (a == NULL) return NULL;\\r\\nt = EC_POINT_new(group);\\r\\nif (t == NULL) return(NULL);\\r\\nr = EC_POINT_copy(t, a);\\r\\nif (!r)\\r\\n{\\r\\nEC_POINT_free(t);\\r\\nreturn NULL;\\r\\n}\\r\\nelse return t;\\r\\n}\\r\\nconst EC_METHOD *EC_POINT_method_of(const EC_POINT *point)\\r\\n{\\r\\nreturn point->meth;\\r\\n}\\r\\nint EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point)\\r\\n{\\r\\nif (group->meth->point_set_to_infinity == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_TO_INFINITY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_TO_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_to_infinity(group, point);\\r\\n}\\r\\nint EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_Jprojective_coordinates_GFp == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);\\r\\n}\\r\\nint EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_Jprojective_coordinates_GFp == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);\\r\\n}\\r\\nint EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_affine_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_affine_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_affine_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_affine_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, int y_bit, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_compressed_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);\\r\\n}\\r\\nint EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, int y_bit, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_compressed_coordinates == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_compressed_coordinates(group, point, x, y_bit, ctx);\\r\\n}\\r\\nsize_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point, point_conversion_form_t form,\\r\\nunsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point2oct == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_POINT2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_POINT2OCT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point2oct(group, point, form, buf, len, ctx);\\r\\n}\\r\\nint EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->oct2point == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_OCT2POINT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_OCT2POINT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->oct2point(group, point, buf, len, ctx);\\r\\n}\\r\\nint EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->add == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_ADD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif ((group->meth != r->meth) || (r->meth != a->meth) || (a->meth != b->meth))\\r\\n{\\r\\nECerr(EC_F_EC_POINT_ADD, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->add(group, r, a, b, ctx);\\r\\n}\\r\\nint EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->dbl == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif ((group->meth != r->meth) || (r->meth != a->meth))\\r\\n{\\r\\nECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->dbl(group, r, a, ctx);\\r\\n}\\r\\nint EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->dbl == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != a->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->invert(group, a, ctx);\\r\\n}\\r\\nint EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)\\r\\n{\\r\\nif (group->meth->is_at_infinity == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_IS_AT_INFINITY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_IS_AT_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->is_at_infinity(group, point);\\r\\n}\\r\\nint EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->is_on_curve == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_IS_ON_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_IS_ON_CURVE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->is_on_curve(group, point, ctx);\\r\\n}\\r\\nint EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_cmp == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_CMP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif ((group->meth != a->meth) || (a->meth != b->meth))\\r\\n{\\r\\nECerr(EC_F_EC_POINT_CMP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_cmp(group, a, b, ctx);\\r\\n}\\r\\nint EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->make_affine == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINT_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->make_affine(group, point, ctx);\\r\\n}\\r\\nint EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nsize_t i;\\r\\nif (group->meth->points_make_affine == 0)\\r\\n{\\r\\nECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif (group->meth != points[i]->meth)\\r\\n{\\r\\nECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn group->meth->points_make_affine(group, num, points, ctx);\\r\\n}\\r\\nint EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nsize_t num, const EC_POINT *points[], const BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);\\r\\nreturn group->meth->mul(group, r, scalar, num, points, scalars, ctx);\\r\\n}\\r\\nint EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,\\r\\nconst EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_POINT *points[1];\\r\\nconst BIGNUM *scalars[1];\\r\\npoints[0] = point;\\r\\nscalars[0] = p_scalar;\\r\\nreturn EC_POINTs_mul(group, r, g_scalar, (point != NULL && p_scalar != NULL), points, scalars, ctx);\\r\\n}\\r\\nint EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_precompute_mult(group, ctx);\\r\\nif (group->meth->precompute_mult != 0)\\r\\nreturn group->meth->precompute_mult(group, ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint EC_GROUP_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_have_precompute_mult(group);\\r\\nif (group->meth->have_precompute_mult != 0)\\r\\nreturn group->meth->have_precompute_mult(group);\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_err2_c", "target": 0, "func": "void SSL_load_error_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_crypto_strings();\\r\\nERR_load_SSL_strings();\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rmd_dgst_c", "target": 0, "func": "int RIPEMD160_Init(RIPEMD160_CTX *c)\\r\\n{\\r\\nc->A=RIPEMD160_A;\\r\\nc->B=RIPEMD160_B;\\r\\nc->C=RIPEMD160_C;\\r\\nc->D=RIPEMD160_D;\\r\\nc->E=RIPEMD160_E;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ripemd160_block_host_order (RIPEMD160_CTX *ctx, const void *p, size_t num)\\r\\n{\\r\\nconst RIPEMD160_LONG *XX=p;\\r\\nregister unsigned MD32_REG_T A,B,C,D,E;\\r\\nregister unsigned MD32_REG_T a,b,c,d,e;\\r\\nfor (;num--;XX+=HASH_LBLOCK)\\r\\n{\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nRIP1(A,B,C,D,E,WL00,SL00);\\r\\nRIP1(E,A,B,C,D,WL01,SL01);\\r\\nRIP1(D,E,A,B,C,WL02,SL02);\\r\\nRIP1(C,D,E,A,B,WL03,SL03);\\r\\nRIP1(B,C,D,E,A,WL04,SL04);\\r\\nRIP1(A,B,C,D,E,WL05,SL05);\\r\\nRIP1(E,A,B,C,D,WL06,SL06);\\r\\nRIP1(D,E,A,B,C,WL07,SL07);\\r\\nRIP1(C,D,E,A,B,WL08,SL08);\\r\\nRIP1(B,C,D,E,A,WL09,SL09);\\r\\nRIP1(A,B,C,D,E,WL10,SL10);\\r\\nRIP1(E,A,B,C,D,WL11,SL11);\\r\\nRIP1(D,E,A,B,C,WL12,SL12);\\r\\nRIP1(C,D,E,A,B,WL13,SL13);\\r\\nRIP1(B,C,D,E,A,WL14,SL14);\\r\\nRIP1(A,B,C,D,E,WL15,SL15);\\r\\nRIP2(E,A,B,C,D,WL16,SL16,KL1);\\r\\nRIP2(D,E,A,B,C,WL17,SL17,KL1);\\r\\nRIP2(C,D,E,A,B,WL18,SL18,KL1);\\r\\nRIP2(B,C,D,E,A,WL19,SL19,KL1);\\r\\nRIP2(A,B,C,D,E,WL20,SL20,KL1);\\r\\nRIP2(E,A,B,C,D,WL21,SL21,KL1);\\r\\nRIP2(D,E,A,B,C,WL22,SL22,KL1);\\r\\nRIP2(C,D,E,A,B,WL23,SL23,KL1);\\r\\nRIP2(B,C,D,E,A,WL24,SL24,KL1);\\r\\nRIP2(A,B,C,D,E,WL25,SL25,KL1);\\r\\nRIP2(E,A,B,C,D,WL26,SL26,KL1);\\r\\nRIP2(D,E,A,B,C,WL27,SL27,KL1);\\r\\nRIP2(C,D,E,A,B,WL28,SL28,KL1);\\r\\nRIP2(B,C,D,E,A,WL29,SL29,KL1);\\r\\nRIP2(A,B,C,D,E,WL30,SL30,KL1);\\r\\nRIP2(E,A,B,C,D,WL31,SL31,KL1);\\r\\nRIP3(D,E,A,B,C,WL32,SL32,KL2);\\r\\nRIP3(C,D,E,A,B,WL33,SL33,KL2);\\r\\nRIP3(B,C,D,E,A,WL34,SL34,KL2);\\r\\nRIP3(A,B,C,D,E,WL35,SL35,KL2);\\r\\nRIP3(E,A,B,C,D,WL36,SL36,KL2);\\r\\nRIP3(D,E,A,B,C,WL37,SL37,KL2);\\r\\nRIP3(C,D,E,A,B,WL38,SL38,KL2);\\r\\nRIP3(B,C,D,E,A,WL39,SL39,KL2);\\r\\nRIP3(A,B,C,D,E,WL40,SL40,KL2);\\r\\nRIP3(E,A,B,C,D,WL41,SL41,KL2);\\r\\nRIP3(D,E,A,B,C,WL42,SL42,KL2);\\r\\nRIP3(C,D,E,A,B,WL43,SL43,KL2);\\r\\nRIP3(B,C,D,E,A,WL44,SL44,KL2);\\r\\nRIP3(A,B,C,D,E,WL45,SL45,KL2);\\r\\nRIP3(E,A,B,C,D,WL46,SL46,KL2);\\r\\nRIP3(D,E,A,B,C,WL47,SL47,KL2);\\r\\nRIP4(C,D,E,A,B,WL48,SL48,KL3);\\r\\nRIP4(B,C,D,E,A,WL49,SL49,KL3);\\r\\nRIP4(A,B,C,D,E,WL50,SL50,KL3);\\r\\nRIP4(E,A,B,C,D,WL51,SL51,KL3);\\r\\nRIP4(D,E,A,B,C,WL52,SL52,KL3);\\r\\nRIP4(C,D,E,A,B,WL53,SL53,KL3);\\r\\nRIP4(B,C,D,E,A,WL54,SL54,KL3);\\r\\nRIP4(A,B,C,D,E,WL55,SL55,KL3);\\r\\nRIP4(E,A,B,C,D,WL56,SL56,KL3);\\r\\nRIP4(D,E,A,B,C,WL57,SL57,KL3);\\r\\nRIP4(C,D,E,A,B,WL58,SL58,KL3);\\r\\nRIP4(B,C,D,E,A,WL59,SL59,KL3);\\r\\nRIP4(A,B,C,D,E,WL60,SL60,KL3);\\r\\nRIP4(E,A,B,C,D,WL61,SL61,KL3);\\r\\nRIP4(D,E,A,B,C,WL62,SL62,KL3);\\r\\nRIP4(C,D,E,A,B,WL63,SL63,KL3);\\r\\nRIP5(B,C,D,E,A,WL64,SL64,KL4);\\r\\nRIP5(A,B,C,D,E,WL65,SL65,KL4);\\r\\nRIP5(E,A,B,C,D,WL66,SL66,KL4);\\r\\nRIP5(D,E,A,B,C,WL67,SL67,KL4);\\r\\nRIP5(C,D,E,A,B,WL68,SL68,KL4);\\r\\nRIP5(B,C,D,E,A,WL69,SL69,KL4);\\r\\nRIP5(A,B,C,D,E,WL70,SL70,KL4);\\r\\nRIP5(E,A,B,C,D,WL71,SL71,KL4);\\r\\nRIP5(D,E,A,B,C,WL72,SL72,KL4);\\r\\nRIP5(C,D,E,A,B,WL73,SL73,KL4);\\r\\nRIP5(B,C,D,E,A,WL74,SL74,KL4);\\r\\nRIP5(A,B,C,D,E,WL75,SL75,KL4);\\r\\nRIP5(E,A,B,C,D,WL76,SL76,KL4);\\r\\nRIP5(D,E,A,B,C,WL77,SL77,KL4);\\r\\nRIP5(C,D,E,A,B,WL78,SL78,KL4);\\r\\nRIP5(B,C,D,E,A,WL79,SL79,KL4);\\r\\na=A; b=B; c=C; d=D; e=E;\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nRIP5(A,B,C,D,E,WR00,SR00,KR0);\\r\\nRIP5(E,A,B,C,D,WR01,SR01,KR0);\\r\\nRIP5(D,E,A,B,C,WR02,SR02,KR0);\\r\\nRIP5(C,D,E,A,B,WR03,SR03,KR0);\\r\\nRIP5(B,C,D,E,A,WR04,SR04,KR0);\\r\\nRIP5(A,B,C,D,E,WR05,SR05,KR0);\\r\\nRIP5(E,A,B,C,D,WR06,SR06,KR0);\\r\\nRIP5(D,E,A,B,C,WR07,SR07,KR0);\\r\\nRIP5(C,D,E,A,B,WR08,SR08,KR0);\\r\\nRIP5(B,C,D,E,A,WR09,SR09,KR0);\\r\\nRIP5(A,B,C,D,E,WR10,SR10,KR0);\\r\\nRIP5(E,A,B,C,D,WR11,SR11,KR0);\\r\\nRIP5(D,E,A,B,C,WR12,SR12,KR0);\\r\\nRIP5(C,D,E,A,B,WR13,SR13,KR0);\\r\\nRIP5(B,C,D,E,A,WR14,SR14,KR0);\\r\\nRIP5(A,B,C,D,E,WR15,SR15,KR0);\\r\\nRIP4(E,A,B,C,D,WR16,SR16,KR1);\\r\\nRIP4(D,E,A,B,C,WR17,SR17,KR1);\\r\\nRIP4(C,D,E,A,B,WR18,SR18,KR1);\\r\\nRIP4(B,C,D,E,A,WR19,SR19,KR1);\\r\\nRIP4(A,B,C,D,E,WR20,SR20,KR1);\\r\\nRIP4(E,A,B,C,D,WR21,SR21,KR1);\\r\\nRIP4(D,E,A,B,C,WR22,SR22,KR1);\\r\\nRIP4(C,D,E,A,B,WR23,SR23,KR1);\\r\\nRIP4(B,C,D,E,A,WR24,SR24,KR1);\\r\\nRIP4(A,B,C,D,E,WR25,SR25,KR1);\\r\\nRIP4(E,A,B,C,D,WR26,SR26,KR1);\\r\\nRIP4(D,E,A,B,C,WR27,SR27,KR1);\\r\\nRIP4(C,D,E,A,B,WR28,SR28,KR1);\\r\\nRIP4(B,C,D,E,A,WR29,SR29,KR1);\\r\\nRIP4(A,B,C,D,E,WR30,SR30,KR1);\\r\\nRIP4(E,A,B,C,D,WR31,SR31,KR1);\\r\\nRIP3(D,E,A,B,C,WR32,SR32,KR2);\\r\\nRIP3(C,D,E,A,B,WR33,SR33,KR2);\\r\\nRIP3(B,C,D,E,A,WR34,SR34,KR2);\\r\\nRIP3(A,B,C,D,E,WR35,SR35,KR2);\\r\\nRIP3(E,A,B,C,D,WR36,SR36,KR2);\\r\\nRIP3(D,E,A,B,C,WR37,SR37,KR2);\\r\\nRIP3(C,D,E,A,B,WR38,SR38,KR2);\\r\\nRIP3(B,C,D,E,A,WR39,SR39,KR2);\\r\\nRIP3(A,B,C,D,E,WR40,SR40,KR2);\\r\\nRIP3(E,A,B,C,D,WR41,SR41,KR2);\\r\\nRIP3(D,E,A,B,C,WR42,SR42,KR2);\\r\\nRIP3(C,D,E,A,B,WR43,SR43,KR2);\\r\\nRIP3(B,C,D,E,A,WR44,SR44,KR2);\\r\\nRIP3(A,B,C,D,E,WR45,SR45,KR2);\\r\\nRIP3(E,A,B,C,D,WR46,SR46,KR2);\\r\\nRIP3(D,E,A,B,C,WR47,SR47,KR2);\\r\\nRIP2(C,D,E,A,B,WR48,SR48,KR3);\\r\\nRIP2(B,C,D,E,A,WR49,SR49,KR3);\\r\\nRIP2(A,B,C,D,E,WR50,SR50,KR3);\\r\\nRIP2(E,A,B,C,D,WR51,SR51,KR3);\\r\\nRIP2(D,E,A,B,C,WR52,SR52,KR3);\\r\\nRIP2(C,D,E,A,B,WR53,SR53,KR3);\\r\\nRIP2(B,C,D,E,A,WR54,SR54,KR3);\\r\\nRIP2(A,B,C,D,E,WR55,SR55,KR3);\\r\\nRIP2(E,A,B,C,D,WR56,SR56,KR3);\\r\\nRIP2(D,E,A,B,C,WR57,SR57,KR3);\\r\\nRIP2(C,D,E,A,B,WR58,SR58,KR3);\\r\\nRIP2(B,C,D,E,A,WR59,SR59,KR3);\\r\\nRIP2(A,B,C,D,E,WR60,SR60,KR3);\\r\\nRIP2(E,A,B,C,D,WR61,SR61,KR3);\\r\\nRIP2(D,E,A,B,C,WR62,SR62,KR3);\\r\\nRIP2(C,D,E,A,B,WR63,SR63,KR3);\\r\\nRIP1(B,C,D,E,A,WR64,SR64);\\r\\nRIP1(A,B,C,D,E,WR65,SR65);\\r\\nRIP1(E,A,B,C,D,WR66,SR66);\\r\\nRIP1(D,E,A,B,C,WR67,SR67);\\r\\nRIP1(C,D,E,A,B,WR68,SR68);\\r\\nRIP1(B,C,D,E,A,WR69,SR69);\\r\\nRIP1(A,B,C,D,E,WR70,SR70);\\r\\nRIP1(E,A,B,C,D,WR71,SR71);\\r\\nRIP1(D,E,A,B,C,WR72,SR72);\\r\\nRIP1(C,D,E,A,B,WR73,SR73);\\r\\nRIP1(B,C,D,E,A,WR74,SR74);\\r\\nRIP1(A,B,C,D,E,WR75,SR75);\\r\\nRIP1(E,A,B,C,D,WR76,SR76);\\r\\nRIP1(D,E,A,B,C,WR77,SR77);\\r\\nRIP1(C,D,E,A,B,WR78,SR78);\\r\\nRIP1(B,C,D,E,A,WR79,SR79);\\r\\nD =ctx->B+c+D;\\r\\nctx->B=ctx->C+d+E;\\r\\nctx->C=ctx->D+e+A;\\r\\nctx->D=ctx->E+a+B;\\r\\nctx->E=ctx->A+b+C;\\r\\nctx->A=D;\\r\\n}\\r\\n}\\r\\nvoid ripemd160_block_data_order (RIPEMD160_CTX *ctx, const void *p, size_t num)\\r\\n{\\r\\nconst unsigned char *data=p;\\r\\nregister unsigned MD32_REG_T A,B,C,D,E;\\r\\nunsigned MD32_REG_T a,b,c,d,e,l;\\r\\n#ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9,XX10,XX11,XX12,XX13,XX14,XX15;\\r\\n# define X(i) XX##i\\r\\n#else\\r\\nRIPEMD160_LONG XX[16];\\r\\n# define X(i) XX[i]\\r\\n#endif\\r\\nfor (;num--;)\\r\\n{\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nHOST_c2l(data,l); X( 0)=l; HOST_c2l(data,l); X( 1)=l;\\r\\nRIP1(A,B,C,D,E,WL00,SL00); HOST_c2l(data,l); X( 2)=l;\\r\\nRIP1(E,A,B,C,D,WL01,SL01); HOST_c2l(data,l); X( 3)=l;\\r\\nRIP1(D,E,A,B,C,WL02,SL02); HOST_c2l(data,l); X( 4)=l;\\r\\nRIP1(C,D,E,A,B,WL03,SL03); HOST_c2l(data,l); X( 5)=l;\\r\\nRIP1(B,C,D,E,A,WL04,SL04); HOST_c2l(data,l); X( 6)=l;\\r\\nRIP1(A,B,C,D,E,WL05,SL05); HOST_c2l(data,l); X( 7)=l;\\r\\nRIP1(E,A,B,C,D,WL06,SL06); HOST_c2l(data,l); X( 8)=l;\\r\\nRIP1(D,E,A,B,C,WL07,SL07); HOST_c2l(data,l); X( 9)=l;\\r\\nRIP1(C,D,E,A,B,WL08,SL08); HOST_c2l(data,l); X(10)=l;\\r\\nRIP1(B,C,D,E,A,WL09,SL09); HOST_c2l(data,l); X(11)=l;\\r\\nRIP1(A,B,C,D,E,WL10,SL10); HOST_c2l(data,l); X(12)=l;\\r\\nRIP1(E,A,B,C,D,WL11,SL11); HOST_c2l(data,l); X(13)=l;\\r\\nRIP1(D,E,A,B,C,WL12,SL12); HOST_c2l(data,l); X(14)=l;\\r\\nRIP1(C,D,E,A,B,WL13,SL13); HOST_c2l(data,l); X(15)=l;\\r\\nRIP1(B,C,D,E,A,WL14,SL14);\\r\\nRIP1(A,B,C,D,E,WL15,SL15);\\r\\nRIP2(E,A,B,C,D,WL16,SL16,KL1);\\r\\nRIP2(D,E,A,B,C,WL17,SL17,KL1);\\r\\nRIP2(C,D,E,A,B,WL18,SL18,KL1);\\r\\nRIP2(B,C,D,E,A,WL19,SL19,KL1);\\r\\nRIP2(A,B,C,D,E,WL20,SL20,KL1);\\r\\nRIP2(E,A,B,C,D,WL21,SL21,KL1);\\r\\nRIP2(D,E,A,B,C,WL22,SL22,KL1);\\r\\nRIP2(C,D,E,A,B,WL23,SL23,KL1);\\r\\nRIP2(B,C,D,E,A,WL24,SL24,KL1);\\r\\nRIP2(A,B,C,D,E,WL25,SL25,KL1);\\r\\nRIP2(E,A,B,C,D,WL26,SL26,KL1);\\r\\nRIP2(D,E,A,B,C,WL27,SL27,KL1);\\r\\nRIP2(C,D,E,A,B,WL28,SL28,KL1);\\r\\nRIP2(B,C,D,E,A,WL29,SL29,KL1);\\r\\nRIP2(A,B,C,D,E,WL30,SL30,KL1);\\r\\nRIP2(E,A,B,C,D,WL31,SL31,KL1);\\r\\nRIP3(D,E,A,B,C,WL32,SL32,KL2);\\r\\nRIP3(C,D,E,A,B,WL33,SL33,KL2);\\r\\nRIP3(B,C,D,E,A,WL34,SL34,KL2);\\r\\nRIP3(A,B,C,D,E,WL35,SL35,KL2);\\r\\nRIP3(E,A,B,C,D,WL36,SL36,KL2);\\r\\nRIP3(D,E,A,B,C,WL37,SL37,KL2);\\r\\nRIP3(C,D,E,A,B,WL38,SL38,KL2);\\r\\nRIP3(B,C,D,E,A,WL39,SL39,KL2);\\r\\nRIP3(A,B,C,D,E,WL40,SL40,KL2);\\r\\nRIP3(E,A,B,C,D,WL41,SL41,KL2);\\r\\nRIP3(D,E,A,B,C,WL42,SL42,KL2);\\r\\nRIP3(C,D,E,A,B,WL43,SL43,KL2);\\r\\nRIP3(B,C,D,E,A,WL44,SL44,KL2);\\r\\nRIP3(A,B,C,D,E,WL45,SL45,KL2);\\r\\nRIP3(E,A,B,C,D,WL46,SL46,KL2);\\r\\nRIP3(D,E,A,B,C,WL47,SL47,KL2);\\r\\nRIP4(C,D,E,A,B,WL48,SL48,KL3);\\r\\nRIP4(B,C,D,E,A,WL49,SL49,KL3);\\r\\nRIP4(A,B,C,D,E,WL50,SL50,KL3);\\r\\nRIP4(E,A,B,C,D,WL51,SL51,KL3);\\r\\nRIP4(D,E,A,B,C,WL52,SL52,KL3);\\r\\nRIP4(C,D,E,A,B,WL53,SL53,KL3);\\r\\nRIP4(B,C,D,E,A,WL54,SL54,KL3);\\r\\nRIP4(A,B,C,D,E,WL55,SL55,KL3);\\r\\nRIP4(E,A,B,C,D,WL56,SL56,KL3);\\r\\nRIP4(D,E,A,B,C,WL57,SL57,KL3);\\r\\nRIP4(C,D,E,A,B,WL58,SL58,KL3);\\r\\nRIP4(B,C,D,E,A,WL59,SL59,KL3);\\r\\nRIP4(A,B,C,D,E,WL60,SL60,KL3);\\r\\nRIP4(E,A,B,C,D,WL61,SL61,KL3);\\r\\nRIP4(D,E,A,B,C,WL62,SL62,KL3);\\r\\nRIP4(C,D,E,A,B,WL63,SL63,KL3);\\r\\nRIP5(B,C,D,E,A,WL64,SL64,KL4);\\r\\nRIP5(A,B,C,D,E,WL65,SL65,KL4);\\r\\nRIP5(E,A,B,C,D,WL66,SL66,KL4);\\r\\nRIP5(D,E,A,B,C,WL67,SL67,KL4);\\r\\nRIP5(C,D,E,A,B,WL68,SL68,KL4);\\r\\nRIP5(B,C,D,E,A,WL69,SL69,KL4);\\r\\nRIP5(A,B,C,D,E,WL70,SL70,KL4);\\r\\nRIP5(E,A,B,C,D,WL71,SL71,KL4);\\r\\nRIP5(D,E,A,B,C,WL72,SL72,KL4);\\r\\nRIP5(C,D,E,A,B,WL73,SL73,KL4);\\r\\nRIP5(B,C,D,E,A,WL74,SL74,KL4);\\r\\nRIP5(A,B,C,D,E,WL75,SL75,KL4);\\r\\nRIP5(E,A,B,C,D,WL76,SL76,KL4);\\r\\nRIP5(D,E,A,B,C,WL77,SL77,KL4);\\r\\nRIP5(C,D,E,A,B,WL78,SL78,KL4);\\r\\nRIP5(B,C,D,E,A,WL79,SL79,KL4);\\r\\na=A; b=B; c=C; d=D; e=E;\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nRIP5(A,B,C,D,E,WR00,SR00,KR0);\\r\\nRIP5(E,A,B,C,D,WR01,SR01,KR0);\\r\\nRIP5(D,E,A,B,C,WR02,SR02,KR0);\\r\\nRIP5(C,D,E,A,B,WR03,SR03,KR0);\\r\\nRIP5(B,C,D,E,A,WR04,SR04,KR0);\\r\\nRIP5(A,B,C,D,E,WR05,SR05,KR0);\\r\\nRIP5(E,A,B,C,D,WR06,SR06,KR0);\\r\\nRIP5(D,E,A,B,C,WR07,SR07,KR0);\\r\\nRIP5(C,D,E,A,B,WR08,SR08,KR0);\\r\\nRIP5(B,C,D,E,A,WR09,SR09,KR0);\\r\\nRIP5(A,B,C,D,E,WR10,SR10,KR0);\\r\\nRIP5(E,A,B,C,D,WR11,SR11,KR0);\\r\\nRIP5(D,E,A,B,C,WR12,SR12,KR0);\\r\\nRIP5(C,D,E,A,B,WR13,SR13,KR0);\\r\\nRIP5(B,C,D,E,A,WR14,SR14,KR0);\\r\\nRIP5(A,B,C,D,E,WR15,SR15,KR0);\\r\\nRIP4(E,A,B,C,D,WR16,SR16,KR1);\\r\\nRIP4(D,E,A,B,C,WR17,SR17,KR1);\\r\\nRIP4(C,D,E,A,B,WR18,SR18,KR1);\\r\\nRIP4(B,C,D,E,A,WR19,SR19,KR1);\\r\\nRIP4(A,B,C,D,E,WR20,SR20,KR1);\\r\\nRIP4(E,A,B,C,D,WR21,SR21,KR1);\\r\\nRIP4(D,E,A,B,C,WR22,SR22,KR1);\\r\\nRIP4(C,D,E,A,B,WR23,SR23,KR1);\\r\\nRIP4(B,C,D,E,A,WR24,SR24,KR1);\\r\\nRIP4(A,B,C,D,E,WR25,SR25,KR1);\\r\\nRIP4(E,A,B,C,D,WR26,SR26,KR1);\\r\\nRIP4(D,E,A,B,C,WR27,SR27,KR1);\\r\\nRIP4(C,D,E,A,B,WR28,SR28,KR1);\\r\\nRIP4(B,C,D,E,A,WR29,SR29,KR1);\\r\\nRIP4(A,B,C,D,E,WR30,SR30,KR1);\\r\\nRIP4(E,A,B,C,D,WR31,SR31,KR1);\\r\\nRIP3(D,E,A,B,C,WR32,SR32,KR2);\\r\\nRIP3(C,D,E,A,B,WR33,SR33,KR2);\\r\\nRIP3(B,C,D,E,A,WR34,SR34,KR2);\\r\\nRIP3(A,B,C,D,E,WR35,SR35,KR2);\\r\\nRIP3(E,A,B,C,D,WR36,SR36,KR2);\\r\\nRIP3(D,E,A,B,C,WR37,SR37,KR2);\\r\\nRIP3(C,D,E,A,B,WR38,SR38,KR2);\\r\\nRIP3(B,C,D,E,A,WR39,SR39,KR2);\\r\\nRIP3(A,B,C,D,E,WR40,SR40,KR2);\\r\\nRIP3(E,A,B,C,D,WR41,SR41,KR2);\\r\\nRIP3(D,E,A,B,C,WR42,SR42,KR2);\\r\\nRIP3(C,D,E,A,B,WR43,SR43,KR2);\\r\\nRIP3(B,C,D,E,A,WR44,SR44,KR2);\\r\\nRIP3(A,B,C,D,E,WR45,SR45,KR2);\\r\\nRIP3(E,A,B,C,D,WR46,SR46,KR2);\\r\\nRIP3(D,E,A,B,C,WR47,SR47,KR2);\\r\\nRIP2(C,D,E,A,B,WR48,SR48,KR3);\\r\\nRIP2(B,C,D,E,A,WR49,SR49,KR3);\\r\\nRIP2(A,B,C,D,E,WR50,SR50,KR3);\\r\\nRIP2(E,A,B,C,D,WR51,SR51,KR3);\\r\\nRIP2(D,E,A,B,C,WR52,SR52,KR3);\\r\\nRIP2(C,D,E,A,B,WR53,SR53,KR3);\\r\\nRIP2(B,C,D,E,A,WR54,SR54,KR3);\\r\\nRIP2(A,B,C,D,E,WR55,SR55,KR3);\\r\\nRIP2(E,A,B,C,D,WR56,SR56,KR3);\\r\\nRIP2(D,E,A,B,C,WR57,SR57,KR3);\\r\\nRIP2(C,D,E,A,B,WR58,SR58,KR3);\\r\\nRIP2(B,C,D,E,A,WR59,SR59,KR3);\\r\\nRIP2(A,B,C,D,E,WR60,SR60,KR3);\\r\\nRIP2(E,A,B,C,D,WR61,SR61,KR3);\\r\\nRIP2(D,E,A,B,C,WR62,SR62,KR3);\\r\\nRIP2(C,D,E,A,B,WR63,SR63,KR3);\\r\\nRIP1(B,C,D,E,A,WR64,SR64);\\r\\nRIP1(A,B,C,D,E,WR65,SR65);\\r\\nRIP1(E,A,B,C,D,WR66,SR66);\\r\\nRIP1(D,E,A,B,C,WR67,SR67);\\r\\nRIP1(C,D,E,A,B,WR68,SR68);\\r\\nRIP1(B,C,D,E,A,WR69,SR69);\\r\\nRIP1(A,B,C,D,E,WR70,SR70);\\r\\nRIP1(E,A,B,C,D,WR71,SR71);\\r\\nRIP1(D,E,A,B,C,WR72,SR72);\\r\\nRIP1(C,D,E,A,B,WR73,SR73);\\r\\nRIP1(B,C,D,E,A,WR74,SR74);\\r\\nRIP1(A,B,C,D,E,WR75,SR75);\\r\\nRIP1(E,A,B,C,D,WR76,SR76);\\r\\nRIP1(D,E,A,B,C,WR77,SR77);\\r\\nRIP1(C,D,E,A,B,WR78,SR78);\\r\\nRIP1(B,C,D,E,A,WR79,SR79);\\r\\nD =ctx->B+c+D;\\r\\nctx->B=ctx->C+d+E;\\r\\nctx->C=ctx->D+e+A;\\r\\nctx->D=ctx->E+a+B;\\r\\nctx->E=ctx->A+b+C;\\r\\nctx->A=D;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_cast_c", "target": 0, "func": "static int cast_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nCAST_set_key(&data(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),key);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_err_c", "target": 0, "func": "void ERR_load_DSA_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,DSA_str_functs);\\r\\nERR_load_strings(0,DSA_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_gen_c", "target": 0, "func": "int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)\\r\\n{\\r\\nif(rsa->meth->rsa_keygen)\\r\\nreturn rsa->meth->rsa_keygen(rsa, bits, e_value, cb);\\r\\nreturn rsa_builtin_keygen(rsa, bits, e_value, cb);\\r\\n}\\r\\nstatic int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;\\r\\nint bitsp,bitsq,ok= -1,n=0;\\r\\nBN_CTX *ctx=NULL;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\nr1 = BN_CTX_get(ctx);\\r\\nr2 = BN_CTX_get(ctx);\\r\\nr3 = BN_CTX_get(ctx);\\r\\nif (r3 == NULL) goto err;\\r\\nbitsp=(bits+1)/2;\\r\\nbitsq=bits-bitsp;\\r\\nif(!rsa->n && ((rsa->n=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->d && ((rsa->d=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->e && ((rsa->e=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->p && ((rsa->p=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->q && ((rsa->q=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->dmp1 && ((rsa->dmp1=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->dmq1 && ((rsa->dmq1=BN_new()) == NULL)) goto err;\\r\\nif(!rsa->iqmp && ((rsa->iqmp=BN_new()) == NULL)) goto err;\\r\\nBN_copy(rsa->e, e_value);\\r\\nfor (;;)\\r\\n{\\r\\nif(!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))\\r\\ngoto err;\\r\\nif (!BN_sub(r2,rsa->p,BN_value_one())) goto err;\\r\\nif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\\r\\nif (BN_is_one(r1)) break;\\r\\nif(!BN_GENCB_call(cb, 2, n++))\\r\\ngoto err;\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 3, 0))\\r\\ngoto err;\\r\\nfor (;;)\\r\\n{\\r\\nunsigned int degenerate = 0;\\r\\ndo\\r\\n{\\r\\nif(!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\\r\\ngoto err;\\r\\n} while((BN_cmp(rsa->p, rsa->q) == 0) && (++degenerate < 3));\\r\\nif(degenerate == 3)\\r\\n{\\r\\nok = 0;\\r\\nRSAerr(RSA_F_RSA_BUILTIN_KEYGEN,RSA_R_KEY_SIZE_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\\r\\nif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\\r\\nif (BN_is_one(r1))\\r\\nbreak;\\r\\nif(!BN_GENCB_call(cb, 2, n++))\\r\\ngoto err;\\r\\n}\\r\\nif(!BN_GENCB_call(cb, 3, 1))\\r\\ngoto err;\\r\\nif (BN_cmp(rsa->p,rsa->q) < 0)\\r\\n{\\r\\ntmp=rsa->p;\\r\\nrsa->p=rsa->q;\\r\\nrsa->q=tmp;\\r\\n}\\r\\nif (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;\\r\\nif (!BN_sub(r1,rsa->p,BN_value_one())) goto err;\\r\\nif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\\r\\nif (!BN_mul(r0,r1,r2,ctx)) goto err;\\r\\nif (!BN_mod_inverse(rsa->d,rsa->e,r0,ctx)) goto err;\\r\\nif (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;\\r\\nif (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;\\r\\nif (!BN_mod_inverse(rsa->iqmp,rsa->q,rsa->p,ctx)) goto err;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok == -1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_BUILTIN_KEYGEN,ERR_LIB_BN);\\r\\nok=0;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ech_err_c", "target": 0, "func": "void ERR_load_ECDH_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,ECDH_str_functs);\\r\\nERR_load_strings(0,ECDH_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_lib_c", "target": 0, "func": "int PEM_def_callback(char *buf, int num, int w, void *key)\\r\\n{\\r\\n#ifdef OPENSSL_NO_FP_API\\r\\nPEMerr(PEM_F_PEM_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(-1);\\r\\n#else\\r\\nint i,j;\\r\\nconst char *prompt;\\r\\nif(key) {\\r\\ni=strlen(key);\\r\\ni=(i > num)?num:i;\\r\\nmemcpy(buf,key,i);\\r\\nreturn(i);\\r\\n}\\r\\nprompt=EVP_get_pw_prompt();\\r\\nif (prompt == NULL)\\r\\nprompt=\"Enter PEM pass phrase:\";\\r\\nfor (;;)\\r\\n{\\r\\ni=EVP_read_pw_string(buf,num,prompt,w);\\r\\nif (i != 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);\\r\\nmemset(buf,0,(unsigned int)num);\\r\\nreturn(-1);\\r\\n}\\r\\nj=strlen(buf);\\r\\nif (j < MIN_LENGTH)\\r\\n{\\r\\nfprintf(stderr,\"phrase is too short, needs to be at least %d chars\\n\",MIN_LENGTH);\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nreturn(j);\\r\\n#endif\\r\\n}\\r\\nvoid PEM_proc_type(char *buf, int type)\\r\\n{\\r\\nconst char *str;\\r\\nif (type == PEM_TYPE_ENCRYPTED)\\r\\nstr=\"ENCRYPTED\";\\r\\nelse if (type == PEM_TYPE_MIC_CLEAR)\\r\\nstr=\"MIC-CLEAR\";\\r\\nelse if (type == PEM_TYPE_MIC_ONLY)\\r\\nstr=\"MIC-ONLY\";\\r\\nelse\\r\\nstr=\"BAD-TYPE\";\\r\\nBUF_strlcat(buf,\"Proc-Type: 4,\",PEM_BUFSIZE);\\r\\nBUF_strlcat(buf,str,PEM_BUFSIZE);\\r\\nBUF_strlcat(buf,\"\\n\",PEM_BUFSIZE);\\r\\n}\\r\\nvoid PEM_dek_info(char *buf, const char *type, int len, char *str)\\r\\n{\\r\\nstatic const unsigned char map[17]=\"0123456789ABCDEF\";\\r\\nlong i;\\r\\nint j;\\r\\nBUF_strlcat(buf,\"DEK-Info: \",PEM_BUFSIZE);\\r\\nBUF_strlcat(buf,type,PEM_BUFSIZE);\\r\\nBUF_strlcat(buf,\",\",PEM_BUFSIZE);\\r\\nj=strlen(buf);\\r\\nif (j + (len * 2) + 1 > PEM_BUFSIZE)\\r\\nreturn;\\r\\nfor (i=0; i<len; i++)\\r\\n{\\r\\nbuf[j+i*2] =map[(str[i]>>4)&0x0f];\\r\\nbuf[j+i*2+1]=map[(str[i] )&0x0f];\\r\\n}\\r\\nbuf[j+i*2]='\\n';\\r\\nbuf[j+i*2+1]='\\0';\\r\\n}\\r\\nvoid *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nvoid *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int check_pem(const char *nm, const char *name)\\r\\n{\\r\\nif (!strcmp(nm,name)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_PKCS8) &&\\r\\n!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_PKCS8INF) &&\\r\\n!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_RSA) &&\\r\\n!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_DSA) &&\\r\\n!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_ECPRIVATEKEY) &&\\r\\n!strcmp(name,PEM_STRING_EVP_PKEY)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_X509_OLD) &&\\r\\n!strcmp(name,PEM_STRING_X509)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_X509_REQ_OLD) &&\\r\\n!strcmp(name,PEM_STRING_X509_REQ)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_X509) &&\\r\\n!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;\\r\\nif(!strcmp(nm,PEM_STRING_X509_OLD) &&\\r\\n!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;\\r\\nif(!strcmp(nm, PEM_STRING_X509) &&\\r\\n!strcmp(name, PEM_STRING_PKCS7)) return 1;\\r\\nreturn 0;\\r\\n}\\r\\nint PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nEVP_CIPHER_INFO cipher;\\r\\nchar *nm=NULL,*header=NULL;\\r\\nunsigned char *data=NULL;\\r\\nlong len;\\r\\nint ret = 0;\\r\\nfor (;;)\\r\\n{\\r\\nif (!PEM_read_bio(bp,&nm,&header,&data,&len)) {\\r\\nif(ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_NO_START_LINE)\\r\\nERR_add_error_data(2, \"Expecting: \", name);\\r\\nreturn 0;\\r\\n}\\r\\nif(check_pem(nm, name)) break;\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(header);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nif (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;\\r\\nif (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;\\r\\n*pdata = data;\\r\\n*plen = len;\\r\\nif (pnm)\\r\\n*pnm = nm;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret || !pnm) OPENSSL_free(nm);\\r\\nOPENSSL_free(header);\\r\\nif (!ret) OPENSSL_free(data);\\r\\nreturn ret;\\r\\n}\\r\\nint PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,\\r\\nchar *x, const EVP_CIPHER *enc, unsigned char *kstr,\\r\\nint klen, pem_password_cb *callback, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,\\r\\nchar *x, const EVP_CIPHER *enc, unsigned char *kstr,\\r\\nint klen, pem_password_cb *callback, void *u)\\r\\n{\\r\\nEVP_CIPHER_CTX ctx;\\r\\nint dsize=0,i,j,ret=0;\\r\\nunsigned char *p,*data=NULL;\\r\\nconst char *objstr=NULL;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nif (enc != NULL)\\r\\n{\\r\\nobjstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));\\r\\nif (objstr == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((dsize=i2d(x,NULL)) < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_ASN1_LIB);\\r\\ndsize=0;\\r\\ngoto err;\\r\\n}\\r\\ndata=(unsigned char *)OPENSSL_malloc((unsigned int)dsize+20);\\r\\nif (data == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=data;\\r\\ni=i2d(x,&p);\\r\\nif (enc != NULL)\\r\\n{\\r\\nif (kstr == NULL)\\r\\n{\\r\\nif (callback == NULL)\\r\\nklen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);\\r\\nelse\\r\\nklen=(*callback)(buf,PEM_BUFSIZE,1,u);\\r\\nif (klen <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nkstr=(unsigned char *)buf;\\r\\n}\\r\\nRAND_add(data,i,0);\\r\\nOPENSSL_assert(enc->iv_len <= (int)sizeof(iv));\\r\\nif (RAND_pseudo_bytes(iv,enc->iv_len) < 0)\\r\\ngoto err;\\r\\nEVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL);\\r\\nif (kstr == (unsigned char *)buf) OPENSSL_cleanse(buf,PEM_BUFSIZE);\\r\\nOPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);\\r\\nbuf[0]='\\0';\\r\\nPEM_proc_type(buf,PEM_TYPE_ENCRYPTED);\\r\\nPEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_EncryptInit_ex(&ctx,enc,NULL,key,iv);\\r\\nEVP_EncryptUpdate(&ctx,data,&j,data,i);\\r\\nEVP_EncryptFinal_ex(&ctx,&(data[j]),&i);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\ni+=j;\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=1;\\r\\nbuf[0]='\\0';\\r\\n}\\r\\ni=PEM_write_bio(bp,name,buf,data,i);\\r\\nif (i <= 0) ret=0;\\r\\nerr:\\r\\nOPENSSL_cleanse(key,sizeof(key));\\r\\nOPENSSL_cleanse(iv,sizeof(iv));\\r\\nOPENSSL_cleanse((char *)&ctx,sizeof(ctx));\\r\\nOPENSSL_cleanse(buf,PEM_BUFSIZE);\\r\\nif (data != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(data,(unsigned int)dsize);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,\\r\\npem_password_cb *callback,void *u)\\r\\n{\\r\\nint i,j,o,klen;\\r\\nlong len;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nchar buf[PEM_BUFSIZE];\\r\\nlen= *plen;\\r\\nif (cipher->cipher == NULL) return(1);\\r\\nif (callback == NULL)\\r\\nklen=PEM_def_callback(buf,PEM_BUFSIZE,0,u);\\r\\nelse\\r\\nklen=callback(buf,PEM_BUFSIZE,0,u);\\r\\nif (klen <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_PASSWORD_READ);\\r\\nreturn(0);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nEVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),\\r\\n(unsigned char *)buf,klen,1,key,NULL);\\r\\nj=(int)len;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));\\r\\nEVP_DecryptUpdate(&ctx,data,&i,data,j);\\r\\no=EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nOPENSSL_cleanse((char *)buf,sizeof(buf));\\r\\nOPENSSL_cleanse((char *)key,sizeof(key));\\r\\nj+=i;\\r\\nif (!o)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\n*plen=j;\\r\\nreturn(1);\\r\\n}\\r\\nint PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)\\r\\n{\\r\\nint o;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nchar *p,c;\\r\\nchar **header_pp = &header;\\r\\ncipher->cipher=NULL;\\r\\nif ((header == NULL) || (*header == '\\0') || (*header == '\\n'))\\r\\nreturn(1);\\r\\nif (strncmp(header,\"Proc-Type: \",11) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_PROC_TYPE); return(0); }\\r\\nheader+=11;\\r\\nif (*header != '4') return(0); header++;\\r\\nif (*header != ',') return(0); header++;\\r\\nif (strncmp(header,\"ENCRYPTED\",9) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_ENCRYPTED); return(0); }\\r\\nfor (; (*header != '\\n') && (*header != '\\0'); header++)\\r\\n;\\r\\nif (*header == '\\0')\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_SHORT_HEADER); return(0); }\\r\\nheader++;\\r\\nif (strncmp(header,\"DEK-Info: \",10) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_DEK_INFO); return(0); }\\r\\nheader+=10;\\r\\np=header;\\r\\nfor (;;)\\r\\n{\\r\\nc= *header;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((c >= 'A') && (c <= 'Z')) || (c == '-') ||\\r\\n((c >= '0') && (c <= '9'))))\\r\\nbreak;\\r\\n#else\\r\\nif (!( isupper(c) || (c == '-') ||\\r\\nisdigit(c)))\\r\\nbreak;\\r\\n#endif\\r\\nheader++;\\r\\n}\\r\\n*header='\\0';\\r\\no=OBJ_sn2nid(p);\\r\\ncipher->cipher=enc=EVP_get_cipherbyname(p);\\r\\n*header=c;\\r\\nheader++;\\r\\nif (enc == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_UNSUPPORTED_ENCRYPTION);\\r\\nreturn(0);\\r\\n}\\r\\nif (!load_iv(header_pp,&(cipher->iv[0]),enc->iv_len))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int load_iv(char **fromp, unsigned char *to, int num)\\r\\n{\\r\\nint v,i;\\r\\nchar *from;\\r\\nfrom= *fromp;\\r\\nfor (i=0; i<num; i++) to[i]=0;\\r\\nnum*=2;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nif ((*from >= '0') && (*from <= '9'))\\r\\nv= *from-'0';\\r\\nelse if ((*from >= 'A') && (*from <= 'F'))\\r\\nv= *from-'A'+10;\\r\\nelse if ((*from >= 'a') && (*from <= 'f'))\\r\\nv= *from-'a'+10;\\r\\nelse\\r\\n{\\r\\nPEMerr(PEM_F_LOAD_IV,PEM_R_BAD_IV_CHARS);\\r\\nreturn(0);\\r\\n}\\r\\nfrom++;\\r\\nto[i/2]|=v<<(long)((!(i&1))*4);\\r\\n}\\r\\n*fromp=from;\\r\\nreturn(1);\\r\\n}\\r\\nint PEM_write(FILE *fp, char *name, char *header, unsigned char *data,\\r\\nlong len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_WRITE,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_write_bio(b, name, header, data,len);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,\\r\\nlong len)\\r\\n{\\r\\nint nlen,n,i,j,outl;\\r\\nunsigned char *buf = NULL;\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint reason=ERR_R_BUF_LIB;\\r\\nEVP_EncodeInit(&ctx);\\r\\nnlen=strlen(name);\\r\\nif ( (BIO_write(bp,\"-----BEGIN \",11) != 11) ||\\r\\n(BIO_write(bp,name,nlen) != nlen) ||\\r\\n(BIO_write(bp,\"-----\\n\",6) != 6))\\r\\ngoto err;\\r\\ni=strlen(header);\\r\\nif (i > 0)\\r\\n{\\r\\nif ( (BIO_write(bp,header,i) != i) ||\\r\\n(BIO_write(bp,\"\\n\",1) != 1))\\r\\ngoto err;\\r\\n}\\r\\nbuf = OPENSSL_malloc(PEM_BUFSIZE*8);\\r\\nif (buf == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\ni=j=0;\\r\\nwhile (len > 0)\\r\\n{\\r\\nn=(int)((len>(PEM_BUFSIZE*5))?(PEM_BUFSIZE*5):len);\\r\\nEVP_EncodeUpdate(&ctx,buf,&outl,&(data[j]),n);\\r\\nif ((outl) && (BIO_write(bp,(char *)buf,outl) != outl))\\r\\ngoto err;\\r\\ni+=outl;\\r\\nlen-=n;\\r\\nj+=n;\\r\\n}\\r\\nEVP_EncodeFinal(&ctx,buf,&outl);\\r\\nif ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;\\r\\nOPENSSL_free(buf);\\r\\nbuf = NULL;\\r\\nif ( (BIO_write(bp,\"-----END \",9) != 9) ||\\r\\n(BIO_write(bp,name,nlen) != nlen) ||\\r\\n(BIO_write(bp,\"-----\\n\",6) != 6))\\r\\ngoto err;\\r\\nreturn(i+outl);\\r\\nerr:\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nPEMerr(PEM_F_PEM_WRITE_BIO,reason);\\r\\nreturn(0);\\r\\n}\\r\\nint PEM_read(FILE *fp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_read_bio(b, name, header, data,len);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint end=0,i,k,bl=0,hl=0,nohead=0;\\r\\nchar buf[256];\\r\\nBUF_MEM *nameB;\\r\\nBUF_MEM *headerB;\\r\\nBUF_MEM *dataB,*tmpB;\\r\\nnameB=BUF_MEM_new();\\r\\nheaderB=BUF_MEM_new();\\r\\ndataB=BUF_MEM_new();\\r\\nif ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))\\r\\n{\\r\\nBUF_MEM_free(nameB);\\r\\nBUF_MEM_free(headerB);\\r\\nBUF_MEM_free(dataB);\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nbuf[254]='\\0';\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);\\r\\ngoto err;\\r\\n}\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (strncmp(buf,\"-----BEGIN \",11) == 0)\\r\\n{\\r\\ni=strlen(&(buf[11]));\\r\\nif (strncmp(&(buf[11+i-6]),\"-----\\n\",6) != 0)\\r\\ncontinue;\\r\\nif (!BUF_MEM_grow(nameB,i+9))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(nameB->data,&(buf[11]),i-6);\\r\\nnameB->data[i-6]='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nhl=0;\\r\\nif (!BUF_MEM_grow(headerB,256))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\nheaderB->data[0]='\\0';\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (buf[0] == '\\n') break;\\r\\nif (!BUF_MEM_grow(headerB,hl+i+9))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\nif (strncmp(buf,\"-----END \",9) == 0)\\r\\n{\\r\\nnohead=1;\\r\\nbreak;\\r\\n}\\r\\nmemcpy(&(headerB->data[hl]),buf,i);\\r\\nheaderB->data[hl+i]='\\0';\\r\\nhl+=i;\\r\\n}\\r\\nbl=0;\\r\\nif (!BUF_MEM_grow(dataB,1024))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\ndataB->data[0]='\\0';\\r\\nif (!nohead)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (i != 65) end=1;\\r\\nif (strncmp(buf,\"-----END \",9) == 0)\\r\\nbreak;\\r\\nif (i > 65) break;\\r\\nif (!BUF_MEM_grow_clean(dataB,i+bl+9))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(&(dataB->data[bl]),buf,i);\\r\\ndataB->data[bl+i]='\\0';\\r\\nbl+=i;\\r\\nif (end)\\r\\n{\\r\\nbuf[0]='\\0';\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ntmpB=headerB;\\r\\nheaderB=dataB;\\r\\ndataB=tmpB;\\r\\nbl=hl;\\r\\n}\\r\\ni=strlen(nameB->data);\\r\\nif ( (strncmp(buf,\"-----END \",9) != 0) ||\\r\\n(strncmp(nameB->data,&(buf[9]),i) != 0) ||\\r\\n(strncmp(&(buf[9+i]),\"-----\\n\",6) != 0))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_DecodeInit(&ctx);\\r\\ni=EVP_DecodeUpdate(&ctx,\\r\\n(unsigned char *)dataB->data,&bl,\\r\\n(unsigned char *)dataB->data,bl);\\r\\nif (i < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\ni=EVP_DecodeFinal(&ctx,(unsigned char *)&(dataB->data[bl]),&k);\\r\\nif (i < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\nbl+=k;\\r\\nif (bl == 0) goto err;\\r\\n*name=nameB->data;\\r\\n*header=headerB->data;\\r\\n*data=(unsigned char *)dataB->data;\\r\\n*len=bl;\\r\\nOPENSSL_free(nameB);\\r\\nOPENSSL_free(headerB);\\r\\nOPENSSL_free(dataB);\\r\\nreturn(1);\\r\\nerr:\\r\\nBUF_MEM_free(nameB);\\r\\nBUF_MEM_free(headerB);\\r\\nBUF_MEM_free(dataB);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_comp_err_c", "target": 0, "func": "void ERR_load_COMP_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,COMP_str_functs);\\r\\nERR_load_strings(0,COMP_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ip_c", "target": 0, "func": "int ip_initialise(void)\\r\\n{\\r\\nstruct sigaction sa;\\r\\nsa.sa_handler = SIG_IGN;\\r\\nsa.sa_flags = 0;\\r\\nsigemptyset(&sa.sa_mask);\\r\\nif(sigaction(SIGPIPE, &sa, NULL) != 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ip_create_listener_split(const char *ip, unsigned short port)\\r\\n{\\r\\nstruct sockaddr_in in_addr;\\r\\nint fd = -1;\\r\\nint reuseVal = 1;\\r\\nif((fd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\\r\\ngoto err;\\r\\nif(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)(&reuseVal),\\r\\nsizeof(reuseVal)) != 0)\\r\\ngoto err;\\r\\nin_addr.sin_family = AF_INET;\\r\\nmemcpy(&in_addr.sin_addr.s_addr, ip, 4);\\r\\nin_addr.sin_port = htons(port);\\r\\nif(bind(fd, (struct sockaddr *)&in_addr, sizeof(struct sockaddr_in)) != 0)\\r\\ngoto err;\\r\\nif(listen(fd, IP_LISTENER_BACKLOG) != 0)\\r\\ngoto err;\\r\\nreturn fd;\\r\\nerr:\\r\\nif(fd != -1)\\r\\nclose(fd);\\r\\nreturn -1;\\r\\n}\\r\\nint ip_create_connection_split(const char *ip, unsigned short port)\\r\\n{\\r\\nstruct sockaddr_in in_addr;\\r\\nint flags, fd = -1;\\r\\nif((fd = socket(PF_INET, SOCK_STREAM, 0)) == -1)\\r\\ngoto err;\\r\\nif(((flags = fcntl(fd, F_GETFL, 0)) < 0) ||\\r\\n(fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0))\\r\\ngoto err;\\r\\nin_addr.sin_family = AF_INET;\\r\\nmemcpy(&in_addr.sin_addr.s_addr, ip, 4);\\r\\nin_addr.sin_port = htons(port);\\r\\nif((connect(fd, (struct sockaddr *)&in_addr,\\r\\nsizeof(struct sockaddr_in)) != 0) &&\\r\\n(errno != EINPROGRESS))\\r\\ngoto err;\\r\\nreturn fd;\\r\\nerr:\\r\\nif(fd != -1)\\r\\nclose(fd);\\r\\nreturn -1;\\r\\n}\\r\\nint ip_parse_address(const char *address, const char **parsed_ip,\\r\\nunsigned short *parsed_port, int accept_all_ip)\\r\\n{\\r\\nchar buf[256];\\r\\nstruct hostent *lookup;\\r\\nunsigned long port;\\r\\nconst char *ptr = strstr(address, \":\");\\r\\nconst char *ip = all_local_ip;\\r\\nif(!ptr) {\\r\\nif(!accept_all_ip)\\r\\nreturn 0;\\r\\nptr = address;\\r\\ngoto determine_port;\\r\\n}\\r\\nif((ptr - address) > 255)\\r\\nreturn 0;\\r\\nmemset(buf, 0, 256);\\r\\nmemcpy(buf, address, ptr - address);\\r\\nptr++;\\r\\nif((lookup = gethostbyname(buf)) == NULL) {\\r\\nfprintf(stderr, \"hostname lookup for '%s' failed\\n\", buf);\\r\\nreturn 0;\\r\\n}\\r\\nip = lookup->h_addr_list[0];\\r\\ndetermine_port:\\r\\nif(strlen(ptr) < 1)\\r\\nreturn 0;\\r\\nif(!int_strtoul(ptr, &port) || (port > 65535))\\r\\nreturn 0;\\r\\n*parsed_ip = ip;\\r\\n*parsed_port = (unsigned short)port;\\r\\nreturn 1;\\r\\n}\\r\\nint ip_create_listener(const char *address)\\r\\n{\\r\\nconst char *ip;\\r\\nunsigned short port;\\r\\nif(!ip_parse_address(address, &ip, &port, 1))\\r\\nreturn -1;\\r\\nreturn ip_create_listener_split(ip, port);\\r\\n}\\r\\nint ip_create_connection(const char *address)\\r\\n{\\r\\nconst char *ip;\\r\\nunsigned short port;\\r\\nif(!ip_parse_address(address, &ip, &port, 0))\\r\\nreturn -1;\\r\\nreturn ip_create_connection_split(ip, port);\\r\\n}\\r\\nint ip_accept_connection(int listen_fd)\\r\\n{\\r\\nreturn accept(listen_fd, NULL, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_chil_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth2;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_hwcrhk_id) ||\\r\\n!ENGINE_set_name(e, engine_hwcrhk_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &hwcrhk_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &hwcrhk_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &hwcrhk_rand) ||\\r\\n!ENGINE_set_destroy_function(e, hwcrhk_destroy) ||\\r\\n!ENGINE_set_init_function(e, hwcrhk_init) ||\\r\\n!ENGINE_set_finish_function(e, hwcrhk_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, hwcrhk_ctrl) ||\\r\\n!ENGINE_set_load_privkey_function(e, hwcrhk_load_privkey) ||\\r\\n!ENGINE_set_load_pubkey_function(e, hwcrhk_load_pubkey) ||\\r\\n!ENGINE_set_cmd_defns(e, hwcrhk_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\nhwcrhk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\nhwcrhk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\nhwcrhk_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\nhwcrhk_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth2 = DH_OpenSSL();\\r\\nhwcrhk_dh.generate_key = meth2->generate_key;\\r\\nhwcrhk_dh.compute_key = meth2->compute_key;\\r\\n#endif\\r\\nERR_load_HWCRHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_chil(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_chil(void)\\r\\n{\\r\\nENGINE *toadd = engine_chil();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic void free_HWCRHK_LIBNAME(void)\\r\\n{\\r\\nif(HWCRHK_LIBNAME)\\r\\nOPENSSL_free((void*)HWCRHK_LIBNAME);\\r\\nHWCRHK_LIBNAME = NULL;\\r\\n}\\r\\nstatic const char *get_HWCRHK_LIBNAME(void)\\r\\n{\\r\\nif(HWCRHK_LIBNAME)\\r\\nreturn HWCRHK_LIBNAME;\\r\\nreturn \"nfhwcrhk\";\\r\\n}\\r\\nstatic long set_HWCRHK_LIBNAME(const char *name)\\r\\n{\\r\\nfree_HWCRHK_LIBNAME();\\r\\nreturn (((HWCRHK_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int get_context(HWCryptoHook_ContextHandle *hac,\\r\\nHWCryptoHook_CallerContext *cac)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\n*hac = p_hwcrhk_Init(&hwcrhk_globals, sizeof(hwcrhk_globals), &rmsg,\\r\\ncac);\\r\\nif (!*hac)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void release_context(HWCryptoHook_ContextHandle hac)\\r\\n{\\r\\np_hwcrhk_Finish(hac);\\r\\n}\\r\\nstatic int hwcrhk_destroy(ENGINE *e)\\r\\n{\\r\\nfree_HWCRHK_LIBNAME();\\r\\nERR_unload_HWCRHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hwcrhk_init(ENGINE *e)\\r\\n{\\r\\nHWCryptoHook_Init_t *p1;\\r\\nHWCryptoHook_Finish_t *p2;\\r\\nHWCryptoHook_ModExp_t *p3;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nHWCryptoHook_RSA_t *p4;\\r\\nHWCryptoHook_RSALoadKey_t *p5;\\r\\nHWCryptoHook_RSAGetPublicKey_t *p6;\\r\\nHWCryptoHook_RSAUnloadKey_t *p7;\\r\\n#endif\\r\\nHWCryptoHook_RandomBytes_t *p8;\\r\\nHWCryptoHook_ModExpCRT_t *p9;\\r\\nif(hwcrhk_dso != NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT,HWCRHK_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nhwcrhk_dso = DSO_load(NULL, get_HWCRHK_LIBNAME(), NULL, 0);\\r\\nif(hwcrhk_dso == NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT,HWCRHK_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif(!(p1 = (HWCryptoHook_Init_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_Init)) ||\\r\\n!(p2 = (HWCryptoHook_Finish_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_Finish)) ||\\r\\n!(p3 = (HWCryptoHook_ModExp_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExp)) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!(p4 = (HWCryptoHook_RSA_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSA)) ||\\r\\n!(p5 = (HWCryptoHook_RSALoadKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSALoadKey)) ||\\r\\n!(p6 = (HWCryptoHook_RSAGetPublicKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAGetPublicKey)) ||\\r\\n!(p7 = (HWCryptoHook_RSAUnloadKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAUnloadKey)) ||\\r\\n#endif\\r\\n!(p8 = (HWCryptoHook_RandomBytes_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RandomBytes)) ||\\r\\n!(p9 = (HWCryptoHook_ModExpCRT_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExpCRT)))\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT,HWCRHK_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_hwcrhk_Init = p1;\\r\\np_hwcrhk_Finish = p2;\\r\\np_hwcrhk_ModExp = p3;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = p4;\\r\\np_hwcrhk_RSALoadKey = p5;\\r\\np_hwcrhk_RSAGetPublicKey = p6;\\r\\np_hwcrhk_RSAUnloadKey = p7;\\r\\n#endif\\r\\np_hwcrhk_RandomBytes = p8;\\r\\np_hwcrhk_ModExpCRT = p9;\\r\\nif (disable_mutex_callbacks == 0)\\r\\n{\\r\\nif (CRYPTO_get_dynlock_create_callback() != NULL &&\\r\\nCRYPTO_get_dynlock_lock_callback() != NULL &&\\r\\nCRYPTO_get_dynlock_destroy_callback() != NULL)\\r\\n{\\r\\nhwcrhk_globals.mutex_init = hwcrhk_mutex_init;\\r\\nhwcrhk_globals.mutex_acquire = hwcrhk_mutex_lock;\\r\\nhwcrhk_globals.mutex_release = hwcrhk_mutex_unlock;\\r\\nhwcrhk_globals.mutex_destroy = hwcrhk_mutex_destroy;\\r\\n}\\r\\nelse if (CRYPTO_get_locking_callback() != NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT,HWCRHK_R_LOCKING_MISSING);\\r\\nERR_add_error_data(1,\"You HAVE to add dynamic locking callbacks via CRYPTO_set_dynlock_{create,lock,destroy}_callback()\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif(!get_context(&hwcrhk_context, &password_context))\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT,HWCRHK_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (hndidx_rsa == -1)\\r\\nhndidx_rsa = RSA_get_ex_new_index(0,\\r\\n\"nFast HWCryptoHook RSA key handle\",\\r\\nNULL, NULL, hwcrhk_ex_free);\\r\\n#endif\\r\\nreturn 1;\\r\\nerr:\\r\\nif(hwcrhk_dso)\\r\\nDSO_free(hwcrhk_dso);\\r\\nhwcrhk_dso = NULL;\\r\\np_hwcrhk_Init = NULL;\\r\\np_hwcrhk_Finish = NULL;\\r\\np_hwcrhk_ModExp = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = NULL;\\r\\np_hwcrhk_RSALoadKey = NULL;\\r\\np_hwcrhk_RSAGetPublicKey = NULL;\\r\\np_hwcrhk_RSAUnloadKey = NULL;\\r\\n#endif\\r\\np_hwcrhk_ModExpCRT = NULL;\\r\\np_hwcrhk_RandomBytes = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nfree_HWCRHK_LIBNAME();\\r\\nif(hwcrhk_dso == NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_FINISH,HWCRHK_R_NOT_LOADED);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\nrelease_context(hwcrhk_context);\\r\\nif(!DSO_free(hwcrhk_dso))\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_FINISH,HWCRHK_R_DSO_FAILURE);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (logstream)\\r\\nBIO_free(logstream);\\r\\nhwcrhk_dso = NULL;\\r\\np_hwcrhk_Init = NULL;\\r\\np_hwcrhk_Finish = NULL;\\r\\np_hwcrhk_ModExp = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = NULL;\\r\\np_hwcrhk_RSALoadKey = NULL;\\r\\np_hwcrhk_RSAGetPublicKey = NULL;\\r\\np_hwcrhk_RSAUnloadKey = NULL;\\r\\n#endif\\r\\np_hwcrhk_ModExpCRT = NULL;\\r\\np_hwcrhk_RandomBytes = NULL;\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint to_return = 1;\\r\\nswitch(cmd)\\r\\n{\\r\\ncase HWCRHK_CMD_SO_PATH:\\r\\nif(hwcrhk_dso)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL,HWCRHK_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(p == NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_HWCRHK_LIBNAME((const char *)p);\\r\\ncase ENGINE_CTRL_SET_LOGSTREAM:\\r\\n{\\r\\nBIO *bio = (BIO *)p;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (logstream)\\r\\n{\\r\\nBIO_free(logstream);\\r\\nlogstream = NULL;\\r\\n}\\r\\nif (CRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO) > 1)\\r\\nlogstream = bio;\\r\\nelse\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL,HWCRHK_R_BIO_WAS_FREED);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_PASSWORD_CALLBACK:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.password_callback = (pem_password_cb *)f;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_USER_INTERFACE:\\r\\ncase HWCRHK_CMD_SET_USER_INTERFACE:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.ui_method = (UI_METHOD *)p;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_CALLBACK_DATA:\\r\\ncase HWCRHK_CMD_SET_CALLBACK_DATA:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.callback_data = p;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_CHIL_SET_FORKCHECK:\\r\\ncase HWCRHK_CMD_FORK_CHECK:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(i)\\r\\nhwcrhk_globals.flags |=\\r\\nHWCryptoHook_InitFlags_SimpleForkCheck;\\r\\nelse\\r\\nhwcrhk_globals.flags &=\\r\\n~HWCryptoHook_InitFlags_SimpleForkCheck;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_CHIL_NO_LOCKING:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\ndisable_mutex_callbacks = 1;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase HWCRHK_CMD_THREAD_LOCKING:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\ndisable_mutex_callbacks = ((i == 0) ? 0 : 1);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ndefault:\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL,\\r\\nHWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nto_return = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic EVP_PKEY *hwcrhk_load_privkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rtmp = NULL;\\r\\n#endif\\r\\nEVP_PKEY *res = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nHWCryptoHook_MPI e, n;\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_RSA)\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\n#endif\\r\\nHWCryptoHook_PassphraseContext ppctx;\\r\\n#if !defined(OPENSSL_NO_RSA)\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\n#endif\\r\\nif(!hwcrhk_context)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nhptr = OPENSSL_malloc(sizeof(HWCryptoHook_RSAKeyHandle));\\r\\nif (!hptr)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nppctx.ui_method = ui_method;\\r\\nppctx.callback_data = callback_data;\\r\\nif (p_hwcrhk_RSALoadKey(hwcrhk_context, key_id, hptr,\\r\\n&rmsg, &ppctx))\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nif (!*hptr)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_NO_KEY);\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nrtmp = RSA_new_method(eng);\\r\\nRSA_set_ex_data(rtmp, hndidx_rsa, (char *)hptr);\\r\\nrtmp->e = BN_new();\\r\\nrtmp->n = BN_new();\\r\\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\\r\\nMPI2BN(rtmp->e, e);\\r\\nMPI2BN(rtmp->n, n);\\r\\nif (p_hwcrhk_RSAGetPublicKey(*hptr, &n, &e, &rmsg)\\r\\n!= HWCRYPTOHOOK_ERROR_MPISIZE)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,HWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(rtmp->e, e.size/sizeof(BN_ULONG));\\r\\nbn_expand2(rtmp->n, n.size/sizeof(BN_ULONG));\\r\\nMPI2BN(rtmp->e, e);\\r\\nMPI2BN(rtmp->n, n);\\r\\nif (p_hwcrhk_RSAGetPublicKey(*hptr, &n, &e, &rmsg))\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nrtmp->e->top = e.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(rtmp->e);\\r\\nrtmp->n->top = n.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(rtmp->n);\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_RSA(res, rtmp);\\r\\n#endif\\r\\nif (!res)\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_PRIVATE_KEY_ALGORITHMS_DISABLED);\\r\\nreturn res;\\r\\nerr:\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (rtmp)\\r\\nRSA_free(rtmp);\\r\\n#endif\\r\\nreturn NULL;\\r\\n}\\r\\nstatic EVP_PKEY *hwcrhk_load_pubkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *res = NULL;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nres = hwcrhk_load_privkey(eng, key_id,\\r\\nui_method, callback_data);\\r\\n#endif\\r\\nif (res)\\r\\nswitch(res->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\n{\\r\\nRSA *rsa = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EVP_PKEY);\\r\\nrsa = res->pkey.rsa;\\r\\nres->pkey.rsa = RSA_new();\\r\\nres->pkey.rsa->n = rsa->n;\\r\\nres->pkey.rsa->e = rsa->e;\\r\\nrsa->n = NULL;\\r\\nrsa->e = NULL;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EVP_PKEY);\\r\\nRSA_free(rsa);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PUBKEY,\\r\\nHWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\ngoto err;\\r\\n}\\r\\nreturn res;\\r\\nerr:\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int hwcrhk_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nHWCryptoHook_MPI m_a, m_p, m_n, m_r;\\r\\nint to_return, ret;\\r\\nto_return = 0;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif(!hwcrhk_context)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP,HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, m->top);\\r\\nBN2MPI(m_a, a);\\r\\nBN2MPI(m_p, p);\\r\\nBN2MPI(m_n, m);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_ModExp(hwcrhk_context, m_a, m_p, m_n, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0)\\r\\n{\\r\\nif(ret == HWCRYPTOHOOK_ERROR_FALLBACK)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP,HWCRHK_R_REQUEST_FALLBACK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP,HWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_rsa_mod_exp(BIGNUM *r, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\nint to_return = 0, ret;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif(!hwcrhk_context)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nif ((hptr = (HWCryptoHook_RSAKeyHandle *) RSA_get_ex_data(rsa, hndidx_rsa))\\r\\n!= NULL)\\r\\n{\\r\\nHWCryptoHook_MPI m_a, m_r;\\r\\nif(!rsa->n)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, rsa->n->top);\\r\\nBN2MPI(m_a, I);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_RSA(m_a, *hptr, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0)\\r\\n{\\r\\nif(ret == HWCRYPTOHOOK_ERROR_FALLBACK)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FALLBACK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nHWCryptoHook_MPI m_a, m_p, m_q, m_dmp1, m_dmq1, m_iqmp, m_r;\\r\\nif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, rsa->n->top);\\r\\nBN2MPI(m_a, I);\\r\\nBN2MPI(m_p, rsa->p);\\r\\nBN2MPI(m_q, rsa->q);\\r\\nBN2MPI(m_dmp1, rsa->dmp1);\\r\\nBN2MPI(m_dmq1, rsa->dmq1);\\r\\nBN2MPI(m_iqmp, rsa->iqmp);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_ModExpCRT(hwcrhk_context, m_a, m_p, m_q,\\r\\nm_dmp1, m_dmq1, m_iqmp, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0)\\r\\n{\\r\\nif(ret == HWCRYPTOHOOK_ERROR_FALLBACK)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FALLBACK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn hwcrhk_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int hwcrhk_mod_exp_dh(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn hwcrhk_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int hwcrhk_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nint to_return = 0;\\r\\nint ret;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif(!hwcrhk_context)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES,HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nret = p_hwcrhk_RandomBytes(hwcrhk_context, buf, num, &rmsg);\\r\\nif (ret < 0)\\r\\n{\\r\\nif(ret == HWCRYPTOHOOK_ERROR_FALLBACK)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES,\\r\\nHWCRHK_R_REQUEST_FALLBACK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES,\\r\\nHWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1,rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic void hwcrhk_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad,\\r\\nint ind,long argl, void *argp)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_RSA)\\r\\nint ret;\\r\\n#endif\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nhptr = (HWCryptoHook_RSAKeyHandle *) item;\\r\\nif(hptr)\\r\\n{\\r\\nret = p_hwcrhk_RSAUnloadKey(*hptr, NULL);\\r\\nOPENSSL_free(hptr);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic int hwcrhk_mutex_init(HWCryptoHook_Mutex* mt,\\r\\nHWCryptoHook_CallerContext *cactx)\\r\\n{\\r\\nmt->lockid = CRYPTO_get_new_dynlockid();\\r\\nif (mt->lockid == 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_mutex_lock(HWCryptoHook_Mutex *mt)\\r\\n{\\r\\nCRYPTO_w_lock(mt->lockid);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void hwcrhk_mutex_unlock(HWCryptoHook_Mutex * mt)\\r\\n{\\r\\nCRYPTO_w_unlock(mt->lockid);\\r\\n}\\r\\nstatic void hwcrhk_mutex_destroy(HWCryptoHook_Mutex *mt)\\r\\n{\\r\\nCRYPTO_destroy_dynlockid(mt->lockid);\\r\\n}\\r\\nstatic int hwcrhk_get_pass(const char *prompt_info,\\r\\nint *len_io, char *buf,\\r\\nHWCryptoHook_PassphraseContext *ppctx,\\r\\nHWCryptoHook_CallerContext *cactx)\\r\\n{\\r\\npem_password_cb *callback = NULL;\\r\\nvoid *callback_data = NULL;\\r\\nUI_METHOD *ui_method = NULL;\\r\\nif (cactx)\\r\\n{\\r\\nif (cactx->ui_method)\\r\\nui_method = cactx->ui_method;\\r\\nif (cactx->password_callback)\\r\\ncallback = cactx->password_callback;\\r\\nif (cactx->callback_data)\\r\\ncallback_data = cactx->callback_data;\\r\\n}\\r\\nif (ppctx)\\r\\n{\\r\\nif (ppctx->ui_method)\\r\\n{\\r\\nui_method = ppctx->ui_method;\\r\\ncallback = NULL;\\r\\n}\\r\\nif (ppctx->callback_data)\\r\\ncallback_data = ppctx->callback_data;\\r\\n}\\r\\nif (callback == NULL && ui_method == NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_GET_PASS,HWCRHK_R_NO_CALLBACK);\\r\\nreturn -1;\\r\\n}\\r\\nif (ui_method)\\r\\n{\\r\\nUI *ui = UI_new_method(ui_method);\\r\\nif (ui)\\r\\n{\\r\\nint ok;\\r\\nchar *prompt = UI_construct_prompt(ui,\\r\\n\"pass phrase\", prompt_info);\\r\\nok = UI_add_input_string(ui,prompt,\\r\\nUI_INPUT_FLAG_DEFAULT_PWD,\\r\\nbuf,0,(*len_io) - 1);\\r\\nUI_add_user_data(ui, callback_data);\\r\\nUI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);\\r\\nif (ok >= 0)\\r\\ndo\\r\\n{\\r\\nok=UI_process(ui);\\r\\n}\\r\\nwhile (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));\\r\\nif (ok >= 0)\\r\\n*len_io = strlen(buf);\\r\\nUI_free(ui);\\r\\nOPENSSL_free(prompt);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n*len_io = callback(buf, *len_io, 0, callback_data);\\r\\n}\\r\\nif(!*len_io)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_insert_card(const char *prompt_info,\\r\\nconst char *wrong_info,\\r\\nHWCryptoHook_PassphraseContext *ppctx,\\r\\nHWCryptoHook_CallerContext *cactx)\\r\\n{\\r\\nint ok = -1;\\r\\nUI *ui;\\r\\nvoid *callback_data = NULL;\\r\\nUI_METHOD *ui_method = NULL;\\r\\nif (cactx)\\r\\n{\\r\\nif (cactx->ui_method)\\r\\nui_method = cactx->ui_method;\\r\\nif (cactx->callback_data)\\r\\ncallback_data = cactx->callback_data;\\r\\n}\\r\\nif (ppctx)\\r\\n{\\r\\nif (ppctx->ui_method)\\r\\nui_method = ppctx->ui_method;\\r\\nif (ppctx->callback_data)\\r\\ncallback_data = ppctx->callback_data;\\r\\n}\\r\\nif (ui_method == NULL)\\r\\n{\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INSERT_CARD,\\r\\nHWCRHK_R_NO_CALLBACK);\\r\\nreturn -1;\\r\\n}\\r\\nui = UI_new_method(ui_method);\\r\\nif (ui)\\r\\n{\\r\\nchar answer;\\r\\nchar buf[BUFSIZ];\\r\\nif (wrong_info)\\r\\nBIO_snprintf(buf, sizeof(buf)-1,\\r\\n\"Current card: \\\"%s\\\"\\n\", wrong_info);\\r\\nok = UI_dup_info_string(ui, buf);\\r\\nif (ok >= 0 && prompt_info)\\r\\n{\\r\\nBIO_snprintf(buf, sizeof(buf)-1,\\r\\n\"Insert card \\\"%s\\\"\", prompt_info);\\r\\nok = UI_dup_input_boolean(ui, buf,\\r\\n\"\\n then hit <enter> or C<enter> to cancel\\n\",\\r\\n\"\\r\\n\", \"Cc\", UI_INPUT_FLAG_ECHO, &answer);\\r\\n}\\r\\nUI_add_user_data(ui, callback_data);\\r\\nif (ok >= 0)\\r\\nok = UI_process(ui);\\r\\nUI_free(ui);\\r\\nif (ok == -2 || (ok >= 0 && answer == 'C'))\\r\\nok = 1;\\r\\nelse if (ok < 0)\\r\\nok = -1;\\r\\nelse\\r\\nok = 0;\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nstatic void hwcrhk_log_message(void *logstr, const char *message)\\r\\n{\\r\\nBIO *lstream = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_BIO);\\r\\nif (logstr)\\r\\nlstream=*(BIO **)logstr;\\r\\nif (lstream)\\r\\n{\\r\\nBIO_printf(lstream, \"%s\\n\", message);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_BIO);\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_hwcrhk_id) != 0) &&\\r\\n(strcmp(id, engine_hwcrhk_id_alt) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_clnt_c", "target": 0, "func": "static SSL_METHOD *ssl2_get_client_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_client_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_client_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_client_data.ssl_connect=ssl2_connect;\\r\\nSSLv2_client_data.get_ssl_method=ssl2_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv2_client_data);\\r\\n}\\r\\nint ssl2_connect(SSL *s)\\r\\n{\\r\\nunsigned long l=time(NULL);\\r\\nBUF_MEM *buf=NULL;\\r\\nint ret= -1;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint new_state,state;\\r\\nRAND_add(&l,sizeof(l),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->version=SSL2_VERSION;\\r\\ns->type=SSL_ST_CONNECT;\\r\\nbuf=s->init_buf;\\r\\nif ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\nif (buf == s->init_buf)\\r\\nbuf=NULL;\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\nbuf=NULL;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_CLIENT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->handshake_func=ssl2_connect;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A:\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A:\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B:\\r\\nret=get_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (!s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_A;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\\r\\nbreak;\\r\\n}\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A:\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B:\\r\\nret=client_master_key(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\\r\\nbreak;\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION:\\r\\nif (!ssl2_enc_init(s,1))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->s2->clear_text=0;\\r\\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A:\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B:\\r\\nret=client_finished(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_VERIFY_A;\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A:\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B:\\r\\nret=get_server_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A:\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B:\\r\\nret=get_server_finished(s);\\r\\nif (ret <= 0) goto end;\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D:\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE:\\r\\nret=client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\ns->init_num=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\\r\\nif (s->hit) s->ctx->stats.sess_hit++;\\r\\nret=1;\\r\\ns->ctx->stats.sess_connect_good++;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL2_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nreturn(-1);\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int get_server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nint i,j;\\r\\nunsigned long len;\\r\\nSTACK_OF(SSL_CIPHER) *sk=NULL,*cl, *prio, *allow;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=buf;\\r\\nif (s->state == SSL2_ST_GET_SERVER_HELLO_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),11-s->init_num);\\r\\nif (i < (11-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\\r\\ns->init_num = 11;\\r\\nif (*(p++) != SSL2_MT_SERVER_HELLO)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,\\r\\nSSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,\\r\\nSSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n#ifdef __APPLE_CC__\\r\\ns->hit=(i=*(p++))?1:0;\\r\\n#else\\r\\ns->hit=(*(p++))?1:0;\\r\\n#endif\\r\\ns->s2->tmp.cert_type= *(p++);\\r\\nn2s(p,i);\\r\\nif (i < s->version) s->version=i;\\r\\nn2s(p,i); s->s2->tmp.cert_length=i;\\r\\nn2s(p,i); s->s2->tmp.csl=i;\\r\\nn2s(p,i); s->s2->tmp.conn_id_length=i;\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_B;\\r\\n}\\r\\nlen = 11 + (unsigned long)s->s2->tmp.cert_length + (unsigned long)s->s2->tmp.csl + (unsigned long)s->s2->tmp.conn_id_length;\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_MESSAGE_TOO_LONG);\\r\\nreturn -1;\\r\\n}\\r\\nj = (int)len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(buf[s->init_num]),j);\\r\\nif (i != j) return(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, buf, (size_t)len, s, s->msg_callback_arg);\\r\\np = buf + 11;\\r\\nif (s->hit)\\r\\n{\\r\\nif (s->s2->tmp.cert_length != 0)\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_LENGTH_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\nif (s->s2->tmp.cert_type != 0)\\r\\n{\\r\\nif (!(s->options &\\r\\nSSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_TYPE_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (s->s2->tmp.csl != 0)\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CIPHER_LIST_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef undef\\r\\nmemset(s->session->session_id,0,\\r\\nSSL_MAX_SSL_SESSION_ID_LENGTH_IN_BYTES);\\r\\ns->session->session_id_length=0;\\r\\n*/\\r\\n#endif\\r\\nif (s->session->session_id_length > 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (ssl2_set_certificate(s,s->s2->tmp.cert_type,\\r\\ns->s2->tmp.cert_length,p) <= 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\nreturn(-1);\\r\\n}\\r\\np+=s->s2->tmp.cert_length;\\r\\nif (s->s2->tmp.csl == 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_LIST);\\r\\nreturn(-1);\\r\\n}\\r\\nsk=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.csl,\\r\\n&s->session->ciphers);\\r\\np+=s->s2->tmp.csl;\\r\\nif (sk == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nsk_SSL_CIPHER_set_cmp_func(sk,ssl_cipher_ptr_id_cmp);\\r\\ncl=SSL_get_ciphers(s);\\r\\nsk_SSL_CIPHER_set_cmp_func(cl,ssl_cipher_ptr_id_cmp);\\r\\nif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\\r\\n{\\r\\nprio = sk;\\r\\nallow = cl;\\r\\n}\\r\\nelse\\r\\n{\\r\\nprio = cl;\\r\\nallow = sk;\\r\\n}\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(prio); i++)\\r\\n{\\r\\nif (sk_SSL_CIPHER_find(allow,\\r\\nsk_SSL_CIPHER_value(prio,i)) >= 0)\\r\\nbreak;\\r\\n}\\r\\nif (i >= sk_SSL_CIPHER_num(prio))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_MATCH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->session->cipher=sk_SSL_CIPHER_value(prio,i);\\r\\nif (s->session->peer != NULL)\\r\\n{\\r\\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ns->session->peer = s->session->sess_cert->peer_key->x509;\\r\\nCRYPTO_add(&s->session->peer->references, 1, CRYPTO_LOCK_X509);\\r\\n}\\r\\nif (s->session->peer != s->session->sess_cert->peer_key->x509)\\r\\n{\\r\\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ns->s2->conn_id_length=s->s2->tmp.conn_id_length;\\r\\nif (s->s2->conn_id_length > sizeof s->s2->conn_id)\\r\\n{\\r\\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO, SSL_R_SSL2_CONNECTION_ID_TOO_LONG);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(s->s2->conn_id,p,s->s2->tmp.conn_id_length);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,n,j;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_HELLO_A)\\r\\n{\\r\\nif ((s->session == NULL) ||\\r\\n(s->session->ssl_version != s->version))\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np=buf;\\r\\nd=p+9;\\r\\n*(p++)=SSL2_MT_CLIENT_HELLO;\\r\\ns2n(SSL2_VERSION,p);\\r\\nn=j=0;\\r\\nn=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),d,0);\\r\\nd+=n;\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\nreturn(-1);\\r\\n}\\r\\ns2n(n,p);\\r\\nif ((s->session->session_id_length > 0) &&\\r\\n(s->session->session_id_length <=\\r\\nSSL2_MAX_SSL_SESSION_ID_LENGTH))\\r\\n{\\r\\ni=s->session->session_id_length;\\r\\ns2n(i,p);\\r\\nmemcpy(d,s->session->session_id,(unsigned int)i);\\r\\nd+=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns2n(0,p);\\r\\n}\\r\\ns->s2->challenge_length=SSL2_CHALLENGE_LENGTH;\\r\\ns2n(SSL2_CHALLENGE_LENGTH,p);\\r\\nif (RAND_pseudo_bytes(s->s2->challenge,SSL2_CHALLENGE_LENGTH) <= 0)\\r\\nreturn -1;\\r\\nmemcpy(d,s->s2->challenge,SSL2_CHALLENGE_LENGTH);\\r\\nd+=SSL2_CHALLENGE_LENGTH;\\r\\ns->state=SSL2_ST_SEND_CLIENT_HELLO_B;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_master_key(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint clear,enc,karg,i;\\r\\nSSL_SESSION *sess;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_MASTER_KEY_A)\\r\\n{\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(-1);\\r\\n}\\r\\nsess=s->session;\\r\\np=buf;\\r\\nd=p+10;\\r\\n*(p++)=SSL2_MT_CLIENT_MASTER_KEY;\\r\\ni=ssl_put_cipher_by_char(s,sess->cipher,p);\\r\\np+=i;\\r\\ni=EVP_CIPHER_iv_length(c);\\r\\nsess->key_arg_length=i;\\r\\nif (i > SSL_MAX_KEY_ARG_LENGTH)\\r\\n{\\r\\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nif (i > 0)\\r\\nif (RAND_pseudo_bytes(sess->key_arg,i) <= 0)\\r\\nreturn -1;\\r\\ni=EVP_CIPHER_key_length(c);\\r\\nsess->master_key_length=i;\\r\\nif (i > 0)\\r\\n{\\r\\nif (i > (int)sizeof(sess->master_key))\\r\\n{\\r\\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nif (RAND_bytes(sess->master_key,i) <= 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (sess->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)\\r\\nenc=8;\\r\\nelse if (SSL_C_IS_EXPORT(sess->cipher))\\r\\nenc=5;\\r\\nelse\\r\\nenc=i;\\r\\nif ((int)i < enc)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_CIPHER_TABLE_SRC_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nclear=i-enc;\\r\\ns2n(clear,p);\\r\\nmemcpy(d,sess->master_key,(unsigned int)clear);\\r\\nd+=clear;\\r\\nenc=ssl_rsa_public_encrypt(sess->sess_cert,enc,\\r\\n&(sess->master_key[clear]),d,\\r\\n(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);\\r\\nif (enc <= 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PUBLIC_KEY_ENCRYPT_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n#ifdef PKCS1_CHECK\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_1) d[1]++;\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_2)\\r\\nsess->master_key[clear]++;\\r\\n#endif\\r\\ns2n(enc,p);\\r\\nd+=enc;\\r\\nkarg=sess->key_arg_length;\\r\\ns2n(karg,p);\\r\\nif (karg > (int)sizeof(sess->key_arg))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(d,sess->key_arg,(unsigned int)karg);\\r\\nd+=karg;\\r\\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_B;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_finished(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_FINISHED_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_CLIENT_FINISHED;\\r\\nif (s->s2->conn_id_length > sizeof s->s2->conn_id)\\r\\n{\\r\\nSSLerr(SSL_F_CLIENT_FINISHED, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(p,s->s2->conn_id,(unsigned int)s->s2->conn_id_length);\\r\\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_B;\\r\\ns->init_num=s->s2->conn_id_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_certificate(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i;\\r\\nunsigned int n;\\r\\nint cert_ch_len;\\r\\nunsigned char *cert_ch;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),\\r\\nSSL2_MAX_CERT_CHALLENGE_LENGTH+2-s->init_num);\\r\\nif (i<(SSL2_MIN_CERT_CHALLENGE_LENGTH+2-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_CLIENT_CERTIFICATE,i));\\r\\ns->init_num += i;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg);\\r\\nif (buf[1] != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\\r\\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_AUTHENTICATION_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\nif ((s->cert == NULL) ||\\r\\n(s->cert->key->x509 == NULL) ||\\r\\n(s->cert->key->privatekey == NULL))\\r\\n{\\r\\ns->state=SSL2_ST_X509_GET_CLIENT_CERTIFICATE;\\r\\n}\\r\\nelse\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\\r\\n}\\r\\ncert_ch = buf + 2;\\r\\ncert_ch_len = s->init_num - 2;\\r\\nif (s->state == SSL2_ST_X509_GET_CLIENT_CERTIFICATE)\\r\\n{\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\ni=0;\\r\\nif (s->ctx->client_cert_cb != NULL)\\r\\n{\\r\\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\ns->rwstate=SSL_X509_LOOKUP;\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\\r\\nif ( !SSL_use_certificate(s,x509) ||\\r\\n!SSL_use_PrivateKey(s,pkey))\\r\\n{\\r\\ni=0;\\r\\n}\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse if (i == 1)\\r\\n{\\r\\nif (x509 != NULL) X509_free(x509);\\r\\nif (pkey != NULL) EVP_PKEY_free(pkey);\\r\\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\\r\\ni=0;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_B;\\r\\np=buf;\\r\\n*(p++)=SSL2_MT_ERROR;\\r\\ns2n(SSL2_PE_NO_CERTIFICATE,p);\\r\\ns->init_off=0;\\r\\ns->init_num=3;\\r\\n}\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_B)\\r\\n{\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_C)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\np=buf;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_SignInit_ex(&ctx,s->ctx->rsa_md5, NULL);\\r\\nEVP_SignUpdate(&ctx,s->s2->key_material,\\r\\ns->s2->key_material_length);\\r\\nEVP_SignUpdate(&ctx,cert_ch,(unsigned int)cert_ch_len);\\r\\nn=i2d_X509(s->session->sess_cert->peer_key->x509,&p);\\r\\nEVP_SignUpdate(&ctx,buf,(unsigned int)n);\\r\\np=buf;\\r\\nd=p+6;\\r\\n*(p++)=SSL2_MT_CLIENT_CERTIFICATE;\\r\\n*(p++)=SSL2_CT_X509_CERTIFICATE;\\r\\nn=i2d_X509(s->cert->key->x509,&d);\\r\\ns2n(n,p);\\r\\nif (!EVP_SignFinal(&ctx,d,&n,s->cert->key->privatekey))\\r\\n{\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\ns2n(n,p);\\r\\nd+=n;\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_D;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int get_server_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nint i, n, len;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_SERVER_VERIFY_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);\\r\\nif (i < (1-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\\r\\ns->init_num += i;\\r\\ns->state= SSL2_ST_GET_SERVER_VERIFY_B;\\r\\nif (*p != SSL2_MT_SERVER_VERIFY)\\r\\n{\\r\\nif (p[0] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,\\r\\nSSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_PEER_ERROR);\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);\\r\\nreturn ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nlen = 1 + s->s2->challenge_length;\\r\\nn = len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i < n)\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg);\\r\\np += 1;\\r\\nif (memcmp(p,s->s2->challenge,s->s2->challenge_length) != 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_CHALLENGE_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_server_finished(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nint i, n, len;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=buf;\\r\\nif (s->state == SSL2_ST_GET_SERVER_FINISHED_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),1-s->init_num);\\r\\nif (i < (1-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\\r\\ns->init_num += i;\\r\\nif (*p == SSL2_MT_REQUEST_CERTIFICATE)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_A;\\r\\nreturn(1);\\r\\n}\\r\\nelse if (*p != SSL2_MT_SERVER_FINISHED)\\r\\n{\\r\\nif (p[0] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_PEER_ERROR);\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);\\r\\nreturn ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\ns->state=SSL2_ST_GET_SERVER_FINISHED_B;\\r\\n}\\r\\nlen = 1 + SSL2_SSL_SESSION_ID_LENGTH;\\r\\nn = len - s->init_num;\\r\\ni = ssl2_read(s,(char *)&(buf[s->init_num]), n);\\r\\nif (i < n)\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\\r\\ns->init_num += i;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg);\\r\\nif (!s->hit)\\r\\n{\\r\\ns->session->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;\\r\\nmemcpy(s->session->session_id,p+1,SSL2_SSL_SESSION_ID_LENGTH);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(s->options & SSL_OP_MICROSOFT_SESS_ID_BUG))\\r\\n{\\r\\nif ((s->session->session_id_length > sizeof s->session->session_id)\\r\\n|| (0 != memcmp(buf + 1, s->session->session_id,\\r\\n(unsigned int)s->session->session_id_length)))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_SSL_SESSION_ID_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\ns->state = SSL_ST_OK;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data)\\r\\n{\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nSESS_CERT *sc=NULL;\\r\\nint i;\\r\\nX509 *x509=NULL;\\r\\nint ret=0;\\r\\nx509=d2i_X509(NULL,&data,(long)len);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((sk=sk_X509_new_null()) == NULL || !sk_X509_push(sk,x509))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif ((s->verify_mode != SSL_VERIFY_NONE) && (!i))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nERR_clear_error();\\r\\ns->session->verify_result = s->verify_result;\\r\\nsc=ssl_sess_cert_new();\\r\\nif (sc == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nif (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=sc;\\r\\nsc->peer_pkeys[SSL_PKEY_RSA_ENC].x509=x509;\\r\\nsc->peer_key= &(sc->peer_pkeys[SSL_PKEY_RSA_ENC]);\\r\\npkey=X509_get_pubkey(x509);\\r\\nx509=NULL;\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (pkey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_PUBLIC_KEY_NOT_RSA);\\r\\ngoto err;\\r\\n}\\r\\nif (!ssl_set_peer_cert_type(sc,SSL2_CT_X509_CERTIFICATE))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nsk_X509_free(sk);\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_rsa_public_encrypt(SESS_CERT *sc, int len, unsigned char *from,\\r\\nunsigned char *to, int padding)\\r\\n{\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i= -1;\\r\\nif ((sc == NULL) || (sc->peer_key->x509 == NULL) ||\\r\\n((pkey=X509_get_pubkey(sc->peer_key->x509)) == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_NO_PUBLICKEY);\\r\\nreturn(-1);\\r\\n}\\r\\nif (pkey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);\\r\\ngoto end;\\r\\n}\\r\\ni=RSA_public_encrypt(len,from,to,pkey->pkey.rsa,padding);\\r\\nif (i < 0)\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,ERR_R_RSA_LIB);\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_b_print_c", "target": 0, "func": "static void\\r\\n_dopr(\\r\\nchar **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *maxlen,\\r\\nsize_t *retlen,\\r\\nint *truncated,\\r\\nconst char *format,\\r\\nva_list args)\\r\\n{\\r\\nchar ch;\\r\\nLLONG value;\\r\\nLDOUBLE fvalue;\\r\\nchar *strvalue;\\r\\nint min;\\r\\nint max;\\r\\nint state;\\r\\nint flags;\\r\\nint cflags;\\r\\nsize_t currlen;\\r\\nstate = DP_S_DEFAULT;\\r\\nflags = currlen = cflags = min = 0;\\r\\nmax = -1;\\r\\nch = *format++;\\r\\nwhile (state != DP_S_DONE) {\\r\\nif (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\\r\\nstate = DP_S_DONE;\\r\\nswitch (state) {\\r\\ncase DP_S_DEFAULT:\\r\\nif (ch == '%')\\r\\nstate = DP_S_FLAGS;\\r\\nelse\\r\\ndoapr_outch(sbuffer,buffer, &currlen, maxlen, ch);\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase DP_S_FLAGS:\\r\\nswitch (ch) {\\r\\ncase '-':\\r\\nflags |= DP_F_MINUS;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '+':\\r\\nflags |= DP_F_PLUS;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase ' ':\\r\\nflags |= DP_F_SPACE;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '#':\\r\\nflags |= DP_F_NUM;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '0':\\r\\nflags |= DP_F_ZERO;\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nstate = DP_S_MIN;\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase DP_S_MIN:\\r\\nif (isdigit((unsigned char)ch)) {\\r\\nmin = 10 * min + char_to_int(ch);\\r\\nch = *format++;\\r\\n} else if (ch == '*') {\\r\\nmin = va_arg(args, int);\\r\\nch = *format++;\\r\\nstate = DP_S_DOT;\\r\\n} else\\r\\nstate = DP_S_DOT;\\r\\nbreak;\\r\\ncase DP_S_DOT:\\r\\nif (ch == '.') {\\r\\nstate = DP_S_MAX;\\r\\nch = *format++;\\r\\n} else\\r\\nstate = DP_S_MOD;\\r\\nbreak;\\r\\ncase DP_S_MAX:\\r\\nif (isdigit((unsigned char)ch)) {\\r\\nif (max < 0)\\r\\nmax = 0;\\r\\nmax = 10 * max + char_to_int(ch);\\r\\nch = *format++;\\r\\n} else if (ch == '*') {\\r\\nmax = va_arg(args, int);\\r\\nch = *format++;\\r\\nstate = DP_S_MOD;\\r\\n} else\\r\\nstate = DP_S_MOD;\\r\\nbreak;\\r\\ncase DP_S_MOD:\\r\\nswitch (ch) {\\r\\ncase 'h':\\r\\ncflags = DP_C_SHORT;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'l':\\r\\nif (*format == 'l') {\\r\\ncflags = DP_C_LLONG;\\r\\nformat++;\\r\\n} else\\r\\ncflags = DP_C_LONG;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'q':\\r\\ncflags = DP_C_LLONG;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'L':\\r\\ncflags = DP_C_LDOUBLE;\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nstate = DP_S_CONV;\\r\\nbreak;\\r\\ncase DP_S_CONV:\\r\\nswitch (ch) {\\r\\ncase 'd':\\r\\ncase 'i':\\r\\nswitch (cflags) {\\r\\ncase DP_C_SHORT:\\r\\nvalue = (short int)va_arg(args, int);\\r\\nbreak;\\r\\ncase DP_C_LONG:\\r\\nvalue = va_arg(args, long int);\\r\\nbreak;\\r\\ncase DP_C_LLONG:\\r\\nvalue = va_arg(args, LLONG);\\r\\nbreak;\\r\\ndefault:\\r\\nvalue = va_arg(args, int);\\r\\nbreak;\\r\\n}\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen,\\r\\nvalue, 10, min, max, flags);\\r\\nbreak;\\r\\ncase 'X':\\r\\nflags |= DP_F_UP;\\r\\ncase 'x':\\r\\ncase 'o':\\r\\ncase 'u':\\r\\nflags |= DP_F_UNSIGNED;\\r\\nswitch (cflags) {\\r\\ncase DP_C_SHORT:\\r\\nvalue = (unsigned short int)va_arg(args, unsigned int);\\r\\nbreak;\\r\\ncase DP_C_LONG:\\r\\nvalue = (LLONG) va_arg(args,\\r\\nunsigned long int);\\r\\nbreak;\\r\\ncase DP_C_LLONG:\\r\\nvalue = va_arg(args, unsigned LLONG);\\r\\nbreak;\\r\\ndefault:\\r\\nvalue = (LLONG) va_arg(args,\\r\\nunsigned int);\\r\\nbreak;\\r\\n}\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen, value,\\r\\nch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\\r\\nmin, max, flags);\\r\\nbreak;\\r\\ncase 'f':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nfmtfp(sbuffer, buffer, &currlen, maxlen,\\r\\nfvalue, min, max, flags);\\r\\nbreak;\\r\\ncase 'E':\\r\\nflags |= DP_F_UP;\\r\\ncase 'e':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nbreak;\\r\\ncase 'G':\\r\\nflags |= DP_F_UP;\\r\\ncase 'g':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nbreak;\\r\\ncase 'c':\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen,\\r\\nva_arg(args, int));\\r\\nbreak;\\r\\ncase 's':\\r\\nstrvalue = va_arg(args, char *);\\r\\nif (max < 0) {\\r\\nif (buffer)\\r\\nmax = INT_MAX;\\r\\nelse\\r\\nmax = *maxlen;\\r\\n}\\r\\nfmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\\r\\nflags, min, max);\\r\\nbreak;\\r\\ncase 'p':\\r\\nvalue = (long)va_arg(args, void *);\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen,\\r\\nvalue, 16, min, max, flags|DP_F_NUM);\\r\\nbreak;\\r\\ncase 'n':\\r\\nif (cflags == DP_C_SHORT) {\\r\\nshort int *num;\\r\\nnum = va_arg(args, short int *);\\r\\n*num = currlen;\\r\\n} else if (cflags == DP_C_LONG) {\\r\\nlong int *num;\\r\\nnum = va_arg(args, long int *);\\r\\n*num = (long int) currlen;\\r\\n} else if (cflags == DP_C_LLONG) {\\r\\nLLONG *num;\\r\\nnum = va_arg(args, LLONG *);\\r\\n*num = (LLONG) currlen;\\r\\n} else {\\r\\nint *num;\\r\\nnum = va_arg(args, int *);\\r\\n*num = currlen;\\r\\n}\\r\\nbreak;\\r\\ncase '%':\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\\r\\nbreak;\\r\\ncase 'w':\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nch = *format++;\\r\\nstate = DP_S_DEFAULT;\\r\\nflags = cflags = min = 0;\\r\\nmax = -1;\\r\\nbreak;\\r\\ncase DP_S_DONE:\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n*truncated = (currlen > *maxlen - 1);\\r\\nif (*truncated)\\r\\ncurrlen = *maxlen - 1;\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, '\\0');\\r\\n*retlen = currlen - 1;\\r\\nreturn;\\r\\n}\\r\\nstatic void\\r\\nfmtstr(\\r\\nchar **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen,\\r\\nconst char *value,\\r\\nint flags,\\r\\nint min,\\r\\nint max)\\r\\n{\\r\\nint padlen, strln;\\r\\nint cnt = 0;\\r\\nif (value == 0)\\r\\nvalue = \"<NULL>\";\\r\\nfor (strln = 0; value[strln]; ++strln)\\r\\n;\\r\\npadlen = min - strln;\\r\\nif (padlen < 0)\\r\\npadlen = 0;\\r\\nif (flags & DP_F_MINUS)\\r\\npadlen = -padlen;\\r\\nwhile ((padlen > 0) && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--padlen;\\r\\n++cnt;\\r\\n}\\r\\nwhile (*value && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *value++);\\r\\n++cnt;\\r\\n}\\r\\nwhile ((padlen < 0) && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++padlen;\\r\\n++cnt;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\nfmtint(\\r\\nchar **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen,\\r\\nLLONG value,\\r\\nint base,\\r\\nint min,\\r\\nint max,\\r\\nint flags)\\r\\n{\\r\\nint signvalue = 0;\\r\\nconst char *prefix = \"\";\\r\\nunsigned LLONG uvalue;\\r\\nchar convert[DECIMAL_SIZE(value)+3];\\r\\nint place = 0;\\r\\nint spadlen = 0;\\r\\nint zpadlen = 0;\\r\\nint caps = 0;\\r\\nif (max < 0)\\r\\nmax = 0;\\r\\nuvalue = value;\\r\\nif (!(flags & DP_F_UNSIGNED)) {\\r\\nif (value < 0) {\\r\\nsignvalue = '-';\\r\\nuvalue = -value;\\r\\n} else if (flags & DP_F_PLUS)\\r\\nsignvalue = '+';\\r\\nelse if (flags & DP_F_SPACE)\\r\\nsignvalue = ' ';\\r\\n}\\r\\nif (flags & DP_F_NUM) {\\r\\nif (base == 8) prefix = \"0\";\\r\\nif (base == 16) prefix = \"0x\";\\r\\n}\\r\\nif (flags & DP_F_UP)\\r\\ncaps = 1;\\r\\ndo {\\r\\nconvert[place++] =\\r\\n(caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")\\r\\n[uvalue % (unsigned) base];\\r\\nuvalue = (uvalue / (unsigned) base);\\r\\n} while (uvalue && (place < (int)sizeof(convert)));\\r\\nif (place == sizeof(convert))\\r\\nplace--;\\r\\nconvert[place] = 0;\\r\\nzpadlen = max - place;\\r\\nspadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);\\r\\nif (zpadlen < 0)\\r\\nzpadlen = 0;\\r\\nif (spadlen < 0)\\r\\nspadlen = 0;\\r\\nif (flags & DP_F_ZERO) {\\r\\nzpadlen = OSSL_MAX(zpadlen, spadlen);\\r\\nspadlen = 0;\\r\\n}\\r\\nif (flags & DP_F_MINUS)\\r\\nspadlen = -spadlen;\\r\\nwhile (spadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--spadlen;\\r\\n}\\r\\nif (signvalue)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\nwhile (*prefix) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);\\r\\nprefix++;\\r\\n}\\r\\nif (zpadlen > 0) {\\r\\nwhile (zpadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--zpadlen;\\r\\n}\\r\\n}\\r\\nwhile (place > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);\\r\\nwhile (spadlen < 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++spadlen;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic LDOUBLE\\r\\nabs_val(LDOUBLE value)\\r\\n{\\r\\nLDOUBLE result = value;\\r\\nif (value < 0)\\r\\nresult = -value;\\r\\nreturn result;\\r\\n}\\r\\nstatic LDOUBLE\\r\\npow_10(int in_exp)\\r\\n{\\r\\nLDOUBLE result = 1;\\r\\nwhile (in_exp) {\\r\\nresult *= 10;\\r\\nin_exp--;\\r\\n}\\r\\nreturn result;\\r\\n}\\r\\nstatic long\\r\\nroundv(LDOUBLE value)\\r\\n{\\r\\nlong intpart;\\r\\nintpart = (long) value;\\r\\nvalue = value - intpart;\\r\\nif (value >= 0.5)\\r\\nintpart++;\\r\\nreturn intpart;\\r\\n}\\r\\nstatic void\\r\\nfmtfp(\\r\\nchar **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen,\\r\\nLDOUBLE fvalue,\\r\\nint min,\\r\\nint max,\\r\\nint flags)\\r\\n{\\r\\nint signvalue = 0;\\r\\nLDOUBLE ufvalue;\\r\\nchar iconvert[20];\\r\\nchar fconvert[20];\\r\\nint iplace = 0;\\r\\nint fplace = 0;\\r\\nint padlen = 0;\\r\\nint zpadlen = 0;\\r\\nint caps = 0;\\r\\nlong intpart;\\r\\nlong fracpart;\\r\\nlong max10;\\r\\nif (max < 0)\\r\\nmax = 6;\\r\\nufvalue = abs_val(fvalue);\\r\\nif (fvalue < 0)\\r\\nsignvalue = '-';\\r\\nelse if (flags & DP_F_PLUS)\\r\\nsignvalue = '+';\\r\\nelse if (flags & DP_F_SPACE)\\r\\nsignvalue = ' ';\\r\\nintpart = (long)ufvalue;\\r\\nif (max > 9)\\r\\nmax = 9;\\r\\nmax10 = roundv(pow_10(max));\\r\\nfracpart = roundv(pow_10(max) * (ufvalue - intpart));\\r\\nif (fracpart >= max10) {\\r\\nintpart++;\\r\\nfracpart -= max10;\\r\\n}\\r\\ndo {\\r\\niconvert[iplace++] =\\r\\n(caps ? \"0123456789ABCDEF\"\\r\\n: \"0123456789abcdef\")[intpart % 10];\\r\\nintpart = (intpart / 10);\\r\\n} while (intpart && (iplace < (int)sizeof(iconvert)));\\r\\nif (iplace == sizeof iconvert)\\r\\niplace--;\\r\\niconvert[iplace] = 0;\\r\\ndo {\\r\\nfconvert[fplace++] =\\r\\n(caps ? \"0123456789ABCDEF\"\\r\\n: \"0123456789abcdef\")[fracpart % 10];\\r\\nfracpart = (fracpart / 10);\\r\\n} while (fplace < max);\\r\\nif (fplace == sizeof fconvert)\\r\\nfplace--;\\r\\nfconvert[fplace] = 0;\\r\\npadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\\r\\nzpadlen = max - fplace;\\r\\nif (zpadlen < 0)\\r\\nzpadlen = 0;\\r\\nif (padlen < 0)\\r\\npadlen = 0;\\r\\nif (flags & DP_F_MINUS)\\r\\npadlen = -padlen;\\r\\nif ((flags & DP_F_ZERO) && (padlen > 0)) {\\r\\nif (signvalue) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\n--padlen;\\r\\nsignvalue = 0;\\r\\n}\\r\\nwhile (padlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--padlen;\\r\\n}\\r\\n}\\r\\nwhile (padlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--padlen;\\r\\n}\\r\\nif (signvalue)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\nwhile (iplace > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);\\r\\nif (max > 0 || (flags & DP_F_NUM)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '.');\\r\\nwhile (fplace > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);\\r\\n}\\r\\nwhile (zpadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--zpadlen;\\r\\n}\\r\\nwhile (padlen < 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++padlen;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\ndoapr_outch(\\r\\nchar **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen,\\r\\nint c)\\r\\n{\\r\\nassert(*sbuffer != NULL || buffer != NULL);\\r\\nif (buffer) {\\r\\nwhile (*currlen >= *maxlen) {\\r\\nif (*buffer == NULL) {\\r\\nif (*maxlen == 0)\\r\\n*maxlen = 1024;\\r\\n*buffer = OPENSSL_malloc(*maxlen);\\r\\nif (*currlen > 0) {\\r\\nassert(*sbuffer != NULL);\\r\\nmemcpy(*buffer, *sbuffer, *currlen);\\r\\n}\\r\\n*sbuffer = NULL;\\r\\n} else {\\r\\n*maxlen += 1024;\\r\\n*buffer = OPENSSL_realloc(*buffer, *maxlen);\\r\\n}\\r\\n}\\r\\nassert(*sbuffer != NULL || *buffer != NULL);\\r\\n}\\r\\nif (*currlen < *maxlen) {\\r\\nif (*sbuffer)\\r\\n(*sbuffer)[(*currlen)++] = (char)c;\\r\\nelse\\r\\n(*buffer)[(*currlen)++] = (char)c;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nint BIO_printf (BIO *bio, const char *format, ...)\\r\\n{\\r\\nva_list args;\\r\\nint ret;\\r\\nva_start(args, format);\\r\\nret = BIO_vprintf(bio, format, args);\\r\\nva_end(args);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_vprintf (BIO *bio, const char *format, va_list args)\\r\\n{\\r\\nint ret;\\r\\nsize_t retlen;\\r\\nchar hugebuf[1024*2];\\r\\nchar *hugebufp = hugebuf;\\r\\nsize_t hugebufsize = sizeof(hugebuf);\\r\\nchar *dynbuf = NULL;\\r\\nint ignored;\\r\\ndynbuf = NULL;\\r\\nCRYPTO_push_info(\"doapr()\");\\r\\n_dopr(&hugebufp, &dynbuf, &hugebufsize,\\r\\n&retlen, &ignored, format, args);\\r\\nif (dynbuf)\\r\\n{\\r\\nret=BIO_write(bio, dynbuf, (int)retlen);\\r\\nOPENSSL_free(dynbuf);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=BIO_write(bio, hugebuf, (int)retlen);\\r\\n}\\r\\nCRYPTO_pop_info();\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\\r\\n{\\r\\nva_list args;\\r\\nint ret;\\r\\nva_start(args, format);\\r\\nret = BIO_vsnprintf(buf, n, format, args);\\r\\nva_end(args);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\\r\\n{\\r\\nsize_t retlen;\\r\\nint truncated;\\r\\n_dopr(&buf, NULL, &n, &retlen, &truncated, format, args);\\r\\nif (truncated)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn (retlen <= INT_MAX) ? (int)retlen : -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_ecb_c", "target": 0, "func": "void CAST_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nCAST_KEY *ks, int enc)\\r\\n{\\r\\nCAST_LONG l,d[2];\\r\\nn2l(in,l); d[0]=l;\\r\\nn2l(in,l); d[1]=l;\\r\\nif (enc)\\r\\nCAST_encrypt(d,ks);\\r\\nelse\\r\\nCAST_decrypt(d,ks);\\r\\nl=d[0]; l2n(l,out);\\r\\nl=d[1]; l2n(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_recp_c", "target": 0, "func": "void BN_RECP_CTX_init(BN_RECP_CTX *recp)\\r\\n{\\r\\nBN_init(&(recp->N));\\r\\nBN_init(&(recp->Nr));\\r\\nrecp->num_bits=0;\\r\\nrecp->flags=0;\\r\\n}\\r\\nBN_RECP_CTX *BN_RECP_CTX_new(void)\\r\\n{\\r\\nBN_RECP_CTX *ret;\\r\\nif ((ret=(BN_RECP_CTX *)OPENSSL_malloc(sizeof(BN_RECP_CTX))) == NULL)\\r\\nreturn(NULL);\\r\\nBN_RECP_CTX_init(ret);\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BN_RECP_CTX_free(BN_RECP_CTX *recp)\\r\\n{\\r\\nif(recp == NULL)\\r\\nreturn;\\r\\nBN_free(&(recp->N));\\r\\nBN_free(&(recp->Nr));\\r\\nif (recp->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(recp);\\r\\n}\\r\\nint BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(&(recp->N),d)) return 0;\\r\\nBN_zero(&(recp->Nr));\\r\\nrecp->num_bits=BN_num_bits(d);\\r\\nrecp->shift=0;\\r\\nreturn(1);\\r\\n}\\r\\nint BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,\\r\\nBN_RECP_CTX *recp, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nBIGNUM *a;\\r\\nconst BIGNUM *ca;\\r\\nBN_CTX_start(ctx);\\r\\nif ((a = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (y != NULL)\\r\\n{\\r\\nif (x == y)\\r\\n{ if (!BN_sqr(a,x,ctx)) goto err; }\\r\\nelse\\r\\n{ if (!BN_mul(a,x,y,ctx)) goto err; }\\r\\nca = a;\\r\\n}\\r\\nelse\\r\\nca=x;\\r\\nret = BN_div_recp(NULL,r,ca,recp,ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,\\r\\nBN_RECP_CTX *recp, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,ret=0;\\r\\nBIGNUM *a,*b,*d,*r;\\r\\nBN_CTX_start(ctx);\\r\\na=BN_CTX_get(ctx);\\r\\nb=BN_CTX_get(ctx);\\r\\nif (dv != NULL)\\r\\nd=dv;\\r\\nelse\\r\\nd=BN_CTX_get(ctx);\\r\\nif (rem != NULL)\\r\\nr=rem;\\r\\nelse\\r\\nr=BN_CTX_get(ctx);\\r\\nif (a == NULL || b == NULL || d == NULL || r == NULL) goto err;\\r\\nif (BN_ucmp(m,&(recp->N)) < 0)\\r\\n{\\r\\nBN_zero(d);\\r\\nif (!BN_copy(r,m)) return 0;\\r\\nBN_CTX_end(ctx);\\r\\nreturn(1);\\r\\n}\\r\\ni=BN_num_bits(m);\\r\\nj=recp->num_bits<<1;\\r\\nif (j>i) i=j;\\r\\nif (i != recp->shift)\\r\\nrecp->shift=BN_reciprocal(&(recp->Nr),&(recp->N),\\r\\ni,ctx);\\r\\nif (recp->shift == -1) goto err;\\r\\nif (!BN_rshift(a,m,recp->num_bits)) goto err;\\r\\nif (!BN_mul(b,a,&(recp->Nr),ctx)) goto err;\\r\\nif (!BN_rshift(d,b,i-recp->num_bits)) goto err;\\r\\nd->neg=0;\\r\\nif (!BN_mul(b,&(recp->N),d,ctx)) goto err;\\r\\nif (!BN_usub(r,m,b)) goto err;\\r\\nr->neg=0;\\r\\n#if 1\\r\\nj=0;\\r\\nwhile (BN_ucmp(r,&(recp->N)) >= 0)\\r\\n{\\r\\nif (j++ > 2)\\r\\n{\\r\\nBNerr(BN_F_BN_DIV_RECP,BN_R_BAD_RECIPROCAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_usub(r,r,&(recp->N))) goto err;\\r\\nif (!BN_add_word(d,1)) goto err;\\r\\n}\\r\\n#endif\\r\\nr->neg=BN_is_zero(r)?0:m->neg;\\r\\nd->neg=m->neg^recp->N.neg;\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif(dv) bn_check_top(dv);\\r\\nif(rem) bn_check_top(rem);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx)\\r\\n{\\r\\nint ret= -1;\\r\\nBIGNUM *t;\\r\\nBN_CTX_start(ctx);\\r\\nif((t = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!BN_set_bit(t,len)) goto err;\\r\\nif (!BN_div(r,NULL,t,m,ctx)) goto err;\\r\\nret=len;\\r\\nerr:\\r\\nbn_check_top(r);\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2_ecb_c", "target": 0, "func": "void RC2_ecb_encrypt(const unsigned char *in, unsigned char *out, RC2_KEY *ks,\\r\\nint encrypt)\\r\\n{\\r\\nunsigned long l,d[2];\\r\\nc2l(in,l); d[0]=l;\\r\\nc2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nRC2_encrypt(d,ks);\\r\\nelse\\r\\nRC2_decrypt(d,ks);\\r\\nl=d[0]; l2c(l,out);\\r\\nl=d[1]; l2c(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_des_old_c", "target": 0, "func": "const char *_ossl_old_des_options(void)\\r\\n{\\r\\nreturn DES_options();\\r\\n}\\r\\nvoid _ossl_old_des_ecb3_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,\\r\\ndes_key_schedule ks1,des_key_schedule ks2,\\r\\ndes_key_schedule ks3, int enc)\\r\\n{\\r\\nDES_ecb3_encrypt((const_DES_cblock *)input, output,\\r\\n(DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3, enc);\\r\\n}\\r\\nDES_LONG _ossl_old_des_cbc_cksum(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,\\r\\nlong length,des_key_schedule schedule,_ossl_old_des_cblock *ivec)\\r\\n{\\r\\nreturn DES_cbc_cksum((unsigned char *)input, output, length,\\r\\n(DES_key_schedule *)schedule, ivec);\\r\\n}\\r\\nvoid _ossl_old_des_cbc_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,long length,\\r\\ndes_key_schedule schedule,_ossl_old_des_cblock *ivec,int enc)\\r\\n{\\r\\nDES_cbc_encrypt((unsigned char *)input, (unsigned char *)output,\\r\\nlength, (DES_key_schedule *)schedule, ivec, enc);\\r\\n}\\r\\nvoid _ossl_old_des_ncbc_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,long length,\\r\\ndes_key_schedule schedule,_ossl_old_des_cblock *ivec,int enc)\\r\\n{\\r\\nDES_ncbc_encrypt((unsigned char *)input, (unsigned char *)output,\\r\\nlength, (DES_key_schedule *)schedule, ivec, enc);\\r\\n}\\r\\nvoid _ossl_old_des_xcbc_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,long length,\\r\\ndes_key_schedule schedule,_ossl_old_des_cblock *ivec,\\r\\n_ossl_old_des_cblock *inw,_ossl_old_des_cblock *outw,int enc)\\r\\n{\\r\\nDES_xcbc_encrypt((unsigned char *)input, (unsigned char *)output,\\r\\nlength, (DES_key_schedule *)schedule, ivec, inw, outw, enc);\\r\\n}\\r\\nvoid _ossl_old_des_cfb_encrypt(unsigned char *in,unsigned char *out,int numbits,\\r\\nlong length,des_key_schedule schedule,_ossl_old_des_cblock *ivec,int enc)\\r\\n{\\r\\nDES_cfb_encrypt(in, out, numbits, length,\\r\\n(DES_key_schedule *)schedule, ivec, enc);\\r\\n}\\r\\nvoid _ossl_old_des_ecb_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,\\r\\ndes_key_schedule ks,int enc)\\r\\n{\\r\\nDES_ecb_encrypt(input, output, (DES_key_schedule *)ks, enc);\\r\\n}\\r\\nvoid _ossl_old_des_encrypt(DES_LONG *data,des_key_schedule ks, int enc)\\r\\n{\\r\\nDES_encrypt1(data, (DES_key_schedule *)ks, enc);\\r\\n}\\r\\nvoid _ossl_old_des_encrypt2(DES_LONG *data,des_key_schedule ks, int enc)\\r\\n{\\r\\nDES_encrypt2(data, (DES_key_schedule *)ks, enc);\\r\\n}\\r\\nvoid _ossl_old_des_encrypt3(DES_LONG *data, des_key_schedule ks1,\\r\\ndes_key_schedule ks2, des_key_schedule ks3)\\r\\n{\\r\\nDES_encrypt3(data, (DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3);\\r\\n}\\r\\nvoid _ossl_old_des_decrypt3(DES_LONG *data, des_key_schedule ks1,\\r\\ndes_key_schedule ks2, des_key_schedule ks3)\\r\\n{\\r\\nDES_decrypt3(data, (DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3);\\r\\n}\\r\\nvoid _ossl_old_des_ede3_cbc_encrypt(_ossl_old_des_cblock *input, _ossl_old_des_cblock *output,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, _ossl_old_des_cblock *ivec, int enc)\\r\\n{\\r\\nDES_ede3_cbc_encrypt((unsigned char *)input, (unsigned char *)output,\\r\\nlength, (DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3, ivec, enc);\\r\\n}\\r\\nvoid _ossl_old_des_ede3_cfb64_encrypt(unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, _ossl_old_des_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nDES_ede3_cfb64_encrypt(in, out, length,\\r\\n(DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3, ivec, num, enc);\\r\\n}\\r\\nvoid _ossl_old_des_ede3_ofb64_encrypt(unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, _ossl_old_des_cblock *ivec, int *num)\\r\\n{\\r\\nDES_ede3_ofb64_encrypt(in, out, length,\\r\\n(DES_key_schedule *)ks1, (DES_key_schedule *)ks2,\\r\\n(DES_key_schedule *)ks3, ivec, num);\\r\\n}\\r\\nint _ossl_old_des_enc_read(int fd,char *buf,int len,des_key_schedule sched,\\r\\n_ossl_old_des_cblock *iv)\\r\\n{\\r\\nreturn DES_enc_read(fd, buf, len, (DES_key_schedule *)sched, iv);\\r\\n}\\r\\nint _ossl_old_des_enc_write(int fd,char *buf,int len,des_key_schedule sched,\\r\\n_ossl_old_des_cblock *iv)\\r\\n{\\r\\nreturn DES_enc_write(fd, buf, len, (DES_key_schedule *)sched, iv);\\r\\n}\\r\\nchar *_ossl_old_des_fcrypt(const char *buf,const char *salt, char *ret)\\r\\n{\\r\\nreturn DES_fcrypt(buf, salt, ret);\\r\\n}\\r\\nchar *_ossl_old_des_crypt(const char *buf,const char *salt)\\r\\n{\\r\\nreturn DES_crypt(buf, salt);\\r\\n}\\r\\nchar *_ossl_old_crypt(const char *buf,const char *salt)\\r\\n{\\r\\nreturn DES_crypt(buf, salt);\\r\\n}\\r\\nvoid _ossl_old_des_ofb_encrypt(unsigned char *in,unsigned char *out,\\r\\nint numbits,long length,des_key_schedule schedule,_ossl_old_des_cblock *ivec)\\r\\n{\\r\\nDES_ofb_encrypt(in, out, numbits, length, (DES_key_schedule *)schedule,\\r\\nivec);\\r\\n}\\r\\nvoid _ossl_old_des_pcbc_encrypt(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,long length,\\r\\ndes_key_schedule schedule,_ossl_old_des_cblock *ivec,int enc)\\r\\n{\\r\\nDES_pcbc_encrypt((unsigned char *)input, (unsigned char *)output,\\r\\nlength, (DES_key_schedule *)schedule, ivec, enc);\\r\\n}\\r\\nDES_LONG _ossl_old_des_quad_cksum(_ossl_old_des_cblock *input,_ossl_old_des_cblock *output,\\r\\nlong length,int out_count,_ossl_old_des_cblock *seed)\\r\\n{\\r\\nreturn DES_quad_cksum((unsigned char *)input, output, length,\\r\\nout_count, seed);\\r\\n}\\r\\nvoid _ossl_old_des_random_seed(_ossl_old_des_cblock key)\\r\\n{\\r\\nRAND_seed(key, sizeof(_ossl_old_des_cblock));\\r\\n}\\r\\nvoid _ossl_old_des_random_key(_ossl_old_des_cblock ret)\\r\\n{\\r\\nDES_random_key((DES_cblock *)ret);\\r\\n}\\r\\nint _ossl_old_des_read_password(_ossl_old_des_cblock *key, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nreturn DES_read_password(key, prompt, verify);\\r\\n}\\r\\nint _ossl_old_des_read_2passwords(_ossl_old_des_cblock *key1, _ossl_old_des_cblock *key2,\\r\\nconst char *prompt, int verify)\\r\\n{\\r\\nreturn DES_read_2passwords(key1, key2, prompt, verify);\\r\\n}\\r\\nvoid _ossl_old_des_set_odd_parity(_ossl_old_des_cblock *key)\\r\\n{\\r\\nDES_set_odd_parity(key);\\r\\n}\\r\\nint _ossl_old_des_is_weak_key(_ossl_old_des_cblock *key)\\r\\n{\\r\\nreturn DES_is_weak_key(key);\\r\\n}\\r\\nint _ossl_old_des_set_key(_ossl_old_des_cblock *key,des_key_schedule schedule)\\r\\n{\\r\\nreturn DES_set_key(key, (DES_key_schedule *)schedule);\\r\\n}\\r\\nint _ossl_old_des_key_sched(_ossl_old_des_cblock *key,des_key_schedule schedule)\\r\\n{\\r\\nreturn DES_key_sched(key, (DES_key_schedule *)schedule);\\r\\n}\\r\\nvoid _ossl_old_des_string_to_key(char *str,_ossl_old_des_cblock *key)\\r\\n{\\r\\nDES_string_to_key(str, key);\\r\\n}\\r\\nvoid _ossl_old_des_string_to_2keys(char *str,_ossl_old_des_cblock *key1,_ossl_old_des_cblock *key2)\\r\\n{\\r\\nDES_string_to_2keys(str, key1, key2);\\r\\n}\\r\\nvoid _ossl_old_des_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\ndes_key_schedule schedule, _ossl_old_des_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nDES_cfb64_encrypt(in, out, length, (DES_key_schedule *)schedule,\\r\\nivec, num, enc);\\r\\n}\\r\\nvoid _ossl_old_des_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\ndes_key_schedule schedule, _ossl_old_des_cblock *ivec, int *num)\\r\\n{\\r\\nDES_ofb64_encrypt(in, out, length, (DES_key_schedule *)schedule,\\r\\nivec, num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_cbc_c", "target": 0, "func": "void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst unsigned long length, const AES_KEY *key,\\r\\nunsigned char *ivec, const int enc) {\\r\\nunsigned long n;\\r\\nunsigned long len = length;\\r\\nunsigned char tmp[AES_BLOCK_SIZE];\\r\\nconst unsigned char *iv = ivec;\\r\\nassert(in && out && key && ivec);\\r\\nassert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));\\r\\nif (AES_ENCRYPT == enc) {\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nfor(n=0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] = in[n] ^ iv[n];\\r\\nAES_encrypt(out, out, key);\\r\\niv = out;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nif (len) {\\r\\nfor(n=0; n < len; ++n)\\r\\nout[n] = in[n] ^ iv[n];\\r\\nfor(n=len; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] = iv[n];\\r\\nAES_encrypt(out, out, key);\\r\\niv = out;\\r\\n}\\r\\nmemcpy(ivec,iv,AES_BLOCK_SIZE);\\r\\n} else if (in != out) {\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nAES_decrypt(in, out, key);\\r\\nfor(n=0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv[n];\\r\\niv = in;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nif (len) {\\r\\nAES_decrypt(in,tmp,key);\\r\\nfor(n=0; n < len; ++n)\\r\\nout[n] = tmp[n] ^ iv[n];\\r\\niv = in;\\r\\n}\\r\\nmemcpy(ivec,iv,AES_BLOCK_SIZE);\\r\\n} else {\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nmemcpy(tmp, in, AES_BLOCK_SIZE);\\r\\nAES_decrypt(in, out, key);\\r\\nfor(n=0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= ivec[n];\\r\\nmemcpy(ivec, tmp, AES_BLOCK_SIZE);\\r\\nlen -= AES_BLOCK_SIZE;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nif (len) {\\r\\nmemcpy(tmp, in, AES_BLOCK_SIZE);\\r\\nAES_decrypt(tmp, out, key);\\r\\nfor(n=0; n < len; ++n)\\r\\nout[n] ^= ivec[n];\\r\\nfor(n=len; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] = tmp[n];\\r\\nmemcpy(ivec, tmp, AES_BLOCK_SIZE);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_zlib_c", "target": 0, "func": "static void zlib_stateful_free_ex_data(void *obj, void *item,\\r\\nCRYPTO_EX_DATA *ad, int ind,long argl, void *argp)\\r\\n{\\r\\nstruct zlib_state *state = (struct zlib_state *)item;\\r\\ninflateEnd(&state->istream);\\r\\ndeflateEnd(&state->ostream);\\r\\nOPENSSL_free(state);\\r\\n}\\r\\nstatic int zlib_stateful_init(COMP_CTX *ctx)\\r\\n{\\r\\nint err;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));\\r\\nif (state == NULL)\\r\\ngoto err;\\r\\nstate->istream.zalloc = Z_NULL;\\r\\nstate->istream.zfree = Z_NULL;\\r\\nstate->istream.opaque = Z_NULL;\\r\\nstate->istream.next_in = Z_NULL;\\r\\nstate->istream.next_out = Z_NULL;\\r\\nstate->istream.avail_in = 0;\\r\\nstate->istream.avail_out = 0;\\r\\nerr = inflateInit_(&state->istream,\\r\\nZLIB_VERSION, sizeof(z_stream));\\r\\nif (err != Z_OK)\\r\\ngoto err;\\r\\nstate->ostream.zalloc = Z_NULL;\\r\\nstate->ostream.zfree = Z_NULL;\\r\\nstate->ostream.opaque = Z_NULL;\\r\\nstate->ostream.next_in = Z_NULL;\\r\\nstate->ostream.next_out = Z_NULL;\\r\\nstate->ostream.avail_in = 0;\\r\\nstate->ostream.avail_out = 0;\\r\\nerr = deflateInit_(&state->ostream,Z_DEFAULT_COMPRESSION,\\r\\nZLIB_VERSION, sizeof(z_stream));\\r\\nif (err != Z_OK)\\r\\ngoto err;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\\r\\nif (zlib_stateful_ex_idx == -1)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_COMP);\\r\\nif (zlib_stateful_ex_idx == -1)\\r\\nzlib_stateful_ex_idx =\\r\\nCRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,\\r\\n0,NULL,NULL,NULL,zlib_stateful_free_ex_data);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_COMP);\\r\\nif (zlib_stateful_ex_idx == -1)\\r\\ngoto err;\\r\\n}\\r\\nCRYPTO_set_ex_data(&ctx->ex_data,zlib_stateful_ex_idx,state);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (state) OPENSSL_free(state);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void zlib_stateful_finish(COMP_CTX *ctx)\\r\\n{\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\\r\\n}\\r\\nstatic int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nint err = Z_OK;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\\r\\nzlib_stateful_ex_idx);\\r\\nif (state == NULL)\\r\\nreturn -1;\\r\\nstate->ostream.next_in = in;\\r\\nstate->ostream.avail_in = ilen;\\r\\nstate->ostream.next_out = out;\\r\\nstate->ostream.avail_out = olen;\\r\\nif (ilen > 0)\\r\\nerr = deflate(&state->ostream, Z_SYNC_FLUSH);\\r\\nif (err != Z_OK)\\r\\nreturn -1;\\r\\n#ifdef DEBUG_ZLIB\\r\\nfprintf(stderr,\"compress(%4d)->%4d %s\\n\",\\r\\nilen,olen - state->ostream.avail_out,\\r\\n(ilen != olen - state->ostream.avail_out)?\"zlib\":\"clear\");\\r\\n#endif\\r\\nreturn olen - state->ostream.avail_out;\\r\\n}\\r\\nstatic int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nint err = Z_OK;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\\r\\nzlib_stateful_ex_idx);\\r\\nif (state == NULL)\\r\\nreturn 0;\\r\\nstate->istream.next_in = in;\\r\\nstate->istream.avail_in = ilen;\\r\\nstate->istream.next_out = out;\\r\\nstate->istream.avail_out = olen;\\r\\nif (ilen > 0)\\r\\nerr = inflate(&state->istream, Z_SYNC_FLUSH);\\r\\nif (err != Z_OK)\\r\\nreturn -1;\\r\\n#ifdef DEBUG_ZLIB\\r\\nfprintf(stderr,\"expand(%4d)->%4d %s\\n\",\\r\\nilen,olen - state->istream.avail_out,\\r\\n(ilen != olen - state->istream.avail_out)?\"zlib\":\"clear\");\\r\\n#endif\\r\\nreturn olen - state->istream.avail_out;\\r\\n}\\r\\nCOMP_METHOD *COMP_zlib(void)\\r\\n{\\r\\nCOMP_METHOD *meth = &zlib_method_nozlib;\\r\\n#ifdef ZLIB_SHARED\\r\\nif (!zlib_loaded)\\r\\n{\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)\\r\\nzlib_dso = DSO_load(NULL, \"ZLIB1\", NULL, 0);\\r\\nif (!zlib_dso)\\r\\n{\\r\\nzlib_dso = DSO_load(NULL, \"ZLIB\", NULL, 0);\\r\\nif (zlib_dso)\\r\\n{\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\n#else\\r\\nzlib_dso = DSO_load(NULL, \"z\", NULL, 0);\\r\\n#endif\\r\\nif (zlib_dso != NULL)\\r\\n{\\r\\np_compress\\r\\n= (compress_ft) DSO_bind_func(zlib_dso,\\r\\n\"compress\");\\r\\np_inflateEnd\\r\\n= (inflateEnd_ft) DSO_bind_func(zlib_dso,\\r\\n\"inflateEnd\");\\r\\np_inflate\\r\\n= (inflate_ft) DSO_bind_func(zlib_dso,\\r\\n\"inflate\");\\r\\np_inflateInit_\\r\\n= (inflateInit__ft) DSO_bind_func(zlib_dso,\\r\\n\"inflateInit_\");\\r\\np_deflateEnd\\r\\n= (deflateEnd_ft) DSO_bind_func(zlib_dso,\\r\\n\"deflateEnd\");\\r\\np_deflate\\r\\n= (deflate_ft) DSO_bind_func(zlib_dso,\\r\\n\"deflate\");\\r\\np_deflateInit_\\r\\n= (deflateInit__ft) DSO_bind_func(zlib_dso,\\r\\n\"deflateInit_\");\\r\\nzlib_loaded++;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#if defined(ZLIB) || defined(ZLIB_SHARED)\\r\\nmeth = &zlib_stateful_method;\\r\\n#endif\\r\\nreturn(meth);\\r\\n}\\r\\nstatic int\\r\\nstub_inflateEnd(z_streamp strm)\\r\\n{\\r\\nif ( p_inflateEnd )\\r\\nreturn(p_inflateEnd(strm));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}\\r\\nstatic int\\r\\nstub_inflate(z_streamp strm, int flush)\\r\\n{\\r\\nif ( p_inflate )\\r\\nreturn(p_inflate(strm,flush));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}\\r\\nstatic int\\r\\nstub_inflateInit_(z_streamp strm, const char * version, int stream_size)\\r\\n{\\r\\nif ( p_inflateInit_ )\\r\\nreturn(p_inflateInit_(strm,version,stream_size));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}\\r\\nstatic int\\r\\nstub_deflateEnd(z_streamp strm)\\r\\n{\\r\\nif ( p_deflateEnd )\\r\\nreturn(p_deflateEnd(strm));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}\\r\\nstatic int\\r\\nstub_deflate(z_streamp strm, int flush)\\r\\n{\\r\\nif ( p_deflate )\\r\\nreturn(p_deflate(strm,flush));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}\\r\\nstatic int\\r\\nstub_deflateInit_(z_streamp strm, int level,\\r\\nconst char * version, int stream_size)\\r\\n{\\r\\nif ( p_deflateInit_ )\\r\\nreturn(p_deflateInit_(strm,level,version,stream_size));\\r\\nelse\\r\\nreturn(Z_MEM_ERROR);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_enc_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nX509 *x509;\\r\\nPKCS7 *p7;\\r\\nBIO *in;\\r\\nBIO *data,*p7bio;\\r\\nchar buf[1024*4];\\r\\nint i;\\r\\nint nodetach=1;\\r\\nchar *keyfile = NULL;\\r\\nconst EVP_CIPHER *cipher=NULL;\\r\\nSTACK_OF(X509) *recips=NULL;\\r\\nOpenSSL_add_all_algorithms();\\r\\ndata=BIO_new(BIO_s_file());\\r\\nwhile(argc > 1)\\r\\n{\\r\\nif (strcmp(argv[1],\"-nd\") == 0)\\r\\n{\\r\\nnodetach=1;\\r\\nargv++; argc--;\\r\\n}\\r\\nelse if ((strcmp(argv[1],\"-c\") == 0) && (argc >= 2)) {\\r\\nif(!(cipher = EVP_get_cipherbyname(argv[2]))) {\\r\\nfprintf(stderr, \"Unknown cipher %s\\n\", argv[2]);\\r\\ngoto err;\\r\\n}\\r\\nargc-=2;\\r\\nargv+=2;\\r\\n} else if ((strcmp(argv[1],\"-k\") == 0) && (argc >= 2)) {\\r\\nkeyfile = argv[2];\\r\\nargc-=2;\\r\\nargv+=2;\\r\\nif (!(in=BIO_new_file(keyfile,\"r\"))) goto err;\\r\\nif (!(x509=PEM_read_bio_X509(in,NULL,NULL,NULL)))\\r\\ngoto err;\\r\\nif(!recips) recips = sk_X509_new_null();\\r\\nsk_X509_push(recips, x509);\\r\\nBIO_free(in);\\r\\n} else break;\\r\\n}\\r\\nif(!recips) {\\r\\nfprintf(stderr, \"No recipients\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[1])) goto err;\\r\\np7=PKCS7_new();\\r\\n#if 0\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_free(in);\\r\\nPKCS7_set_type(p7,NID_pkcs7_signedAndEnveloped);\\r\\nif (PKCS7_add_signature(p7,x509,pkey,EVP_sha1()) == NULL) goto err;\\r\\nPKCS7_add_certificate(p7,x509);\\r\\n#else\\r\\nPKCS7_set_type(p7,NID_pkcs7_enveloped);\\r\\n#endif\\r\\nif(!cipher) {\\r\\n#ifndef OPENSSL_NO_DES\\r\\ncipher = EVP_des_ede3_cbc();\\r\\n#else\\r\\nfprintf(stderr, \"No cipher selected\\n\");\\r\\ngoto err;\\r\\n#endif\\r\\n}\\r\\nif (!PKCS7_set_cipher(p7,cipher)) goto err;\\r\\nfor(i = 0; i < sk_X509_num(recips); i++) {\\r\\nif (!PKCS7_add_recipient(p7,sk_X509_value(recips, i))) goto err;\\r\\n}\\r\\nsk_X509_pop_free(recips, X509_free);\\r\\nif ((p7bio=PKCS7_dataInit(p7,NULL)) == NULL) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(data,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nBIO_write(p7bio,buf,i);\\r\\n}\\r\\nBIO_flush(p7bio);\\r\\nif (!PKCS7_dataFinal(p7,p7bio)) goto err;\\r\\nBIO_free(p7bio);\\r\\nPEM_write_PKCS7(stdout,p7);\\r\\nPKCS7_free(p7);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_cvt_c", "target": 0, "func": "EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_METHOD *meth;\\r\\nEC_GROUP *ret;\\r\\nmeth = EC_GFp_nist_method();\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GFp(ret, p, a, b, ctx))\\r\\n{\\r\\nunsigned long err;\\r\\nerr = ERR_peek_last_error();\\r\\nif (!(ERR_GET_LIB(err) == ERR_LIB_EC &&\\r\\n((ERR_GET_REASON(err) == EC_R_NOT_A_NIST_PRIME) ||\\r\\n(ERR_GET_REASON(err) == EC_R_NOT_A_SUPPORTED_NIST_PRIME))))\\r\\n{\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nERR_clear_error();\\r\\nEC_GROUP_clear_free(ret);\\r\\nmeth = EC_GFp_mont_method();\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GFp(ret, p, a, b, ctx))\\r\\n{\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_METHOD *meth;\\r\\nEC_GROUP *ret;\\r\\nmeth = EC_GF2m_simple_method();\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GF2m(ret, p, a, b, ctx))\\r\\n{\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s_socket_c", "target": 0, "func": "static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,\\r\\nLPARAM lParam)\\r\\n{\\r\\nif (hwnd == topWnd)\\r\\n{\\r\\nswitch(message)\\r\\n{\\r\\ncase WM_DESTROY:\\r\\ncase WM_CLOSE:\\r\\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopWndProc);\\r\\nssl_sock_cleanup();\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn CallWindowProc(lpTopWndProc,hwnd,message,wParam,lParam);\\r\\n}\\r\\nstatic BOOL CALLBACK enumproc(HWND hwnd,LPARAM lParam)\\r\\n{\\r\\ntopWnd=hwnd;\\r\\nreturn(FALSE);\\r\\n}\\r\\nstatic void ssl_sock_cleanup(void)\\r\\n{\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\n#ifndef OPENSSL_SYS_WINCE\\r\\nWSACancelBlockingCall();\\r\\n#endif\\r\\nWSACleanup();\\r\\n}\\r\\n}\\r\\nstatic void sock_cleanup(void)\\r\\n{\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\nWSACleanup();\\r\\n}\\r\\n}\\r\\nstatic int ssl_sock_init(void)\\r\\n{\\r\\n#ifdef WATT32\\r\\nextern int _watt_do_exit;\\r\\n_watt_do_exit = 0;\\r\\nif (sock_init())\\r\\nreturn (0);\\r\\n#elif defined(OPENSSL_SYS_WINDOWS)\\r\\nif (!wsa_init_done)\\r\\n{\\r\\nint err;\\r\\n#ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))ssl_sock_cleanup);\\r\\n#endif\\r\\nwsa_init_done=1;\\r\\nmemset(&wsa_state,0,sizeof(wsa_state));\\r\\nif (WSAStartup(0x0101,&wsa_state)!=0)\\r\\n{\\r\\nerr=WSAGetLastError();\\r\\nBIO_printf(bio_err,\"unable to start WINSOCK, error code=%d\\n\",err);\\r\\nreturn(0);\\r\\n}\\r\\n#ifdef OPENSSL_SYS_WIN16\\r\\nEnumTaskWindows(GetCurrentTask(),enumproc,0L);\\r\\nlpTopWndProc=(FARPROC)GetWindowLong(topWnd,GWL_WNDPROC);\\r\\nlpTopHookProc=MakeProcInstance((FARPROC)topHookProc,_hInstance);\\r\\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopHookProc);\\r\\n#endif\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nWORD wVerReq;\\r\\nWSADATA wsaData;\\r\\nint err;\\r\\nif (!wsa_init_done)\\r\\n{\\r\\n# ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))sock_cleanup);\\r\\n# endif\\r\\nwsa_init_done=1;\\r\\nwVerReq = MAKEWORD( 2, 0 );\\r\\nerr = WSAStartup(wVerReq,&wsaData);\\r\\nif (err != 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to start WINSOCK2, error code=%d\\n\",err);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nint init_client(int *sock, char *host, int port, int type)\\r\\n{\\r\\nunsigned char ip[4];\\r\\nshort p=0;\\r\\nif (!host_ip(host,&(ip[0])))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nif (p != 0) port=p;\\r\\nreturn(init_client_ip(sock,ip,port,type));\\r\\n}\\r\\nstatic int init_client_ip(int *sock, unsigned char ip[4], int port, int type)\\r\\n{\\r\\nunsigned long addr;\\r\\nstruct sockaddr_in them;\\r\\nint s,i;\\r\\nif (!ssl_sock_init()) return(0);\\r\\nmemset((char *)&them,0,sizeof(them));\\r\\nthem.sin_family=AF_INET;\\r\\nthem.sin_port=htons((unsigned short)port);\\r\\naddr=(unsigned long)\\r\\n((unsigned long)ip[0]<<24L)|\\r\\n((unsigned long)ip[1]<<16L)|\\r\\n((unsigned long)ip[2]<< 8L)|\\r\\n((unsigned long)ip[3]);\\r\\nthem.sin_addr.s_addr=htonl(addr);\\r\\nif (type == SOCK_STREAM)\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nelse\\r\\ns=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);\\r\\nif (s == INVALID_SOCKET) { perror(\"socket\"); return(0); }\\r\\n#ifndef OPENSSL_SYS_MPE\\r\\nif (type == SOCK_STREAM)\\r\\n{\\r\\ni=0;\\r\\ni=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\\r\\nif (i < 0) { perror(\"keepalive\"); return(0); }\\r\\n}\\r\\n#endif\\r\\nif (connect(s,(struct sockaddr *)&them,sizeof(them)) == -1)\\r\\n{ close(s); perror(\"connect\"); return(0); }\\r\\n*sock=s;\\r\\nreturn(1);\\r\\n}\\r\\nint do_server(int port, int type, int *ret, int (*cb)(char *hostname, int s, unsigned char *context), unsigned char *context)\\r\\n{\\r\\nint sock;\\r\\nchar *name = NULL;\\r\\nint accept_socket;\\r\\nint i;\\r\\nif (!init_server(&accept_socket,port,type)) return(0);\\r\\nif (ret != NULL)\\r\\n{\\r\\n*ret=accept_socket;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nif (type==SOCK_STREAM)\\r\\n{\\r\\nif (do_accept(accept_socket,&sock,&name) == 0)\\r\\n{\\r\\nSHUTDOWN(accept_socket);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\nsock = accept_socket;\\r\\ni=(*cb)(name,sock, context);\\r\\nif (name != NULL) OPENSSL_free(name);\\r\\nif (type==SOCK_STREAM)\\r\\nSHUTDOWN2(sock);\\r\\nif (i < 0)\\r\\n{\\r\\nSHUTDOWN2(accept_socket);\\r\\nreturn(i);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int init_server_long(int *sock, int port, char *ip, int type)\\r\\n{\\r\\nint ret=0;\\r\\nstruct sockaddr_in server;\\r\\nint s= -1,i;\\r\\nif (!ssl_sock_init()) return(0);\\r\\nmemset((char *)&server,0,sizeof(server));\\r\\nserver.sin_family=AF_INET;\\r\\nserver.sin_port=htons((unsigned short)port);\\r\\nif (ip == NULL)\\r\\nserver.sin_addr.s_addr=INADDR_ANY;\\r\\nelse\\r\\n#ifndef BIT_FIELD_LIMITS\\r\\nmemcpy(&server.sin_addr.s_addr,ip,4);\\r\\n#else\\r\\nmemcpy(&server.sin_addr,ip,4);\\r\\n#endif\\r\\nif (type == SOCK_STREAM)\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nelse\\r\\ns=socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);\\r\\nif (s == INVALID_SOCKET) goto err;\\r\\n#if defined SOL_SOCKET && defined SO_REUSEADDR\\r\\n{\\r\\nint j = 1;\\r\\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR,\\r\\n(void *) &j, sizeof j);\\r\\n}\\r\\n#endif\\r\\nif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\\r\\n{\\r\\n#ifndef OPENSSL_SYS_WINDOWS\\r\\nperror(\"bind\");\\r\\n#endif\\r\\ngoto err;\\r\\n}\\r\\nif (type==SOCK_STREAM && listen(s,128) == -1) goto err;\\r\\ni=0;\\r\\n*sock=s;\\r\\nret=1;\\r\\nerr:\\r\\nif ((ret == 0) && (s != -1))\\r\\n{\\r\\nSHUTDOWN(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int init_server(int *sock, int port, int type)\\r\\n{\\r\\nreturn(init_server_long(sock, port, NULL, type));\\r\\n}\\r\\nstatic int do_accept(int acc_sock, int *sock, char **host)\\r\\n{\\r\\nint ret,i;\\r\\nstruct hostent *h1,*h2;\\r\\nstatic struct sockaddr_in from;\\r\\nint len;\\r\\nif (!ssl_sock_init()) return(0);\\r\\n#ifndef OPENSSL_SYS_WINDOWS\\r\\nredoit:\\r\\n#endif\\r\\nmemset((char *)&from,0,sizeof(from));\\r\\nlen=sizeof(from);\\r\\nret=accept(acc_sock,(struct sockaddr *)&from,(void *)&len);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))\\r\\ni=WSAGetLastError();\\r\\nBIO_printf(bio_err,\"accept error %d\\n\",i);\\r\\n#else\\r\\nif (errno == EINTR)\\r\\n{\\r\\ngoto redoit;\\r\\n}\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"accept\");\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nif (host == NULL) goto end;\\r\\n#ifndef BIT_FIELD_LIMITS\\r\\nh1=gethostbyaddr((char *)&from.sin_addr.s_addr,\\r\\nsizeof(from.sin_addr.s_addr),AF_INET);\\r\\n#else\\r\\nh1=gethostbyaddr((char *)&from.sin_addr,\\r\\nsizeof(struct in_addr),AF_INET);\\r\\n#endif\\r\\nif (h1 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"bad gethostbyaddr\\n\");\\r\\n*host=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((*host=(char *)OPENSSL_malloc(strlen(h1->h_name)+1)) == NULL)\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\nreturn(0);\\r\\n}\\r\\nBUF_strlcpy(*host,h1->h_name,strlen(h1->h_name)+1);\\r\\nh2=GetHostByName(*host);\\r\\nif (h2 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname failure\\n\");\\r\\nreturn(0);\\r\\n}\\r\\ni=0;\\r\\nif (h2->h_addrtype != AF_INET)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname addr is not AF_INET\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nend:\\r\\n*sock=ret;\\r\\nreturn(1);\\r\\n}\\r\\nint extract_host_port(char *str, char **host_ptr, unsigned char *ip,\\r\\nshort *port_ptr)\\r\\n{\\r\\nchar *h,*p;\\r\\nh=str;\\r\\np=strchr(str,':');\\r\\nif (p == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no port defined\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n*(p++)='\\0';\\r\\nif ((ip != NULL) && !host_ip(str,ip))\\r\\ngoto err;\\r\\nif (host_ptr != NULL) *host_ptr=h;\\r\\nif (!extract_port(p,port_ptr))\\r\\ngoto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nstatic int host_ip(char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int in[4];\\r\\nint i;\\r\\nif (sscanf(str,\"%u.%u.%u.%u\",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)\\r\\n{\\r\\nfor (i=0; i<4; i++)\\r\\nif (in[i] > 255)\\r\\n{\\r\\nBIO_printf(bio_err,\"invalid IP address\\n\");\\r\\ngoto err;\\r\\n}\\r\\nip[0]=in[0];\\r\\nip[1]=in[1];\\r\\nip[2]=in[2];\\r\\nip[3]=in[3];\\r\\n}\\r\\nelse\\r\\n{\\r\\nstruct hostent *he;\\r\\nif (!ssl_sock_init()) return(0);\\r\\nhe=GetHostByName(str);\\r\\nif (he == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname addr is not AF_INET\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nip[0]=he->h_addr_list[0][0];\\r\\nip[1]=he->h_addr_list[0][1];\\r\\nip[2]=he->h_addr_list[0][2];\\r\\nip[3]=he->h_addr_list[0][3];\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint extract_port(char *str, short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\ni=atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr=(unsigned short)i;\\r\\nelse\\r\\n{\\r\\ns=getservbyname(str,\"tcp\");\\r\\nif (s == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"getservbyname failure for %s\\n\",str);\\r\\nreturn(0);\\r\\n}\\r\\n*port_ptr=ntohs((unsigned short)s->s_port);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic struct hostent *GetHostByName(char *name)\\r\\n{\\r\\nstruct hostent *ret;\\r\\nint i,lowi=0;\\r\\nunsigned long low= (unsigned long)-1;\\r\\nfor (i=0; i<GHBN_NUM; i++)\\r\\n{\\r\\nif (low > ghbn_cache[i].order)\\r\\n{\\r\\nlow=ghbn_cache[i].order;\\r\\nlowi=i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0)\\r\\n{\\r\\nif (strncmp(name,ghbn_cache[i].name,128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i == GHBN_NUM)\\r\\n{\\r\\nghbn_miss++;\\r\\nret=gethostbyname(name);\\r\\nif (ret == NULL) return(NULL);\\r\\nif(strlen(name) < sizeof ghbn_cache[0].name)\\r\\n{\\r\\nstrcpy(ghbn_cache[lowi].name,name);\\r\\nmemcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));\\r\\nghbn_cache[lowi].order=ghbn_miss+ghbn_hits;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nelse\\r\\n{\\r\\nghbn_hits++;\\r\\nret= &(ghbn_cache[i].ent);\\r\\nghbn_cache[i].order=ghbn_miss+ghbn_hits;\\r\\nreturn(ret);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_names_c", "target": 0, "func": "int EVP_add_cipher(const EVP_CIPHER *c)\\r\\n{\\r\\nint r;\\r\\nr=OBJ_NAME_add(OBJ_nid2sn(c->nid),OBJ_NAME_TYPE_CIPHER_METH,(const char *)c);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(c->nid),OBJ_NAME_TYPE_CIPHER_METH,(const char *)c);\\r\\nreturn(r);\\r\\n}\\r\\nint EVP_add_digest(const EVP_MD *md)\\r\\n{\\r\\nint r;\\r\\nconst char *name;\\r\\nname=OBJ_nid2sn(md->type);\\r\\nr=OBJ_NAME_add(name,OBJ_NAME_TYPE_MD_METH,(const char *)md);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(md->type),OBJ_NAME_TYPE_MD_METH,(const char *)md);\\r\\nif (r == 0) return(0);\\r\\nif (md->type != md->pkey_type)\\r\\n{\\r\\nr=OBJ_NAME_add(OBJ_nid2sn(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,name);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,name);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *name)\\r\\n{\\r\\nconst EVP_CIPHER *cp;\\r\\ncp=(const EVP_CIPHER *)OBJ_NAME_get(name,OBJ_NAME_TYPE_CIPHER_METH);\\r\\nreturn(cp);\\r\\n}\\r\\nconst EVP_MD *EVP_get_digestbyname(const char *name)\\r\\n{\\r\\nconst EVP_MD *cp;\\r\\ncp=(const EVP_MD *)OBJ_NAME_get(name,OBJ_NAME_TYPE_MD_METH);\\r\\nreturn(cp);\\r\\n}\\r\\nvoid EVP_cleanup(void)\\r\\n{\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_CIPHER_METH);\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_MD_METH);\\r\\nOBJ_NAME_cleanup(-1);\\r\\nEVP_PBE_cleanup();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md4_dgst_c", "target": 0, "func": "int MD4_Init(MD4_CTX *c)\\r\\n{\\r\\nc->A=INIT_DATA_A;\\r\\nc->B=INIT_DATA_B;\\r\\nc->C=INIT_DATA_C;\\r\\nc->D=INIT_DATA_D;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid md4_block_host_order (MD4_CTX *c, const void *data, size_t num)\\r\\n{\\r\\nconst MD4_LONG *X=data;\\r\\nregister unsigned MD32_REG_T A,B,C,D;\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;X+=HASH_LBLOCK)\\r\\n{\\r\\nR0(A,B,C,D,X[ 0], 3,0);\\r\\nR0(D,A,B,C,X[ 1], 7,0);\\r\\nR0(C,D,A,B,X[ 2],11,0);\\r\\nR0(B,C,D,A,X[ 3],19,0);\\r\\nR0(A,B,C,D,X[ 4], 3,0);\\r\\nR0(D,A,B,C,X[ 5], 7,0);\\r\\nR0(C,D,A,B,X[ 6],11,0);\\r\\nR0(B,C,D,A,X[ 7],19,0);\\r\\nR0(A,B,C,D,X[ 8], 3,0);\\r\\nR0(D,A,B,C,X[ 9], 7,0);\\r\\nR0(C,D,A,B,X[10],11,0);\\r\\nR0(B,C,D,A,X[11],19,0);\\r\\nR0(A,B,C,D,X[12], 3,0);\\r\\nR0(D,A,B,C,X[13], 7,0);\\r\\nR0(C,D,A,B,X[14],11,0);\\r\\nR0(B,C,D,A,X[15],19,0);\\r\\nR1(A,B,C,D,X[ 0], 3,0x5A827999L);\\r\\nR1(D,A,B,C,X[ 4], 5,0x5A827999L);\\r\\nR1(C,D,A,B,X[ 8], 9,0x5A827999L);\\r\\nR1(B,C,D,A,X[12],13,0x5A827999L);\\r\\nR1(A,B,C,D,X[ 1], 3,0x5A827999L);\\r\\nR1(D,A,B,C,X[ 5], 5,0x5A827999L);\\r\\nR1(C,D,A,B,X[ 9], 9,0x5A827999L);\\r\\nR1(B,C,D,A,X[13],13,0x5A827999L);\\r\\nR1(A,B,C,D,X[ 2], 3,0x5A827999L);\\r\\nR1(D,A,B,C,X[ 6], 5,0x5A827999L);\\r\\nR1(C,D,A,B,X[10], 9,0x5A827999L);\\r\\nR1(B,C,D,A,X[14],13,0x5A827999L);\\r\\nR1(A,B,C,D,X[ 3], 3,0x5A827999L);\\r\\nR1(D,A,B,C,X[ 7], 5,0x5A827999L);\\r\\nR1(C,D,A,B,X[11], 9,0x5A827999L);\\r\\nR1(B,C,D,A,X[15],13,0x5A827999L);\\r\\nR2(A,B,C,D,X[ 0], 3,0x6ED9EBA1);\\r\\nR2(D,A,B,C,X[ 8], 9,0x6ED9EBA1);\\r\\nR2(C,D,A,B,X[ 4],11,0x6ED9EBA1);\\r\\nR2(B,C,D,A,X[12],15,0x6ED9EBA1);\\r\\nR2(A,B,C,D,X[ 2], 3,0x6ED9EBA1);\\r\\nR2(D,A,B,C,X[10], 9,0x6ED9EBA1);\\r\\nR2(C,D,A,B,X[ 6],11,0x6ED9EBA1);\\r\\nR2(B,C,D,A,X[14],15,0x6ED9EBA1);\\r\\nR2(A,B,C,D,X[ 1], 3,0x6ED9EBA1);\\r\\nR2(D,A,B,C,X[ 9], 9,0x6ED9EBA1);\\r\\nR2(C,D,A,B,X[ 5],11,0x6ED9EBA1);\\r\\nR2(B,C,D,A,X[13],15,0x6ED9EBA1);\\r\\nR2(A,B,C,D,X[ 3], 3,0x6ED9EBA1);\\r\\nR2(D,A,B,C,X[11], 9,0x6ED9EBA1);\\r\\nR2(C,D,A,B,X[ 7],11,0x6ED9EBA1);\\r\\nR2(B,C,D,A,X[15],15,0x6ED9EBA1);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nvoid md4_block_data_order (MD4_CTX *c, const void *data_, size_t num)\\r\\n{\\r\\nconst unsigned char *data=data_;\\r\\nregister unsigned MD32_REG_T A,B,C,D,l;\\r\\n#ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9,XX10,XX11,XX12,XX13,XX14,XX15;\\r\\n# define X(i) XX##i\\r\\n#else\\r\\nMD4_LONG XX[MD4_LBLOCK];\\r\\n# define X(i) XX[i]\\r\\n#endif\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;)\\r\\n{\\r\\nHOST_c2l(data,l); X( 0)=l; HOST_c2l(data,l); X( 1)=l;\\r\\nR0(A,B,C,D,X( 0), 3,0); HOST_c2l(data,l); X( 2)=l;\\r\\nR0(D,A,B,C,X( 1), 7,0); HOST_c2l(data,l); X( 3)=l;\\r\\nR0(C,D,A,B,X( 2),11,0); HOST_c2l(data,l); X( 4)=l;\\r\\nR0(B,C,D,A,X( 3),19,0); HOST_c2l(data,l); X( 5)=l;\\r\\nR0(A,B,C,D,X( 4), 3,0); HOST_c2l(data,l); X( 6)=l;\\r\\nR0(D,A,B,C,X( 5), 7,0); HOST_c2l(data,l); X( 7)=l;\\r\\nR0(C,D,A,B,X( 6),11,0); HOST_c2l(data,l); X( 8)=l;\\r\\nR0(B,C,D,A,X( 7),19,0); HOST_c2l(data,l); X( 9)=l;\\r\\nR0(A,B,C,D,X( 8), 3,0); HOST_c2l(data,l); X(10)=l;\\r\\nR0(D,A,B,C,X( 9), 7,0); HOST_c2l(data,l); X(11)=l;\\r\\nR0(C,D,A,B,X(10),11,0); HOST_c2l(data,l); X(12)=l;\\r\\nR0(B,C,D,A,X(11),19,0); HOST_c2l(data,l); X(13)=l;\\r\\nR0(A,B,C,D,X(12), 3,0); HOST_c2l(data,l); X(14)=l;\\r\\nR0(D,A,B,C,X(13), 7,0); HOST_c2l(data,l); X(15)=l;\\r\\nR0(C,D,A,B,X(14),11,0);\\r\\nR0(B,C,D,A,X(15),19,0);\\r\\nR1(A,B,C,D,X( 0), 3,0x5A827999L);\\r\\nR1(D,A,B,C,X( 4), 5,0x5A827999L);\\r\\nR1(C,D,A,B,X( 8), 9,0x5A827999L);\\r\\nR1(B,C,D,A,X(12),13,0x5A827999L);\\r\\nR1(A,B,C,D,X( 1), 3,0x5A827999L);\\r\\nR1(D,A,B,C,X( 5), 5,0x5A827999L);\\r\\nR1(C,D,A,B,X( 9), 9,0x5A827999L);\\r\\nR1(B,C,D,A,X(13),13,0x5A827999L);\\r\\nR1(A,B,C,D,X( 2), 3,0x5A827999L);\\r\\nR1(D,A,B,C,X( 6), 5,0x5A827999L);\\r\\nR1(C,D,A,B,X(10), 9,0x5A827999L);\\r\\nR1(B,C,D,A,X(14),13,0x5A827999L);\\r\\nR1(A,B,C,D,X( 3), 3,0x5A827999L);\\r\\nR1(D,A,B,C,X( 7), 5,0x5A827999L);\\r\\nR1(C,D,A,B,X(11), 9,0x5A827999L);\\r\\nR1(B,C,D,A,X(15),13,0x5A827999L);\\r\\nR2(A,B,C,D,X( 0), 3,0x6ED9EBA1L);\\r\\nR2(D,A,B,C,X( 8), 9,0x6ED9EBA1L);\\r\\nR2(C,D,A,B,X( 4),11,0x6ED9EBA1L);\\r\\nR2(B,C,D,A,X(12),15,0x6ED9EBA1L);\\r\\nR2(A,B,C,D,X( 2), 3,0x6ED9EBA1L);\\r\\nR2(D,A,B,C,X(10), 9,0x6ED9EBA1L);\\r\\nR2(C,D,A,B,X( 6),11,0x6ED9EBA1L);\\r\\nR2(B,C,D,A,X(14),15,0x6ED9EBA1L);\\r\\nR2(A,B,C,D,X( 1), 3,0x6ED9EBA1L);\\r\\nR2(D,A,B,C,X( 9), 9,0x6ED9EBA1L);\\r\\nR2(C,D,A,B,X( 5),11,0x6ED9EBA1L);\\r\\nR2(B,C,D,A,X(13),15,0x6ED9EBA1L);\\r\\nR2(A,B,C,D,X( 3), 3,0x6ED9EBA1L);\\r\\nR2(D,A,B,C,X(11), 9,0x6ED9EBA1L);\\r\\nR2(C,D,A,B,X( 7),11,0x6ED9EBA1L);\\r\\nR2(B,C,D,A,X(15),15,0x6ED9EBA1L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nint printit(unsigned long *l)\\r\\n{\\r\\nint i,ii;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nfor (ii=0; ii<8; ii++)\\r\\n{\\r\\nfprintf(stderr,\"%08lx \",l[i*8+ii]);\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_sock_c", "target": 0, "func": "BIO_METHOD *BIO_s_socket(void)\\r\\n{\\r\\nreturn(&methods_sockp);\\r\\n}\\r\\nBIO *BIO_new_socket(int fd, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_socket());\\r\\nif (ret == NULL) return(NULL);\\r\\nBIO_set_fd(ret,fd,close_flag);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int sock_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=0;\\r\\nbi->ptr=NULL;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int sock_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif (a->init)\\r\\n{\\r\\nSHUTDOWN2(a->num);\\r\\n}\\r\\na->init=0;\\r\\na->flags=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int sock_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out != NULL)\\r\\n{\\r\\nclear_socket_error();\\r\\nret=readsocket(b->num,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int sock_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nclear_socket_error();\\r\\nret=writesocket(b->num,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long sock_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nint *ip;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nnum=0;\\r\\ncase BIO_C_FILE_SEEK:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nsock_free(b);\\r\\nb->num= *((int *)ptr);\\r\\nb->shutdown=(int)num;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL) *ip=b->num;\\r\\nret=b->num;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int sock_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=sock_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_sock_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1))\\r\\n{\\r\\nerr=get_last_socket_error();\\r\\n#if defined(OPENSSL_SYS_WINDOWS) && 0\\r\\nif ((i == -1) && (err == 0))\\r\\nreturn(1);\\r\\n#endif\\r\\nreturn(BIO_sock_non_fatal_error(err));\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BIO_sock_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err)\\r\\n{\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_NETWARE)\\r\\n# if defined(WSAEWOULDBLOCK)\\r\\ncase WSAEWOULDBLOCK:\\r\\n# endif\\r\\n# if 0\\r\\n# if defined(WSAENOTCONN)\\r\\ncase WSAENOTCONN:\\r\\n# endif\\r\\n# endif\\r\\n#endif\\r\\n#ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n#endif\\r\\n#if defined(ENOTCONN)\\r\\ncase ENOTCONN:\\r\\n#endif\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\n# if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n#endif\\r\\n#ifdef EPROTO\\r\\ncase EPROTO:\\r\\n#endif\\r\\n#ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n#endif\\r\\n#ifdef EALREADY\\r\\ncase EALREADY:\\r\\n#endif\\r\\nreturn(1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_enc_writ_c", "target": 0, "func": "int DES_enc_write(int fd, const void *_buf, int len,\\r\\nDES_key_schedule *sched, DES_cblock *iv)\\r\\n{\\r\\n#ifdef _LIBC\\r\\nextern unsigned long time();\\r\\nextern int write();\\r\\n#endif\\r\\nconst unsigned char *buf=_buf;\\r\\nlong rnum;\\r\\nint i,j,k,outnum;\\r\\nstatic unsigned char *outbuf=NULL;\\r\\nunsigned char shortbuf[8];\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nstatic int start=1;\\r\\nif (outbuf == NULL)\\r\\n{\\r\\noutbuf=OPENSSL_malloc(BSIZE+HDRSIZE);\\r\\nif (outbuf == NULL) return(-1);\\r\\n}\\r\\nif (start)\\r\\n{\\r\\nstart=0;\\r\\n}\\r\\nif (len > MAXWRITE)\\r\\n{\\r\\nj=0;\\r\\nfor (i=0; i<len; i+=k)\\r\\n{\\r\\nk=DES_enc_write(fd,&(buf[i]),\\r\\n((len-i) > MAXWRITE)?MAXWRITE:(len-i),sched,iv);\\r\\nif (k < 0)\\r\\nreturn(k);\\r\\nelse\\r\\nj+=k;\\r\\n}\\r\\nreturn(j);\\r\\n}\\r\\np=outbuf;\\r\\nl2n(len,p);\\r\\nif (len < 8)\\r\\n{\\r\\ncp=shortbuf;\\r\\nmemcpy(shortbuf,buf,len);\\r\\nRAND_pseudo_bytes(shortbuf+len, 8-len);\\r\\nrnum=8;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncp=buf;\\r\\nrnum=((len+7)/8*8);\\r\\n}\\r\\nif (DES_rw_mode & DES_PCBC_MODE)\\r\\nDES_pcbc_encrypt(cp,&(outbuf[HDRSIZE]),(len<8)?8:len,sched,iv,\\r\\nDES_ENCRYPT);\\r\\nelse\\r\\nDES_cbc_encrypt(cp,&(outbuf[HDRSIZE]),(len<8)?8:len,sched,iv,\\r\\nDES_ENCRYPT);\\r\\noutnum=rnum+HDRSIZE;\\r\\nfor (j=0; j<outnum; j+=i)\\r\\n{\\r\\ni=write(fd,(void *)&(outbuf[j]),outnum-j);\\r\\nif (i == -1)\\r\\n{\\r\\n#ifdef EINTR\\r\\nif (errno == EINTR)\\r\\ni=0;\\r\\nelse\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nreturn(len);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_openssl_c", "target": 0, "func": "static void lock_dbg_cb(int mode, int type, const char *file, int line)\\r\\n{\\r\\nstatic int modes[CRYPTO_NUM_LOCKS];\\r\\nconst char *errstr = NULL;\\r\\nint rw;\\r\\nrw = mode & (CRYPTO_READ|CRYPTO_WRITE);\\r\\nif (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE)))\\r\\n{\\r\\nerrstr = \"invalid mode\";\\r\\ngoto err;\\r\\n}\\r\\nif (type < 0 || type >= CRYPTO_NUM_LOCKS)\\r\\n{\\r\\nerrstr = \"type out of bounds\";\\r\\ngoto err;\\r\\n}\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\nif (modes[type])\\r\\n{\\r\\nerrstr = \"already locked\";\\r\\ngoto err;\\r\\n}\\r\\nmodes[type] = rw;\\r\\n}\\r\\nelse if (mode & CRYPTO_UNLOCK)\\r\\n{\\r\\nif (!modes[type])\\r\\n{\\r\\nerrstr = \"not locked\";\\r\\ngoto err;\\r\\n}\\r\\nif (modes[type] != rw)\\r\\n{\\r\\nerrstr = (rw == CRYPTO_READ) ?\\r\\n\"CRYPTO_r_unlock on write lock\" :\\r\\n\"CRYPTO_w_unlock on read lock\";\\r\\n}\\r\\nmodes[type] = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nerrstr = \"invalid mode\";\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (errstr)\\r\\n{\\r\\nfprintf(stderr, \"openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\\n\",\\r\\nerrstr, mode, type, file, line);\\r\\n}\\r\\n}\\r\\nint main(int Argc, char *Argv[])\\r\\n{\\r\\nARGS arg;\\r\\n#define PROG_NAME_SIZE 39\\r\\nchar pname[PROG_NAME_SIZE+1];\\r\\nFUNCTION f,*fp;\\r\\nMS_STATIC const char *prompt;\\r\\nMS_STATIC char buf[1024];\\r\\nchar *to_free=NULL;\\r\\nint n,i,ret=0;\\r\\nint argc;\\r\\nchar **argv,*p;\\r\\nLHASH *prog=NULL;\\r\\nlong errline;\\r\\narg.data=NULL;\\r\\narg.count=0;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL)\\r\\n{\\r\\nif (!(0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))\\r\\n{\\r\\nCRYPTO_malloc_debug_init();\\r\\nCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);\\r\\n}\\r\\n}\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\n#if 0\\r\\nif (getenv(\"OPENSSL_DEBUG_LOCKING\") != NULL)\\r\\n#endif\\r\\n{\\r\\nCRYPTO_set_locking_callback(lock_dbg_cb);\\r\\n}\\r\\napps_startup();\\r\\np=getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np=getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\np=to_free=make_config_name();\\r\\ndefault_config_file=p;\\r\\nconfig=NCONF_new(NULL);\\r\\ni=NCONF_load(config,p,&errline);\\r\\nif (i == 0)\\r\\n{\\r\\nNCONF_free(config);\\r\\nconfig = NULL;\\r\\nERR_clear_error();\\r\\n}\\r\\nprog=prog_init();\\r\\nprogram_name(Argv[0],pname,sizeof pname);\\r\\nf.name=pname;\\r\\nfp=(FUNCTION *)lh_retrieve(prog,&f);\\r\\nif (fp != NULL)\\r\\n{\\r\\nArgv[0]=pname;\\r\\nret=fp->func(Argc,Argv);\\r\\ngoto end;\\r\\n}\\r\\nif (Argc != 1)\\r\\n{\\r\\nArgc--;\\r\\nArgv++;\\r\\nret=do_cmd(prog,Argc,Argv);\\r\\nif (ret < 0) ret=0;\\r\\ngoto end;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nret=0;\\r\\np=buf;\\r\\nn=sizeof buf;\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\np[0]='\\0';\\r\\nif (i++)\\r\\nprompt=\">\";\\r\\nelse prompt=\"OpenSSL> \";\\r\\nfputs(prompt,stdout);\\r\\nfflush(stdout);\\r\\nfgets(p,n,stdin);\\r\\nif (p[0] == '\\0') goto end;\\r\\ni=strlen(p);\\r\\nif (i <= 1) break;\\r\\nif (p[i-2] != '\\\\') break;\\r\\ni-=2;\\r\\np+=i;\\r\\nn-=i;\\r\\n}\\r\\nif (!chopup_args(&arg,buf,&argc,&argv)) break;\\r\\nret=do_cmd(prog,argc,argv);\\r\\nif (ret < 0)\\r\\n{\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif (ret != 0)\\r\\nBIO_printf(bio_err,\"error in %s\\n\",argv[0]);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nBIO_printf(bio_err,\"bad exit\\n\");\\r\\nret=1;\\r\\nend:\\r\\nif (to_free)\\r\\nOPENSSL_free(to_free);\\r\\nif (config != NULL)\\r\\n{\\r\\nNCONF_free(config);\\r\\nconfig=NULL;\\r\\n}\\r\\nif (prog != NULL) lh_free(prog);\\r\\nif (arg.data != NULL) OPENSSL_free(arg.data);\\r\\napps_shutdown();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nif (bio_err != NULL)\\r\\n{\\r\\nBIO_free(bio_err);\\r\\nbio_err=NULL;\\r\\n}\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int do_cmd(LHASH *prog, int argc, char *argv[])\\r\\n{\\r\\nFUNCTION f,*fp;\\r\\nint i,ret=1,tp,nl;\\r\\nif ((argc <= 0) || (argv[0] == NULL))\\r\\n{ ret=0; goto end; }\\r\\nf.name=argv[0];\\r\\nfp=(FUNCTION *)lh_retrieve(prog,&f);\\r\\nif (fp != NULL)\\r\\n{\\r\\nret=fp->func(argc,argv);\\r\\n}\\r\\nelse if ((strncmp(argv[0],\"no-\",3)) == 0)\\r\\n{\\r\\nBIO *bio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_stdout = BIO_push(tmpbio, bio_stdout);\\r\\n}\\r\\n#endif\\r\\nf.name=argv[0]+3;\\r\\nret = (lh_retrieve(prog,&f) != NULL);\\r\\nif (!ret)\\r\\nBIO_printf(bio_stdout, \"%s\\n\", argv[0]);\\r\\nelse\\r\\nBIO_printf(bio_stdout, \"%s\\n\", argv[0]+3);\\r\\nBIO_free_all(bio_stdout);\\r\\ngoto end;\\r\\n}\\r\\nelse if ((strcmp(argv[0],\"quit\") == 0) ||\\r\\n(strcmp(argv[0],\"q\") == 0) ||\\r\\n(strcmp(argv[0],\"exit\") == 0) ||\\r\\n(strcmp(argv[0],\"bye\") == 0))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nelse if ((strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0) ||\\r\\n(strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0) ||\\r\\n(strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0))\\r\\n{\\r\\nint list_type;\\r\\nBIO *bio_stdout;\\r\\nif (strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0)\\r\\nlist_type = FUNC_TYPE_GENERAL;\\r\\nelse if (strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0)\\r\\nlist_type = FUNC_TYPE_MD;\\r\\nelse\\r\\nlist_type = FUNC_TYPE_CIPHER;\\r\\nbio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_stdout = BIO_push(tmpbio, bio_stdout);\\r\\n}\\r\\n#endif\\r\\nfor (fp=functions; fp->name != NULL; fp++)\\r\\nif (fp->type == list_type)\\r\\nBIO_printf(bio_stdout, \"%s\\n\", fp->name);\\r\\nBIO_free_all(bio_stdout);\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"openssl:Error: '%s' is an invalid command.\\n\",\\r\\nargv[0]);\\r\\nBIO_printf(bio_err, \"\\nStandard commands\");\\r\\ni=0;\\r\\ntp=0;\\r\\nfor (fp=functions; fp->name != NULL; fp++)\\r\\n{\\r\\nnl=0;\\r\\nif (((i++) % 5) == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nnl=1;\\r\\n}\\r\\nif (fp->type != tp)\\r\\n{\\r\\ntp=fp->type;\\r\\nif (!nl) BIO_printf(bio_err,\"\\n\");\\r\\nif (tp == FUNC_TYPE_MD)\\r\\n{\\r\\ni=1;\\r\\nBIO_printf(bio_err,\\r\\n\"\\nMessage Digest commands (see the `dgst' command for more details)\\n\");\\r\\n}\\r\\nelse if (tp == FUNC_TYPE_CIPHER)\\r\\n{\\r\\ni=1;\\r\\nBIO_printf(bio_err,\"\\nCipher commands (see the `enc' command for more details)\\n\");\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"%-15s\",fp->name);\\r\\n}\\r\\nBIO_printf(bio_err,\"\\n\\n\");\\r\\nret=0;\\r\\n}\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int SortFnByName(const void *_f1,const void *_f2)\\r\\n{\\r\\nconst FUNCTION *f1=_f1;\\r\\nconst FUNCTION *f2=_f2;\\r\\nif(f1->type != f2->type)\\r\\nreturn f1->type-f2->type;\\r\\nreturn strcmp(f1->name,f2->name);\\r\\n}\\r\\nstatic LHASH *prog_init(void)\\r\\n{\\r\\nLHASH *ret;\\r\\nFUNCTION *f;\\r\\nsize_t i;\\r\\nfor(i=0,f=functions ; f->name != NULL ; ++f,++i)\\r\\n;\\r\\nqsort(functions,i,sizeof *functions,SortFnByName);\\r\\nif ((ret=lh_new(hash, cmp)) == NULL)\\r\\nreturn(NULL);\\r\\nfor (f=functions; f->name != NULL; f++)\\r\\nlh_insert(ret,f);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nreturn(strncmp(((const FUNCTION *)a_void)->name,\\r\\n((const FUNCTION *)b_void)->name,8));\\r\\n}\\r\\nstatic unsigned long MS_CALLBACK hash(const void *a_void)\\r\\n{\\r\\nreturn(lh_strhash(((const FUNCTION *)a_void)->name));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_dyn_c", "target": 0, "func": "static void int_free_str(void *s) { OPENSSL_free(s); }\\r\\nstatic void dynamic_data_ctx_free_func(void *parent, void *ptr,\\r\\nCRYPTO_EX_DATA *ad, int idx, long argl, void *argp)\\r\\n{\\r\\nif(ptr)\\r\\n{\\r\\ndynamic_data_ctx *ctx = (dynamic_data_ctx *)ptr;\\r\\nif(ctx->dynamic_dso)\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nif(ctx->DYNAMIC_LIBNAME)\\r\\nOPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);\\r\\nif(ctx->engine_id)\\r\\nOPENSSL_free((void*)ctx->engine_id);\\r\\nif(ctx->dirs)\\r\\nsk_pop_free(ctx->dirs, int_free_str);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\n}\\r\\nstatic int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)\\r\\n{\\r\\ndynamic_data_ctx *c;\\r\\nc = OPENSSL_malloc(sizeof(dynamic_data_ctx));\\r\\nif(!c)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemset(c, 0, sizeof(dynamic_data_ctx));\\r\\nc->dynamic_dso = NULL;\\r\\nc->v_check = NULL;\\r\\nc->bind_engine = NULL;\\r\\nc->DYNAMIC_LIBNAME = NULL;\\r\\nc->no_vcheck = 0;\\r\\nc->engine_id = NULL;\\r\\nc->list_add_value = 0;\\r\\nc->DYNAMIC_F1 = \"v_check\";\\r\\nc->DYNAMIC_F2 = \"bind_engine\";\\r\\nc->dir_load = 1;\\r\\nc->dirs = sk_new_null();\\r\\nif(!c->dirs)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(c);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e,\\r\\ndynamic_ex_data_idx)) == NULL)\\r\\n{\\r\\nENGINE_set_ex_data(e, dynamic_ex_data_idx, c);\\r\\n*ctx = c;\\r\\nc = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif(c)\\r\\nOPENSSL_free(c);\\r\\nreturn 1;\\r\\n}\\r\\nstatic dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e)\\r\\n{\\r\\ndynamic_data_ctx *ctx;\\r\\nif(dynamic_ex_data_idx < 0)\\r\\n{\\r\\nint new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL,\\r\\ndynamic_data_ctx_free_func);\\r\\nif(new_idx == -1)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX,ENGINE_R_NO_INDEX);\\r\\nreturn NULL;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif(dynamic_ex_data_idx < 0)\\r\\n{\\r\\ndynamic_ex_data_idx = new_idx;\\r\\nnew_idx = -1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\n}\\r\\nctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx);\\r\\nif((ctx == NULL) && !dynamic_set_data_ctx(e, &ctx))\\r\\nreturn NULL;\\r\\nreturn ctx;\\r\\n}\\r\\nstatic ENGINE *engine_dynamic(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!ENGINE_set_id(ret, engine_dynamic_id) ||\\r\\n!ENGINE_set_name(ret, engine_dynamic_name) ||\\r\\n!ENGINE_set_init_function(ret, dynamic_init) ||\\r\\n!ENGINE_set_finish_function(ret, dynamic_finish) ||\\r\\n!ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||\\r\\n!ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||\\r\\n!ENGINE_set_cmd_defns(ret, dynamic_cmd_defns))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_dynamic(void)\\r\\n{\\r\\nENGINE *toadd = engine_dynamic();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int dynamic_init(ENGINE *e)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_finish(ENGINE *e)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\ndynamic_data_ctx *ctx = dynamic_get_data_ctx(e);\\r\\nint initialised;\\r\\nif(!ctx)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\ninitialised = ((ctx->dynamic_dso == NULL) ? 0 : 1);\\r\\nif(initialised)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\\r\\nENGINE_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nswitch(cmd)\\r\\n{\\r\\ncase DYNAMIC_CMD_SO_PATH:\\r\\nif(p && (strlen((const char *)p) < 1))\\r\\np = NULL;\\r\\nif(ctx->DYNAMIC_LIBNAME)\\r\\nOPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);\\r\\nif(p)\\r\\nctx->DYNAMIC_LIBNAME = BUF_strdup(p);\\r\\nelse\\r\\nctx->DYNAMIC_LIBNAME = NULL;\\r\\nreturn (ctx->DYNAMIC_LIBNAME ? 1 : 0);\\r\\ncase DYNAMIC_CMD_NO_VCHECK:\\r\\nctx->no_vcheck = ((i == 0) ? 0 : 1);\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_ID:\\r\\nif(p && (strlen((const char *)p) < 1))\\r\\np = NULL;\\r\\nif(ctx->engine_id)\\r\\nOPENSSL_free((void*)ctx->engine_id);\\r\\nif(p)\\r\\nctx->engine_id = BUF_strdup(p);\\r\\nelse\\r\\nctx->engine_id = NULL;\\r\\nreturn (ctx->engine_id ? 1 : 0);\\r\\ncase DYNAMIC_CMD_LIST_ADD:\\r\\nif((i < 0) || (i > 2))\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\\r\\nENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nctx->list_add_value = (int)i;\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_LOAD:\\r\\nreturn dynamic_load(e, ctx);\\r\\ncase DYNAMIC_CMD_DIR_LOAD:\\r\\nif((i < 0) || (i > 2))\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\\r\\nENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nctx->dir_load = (int)i;\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_DIR_ADD:\\r\\nif(!p || (strlen((const char *)p) < 1))\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\\r\\nENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\n{\\r\\nchar *tmp_str = BUF_strdup(p);\\r\\nif(!tmp_str)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_insert(ctx->dirs, tmp_str, -1);\\r\\n}\\r\\nreturn 1;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int int_load(dynamic_data_ctx *ctx)\\r\\n{\\r\\nint num, loop;\\r\\nif((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,\\r\\nctx->DYNAMIC_LIBNAME, NULL, 0)) != NULL)\\r\\nreturn 1;\\r\\nif(!ctx->dir_load || ((num = sk_num(ctx->dirs)) < 1))\\r\\nreturn 0;\\r\\nfor(loop = 0; loop < num; loop++)\\r\\n{\\r\\nconst char *s = sk_value(ctx->dirs, loop);\\r\\nchar *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s);\\r\\nif(!merge)\\r\\nreturn 0;\\r\\nif(DSO_load(ctx->dynamic_dso, merge, NULL, 0))\\r\\n{\\r\\nOPENSSL_free(merge);\\r\\nreturn 1;\\r\\n}\\r\\nOPENSSL_free(merge);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)\\r\\n{\\r\\nENGINE cpy;\\r\\ndynamic_fns fns;\\r\\nif(!ctx->dynamic_dso)\\r\\nctx->dynamic_dso = DSO_new();\\r\\nif(!ctx->DYNAMIC_LIBNAME)\\r\\n{\\r\\nif(!ctx->engine_id)\\r\\nreturn 0;\\r\\nctx->DYNAMIC_LIBNAME =\\r\\nDSO_convert_filename(ctx->dynamic_dso, ctx->engine_id);\\r\\n}\\r\\nif(!int_load(ctx))\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_DSO_NOT_FOUND);\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nif(!(ctx->bind_engine = (dynamic_bind_engine)DSO_bind_func(\\r\\nctx->dynamic_dso, ctx->DYNAMIC_F2)))\\r\\n{\\r\\nctx->bind_engine = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif(!ctx->no_vcheck)\\r\\n{\\r\\nunsigned long vcheck_res = 0;\\r\\nctx->v_check = (dynamic_v_check_fn)DSO_bind_func(\\r\\nctx->dynamic_dso, ctx->DYNAMIC_F1);\\r\\nif(ctx->v_check)\\r\\nvcheck_res = ctx->v_check(OSSL_DYNAMIC_VERSION);\\r\\nif(vcheck_res < OSSL_DYNAMIC_OLDEST)\\r\\n{\\r\\nctx->bind_engine = NULL;\\r\\nctx->v_check = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_VERSION_INCOMPATIBILITY);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nmemcpy(&cpy, e, sizeof(ENGINE));\\r\\nfns.static_state = ENGINE_get_static_state();\\r\\nfns.err_fns = ERR_get_implementation();\\r\\nfns.ex_data_fns = CRYPTO_get_ex_data_implementation();\\r\\nCRYPTO_get_mem_functions(&fns.mem_fns.malloc_cb,\\r\\n&fns.mem_fns.realloc_cb,\\r\\n&fns.mem_fns.free_cb);\\r\\nfns.lock_fns.lock_locking_cb = CRYPTO_get_locking_callback();\\r\\nfns.lock_fns.lock_add_lock_cb = CRYPTO_get_add_lock_callback();\\r\\nfns.lock_fns.dynlock_create_cb = CRYPTO_get_dynlock_create_callback();\\r\\nfns.lock_fns.dynlock_lock_cb = CRYPTO_get_dynlock_lock_callback();\\r\\nfns.lock_fns.dynlock_destroy_cb = CRYPTO_get_dynlock_destroy_callback();\\r\\nengine_set_all_null(e);\\r\\nif(!ctx->bind_engine(e, ctx->engine_id, &fns))\\r\\n{\\r\\nctx->bind_engine = NULL;\\r\\nctx->v_check = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,ENGINE_R_INIT_FAILED);\\r\\nmemcpy(e, &cpy, sizeof(ENGINE));\\r\\nreturn 0;\\r\\n}\\r\\nif(ctx->list_add_value > 0)\\r\\n{\\r\\nif(!ENGINE_add(e))\\r\\n{\\r\\nif(ctx->list_add_value > 1)\\r\\n{\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_CONFLICTING_ENGINE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_mod_c", "target": 0, "func": "int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\nif (!(BN_mod(r,m,d,ctx)))\\r\\nreturn 0;\\r\\nif (!r->neg)\\r\\nreturn 1;\\r\\nreturn (d->neg ? BN_sub : BN_add)(r, r, d);\\r\\n}\\r\\nint BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_add(r, a, b)) return 0;\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)\\r\\n{\\r\\nif (!BN_uadd(r, a, b)) return 0;\\r\\nif (BN_ucmp(r, m) >= 0)\\r\\nreturn BN_usub(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_sub(r, a, b)) return 0;\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)\\r\\n{\\r\\nif (!BN_sub(r, a, b)) return 0;\\r\\nif (r->neg)\\r\\nreturn BN_add(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint ret=0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(m);\\r\\nBN_CTX_start(ctx);\\r\\nif ((t = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (a == b)\\r\\n{ if (!BN_sqr(t,a,ctx)) goto err; }\\r\\nelse\\r\\n{ if (!BN_mul(t,a,b,ctx)) goto err; }\\r\\nif (!BN_nnmod(r,t,m,ctx)) goto err;\\r\\nbn_check_top(r);\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_sqr(r, a, ctx)) return 0;\\r\\nreturn BN_mod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_lshift1(r, a)) return 0;\\r\\nbn_check_top(r);\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)\\r\\n{\\r\\nif (!BN_lshift1(r, a)) return 0;\\r\\nbn_check_top(r);\\r\\nif (BN_cmp(r, m) >= 0)\\r\\nreturn BN_sub(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *abs_m = NULL;\\r\\nint ret;\\r\\nif (!BN_nnmod(r, a, m, ctx)) return 0;\\r\\nif (m->neg)\\r\\n{\\r\\nabs_m = BN_dup(m);\\r\\nif (abs_m == NULL) return 0;\\r\\nabs_m->neg = 0;\\r\\n}\\r\\nret = BN_mod_lshift_quick(r, r, n, (abs_m ? abs_m : m));\\r\\nbn_check_top(r);\\r\\nif (abs_m)\\r\\nBN_free(abs_m);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)\\r\\n{\\r\\nif (r != a)\\r\\n{\\r\\nif (BN_copy(r, a) == NULL) return 0;\\r\\n}\\r\\nwhile (n > 0)\\r\\n{\\r\\nint max_shift;\\r\\nmax_shift = BN_num_bits(m) - BN_num_bits(r);\\r\\nif (max_shift < 0)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_LSHIFT_QUICK, BN_R_INPUT_NOT_REDUCED);\\r\\nreturn 0;\\r\\n}\\r\\nif (max_shift > n)\\r\\nmax_shift = n;\\r\\nif (max_shift)\\r\\n{\\r\\nif (!BN_lshift(r, r, max_shift)) return 0;\\r\\nn -= max_shift;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_lshift1(r, r)) return 0;\\r\\n--n;\\r\\n}\\r\\nif (BN_cmp(r, m) >= 0)\\r\\n{\\r\\nif (!BN_sub(r, r, m)) return 0;\\r\\n}\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_asn1_c", "target": 0, "func": "static int dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(operation == ASN1_OP_NEW_PRE) {\\r\\n*pval = (ASN1_VALUE *)DH_new();\\r\\nif(*pval) return 2;\\r\\nreturn 0;\\r\\n} else if(operation == ASN1_OP_FREE_PRE) {\\r\\nDH_free((DH *)*pval);\\r\\n*pval = NULL;\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_verify_c", "target": 0, "func": "int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\\r\\nunsigned int siglen, EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i,ok=0,v;\\r\\nMS_STATIC EVP_MD_CTX tmp_ctx;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nv=ctx->digest->required_pkey_type[i];\\r\\nif (v == 0) break;\\r\\nif (pkey->type == v)\\r\\n{\\r\\nok=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nEVP_MD_CTX_copy_ex(&tmp_ctx,ctx);\\r\\nEVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len);\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nif (ctx->digest->verify == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ctx->digest->verify(ctx->digest->type,m,m_len,\\r\\nsigbuf,siglen,pkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_crl_c", "target": 0, "func": "int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)\\r\\n{\\r\\nX509_CRL_INFO *inf;\\r\\ninf = crl->crl;\\r\\nif(!inf->revoked)\\r\\ninf->revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);\\r\\nif(!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {\\r\\nASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ninf->enc.modified = 1;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_dss_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return SHA1_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA1_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA1_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_dss(void)\\r\\n{\\r\\nreturn(&dsa_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_srvr_c", "target": 0, "func": "static SSL_METHOD *dtls1_get_server_method(int ver)\\r\\n{\\r\\nif (ver == DTLS1_VERSION)\\r\\nreturn(DTLSv1_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *DTLSv1_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD DTLSv1_server_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&DTLSv1_server_data,(char *)dtlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nDTLSv1_server_data.ssl_accept=dtls1_accept;\\r\\nDTLSv1_server_data.get_ssl_method=dtls1_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&DTLSv1_server_data);\\r\\n}\\r\\nint dtls1_accept(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long l,Time=time(NULL);\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nlong num1;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version & 0xff00) != (DTLS1_VERSION & 0xff00))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_ACCEPT, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (s->state != SSL_ST_RENEGOTIATE)\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_accept++;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->ctx->stats.sess_accept_renegotiate++;\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_A;\\r\\n}\\r\\nif ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE))\\r\\ns->d1->send_cookie = 1;\\r\\nelse\\r\\ns->d1->send_cookie = 0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A:\\r\\ncase SSL3_ST_SW_HELLO_REQ_B:\\r\\ns->shutdown=0;\\r\\nret=dtls1_send_hello_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nssl3_init_finished_mac(s);\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C:\\r\\ns->state=SSL_ST_OK;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C:\\r\\ns->shutdown=0;\\r\\nret=ssl3_get_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->new_session = 2;\\r\\nif ( s->d1->send_cookie)\\r\\ns->state = DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A;\\r\\nelse\\r\\ns->state = SSL3_ST_SW_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:\\r\\nret = dtls1_send_hello_verify_request(s);\\r\\nif ( ret <= 0) goto end;\\r\\ns->d1->send_cookie = 0;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A:\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B:\\r\\nret=dtls1_send_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CERT_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_A:\\r\\ncase SSL3_ST_SW_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=dtls1_send_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A:\\r\\ncase SSL3_ST_SW_KEY_EXCH_B:\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif ((s->options & SSL_OP_EPHEMERAL_RSA)\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\n&& !(l & SSL_KRB5)\\r\\n#endif\\r\\n)\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\nelse\\r\\ns->s3->tmp.use_rsa_tmp=0;\\r\\nif (s->s3->tmp.use_rsa_tmp\\r\\n|| (l & (SSL_DH|SSL_kFZA))\\r\\n|| ((l & SSL_kRSA)\\r\\n&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\\r\\n|| (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\\r\\n&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\\r\\n)\\r\\n)\\r\\n)\\r\\n)\\r\\n{\\r\\nret=dtls1_send_server_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_A:\\r\\ncase SSL3_ST_SW_CERT_REQ_B:\\r\\nif (\\r\\n!(s->verify_mode & SSL_VERIFY_PEER) ||\\r\\n((s->session->peer != NULL) &&\\r\\n(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\\r\\n((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&\\r\\n!(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\\r\\n(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))\\r\\n{\\r\\nskip=1;\\r\\ns->s3->tmp.cert_request=0;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_request=1;\\r\\nret=dtls1_send_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\n#ifndef NETSCAPE_HANG_BUG\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\n#else\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\\r\\n#endif\\r\\ns->init_num=0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A:\\r\\ncase SSL3_ST_SW_SRVR_DONE_B:\\r\\nret=dtls1_send_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_A:\\r\\ncase SSL3_ST_SR_CERT_B:\\r\\nret = ssl3_check_client_hello(s);\\r\\nif (ret <= 0)\\r\\ngoto end;\\r\\nif (ret == 2)\\r\\ns->state = SSL3_ST_SR_CLNT_HELLO_C;\\r\\nelse {\\r\\nret=ssl3_get_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL3_ST_SR_KEY_EXCH_A;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A:\\r\\ncase SSL3_ST_SR_KEY_EXCH_B:\\r\\nret=ssl3_get_client_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SR_CERT_VRFY_A;\\r\\ns->init_num=0;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->tmp.cert_verify_md[0]));\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst2),\\r\\n&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A:\\r\\ncase SSL3_ST_SR_CERT_VRFY_B:\\r\\nret=ssl3_get_cert_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SR_FINISHED_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\\r\\nSSL3_ST_SR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL_ST_OK;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{ ret= -1; goto end; }\\r\\nret=dtls1_send_change_cipher_spec(s,\\r\\nSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FINISHED_A;\\r\\ns->init_num=0;\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_SERVER_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ndtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\nret=dtls1_send_finished(s,\\r\\nSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\\r\\ns->method->ssl3_enc->server_finished_label,\\r\\ns->method->ssl3_enc->server_finished_label_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\nif (s->hit)\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\\r\\nelse\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\n#if 0\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n#endif\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_num=0;\\r\\nif (s->new_session == 2)\\r\\n{\\r\\ns->new_session=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_SERVER);\\r\\ns->ctx->stats.sess_accept_good++;\\r\\ns->handshake_func=dtls1_accept;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\n}\\r\\nret = 1;\\r\\ns->d1->handshake_read_seq = 0;\\r\\ns->d1->handshake_write_seq = 0;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_DTLS1_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint dtls1_send_hello_request(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_HELLO_REQ_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\np = dtls1_set_message_header(s, p, SSL3_MT_HELLO_REQUEST, 0, 0, 0);\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_B;\\r\\ns->init_num=DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint dtls1_send_hello_verify_request(SSL *s)\\r\\n{\\r\\nunsigned int msg_len;\\r\\nunsigned char *msg, *buf, *p;\\r\\nif (s->state == DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A)\\r\\n{\\r\\nbuf = (unsigned char *)s->init_buf->data;\\r\\nmsg = p = &(buf[DTLS1_HM_HEADER_LENGTH]);\\r\\n*(p++) = s->version >> 8;\\r\\n*(p++) = s->version & 0xFF;\\r\\n*(p++) = (unsigned char) s->d1->cookie_len;\\r\\nif ( s->ctx->app_gen_cookie_cb != NULL &&\\r\\ns->ctx->app_gen_cookie_cb(s, s->d1->cookie,\\r\\n&(s->d1->cookie_len)) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_HELLO_VERIFY_REQUEST,ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(p, s->d1->cookie, s->d1->cookie_len);\\r\\np += s->d1->cookie_len;\\r\\nmsg_len = p - msg;\\r\\ndtls1_set_message_header(s, buf,\\r\\nDTLS1_MT_HELLO_VERIFY_REQUEST, msg_len, 0, msg_len);\\r\\ns->state=DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint dtls1_send_server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,sl;\\r\\nunsigned long l,Time;\\r\\nif (s->state == SSL3_ST_SW_SRVR_HELLO_A)\\r\\n{\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=s->s3->server_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nRAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));\\r\\nd=p= &(buf[DTLS1_HM_HEADER_LENGTH]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER))\\r\\ns->session->session_id_length=0;\\r\\nsl=s->session->session_id_length;\\r\\nif (sl > sizeof s->session->session_id)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\n*(p++)=sl;\\r\\nmemcpy(p,s->session->session_id,sl);\\r\\np+=sl;\\r\\ni=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);\\r\\np+=i;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\n*(p++)=0;\\r\\nelse\\r\\n*(p++)=s->s3->tmp.new_compression->id;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\nd = dtls1_set_message_header(s, d, SSL3_MT_SERVER_HELLO, l, 0, l);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint dtls1_send_server_done(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_SRVR_DONE_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\np = dtls1_set_message_header(s, p, SSL3_MT_SERVER_DONE, 0, 0, 0);\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_B;\\r\\ns->init_num=DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint dtls1_send_server_key_exchange(SSL *s)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned char *q;\\r\\nint j,num;\\r\\nRSA *rsa;\\r\\nunsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nunsigned int u;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nDH *dh=NULL,*dhp;\\r\\n#endif\\r\\nEVP_PKEY *pkey;\\r\\nunsigned char *p,*d;\\r\\nint al,i;\\r\\nunsigned long type;\\r\\nint n;\\r\\nCERT *cert;\\r\\nBIGNUM *r[4];\\r\\nint nr[4],kn;\\r\\nBUF_MEM *buf;\\r\\nEVP_MD_CTX md_ctx;\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nif (s->state == SSL3_ST_SW_KEY_EXCH_A)\\r\\n{\\r\\ntype=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;\\r\\ncert=s->cert;\\r\\nbuf=s->init_buf;\\r\\nr[0]=r[1]=r[2]=r[3]=NULL;\\r\\nn=0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (type & SSL_kRSA)\\r\\n{\\r\\nrsa=cert->rsa_tmp;\\r\\nif ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))\\r\\n{\\r\\nrsa=s->cert->rsa_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nif(rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\ncert->rsa_tmp=rsa;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nr[0]=rsa->n;\\r\\nr[1]=rsa->e;\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (type & SSL_kEDH)\\r\\n{\\r\\ndhp=cert->dh_tmp;\\r\\nif ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))\\r\\ndhp=s->cert->dh_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nif (dhp == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->tmp.dh != NULL)\\r\\n{\\r\\nDH_free(dh);\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh=DHparams_dup(dhp)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.dh=dh;\\r\\nif ((dhp->pub_key == NULL ||\\r\\ndhp->priv_key == NULL ||\\r\\n(s->options & SSL_OP_SINGLE_DH_USE)))\\r\\n{\\r\\nif(!DH_generate_key(dh))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,\\r\\nERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ndh->pub_key=BN_dup(dhp->pub_key);\\r\\ndh->priv_key=BN_dup(dhp->priv_key);\\r\\nif ((dh->pub_key == NULL) ||\\r\\n(dh->priv_key == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr[0]=dh->p;\\r\\nr[1]=dh->g;\\r\\nr[2]=dh->pub_key;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\nnr[i]=BN_num_bytes(r[i]);\\r\\nn+=2+nr[i];\\r\\n}\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nif ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))\\r\\n== NULL)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\nkn=EVP_PKEY_size(pkey);\\r\\n}\\r\\nelse\\r\\n{\\r\\npkey=NULL;\\r\\nkn=0;\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(buf,n+DTLS1_HM_HEADER_LENGTH+kn))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);\\r\\ngoto err;\\r\\n}\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[DTLS1_HM_HEADER_LENGTH]);\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\ns2n(nr[i],p);\\r\\nBN_bn2bin(r[i],p);\\r\\np+=nr[i];\\r\\n}\\r\\nif (pkey != NULL)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nq=md_buf;\\r\\nj=0;\\r\\nfor (num=2; num > 0; num--)\\r\\n{\\r\\nEVP_DigestInit_ex(&md_ctx,(num == 2)\\r\\n?s->ctx->md5:s->ctx->sha1, NULL);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);\\r\\nEVP_DigestFinal_ex(&md_ctx,q,\\r\\n(unsigned int *)&i);\\r\\nq+=i;\\r\\nj+=i;\\r\\n}\\r\\nif (RSA_sign(NID_md5_sha1, md_buf, j,\\r\\n&(p[2]), &u, pkey->pkey.rsa) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(u,p);\\r\\nn+=u+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_DSA)\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nEVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(d[DTLS1_HM_HEADER_LENGTH]),n);\\r\\nif (!EVP_SignFinal(&md_ctx,&(p[2]),\\r\\n(unsigned int *)&i,pkey))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn+=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nd = dtls1_set_message_header(s, d,\\r\\nSSL3_MT_SERVER_KEY_EXCHANGE, n, 0, n);\\r\\ns->init_num=n+DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\ns->state = SSL3_ST_SW_KEY_EXCH_B;\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(-1);\\r\\n}\\r\\nint dtls1_send_certificate_request(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i,j,nl,off,n;\\r\\nSTACK_OF(X509_NAME) *sk=NULL;\\r\\nX509_NAME *name;\\r\\nBUF_MEM *buf;\\r\\nif (s->state == SSL3_ST_SW_CERT_REQ_A)\\r\\n{\\r\\nbuf=s->init_buf;\\r\\nd=p=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);\\r\\np++;\\r\\nn=ssl3_get_req_cert_type(s,p);\\r\\nd[0]=n;\\r\\np+=n;\\r\\nn++;\\r\\noff=n;\\r\\np+=2;\\r\\nn+=2;\\r\\nsk=SSL_get_client_CA_list(s);\\r\\nnl=0;\\r\\nif (sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_NAME_num(sk); i++)\\r\\n{\\r\\nname=sk_X509_NAME_value(sk,i);\\r\\nj=i2d_X509_NAME(name,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,DTLS1_HM_HEADER_LENGTH+n+j+2))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH+n]);\\r\\nif (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\\r\\n{\\r\\ns2n(j,p);\\r\\ni2d_X509_NAME(name,&p);\\r\\nn+=2+j;\\r\\nnl+=2+j;\\r\\n}\\r\\nelse\\r\\n{\\r\\nd=p;\\r\\ni2d_X509_NAME(name,&p);\\r\\nj-=2; s2n(j,d); j+=2;\\r\\nn+=j;\\r\\nnl+=j;\\r\\n}\\r\\n}\\r\\n}\\r\\np=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH+off]);\\r\\ns2n(nl,p);\\r\\nd=(unsigned char *)buf->data;\\r\\n*(d++)=SSL3_MT_CERTIFICATE_REQUEST;\\r\\nl2n3(n,d);\\r\\ns2n(s->d1->handshake_write_seq,d);\\r\\ns->d1->handshake_write_seq++;\\r\\ns->init_num=n+DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\n#ifdef NETSCAPE_HANG_BUG\\r\\np=(unsigned char *)s->init_buf->data + s->init_num;\\r\\n*(p++)=SSL3_MT_SERVER_DONE;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->init_num += 4;\\r\\n#endif\\r\\ndtls1_buffer_message(s, 0);\\r\\ns->state = SSL3_ST_SW_CERT_REQ_B;\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint dtls1_send_server_certificate(SSL *s)\\r\\n{\\r\\nunsigned long l;\\r\\nX509 *x;\\r\\nif (s->state == SSL3_ST_SW_CERT_A)\\r\\n{\\r\\nx=ssl_get_server_send_cert(s);\\r\\nif (x == NULL &&\\r\\n(s->s3->tmp.new_cipher->algorithms\\r\\n& (SSL_MKEY_MASK|SSL_AUTH_MASK))\\r\\n!= (SSL_aKRB5|SSL_kKRB5))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);\\r\\nreturn(0);\\r\\n}\\r\\nl=dtls1_output_cert_chain(s,x);\\r\\ns->state=SSL3_ST_SW_CERT_B;\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_lib_c", "target": 0, "func": "OCSP_CERTID *OCSP_cert_to_id(const EVP_MD *dgst, X509 *subject, X509 *issuer)\\r\\n{\\r\\nX509_NAME *iname;\\r\\nASN1_INTEGER *serial;\\r\\nASN1_BIT_STRING *ikey;\\r\\n#ifndef OPENSSL_NO_SHA1\\r\\nif(!dgst) dgst = EVP_sha1();\\r\\n#endif\\r\\nif (subject)\\r\\n{\\r\\niname = X509_get_issuer_name(subject);\\r\\nserial = X509_get_serialNumber(subject);\\r\\n}\\r\\nelse\\r\\n{\\r\\niname = X509_get_subject_name(issuer);\\r\\nserial = NULL;\\r\\n}\\r\\nikey = X509_get0_pubkey_bitstr(issuer);\\r\\nreturn OCSP_cert_id_new(dgst, iname, ikey, serial);\\r\\n}\\r\\nOCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,\\r\\nX509_NAME *issuerName,\\r\\nASN1_BIT_STRING* issuerKey,\\r\\nASN1_INTEGER *serialNumber)\\r\\n{\\r\\nint nid;\\r\\nunsigned int i;\\r\\nX509_ALGOR *alg;\\r\\nOCSP_CERTID *cid = NULL;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!(cid = OCSP_CERTID_new())) goto err;\\r\\nalg = cid->hashAlgorithm;\\r\\nif (alg->algorithm != NULL) ASN1_OBJECT_free(alg->algorithm);\\r\\nif ((nid = EVP_MD_type(dgst)) == NID_undef)\\r\\n{\\r\\nOCSPerr(OCSP_F_OCSP_CERT_ID_NEW,OCSP_R_UNKNOWN_NID);\\r\\ngoto err;\\r\\n}\\r\\nif (!(alg->algorithm=OBJ_nid2obj(nid))) goto err;\\r\\nif ((alg->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\nalg->parameter->type=V_ASN1_NULL;\\r\\nif (!X509_NAME_digest(issuerName, dgst, md, &i)) goto digerr;\\r\\nif (!(ASN1_OCTET_STRING_set(cid->issuerNameHash, md, i))) goto err;\\r\\nEVP_Digest(issuerKey->data, issuerKey->length, md, &i, dgst, NULL);\\r\\nif (!(ASN1_OCTET_STRING_set(cid->issuerKeyHash, md, i))) goto err;\\r\\nif (serialNumber)\\r\\n{\\r\\nASN1_INTEGER_free(cid->serialNumber);\\r\\nif (!(cid->serialNumber = ASN1_INTEGER_dup(serialNumber))) goto err;\\r\\n}\\r\\nreturn cid;\\r\\ndigerr:\\r\\nOCSPerr(OCSP_F_OCSP_CERT_ID_NEW,OCSP_R_DIGEST_ERR);\\r\\nerr:\\r\\nif (cid) OCSP_CERTID_free(cid);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_id_issuer_cmp(OCSP_CERTID *a, OCSP_CERTID *b)\\r\\n{\\r\\nint ret;\\r\\nret = OBJ_cmp(a->hashAlgorithm->algorithm, b->hashAlgorithm->algorithm);\\r\\nif (ret) return ret;\\r\\nret = ASN1_OCTET_STRING_cmp(a->issuerNameHash, b->issuerNameHash);\\r\\nif (ret) return ret;\\r\\nreturn ASN1_OCTET_STRING_cmp(a->issuerKeyHash, b->issuerKeyHash);\\r\\n}\\r\\nint OCSP_id_cmp(OCSP_CERTID *a, OCSP_CERTID *b)\\r\\n{\\r\\nint ret;\\r\\nret = OCSP_id_issuer_cmp(a, b);\\r\\nif (ret) return ret;\\r\\nreturn ASN1_INTEGER_cmp(a->serialNumber, b->serialNumber);\\r\\n}\\r\\nint OCSP_parse_url(char *url, char **phost, char **pport, char **ppath, int *pssl)\\r\\n{\\r\\nchar *p, *buf;\\r\\nchar *host, *port;\\r\\nbuf = BUF_strdup(url);\\r\\nif (!buf) goto mem_err;\\r\\n*phost = NULL;\\r\\n*pport = NULL;\\r\\n*ppath = NULL;\\r\\np = strchr(buf, ':');\\r\\nif (!p) goto parse_err;\\r\\n*(p++) = '\\0';\\r\\nif (!strcmp(buf, \"http\"))\\r\\n{\\r\\n*pssl = 0;\\r\\nport = \"80\";\\r\\n}\\r\\nelse if (!strcmp(buf, \"https\"))\\r\\n{\\r\\n*pssl = 1;\\r\\nport = \"443\";\\r\\n}\\r\\nelse\\r\\ngoto parse_err;\\r\\nif ((p[0] != '/') || (p[1] != '/'))\\r\\ngoto parse_err;\\r\\np += 2;\\r\\nhost = p;\\r\\np = strchr(p, '/');\\r\\nif (!p)\\r\\n*ppath = BUF_strdup(\"/\");\\r\\nelse\\r\\n{\\r\\n*ppath = BUF_strdup(p);\\r\\n*p = '\\0';\\r\\n}\\r\\nif (!*ppath) goto mem_err;\\r\\nif ((p = strchr(host, ':')))\\r\\n{\\r\\n*p = 0;\\r\\nport = p + 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (*pssl) port = \"443\";\\r\\nelse port = \"80\";\\r\\n}\\r\\n*pport = BUF_strdup(port);\\r\\nif (!*pport) goto mem_err;\\r\\n*phost = BUF_strdup(host);\\r\\nif (!*phost) goto mem_err;\\r\\nOPENSSL_free(buf);\\r\\nreturn 1;\\r\\nmem_err:\\r\\nOCSPerr(OCSP_F_OCSP_PARSE_URL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\nparse_err:\\r\\nOCSPerr(OCSP_F_OCSP_PARSE_URL, OCSP_R_ERROR_PARSING_URL);\\r\\nerr:\\r\\nif (buf) OPENSSL_free(buf);\\r\\nif (*ppath) OPENSSL_free(*ppath);\\r\\nif (*pport) OPENSSL_free(*pport);\\r\\nif (*phost) OPENSSL_free(*phost);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s_client_c", "target": 0, "func": "static void sc_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"usage: s_client args\\n\");\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nBIO_printf(bio_err,\" -host host - use -connect instead\\n\");\\r\\nBIO_printf(bio_err,\" -port port - use -connect instead\\n\");\\r\\nBIO_printf(bio_err,\" -connect host:port - who to connect to (default is %s:%s)\\n\",SSL_HOST_NAME,PORT_STR);\\r\\nBIO_printf(bio_err,\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\" -cert arg - certificate file to use, PEM format assumed\\n\");\\r\\nBIO_printf(bio_err,\" -certform arg - certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -key arg - Private key file to use, in cert file if\\n\");\\r\\nBIO_printf(bio_err,\" not specified but cert file is.\\n\");\\r\\nBIO_printf(bio_err,\" -keyform arg - key format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -pass arg - private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -reconnect - Drop and re-make the connection with the same Session-ID\\n\");\\r\\nBIO_printf(bio_err,\" -pause - sleep(1) after each read(2) and write(2) system call\\n\");\\r\\nBIO_printf(bio_err,\" -showcerts - show all certificates in the chain\\n\");\\r\\nBIO_printf(bio_err,\" -debug - extra output\\n\");\\r\\n#ifdef WATT32\\r\\nBIO_printf(bio_err,\" -wdebug - WATT-32 tcp debugging\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -msg - Show protocol messages\\n\");\\r\\nBIO_printf(bio_err,\" -nbio_test - more ssl protocol testing\\n\");\\r\\nBIO_printf(bio_err,\" -state - print the 'ssl' states\\n\");\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err,\" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\nBIO_printf(bio_err,\" -quiet - no s_client output\\n\");\\r\\nBIO_printf(bio_err,\" -ign_eof - ignore input eof (default when -quiet)\\n\");\\r\\nBIO_printf(bio_err,\" -ssl2 - just use SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -ssl3 - just use SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -tls1 - just use TLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -dtls1 - just use DTLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -mtu - set the MTU\\n\");\\r\\nBIO_printf(bio_err,\" -no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\\n\");\\r\\nBIO_printf(bio_err,\" -bugs - Switch on all SSL implementation bug workarounds\\n\");\\r\\nBIO_printf(bio_err,\" -serverpref - Use server's cipher preferences (only SSLv2)\\n\");\\r\\nBIO_printf(bio_err,\" -cipher - preferred cipher to use, use the 'openssl ciphers'\\n\");\\r\\nBIO_printf(bio_err,\" command to see what is available\\n\");\\r\\nBIO_printf(bio_err,\" -starttls prot - use the STARTTLS command before starting TLS\\n\");\\r\\nBIO_printf(bio_err,\" for those protocols that support it, where\\n\");\\r\\nBIO_printf(bio_err,\" 'prot' defines which one to assume. Currently,\\n\");\\r\\nBIO_printf(bio_err,\" only \\\"smtp\\\" and \\\"pop3\\\" are supported.\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine id - Initialise and use the specified engine\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint off=0;\\r\\nSSL *con=NULL,*con2=NULL;\\r\\nX509_STORE *store = NULL;\\r\\nint s,k,width,state=0;\\r\\nchar *cbuf=NULL,*sbuf=NULL,*mbuf=NULL;\\r\\nint cbuf_len,cbuf_off;\\r\\nint sbuf_len,sbuf_off;\\r\\nfd_set readfds,writefds;\\r\\nshort port=PORT;\\r\\nint full_log=1;\\r\\nchar *host=SSL_HOST_NAME;\\r\\nchar *cert_file=NULL,*key_file=NULL;\\r\\nint cert_format = FORMAT_PEM, key_format = FORMAT_PEM;\\r\\nchar *passarg = NULL, *pass = NULL;\\r\\nX509 *cert = NULL;\\r\\nEVP_PKEY *key = NULL;\\r\\nchar *CApath=NULL,*CAfile=NULL,*cipher=NULL;\\r\\nint reconnect=0,badop=0,verify=SSL_VERIFY_NONE,bugs=0;\\r\\nint crlf=0;\\r\\nint write_tty,read_tty,write_ssl,read_ssl,tty_on,ssl_pending;\\r\\nSSL_CTX *ctx=NULL;\\r\\nint ret=1,in_init=1,i,nbio_test=0;\\r\\nint starttls_proto = 0;\\r\\nint prexit = 0, vflags = 0;\\r\\nSSL_METHOD *meth=NULL;\\r\\n#ifdef sock_type\\r\\n#undef sock_type\\r\\n#endif\\r\\nint sock_type=SOCK_STREAM;\\r\\nBIO *sbio;\\r\\nchar *inrand=NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine_id=NULL;\\r\\nENGINE *e=NULL;\\r\\n#endif\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\\r\\nstruct timeval tv;\\r\\n#endif\\r\\nstruct sockaddr peer;\\r\\nint peerlen = sizeof(peer);\\r\\nint enable_timeouts = 0 ;\\r\\nlong mtu = 0;\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv23_client_method();\\r\\n#elif !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv3_client_method();\\r\\n#elif !defined(OPENSSL_NO_SSL2)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\napps_startup();\\r\\nc_Pause=0;\\r\\nc_quiet=0;\\r\\nc_ign_eof=0;\\r\\nc_debug=0;\\r\\nc_msg=0;\\r\\nc_showcerts=0;\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nif ( ((cbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||\\r\\n((sbuf=OPENSSL_malloc(BUFSIZZ)) == NULL) ||\\r\\n((mbuf=OPENSSL_malloc(BUFSIZZ)) == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nverify_depth=0;\\r\\nverify_error=X509_V_OK;\\r\\n#ifdef FIONBIO\\r\\nc_nbio=0;\\r\\n#endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-host\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-port\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nport=atoi(*(++argv));\\r\\nif (port == 0) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-connect\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!extract_host_port(*(++argv),&host,NULL,&port))\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\n{\\r\\nverify=SSL_VERIFY_PEER;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncert_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-certform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncert_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_check\") == 0)\\r\\nvflags |= X509_V_FLAG_CRL_CHECK;\\r\\nelse if (strcmp(*argv,\"-crl_check_all\") == 0)\\r\\nvflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\\r\\nelse if (strcmp(*argv,\"-prexit\") == 0)\\r\\nprexit=1;\\r\\nelse if (strcmp(*argv,\"-crlf\") == 0)\\r\\ncrlf=1;\\r\\nelse if (strcmp(*argv,\"-quiet\") == 0)\\r\\n{\\r\\nc_quiet=1;\\r\\nc_ign_eof=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-ign_eof\") == 0)\\r\\nc_ign_eof=1;\\r\\nelse if (strcmp(*argv,\"-pause\") == 0)\\r\\nc_Pause=1;\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\nc_debug=1;\\r\\n#ifdef WATT32\\r\\nelse if (strcmp(*argv,\"-wdebug\") == 0)\\r\\ndbug_init();\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-msg\") == 0)\\r\\nc_msg=1;\\r\\nelse if (strcmp(*argv,\"-showcerts\") == 0)\\r\\nc_showcerts=1;\\r\\nelse if (strcmp(*argv,\"-nbio_test\") == 0)\\r\\nnbio_test=1;\\r\\nelse if (strcmp(*argv,\"-state\") == 0)\\r\\nstate=1;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\nmeth=SSLv3_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv,\"-tls1\") == 0)\\r\\nmeth=TLSv1_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DTLS1\\r\\nelse if (strcmp(*argv,\"-dtls1\") == 0)\\r\\n{\\r\\nmeth=DTLSv1_client_method();\\r\\nsock_type=SOCK_DGRAM;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-timeout\") == 0)\\r\\nenable_timeouts=1;\\r\\nelse if (strcmp(*argv,\"-mtu\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nmtu = atol(*(++argv));\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-bugs\") == 0)\\r\\nbugs=1;\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-pass\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassarg = *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-reconnect\") == 0)\\r\\n{\\r\\nreconnect=5;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-no_tls1\") == 0)\\r\\noff|=SSL_OP_NO_TLSv1;\\r\\nelse if (strcmp(*argv,\"-no_ssl3\") == 0)\\r\\noff|=SSL_OP_NO_SSLv3;\\r\\nelse if (strcmp(*argv,\"-no_ssl2\") == 0)\\r\\noff|=SSL_OP_NO_SSLv2;\\r\\nelse if (strcmp(*argv,\"-serverpref\") == 0)\\r\\noff|=SSL_OP_CIPHER_SERVER_PREFERENCE;\\r\\nelse if (strcmp(*argv,\"-cipher\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncipher= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv,\"-nbio\") == 0)\\r\\n{ c_nbio=1; }\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-starttls\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\n++argv;\\r\\nif (strcmp(*argv,\"smtp\") == 0)\\r\\nstarttls_proto = 1;\\r\\nelse if (strcmp(*argv,\"pop3\") == 0)\\r\\nstarttls_proto = 2;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine_id = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop)\\r\\n{\\r\\nbad:\\r\\nsc_usage();\\r\\ngoto end;\\r\\n}\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nSSL_load_error_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine_id, 1);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passarg, NULL, &pass, NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (key_file == NULL)\\r\\nkey_file = cert_file;\\r\\nif (key_file)\\r\\n{\\r\\nkey = load_key(bio_err, key_file, key_format, 0, pass, e,\\r\\n\"client certificate private key file\");\\r\\nif (!key)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (cert_file)\\r\\n{\\r\\ncert = load_cert(bio_err,cert_file,cert_format,\\r\\nNULL, e, \"client certificate file\");\\r\\nif (!cert)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status())\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nif (bio_c_out == NULL)\\r\\n{\\r\\nif (c_quiet && !c_debug && !c_msg)\\r\\n{\\r\\nbio_c_out=BIO_new(BIO_s_null());\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bio_c_out == NULL)\\r\\nbio_c_out=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (bugs)\\r\\nSSL_CTX_set_options(ctx,SSL_OP_ALL|off);\\r\\nelse\\r\\nSSL_CTX_set_options(ctx,off);\\r\\nif (sock_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);\\r\\nif (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);\\r\\nif (cipher != NULL)\\r\\nif(!SSL_CTX_set_cipher_list(ctx,cipher)) {\\r\\nBIO_printf(bio_err,\"error setting cipher list\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#if 0\\r\\nelse\\r\\nSSL_CTX_set_cipher_list(ctx,getenv(\"SSL_CIPHER\"));\\r\\n#endif\\r\\nSSL_CTX_set_verify(ctx,verify,verify_callback);\\r\\nif (!set_cert_key_stuff(ctx,cert,key))\\r\\ngoto end;\\r\\nif ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nstore = SSL_CTX_get_cert_store(ctx);\\r\\nX509_STORE_set_flags(store, vflags);\\r\\ncon=SSL_new(ctx);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (con && (con->kssl_ctx = kssl_ctx_new()) != NULL)\\r\\n{\\r\\nkssl_ctx_setstring(con->kssl_ctx, KSSL_SERVER, host);\\r\\n}\\r\\n#endif\\r\\nre_start:\\r\\nif (init_client(&s,host,port,sock_type) == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"connect:errno=%d\\n\",get_last_socket_error());\\r\\nSHUTDOWN(s);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_c_out,\"CONNECTED(%08X)\\n\",s);\\r\\n#ifdef FIONBIO\\r\\nif (c_nbio)\\r\\n{\\r\\nunsigned long l=1;\\r\\nBIO_printf(bio_c_out,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&l) < 0)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (c_Pause & 0x01) con->debug=1;\\r\\nif ( SSL_version(con) == DTLS1_VERSION)\\r\\n{\\r\\nstruct timeval timeout;\\r\\nsbio=BIO_new_dgram(s,BIO_NOCLOSE);\\r\\nif (getsockname(s, &peer, (void *)&peerlen) < 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"getsockname:errno=%d\\n\",\\r\\nget_last_socket_error());\\r\\nSHUTDOWN(s);\\r\\ngoto end;\\r\\n}\\r\\nBIO_ctrl_set_connected(sbio, 1, &peer);\\r\\nif ( enable_timeouts)\\r\\n{\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_RCV_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_SND_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\\r\\n}\\r\\nif ( mtu > 0)\\r\\n{\\r\\nSSL_set_options(con, SSL_OP_NO_QUERY_MTU);\\r\\nSSL_set_mtu(con, mtu);\\r\\n}\\r\\nelse\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\\r\\n}\\r\\nelse\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nif (c_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(sbio,bio_dump_callback);\\r\\nBIO_set_callback_arg(sbio,bio_c_out);\\r\\n}\\r\\nif (c_msg)\\r\\n{\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_c_out);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_connect_state(con);\\r\\nwidth=SSL_get_fd(con)+1;\\r\\nread_tty=1;\\r\\nwrite_tty=0;\\r\\ntty_on=0;\\r\\nread_ssl=1;\\r\\nwrite_ssl=1;\\r\\ncbuf_len=0;\\r\\ncbuf_off=0;\\r\\nsbuf_len=0;\\r\\nsbuf_off=0;\\r\\nif (starttls_proto == 1)\\r\\n{\\r\\nBIO_read(sbio,mbuf,BUFSIZZ);\\r\\nBIO_printf(sbio,\"STARTTLS\\r\\n\");\\r\\nBIO_read(sbio,sbuf,BUFSIZZ);\\r\\n}\\r\\nif (starttls_proto == 2)\\r\\n{\\r\\nBIO_read(sbio,mbuf,BUFSIZZ);\\r\\nBIO_printf(sbio,\"STLS\\r\\n\");\\r\\nBIO_read(sbio,sbuf,BUFSIZZ);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nFD_ZERO(&readfds);\\r\\nFD_ZERO(&writefds);\\r\\nif (SSL_in_init(con) && !SSL_total_renegotiations(con))\\r\\n{\\r\\nin_init=1;\\r\\ntty_on=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntty_on=1;\\r\\nif (in_init)\\r\\n{\\r\\nin_init=0;\\r\\nprint_stuff(bio_c_out,con,full_log);\\r\\nif (full_log > 0) full_log--;\\r\\nif (starttls_proto)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s\",mbuf);\\r\\nstarttls_proto = 0;\\r\\n}\\r\\nif (reconnect)\\r\\n{\\r\\nreconnect--;\\r\\nBIO_printf(bio_c_out,\"drop connection and then reconnect\\n\");\\r\\nSSL_shutdown(con);\\r\\nSSL_set_connect_state(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\ngoto re_start;\\r\\n}\\r\\n}\\r\\n}\\r\\nssl_pending = read_ssl && SSL_pending(con);\\r\\nif (!ssl_pending)\\r\\n{\\r\\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)\\r\\nif (tty_on)\\r\\n{\\r\\nif (read_tty) FD_SET(fileno(stdin),&readfds);\\r\\nif (write_tty) FD_SET(fileno(stdout),&writefds);\\r\\n}\\r\\nif (read_ssl)\\r\\nFD_SET(SSL_get_fd(con),&readfds);\\r\\nif (write_ssl)\\r\\nFD_SET(SSL_get_fd(con),&writefds);\\r\\n#else\\r\\nif(!tty_on || !write_tty) {\\r\\nif (read_ssl)\\r\\nFD_SET(SSL_get_fd(con),&readfds);\\r\\nif (write_ssl)\\r\\nFD_SET(SSL_get_fd(con),&writefds);\\r\\n}\\r\\n#endif\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\\r\\ni=0;\\r\\nif(!write_tty) {\\r\\nif(read_tty) {\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,&tv);\\r\\n#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)\\r\\nif(!i && (!_kbhit() || !read_tty) ) continue;\\r\\n#else\\r\\nif(!i && (!((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0))) || !read_tty) ) continue;\\r\\n#endif\\r\\n} else i=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,NULL);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_NETWARE)\\r\\nif(!write_tty) {\\r\\nif(read_tty) {\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,&tv);\\r\\n} else i=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,NULL);\\r\\n}\\r\\n#else\\r\\ni=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,NULL);\\r\\n#endif\\r\\nif ( i < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"bad select %d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\nif (!ssl_pending && FD_ISSET(SSL_get_fd(con),&writefds))\\r\\n{\\r\\nk=SSL_write(con,&(cbuf[cbuf_off]),\\r\\n(unsigned int)cbuf_len);\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\ncbuf_off+=k;\\r\\ncbuf_len-=k;\\r\\nif (k <= 0) goto end;\\r\\nif (cbuf_len <= 0)\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=0;\\r\\nwrite_ssl=1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out,\"write W BLOCK\\n\");\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out,\"write R BLOCK\\n\");\\r\\nwrite_tty=0;\\r\\nread_ssl=1;\\r\\nwrite_ssl=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out,\"write X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nif (cbuf_len != 0)\\r\\n{\\r\\nBIO_printf(bio_c_out,\"shutdown\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\nbreak;\\r\\n}\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nif ((k != 0) || (cbuf_len != 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"write:errno=%d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\\r\\nelse if (!ssl_pending && write_tty)\\r\\n#else\\r\\nelse if (!ssl_pending && FD_ISSET(fileno(stdout),&writefds))\\r\\n#endif\\r\\n{\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(&(sbuf[sbuf_off]),&(sbuf[sbuf_off]),sbuf_len);\\r\\n#endif\\r\\ni=write(fileno(stdout),&(sbuf[sbuf_off]),sbuf_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_printf(bio_c_out,\"DONE\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nsbuf_len-=i;;\\r\\nsbuf_off+=i;\\r\\nif (sbuf_len <= 0)\\r\\n{\\r\\nread_ssl=1;\\r\\nwrite_tty=0;\\r\\n}\\r\\n}\\r\\nelse if (ssl_pending || FD_ISSET(SSL_get_fd(con),&readfds))\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static int iiii; if (++iiii == 52) { SSL_renegotiate(con); iiii=0; } }\\r\\n#endif\\r\\n#if 1\\r\\nk=SSL_read(con,sbuf,1024 );\\r\\n#else\\r\\nk=SSL_read(con,sbuf,16);\\r\\n{ char zbuf[10240];\\r\\nprintf(\"read=%d pending=%d peek=%d\\n\",k,SSL_pending(con),SSL_peek(con,zbuf,10240));\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (k <= 0)\\r\\ngoto end;\\r\\nsbuf_off=0;\\r\\nsbuf_len=k;\\r\\nread_ssl=0;\\r\\nwrite_tty=1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out,\"read W BLOCK\\n\");\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out,\"read R BLOCK\\n\");\\r\\nwrite_tty=0;\\r\\nread_ssl=1;\\r\\nif ((read_tty == 0) && (write_ssl == 0))\\r\\nwrite_ssl=1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out,\"read X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nBIO_printf(bio_err,\"read:errno=%d\\n\",get_last_socket_error());\\r\\ngoto shut;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_c_out,\"closed\\n\");\\r\\ngoto shut;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\\r\\n#if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)\\r\\nelse if (_kbhit())\\r\\n#else\\r\\nelse if ((_kbhit()) || (WAIT_OBJECT_0 == WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0)))\\r\\n#endif\\r\\n#elif defined (OPENSSL_SYS_NETWARE)\\r\\nelse if (_kbhit())\\r\\n#else\\r\\nelse if (FD_ISSET(fileno(stdin),&readfds))\\r\\n#endif\\r\\n{\\r\\nif (crlf)\\r\\n{\\r\\nint j, lf_num;\\r\\ni=read(fileno(stdin),cbuf,BUFSIZZ/2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (cbuf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i-1; j >= 0; j--)\\r\\n{\\r\\ncbuf[j+lf_num] = cbuf[j];\\r\\nif (cbuf[j] == '\\n')\\r\\n{\\r\\nlf_num--;\\r\\ni++;\\r\\ncbuf[j+lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n}\\r\\nelse\\r\\ni=read(fileno(stdin),cbuf,BUFSIZZ);\\r\\nif ((!c_ign_eof) && ((i <= 0) || (cbuf[0] == 'Q')))\\r\\n{\\r\\nBIO_printf(bio_err,\"DONE\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nif ((!c_ign_eof) && (cbuf[0] == 'R'))\\r\\n{\\r\\nBIO_printf(bio_err,\"RENEGOTIATING\\n\");\\r\\nSSL_renegotiate(con);\\r\\ncbuf_len=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncbuf_len=i;\\r\\ncbuf_off=0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(cbuf, cbuf, i);\\r\\n#endif\\r\\n}\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\n}\\r\\n}\\r\\nshut:\\r\\nSSL_shutdown(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\nret=0;\\r\\nend:\\r\\nif(prexit) print_stuff(bio_c_out,con,1);\\r\\nif (con != NULL) SSL_free(con);\\r\\nif (con2 != NULL) SSL_free(con2);\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (cert)\\r\\nX509_free(cert);\\r\\nif (key)\\r\\nEVP_PKEY_free(key);\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\nif (cbuf != NULL) { OPENSSL_cleanse(cbuf,BUFSIZZ); OPENSSL_free(cbuf); }\\r\\nif (sbuf != NULL) { OPENSSL_cleanse(sbuf,BUFSIZZ); OPENSSL_free(sbuf); }\\r\\nif (mbuf != NULL) { OPENSSL_cleanse(mbuf,BUFSIZZ); OPENSSL_free(mbuf); }\\r\\nif (bio_c_out != NULL)\\r\\n{\\r\\nBIO_free(bio_c_out);\\r\\nbio_c_out=NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void print_stuff(BIO *bio, SSL *s, int full)\\r\\n{\\r\\nX509 *peer=NULL;\\r\\nchar *p;\\r\\nstatic const char *space=\" \";\\r\\nchar buf[BUFSIZ];\\r\\nSTACK_OF(X509) *sk;\\r\\nSTACK_OF(X509_NAME) *sk2;\\r\\nSSL_CIPHER *c;\\r\\nX509_NAME *xn;\\r\\nint j,i;\\r\\nconst COMP_METHOD *comp, *expansion;\\r\\nif (full)\\r\\n{\\r\\nint got_a_chain = 0;\\r\\nsk=SSL_get_peer_cert_chain(s);\\r\\nif (sk != NULL)\\r\\n{\\r\\ngot_a_chain = 1;\\r\\nBIO_printf(bio,\"---\\nCertificate chain\\n\");\\r\\nfor (i=0; i<sk_X509_num(sk); i++)\\r\\n{\\r\\nX509_NAME_oneline(X509_get_subject_name(\\r\\nsk_X509_value(sk,i)),buf,sizeof buf);\\r\\nBIO_printf(bio,\"%2d s:%s\\n\",i,buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(\\r\\nsk_X509_value(sk,i)),buf,sizeof buf);\\r\\nBIO_printf(bio,\" i:%s\\n\",buf);\\r\\nif (c_showcerts)\\r\\nPEM_write_bio_X509(bio,sk_X509_value(sk,i));\\r\\n}\\r\\n}\\r\\nBIO_printf(bio,\"---\\n\");\\r\\npeer=SSL_get_peer_certificate(s);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(bio,\"Server certificate\\n\");\\r\\nif (!(c_showcerts && got_a_chain))\\r\\nPEM_write_bio_X509(bio,peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer),\\r\\nbuf,sizeof buf);\\r\\nBIO_printf(bio,\"subject=%s\\n\",buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer),\\r\\nbuf,sizeof buf);\\r\\nBIO_printf(bio,\"issuer=%s\\n\",buf);\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio,\"no peer certificate available\\n\");\\r\\nsk2=SSL_get_client_CA_list(s);\\r\\nif ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0))\\r\\n{\\r\\nBIO_printf(bio,\"---\\nAcceptable client certificate CA names\\n\");\\r\\nfor (i=0; i<sk_X509_NAME_num(sk2); i++)\\r\\n{\\r\\nxn=sk_X509_NAME_value(sk2,i);\\r\\nX509_NAME_oneline(xn,buf,sizeof(buf));\\r\\nBIO_write(bio,buf,strlen(buf));\\r\\nBIO_write(bio,\"\\n\",1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio,\"---\\nNo client certificate CA names sent\\n\");\\r\\n}\\r\\np=SSL_get_shared_ciphers(s,buf,sizeof buf);\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO_printf(bio,\"---\\nCiphers common between both SSL endpoints:\\n\");\\r\\nj=i=0;\\r\\nwhile (*p)\\r\\n{\\r\\nif (*p == ':')\\r\\n{\\r\\nBIO_write(bio,space,15-j%25);\\r\\ni++;\\r\\nj=0;\\r\\nBIO_write(bio,((i%3)?\" \":\"\\n\"),1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_write(bio,p,1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_write(bio,\"\\n\",1);\\r\\n}\\r\\nBIO_printf(bio,\"---\\nSSL handshake has read %ld bytes and written %ld bytes\\n\",\\r\\nBIO_number_read(SSL_get_rbio(s)),\\r\\nBIO_number_written(SSL_get_wbio(s)));\\r\\n}\\r\\nBIO_printf(bio,((s->hit)?\"---\\nReused, \":\"---\\nNew, \"));\\r\\nc=SSL_get_current_cipher(s);\\r\\nBIO_printf(bio,\"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nif (peer != NULL) {\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(peer);\\r\\nBIO_printf(bio,\"Server public key is %d bit\\n\",\\r\\nEVP_PKEY_bits(pktmp));\\r\\nEVP_PKEY_free(pktmp);\\r\\n}\\r\\ncomp=SSL_get_current_compression(s);\\r\\nexpansion=SSL_get_current_expansion(s);\\r\\nBIO_printf(bio,\"Compression: %s\\n\",\\r\\ncomp ? SSL_COMP_get_name(comp) : \"NONE\");\\r\\nBIO_printf(bio,\"Expansion: %s\\n\",\\r\\nexpansion ? SSL_COMP_get_name(expansion) : \"NONE\");\\r\\nSSL_SESSION_print(bio,SSL_get_session(s));\\r\\nBIO_printf(bio,\"---\\n\");\\r\\nif (peer != NULL)\\r\\nX509_free(peer);\\r\\nBIO_flush(bio);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_dup_c", "target": 0, "func": "void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, char *x)\\r\\n{\\r\\nunsigned char *b,*p;\\r\\nconst unsigned char *p2;\\r\\nint i;\\r\\nchar *ret;\\r\\nif (x == NULL) return(NULL);\\r\\ni=i2d(x,NULL);\\r\\nb=OPENSSL_malloc(i+10);\\r\\nif (b == NULL)\\r\\n{ ASN1err(ASN1_F_ASN1_DUP,ERR_R_MALLOC_FAILURE); return(NULL); }\\r\\np= b;\\r\\ni=i2d(x,&p);\\r\\np2= b;\\r\\nret=d2i(NULL,&p2,i);\\r\\nOPENSSL_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *ASN1_item_dup(const ASN1_ITEM *it, void *x)\\r\\n{\\r\\nunsigned char *b = NULL;\\r\\nconst unsigned char *p;\\r\\nlong i;\\r\\nvoid *ret;\\r\\nif (x == NULL) return(NULL);\\r\\ni=ASN1_item_i2d(x,&b,it);\\r\\nif (b == NULL)\\r\\n{ ASN1err(ASN1_F_ASN1_ITEM_DUP,ERR_R_MALLOC_FAILURE); return(NULL); }\\r\\np= b;\\r\\nret=ASN1_item_d2i(NULL,&p,i, it);\\r\\nOPENSSL_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_attr_c", "target": 0, "func": "int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name,\\r\\nint namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_localKeyID,\\r\\nV_ASN1_OCTET_STRING, name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS8_add_keyusage(PKCS8_PRIV_KEY_INFO *p8, int usage)\\r\\n{\\r\\nunsigned char us_val;\\r\\nus_val = (unsigned char) usage;\\r\\nif (X509at_add1_attr_by_NID(&p8->attributes, NID_key_usage,\\r\\nV_ASN1_BIT_STRING, &us_val, 1))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_friendlyname_asc(PKCS12_SAFEBAG *bag, const char *name,\\r\\nint namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_friendlyName,\\r\\nMBSTRING_ASC, (unsigned char *)name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_friendlyname_uni(PKCS12_SAFEBAG *bag,\\r\\nconst unsigned char *name, int namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_friendlyName,\\r\\nMBSTRING_BMP, name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_CSPName_asc(PKCS12_SAFEBAG *bag, const char *name,\\r\\nint namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_ms_csp_name,\\r\\nMBSTRING_ASC, (unsigned char *)name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nchar *PKCS12_get_friendlyname(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nASN1_TYPE *atype;\\r\\nif (!(atype = PKCS12_get_attr(bag, NID_friendlyName))) return NULL;\\r\\nif (atype->type != V_ASN1_BMPSTRING) return NULL;\\r\\nreturn uni2asc(atype->value.bmpstring->data,\\r\\natype->value.bmpstring->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md4_one_c", "target": 0, "func": "unsigned char *MD4(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD4_CTX c;\\r\\nstatic unsigned char m[MD4_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!MD4_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD4_Update(&c,d,n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0)\\r\\n{\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD4_Update(&c,temp,chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD4_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p1024_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,2);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cbc_cksm_c", "target": 0, "func": "DES_LONG DES_cbc_cksum(const unsigned char *in, DES_cblock *output,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nconst_DES_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG tout0,tout1,tin0,tin1;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *out = &(*output)[0];\\r\\nconst unsigned char *iv = &(*ivec)[0];\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (; l>0; l-=8)\\r\\n{\\r\\nif (l >= 8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\n}\\r\\nelse\\r\\nc2ln(in,tin0,tin1,l);\\r\\ntin0^=tout0; tin[0]=tin0;\\r\\ntin1^=tout1; tin[1]=tin1;\\r\\nDES_encrypt1((DES_LONG *)tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\ntout0=tin0=tin1=tin[0]=tin[1]=0;\\r\\ntout1 = ((tout1 >> 24L) & 0x000000FF)\\r\\n| ((tout1 >> 8L) & 0x0000FF00)\\r\\n| ((tout1 << 8L) & 0x00FF0000)\\r\\n| ((tout1 << 24L) & 0xFF000000);\\r\\nreturn(tout1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_vms_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_vms(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_vms(void)\\r\\n{\\r\\nreturn(&dso_meth_vms);\\r\\n}\\r\\nstatic int vms_load(DSO *dso)\\r\\n{\\r\\nvoid *ptr = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nDSO_VMS_INTERNAL *p;\\r\\nconst char *sp1, *sp2;\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_LOAD,DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nsp1 = strrchr(filename, ']');\\r\\nsp2 = strrchr(filename, '>');\\r\\nif (sp1 == NULL) sp1 = sp2;\\r\\nif (sp2 != NULL && sp2 > sp1) sp1 = sp2;\\r\\nif (sp1 == NULL) sp1 = strrchr(filename, ':');\\r\\nif (sp1 == NULL)\\r\\nsp1 = filename;\\r\\nelse\\r\\nsp1++;\\r\\nsp2 = strchr(sp1, '.');\\r\\nif (sp2 == NULL) sp2 = strchr(sp1, ';');\\r\\nif (sp2 == NULL) sp2 = sp1 + strlen(sp1);\\r\\nif (sp2 - sp1 > FILENAME_MAX\\r\\n|| (sp1 - filename) + strlen(sp2) > FILENAME_MAX)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_LOAD,DSO_R_FILENAME_TOO_BIG);\\r\\ngoto err;\\r\\n}\\r\\np = (DSO_VMS_INTERNAL *)OPENSSL_malloc(sizeof(DSO_VMS_INTERNAL));\\r\\nif(p == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_LOAD,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nstrncpy(p->filename, sp1, sp2-sp1);\\r\\np->filename[sp2-sp1] = '\\0';\\r\\nstrncpy(p->imagename, filename, sp1-filename);\\r\\np->imagename[sp1-filename] = '\\0';\\r\\nstrcat(p->imagename, sp2);\\r\\np->filename_dsc.dsc$w_length = strlen(p->filename);\\r\\np->filename_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\np->filename_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\np->filename_dsc.dsc$a_pointer = p->filename;\\r\\np->imagename_dsc.dsc$w_length = strlen(p->imagename);\\r\\np->imagename_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\np->imagename_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\np->imagename_dsc.dsc$a_pointer = p->imagename;\\r\\nif(!sk_push(dso->meth_data, (char *)p))\\r\\n{\\r\\nDSOerr(DSO_F_VMS_LOAD,DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn(1);\\r\\nerr:\\r\\nif(p != NULL)\\r\\nOPENSSL_free(p);\\r\\nif(filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int vms_unload(DSO *dso)\\r\\n{\\r\\nDSO_VMS_INTERNAL *p;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\nreturn(1);\\r\\np = (DSO_VMS_INTERNAL *)sk_pop(dso->meth_data);\\r\\nif(p == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_UNLOAD,DSO_R_NULL_HANDLE);\\r\\nreturn(0);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int do_find_symbol(DSO_VMS_INTERNAL *ptr,\\r\\nstruct dsc$descriptor_s *symname_dsc, void **sym,\\r\\nunsigned long flags)\\r\\n{\\r\\nlib$establish(lib$sig_to_ret);\\r\\nif(ptr->imagename_dsc.dsc$w_length)\\r\\nreturn lib$find_image_symbol(&ptr->filename_dsc,\\r\\nsymname_dsc, sym,\\r\\n&ptr->imagename_dsc, flags);\\r\\nelse\\r\\nreturn lib$find_image_symbol(&ptr->filename_dsc,\\r\\nsymname_dsc, sym,\\r\\n0, flags);\\r\\n}\\r\\nvoid vms_bind_sym(DSO *dso, const char *symname, void **sym)\\r\\n{\\r\\nDSO_VMS_INTERNAL *ptr;\\r\\nint status;\\r\\n#if 0\\r\\nint flags = (1<<4);\\r\\n#else\\r\\nint flags = 0;\\r\\n#endif\\r\\nstruct dsc$descriptor_s symname_dsc;\\r\\n*sym = NULL;\\r\\nsymname_dsc.dsc$w_length = strlen(symname);\\r\\nsymname_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nsymname_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nsymname_dsc.dsc$a_pointer = (char *)symname;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_VMS_BIND_SYM,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn;\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_BIND_SYM,DSO_R_STACK_ERROR);\\r\\nreturn;\\r\\n}\\r\\nptr = (DSO_VMS_INTERNAL *)sk_value(dso->meth_data,\\r\\nsk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_VMS_BIND_SYM,DSO_R_NULL_HANDLE);\\r\\nreturn;\\r\\n}\\r\\nif(dso->flags & DSO_FLAG_UPCASE_SYMBOL) flags = 0;\\r\\nstatus = do_find_symbol(ptr, &symname_dsc, sym, flags);\\r\\nif(!$VMS_STATUS_SUCCESS(status))\\r\\n{\\r\\nunsigned short length;\\r\\nchar errstring[257];\\r\\nstruct dsc$descriptor_s errstring_dsc;\\r\\nerrstring_dsc.dsc$w_length = sizeof(errstring);\\r\\nerrstring_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nerrstring_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nerrstring_dsc.dsc$a_pointer = errstring;\\r\\n*sym = NULL;\\r\\nstatus = sys$getmsg(status, &length, &errstring_dsc, 1, 0);\\r\\nif (!$VMS_STATUS_SUCCESS(status))\\r\\nlib$signal(status);\\r\\nelse\\r\\n{\\r\\nerrstring[length] = '\\0';\\r\\nDSOerr(DSO_F_VMS_BIND_SYM,DSO_R_SYM_FAILURE);\\r\\nif (ptr->imagename_dsc.dsc$w_length)\\r\\nERR_add_error_data(9,\\r\\n\"Symbol \", symname,\\r\\n\" in \", ptr->filename,\\r\\n\" (\", ptr->imagename, \")\",\\r\\n\": \", errstring);\\r\\nelse\\r\\nERR_add_error_data(6,\\r\\n\"Symbol \", symname,\\r\\n\" in \", ptr->filename,\\r\\n\": \", errstring);\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic void *vms_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *sym = 0;\\r\\nvms_bind_sym(dso, symname, &sym);\\r\\nreturn sym;\\r\\n}\\r\\nstatic DSO_FUNC_TYPE vms_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nDSO_FUNC_TYPE sym = 0;\\r\\nvms_bind_sym(dso, symname, (void **)&sym);\\r\\nreturn sym;\\r\\n}\\r\\nstatic char *vms_merger(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nint status;\\r\\nint filespec1len, filespec2len;\\r\\nstruct FAB fab;\\r\\n#ifdef NAML$C_MAXRSS\\r\\nstruct NAML nam;\\r\\nchar esa[NAML$C_MAXRSS];\\r\\n#else\\r\\nstruct NAM nam;\\r\\nchar esa[NAM$C_MAXRSS];\\r\\n#endif\\r\\nchar *merged;\\r\\nif (!filespec1) filespec1 = \"\";\\r\\nif (!filespec2) filespec2 = \"\";\\r\\nfilespec1len = strlen(filespec1);\\r\\nfilespec2len = strlen(filespec2);\\r\\nfab = cc$rms_fab;\\r\\n#ifdef NAML$C_MAXRSS\\r\\nnam = cc$rms_naml;\\r\\n#else\\r\\nnam = cc$rms_nam;\\r\\n#endif\\r\\nfab.fab$l_fna = (char *)filespec1;\\r\\nfab.fab$b_fns = filespec1len;\\r\\nfab.fab$l_dna = (char *)filespec2;\\r\\nfab.fab$b_dns = filespec2len;\\r\\n#ifdef NAML$C_MAXRSS\\r\\nif (filespec1len > NAM$C_MAXRSS)\\r\\n{\\r\\nfab.fab$l_fna = 0;\\r\\nfab.fab$b_fns = 0;\\r\\nnam.naml$l_long_filename = (char *)filespec1;\\r\\nnam.naml$l_long_filename_size = filespec1len;\\r\\n}\\r\\nif (filespec2len > NAM$C_MAXRSS)\\r\\n{\\r\\nfab.fab$l_dna = 0;\\r\\nfab.fab$b_dns = 0;\\r\\nnam.naml$l_long_defname = (char *)filespec2;\\r\\nnam.naml$l_long_defname_size = filespec2len;\\r\\n}\\r\\nnam.naml$l_esa = esa;\\r\\nnam.naml$b_ess = NAM$C_MAXRSS;\\r\\nnam.naml$l_long_expand = esa;\\r\\nnam.naml$l_long_expand_alloc = sizeof(esa);\\r\\nnam.naml$b_nop = NAM$M_SYNCHK | NAM$M_PWD;\\r\\nnam.naml$v_no_short_upcase = 1;\\r\\nfab.fab$l_naml = &nam;\\r\\n#else\\r\\nnam.nam$l_esa = esa;\\r\\nnam.nam$b_ess = NAM$C_MAXRSS;\\r\\nnam.nam$b_nop = NAM$M_SYNCHK | NAM$M_PWD;\\r\\nfab.fab$l_nam = &nam;\\r\\n#endif\\r\\nstatus = sys$parse(&fab, 0, 0);\\r\\nif(!$VMS_STATUS_SUCCESS(status))\\r\\n{\\r\\nunsigned short length;\\r\\nchar errstring[257];\\r\\nstruct dsc$descriptor_s errstring_dsc;\\r\\nerrstring_dsc.dsc$w_length = sizeof(errstring);\\r\\nerrstring_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nerrstring_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nerrstring_dsc.dsc$a_pointer = errstring;\\r\\nstatus = sys$getmsg(status, &length, &errstring_dsc, 1, 0);\\r\\nif (!$VMS_STATUS_SUCCESS(status))\\r\\nlib$signal(status);\\r\\nelse\\r\\n{\\r\\nerrstring[length] = '\\0';\\r\\nDSOerr(DSO_F_VMS_MERGER,DSO_R_FAILURE);\\r\\nERR_add_error_data(7,\\r\\n\"filespec \\\"\", filespec1, \"\\\", \",\\r\\n\"defaults \\\"\", filespec2, \"\\\": \",\\r\\nerrstring);\\r\\n}\\r\\nreturn(NULL);\\r\\n}\\r\\n#ifdef NAML$C_MAXRSS\\r\\nif (nam.naml$l_long_expand_size)\\r\\n{\\r\\nmerged = OPENSSL_malloc(nam.naml$l_long_expand_size + 1);\\r\\nif(!merged)\\r\\ngoto malloc_err;\\r\\nstrncpy(merged, nam.naml$l_long_expand,\\r\\nnam.naml$l_long_expand_size);\\r\\nmerged[nam.naml$l_long_expand_size] = '\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nmerged = OPENSSL_malloc(nam.naml$b_esl + 1);\\r\\nif(!merged)\\r\\ngoto malloc_err;\\r\\nstrncpy(merged, nam.naml$l_esa,\\r\\nnam.naml$b_esl);\\r\\nmerged[nam.naml$b_esl] = '\\0';\\r\\n}\\r\\n#else\\r\\nmerged = OPENSSL_malloc(nam.nam$b_esl + 1);\\r\\nif(!merged)\\r\\ngoto malloc_err;\\r\\nstrncpy(merged, nam.nam$l_esa,\\r\\nnam.nam$b_esl);\\r\\nmerged[nam.nam$b_esl] = '\\0';\\r\\n#endif\\r\\nreturn(merged);\\r\\nmalloc_err:\\r\\nDSOerr(DSO_F_VMS_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\n}\\r\\nstatic char *vms_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nint len = strlen(filename);\\r\\nchar *not_translated = OPENSSL_malloc(len+1);\\r\\nstrcpy(not_translated,filename);\\r\\nreturn(not_translated);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_atalla_err_c", "target": 0, "func": "static void ERR_load_ATALLA_strings(void)\\r\\n{\\r\\nif (ATALLA_lib_error_code == 0)\\r\\nATALLA_lib_error_code=ERR_get_next_error_library();\\r\\nif (ATALLA_error_init)\\r\\n{\\r\\nATALLA_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(ATALLA_lib_error_code,ATALLA_str_functs);\\r\\nERR_load_strings(ATALLA_lib_error_code,ATALLA_str_reasons);\\r\\n#endif\\r\\n#ifdef ATALLA_LIB_NAME\\r\\nATALLA_lib_name->error = ERR_PACK(ATALLA_lib_error_code,0,0);\\r\\nERR_load_strings(0,ATALLA_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_ATALLA_strings(void)\\r\\n{\\r\\nif (ATALLA_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(ATALLA_lib_error_code,ATALLA_str_functs);\\r\\nERR_unload_strings(ATALLA_lib_error_code,ATALLA_str_reasons);\\r\\n#endif\\r\\n#ifdef ATALLA_LIB_NAME\\r\\nERR_unload_strings(0,ATALLA_lib_name);\\r\\n#endif\\r\\nATALLA_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_ATALLA_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (ATALLA_lib_error_code == 0)\\r\\nATALLA_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(ATALLA_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md5_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"MD5(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nMD5_CTX c;\\r\\nunsigned char md[MD5_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nMD5_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nMD5_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nMD5_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<MD5_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_rsa_c", "target": 0, "func": "void ENGINE_unregister_RSA(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&rsa_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_RSA(void)\\r\\n{\\r\\nengine_table_cleanup(&rsa_table);\\r\\n}\\r\\nint ENGINE_register_RSA(ENGINE *e)\\r\\n{\\r\\nif(e->rsa_meth)\\r\\nreturn engine_table_register(&rsa_table,\\r\\nengine_unregister_all_RSA, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_RSA()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_RSA(e);\\r\\n}\\r\\nint ENGINE_set_default_RSA(ENGINE *e)\\r\\n{\\r\\nif(e->rsa_meth)\\r\\nreturn engine_table_register(&rsa_table,\\r\\nengine_unregister_all_RSA, e, &dummy_nid, 1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_RSA(void)\\r\\n{\\r\\nreturn engine_table_select(&rsa_table, dummy_nid);\\r\\n}\\r\\nconst RSA_METHOD *ENGINE_get_RSA(const ENGINE *e)\\r\\n{\\r\\nreturn e->rsa_meth;\\r\\n}\\r\\nint ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth)\\r\\n{\\r\\ne->rsa_meth = rsa_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_des_opts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic DES_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nstatic DES_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};\\r\\nstatic DES_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};\\r\\nDES_key_schedule sch,sch2,sch3;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most accurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nDES_set_key_unchecked(&key,&sch);\\r\\nDES_set_key_unchecked(&key2,&sch2);\\r\\nDES_set_key_unchecked(&key3,&sch3);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\nDES_set_key_unchecked(&key,sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nDES_encrypt1(data,&(sch[0]),DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\n#ifdef PART1\\r\\ntime_it(des_encrypt_u4_cisc_idx, \"des_encrypt_u4_cisc_idx \", 0);\\r\\ntime_it(des_encrypt_u16_cisc_idx, \"des_encrypt_u16_cisc_idx \", 1);\\r\\ntime_it(des_encrypt_u4_risc1_idx, \"des_encrypt_u4_risc1_idx \", 2);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART2\\r\\ntime_it(des_encrypt_u16_risc1_idx,\"des_encrypt_u16_risc1_idx\", 3);\\r\\ntime_it(des_encrypt_u4_risc2_idx, \"des_encrypt_u4_risc2_idx \", 4);\\r\\ntime_it(des_encrypt_u16_risc2_idx,\"des_encrypt_u16_risc2_idx\", 5);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART3\\r\\ntime_it(des_encrypt_u4_cisc_ptr, \"des_encrypt_u4_cisc_ptr \", 6);\\r\\ntime_it(des_encrypt_u16_cisc_ptr, \"des_encrypt_u16_cisc_ptr \", 7);\\r\\ntime_it(des_encrypt_u4_risc1_ptr, \"des_encrypt_u4_risc1_ptr \", 8);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART4\\r\\ntime_it(des_encrypt_u16_risc1_ptr,\"des_encrypt_u16_risc1_ptr\", 9);\\r\\ntime_it(des_encrypt_u4_risc2_ptr, \"des_encrypt_u4_risc2_ptr \",10);\\r\\ntime_it(des_encrypt_u16_risc2_ptr,\"des_encrypt_u16_risc2_ptr\",11);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART1\\r\\nstr[0]=\" 4 c i\";\\r\\nprint_it(\"des_encrypt_u4_cisc_idx \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"16 c i\";\\r\\nprint_it(\"des_encrypt_u16_cisc_idx \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\" 4 r1 i\";\\r\\nprint_it(\"des_encrypt_u4_risc1_idx \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\n#endif\\r\\n#ifdef PART2\\r\\nstr[3]=\"16 r1 i\";\\r\\nprint_it(\"des_encrypt_u16_risc1_idx\",3);\\r\\nif (max < tm[3]) { max=tm[3]; max_idx=3; }\\r\\nstr[4]=\" 4 r2 i\";\\r\\nprint_it(\"des_encrypt_u4_risc2_idx \",4);\\r\\nif (max < tm[4]) { max=tm[4]; max_idx=4; }\\r\\nstr[5]=\"16 r2 i\";\\r\\nprint_it(\"des_encrypt_u16_risc2_idx\",5);\\r\\nif (max < tm[5]) { max=tm[5]; max_idx=5; }\\r\\n#endif\\r\\n#ifdef PART3\\r\\nstr[6]=\" 4 c p\";\\r\\nprint_it(\"des_encrypt_u4_cisc_ptr \",6);\\r\\nif (max < tm[6]) { max=tm[6]; max_idx=6; }\\r\\nstr[7]=\"16 c p\";\\r\\nprint_it(\"des_encrypt_u16_cisc_ptr \",7);\\r\\nif (max < tm[7]) { max=tm[7]; max_idx=7; }\\r\\nstr[8]=\" 4 r1 p\";\\r\\nprint_it(\"des_encrypt_u4_risc1_ptr \",8);\\r\\nif (max < tm[8]) { max=tm[8]; max_idx=8; }\\r\\n#endif\\r\\n#ifdef PART4\\r\\nstr[9]=\"16 r1 p\";\\r\\nprint_it(\"des_encrypt_u16_risc1_ptr\",9);\\r\\nif (max < tm[9]) { max=tm[9]; max_idx=9; }\\r\\nstr[10]=\" 4 r2 p\";\\r\\nprint_it(\"des_encrypt_u4_risc2_ptr \",10);\\r\\nif (max < tm[10]) { max=tm[10]; max_idx=10; }\\r\\nstr[11]=\"16 r2 p\";\\r\\nprint_it(\"des_encrypt_u16_risc2_ptr\",11);\\r\\nif (max < tm[11]) { max=tm[11]; max_idx=11; }\\r\\n#endif\\r\\nprintf(\"options des ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DDES_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DDES_UNROLL\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DDES_RISC1\\n\");\\r\\nbreak;\\r\\ncase 3:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC1\\n\");\\r\\nbreak;\\r\\ncase 4:\\r\\nprintf(\"-DDES_RISC2\\n\");\\r\\nbreak;\\r\\ncase 5:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC2\\n\");\\r\\nbreak;\\r\\ncase 6:\\r\\nprintf(\"-DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 7:\\r\\nprintf(\"-DDES_UNROLL -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 8:\\r\\nprintf(\"-DDES_RISC1 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 9:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC1 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 10:\\r\\nprintf(\"-DDES_RISC2 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 11:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC2 -DDES_PTR\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md5_one_c", "target": 0, "func": "unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD5_CTX c;\\r\\nstatic unsigned char m[MD5_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!MD5_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD5_Update(&c,d,n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0)\\r\\n{\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD5_Update(&c,temp,chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD5_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_skey_c", "target": 0, "func": "void BF_set_key(BF_KEY *key, int len, const unsigned char *data)\\r\\n{\\r\\nint i;\\r\\nBF_LONG *p,ri,in[2];\\r\\nconst unsigned char *d,*end;\\r\\nmemcpy(key,&bf_init,sizeof(BF_KEY));\\r\\np=key->P;\\r\\nif (len > ((BF_ROUNDS+2)*4)) len=(BF_ROUNDS+2)*4;\\r\\nd=data;\\r\\nend= &(data[len]);\\r\\nfor (i=0; i<(BF_ROUNDS+2); i++)\\r\\n{\\r\\nri= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\np[i]^=ri;\\r\\n}\\r\\nin[0]=0L;\\r\\nin[1]=0L;\\r\\nfor (i=0; i<(BF_ROUNDS+2); i+=2)\\r\\n{\\r\\nBF_encrypt(in,key);\\r\\np[i ]=in[0];\\r\\np[i+1]=in[1];\\r\\n}\\r\\np=key->S;\\r\\nfor (i=0; i<4*256; i+=2)\\r\\n{\\r\\nBF_encrypt(in,key);\\r\\np[i ]=in[0];\\r\\np[i+1]=in[1];\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_ht_c", "target": 0, "func": "OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, char *path, OCSP_REQUEST *req)\\r\\n{\\r\\nBIO *mem = NULL;\\r\\nchar tmpbuf[1024];\\r\\nOCSP_RESPONSE *resp = NULL;\\r\\nchar *p, *q, *r;\\r\\nint len, retcode;\\r\\nstatic char req_txt[] =\\r\\n\"POST %s HTTP/1.0\\r\\n\\\\r\\nContent-Type: application/ocsp-request\\r\\n\\\\r\\nContent-Length: %d\\r\\n\\r\\n\";\\r\\nlen = i2d_OCSP_REQUEST(req, NULL);\\r\\nif(BIO_printf(b, req_txt, path, len) < 0) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_WRITE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif(i2d_OCSP_REQUEST_bio(b, req) <= 0) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_WRITE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif(!(mem = BIO_new(BIO_s_mem()))) goto err;\\r\\nwhile ((len = BIO_read(b, tmpbuf, sizeof tmpbuf))) {\\r\\nif(len < 0) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_READ_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nBIO_write(mem, tmpbuf, len);\\r\\n}\\r\\nif(BIO_gets(mem, tmpbuf, 512) <= 0) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nfor(p = tmpbuf; *p && !isspace((unsigned char)*p); p++) continue;\\r\\nif(!*p) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile(*p && isspace((unsigned char)*p)) p++;\\r\\nif(!*p) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nfor(q = p; *q && !isspace((unsigned char)*q); q++) continue;\\r\\nif(!*q) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*q++ = 0;\\r\\nretcode = strtoul(p, &r, 10);\\r\\nif(*r) goto err;\\r\\nwhile(*q && isspace((unsigned char)*q)) q++;\\r\\nif(*q) {\\r\\nfor(r = q + strlen(q) - 1; isspace((unsigned char)*r); r--) *r = 0;\\r\\n}\\r\\nif(retcode != 200) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_SERVER_RESPONSE_ERROR);\\r\\nif(!*q) {\\r\\nERR_add_error_data(2, \"Code=\", p);\\r\\n}\\r\\nelse {\\r\\nERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nwhile(BIO_gets(mem, tmpbuf, 512) > 0)\\r\\n{\\r\\nfor(p = tmpbuf; *p && isspace((unsigned char)*p); p++) continue;\\r\\nif(!*p) break;\\r\\n}\\r\\nif(*p) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,OCSP_R_NO_CONTENT);\\r\\ngoto err;\\r\\n}\\r\\nif(!(resp = d2i_OCSP_RESPONSE_bio(mem, NULL))) {\\r\\nOCSPerr(OCSP_F_OCSP_SENDREQ_BIO,ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nBIO_free(mem);\\r\\nreturn resp;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_chil_err_c", "target": 0, "func": "static void ERR_load_HWCRHK_strings(void)\\r\\n{\\r\\nif (HWCRHK_lib_error_code == 0)\\r\\nHWCRHK_lib_error_code=ERR_get_next_error_library();\\r\\nif (HWCRHK_error_init)\\r\\n{\\r\\nHWCRHK_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(HWCRHK_lib_error_code,HWCRHK_str_functs);\\r\\nERR_load_strings(HWCRHK_lib_error_code,HWCRHK_str_reasons);\\r\\n#endif\\r\\n#ifdef HWCRHK_LIB_NAME\\r\\nHWCRHK_lib_name->error = ERR_PACK(HWCRHK_lib_error_code,0,0);\\r\\nERR_load_strings(0,HWCRHK_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_HWCRHK_strings(void)\\r\\n{\\r\\nif (HWCRHK_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(HWCRHK_lib_error_code,HWCRHK_str_functs);\\r\\nERR_unload_strings(HWCRHK_lib_error_code,HWCRHK_str_reasons);\\r\\n#endif\\r\\n#ifdef HWCRHK_LIB_NAME\\r\\nERR_unload_strings(0,HWCRHK_lib_name);\\r\\n#endif\\r\\nHWCRHK_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_HWCRHK_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (HWCRHK_lib_error_code == 0)\\r\\nHWCRHK_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(HWCRHK_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sm_c", "target": 0, "func": "void state_machine_init(state_machine_t *machine)\\r\\n{\\r\\nmachine->ssl = NULL;\\r\\nmachine->bio_intossl = machine->bio_fromssl = NULL;\\r\\nbuffer_init(&machine->clean_in);\\r\\nbuffer_init(&machine->clean_out);\\r\\nbuffer_init(&machine->dirty_in);\\r\\nbuffer_init(&machine->dirty_out);\\r\\n}\\r\\nvoid state_machine_close(state_machine_t *machine)\\r\\n{\\r\\nif(machine->ssl)\\r\\nSSL_free(machine->ssl);\\r\\n#if 0\\r\\nif(machine->bio_intossl)\\r\\nBIO_free(machine->bio_intossl);\\r\\nif(machine->bio_fromssl)\\r\\nBIO_free(machine->bio_fromssl);\\r\\n#endif\\r\\nbuffer_close(&machine->clean_in);\\r\\nbuffer_close(&machine->clean_out);\\r\\nbuffer_close(&machine->dirty_in);\\r\\nbuffer_close(&machine->dirty_out);\\r\\nstate_machine_init(machine);\\r\\n}\\r\\nbuffer_t *state_machine_get_buffer(state_machine_t *machine, sm_buffer_t type)\\r\\n{\\r\\nswitch(type) {\\r\\ncase SM_CLEAN_IN:\\r\\nreturn &machine->clean_in;\\r\\ncase SM_CLEAN_OUT:\\r\\nreturn &machine->clean_out;\\r\\ncase SM_DIRTY_IN:\\r\\nreturn &machine->dirty_in;\\r\\ncase SM_DIRTY_OUT:\\r\\nreturn &machine->dirty_out;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nabort();\\r\\nreturn NULL;\\r\\n}\\r\\nSSL *state_machine_get_SSL(state_machine_t *machine)\\r\\n{\\r\\nreturn machine->ssl;\\r\\n}\\r\\nint state_machine_set_SSL(state_machine_t *machine, SSL *ssl, int is_server)\\r\\n{\\r\\nif(machine->ssl)\\r\\nabort();\\r\\nmachine->ssl = ssl;\\r\\nif((machine->bio_intossl = BIO_new(BIO_s_mem())) == NULL)\\r\\nabort();\\r\\nif((machine->bio_fromssl = BIO_new(BIO_s_mem())) == NULL)\\r\\nabort();\\r\\nSSL_set_bio(machine->ssl, machine->bio_intossl, machine->bio_fromssl);\\r\\nif(is_server)\\r\\nSSL_set_accept_state(machine->ssl);\\r\\nelse\\r\\nSSL_set_connect_state(machine->ssl);\\r\\nreturn state_machine_churn(machine);\\r\\n}\\r\\nint state_machine_churn(state_machine_t *machine)\\r\\n{\\r\\nunsigned int loop;\\r\\nif(machine->ssl == NULL) {\\r\\nif(buffer_empty(&machine->clean_out))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nfor(loop = 0; loop < 2; loop++) {\\r\\nbuffer_to_SSL(&machine->clean_in, machine->ssl);\\r\\nbuffer_to_BIO(&machine->dirty_in, machine->bio_intossl);\\r\\nbuffer_from_SSL(&machine->clean_out, machine->ssl);\\r\\nbuffer_from_BIO(&machine->dirty_out, machine->bio_fromssl);\\r\\n}\\r\\nif(SSL_get_app_data(machine->ssl) || (SSL_get_shutdown(machine->ssl) &&\\r\\nbuffer_empty(&machine->dirty_out))) {\\r\\nif(!state_machine_close_dirty(machine))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint state_machine_close_clean(state_machine_t *machine)\\r\\n{\\r\\nbuffer_close(&machine->clean_in);\\r\\nbuffer_close(&machine->clean_out);\\r\\nif(machine->ssl)\\r\\nSSL_shutdown(machine->ssl);\\r\\nstate_machine_churn(machine);\\r\\nif(buffer_empty(&machine->dirty_in) &&\\r\\nbuffer_empty(&machine->dirty_out))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint state_machine_close_dirty(state_machine_t *machine)\\r\\n{\\r\\nbuffer_close(&machine->dirty_in);\\r\\nbuffer_close(&machine->dirty_out);\\r\\nbuffer_close(&machine->clean_in);\\r\\nif(machine->ssl)\\r\\nSSL_free(machine->ssl);\\r\\nmachine->ssl = NULL;\\r\\nmachine->bio_intossl = machine->bio_fromssl = NULL;\\r\\nif(buffer_empty(&machine->clean_out))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_lib_c", "target": 0, "func": "void DH_set_default_method(const DH_METHOD *meth)\\r\\n{\\r\\ndefault_DH_method = meth;\\r\\n}\\r\\nconst DH_METHOD *DH_get_default_method(void)\\r\\n{\\r\\nif(!default_DH_method)\\r\\ndefault_DH_method = DH_OpenSSL();\\r\\nreturn default_DH_method;\\r\\n}\\r\\nint DH_set_method(DH *dh, const DH_METHOD *meth)\\r\\n{\\r\\nconst DH_METHOD *mtmp;\\r\\nmtmp = dh->meth;\\r\\nif (mtmp->finish) mtmp->finish(dh);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (dh->engine)\\r\\n{\\r\\nENGINE_finish(dh->engine);\\r\\ndh->engine = NULL;\\r\\n}\\r\\n#endif\\r\\ndh->meth = meth;\\r\\nif (meth->init) meth->init(dh);\\r\\nreturn 1;\\r\\n}\\r\\nDH *DH_new(void)\\r\\n{\\r\\nreturn DH_new_method(NULL);\\r\\n}\\r\\nDH *DH_new_method(ENGINE *engine)\\r\\n{\\r\\nDH *ret;\\r\\nret=(DH *)OPENSSL_malloc(sizeof(DH));\\r\\nif (ret == NULL)\\r\\n{\\r\\nDHerr(DH_F_DH_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->meth = DH_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine)\\r\\n{\\r\\nif (!ENGINE_init(engine))\\r\\n{\\r\\nDHerr(DH_F_DH_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n}\\r\\nelse\\r\\nret->engine = ENGINE_get_default_DH();\\r\\nif(ret->engine)\\r\\n{\\r\\nret->meth = ENGINE_get_DH(ret->engine);\\r\\nif(!ret->meth)\\r\\n{\\r\\nDHerr(DH_F_DH_NEW_METHOD,ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->p=NULL;\\r\\nret->g=NULL;\\r\\nret->length=0;\\r\\nret->pub_key=NULL;\\r\\nret->priv_key=NULL;\\r\\nret->q=NULL;\\r\\nret->j=NULL;\\r\\nret->seed = NULL;\\r\\nret->seedlen = 0;\\r\\nret->counter = NULL;\\r\\nret->method_mont_p=NULL;\\r\\nret->references = 1;\\r\\nret->flags=ret->meth->flags;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_DH, ret, &ret->ex_data);\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid DH_free(DH *r)\\r\\n{\\r\\nint i;\\r\\nif(r == NULL) return;\\r\\ni = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DH\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"DH_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->g != NULL) BN_clear_free(r->g);\\r\\nif (r->q != NULL) BN_clear_free(r->q);\\r\\nif (r->j != NULL) BN_clear_free(r->j);\\r\\nif (r->seed) OPENSSL_free(r->seed);\\r\\nif (r->counter != NULL) BN_clear_free(r->counter);\\r\\nif (r->pub_key != NULL) BN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL) BN_clear_free(r->priv_key);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint DH_up_ref(DH *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_DH);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DH\",r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2)\\r\\n{\\r\\nfprintf(stderr, \"DH_up, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint DH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint DH_set_ex_data(DH *d, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&d->ex_data,idx,arg));\\r\\n}\\r\\nvoid *DH_get_ex_data(DH *d, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&d->ex_data,idx));\\r\\n}\\r\\nint DH_size(const DH *dh)\\r\\n{\\r\\nreturn(BN_num_bytes(dh->p));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ex_data_c", "target": 0, "func": "static void impl_check(void)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nif(!impl)\\r\\nimpl = &impl_default;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\n}\\r\\nconst CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)\\r\\n{\\r\\nIMPL_CHECK\\r\\nreturn impl;\\r\\n}\\r\\nint CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)\\r\\n{\\r\\nint toret = 0;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nif(!impl)\\r\\n{\\r\\nimpl = i;\\r\\ntoret = 1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic unsigned long ex_hash_cb(const void *a_void)\\r\\n{\\r\\nreturn ((const EX_CLASS_ITEM *)a_void)->class_index;\\r\\n}\\r\\nstatic int ex_cmp_cb(const void *a_void, const void *b_void)\\r\\n{\\r\\nreturn (((const EX_CLASS_ITEM *)a_void)->class_index -\\r\\n((const EX_CLASS_ITEM *)b_void)->class_index);\\r\\n}\\r\\nstatic int ex_data_check(void)\\r\\n{\\r\\nint toret = 1;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nif(!ex_data && ((ex_data = lh_new(ex_hash_cb, ex_cmp_cb)) == NULL))\\r\\ntoret = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic void def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)\\r\\n{\\r\\nOPENSSL_free(funcs);\\r\\n}\\r\\nstatic void def_cleanup_cb(void *a_void)\\r\\n{\\r\\nEX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;\\r\\nsk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);\\r\\nOPENSSL_free(item);\\r\\n}\\r\\nstatic EX_CLASS_ITEM *def_get_class(int class_index)\\r\\n{\\r\\nEX_CLASS_ITEM d, *p, *gen;\\r\\nEX_DATA_CHECK(return NULL;)\\r\\nd.class_index = class_index;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\np = lh_retrieve(ex_data, &d);\\r\\nif(!p)\\r\\n{\\r\\ngen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));\\r\\nif(gen)\\r\\n{\\r\\ngen->class_index = class_index;\\r\\ngen->meth_num = 0;\\r\\ngen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();\\r\\nif(!gen->meth)\\r\\nOPENSSL_free(gen);\\r\\nelse\\r\\n{\\r\\nlh_insert(ex_data, gen);\\r\\np = gen;\\r\\n}\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif(!p)\\r\\nCRYPTOerr(CRYPTO_F_DEF_GET_CLASS,ERR_R_MALLOC_FAILURE);\\r\\nreturn p;\\r\\n}\\r\\nstatic int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nint toret = -1;\\r\\nCRYPTO_EX_DATA_FUNCS *a = (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(\\r\\nsizeof(CRYPTO_EX_DATA_FUNCS));\\r\\nif(!a)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\na->argl=argl;\\r\\na->argp=argp;\\r\\na->new_func=new_func;\\r\\na->dup_func=dup_func;\\r\\na->free_func=free_func;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nwhile (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num)\\r\\n{\\r\\nif (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(a);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ntoret = item->meth_num++;\\r\\nsk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);\\r\\nerr:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic int int_new_class(void)\\r\\n{\\r\\nint toret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\ntoret = ex_class++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic void int_cleanup(void)\\r\\n{\\r\\nEX_DATA_CHECK(return;)\\r\\nlh_doall(ex_data, def_cleanup_cb);\\r\\nlh_free(ex_data);\\r\\nex_data = NULL;\\r\\nimpl = NULL;\\r\\n}\\r\\nstatic int int_get_new_index(int class_index, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nEX_CLASS_ITEM *item = def_get_class(class_index);\\r\\nif(!item)\\r\\nreturn -1;\\r\\nreturn def_add_index(item, argl, argp, new_func, dup_func, free_func);\\r\\n}\\r\\nstatic int int_new_ex_data(int class_index, void *obj,\\r\\nCRYPTO_EX_DATA *ad)\\r\\n{\\r\\nint mx,i;\\r\\nvoid *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nEX_CLASS_ITEM *item = def_get_class(class_index);\\r\\nif(!item)\\r\\nreturn 0;\\r\\nad->sk = NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nif(mx > 0)\\r\\n{\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\\r\\nif(!storage)\\r\\ngoto skip;\\r\\nfor(i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif((mx > 0) && !storage)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < mx; i++)\\r\\n{\\r\\nif(storage[i] && storage[i]->new_func)\\r\\n{\\r\\nptr = CRYPTO_get_ex_data(ad, i);\\r\\nstorage[i]->new_func(obj,ptr,ad,i,\\r\\nstorage[i]->argl,storage[i]->argp);\\r\\n}\\r\\n}\\r\\nif(storage)\\r\\nOPENSSL_free(storage);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\\r\\nCRYPTO_EX_DATA *from)\\r\\n{\\r\\nint mx, j, i;\\r\\nchar *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nEX_CLASS_ITEM *item;\\r\\nif(!from->sk)\\r\\nreturn 1;\\r\\nif((item = def_get_class(class_index)) == NULL)\\r\\nreturn 0;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nj = sk_num(from->sk);\\r\\nif(j < mx)\\r\\nmx = j;\\r\\nif(mx > 0)\\r\\n{\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\\r\\nif(!storage)\\r\\ngoto skip;\\r\\nfor(i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif((mx > 0) && !storage)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < mx; i++)\\r\\n{\\r\\nptr = CRYPTO_get_ex_data(from, i);\\r\\nif(storage[i] && storage[i]->dup_func)\\r\\nstorage[i]->dup_func(to,from,&ptr,i,\\r\\nstorage[i]->argl,storage[i]->argp);\\r\\nCRYPTO_set_ex_data(to,i,ptr);\\r\\n}\\r\\nif(storage)\\r\\nOPENSSL_free(storage);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_free_ex_data(int class_index, void *obj,\\r\\nCRYPTO_EX_DATA *ad)\\r\\n{\\r\\nint mx,i;\\r\\nEX_CLASS_ITEM *item;\\r\\nvoid *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nif((item = def_get_class(class_index)) == NULL)\\r\\nreturn;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nif(mx > 0)\\r\\n{\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\\r\\nif(!storage)\\r\\ngoto skip;\\r\\nfor(i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif((mx > 0) && !storage)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn;\\r\\n}\\r\\nfor(i = 0; i < mx; i++)\\r\\n{\\r\\nif(storage[i] && storage[i]->free_func)\\r\\n{\\r\\nptr = CRYPTO_get_ex_data(ad,i);\\r\\nstorage[i]->free_func(obj,ptr,ad,i,\\r\\nstorage[i]->argl,storage[i]->argp);\\r\\n}\\r\\n}\\r\\nif(storage)\\r\\nOPENSSL_free(storage);\\r\\nif(ad->sk)\\r\\n{\\r\\nsk_free(ad->sk);\\r\\nad->sk=NULL;\\r\\n}\\r\\n}\\r\\nint CRYPTO_ex_data_new_class(void)\\r\\n{\\r\\nIMPL_CHECK\\r\\nreturn EX_IMPL(new_class)();\\r\\n}\\r\\nvoid CRYPTO_cleanup_all_ex_data(void)\\r\\n{\\r\\nIMPL_CHECK\\r\\nEX_IMPL(cleanup)();\\r\\n}\\r\\nint CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nint ret = -1;\\r\\nIMPL_CHECK\\r\\nret = EX_IMPL(get_new_index)(class_index,\\r\\nargl, argp, new_func, dup_func, free_func);\\r\\nreturn ret;\\r\\n}\\r\\nint CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nIMPL_CHECK\\r\\nreturn EX_IMPL(new_ex_data)(class_index, obj, ad);\\r\\n}\\r\\nint CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\\r\\nCRYPTO_EX_DATA *from)\\r\\n{\\r\\nIMPL_CHECK\\r\\nreturn EX_IMPL(dup_ex_data)(class_index, to, from);\\r\\n}\\r\\nvoid CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nIMPL_CHECK\\r\\nEX_IMPL(free_ex_data)(class_index, obj, ad);\\r\\n}\\r\\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)\\r\\n{\\r\\nint i;\\r\\nif (ad->sk == NULL)\\r\\n{\\r\\nif ((ad->sk=sk_new_null()) == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\ni=sk_num(ad->sk);\\r\\nwhile (i <= idx)\\r\\n{\\r\\nif (!sk_push(ad->sk,NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\ni++;\\r\\n}\\r\\nsk_set(ad->sk,idx,val);\\r\\nreturn(1);\\r\\n}\\r\\nvoid *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)\\r\\n{\\r\\nif (ad->sk == NULL)\\r\\nreturn(0);\\r\\nelse if (idx >= sk_num(ad->sk))\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(sk_value(ad->sk,idx));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_idea_spd_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nIDEA_KEY_SCHEDULE sch;\\r\\ndouble a,aa,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nidea_set_encrypt_key(key,&sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nIDEA_INT data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nidea_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/4;\\r\\ncca=count/200;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"idea_set_encrypt_key %ld times\\n\",ca);\\r\\n#define COND(d) (count <= (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing idea_set_encrypt_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea idea_set_encrypt_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_set_decrypt_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_set_decrypt_key %ld times\\n\",cca);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cca); count+=4)\\r\\n{\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea idea_set_decrypt_key's in %.2f seconds\\n\",count,d);\\r\\naa=((double)COUNT(cca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nidea_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),IDEA_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"IDEA set_encrypt_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"IDEA set_decrypt_key per sec = %12.2f (%9.3fuS)\\n\",aa,1.0e6/aa);\\r\\nprintf(\"IDEA raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"IDEA cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pk12err_c", "target": 0, "func": "void ERR_load_PKCS12_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,PKCS12_str_functs);\\r\\nERR_load_strings(0,PKCS12_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_conf_c", "target": 0, "func": "X509_EXTENSION *X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\nX509_EXTENSION *ret;\\r\\ncrit = v3_check_critical(&value);\\r\\nif ((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(name, value, crit, ext_type, ctx);\\r\\nret = do_ext_nconf(conf, ctx, OBJ_sn2nid(name), crit, value);\\r\\nif (!ret)\\r\\n{\\r\\nX509V3err(X509V3_F_X509V3_EXT_NCONF,X509V3_R_ERROR_IN_EXTENSION);\\r\\nERR_add_error_data(4,\"name=\", name, \", value=\", value);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\ncrit = v3_check_critical(&value);\\r\\nif ((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(OBJ_nid2sn(ext_nid),\\r\\nvalue, crit, ext_type, ctx);\\r\\nreturn do_ext_nconf(conf, ctx, ext_nid, crit, value);\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nint crit, char *value)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nX509_EXTENSION *ext;\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nvoid *ext_struc;\\r\\nif (ext_nid == NID_undef)\\r\\n{\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION_NAME);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(method = X509V3_EXT_get_nid(ext_nid)))\\r\\n{\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nif (method->v2i)\\r\\n{\\r\\nif(*value == '@') nval = NCONF_get_section(conf, value + 1);\\r\\nelse nval = X509V3_parse_list(value);\\r\\nif(sk_CONF_VALUE_num(nval) <= 0)\\r\\n{\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_INVALID_EXTENSION_STRING);\\r\\nERR_add_error_data(4, \"name=\", OBJ_nid2sn(ext_nid), \",section=\", value);\\r\\nreturn NULL;\\r\\n}\\r\\next_struc = method->v2i(method, ctx, nval);\\r\\nif(*value != '@') sk_CONF_VALUE_pop_free(nval,\\r\\nX509V3_conf_free);\\r\\nif(!ext_struc) return NULL;\\r\\n}\\r\\nelse if(method->s2i)\\r\\n{\\r\\nif(!(ext_struc = method->s2i(method, ctx, value))) return NULL;\\r\\n}\\r\\nelse if(method->r2i)\\r\\n{\\r\\nif(!ctx->db || !ctx->db_meth)\\r\\n{\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_NO_CONFIG_DATABASE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(ext_struc = method->r2i(method, ctx, value))) return NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);\\r\\nERR_add_error_data(2, \"name=\", OBJ_nid2sn(ext_nid));\\r\\nreturn NULL;\\r\\n}\\r\\next = do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\nif(method->it) ASN1_item_free(ext_struc, ASN1_ITEM_ptr(method->it));\\r\\nelse method->ext_free(ext_struc);\\r\\nreturn ext;\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_i2d(X509V3_EXT_METHOD *method, int ext_nid,\\r\\nint crit, void *ext_struc)\\r\\n{\\r\\nunsigned char *ext_der;\\r\\nint ext_len;\\r\\nASN1_OCTET_STRING *ext_oct;\\r\\nX509_EXTENSION *ext;\\r\\nif (method->it)\\r\\n{\\r\\next_der = NULL;\\r\\next_len = ASN1_item_i2d(ext_struc, &ext_der, ASN1_ITEM_ptr(method->it));\\r\\nif (ext_len < 0) goto merr;\\r\\n}\\r\\nelse\\r\\n{\\r\\nunsigned char *p;\\r\\next_len = method->i2d(ext_struc, NULL);\\r\\nif(!(ext_der = OPENSSL_malloc(ext_len))) goto merr;\\r\\np = ext_der;\\r\\nmethod->i2d(ext_struc, &p);\\r\\n}\\r\\nif (!(ext_oct = M_ASN1_OCTET_STRING_new())) goto merr;\\r\\next_oct->data = ext_der;\\r\\next_oct->length = ext_len;\\r\\next = X509_EXTENSION_create_by_NID(NULL, ext_nid, crit, ext_oct);\\r\\nif (!ext) goto merr;\\r\\nM_ASN1_OCTET_STRING_free(ext_oct);\\r\\nreturn ext;\\r\\nmerr:\\r\\nX509V3err(X509V3_F_DO_EXT_I2D,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nif (!(method = X509V3_EXT_get_nid(ext_nid))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_I2D,X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\n}\\r\\nstatic int v3_check_critical(char **value)\\r\\n{\\r\\nchar *p = *value;\\r\\nif ((strlen(p) < 9) || strncmp(p, \"critical,\", 9)) return 0;\\r\\np+=9;\\r\\nwhile(isspace((unsigned char)*p)) p++;\\r\\n*value = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int v3_check_generic(char **value)\\r\\n{\\r\\nint gen_type = 0;\\r\\nchar *p = *value;\\r\\nif ((strlen(p) >= 4) && !strncmp(p, \"DER:\", 4))\\r\\n{\\r\\np+=4;\\r\\ngen_type = 1;\\r\\n}\\r\\nelse if ((strlen(p) >= 5) && !strncmp(p, \"ASN1:\", 5))\\r\\n{\\r\\np+=5;\\r\\ngen_type = 2;\\r\\n}\\r\\nelse\\r\\nreturn 0;\\r\\nwhile (isspace((unsigned char)*p)) p++;\\r\\n*value = p;\\r\\nreturn gen_type;\\r\\n}\\r\\nstatic X509_EXTENSION *v3_generic_extension(const char *ext, char *value,\\r\\nint crit, int gen_type, X509V3_CTX *ctx)\\r\\n{\\r\\nunsigned char *ext_der=NULL;\\r\\nlong ext_len;\\r\\nASN1_OBJECT *obj=NULL;\\r\\nASN1_OCTET_STRING *oct=NULL;\\r\\nX509_EXTENSION *extension=NULL;\\r\\nif (!(obj = OBJ_txt2obj(ext, 0)))\\r\\n{\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_NAME_ERROR);\\r\\nERR_add_error_data(2, \"name=\", ext);\\r\\ngoto err;\\r\\n}\\r\\nif (gen_type == 1)\\r\\next_der = string_to_hex(value, &ext_len);\\r\\nelse if (gen_type == 2)\\r\\next_der = generic_asn1(value, ctx, &ext_len);\\r\\nif (ext_der == NULL)\\r\\n{\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_VALUE_ERROR);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new()))\\r\\n{\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\noct->data = ext_der;\\r\\noct->length = ext_len;\\r\\next_der = NULL;\\r\\nextension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);\\r\\nerr:\\r\\nASN1_OBJECT_free(obj);\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nif(ext_der) OPENSSL_free(ext_der);\\r\\nreturn extension;\\r\\n}\\r\\nstatic unsigned char *generic_asn1(char *value, X509V3_CTX *ctx, long *ext_len)\\r\\n{\\r\\nASN1_TYPE *typ;\\r\\nunsigned char *ext_der = NULL;\\r\\ntyp = ASN1_generate_v3(value, ctx);\\r\\nif (typ == NULL)\\r\\nreturn NULL;\\r\\n*ext_len = i2d_ASN1_TYPE(typ, &ext_der);\\r\\nASN1_TYPE_free(typ);\\r\\nreturn ext_der;\\r\\n}\\r\\nint X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509 *cert)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) **sk = NULL;\\r\\nif (cert)\\r\\nsk = &cert->cert_info->extensions;\\r\\nreturn X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\n}\\r\\nint X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_CRL *crl)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) **sk = NULL;\\r\\nif (crl)\\r\\nsk = &crl->crl->extensions;\\r\\nreturn X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\n}\\r\\nint X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_REQ *req)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) *extlist = NULL, **sk = NULL;\\r\\nint i;\\r\\nif (req)\\r\\nsk = &extlist;\\r\\ni = X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\nif (!i || !sk)\\r\\nreturn i;\\r\\ni = X509_REQ_add_extensions(req, extlist);\\r\\nsk_X509_EXTENSION_pop_free(extlist, X509_EXTENSION_free);\\r\\nreturn i;\\r\\n}\\r\\nchar * X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)\\r\\n{\\r\\nif(!ctx->db || !ctx->db_meth || !ctx->db_meth->get_string)\\r\\n{\\r\\nX509V3err(X509V3_F_X509V3_GET_STRING,X509V3_R_OPERATION_NOT_DEFINED);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ctx->db_meth->get_string)\\r\\nreturn ctx->db_meth->get_string(ctx->db, name, section);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic char *nconf_get_string(void *db, char *section, char *value)\\r\\n{\\r\\nreturn NCONF_get_string(db, section, value);\\r\\n}\\r\\nvoid X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)\\r\\n{\\r\\nctx->db_meth = &nconf_method;\\r\\nctx->db = conf;\\r\\n}\\r\\nvoid X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,\\r\\nX509_CRL *crl, int flags)\\r\\n{\\r\\nctx->issuer_cert = issuer;\\r\\nctx->subject_cert = subj;\\r\\nctx->crl = crl;\\r\\nctx->subject_req = req;\\r\\nctx->flags = flags;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name,\\r\\nchar *value)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn X509V3_EXT_nconf(&ctmp, ctx, name, value);\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nchar *value)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn X509V3_EXT_nconf_nid(&ctmp, ctx, ext_nid, value);\\r\\n}\\r\\nstatic char *conf_lhash_get_string(void *db, char *section, char *value)\\r\\n{\\r\\nreturn CONF_get_string(db, section, value);\\r\\n}\\r\\nvoid X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH *lhash)\\r\\n{\\r\\nctx->db_meth = &conf_lhash_method;\\r\\nctx->db = lhash;\\r\\n}\\r\\nint X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,\\r\\nX509 *cert)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn X509V3_EXT_add_nconf(&ctmp, ctx, section, cert);\\r\\n}\\r\\nint X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_CRL *crl)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn X509V3_EXT_CRL_add_nconf(&ctmp, ctx, section, crl);\\r\\n}\\r\\nint X509V3_EXT_REQ_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_REQ *req)\\r\\n{\\r\\nCONF ctmp;\\r\\nCONF_set_nconf(&ctmp, conf);\\r\\nreturn X509V3_EXT_REQ_add_nconf(&ctmp, ctx, section, req);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_win32_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_win32(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nstatic FARPROC GetProcAddressA(HMODULE hModule,LPCSTR lpProcName)\\r\\n{\\r\\nWCHAR lpProcNameW[64];\\r\\nint i;\\r\\nfor (i=0;lpProcName[i] && i<64;i++)\\r\\nlpProcNameW[i] = (WCHAR)lpProcName[i];\\r\\nif (i==64) return NULL;\\r\\nlpProcNameW[i] = 0;\\r\\nreturn GetProcAddressW(hModule,lpProcNameW);\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_win32(void)\\r\\n{\\r\\nreturn(&dso_meth_win32);\\r\\n}\\r\\nstatic int win32_load(DSO *dso)\\r\\n{\\r\\nHINSTANCE h = NULL, *p = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nh = LoadLibraryA(filename);\\r\\nif(h == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(3, \"filename(\", filename, \")\");\\r\\ngoto err;\\r\\n}\\r\\np = (HINSTANCE *)OPENSSL_malloc(sizeof(HINSTANCE));\\r\\nif(p == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_LOAD,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n*p = h;\\r\\nif(!sk_push(dso->meth_data, (char *)p))\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn(1);\\r\\nerr:\\r\\nif(filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif(p != NULL)\\r\\nOPENSSL_free(p);\\r\\nif(h != NULL)\\r\\nFreeLibrary(h);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int win32_unload(DSO *dso)\\r\\n{\\r\\nHINSTANCE *p;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\nreturn(1);\\r\\np = (HINSTANCE *)sk_pop(dso->meth_data);\\r\\nif(p == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_UNLOAD,DSO_R_NULL_HANDLE);\\r\\nreturn(0);\\r\\n}\\r\\nif(!FreeLibrary(*p))\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_UNLOAD,DSO_R_UNLOAD_FAILED);\\r\\nsk_push(dso->meth_data, (char *)p);\\r\\nreturn(0);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\nreturn(1);\\r\\n}\\r\\nstatic void *win32_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nHINSTANCE *ptr;\\r\\nvoid *sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (HINSTANCE *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\nsym = GetProcAddress(*ptr, symname);\\r\\nif(sym == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(3, \"symname(\", symname, \")\");\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nHINSTANCE *ptr;\\r\\nvoid *sym;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(sk_num(dso->meth_data) < 1)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_STACK_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nptr = (HINSTANCE *)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif(ptr == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_NULL_HANDLE);\\r\\nreturn(NULL);\\r\\n}\\r\\nsym = GetProcAddress(*ptr, symname);\\r\\nif(sym == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(3, \"symname(\", symname, \")\");\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn((DSO_FUNC_TYPE)sym);\\r\\n}\\r\\nstatic struct file_st *win32_splitter(DSO *dso, const char *filename,\\r\\nint assume_last_is_dir)\\r\\n{\\r\\nstruct file_st *result = NULL;\\r\\nenum { IN_NODE, IN_DEVICE, IN_FILE } position;\\r\\nconst char *start = filename;\\r\\nif (!filename)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_SPLITTER,DSO_R_NO_FILENAME);\\r\\nreturn(NULL);\\r\\n}\\r\\nresult = OPENSSL_malloc(sizeof(struct file_st));\\r\\nif(result == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_SPLITTER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(result, 0, sizeof(struct file_st));\\r\\nposition = IN_DEVICE;\\r\\nif(filename[0] == '\\\\' && filename[1] == '\\\\'\\r\\n|| filename[0] == '/' && filename[1] == '/')\\r\\n{\\r\\nposition = IN_NODE;\\r\\nfilename += 2;\\r\\nstart = filename;\\r\\nresult->node = start;\\r\\n}\\r\\ndo\\r\\n{\\r\\nswitch(filename[0])\\r\\n{\\r\\ncase ':':\\r\\nif(position != IN_DEVICE)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_SPLITTER,\\r\\nDSO_R_INCORRECT_FILE_SYNTAX);\\r\\nreturn(NULL);\\r\\n}\\r\\nresult->device = start;\\r\\nresult->devicelen = filename - start;\\r\\nposition = IN_FILE;\\r\\nstart = ++filename;\\r\\nresult->dir = start;\\r\\nbreak;\\r\\ncase '\\\\':\\r\\ncase '/':\\r\\nif(position == IN_NODE)\\r\\n{\\r\\nresult->nodelen = filename - start;\\r\\nposition = IN_FILE;\\r\\nstart = ++filename;\\r\\nresult->dir = start;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfilename++;\\r\\nresult->dirlen += filename - start;\\r\\n}\\r\\nbreak;\\r\\ncase '\\0':\\r\\nif(position == IN_NODE)\\r\\n{\\r\\nresult->nodelen = filename - start;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif(filename - start > 0)\\r\\n{\\r\\nif (assume_last_is_dir)\\r\\n{\\r\\nresult->devicelen += filename - start;\\r\\n}\\r\\nelse\\r\\n{\\r\\nresult->file = start;\\r\\nresult->filelen = filename - start;\\r\\n}\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nfilename++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nwhile(*filename);\\r\\nif(!result->nodelen) result->node = NULL;\\r\\nif(!result->devicelen) result->device = NULL;\\r\\nif(!result->dirlen) result->dir = NULL;\\r\\nif(!result->filelen) result->file = NULL;\\r\\nreturn(result);\\r\\n}\\r\\nstatic char *win32_joiner(DSO *dso, const struct file_st *file_split)\\r\\n{\\r\\nint len = 0, offset = 0;\\r\\nchar *result = NULL;\\r\\nconst char *start;\\r\\nif(!file_split)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_JOINER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(file_split->node)\\r\\n{\\r\\nlen += 2 + file_split->nodelen;\\r\\nif(file_split->predir || file_split->dir || file_split->file)\\r\\nlen++;\\r\\n}\\r\\nelse if(file_split->device)\\r\\n{\\r\\nlen += file_split->devicelen + 1;\\r\\n}\\r\\nlen += file_split->predirlen;\\r\\nif(file_split->predir && (file_split->dir || file_split->file))\\r\\n{\\r\\nlen++;\\r\\n}\\r\\nlen += file_split->dirlen;\\r\\nif(file_split->dir && file_split->file)\\r\\n{\\r\\nlen++;\\r\\n}\\r\\nlen += file_split->filelen;\\r\\nif(!len)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nresult = OPENSSL_malloc(len + 1);\\r\\nif (!result)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_JOINER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(file_split->node)\\r\\n{\\r\\nstrcpy(&result[offset], \"\\\\\\\\\"); offset += 2;\\r\\nstrncpy(&result[offset], file_split->node,\\r\\nfile_split->nodelen); offset += file_split->nodelen;\\r\\nif(file_split->predir || file_split->dir || file_split->file)\\r\\n{\\r\\nresult[offset] = '\\\\'; offset++;\\r\\n}\\r\\n}\\r\\nelse if(file_split->device)\\r\\n{\\r\\nstrncpy(&result[offset], file_split->device,\\r\\nfile_split->devicelen); offset += file_split->devicelen;\\r\\nresult[offset] = ':'; offset++;\\r\\n}\\r\\nstart = file_split->predir;\\r\\nwhile(file_split->predirlen > (start - file_split->predir))\\r\\n{\\r\\nconst char *end = openssl_strnchr(start, '/',\\r\\nfile_split->predirlen - (start - file_split->predir));\\r\\nif(!end)\\r\\nend = start\\r\\n+ file_split->predirlen\\r\\n- (start - file_split->predir);\\r\\nstrncpy(&result[offset], start,\\r\\nend - start); offset += end - start;\\r\\nresult[offset] = '\\\\'; offset++;\\r\\nstart = end + 1;\\r\\n}\\r\\nif(file_split->predir && (file_split->dir || file_split->file))\\r\\n{\\r\\nresult[offset] = '\\\\'; offset++;\\r\\n}\\r\\nstart = file_split->dir;\\r\\nwhile(file_split->dirlen > (start - file_split->dir))\\r\\n{\\r\\nconst char *end = openssl_strnchr(start, '/',\\r\\nfile_split->dirlen - (start - file_split->dir));\\r\\nif(!end)\\r\\nend = start\\r\\n+ file_split->dirlen\\r\\n- (start - file_split->dir);\\r\\nstrncpy(&result[offset], start,\\r\\nend - start); offset += end - start;\\r\\nresult[offset] = '\\\\'; offset++;\\r\\nstart = end + 1;\\r\\n}\\r\\nif(file_split->dir && file_split->file)\\r\\n{\\r\\nresult[offset] = '\\\\'; offset++;\\r\\n}\\r\\nstrncpy(&result[offset], file_split->file,\\r\\nfile_split->filelen); offset += file_split->filelen;\\r\\nresult[offset] = '\\0';\\r\\nreturn(result);\\r\\n}\\r\\nstatic char *win32_merger(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nchar *merged = NULL;\\r\\nstruct file_st *filespec1_split = NULL;\\r\\nstruct file_st *filespec2_split = NULL;\\r\\nif(!filespec1 && !filespec2)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_MERGER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!filespec2)\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n}\\r\\nelse if (!filespec1)\\r\\n{\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif(!merged)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfilespec1_split = win32_splitter(dso, filespec1, 1);\\r\\nif (!filespec1_split)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nfilespec2_split = win32_splitter(dso, filespec2, 0);\\r\\nif (!filespec1_split)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_MERGER,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(filespec1_split);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!filespec1_split->node && !filespec1_split->device)\\r\\n{\\r\\nfilespec1_split->node = filespec2_split->node;\\r\\nfilespec1_split->nodelen = filespec2_split->nodelen;\\r\\nfilespec1_split->device = filespec2_split->device;\\r\\nfilespec1_split->devicelen = filespec2_split->devicelen;\\r\\n}\\r\\nif (!filespec1_split->dir)\\r\\n{\\r\\nfilespec1_split->dir = filespec2_split->dir;\\r\\nfilespec1_split->dirlen = filespec2_split->dirlen;\\r\\n}\\r\\nelse if (filespec1_split->dir[0] != '\\\\'\\r\\n&& filespec1_split->dir[0] != '/')\\r\\n{\\r\\nfilespec1_split->predir = filespec2_split->dir;\\r\\nfilespec1_split->predirlen = filespec2_split->dirlen;\\r\\n}\\r\\nif (!filespec1_split->file)\\r\\n{\\r\\nfilespec1_split->file = filespec2_split->file;\\r\\nfilespec1_split->filelen = filespec2_split->filelen;\\r\\n}\\r\\nmerged = win32_joiner(dso, filespec1_split);\\r\\n}\\r\\nreturn(merged);\\r\\n}\\r\\nstatic char *win32_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, transform;\\r\\nlen = strlen(filename);\\r\\ntransform = ((strstr(filename, \"/\") == NULL) &&\\r\\n(strstr(filename, \"\\\\\") == NULL) &&\\r\\n(strstr(filename, \":\") == NULL));\\r\\nif(transform)\\r\\ntranslated = OPENSSL_malloc(len + 5);\\r\\nelse\\r\\ntranslated = OPENSSL_malloc(len + 1);\\r\\nif(translated == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_WIN32_NAME_CONVERTER,\\r\\nDSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(transform)\\r\\nsprintf(translated, \"%s.dll\", filename);\\r\\nelse\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn(translated);\\r\\n}\\r\\nstatic const char *openssl_strnchr(const char *string, int c, size_t len)\\r\\n{\\r\\nsize_t i;\\r\\nconst char *p;\\r\\nfor (i = 0, p = string; i < len && *p; i++, p++)\\r\\n{\\r\\nif (*p == c)\\r\\nreturn p;\\r\\n}\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mdc2_one_c", "target": 0, "func": "unsigned char *MDC2(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMDC2_CTX c;\\r\\nstatic unsigned char m[MDC2_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!MDC2_Init(&c))\\r\\nreturn NULL;\\r\\nMDC2_Update(&c,d,n);\\r\\nMDC2_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_win_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nMEMORYSTATUS m;\\r\\nHCRYPTPROV hProvider = 0;\\r\\nBYTE buf[64];\\r\\nDWORD w;\\r\\nHWND h;\\r\\nint good = 0;\\r\\nHMODULE advapi, kernel, user, netapi;\\r\\nCRYPTACQUIRECONTEXTW acquire = 0;\\r\\nCRYPTGENRANDOM gen = 0;\\r\\nCRYPTRELEASECONTEXT release = 0;\\r\\n#if 1\\r\\nNETSTATGET netstatget = 0;\\r\\nNETFREE netfree = 0;\\r\\n#endif\\r\\nOSVERSIONINFO osverinfo ;\\r\\nosverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;\\r\\nGetVersionEx( &osverinfo ) ;\\r\\n#if defined(OPENSSL_SYS_WINCE) && WCEPLATFORM!=MS_HPC_PRO\\r\\n#ifndef CryptAcquireContext\\r\\n#define CryptAcquireContext CryptAcquireContextW\\r\\n#endif\\r\\nif (CryptAcquireContext(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\\r\\n{\\r\\nif (CryptGenRandom(hProvider, sizeof(buf), buf))\\r\\nRAND_add(buf, sizeof(buf), sizeof(buf));\\r\\nCryptReleaseContext(hProvider, 0);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_WINCE\\r\\nadvapi = LoadLibrary(TEXT(\"ADVAPI32.DLL\"));\\r\\nkernel = LoadLibrary(TEXT(\"KERNEL32.DLL\"));\\r\\nuser = LoadLibrary(TEXT(\"USER32.DLL\"));\\r\\nnetapi = LoadLibrary(TEXT(\"NETAPI32.DLL\"));\\r\\n#if 1\\r\\nif (netapi)\\r\\n{\\r\\nnetstatget = (NETSTATGET) GetProcAddress(netapi,\"NetStatisticsGet\");\\r\\nnetfree = (NETFREE) GetProcAddress(netapi,\"NetApiBufferFree\");\\r\\n}\\r\\nif (netstatget && netfree)\\r\\n{\\r\\nLPBYTE outbuf;\\r\\nif (netstatget(NULL, L\"LanmanWorkstation\", 0, 0, &outbuf) == 0)\\r\\n{\\r\\nRAND_add(outbuf, sizeof(STAT_WORKSTATION_0), 45);\\r\\nnetfree(outbuf);\\r\\n}\\r\\nif (netstatget(NULL, L\"LanmanServer\", 0, 0, &outbuf) == 0)\\r\\n{\\r\\nRAND_add(outbuf, sizeof(STAT_SERVER_0), 17);\\r\\nnetfree(outbuf);\\r\\n}\\r\\n}\\r\\nif (netapi)\\r\\nFreeLibrary(netapi);\\r\\n#endif\\r\\n#if 0\\r\\nif ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\\r\\nosverinfo.dwMajorVersion < 5)\\r\\n{\\r\\nLONG rc=ERROR_MORE_DATA;\\r\\nchar * buf=NULL;\\r\\nDWORD bufsz=0;\\r\\nDWORD length;\\r\\nwhile (rc == ERROR_MORE_DATA)\\r\\n{\\r\\nbuf = realloc(buf,bufsz+8192);\\r\\nif (!buf)\\r\\nbreak;\\r\\nbufsz += 8192;\\r\\nlength = bufsz;\\r\\nrc = RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT(\"Global\"),\\r\\nNULL, NULL, buf, &length);\\r\\n}\\r\\nif (rc == ERROR_SUCCESS)\\r\\n{\\r\\nRAND_add(&length, sizeof(length), 0);\\r\\nRAND_add(buf, length, length / 4.0);\\r\\nRegCloseKey(HKEY_PERFORMANCE_DATA);\\r\\n}\\r\\nif (buf)\\r\\nfree(buf);\\r\\n}\\r\\n#endif\\r\\nif (advapi)\\r\\n{\\r\\nacquire = (CRYPTACQUIRECONTEXTW) GetProcAddress(advapi,\\r\\n\"CryptAcquireContextW\");\\r\\ngen = (CRYPTGENRANDOM) GetProcAddress(advapi,\\r\\n\"CryptGenRandom\");\\r\\nrelease = (CRYPTRELEASECONTEXT) GetProcAddress(advapi,\\r\\n\"CryptReleaseContext\");\\r\\n}\\r\\nif (acquire && gen && release)\\r\\n{\\r\\nif (acquire(&hProvider, 0, 0, PROV_RSA_FULL,\\r\\nCRYPT_VERIFYCONTEXT))\\r\\n{\\r\\nif (gen(hProvider, sizeof(buf), buf) != 0)\\r\\n{\\r\\nRAND_add(buf, sizeof(buf), 0);\\r\\ngood = 1;\\r\\n#if 0\\r\\nprintf(\"randomness from PROV_RSA_FULL\\n\");\\r\\n#endif\\r\\n}\\r\\nrelease(hProvider, 0);\\r\\n}\\r\\nif (acquire(&hProvider, 0, INTEL_DEF_PROV, PROV_INTEL_SEC, 0))\\r\\n{\\r\\nif (gen(hProvider, sizeof(buf), buf) != 0)\\r\\n{\\r\\nRAND_add(buf, sizeof(buf), sizeof(buf));\\r\\ngood = 1;\\r\\n#if 0\\r\\nprintf(\"randomness from PROV_INTEL_SEC\\n\");\\r\\n#endif\\r\\n}\\r\\nrelease(hProvider, 0);\\r\\n}\\r\\n}\\r\\nif (advapi)\\r\\nFreeLibrary(advapi);\\r\\nif (user)\\r\\n{\\r\\nGETCURSORINFO cursor;\\r\\nGETFOREGROUNDWINDOW win;\\r\\nGETQUEUESTATUS queue;\\r\\nwin = (GETFOREGROUNDWINDOW) GetProcAddress(user, \"GetForegroundWindow\");\\r\\ncursor = (GETCURSORINFO) GetProcAddress(user, \"GetCursorInfo\");\\r\\nqueue = (GETQUEUESTATUS) GetProcAddress(user, \"GetQueueStatus\");\\r\\nif (win)\\r\\n{\\r\\nh = win();\\r\\nRAND_add(&h, sizeof(h), 0);\\r\\n}\\r\\nif (cursor)\\r\\n{\\r\\nif ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\\r\\nosverinfo.dwMajorVersion < 5)\\r\\ncursor = 0;\\r\\n}\\r\\nif (cursor)\\r\\n{\\r\\nCURSORINFO ci;\\r\\nci.cbSize = sizeof(CURSORINFO);\\r\\nif (cursor(&ci))\\r\\nRAND_add(&ci, ci.cbSize, 2);\\r\\n}\\r\\nif (queue)\\r\\n{\\r\\nw = queue(QS_ALLEVENTS);\\r\\nRAND_add(&w, sizeof(w), 1);\\r\\n}\\r\\nFreeLibrary(user);\\r\\n}\\r\\nif (kernel)\\r\\n{\\r\\nCREATETOOLHELP32SNAPSHOT snap;\\r\\nCLOSETOOLHELP32SNAPSHOT close_snap;\\r\\nHANDLE handle;\\r\\nHEAP32FIRST heap_first;\\r\\nHEAP32NEXT heap_next;\\r\\nHEAP32LIST heaplist_first, heaplist_next;\\r\\nPROCESS32 process_first, process_next;\\r\\nTHREAD32 thread_first, thread_next;\\r\\nMODULE32 module_first, module_next;\\r\\nHEAPLIST32 hlist;\\r\\nHEAPENTRY32 hentry;\\r\\nPROCESSENTRY32 p;\\r\\nTHREADENTRY32 t;\\r\\nMODULEENTRY32 m;\\r\\nDWORD stoptime = 0;\\r\\nsnap = (CREATETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(kernel, \"CreateToolhelp32Snapshot\");\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(kernel, \"CloseToolhelp32Snapshot\");\\r\\nheap_first = (HEAP32FIRST) GetProcAddress(kernel, \"Heap32First\");\\r\\nheap_next = (HEAP32NEXT) GetProcAddress(kernel, \"Heap32Next\");\\r\\nheaplist_first = (HEAP32LIST) GetProcAddress(kernel, \"Heap32ListFirst\");\\r\\nheaplist_next = (HEAP32LIST) GetProcAddress(kernel, \"Heap32ListNext\");\\r\\nprocess_first = (PROCESS32) GetProcAddress(kernel, \"Process32First\");\\r\\nprocess_next = (PROCESS32) GetProcAddress(kernel, \"Process32Next\");\\r\\nthread_first = (THREAD32) GetProcAddress(kernel, \"Thread32First\");\\r\\nthread_next = (THREAD32) GetProcAddress(kernel, \"Thread32Next\");\\r\\nmodule_first = (MODULE32) GetProcAddress(kernel, \"Module32First\");\\r\\nmodule_next = (MODULE32) GetProcAddress(kernel, \"Module32Next\");\\r\\nif (snap && heap_first && heap_next && heaplist_first &&\\r\\nheaplist_next && process_first && process_next &&\\r\\nthread_first && thread_next && module_first &&\\r\\nmodule_next && (handle = snap(TH32CS_SNAPALL,0))\\r\\n!= INVALID_HANDLE_VALUE)\\r\\n{\\r\\nhlist.dwSize = sizeof(HEAPLIST32);\\r\\nif (good) stoptime = GetTickCount() + MAXDELAY;\\r\\nif (heaplist_first(handle, &hlist))\\r\\ndo\\r\\n{\\r\\nRAND_add(&hlist, hlist.dwSize, 3);\\r\\nhentry.dwSize = sizeof(HEAPENTRY32);\\r\\nif (heap_first(&hentry,\\r\\nhlist.th32ProcessID,\\r\\nhlist.th32HeapID))\\r\\n{\\r\\nint entrycnt = 80;\\r\\ndo\\r\\nRAND_add(&hentry,\\r\\nhentry.dwSize, 5);\\r\\nwhile (heap_next(&hentry)\\r\\n&& --entrycnt > 0);\\r\\n}\\r\\n} while (heaplist_next(handle,\\r\\n&hlist) && GetTickCount() < stoptime);\\r\\np.dwSize = sizeof(PROCESSENTRY32);\\r\\nif (good) stoptime = GetTickCount() + MAXDELAY;\\r\\nif (process_first(handle, &p))\\r\\ndo\\r\\nRAND_add(&p, p.dwSize, 9);\\r\\nwhile (process_next(handle, &p) && GetTickCount() < stoptime);\\r\\nt.dwSize = sizeof(THREADENTRY32);\\r\\nif (good) stoptime = GetTickCount() + MAXDELAY;\\r\\nif (thread_first(handle, &t))\\r\\ndo\\r\\nRAND_add(&t, t.dwSize, 6);\\r\\nwhile (thread_next(handle, &t) && GetTickCount() < stoptime);\\r\\nm.dwSize = sizeof(MODULEENTRY32);\\r\\nif (good) stoptime = GetTickCount() + MAXDELAY;\\r\\nif (module_first(handle, &m))\\r\\ndo\\r\\nRAND_add(&m, m.dwSize, 9);\\r\\nwhile (module_next(handle, &m)\\r\\n&& (GetTickCount() < stoptime));\\r\\nif (close_snap)\\r\\nclose_snap(handle);\\r\\nelse\\r\\nCloseHandle(handle);\\r\\n}\\r\\nFreeLibrary(kernel);\\r\\n}\\r\\n#endif\\r\\nreadtimer();\\r\\nGlobalMemoryStatus(&m);\\r\\nRAND_add(&m, sizeof(m), 1);\\r\\nw = GetCurrentProcessId();\\r\\nRAND_add(&w, sizeof(w), 1);\\r\\n#if 0\\r\\nprintf(\"Exiting RAND_poll\\n\");\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nint RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam)\\r\\n{\\r\\ndouble add_entropy=0;\\r\\nswitch (iMsg)\\r\\n{\\r\\ncase WM_KEYDOWN:\\r\\n{\\r\\nstatic WPARAM key;\\r\\nif (key != wParam)\\r\\nadd_entropy = 0.05;\\r\\nkey = wParam;\\r\\n}\\r\\nbreak;\\r\\ncase WM_MOUSEMOVE:\\r\\n{\\r\\nstatic int lastx,lasty,lastdx,lastdy;\\r\\nint x,y,dx,dy;\\r\\nx=LOWORD(lParam);\\r\\ny=HIWORD(lParam);\\r\\ndx=lastx-x;\\r\\ndy=lasty-y;\\r\\nif (dx != 0 && dy != 0 && dx-lastdx != 0 && dy-lastdy != 0)\\r\\nadd_entropy=.2;\\r\\nlastx=x, lasty=y;\\r\\nlastdx=dx, lastdy=dy;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreadtimer();\\r\\nRAND_add(&iMsg, sizeof(iMsg), add_entropy);\\r\\nRAND_add(&wParam, sizeof(wParam), 0);\\r\\nRAND_add(&lParam, sizeof(lParam), 0);\\r\\nreturn (RAND_status());\\r\\n}\\r\\nvoid RAND_screen(void)\\r\\n{\\r\\nRAND_poll();\\r\\nif (GetVersion() >= 0x80000000 || !OPENSSL_isservice())\\r\\nreadscreen();\\r\\n}\\r\\nstatic void readtimer(void)\\r\\n{\\r\\nDWORD w;\\r\\nLARGE_INTEGER l;\\r\\nstatic int have_perfc = 1;\\r\\n#if defined(_MSC_VER) && defined(_M_X86)\\r\\nstatic int have_tsc = 1;\\r\\nDWORD cyclecount;\\r\\nif (have_tsc) {\\r\\n__try {\\r\\n__asm {\\r\\n_emit 0x0f\\r\\n_emit 0x31\\r\\nmov cyclecount, eax\\r\\n}\\r\\nRAND_add(&cyclecount, sizeof(cyclecount), 1);\\r\\n} __except(EXCEPTION_EXECUTE_HANDLER) {\\r\\nhave_tsc = 0;\\r\\n}\\r\\n}\\r\\n#else\\r\\n# define have_tsc 0\\r\\n#endif\\r\\nif (have_perfc) {\\r\\nif (QueryPerformanceCounter(&l) == 0)\\r\\nhave_perfc = 0;\\r\\nelse\\r\\nRAND_add(&l, sizeof(l), 0);\\r\\n}\\r\\nif (!have_tsc && !have_perfc) {\\r\\nw = GetTickCount();\\r\\nRAND_add(&w, sizeof(w), 0);\\r\\n}\\r\\n}\\r\\nstatic void readscreen(void)\\r\\n{\\r\\n#if !defined(OPENSSL_SYS_WINCE) && !defined(OPENSSL_SYS_WIN32_CYGWIN)\\r\\nHDC hScrDC;\\r\\nHDC hMemDC;\\r\\nHBITMAP hBitmap;\\r\\nHBITMAP hOldBitmap;\\r\\nBITMAP bm;\\r\\nunsigned int size;\\r\\nchar *bmbits;\\r\\nint w;\\r\\nint h;\\r\\nint y;\\r\\nint n = 16;\\r\\nhScrDC = CreateDC(TEXT(\"DISPLAY\"), NULL, NULL, NULL);\\r\\nhMemDC = CreateCompatibleDC(hScrDC);\\r\\nw = GetDeviceCaps(hScrDC, HORZRES);\\r\\nh = GetDeviceCaps(hScrDC, VERTRES);\\r\\nhBitmap = CreateCompatibleBitmap(hScrDC, w, n);\\r\\nhOldBitmap = SelectObject(hMemDC, hBitmap);\\r\\nGetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);\\r\\nsize = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;\\r\\nbmbits = OPENSSL_malloc(size);\\r\\nif (bmbits) {\\r\\nfor (y = 0; y < h-n; y += n)\\r\\n{\\r\\nunsigned char md[MD_DIGEST_LENGTH];\\r\\nBitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);\\r\\nGetBitmapBits(hBitmap, size, bmbits);\\r\\nMD(bmbits,size,md);\\r\\nRAND_add(md, MD_DIGEST_LENGTH, 0);\\r\\n}\\r\\nOPENSSL_free(bmbits);\\r\\n}\\r\\nhBitmap = SelectObject(hMemDC, hOldBitmap);\\r\\nDeleteObject(hBitmap);\\r\\nDeleteDC(hMemDC);\\r\\nDeleteDC(hScrDC);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md4_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"MD4(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nMD4_CTX c;\\r\\nunsigned char md[MD4_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nMD4_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,sizeof buf);\\r\\nif (i <= 0) break;\\r\\nMD4_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nMD4_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<MD4_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_cb_c", "target": 0, "func": "long MS_CALLBACK BIO_debug_callback(BIO *bio, int cmd, const char *argp,\\r\\nint argi, long argl, long ret)\\r\\n{\\r\\nBIO *b;\\r\\nMS_STATIC char buf[256];\\r\\nchar *p;\\r\\nlong r=1;\\r\\nsize_t p_maxlen;\\r\\nif (BIO_CB_RETURN & cmd)\\r\\nr=ret;\\r\\nBIO_snprintf(buf,sizeof buf,\"BIO[%08lX]:\",(unsigned long)bio);\\r\\np= &(buf[14]);\\r\\np_maxlen = sizeof buf - 14;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CB_FREE:\\r\\nBIO_snprintf(p,p_maxlen,\"Free - %s\\n\",bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_READ:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nBIO_snprintf(p,p_maxlen,\"read(%d,%d) - %s fd=%d\\n\",\\r\\nbio->num,argi,bio->method->name,bio->num);\\r\\nelse\\r\\nBIO_snprintf(p,p_maxlen,\"read(%d,%d) - %s\\n\",\\r\\nbio->num,argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_WRITE:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nBIO_snprintf(p,p_maxlen,\"write(%d,%d) - %s fd=%d\\n\",\\r\\nbio->num,argi,bio->method->name,bio->num);\\r\\nelse\\r\\nBIO_snprintf(p,p_maxlen,\"write(%d,%d) - %s\\n\",\\r\\nbio->num,argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_PUTS:\\r\\nBIO_snprintf(p,p_maxlen,\"puts() - %s\\n\",bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_GETS:\\r\\nBIO_snprintf(p,p_maxlen,\"gets(%d) - %s\\n\",argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_CTRL:\\r\\nBIO_snprintf(p,p_maxlen,\"ctrl(%d) - %s\\n\",argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_READ:\\r\\nBIO_snprintf(p,p_maxlen,\"read return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_WRITE:\\r\\nBIO_snprintf(p,p_maxlen,\"write return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_GETS:\\r\\nBIO_snprintf(p,p_maxlen,\"gets return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_PUTS:\\r\\nBIO_snprintf(p,p_maxlen,\"puts return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_CTRL:\\r\\nBIO_snprintf(p,p_maxlen,\"ctrl return %ld\\n\",ret);\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_snprintf(p,p_maxlen,\"bio callback - unknown type (%d)\\n\",cmd);\\r\\nbreak;\\r\\n}\\r\\nb=(BIO *)bio->cb_arg;\\r\\nif (b != NULL)\\r\\nBIO_write(b,buf,strlen(buf));\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nelse\\r\\nfputs(buf,stderr);\\r\\n#endif\\r\\nreturn(r);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3_int_c", "target": 0, "func": "static void * s2i_asn1_int(X509V3_EXT_METHOD *meth, X509V3_CTX *ctx, char *value)\\r\\n{\\r\\nreturn s2i_ASN1_INTEGER(meth, value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_stat_c", "target": 0, "func": "const char *SSL_state_string_long(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE: str=\"before SSL initialization\"; break;\\r\\ncase SSL_ST_ACCEPT: str=\"before accept initialization\"; break;\\r\\ncase SSL_ST_CONNECT: str=\"before connect initialization\"; break;\\r\\ncase SSL_ST_OK: str=\"SSL negotiation finished successfully\"; break;\\r\\ncase SSL_ST_RENEGOTIATE: str=\"SSL renegotiate ciphers\"; break;\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT: str=\"before/connect initialization\"; break;\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT: str=\"ok/connect SSL initialization\"; break;\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT: str=\"before/accept initialization\"; break;\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT: str=\"ok/accept SSL initialization\"; break;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION: str=\"SSLv2 client start encryption\"; break;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION: str=\"SSLv2 server start encryption\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A: str=\"SSLv2 write client hello A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B: str=\"SSLv2 write client hello B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A: str=\"SSLv2 read server hello A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B: str=\"SSLv2 read server hello B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str=\"SSLv2 write client master key A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str=\"SSLv2 write client master key B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A: str=\"SSLv2 write client finished A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B: str=\"SSLv2 write client finished B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str=\"SSLv2 write client certificate A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str=\"SSLv2 write client certificate B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str=\"SSLv2 write client certificate C\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str=\"SSLv2 write client certificate D\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A: str=\"SSLv2 read server verify A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B: str=\"SSLv2 read server verify B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A: str=\"SSLv2 read server finished A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B: str=\"SSLv2 read server finished B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A: str=\"SSLv2 read client hello A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B: str=\"SSLv2 read client hello B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C: str=\"SSLv2 read client hello C\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A: str=\"SSLv2 write server hello A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B: str=\"SSLv2 write server hello B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A: str=\"SSLv2 read client master key A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B: str=\"SSLv2 read client master key B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A: str=\"SSLv2 write server verify A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B: str=\"SSLv2 write server verify B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C: str=\"SSLv2 write server verify C\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A: str=\"SSLv2 read client finished A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B: str=\"SSLv2 read client finished B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A: str=\"SSLv2 write server finished A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B: str=\"SSLv2 write server finished B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str=\"SSLv2 write request certificate A\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str=\"SSLv2 write request certificate B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str=\"SSLv2 write request certificate C\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str=\"SSLv2 write request certificate D\"; break;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE: str=\"SSLv2 X509 read server certificate\"; break;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str=\"SSLv2 X509 read client certificate\"; break;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A: str=\"SSLv3 write client hello A\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B: str=\"SSLv3 write client hello B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A: str=\"SSLv3 read server hello A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B: str=\"SSLv3 read server hello B\"; break;\\r\\ncase SSL3_ST_CR_CERT_A: str=\"SSLv3 read server certificate A\"; break;\\r\\ncase SSL3_ST_CR_CERT_B: str=\"SSLv3 read server certificate B\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A: str=\"SSLv3 read server key exchange A\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B: str=\"SSLv3 read server key exchange B\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_A: str=\"SSLv3 read server certificate request A\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_B: str=\"SSLv3 read server certificate request B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A: str=\"SSLv3 read server done A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B: str=\"SSLv3 read server done B\"; break;\\r\\ncase SSL3_ST_CW_CERT_A: str=\"SSLv3 write client certificate A\"; break;\\r\\ncase SSL3_ST_CW_CERT_B: str=\"SSLv3 write client certificate B\"; break;\\r\\ncase SSL3_ST_CW_CERT_C: str=\"SSLv3 write client certificate C\"; break;\\r\\ncase SSL3_ST_CW_CERT_D: str=\"SSLv3 write client certificate D\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A: str=\"SSLv3 write client key exchange A\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B: str=\"SSLv3 write client key exchange B\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A: str=\"SSLv3 write certificate verify A\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B: str=\"SSLv3 write certificate verify B\"; break;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_A: str=\"SSLv3 write change cipher spec A\"; break;\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\ncase SSL3_ST_SW_CHANGE_B: str=\"SSLv3 write change cipher spec B\"; break;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_A: str=\"SSLv3 write finished A\"; break;\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\ncase SSL3_ST_SW_FINISHED_B: str=\"SSLv3 write finished B\"; break;\\r\\ncase SSL3_ST_CR_CHANGE_A:\\r\\ncase SSL3_ST_SR_CHANGE_A: str=\"SSLv3 read change cipher spec A\"; break;\\r\\ncase SSL3_ST_CR_CHANGE_B:\\r\\ncase SSL3_ST_SR_CHANGE_B: str=\"SSLv3 read change cipher spec B\"; break;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_A: str=\"SSLv3 read finished A\"; break;\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\ncase SSL3_ST_SR_FINISHED_B: str=\"SSLv3 read finished B\"; break;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\ncase SSL3_ST_SW_FLUSH: str=\"SSLv3 flush data\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A: str=\"SSLv3 read client hello A\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B: str=\"SSLv3 read client hello B\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C: str=\"SSLv3 read client hello C\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A: str=\"SSLv3 write hello request A\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B: str=\"SSLv3 write hello request B\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C: str=\"SSLv3 write hello request C\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A: str=\"SSLv3 write server hello A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B: str=\"SSLv3 write server hello B\"; break;\\r\\ncase SSL3_ST_SW_CERT_A: str=\"SSLv3 write certificate A\"; break;\\r\\ncase SSL3_ST_SW_CERT_B: str=\"SSLv3 write certificate B\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A: str=\"SSLv3 write key exchange A\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B: str=\"SSLv3 write key exchange B\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_A: str=\"SSLv3 write certificate request A\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_B: str=\"SSLv3 write certificate request B\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A: str=\"SSLv3 write server done A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B: str=\"SSLv3 write server done B\"; break;\\r\\ncase SSL3_ST_SR_CERT_A: str=\"SSLv3 read client certificate A\"; break;\\r\\ncase SSL3_ST_SR_CERT_B: str=\"SSLv3 read client certificate B\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A: str=\"SSLv3 read client key exchange A\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B: str=\"SSLv3 read client key exchange B\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A: str=\"SSLv3 read certificate verify A\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B: str=\"SSLv3 read certificate verify B\"; break;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A: str=\"SSLv2/v3 write client hello A\"; break;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B: str=\"SSLv2/v3 write client hello B\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A: str=\"SSLv2/v3 read server hello A\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B: str=\"SSLv2/v3 read server hello B\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A: str=\"SSLv2/v3 read client hello A\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B: str=\"SSLv2/v3 read client hello B\"; break;\\r\\n#endif\\r\\ndefault: str=\"unknown state\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nconst char *SSL_rstate_string_long(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->rstate)\\r\\n{\\r\\ncase SSL_ST_READ_HEADER: str=\"read header\"; break;\\r\\ncase SSL_ST_READ_BODY: str=\"read body\"; break;\\r\\ncase SSL_ST_READ_DONE: str=\"read done\"; break;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nconst char *SSL_state_string(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE: str=\"PINIT \"; break;\\r\\ncase SSL_ST_ACCEPT: str=\"AINIT \"; break;\\r\\ncase SSL_ST_CONNECT: str=\"CINIT \"; break;\\r\\ncase SSL_ST_OK: str=\"SSLOK \"; break;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION: str=\"2CSENC\"; break;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION: str=\"2SSENC\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A: str=\"2SCH_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B: str=\"2SCH_B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A: str=\"2GSH_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B: str=\"2GSH_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str=\"2SCMKA\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str=\"2SCMKB\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A: str=\"2SCF_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B: str=\"2SCF_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str=\"2SCC_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str=\"2SCC_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str=\"2SCC_C\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str=\"2SCC_D\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A: str=\"2GSV_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B: str=\"2GSV_B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A: str=\"2GSF_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B: str=\"2GSF_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A: str=\"2GCH_A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B: str=\"2GCH_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C: str=\"2GCH_C\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A: str=\"2SSH_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B: str=\"2SSH_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A: str=\"2GCMKA\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B: str=\"2GCMKA\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A: str=\"2SSV_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B: str=\"2SSV_B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C: str=\"2SSV_C\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A: str=\"2GCF_A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B: str=\"2GCF_B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A: str=\"2SSF_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B: str=\"2SSF_B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str=\"2SRC_A\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str=\"2SRC_B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str=\"2SRC_C\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str=\"2SRC_D\"; break;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE: str=\"2X9GSC\"; break;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str=\"2X9GCC\"; break;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\ncase SSL3_ST_CW_FLUSH: str=\"3FLUSH\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A: str=\"3WCH_A\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B: str=\"3WCH_B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A: str=\"3RSH_A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B: str=\"3RSH_B\"; break;\\r\\ncase SSL3_ST_CR_CERT_A: str=\"3RSC_A\"; break;\\r\\ncase SSL3_ST_CR_CERT_B: str=\"3RSC_B\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A: str=\"3RSKEA\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B: str=\"3RSKEB\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_A: str=\"3RCR_A\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_B: str=\"3RCR_B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A: str=\"3RSD_A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B: str=\"3RSD_B\"; break;\\r\\ncase SSL3_ST_CW_CERT_A: str=\"3WCC_A\"; break;\\r\\ncase SSL3_ST_CW_CERT_B: str=\"3WCC_B\"; break;\\r\\ncase SSL3_ST_CW_CERT_C: str=\"3WCC_C\"; break;\\r\\ncase SSL3_ST_CW_CERT_D: str=\"3WCC_D\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A: str=\"3WCKEA\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B: str=\"3WCKEB\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A: str=\"3WCV_A\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B: str=\"3WCV_B\"; break;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_A: str=\"3WCCSA\"; break;\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ncase SSL3_ST_CW_CHANGE_B: str=\"3WCCSB\"; break;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_A: str=\"3WFINA\"; break;\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\ncase SSL3_ST_CW_FINISHED_B: str=\"3WFINB\"; break;\\r\\ncase SSL3_ST_SR_CHANGE_A:\\r\\ncase SSL3_ST_CR_CHANGE_A: str=\"3RCCSA\"; break;\\r\\ncase SSL3_ST_SR_CHANGE_B:\\r\\ncase SSL3_ST_CR_CHANGE_B: str=\"3RCCSB\"; break;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_A: str=\"3RFINA\"; break;\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\ncase SSL3_ST_CR_FINISHED_B: str=\"3RFINB\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A: str=\"3WHR_A\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B: str=\"3WHR_B\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C: str=\"3WHR_C\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A: str=\"3RCH_A\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B: str=\"3RCH_B\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C: str=\"3RCH_C\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A: str=\"3WSH_A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B: str=\"3WSH_B\"; break;\\r\\ncase SSL3_ST_SW_CERT_A: str=\"3WSC_A\"; break;\\r\\ncase SSL3_ST_SW_CERT_B: str=\"3WSC_B\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A: str=\"3WSKEA\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B: str=\"3WSKEB\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_A: str=\"3WCR_A\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_B: str=\"3WCR_B\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A: str=\"3WSD_A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B: str=\"3WSD_B\"; break;\\r\\ncase SSL3_ST_SR_CERT_A: str=\"3RCC_A\"; break;\\r\\ncase SSL3_ST_SR_CERT_B: str=\"3RCC_B\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A: str=\"3RCKEA\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B: str=\"3RCKEB\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A: str=\"3RCV_A\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B: str=\"3RCV_B\"; break;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A: str=\"23WCHA\"; break;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B: str=\"23WCHB\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A: str=\"23RSHA\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B: str=\"23RSHA\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A: str=\"23RCHA\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B: str=\"23RCHB\"; break;\\r\\n#endif\\r\\ndefault: str=\"UNKWN \"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nconst char *SSL_alert_type_string_long(int value)\\r\\n{\\r\\nvalue>>=8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn(\"warning\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn(\"fatal\");\\r\\nelse\\r\\nreturn(\"unknown\");\\r\\n}\\r\\nconst char *SSL_alert_type_string(int value)\\r\\n{\\r\\nvalue>>=8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn(\"W\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn(\"F\");\\r\\nelse\\r\\nreturn(\"U\");\\r\\n}\\r\\nconst char *SSL_alert_desc_string(int value)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (value & 0xff)\\r\\n{\\r\\ncase SSL3_AD_CLOSE_NOTIFY: str=\"CN\"; break;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE: str=\"UM\"; break;\\r\\ncase SSL3_AD_BAD_RECORD_MAC: str=\"BM\"; break;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE: str=\"DF\"; break;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE: str=\"HF\"; break;\\r\\ncase SSL3_AD_NO_CERTIFICATE: str=\"NC\"; break;\\r\\ncase SSL3_AD_BAD_CERTIFICATE: str=\"BC\"; break;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE: str=\"UC\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED: str=\"CR\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED: str=\"CE\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN: str=\"CU\"; break;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER: str=\"IP\"; break;\\r\\ncase TLS1_AD_DECRYPTION_FAILED: str=\"DC\"; break;\\r\\ncase TLS1_AD_RECORD_OVERFLOW: str=\"RO\"; break;\\r\\ncase TLS1_AD_UNKNOWN_CA: str=\"CA\"; break;\\r\\ncase TLS1_AD_ACCESS_DENIED: str=\"AD\"; break;\\r\\ncase TLS1_AD_DECODE_ERROR: str=\"DE\"; break;\\r\\ncase TLS1_AD_DECRYPT_ERROR: str=\"CY\"; break;\\r\\ncase TLS1_AD_EXPORT_RESTRICTION: str=\"ER\"; break;\\r\\ncase TLS1_AD_PROTOCOL_VERSION: str=\"PV\"; break;\\r\\ncase TLS1_AD_INSUFFICIENT_SECURITY: str=\"IS\"; break;\\r\\ncase TLS1_AD_INTERNAL_ERROR: str=\"IE\"; break;\\r\\ncase TLS1_AD_USER_CANCELLED: str=\"US\"; break;\\r\\ncase TLS1_AD_NO_RENEGOTIATION: str=\"NR\"; break;\\r\\ndefault: str=\"UK\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nconst char *SSL_alert_desc_string_long(int value)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (value & 0xff)\\r\\n{\\r\\ncase SSL3_AD_CLOSE_NOTIFY:\\r\\nstr=\"close notify\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE:\\r\\nstr=\"unexpected_message\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_RECORD_MAC:\\r\\nstr=\"bad record mac\";\\r\\nbreak;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE:\\r\\nstr=\"decompression failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE:\\r\\nstr=\"handshake failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_NO_CERTIFICATE:\\r\\nstr=\"no certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_CERTIFICATE:\\r\\nstr=\"bad certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE:\\r\\nstr=\"unsupported certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED:\\r\\nstr=\"certificate revoked\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED:\\r\\nstr=\"certificate expired\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN:\\r\\nstr=\"certificate unknown\";\\r\\nbreak;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER:\\r\\nstr=\"illegal parameter\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPTION_FAILED:\\r\\nstr=\"decryption failed\";\\r\\nbreak;\\r\\ncase TLS1_AD_RECORD_OVERFLOW:\\r\\nstr=\"record overflow\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNKNOWN_CA:\\r\\nstr=\"unknown CA\";\\r\\nbreak;\\r\\ncase TLS1_AD_ACCESS_DENIED:\\r\\nstr=\"access denied\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECODE_ERROR:\\r\\nstr=\"decode error\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPT_ERROR:\\r\\nstr=\"decrypt error\";\\r\\nbreak;\\r\\ncase TLS1_AD_EXPORT_RESTRICTION:\\r\\nstr=\"export restriction\";\\r\\nbreak;\\r\\ncase TLS1_AD_PROTOCOL_VERSION:\\r\\nstr=\"protocol version\";\\r\\nbreak;\\r\\ncase TLS1_AD_INSUFFICIENT_SECURITY:\\r\\nstr=\"insufficient security\";\\r\\nbreak;\\r\\ncase TLS1_AD_INTERNAL_ERROR:\\r\\nstr=\"internal error\";\\r\\nbreak;\\r\\ncase TLS1_AD_USER_CANCELLED:\\r\\nstr=\"user canceled\";\\r\\nbreak;\\r\\ncase TLS1_AD_NO_RENEGOTIATION:\\r\\nstr=\"no renegotiation\";\\r\\nbreak;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nconst char *SSL_rstate_string(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->rstate)\\r\\n{\\r\\ncase SSL_ST_READ_HEADER:str=\"RH\"; break;\\r\\ncase SSL_ST_READ_BODY: str=\"RB\"; break;\\r\\ncase SSL_ST_READ_DONE: str=\"RD\"; break;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_ext_c", "target": 0, "func": "int X509_CRL_get_ext_count(X509_CRL *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->crl->extensions));\\r\\n}\\r\\nint X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->crl->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_OBJ(X509_CRL *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->crl->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->crl->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_get_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->crl->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->crl->extensions,loc));\\r\\n}\\r\\nvoid *X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->crl->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->crl->extensions, nid, value, crit, flags);\\r\\n}\\r\\nint X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->crl->extensions),ex,loc) != NULL);\\r\\n}\\r\\nint X509_get_ext_count(X509 *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->cert_info->extensions));\\r\\n}\\r\\nint X509_get_ext_by_NID(X509 *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->cert_info->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->cert_info->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_get_ext_by_critical(X509 *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->cert_info->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_get_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->cert_info->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_delete_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->cert_info->extensions,loc));\\r\\n}\\r\\nint X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->cert_info->extensions),ex,loc) != NULL);\\r\\n}\\r\\nvoid *X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->cert_info->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->cert_info->extensions, nid, value, crit,\\r\\nflags);\\r\\n}\\r\\nint X509_REVOKED_get_ext_count(X509_REVOKED *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->extensions));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->extensions,loc));\\r\\n}\\r\\nint X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->extensions),ex,loc) != NULL);\\r\\n}\\r\\nvoid *X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->extensions, nid, value, crit, flags);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_txt_db_c", "target": 0, "func": "TXT_DB *TXT_DB_read(BIO *in, int num)\\r\\n{\\r\\nTXT_DB *ret=NULL;\\r\\nint er=1;\\r\\nint esc=0;\\r\\nlong ln=0;\\r\\nint i,add,n;\\r\\nint size=BUFSIZE;\\r\\nint offset=0;\\r\\nchar *p,**pp,*f;\\r\\nBUF_MEM *buf=NULL;\\r\\nif ((buf=BUF_MEM_new()) == NULL) goto err;\\r\\nif (!BUF_MEM_grow(buf,size)) goto err;\\r\\nif ((ret=(TXT_DB *)OPENSSL_malloc(sizeof(TXT_DB))) == NULL)\\r\\ngoto err;\\r\\nret->num_fields=num;\\r\\nret->index=NULL;\\r\\nret->qual=NULL;\\r\\nif ((ret->data=sk_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((ret->index=(LHASH **)OPENSSL_malloc(sizeof(LHASH *)*num)) == NULL)\\r\\ngoto err;\\r\\nif ((ret->qual=(int (**)(char **))OPENSSL_malloc(sizeof(int (**)(char **))*num)) == NULL)\\r\\ngoto err;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nret->index[i]=NULL;\\r\\nret->qual[i]=NULL;\\r\\n}\\r\\nadd=(num+1)*sizeof(char *);\\r\\nbuf->data[size-1]='\\0';\\r\\noffset=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (offset != 0)\\r\\n{\\r\\nsize+=BUFSIZE;\\r\\nif (!BUF_MEM_grow_clean(buf,size)) goto err;\\r\\n}\\r\\nbuf->data[offset]='\\0';\\r\\nBIO_gets(in,&(buf->data[offset]),size-offset);\\r\\nln++;\\r\\nif (buf->data[offset] == '\\0') break;\\r\\nif ((offset == 0) && (buf->data[0] == '#')) continue;\\r\\ni=strlen(&(buf->data[offset]));\\r\\noffset+=i;\\r\\nif (buf->data[offset-1] != '\\n')\\r\\ncontinue;\\r\\nelse\\r\\n{\\r\\nbuf->data[offset-1]='\\0';\\r\\nif (!(p=(char *)OPENSSL_malloc(add+offset))) goto err;\\r\\noffset=0;\\r\\n}\\r\\npp=(char **)p;\\r\\np+=add;\\r\\nn=0;\\r\\npp[n++]=p;\\r\\ni=0;\\r\\nf=buf->data;\\r\\nesc=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (*f == '\\0') break;\\r\\nif (*f == '\\t')\\r\\n{\\r\\nif (esc)\\r\\np--;\\r\\nelse\\r\\n{\\r\\n*(p++)='\\0';\\r\\nf++;\\r\\nif (n >= num) break;\\r\\npp[n++]=p;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nesc=(*f == '\\\\');\\r\\n*(p++)= *(f++);\\r\\n}\\r\\n*(p++)='\\0';\\r\\nif ((n != num) || (*f != '\\0'))\\r\\n{\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr,\"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\\n\",ln,num,n,f);\\r\\n#endif\\r\\ner=2;\\r\\ngoto err;\\r\\n}\\r\\npp[n]=p;\\r\\nif (!sk_push(ret->data,(char *)pp))\\r\\n{\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr,\"failure in sk_push\\n\");\\r\\n#endif\\r\\ner=2;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ner=0;\\r\\nerr:\\r\\nBUF_MEM_free(buf);\\r\\nif (er)\\r\\n{\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nif (er == 1) fprintf(stderr,\"OPENSSL_malloc failure\\n\");\\r\\n#endif\\r\\nif (ret->data != NULL) sk_free(ret->data);\\r\\nif (ret->index != NULL) OPENSSL_free(ret->index);\\r\\nif (ret->qual != NULL) OPENSSL_free(ret->qual);\\r\\nif (ret != NULL) OPENSSL_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nreturn(ret);\\r\\n}\\r\\nchar **TXT_DB_get_by_index(TXT_DB *db, int idx, char **value)\\r\\n{\\r\\nchar **ret;\\r\\nLHASH *lh;\\r\\nif (idx >= db->num_fields)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\\r\\nreturn(NULL);\\r\\n}\\r\\nlh=db->index[idx];\\r\\nif (lh == NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_NO_INDEX;\\r\\nreturn(NULL);\\r\\n}\\r\\nret=(char **)lh_retrieve(lh,value);\\r\\ndb->error=DB_ERROR_OK;\\r\\nreturn(ret);\\r\\n}\\r\\nint TXT_DB_create_index(TXT_DB *db, int field, int (*qual)(char **),\\r\\nLHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE cmp)\\r\\n{\\r\\nLHASH *idx;\\r\\nchar **r;\\r\\nint i,n;\\r\\nif (field >= db->num_fields)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\\r\\nreturn(0);\\r\\n}\\r\\nif ((idx=lh_new(hash,cmp)) == NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_MALLOC;\\r\\nreturn(0);\\r\\n}\\r\\nn=sk_num(db->data);\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nr=(char **)sk_value(db->data,i);\\r\\nif ((qual != NULL) && (qual(r) == 0)) continue;\\r\\nif ((r=lh_insert(idx,r)) != NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_CLASH;\\r\\ndb->arg1=sk_find(db->data,(char *)r);\\r\\ndb->arg2=i;\\r\\nlh_free(idx);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nif (db->index[field] != NULL) lh_free(db->index[field]);\\r\\ndb->index[field]=idx;\\r\\ndb->qual[field]=qual;\\r\\nreturn(1);\\r\\n}\\r\\nlong TXT_DB_write(BIO *out, TXT_DB *db)\\r\\n{\\r\\nlong i,j,n,nn,l,tot=0;\\r\\nchar *p,**pp,*f;\\r\\nBUF_MEM *buf=NULL;\\r\\nlong ret= -1;\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\ngoto err;\\r\\nn=sk_num(db->data);\\r\\nnn=db->num_fields;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\npp=(char **)sk_value(db->data,i);\\r\\nl=0;\\r\\nfor (j=0; j<nn; j++)\\r\\n{\\r\\nif (pp[j] != NULL)\\r\\nl+=strlen(pp[j]);\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(buf,(int)(l*2+nn))) goto err;\\r\\np=buf->data;\\r\\nfor (j=0; j<nn; j++)\\r\\n{\\r\\nf=pp[j];\\r\\nif (f != NULL)\\r\\nfor (;;)\\r\\n{\\r\\nif (*f == '\\0') break;\\r\\nif (*f == '\\t') *(p++)='\\\\';\\r\\n*(p++)= *(f++);\\r\\n}\\r\\n*(p++)='\\t';\\r\\n}\\r\\np[-1]='\\n';\\r\\nj=p-buf->data;\\r\\nif (BIO_write(out,buf->data,(int)j) != j)\\r\\ngoto err;\\r\\ntot+=j;\\r\\n}\\r\\nret=tot;\\r\\nerr:\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nint TXT_DB_insert(TXT_DB *db, char **row)\\r\\n{\\r\\nint i;\\r\\nchar **r;\\r\\nfor (i=0; i<db->num_fields; i++)\\r\\n{\\r\\nif (db->index[i] != NULL)\\r\\n{\\r\\nif ((db->qual[i] != NULL) &&\\r\\n(db->qual[i](row) == 0)) continue;\\r\\nr=(char **)lh_retrieve(db->index[i],row);\\r\\nif (r != NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_CLASH;\\r\\ndb->arg1=i;\\r\\ndb->arg_row=r;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!sk_push(db->data,(char *)row))\\r\\n{\\r\\ndb->error=DB_ERROR_MALLOC;\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<db->num_fields; i++)\\r\\n{\\r\\nif (db->index[i] != NULL)\\r\\n{\\r\\nif ((db->qual[i] != NULL) &&\\r\\n(db->qual[i](row) == 0)) continue;\\r\\nlh_insert(db->index[i],row);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nvoid TXT_DB_free(TXT_DB *db)\\r\\n{\\r\\nint i,n;\\r\\nchar **p,*max;\\r\\nif(db == NULL)\\r\\nreturn;\\r\\nif (db->index != NULL)\\r\\n{\\r\\nfor (i=db->num_fields-1; i>=0; i--)\\r\\nif (db->index[i] != NULL) lh_free(db->index[i]);\\r\\nOPENSSL_free(db->index);\\r\\n}\\r\\nif (db->qual != NULL)\\r\\nOPENSSL_free(db->qual);\\r\\nif (db->data != NULL)\\r\\n{\\r\\nfor (i=sk_num(db->data)-1; i>=0; i--)\\r\\n{\\r\\np=(char **)sk_value(db->data,i);\\r\\nmax=p[db->num_fields];\\r\\nif (max == NULL)\\r\\n{\\r\\nfor (n=0; n<db->num_fields; n++)\\r\\nif (p[n] != NULL) OPENSSL_free(p[n]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (n=0; n<db->num_fields; n++)\\r\\n{\\r\\nif (((p[n] < (char *)p) || (p[n] > max))\\r\\n&& (p[n] != NULL))\\r\\nOPENSSL_free(p[n]);\\r\\n}\\r\\n}\\r\\nOPENSSL_free(sk_value(db->data,i));\\r\\n}\\r\\nsk_free(db->data);\\r\\n}\\r\\nOPENSSL_free(db);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_pk8_c", "target": 0, "func": "int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nstatic int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nX509_SIG *p8;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nint ret;\\r\\nif(!(p8inf = EVP_PKEY2PKCS8(x))) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY,\\r\\nPEM_R_ERROR_CONVERTING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif(enc || (nid != -1)) {\\r\\nif(!kstr) {\\r\\nif(!cb) klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);\\r\\nelse klen = cb(buf, PEM_BUFSIZE, 1, u);\\r\\nif(klen <= 0) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY,PEM_R_READ_KEY);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn 0;\\r\\n}\\r\\nkstr = buf;\\r\\n}\\r\\np8 = PKCS8_encrypt(nid, enc, kstr, klen, NULL, 0, 0, p8inf);\\r\\nif(kstr == buf) OPENSSL_cleanse(buf, klen);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nif(isder) ret = i2d_PKCS8_bio(bp, p8);\\r\\nelse ret = PEM_write_bio_PKCS8(bp, p8);\\r\\nX509_SIG_free(p8);\\r\\nreturn ret;\\r\\n} else {\\r\\nif(isder) ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);\\r\\nelse ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nEVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf = NULL;\\r\\nX509_SIG *p8 = NULL;\\r\\nint klen;\\r\\nEVP_PKEY *ret;\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\np8 = d2i_PKCS8_bio(bp, NULL);\\r\\nif(!p8) return NULL;\\r\\nif (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);\\r\\nelse klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);\\r\\nX509_SIG_free(p8);\\r\\nreturn NULL;\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, psbuf, klen);\\r\\nX509_SIG_free(p8);\\r\\nif(!p8inf) return NULL;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nif(!ret) return NULL;\\r\\nif(x) {\\r\\nif(*x) EVP_PKEY_free(*x);\\r\\n*x = ret;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 1, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 0, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen, pem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nstatic int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *bp;\\r\\nint ret;\\r\\nif(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);\\r\\nBIO_free(bp);\\r\\nreturn ret;\\r\\n}\\r\\nEVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *bp;\\r\\nEVP_PKEY *ret;\\r\\nif(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nPEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP,ERR_R_BUF_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);\\r\\nBIO_free(bp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_alpha_c", "target": 0, "func": "void func(a,b)\\r\\nTYPE *a;\\r\\nTYPE b;\\r\\n{\\r\\nprintf(\"%ld -1 == %ld\\n\",a[0],b);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nTYPE data[5]={1L,2L,3L,4L,5L};\\r\\nTYPE *p;\\r\\nint i;\\r\\np=data;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nfunc(p,*(p++));\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_lib_c", "target": 0, "func": "void DSA_set_default_method(const DSA_METHOD *meth)\\r\\n{\\r\\ndefault_DSA_method = meth;\\r\\n}\\r\\nconst DSA_METHOD *DSA_get_default_method(void)\\r\\n{\\r\\nif(!default_DSA_method)\\r\\ndefault_DSA_method = DSA_OpenSSL();\\r\\nreturn default_DSA_method;\\r\\n}\\r\\nDSA *DSA_new(void)\\r\\n{\\r\\nreturn DSA_new_method(NULL);\\r\\n}\\r\\nint DSA_set_method(DSA *dsa, const DSA_METHOD *meth)\\r\\n{\\r\\nconst DSA_METHOD *mtmp;\\r\\nmtmp = dsa->meth;\\r\\nif (mtmp->finish) mtmp->finish(dsa);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (dsa->engine)\\r\\n{\\r\\nENGINE_finish(dsa->engine);\\r\\ndsa->engine = NULL;\\r\\n}\\r\\n#endif\\r\\ndsa->meth = meth;\\r\\nif (meth->init) meth->init(dsa);\\r\\nreturn 1;\\r\\n}\\r\\nDSA *DSA_new_method(ENGINE *engine)\\r\\n{\\r\\nDSA *ret;\\r\\nret=(DSA *)OPENSSL_malloc(sizeof(DSA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->meth = DSA_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine)\\r\\n{\\r\\nif (!ENGINE_init(engine))\\r\\n{\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n}\\r\\nelse\\r\\nret->engine = ENGINE_get_default_DSA();\\r\\nif(ret->engine)\\r\\n{\\r\\nret->meth = ENGINE_get_DSA(ret->engine);\\r\\nif(!ret->meth)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD,\\r\\nERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->write_params=1;\\r\\nret->p=NULL;\\r\\nret->q=NULL;\\r\\nret->g=NULL;\\r\\nret->pub_key=NULL;\\r\\nret->priv_key=NULL;\\r\\nret->kinv=NULL;\\r\\nret->r=NULL;\\r\\nret->method_mont_p=NULL;\\r\\nret->references=1;\\r\\nret->flags=ret->meth->flags;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_DSA, ret, &ret->ex_data);\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid DSA_free(DSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL) return;\\r\\ni=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_DSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSA\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"DSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif(r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif(r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, r, &r->ex_data);\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->q != NULL) BN_clear_free(r->q);\\r\\nif (r->g != NULL) BN_clear_free(r->g);\\r\\nif (r->pub_key != NULL) BN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL) BN_clear_free(r->priv_key);\\r\\nif (r->kinv != NULL) BN_clear_free(r->kinv);\\r\\nif (r->r != NULL) BN_clear_free(r->r);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint DSA_up_ref(DSA *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_DSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSA\",r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2)\\r\\n{\\r\\nfprintf(stderr, \"DSA_up_ref, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint DSA_size(const DSA *r)\\r\\n{\\r\\nint ret,i;\\r\\nASN1_INTEGER bs;\\r\\nunsigned char buf[4];\\r\\ni=BN_num_bits(r->q);\\r\\nbs.length=(i+7)/8;\\r\\nbs.data=buf;\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbuf[0]=0xff;\\r\\ni=i2d_ASN1_INTEGER(&bs,NULL);\\r\\ni+=i;\\r\\nret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint DSA_set_ex_data(DSA *d, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&d->ex_data,idx,arg));\\r\\n}\\r\\nvoid *DSA_get_ex_data(DSA *d, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&d->ex_data,idx));\\r\\n}\\r\\nDH *DSA_dup_DH(const DSA *r)\\r\\n{\\r\\nDH *ret = NULL;\\r\\nif (r == NULL)\\r\\ngoto err;\\r\\nret = DH_new();\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (r->p != NULL)\\r\\nif ((ret->p = BN_dup(r->p)) == NULL)\\r\\ngoto err;\\r\\nif (r->q != NULL)\\r\\nret->length = BN_num_bits(r->q);\\r\\nif (r->g != NULL)\\r\\nif ((ret->g = BN_dup(r->g)) == NULL)\\r\\ngoto err;\\r\\nif (r->pub_key != NULL)\\r\\nif ((ret->pub_key = BN_dup(r->pub_key)) == NULL)\\r\\ngoto err;\\r\\nif (r->priv_key != NULL)\\r\\nif ((ret->priv_key = BN_dup(r->priv_key)) == NULL)\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_t1_enc_c", "target": 0, "func": "static void tls1_P_hash(const EVP_MD *md, const unsigned char *sec,\\r\\nint sec_len, unsigned char *seed, int seed_len,\\r\\nunsigned char *out, int olen)\\r\\n{\\r\\nint chunk,n;\\r\\nunsigned int j;\\r\\nHMAC_CTX ctx;\\r\\nHMAC_CTX ctx_tmp;\\r\\nunsigned char A1[EVP_MAX_MD_SIZE];\\r\\nunsigned int A1_len;\\r\\nchunk=EVP_MD_size(md);\\r\\nHMAC_CTX_init(&ctx);\\r\\nHMAC_CTX_init(&ctx_tmp);\\r\\nHMAC_Init_ex(&ctx,sec,sec_len,md, NULL);\\r\\nHMAC_Init_ex(&ctx_tmp,sec,sec_len,md, NULL);\\r\\nHMAC_Update(&ctx,seed,seed_len);\\r\\nHMAC_Final(&ctx,A1,&A1_len);\\r\\nn=0;\\r\\nfor (;;)\\r\\n{\\r\\nHMAC_Init_ex(&ctx,NULL,0,NULL,NULL);\\r\\nHMAC_Init_ex(&ctx_tmp,NULL,0,NULL,NULL);\\r\\nHMAC_Update(&ctx,A1,A1_len);\\r\\nHMAC_Update(&ctx_tmp,A1,A1_len);\\r\\nHMAC_Update(&ctx,seed,seed_len);\\r\\nif (olen > chunk)\\r\\n{\\r\\nHMAC_Final(&ctx,out,&j);\\r\\nout+=j;\\r\\nolen-=j;\\r\\nHMAC_Final(&ctx_tmp,A1,&A1_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHMAC_Final(&ctx,A1,&A1_len);\\r\\nmemcpy(out,A1,olen);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nHMAC_CTX_cleanup(&ctx);\\r\\nHMAC_CTX_cleanup(&ctx_tmp);\\r\\nOPENSSL_cleanse(A1,sizeof(A1));\\r\\n}\\r\\nstatic void tls1_PRF(const EVP_MD *md5, const EVP_MD *sha1,\\r\\nunsigned char *label, int label_len,\\r\\nconst unsigned char *sec, int slen, unsigned char *out1,\\r\\nunsigned char *out2, int olen)\\r\\n{\\r\\nint len,i;\\r\\nconst unsigned char *S1,*S2;\\r\\nlen=slen/2;\\r\\nS1=sec;\\r\\nS2= &(sec[len]);\\r\\nlen+=(slen&1);\\r\\ntls1_P_hash(md5 ,S1,len,label,label_len,out1,olen);\\r\\ntls1_P_hash(sha1,S2,len,label,label_len,out2,olen);\\r\\nfor (i=0; i<olen; i++)\\r\\nout1[i]^=out2[i];\\r\\n}\\r\\nstatic void tls1_generate_key_block(SSL *s, unsigned char *km,\\r\\nunsigned char *tmp, int num)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned char buf[SSL3_RANDOM_SIZE*2+\\r\\nTLS_MD_MAX_CONST_SIZE];\\r\\np=buf;\\r\\nmemcpy(p,TLS_MD_KEY_EXPANSION_CONST,\\r\\nTLS_MD_KEY_EXPANSION_CONST_SIZE);\\r\\np+=TLS_MD_KEY_EXPANSION_CONST_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),\\r\\ns->session->master_key,s->session->master_key_length,\\r\\nkm,tmp,num);\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"tls1_generate_key_block() ==> %d byte master_key =\\n\\t\",\\r\\ns->session->master_key_length);\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i < s->session->master_key_length; i++)\\r\\n{\\r\\nprintf(\"%02X\", s->session->master_key[i]);\\r\\n}\\r\\nprintf(\"\\n\"); }\\r\\n#endif\\r\\n}\\r\\nint tls1_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nstatic const unsigned char empty[]=\"\";\\r\\nunsigned char *p,*key_block,*mac_secret;\\r\\nunsigned char *exp_label,buf[TLS_MD_MAX_CONST_SIZE+\\r\\nSSL3_RANDOM_SIZE*2];\\r\\nunsigned char tmp1[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char tmp2[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv1[EVP_MAX_IV_LENGTH*2];\\r\\nunsigned char iv2[EVP_MAX_IV_LENGTH*2];\\r\\nunsigned char *ms,*key,*iv,*er1,*er2;\\r\\nint client_write;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\nconst SSL_COMP *comp;\\r\\nconst EVP_MD *m;\\r\\nint is_export,n,i,j,k,exp_label_len,cl;\\r\\nint reuse_dd = 0;\\r\\nis_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc=s->s3->tmp.new_sym_enc;\\r\\nm=s->s3->tmp.new_hash;\\r\\ncomp=s->s3->tmp.new_compression;\\r\\nkey_block=s->s3->tmp.key_block;\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"tls1_change_cipher_state(which= %d) w/\\n\", which);\\r\\nprintf(\"\\talg= %ld, comp= %p\\n\", s->s3->tmp.new_cipher->algorithms,\\r\\ncomp);\\r\\nprintf(\"\\tevp_cipher == %p ==? &d_cbc_ede_cipher3\\n\", c);\\r\\nprintf(\"\\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\\n\",\\r\\nc->nid,c->block_size,c->key_len,c->iv_len);\\r\\nprintf(\"\\tkey_block: len= %d, data= \", s->s3->tmp.key_block_length);\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<s->s3->tmp.key_block_length; i++)\\r\\nprintf(\"%02x\", key_block[i]); printf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (which & SSL3_CC_READ)\\r\\n{\\r\\nif (s->enc_read_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\ndd= s->enc_read_ctx;\\r\\ns->read_hash=m;\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->expand=COMP_CTX_new(comp->method);\\r\\nif (s->expand == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp=(unsigned char *)\\r\\nOPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (s->version != DTLS1_VERSION)\\r\\nmemset(&(s->s3->read_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->read_mac_secret[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->enc_write_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\nif ((s->enc_write_ctx == NULL) &&\\r\\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\ndd= s->enc_write_ctx;\\r\\ns->write_hash=m;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->compress=COMP_CTX_new(comp->method);\\r\\nif (s->compress == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\nif (s->version != DTLS1_VERSION)\\r\\nmemset(&(s->s3->write_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->write_mac_secret[0]);\\r\\n}\\r\\nif (reuse_dd)\\r\\nEVP_CIPHER_CTX_cleanup(dd);\\r\\nEVP_CIPHER_CTX_init(dd);\\r\\np=s->s3->tmp.key_block;\\r\\ni=EVP_MD_size(m);\\r\\ncl=EVP_CIPHER_key_length(c);\\r\\nj=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nk=EVP_CIPHER_iv_length(c);\\r\\ner1= &(s->s3->client_random[0]);\\r\\ner2= &(s->s3->server_random[0]);\\r\\nif ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ))\\r\\n{\\r\\nms= &(p[ 0]); n=i+i;\\r\\nkey= &(p[ n]); n+=j+j;\\r\\niv= &(p[ n]); n+=k+k;\\r\\nexp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\\r\\nexp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\\r\\nclient_write=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=i;\\r\\nms= &(p[ n]); n+=i+j;\\r\\nkey= &(p[ n]); n+=j+k;\\r\\niv= &(p[ n]); n+=k;\\r\\nexp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\\r\\nexp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\\r\\nclient_write=0;\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nmemcpy(mac_secret,ms,i);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nmac key=\",which);\\r\\n{ int z; for (z=0; z<i; z++) printf(\"%02X%c\",ms[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\nif (is_export)\\r\\n{\\r\\np=buf;\\r\\nmemcpy(p,exp_label,exp_label_len);\\r\\np+=exp_label_len;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),key,j,\\r\\ntmp1,tmp2,EVP_CIPHER_key_length(c));\\r\\nkey=tmp1;\\r\\nif (k > 0)\\r\\n{\\r\\np=buf;\\r\\nmemcpy(p,TLS_MD_IV_BLOCK_CONST,\\r\\nTLS_MD_IV_BLOCK_CONST_SIZE);\\r\\np+=TLS_MD_IV_BLOCK_CONST_SIZE;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,empty,0,\\r\\niv1,iv2,k*2);\\r\\nif (client_write)\\r\\niv=iv1;\\r\\nelse\\r\\niv= &(iv1[k]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length=0;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nprintf(\"EVP_CipherInit_ex(dd,c,key=,iv=,which)\\n\");\\r\\nprintf(\"\\tkey= \"); for (i=0; i<c->key_len; i++) printf(\"%02x\", key[i]);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"\\t iv= \"); for (i=0; i<c->iv_len; i++) printf(\"%02x\", iv[i]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nEVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nkey=\",which);\\r\\n{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(\"%02X%c\",key[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\niv=\");\\r\\n{ int z; for (z=0; z<k; z++) printf(\"%02X%c\",iv[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nOPENSSL_cleanse(tmp1,sizeof(tmp1));\\r\\nOPENSSL_cleanse(tmp2,sizeof(tmp1));\\r\\nOPENSSL_cleanse(iv1,sizeof(iv1));\\r\\nOPENSSL_cleanse(iv2,sizeof(iv2));\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn(0);\\r\\n}\\r\\nint tls1_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p1,*p2;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nSSL_COMP *comp;\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf (\"tls1_setup_key_block()\\n\");\\r\\n#endif\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn(1);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn(0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc=c;\\r\\ns->s3->tmp.new_hash=hash;\\r\\nnum=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);\\r\\nnum*=2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p1=(unsigned char *)OPENSSL_malloc(num)) == NULL)\\r\\ngoto err;\\r\\nif ((p2=(unsigned char *)OPENSSL_malloc(num)) == NULL)\\r\\ngoto err;\\r\\ns->s3->tmp.key_block_length=num;\\r\\ns->s3->tmp.key_block=p1;\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"client random\\n\");\\r\\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf(\"%02X%c\",s->s3->client_random[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"server random\\n\");\\r\\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf(\"%02X%c\",s->s3->server_random[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"pre-master\\n\");\\r\\n{ int z; for (z=0; z<s->session->master_key_length; z++) printf(\"%02X%c\",s->session->master_key[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\ntls1_generate_key_block(s,p1,p2,num);\\r\\nOPENSSL_cleanse(p2,num);\\r\\nOPENSSL_free(p2);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"\\nkey block\\n\");\\r\\n{ int z; for (z=0; z<num; z++) printf(\"%02X%c\",p1[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\nif (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))\\r\\n{\\r\\ns->s3->need_empty_fragments = 1;\\r\\nif (s->session->cipher != NULL)\\r\\n{\\r\\nif ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_eNULL)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nif ((s->session->cipher->algorithms & SSL_ENC_MASK) == SSL_RC4)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nint tls1_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs,i,ii,j,k,n=0;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send)\\r\\n{\\r\\nif (s->write_hash != NULL)\\r\\nn=EVP_MD_size(s->write_hash);\\r\\nds=s->enc_write_ctx;\\r\\nrec= &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->read_hash != NULL)\\r\\nn=EVP_MD_size(s->read_hash);\\r\\nds=s->enc_read_ctx;\\r\\nrec= &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"tls1_enc(%d)\\n\", send);\\r\\n#endif\\r\\nif ((s->session == NULL) || (ds == NULL) ||\\r\\n(enc == NULL))\\r\\n{\\r\\nmemmove(rec->data,rec->input,rec->length);\\r\\nrec->input=rec->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=rec->length;\\r\\nbs=EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send)\\r\\n{\\r\\ni=bs-((int)l%bs);\\r\\nj=i-1;\\r\\nif (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\nj++;\\r\\n}\\r\\nfor (k=(int)l; k<(int)(l+i); k++)\\r\\nrec->input[k]=j;\\r\\nl+=i;\\r\\nrec->length+=i;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long ui;\\r\\nprintf(\"EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\\n\",\\r\\nds,rec->data,rec->input,l);\\r\\nprintf(\"\\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%d %d], %d iv_len\\n\",\\r\\nds->buf_len, ds->cipher->key_len,\\r\\nDES_KEY_SZ, DES_SCHEDULE_SZ,\\r\\nds->cipher->iv_len);\\r\\nprintf(\"\\t\\tIV: \");\\r\\nfor (i=0; i<ds->cipher->iv_len; i++) printf(\"%02X\", ds->iv[i]);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"\\trec->input=\");\\r\\nfor (ui=0; ui<l; ui++) printf(\" %02x\", rec->input[ui]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (!send)\\r\\n{\\r\\nif (l == 0 || l%bs != 0)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nEVP_Cipher(ds,rec->data,rec->input,l);\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long i;\\r\\nprintf(\"\\trec->data=\");\\r\\nfor (i=0; i<l; i++)\\r\\nprintf(\" %02x\", rec->data[i]); printf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nif ((bs != 1) && !send)\\r\\n{\\r\\nii=i=rec->data[l-1];\\r\\ni++;\\r\\nif (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif ((memcmp(s->s3->read_sequence,\\r\\n\"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) && !(ii & 1))\\r\\ns->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\ni--;\\r\\n}\\r\\nif (i > (int)rec->length)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\nfor (j=(int)(l-i); j<(int)l; j++)\\r\\n{\\r\\nif (rec->data[j] != ii)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nrec->length-=i;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in_ctx, unsigned char *out)\\r\\n{\\r\\nunsigned int ret;\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_copy_ex(&ctx,in_ctx);\\r\\nEVP_DigestFinal_ex(&ctx,out,&ret);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn((int)ret);\\r\\n}\\r\\nint tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,\\r\\nconst char *str, int slen, unsigned char *out)\\r\\n{\\r\\nunsigned int i;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char buf[TLS_MD_MAX_CONST_SIZE+MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nunsigned char *q,buf2[12];\\r\\nq=buf;\\r\\nmemcpy(q,str,slen);\\r\\nq+=slen;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_copy_ex(&ctx,in1_ctx);\\r\\nEVP_DigestFinal_ex(&ctx,q,&i);\\r\\nq+=i;\\r\\nEVP_MD_CTX_copy_ex(&ctx,in2_ctx);\\r\\nEVP_DigestFinal_ex(&ctx,q,&i);\\r\\nq+=i;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(q-buf),\\r\\ns->session->master_key,s->session->master_key_length,\\r\\nout,buf2,sizeof buf2);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn sizeof buf2;\\r\\n}\\r\\nint tls1_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *mac_sec,*seq;\\r\\nconst EVP_MD *hash;\\r\\nunsigned int md_size;\\r\\nint i;\\r\\nHMAC_CTX hmac;\\r\\nunsigned char buf[5];\\r\\nif (send)\\r\\n{\\r\\nrec= &(ssl->s3->wrec);\\r\\nmac_sec= &(ssl->s3->write_mac_secret[0]);\\r\\nseq= &(ssl->s3->write_sequence[0]);\\r\\nhash=ssl->write_hash;\\r\\n}\\r\\nelse\\r\\n{\\r\\nrec= &(ssl->s3->rrec);\\r\\nmac_sec= &(ssl->s3->read_mac_secret[0]);\\r\\nseq= &(ssl->s3->read_sequence[0]);\\r\\nhash=ssl->read_hash;\\r\\n}\\r\\nmd_size=EVP_MD_size(hash);\\r\\nbuf[0]=rec->type;\\r\\nbuf[1]=TLS1_VERSION_MAJOR;\\r\\nbuf[2]=TLS1_VERSION_MINOR;\\r\\nbuf[3]=rec->length>>8;\\r\\nbuf[4]=rec->length&0xff;\\r\\nHMAC_CTX_init(&hmac);\\r\\nHMAC_Init_ex(&hmac,mac_sec,EVP_MD_size(hash),hash,NULL);\\r\\nHMAC_Update(&hmac,seq,8);\\r\\nHMAC_Update(&hmac,buf,5);\\r\\nHMAC_Update(&hmac,rec->input,rec->length);\\r\\nHMAC_Final(&hmac,md,&md_size);\\r\\nHMAC_CTX_cleanup(&hmac);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"sec=\");\\r\\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",mac_sec[z]); printf(\"\\n\"); }\\r\\nprintf(\"seq=\");\\r\\n{int z; for (z=0; z<8; z++) printf(\"%02X \",seq[z]); printf(\"\\n\"); }\\r\\nprintf(\"buf=\");\\r\\n{int z; for (z=0; z<5; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\\r\\nprintf(\"rec=\");\\r\\n{unsigned int z; for (z=0; z<rec->length; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\\r\\n#endif\\r\\nif ( SSL_version(ssl) != DTLS1_VERSION)\\r\\n{\\r\\nfor (i=7; i>=0; i--)\\r\\n{\\r\\n++seq[i];\\r\\nif (seq[i] != 0) break;\\r\\n}\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",md[z]); printf(\"\\n\"); }\\r\\n#endif\\r\\nreturn(md_size);\\r\\n}\\r\\nint tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nunsigned char buf[SSL3_RANDOM_SIZE*2+TLS_MD_MASTER_SECRET_CONST_SIZE];\\r\\nunsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf (\"tls1_generate_master_secret(%p,%p, %p, %d)\\n\", s,out, p,len);\\r\\n#endif\\r\\nmemcpy(buf,TLS_MD_MASTER_SECRET_CONST,\\r\\nTLS_MD_MASTER_SECRET_CONST_SIZE);\\r\\nmemcpy(&(buf[TLS_MD_MASTER_SECRET_CONST_SIZE]),\\r\\ns->s3->client_random,SSL3_RANDOM_SIZE);\\r\\nmemcpy(&(buf[SSL3_RANDOM_SIZE+TLS_MD_MASTER_SECRET_CONST_SIZE]),\\r\\ns->s3->server_random,SSL3_RANDOM_SIZE);\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,\\r\\nbuf,TLS_MD_MASTER_SECRET_CONST_SIZE+SSL3_RANDOM_SIZE*2,p,len,\\r\\ns->session->master_key,buff,sizeof buff);\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf (\"tls1_generate_master_secret() complete\\n\");\\r\\n#endif\\r\\nreturn(SSL3_MASTER_SECRET_SIZE);\\r\\n}\\r\\nint tls1_alert_code(int code)\\r\\n{\\r\\nswitch (code)\\r\\n{\\r\\ncase SSL_AD_CLOSE_NOTIFY: return(SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE: return(SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED: return(TLS1_AD_DECRYPTION_FAILED);\\r\\ncase SSL_AD_RECORD_OVERFLOW: return(TLS1_AD_RECORD_OVERFLOW);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE: return(-1);\\r\\ncase SSL_AD_BAD_CERTIFICATE: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER: return(SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA: return(TLS1_AD_UNKNOWN_CA);\\r\\ncase SSL_AD_ACCESS_DENIED: return(TLS1_AD_ACCESS_DENIED);\\r\\ncase SSL_AD_DECODE_ERROR: return(TLS1_AD_DECODE_ERROR);\\r\\ncase SSL_AD_DECRYPT_ERROR: return(TLS1_AD_DECRYPT_ERROR);\\r\\ncase SSL_AD_EXPORT_RESTRICTION: return(TLS1_AD_EXPORT_RESTRICTION);\\r\\ncase SSL_AD_PROTOCOL_VERSION: return(TLS1_AD_PROTOCOL_VERSION);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:return(TLS1_AD_INSUFFICIENT_SECURITY);\\r\\ncase SSL_AD_INTERNAL_ERROR: return(TLS1_AD_INTERNAL_ERROR);\\r\\ncase SSL_AD_USER_CANCELLED: return(TLS1_AD_USER_CANCELLED);\\r\\ncase SSL_AD_NO_RENEGOTIATION: return(TLS1_AD_NO_RENEGOTIATION);\\r\\ncase DTLS1_AD_MISSING_HANDSHAKE_MESSAGE: return\\r\\n(DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\\r\\ndefault: return(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_kron_c", "target": 0, "func": "int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint i;\\r\\nint ret = -2;\\r\\nint err = 0;\\r\\nBIGNUM *A, *B, *tmp;\\r\\nstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1};\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nB = BN_CTX_get(ctx);\\r\\nif (B == NULL) goto end;\\r\\nerr = !BN_copy(A, a);\\r\\nif (err) goto end;\\r\\nerr = !BN_copy(B, b);\\r\\nif (err) goto end;\\r\\nif (BN_is_zero(B))\\r\\n{\\r\\nret = BN_abs_is_word(A, 1);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_is_odd(A) && !BN_is_odd(B))\\r\\n{\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\ni = 0;\\r\\nwhile (!BN_is_bit_set(B, i))\\r\\ni++;\\r\\nerr = !BN_rshift(B, B, i);\\r\\nif (err) goto end;\\r\\nif (i & 1)\\r\\n{\\r\\nret = tab[BN_lsw(A) & 7];\\r\\n}\\r\\nelse\\r\\n{\\r\\nret = 1;\\r\\n}\\r\\nif (B->neg)\\r\\n{\\r\\nB->neg = 0;\\r\\nif (A->neg)\\r\\nret = -ret;\\r\\n}\\r\\nwhile (1)\\r\\n{\\r\\nif (BN_is_zero(A))\\r\\n{\\r\\nret = BN_is_one(B) ? ret : 0;\\r\\ngoto end;\\r\\n}\\r\\ni = 0;\\r\\nwhile (!BN_is_bit_set(A, i))\\r\\ni++;\\r\\nerr = !BN_rshift(A, A, i);\\r\\nif (err) goto end;\\r\\nif (i & 1)\\r\\n{\\r\\nret = ret * tab[BN_lsw(B) & 7];\\r\\n}\\r\\nif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2)\\r\\nret = -ret;\\r\\nerr = !BN_nnmod(B, B, A, ctx);\\r\\nif (err) goto end;\\r\\ntmp = A; A = B; B = tmp;\\r\\ntmp->neg = 0;\\r\\n}\\r\\nend:\\r\\nBN_CTX_end(ctx);\\r\\nif (err)\\r\\nreturn -2;\\r\\nelse\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_nsseq_c", "target": 0, "func": "static int nsseq_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(operation == ASN1_OP_NEW_POST) {\\r\\nNETSCAPE_CERT_SEQUENCE *nsseq;\\r\\nnsseq = (NETSCAPE_CERT_SEQUENCE *)*pval;\\r\\nnsseq->type = OBJ_nid2obj(NID_netscape_cert_sequence);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s2_lib_c", "target": 0, "func": "static long ssl2_default_timeout(void)\\r\\n{\\r\\nreturn(300);\\r\\n}\\r\\nSSL_METHOD *sslv2_base_method(void)\\r\\n{\\r\\nreturn(&SSLv2_data);\\r\\n}\\r\\nint ssl2_num_ciphers(void)\\r\\n{\\r\\nreturn(SSL2_NUM_CIPHERS);\\r\\n}\\r\\nSSL_CIPHER *ssl2_get_cipher(unsigned int u)\\r\\n{\\r\\nif (u < SSL2_NUM_CIPHERS)\\r\\nreturn(&(ssl2_ciphers[SSL2_NUM_CIPHERS-1-u]));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl2_pending(const SSL *s)\\r\\n{\\r\\nreturn SSL_in_init(s) ? 0 : s->s2->ract_data_length;\\r\\n}\\r\\nint ssl2_new(SSL *s)\\r\\n{\\r\\nSSL2_STATE *s2;\\r\\nif ((s2=OPENSSL_malloc(sizeof *s2)) == NULL) goto err;\\r\\nmemset(s2,0,sizeof *s2);\\r\\n#if SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER + 3 > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER + 2\\r\\n# error \"assertion failed\"\\r\\n#endif\\r\\nif ((s2->rbuf=OPENSSL_malloc(\\r\\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2)) == NULL) goto err;\\r\\nif ((s2->wbuf=OPENSSL_malloc(\\r\\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+3)) == NULL) goto err;\\r\\ns->s2=s2;\\r\\nssl2_clear(s);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (s2 != NULL)\\r\\n{\\r\\nif (s2->wbuf != NULL) OPENSSL_free(s2->wbuf);\\r\\nif (s2->rbuf != NULL) OPENSSL_free(s2->rbuf);\\r\\nOPENSSL_free(s2);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl2_free(SSL *s)\\r\\n{\\r\\nSSL2_STATE *s2;\\r\\nif(s == NULL)\\r\\nreturn;\\r\\ns2=s->s2;\\r\\nif (s2->rbuf != NULL) OPENSSL_free(s2->rbuf);\\r\\nif (s2->wbuf != NULL) OPENSSL_free(s2->wbuf);\\r\\nOPENSSL_cleanse(s2,sizeof *s2);\\r\\nOPENSSL_free(s2);\\r\\ns->s2=NULL;\\r\\n}\\r\\nvoid ssl2_clear(SSL *s)\\r\\n{\\r\\nSSL2_STATE *s2;\\r\\nunsigned char *rbuf,*wbuf;\\r\\ns2=s->s2;\\r\\nrbuf=s2->rbuf;\\r\\nwbuf=s2->wbuf;\\r\\nmemset(s2,0,sizeof *s2);\\r\\ns2->rbuf=rbuf;\\r\\ns2->wbuf=wbuf;\\r\\ns2->clear_text=1;\\r\\ns->packet=s2->rbuf;\\r\\ns->version=SSL2_VERSION;\\r\\ns->packet_length=0;\\r\\n}\\r\\nlong ssl2_ctrl(SSL *s, int cmd, long larg, void *parg)\\r\\n{\\r\\nint ret=0;\\r\\nswitch(cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_SESSION_REUSED:\\r\\nret=s->hit;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong ssl2_callback_ctrl(SSL *s, int cmd, void (*fp)(void))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nlong ssl2_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nlong ssl2_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nSSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_CIPHER *sorted[SSL2_NUM_CIPHERS];\\r\\nSSL_CIPHER c,*cp= &c,**cpp;\\r\\nunsigned long id;\\r\\nunsigned int i;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nif (init)\\r\\n{\\r\\nfor (i=0; i<SSL2_NUM_CIPHERS; i++)\\r\\nsorted[i]= &(ssl2_ciphers[i]);\\r\\nqsort((char *)sorted,\\r\\nSSL2_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\n}\\r\\nid=0x02000000L|((unsigned long)p[0]<<16L)|\\r\\n((unsigned long)p[1]<<8L)|(unsigned long)p[2];\\r\\nc.id=id;\\r\\ncpp=(SSL_CIPHER **)OBJ_bsearch((char *)&cp,\\r\\n(char *)sorted,\\r\\nSSL2_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\nif ((cpp == NULL) || !(*cpp)->valid)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(*cpp);\\r\\n}\\r\\nint ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\nif ((l & 0xff000000) != 0x02000000) return(0);\\r\\np[0]=((unsigned char)(l>>16L))&0xFF;\\r\\np[1]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[2]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(3);\\r\\n}\\r\\nint ssl2_generate_key_material(SSL *s)\\r\\n{\\r\\nunsigned int i;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *km;\\r\\nunsigned char c='0';\\r\\nconst EVP_MD *md5;\\r\\nmd5 = EVP_md5();\\r\\n#ifdef CHARSET_EBCDIC\\r\\nc = os_toascii['0'];\\r\\n#endif\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nkm=s->s2->key_material;\\r\\nif (s->session->master_key_length < 0 ||\\r\\ns->session->master_key_length > (int)sizeof(s->session->master_key))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i=0; i<s->s2->key_material_length; i += EVP_MD_size(md5))\\r\\n{\\r\\nif (((km - s->s2->key_material) + EVP_MD_size(md5)) >\\r\\n(int)sizeof(s->s2->key_material))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_DigestInit_ex(&ctx, md5, NULL);\\r\\nOPENSSL_assert(s->session->master_key_length >= 0\\r\\n&& s->session->master_key_length\\r\\n< (int)sizeof(s->session->master_key));\\r\\nEVP_DigestUpdate(&ctx,s->session->master_key,s->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx,&c,1);\\r\\nc++;\\r\\nEVP_DigestUpdate(&ctx,s->s2->challenge,s->s2->challenge_length);\\r\\nEVP_DigestUpdate(&ctx,s->s2->conn_id,s->s2->conn_id_length);\\r\\nEVP_DigestFinal_ex(&ctx,km,NULL);\\r\\nkm += EVP_MD_size(md5);\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ssl2_return_error(SSL *s, int err)\\r\\n{\\r\\nif (!s->error)\\r\\n{\\r\\ns->error=3;\\r\\ns->error_code=err;\\r\\nssl2_write_error(s);\\r\\n}\\r\\n}\\r\\nvoid ssl2_write_error(SSL *s)\\r\\n{\\r\\nunsigned char buf[3];\\r\\nint i,error;\\r\\nbuf[0]=SSL2_MT_ERROR;\\r\\nbuf[1]=(s->error_code>>8)&0xff;\\r\\nbuf[2]=(s->error_code)&0xff;\\r\\nerror=s->error;\\r\\ns->error=0;\\r\\nOPENSSL_assert(error >= 0 && error <= (int)sizeof(buf));\\r\\ni=ssl2_write(s,&(buf[3-error]),error);\\r\\nif (i < 0)\\r\\ns->error=error;\\r\\nelse\\r\\n{\\r\\ns->error=error-i;\\r\\nif (s->error == 0)\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, 0, buf, 3, s, s->msg_callback_arg);\\r\\n}\\r\\n}\\r\\nint ssl2_shutdown(SSL *s)\\r\\n{\\r\\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p12_p8e_c", "target": 0, "func": "X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,\\r\\nconst char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nX509_SIG *p8 = NULL;\\r\\nX509_ALGOR *pbe;\\r\\nif (!(p8 = X509_SIG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif(pbe_nid == -1) pbe = PKCS5_pbe2_set(cipher, iter, salt, saltlen);\\r\\nelse pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);\\r\\nif(!pbe) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_ALGOR_free(p8->algor);\\r\\np8->algor = pbe;\\r\\nM_ASN1_OCTET_STRING_free(p8->digest);\\r\\np8->digest = PKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO),\\r\\npass, passlen, p8inf, 1);\\r\\nif(!p8->digest) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, PKCS12_R_ENCRYPT_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nreturn p8;\\r\\nerr:\\r\\nX509_SIG_free(p8);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret=1;\\r\\nRSA *rsa=NULL;\\r\\nint i,badops=0, sgckey=0;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nBIO *out=NULL;\\r\\nint informat,outformat,text=0,check=0,noout=0;\\r\\nint pubin = 0, pubout = 0;\\r\\nchar *infile,*outfile,*prog;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nint modulus=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passin\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargin= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-sgckey\") == 0)\\r\\nsgckey=1;\\r\\nelse if (strcmp(*argv,\"-pubin\") == 0)\\r\\npubin=1;\\r\\nelse if (strcmp(*argv,\"-pubout\") == 0)\\r\\npubout=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck=1;\\r\\nelse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -sgckey Use IIS SGC key format\\n\");\\r\\nBIO_printf(bio_err,\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err,\" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err,\" -modulus print the RSA key modulus\\n\");\\r\\nBIO_printf(bio_err,\" -check verify key consistency\\n\");\\r\\nBIO_printf(bio_err,\" -pubin expect a public key in input file\\n\");\\r\\nBIO_printf(bio_err,\" -pubout output a public key\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif(!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif(check && pubin) {\\r\\nBIO_printf(bio_err, \"Only private keys can be checked\\n\");\\r\\ngoto end;\\r\\n}\\r\\nout=BIO_new(BIO_s_file());\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif (pubin)\\r\\npkey = load_pubkey(bio_err, infile,\\r\\n(informat == FORMAT_NETSCAPE && sgckey ?\\r\\nFORMAT_IISSGC : informat), 1,\\r\\npassin, e, \"Public Key\");\\r\\nelse\\r\\npkey = load_key(bio_err, infile,\\r\\n(informat == FORMAT_NETSCAPE && sgckey ?\\r\\nFORMAT_IISSGC : informat), 1,\\r\\npassin, e, \"Private Key\");\\r\\nif (pkey != NULL)\\r\\nrsa = pkey == NULL ? NULL : EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!RSA_print(out,rsa,0))\\r\\n{\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nBIO_printf(out,\"Modulus=\");\\r\\nBN_print(out,rsa->n);\\r\\nBIO_printf(out,\"\\n\");\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nint r = RSA_check_key(rsa);\\r\\nif (r == 1)\\r\\nBIO_printf(out,\"RSA key ok\\n\");\\r\\nelse if (r == 0)\\r\\n{\\r\\nunsigned long err;\\r\\nwhile ((err = ERR_peek_error()) != 0 &&\\r\\nERR_GET_LIB(err) == ERR_LIB_RSA &&\\r\\nERR_GET_FUNC(err) == RSA_F_RSA_CHECK_KEY &&\\r\\nERR_GET_REASON(err) != ERR_R_MALLOC_FAILURE)\\r\\n{\\r\\nBIO_printf(out, \"RSA key error: %s\\n\", ERR_reason_error_string(err));\\r\\nERR_get_error();\\r\\n}\\r\\n}\\r\\nif (r == -1 || ERR_peek_error() != 0)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (noout)\\r\\n{\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"writing RSA key\\n\");\\r\\nif (outformat == FORMAT_ASN1) {\\r\\nif(pubout || pubin) i=i2d_RSA_PUBKEY_bio(out,rsa);\\r\\nelse i=i2d_RSAPrivateKey_bio(out,rsa);\\r\\n}\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nelse if (outformat == FORMAT_NETSCAPE)\\r\\n{\\r\\nunsigned char *p,*pp;\\r\\nint size;\\r\\ni=1;\\r\\nsize=i2d_RSA_NET(rsa,NULL,NULL, sgckey);\\r\\nif ((p=(unsigned char *)OPENSSL_malloc(size)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Memory allocation failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\npp=p;\\r\\ni2d_RSA_NET(rsa,&p,NULL, sgckey);\\r\\nBIO_write(out,(char *)pp,size);\\r\\nOPENSSL_free(pp);\\r\\n}\\r\\n#endif\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif(pubout || pubin)\\r\\ni=PEM_write_bio_RSA_PUBKEY(out,rsa);\\r\\nelse i=PEM_write_bio_RSAPrivateKey(out,rsa,\\r\\nenc,NULL,0,NULL,passout);\\r\\n} else {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nend:\\r\\nif(out != NULL) BIO_free_all(out);\\r\\nif(rsa != NULL) RSA_free(rsa);\\r\\nif(passin) OPENSSL_free(passin);\\r\\nif(passout) OPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_err_c", "target": 0, "func": "void ERR_load_DSO_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,DSO_str_functs);\\r\\nERR_load_strings(0,DSO_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecp_smpl_c", "target": 0, "func": "const EC_METHOD *EC_GFp_simple_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_simple_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_simple_group_copy,\\r\\nec_GFp_simple_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\nec_GFp_simple_set_compressed_coordinates,\\r\\nec_GFp_simple_point2oct,\\r\\nec_GFp_simple_oct2point,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_simple_field_mul,\\r\\nec_GFp_simple_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0 };\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_simple_group_init(EC_GROUP *group)\\r\\n{\\r\\nBN_init(&group->field);\\r\\nBN_init(&group->a);\\r\\nBN_init(&group->b);\\r\\ngroup->a_is_minus3 = 0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GFp_simple_group_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_free(&group->field);\\r\\nBN_free(&group->a);\\r\\nBN_free(&group->b);\\r\\n}\\r\\nvoid ec_GFp_simple_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_clear_free(&group->field);\\r\\nBN_clear_free(&group->a);\\r\\nBN_clear_free(&group->b);\\r\\n}\\r\\nint ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nif (!BN_copy(&dest->field, &src->field)) return 0;\\r\\nif (!BN_copy(&dest->a, &src->a)) return 0;\\r\\nif (!BN_copy(&dest->b, &src->b)) return 0;\\r\\ndest->a_is_minus3 = src->a_is_minus3;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_group_set_curve(EC_GROUP *group,\\r\\nconst BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp_a;\\r\\nif (BN_num_bits(p) <= 2 || !BN_is_odd(p))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp_a = BN_CTX_get(ctx);\\r\\nif (tmp_a == NULL) goto err;\\r\\nif (!BN_copy(&group->field, p)) goto err;\\r\\nBN_set_negative(&group->field, 0);\\r\\nif (!BN_nnmod(tmp_a, a, p, ctx)) goto err;\\r\\nif (group->meth->field_encode)\\r\\n{ if (!group->meth->field_encode(group, &group->a, tmp_a, ctx)) goto err; }\\r\\nelse\\r\\nif (!BN_copy(&group->a, tmp_a)) goto err;\\r\\nif (!BN_nnmod(&group->b, b, p, ctx)) goto err;\\r\\nif (group->meth->field_encode)\\r\\nif (!group->meth->field_encode(group, &group->b, &group->b, ctx)) goto err;\\r\\nif (!BN_add_word(tmp_a, 3)) goto err;\\r\\ngroup->a_is_minus3 = (0 == BN_cmp(tmp_a, &group->field));\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (p != NULL)\\r\\n{\\r\\nif (!BN_copy(p, &group->field)) return 0;\\r\\n}\\r\\nif (a != NULL || b != NULL)\\r\\n{\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (a != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\\r\\n}\\r\\nif (b != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (a != NULL)\\r\\n{\\r\\nif (!BN_copy(a, &group->a)) goto err;\\r\\n}\\r\\nif (b != NULL)\\r\\n{\\r\\nif (!BN_copy(b, &group->b)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_group_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nreturn BN_num_bits(&group->field);\\r\\n}\\r\\nint ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *a,*b,*order,*tmp_1,*tmp_2;\\r\\nconst BIGNUM *p = &group->field;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\ntmp_1 = BN_CTX_get(ctx);\\r\\ntmp_2 = BN_CTX_get(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nif (order == NULL) goto err;\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (!group->meth->field_decode(group, a, &group->a, ctx)) goto err;\\r\\nif (!group->meth->field_decode(group, b, &group->b, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_copy(a, &group->a)) goto err;\\r\\nif (!BN_copy(b, &group->b)) goto err;\\r\\n}\\r\\nif (BN_is_zero(a))\\r\\n{\\r\\nif (BN_is_zero(b)) goto err;\\r\\n}\\r\\nelse if (!BN_is_zero(b))\\r\\n{\\r\\nif (!BN_mod_sqr(tmp_1, a, p, ctx)) goto err;\\r\\nif (!BN_mod_mul(tmp_2, tmp_1, a, p, ctx)) goto err;\\r\\nif (!BN_lshift(tmp_1, tmp_2, 2)) goto err;\\r\\nif (!BN_mod_sqr(tmp_2, b, p, ctx)) goto err;\\r\\nif (!BN_mul_word(tmp_2, 27)) goto err;\\r\\nif (!BN_mod_add(a, tmp_1, tmp_2, p, ctx)) goto err;\\r\\nif (BN_is_zero(a)) goto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_point_init(EC_POINT *point)\\r\\n{\\r\\nBN_init(&point->X);\\r\\nBN_init(&point->Y);\\r\\nBN_init(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GFp_simple_point_finish(EC_POINT *point)\\r\\n{\\r\\nBN_free(&point->X);\\r\\nBN_free(&point->Y);\\r\\nBN_free(&point->Z);\\r\\n}\\r\\nvoid ec_GFp_simple_point_clear_finish(EC_POINT *point)\\r\\n{\\r\\nBN_clear_free(&point->X);\\r\\nBN_clear_free(&point->Y);\\r\\nBN_clear_free(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\n}\\r\\nint ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (!BN_copy(&dest->X, &src->X)) return 0;\\r\\nif (!BN_copy(&dest->Y, &src->Y)) return 0;\\r\\nif (!BN_copy(&dest->Z, &src->Z)) return 0;\\r\\ndest->Z_is_one = src->Z_is_one;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group, EC_POINT *point)\\r\\n{\\r\\npoint->Z_is_one = 0;\\r\\nBN_zero(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!BN_nnmod(&point->X, x, &group->field, ctx)) goto err;\\r\\nif (group->meth->field_encode)\\r\\n{\\r\\nif (!group->meth->field_encode(group, &point->X, &point->X, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!BN_nnmod(&point->Y, y, &group->field, ctx)) goto err;\\r\\nif (group->meth->field_encode)\\r\\n{\\r\\nif (!group->meth->field_encode(group, &point->Y, &point->Y, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nif (z != NULL)\\r\\n{\\r\\nint Z_is_one;\\r\\nif (!BN_nnmod(&point->Z, z, &group->field, ctx)) goto err;\\r\\nZ_is_one = BN_is_one(&point->Z);\\r\\nif (group->meth->field_encode)\\r\\n{\\r\\nif (Z_is_one && (group->meth->field_set_to_one != 0))\\r\\n{\\r\\nif (!group->meth->field_set_to_one(group, &point->Z, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!group->meth->field_encode(group, &point->Z, &point->Z, ctx)) goto err;\\r\\n}\\r\\n}\\r\\npoint->Z_is_one = Z_is_one;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nif (group->meth->field_decode != 0)\\r\\n{\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, x, &point->X, ctx)) goto err;\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, y, &point->Y, ctx)) goto err;\\r\\n}\\r\\nif (z != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, z, &point->Z, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!BN_copy(x, &point->X)) goto err;\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!BN_copy(y, &point->Y)) goto err;\\r\\n}\\r\\nif (z != NULL)\\r\\n{\\r\\nif (!BN_copy(z, &point->Z)) goto err;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x, const BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (x == NULL || y == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_Jprojective_coordinates_GFp(group, point, x, y, BN_value_one(), ctx);\\r\\n}\\r\\nint ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *Z, *Z_1, *Z_2, *Z_3;\\r\\nconst BIGNUM *Z_;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, EC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nZ = BN_CTX_get(ctx);\\r\\nZ_1 = BN_CTX_get(ctx);\\r\\nZ_2 = BN_CTX_get(ctx);\\r\\nZ_3 = BN_CTX_get(ctx);\\r\\nif (Z_3 == NULL) goto err;\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (!group->meth->field_decode(group, Z, &point->Z, ctx)) goto err;\\r\\nZ_ = Z;\\r\\n}\\r\\nelse\\r\\n{\\r\\nZ_ = &point->Z;\\r\\n}\\r\\nif (BN_is_one(Z_))\\r\\n{\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, x, &point->X, ctx)) goto err;\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!group->meth->field_decode(group, y, &point->Y, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!BN_copy(x, &point->X)) goto err;\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (!BN_copy(y, &point->Y)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_inverse(Z_1, Z_, &group->field, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (group->meth->field_encode == 0)\\r\\n{\\r\\nif (!group->meth->field_sqr(group, Z_2, Z_1, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_sqr(Z_2, Z_1, &group->field, ctx)) goto err;\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif (!group->meth->field_mul(group, x, &point->X, Z_2, ctx)) goto err;\\r\\n}\\r\\nif (y != NULL)\\r\\n{\\r\\nif (group->meth->field_encode == 0)\\r\\n{\\r\\nif (!group->meth->field_mul(group, Z_3, Z_2, Z_1, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_mul(Z_3, Z_2, Z_1, &group->field, ctx)) goto err;\\r\\n}\\r\\nif (!group->meth->field_mul(group, y, &point->Y, Z_3, ctx)) goto err;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,\\r\\nconst BIGNUM *x_, int y_bit, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp1, *tmp2, *x, *y;\\r\\nint ret = 0;\\r\\nERR_clear_error();\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\ny_bit = (y_bit != 0);\\r\\nBN_CTX_start(ctx);\\r\\ntmp1 = BN_CTX_get(ctx);\\r\\ntmp2 = BN_CTX_get(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto err;\\r\\nif (!BN_nnmod(x, x_, &group->field,ctx)) goto err;\\r\\nif (group->meth->field_decode == 0)\\r\\n{\\r\\nif (!group->meth->field_sqr(group, tmp2, x_, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, tmp1, tmp2, x_, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_sqr(tmp2, x_, &group->field, ctx)) goto err;\\r\\nif (!BN_mod_mul(tmp1, tmp2, x_, &group->field, ctx)) goto err;\\r\\n}\\r\\nif (group->a_is_minus3)\\r\\n{\\r\\nif (!BN_mod_lshift1_quick(tmp2, x, &group->field)) goto err;\\r\\nif (!BN_mod_add_quick(tmp2, tmp2, x, &group->field)) goto err;\\r\\nif (!BN_mod_sub_quick(tmp1, tmp1, tmp2, &group->field)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (!group->meth->field_decode(group, tmp2, &group->a, ctx)) goto err;\\r\\nif (!BN_mod_mul(tmp2, tmp2, x, &group->field, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!group->meth->field_mul(group, tmp2, &group->a, x, ctx)) goto err;\\r\\n}\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field)) goto err;\\r\\n}\\r\\nif (group->meth->field_decode)\\r\\n{\\r\\nif (!group->meth->field_decode(group, tmp2, &group->b, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, &group->b, &group->field)) goto err;\\r\\n}\\r\\nif (!BN_mod_sqrt(y, tmp1, &group->field, ctx))\\r\\n{\\r\\nunsigned long err = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_BN && ERR_GET_REASON(err) == BN_R_NOT_A_SQUARE)\\r\\n{\\r\\nERR_clear_error();\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);\\r\\n}\\r\\nelse\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (y_bit != BN_is_odd(y))\\r\\n{\\r\\nif (BN_is_zero(y))\\r\\n{\\r\\nint kron;\\r\\nkron = BN_kronecker(x, &group->field, ctx);\\r\\nif (kron == -2) goto err;\\r\\nif (kron == 1)\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSION_BIT);\\r\\nelse\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, EC_R_INVALID_COMPRESSED_POINT);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_usub(y, &group->field, y)) goto err;\\r\\n}\\r\\nif (y_bit != BN_is_odd(y))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nsize_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point, point_conversion_form_t form,\\r\\nunsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nsize_t ret;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint used_ctx = 0;\\r\\nBIGNUM *x, *y;\\r\\nsize_t field_len, i, skip;\\r\\nif ((form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nif (buf != NULL)\\r\\n{\\r\\nif (len < 1)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nbuf[0] = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nfield_len = BN_num_bytes(&group->field);\\r\\nret = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;\\r\\nif (buf != NULL)\\r\\n{\\r\\nif (len < ret)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nused_ctx = 1;\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;\\r\\nif ((form == POINT_CONVERSION_COMPRESSED || form == POINT_CONVERSION_HYBRID) && BN_is_odd(y))\\r\\nbuf[0] = form + 1;\\r\\nelse\\r\\nbuf[0] = form;\\r\\ni = 1;\\r\\nskip = field_len - BN_num_bytes(x);\\r\\nif (skip > field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0)\\r\\n{\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(x, buf + i);\\r\\ni += skip;\\r\\nif (i != 1 + field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_UNCOMPRESSED || form == POINT_CONVERSION_HYBRID)\\r\\n{\\r\\nskip = field_len - BN_num_bytes(y);\\r\\nif (skip > field_len)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0)\\r\\n{\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(y, buf + i);\\r\\ni += skip;\\r\\n}\\r\\nif (i != ret)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\nerr:\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\npoint_conversion_form_t form;\\r\\nint y_bit;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nsize_t field_len, enc_len;\\r\\nint ret = 0;\\r\\nif (len == 0)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nform = buf[0];\\r\\ny_bit = form & 1;\\r\\nform = form & ~1U;\\r\\nif ((form != 0) && (form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) && y_bit)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (form == 0)\\r\\n{\\r\\nif (len != 1)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_to_infinity(group, point);\\r\\n}\\r\\nfield_len = BN_num_bytes(&group->field);\\r\\nenc_len = (form == POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2*field_len;\\r\\nif (len != enc_len)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto err;\\r\\nif (!BN_bin2bn(buf + 1, field_len, x)) goto err;\\r\\nif (BN_ucmp(x, &group->field) >= 0)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_COMPRESSED)\\r\\n{\\r\\nif (!EC_POINT_set_compressed_coordinates_GFp(group, point, x, y_bit, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_bin2bn(buf + 1 + field_len, field_len, y)) goto err;\\r\\nif (BN_ucmp(y, &group->field) >= 0)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_HYBRID)\\r\\n{\\r\\nif (y_bit != BN_is_odd(y))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, point, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *n0, *n1, *n2, *n3, *n4, *n5, *n6;\\r\\nint ret = 0;\\r\\nif (a == b)\\r\\nreturn EC_POINT_dbl(group, r, a, ctx);\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\nreturn EC_POINT_copy(r, b);\\r\\nif (EC_POINT_is_at_infinity(group, b))\\r\\nreturn EC_POINT_copy(r, a);\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nn0 = BN_CTX_get(ctx);\\r\\nn1 = BN_CTX_get(ctx);\\r\\nn2 = BN_CTX_get(ctx);\\r\\nn3 = BN_CTX_get(ctx);\\r\\nn4 = BN_CTX_get(ctx);\\r\\nn5 = BN_CTX_get(ctx);\\r\\nn6 = BN_CTX_get(ctx);\\r\\nif (n6 == NULL) goto end;\\r\\nif (b->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(n1, &a->X)) goto end;\\r\\nif (!BN_copy(n2, &a->Y)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!field_sqr(group, n0, &b->Z, ctx)) goto end;\\r\\nif (!field_mul(group, n1, &a->X, n0, ctx)) goto end;\\r\\nif (!field_mul(group, n0, n0, &b->Z, ctx)) goto end;\\r\\nif (!field_mul(group, n2, &a->Y, n0, ctx)) goto end;\\r\\n}\\r\\nif (a->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(n3, &b->X)) goto end;\\r\\nif (!BN_copy(n4, &b->Y)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!field_sqr(group, n0, &a->Z, ctx)) goto end;\\r\\nif (!field_mul(group, n3, &b->X, n0, ctx)) goto end;\\r\\nif (!field_mul(group, n0, n0, &a->Z, ctx)) goto end;\\r\\nif (!field_mul(group, n4, &b->Y, n0, ctx)) goto end;\\r\\n}\\r\\nif (!BN_mod_sub_quick(n5, n1, n3, p)) goto end;\\r\\nif (!BN_mod_sub_quick(n6, n2, n4, p)) goto end;\\r\\nif (BN_is_zero(n5))\\r\\n{\\r\\nif (BN_is_zero(n6))\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nret = EC_POINT_dbl(group, r, a, ctx);\\r\\nctx = NULL;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBN_zero(&r->Z);\\r\\nr->Z_is_one = 0;\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_add_quick(n1, n1, n3, p)) goto end;\\r\\nif (!BN_mod_add_quick(n2, n2, n4, p)) goto end;\\r\\nif (a->Z_is_one && b->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(&r->Z, n5)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (a->Z_is_one)\\r\\n{ if (!BN_copy(n0, &b->Z)) goto end; }\\r\\nelse if (b->Z_is_one)\\r\\n{ if (!BN_copy(n0, &a->Z)) goto end; }\\r\\nelse\\r\\n{ if (!field_mul(group, n0, &a->Z, &b->Z, ctx)) goto end; }\\r\\nif (!field_mul(group, &r->Z, n0, n5, ctx)) goto end;\\r\\n}\\r\\nr->Z_is_one = 0;\\r\\nif (!field_sqr(group, n0, n6, ctx)) goto end;\\r\\nif (!field_sqr(group, n4, n5, ctx)) goto end;\\r\\nif (!field_mul(group, n3, n1, n4, ctx)) goto end;\\r\\nif (!BN_mod_sub_quick(&r->X, n0, n3, p)) goto end;\\r\\nif (!BN_mod_lshift1_quick(n0, &r->X, p)) goto end;\\r\\nif (!BN_mod_sub_quick(n0, n3, n0, p)) goto end;\\r\\nif (!field_mul(group, n0, n0, n6, ctx)) goto end;\\r\\nif (!field_mul(group, n5, n4, n5, ctx)) goto end;\\r\\nif (!field_mul(group, n1, n2, n5, ctx)) goto end;\\r\\nif (!BN_mod_sub_quick(n0, n0, n1, p)) goto end;\\r\\nif (BN_is_odd(n0))\\r\\nif (!BN_add(n0, n0, p)) goto end;\\r\\nif (!BN_rshift1(&r->Y, n0)) goto end;\\r\\nret = 1;\\r\\nend:\\r\\nif (ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *n0, *n1, *n2, *n3;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\n{\\r\\nBN_zero(&r->Z);\\r\\nr->Z_is_one = 0;\\r\\nreturn 1;\\r\\n}\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nn0 = BN_CTX_get(ctx);\\r\\nn1 = BN_CTX_get(ctx);\\r\\nn2 = BN_CTX_get(ctx);\\r\\nn3 = BN_CTX_get(ctx);\\r\\nif (n3 == NULL) goto err;\\r\\nif (a->Z_is_one)\\r\\n{\\r\\nif (!field_sqr(group, n0, &a->X, ctx)) goto err;\\r\\nif (!BN_mod_lshift1_quick(n1, n0, p)) goto err;\\r\\nif (!BN_mod_add_quick(n0, n0, n1, p)) goto err;\\r\\nif (!BN_mod_add_quick(n1, n0, &group->a, p)) goto err;\\r\\n}\\r\\nelse if (group->a_is_minus3)\\r\\n{\\r\\nif (!field_sqr(group, n1, &a->Z, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(n0, &a->X, n1, p)) goto err;\\r\\nif (!BN_mod_sub_quick(n2, &a->X, n1, p)) goto err;\\r\\nif (!field_mul(group, n1, n0, n2, ctx)) goto err;\\r\\nif (!BN_mod_lshift1_quick(n0, n1, p)) goto err;\\r\\nif (!BN_mod_add_quick(n1, n0, n1, p)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!field_sqr(group, n0, &a->X, ctx)) goto err;\\r\\nif (!BN_mod_lshift1_quick(n1, n0, p)) goto err;\\r\\nif (!BN_mod_add_quick(n0, n0, n1, p)) goto err;\\r\\nif (!field_sqr(group, n1, &a->Z, ctx)) goto err;\\r\\nif (!field_sqr(group, n1, n1, ctx)) goto err;\\r\\nif (!field_mul(group, n1, n1, &group->a, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(n1, n1, n0, p)) goto err;\\r\\n}\\r\\nif (a->Z_is_one)\\r\\n{\\r\\nif (!BN_copy(n0, &a->Y)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!field_mul(group, n0, &a->Y, &a->Z, ctx)) goto err;\\r\\n}\\r\\nif (!BN_mod_lshift1_quick(&r->Z, n0, p)) goto err;\\r\\nr->Z_is_one = 0;\\r\\nif (!field_sqr(group, n3, &a->Y, ctx)) goto err;\\r\\nif (!field_mul(group, n2, &a->X, n3, ctx)) goto err;\\r\\nif (!BN_mod_lshift_quick(n2, n2, 2, p)) goto err;\\r\\nif (!BN_mod_lshift1_quick(n0, n2, p)) goto err;\\r\\nif (!field_sqr(group, &r->X, n1, ctx)) goto err;\\r\\nif (!BN_mod_sub_quick(&r->X, &r->X, n0, p)) goto err;\\r\\nif (!field_sqr(group, n0, n3, ctx)) goto err;\\r\\nif (!BN_mod_lshift_quick(n3, n0, 3, p)) goto err;\\r\\nif (!BN_mod_sub_quick(n0, n2, &r->X, p)) goto err;\\r\\nif (!field_mul(group, n0, n1, n0, ctx)) goto err;\\r\\nif (!BN_mod_sub_quick(&r->Y, n0, n3, p)) goto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (EC_POINT_is_at_infinity(group, point) || BN_is_zero(&point->Y))\\r\\nreturn 1;\\r\\nreturn BN_usub(&point->Y, &group->field, &point->Y);\\r\\n}\\r\\nint ec_GFp_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)\\r\\n{\\r\\nreturn BN_is_zero(&point->Z);\\r\\n}\\r\\nint ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *rh, *tmp, *Z4, *Z6;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nrh = BN_CTX_get(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nZ4 = BN_CTX_get(ctx);\\r\\nZ6 = BN_CTX_get(ctx);\\r\\nif (Z6 == NULL) goto err;\\r\\nif (!field_sqr(group, rh, &point->X, ctx)) goto err;\\r\\nif (!point->Z_is_one)\\r\\n{\\r\\nif (!field_sqr(group, tmp, &point->Z, ctx)) goto err;\\r\\nif (!field_sqr(group, Z4, tmp, ctx)) goto err;\\r\\nif (!field_mul(group, Z6, Z4, tmp, ctx)) goto err;\\r\\nif (group->a_is_minus3)\\r\\n{\\r\\nif (!BN_mod_lshift1_quick(tmp, Z4, p)) goto err;\\r\\nif (!BN_mod_add_quick(tmp, tmp, Z4, p)) goto err;\\r\\nif (!BN_mod_sub_quick(rh, rh, tmp, p)) goto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!field_mul(group, tmp, Z4, &group->a, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx)) goto err;\\r\\n}\\r\\nif (!field_mul(group, tmp, &group->b, Z6, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(rh, rh, tmp, p)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_add_quick(rh, rh, &group->a, p)) goto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx)) goto err;\\r\\nif (!BN_mod_add_quick(rh, rh, &group->b, p)) goto err;\\r\\n}\\r\\nif (!field_sqr(group, tmp, &point->Y, ctx)) goto err;\\r\\nret = (0 == BN_ucmp(tmp, rh));\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul)(const EC_GROUP *, BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp1, *tmp2, *Za23, *Zb23;\\r\\nconst BIGNUM *tmp1_, *tmp2_;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\n{\\r\\nreturn EC_POINT_is_at_infinity(group, b) ? 0 : 1;\\r\\n}\\r\\nif (a->Z_is_one && b->Z_is_one)\\r\\n{\\r\\nreturn ((BN_cmp(&a->X, &b->X) == 0) && BN_cmp(&a->Y, &b->Y) == 0) ? 0 : 1;\\r\\n}\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp1 = BN_CTX_get(ctx);\\r\\ntmp2 = BN_CTX_get(ctx);\\r\\nZa23 = BN_CTX_get(ctx);\\r\\nZb23 = BN_CTX_get(ctx);\\r\\nif (Zb23 == NULL) goto end;\\r\\nif (!b->Z_is_one)\\r\\n{\\r\\nif (!field_sqr(group, Zb23, &b->Z, ctx)) goto end;\\r\\nif (!field_mul(group, tmp1, &a->X, Zb23, ctx)) goto end;\\r\\ntmp1_ = tmp1;\\r\\n}\\r\\nelse\\r\\ntmp1_ = &a->X;\\r\\nif (!a->Z_is_one)\\r\\n{\\r\\nif (!field_sqr(group, Za23, &a->Z, ctx)) goto end;\\r\\nif (!field_mul(group, tmp2, &b->X, Za23, ctx)) goto end;\\r\\ntmp2_ = tmp2;\\r\\n}\\r\\nelse\\r\\ntmp2_ = &b->X;\\r\\nif (BN_cmp(tmp1_, tmp2_) != 0)\\r\\n{\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nif (!b->Z_is_one)\\r\\n{\\r\\nif (!field_mul(group, Zb23, Zb23, &b->Z, ctx)) goto end;\\r\\nif (!field_mul(group, tmp1, &a->Y, Zb23, ctx)) goto end;\\r\\n}\\r\\nelse\\r\\ntmp1_ = &a->Y;\\r\\nif (!a->Z_is_one)\\r\\n{\\r\\nif (!field_mul(group, Za23, Za23, &a->Z, ctx)) goto end;\\r\\nif (!field_mul(group, tmp2, &b->Y, Za23, ctx)) goto end;\\r\\n}\\r\\nelse\\r\\ntmp2_ = &b->Y;\\r\\nif (BN_cmp(tmp1_, tmp2_) != 0)\\r\\n{\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nint ret = 0;\\r\\nif (point->Z_is_one || EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx)) goto err;\\r\\nif (!point->Z_is_one)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_MAKE_AFFINE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp0, *tmp1;\\r\\nsize_t pow2 = 0;\\r\\nBIGNUM **heap = NULL;\\r\\nsize_t i;\\r\\nint ret = 0;\\r\\nif (num == 0)\\r\\nreturn 1;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp0 = BN_CTX_get(ctx);\\r\\ntmp1 = BN_CTX_get(ctx);\\r\\nif (tmp0 == NULL || tmp1 == NULL) goto err;\\r\\npow2 = 1;\\r\\nwhile (num > pow2)\\r\\npow2 <<= 1;\\r\\npow2 <<= 1;\\r\\nheap = OPENSSL_malloc(pow2 * sizeof heap[0]);\\r\\nif (heap == NULL) goto err;\\r\\nheap[0] = NULL;\\r\\nfor (i = pow2/2 - 1; i > 0; i--)\\r\\nheap[i] = NULL;\\r\\nfor (i = 0; i < num; i++)\\r\\nheap[pow2/2 + i] = &points[i]->Z;\\r\\nfor (i = pow2/2 + num; i < pow2; i++)\\r\\nheap[i] = NULL;\\r\\nfor (i = pow2/2 - 1; i > 0; i--)\\r\\n{\\r\\nheap[i] = BN_new();\\r\\nif (heap[i] == NULL) goto err;\\r\\nif (heap[2*i] != NULL)\\r\\n{\\r\\nif ((heap[2*i + 1] == NULL) || BN_is_zero(heap[2*i + 1]))\\r\\n{\\r\\nif (!BN_copy(heap[i], heap[2*i])) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_is_zero(heap[2*i]))\\r\\n{\\r\\nif (!BN_copy(heap[i], heap[2*i + 1])) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!group->meth->field_mul(group, heap[i],\\r\\nheap[2*i], heap[2*i + 1], ctx)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!BN_is_zero(heap[1]))\\r\\n{\\r\\nif (!BN_mod_inverse(heap[1], heap[1], &group->field, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (group->meth->field_encode != 0)\\r\\n{\\r\\nif (!group->meth->field_encode(group, heap[1], heap[1], ctx)) goto err;\\r\\nif (!group->meth->field_encode(group, heap[1], heap[1], ctx)) goto err;\\r\\n}\\r\\nfor (i = 2; i < pow2/2 + num; i += 2)\\r\\n{\\r\\nif ((heap[i + 1] != NULL) && !BN_is_zero(heap[i + 1]))\\r\\n{\\r\\nif (!group->meth->field_mul(group, tmp0, heap[i/2], heap[i + 1], ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, tmp1, heap[i/2], heap[i], ctx)) goto err;\\r\\nif (!BN_copy(heap[i], tmp0)) goto err;\\r\\nif (!BN_copy(heap[i + 1], tmp1)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_copy(heap[i], heap[i/2])) goto err;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nEC_POINT *p = points[i];\\r\\nif (!BN_is_zero(&p->Z))\\r\\n{\\r\\nif (!group->meth->field_sqr(group, tmp1, &p->Z, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, &p->X, &p->X, tmp1, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, tmp1, tmp1, &p->Z, ctx)) goto err;\\r\\nif (!group->meth->field_mul(group, &p->Y, &p->Y, tmp1, ctx)) goto err;\\r\\nif (group->meth->field_set_to_one != 0)\\r\\n{\\r\\nif (!group->meth->field_set_to_one(group, &p->Z, ctx)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_one(&p->Z)) goto err;\\r\\n}\\r\\np->Z_is_one = 1;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (heap != NULL)\\r\\n{\\r\\nfor (i = pow2/2 - 1; i > 0; i--)\\r\\n{\\r\\nif (heap[i] != NULL)\\r\\nBN_clear_free(heap[i]);\\r\\n}\\r\\nOPENSSL_free(heap);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_mod_mul(r, a, b, &group->field, ctx);\\r\\n}\\r\\nint ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_mod_sqr(r, a, &group->field, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_ctx_c", "target": 0, "func": "static void ctxdbg(BN_CTX *ctx)\\r\\n{\\r\\nunsigned int bnidx = 0, fpidx = 0;\\r\\nBN_POOL_ITEM *item = ctx->pool.head;\\r\\nBN_STACK *stack = &ctx->stack;\\r\\nfprintf(stderr,\"(%08x): \", (unsigned int)ctx);\\r\\nwhile(bnidx < ctx->used)\\r\\n{\\r\\nfprintf(stderr,\"%02x \", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);\\r\\nif(!(bnidx % BN_CTX_POOL_SIZE))\\r\\nitem = item->next;\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\nbnidx = 0;\\r\\nfprintf(stderr,\" : \");\\r\\nwhile(fpidx < stack->depth)\\r\\n{\\r\\nwhile(bnidx++ < stack->indexes[fpidx])\\r\\nfprintf(stderr,\" \");\\r\\nfprintf(stderr,\"^^ \");\\r\\nbnidx++;\\r\\nfpidx++;\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\nvoid BN_CTX_init(BN_CTX *ctx)\\r\\n{\\r\\nBN_POOL_reset(&ctx->pool);\\r\\nBN_STACK_reset(&ctx->stack);\\r\\nctx->used = 0;\\r\\nctx->err_stack = 0;\\r\\nctx->too_many = 0;\\r\\n}\\r\\nBN_CTX *BN_CTX_new(void)\\r\\n{\\r\\nBN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));\\r\\nif(!ret)\\r\\n{\\r\\nBNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nBN_POOL_init(&ret->pool);\\r\\nBN_STACK_init(&ret->stack);\\r\\nret->used = 0;\\r\\nret->err_stack = 0;\\r\\nret->too_many = 0;\\r\\nreturn ret;\\r\\n}\\r\\nvoid BN_CTX_free(BN_CTX *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn;\\r\\n#ifdef BN_CTX_DEBUG\\r\\n{\\r\\nBN_POOL_ITEM *pool = ctx->pool.head;\\r\\nfprintf(stderr,\"BN_CTX_free, stack-size=%d, pool-bignums=%d\\n\",\\r\\nctx->stack.size, ctx->pool.size);\\r\\nfprintf(stderr,\"dmaxs: \");\\r\\nwhile(pool) {\\r\\nunsigned loop = 0;\\r\\nwhile(loop < BN_CTX_POOL_SIZE)\\r\\nfprintf(stderr,\"%02x \", pool->vals[loop++].dmax);\\r\\npool = pool->next;\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\n#endif\\r\\nBN_STACK_finish(&ctx->stack);\\r\\nBN_POOL_finish(&ctx->pool);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nvoid BN_CTX_start(BN_CTX *ctx)\\r\\n{\\r\\nCTXDBG_ENTRY(\"BN_CTX_start\", ctx);\\r\\nif(ctx->err_stack || ctx->too_many)\\r\\nctx->err_stack++;\\r\\nelse if(!BN_STACK_push(&ctx->stack, ctx->used))\\r\\n{\\r\\nBNerr(BN_F_BN_CTX_START,BN_R_TOO_MANY_TEMPORARY_VARIABLES);\\r\\nctx->err_stack++;\\r\\n}\\r\\nCTXDBG_EXIT(ctx);\\r\\n}\\r\\nvoid BN_CTX_end(BN_CTX *ctx)\\r\\n{\\r\\nCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\\r\\nif(ctx->err_stack)\\r\\nctx->err_stack--;\\r\\nelse\\r\\n{\\r\\nunsigned int fp = BN_STACK_pop(&ctx->stack);\\r\\nif(fp < ctx->used)\\r\\nBN_POOL_release(&ctx->pool, ctx->used - fp);\\r\\nctx->used = fp;\\r\\nctx->too_many = 0;\\r\\n}\\r\\nCTXDBG_EXIT(ctx);\\r\\n}\\r\\nBIGNUM *BN_CTX_get(BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nCTXDBG_ENTRY(\"BN_CTX_get\", ctx);\\r\\nif(ctx->err_stack || ctx->too_many) return NULL;\\r\\nif((ret = BN_POOL_get(&ctx->pool)) == NULL)\\r\\n{\\r\\nctx->too_many = 1;\\r\\nBNerr(BN_F_BN_CTX_GET,BN_R_TOO_MANY_TEMPORARY_VARIABLES);\\r\\nreturn NULL;\\r\\n}\\r\\nBN_zero(ret);\\r\\nctx->used++;\\r\\nCTXDBG_RET(ctx, ret);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void BN_STACK_init(BN_STACK *st)\\r\\n{\\r\\nst->indexes = NULL;\\r\\nst->depth = st->size = 0;\\r\\n}\\r\\nstatic void BN_STACK_finish(BN_STACK *st)\\r\\n{\\r\\nif(st->size) OPENSSL_free(st->indexes);\\r\\n}\\r\\nstatic void BN_STACK_reset(BN_STACK *st)\\r\\n{\\r\\nst->depth = 0;\\r\\n}\\r\\nstatic int BN_STACK_push(BN_STACK *st, unsigned int idx)\\r\\n{\\r\\nif(st->depth == st->size)\\r\\n{\\r\\nunsigned int newsize = (st->size ?\\r\\n(st->size * 3 / 2) : BN_CTX_START_FRAMES);\\r\\nunsigned int *newitems = OPENSSL_malloc(newsize *\\r\\nsizeof(unsigned int));\\r\\nif(!newitems) return 0;\\r\\nif(st->depth)\\r\\nmemcpy(newitems, st->indexes, st->depth *\\r\\nsizeof(unsigned int));\\r\\nif(st->size) OPENSSL_free(st->indexes);\\r\\nst->indexes = newitems;\\r\\nst->size = newsize;\\r\\n}\\r\\nst->indexes[(st->depth)++] = idx;\\r\\nreturn 1;\\r\\n}\\r\\nstatic unsigned int BN_STACK_pop(BN_STACK *st)\\r\\n{\\r\\nreturn st->indexes[--(st->depth)];\\r\\n}\\r\\nstatic void BN_POOL_init(BN_POOL *p)\\r\\n{\\r\\np->head = p->current = p->tail = NULL;\\r\\np->used = p->size = 0;\\r\\n}\\r\\nstatic void BN_POOL_finish(BN_POOL *p)\\r\\n{\\r\\nwhile(p->head)\\r\\n{\\r\\nunsigned int loop = 0;\\r\\nBIGNUM *bn = p->head->vals;\\r\\nwhile(loop++ < BN_CTX_POOL_SIZE)\\r\\n{\\r\\nif(bn->d) BN_clear_free(bn);\\r\\nbn++;\\r\\n}\\r\\np->current = p->head->next;\\r\\nOPENSSL_free(p->head);\\r\\np->head = p->current;\\r\\n}\\r\\n}\\r\\nstatic void BN_POOL_reset(BN_POOL *p)\\r\\n{\\r\\nBN_POOL_ITEM *item = p->head;\\r\\nwhile(item)\\r\\n{\\r\\nunsigned int loop = 0;\\r\\nBIGNUM *bn = item->vals;\\r\\nwhile(loop++ < BN_CTX_POOL_SIZE)\\r\\n{\\r\\nif(bn->d) BN_clear(bn);\\r\\nbn++;\\r\\n}\\r\\nitem = item->next;\\r\\n}\\r\\np->current = p->head;\\r\\np->used = 0;\\r\\n}\\r\\nstatic BIGNUM *BN_POOL_get(BN_POOL *p)\\r\\n{\\r\\nif(p->used == p->size)\\r\\n{\\r\\nBIGNUM *bn;\\r\\nunsigned int loop = 0;\\r\\nBN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));\\r\\nif(!item) return NULL;\\r\\nbn = item->vals;\\r\\nwhile(loop++ < BN_CTX_POOL_SIZE)\\r\\nBN_init(bn++);\\r\\nitem->prev = p->tail;\\r\\nitem->next = NULL;\\r\\nif(!p->head)\\r\\np->head = p->current = p->tail = item;\\r\\nelse\\r\\n{\\r\\np->tail->next = item;\\r\\np->tail = item;\\r\\np->current = item;\\r\\n}\\r\\np->size += BN_CTX_POOL_SIZE;\\r\\np->used++;\\r\\nreturn item->vals;\\r\\n}\\r\\nif(!p->used)\\r\\np->current = p->head;\\r\\nelse if((p->used % BN_CTX_POOL_SIZE) == 0)\\r\\np->current = p->current->next;\\r\\nreturn p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);\\r\\n}\\r\\nstatic void BN_POOL_release(BN_POOL *p, unsigned int num)\\r\\n{\\r\\nunsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;\\r\\np->used -= num;\\r\\nwhile(num--)\\r\\n{\\r\\nbn_check_top(p->current->vals + offset);\\r\\nif(!offset)\\r\\n{\\r\\noffset = BN_CTX_POOL_SIZE - 1;\\r\\np->current = p->current->prev;\\r\\n}\\r\\nelse\\r\\noffset--;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha256_c", "target": 0, "func": "int SHA224_Init (SHA256_CTX *c)\\r\\n{\\r\\nc->h[0]=0xc1059ed8UL; c->h[1]=0x367cd507UL;\\r\\nc->h[2]=0x3070dd17UL; c->h[3]=0xf70e5939UL;\\r\\nc->h[4]=0xffc00b31UL; c->h[5]=0x68581511UL;\\r\\nc->h[6]=0x64f98fa7UL; c->h[7]=0xbefa4fa4UL;\\r\\nc->Nl=0; c->Nh=0;\\r\\nc->num=0; c->md_len=SHA224_DIGEST_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nint SHA256_Init (SHA256_CTX *c)\\r\\n{\\r\\nc->h[0]=0x6a09e667UL; c->h[1]=0xbb67ae85UL;\\r\\nc->h[2]=0x3c6ef372UL; c->h[3]=0xa54ff53aUL;\\r\\nc->h[4]=0x510e527fUL; c->h[5]=0x9b05688cUL;\\r\\nc->h[6]=0x1f83d9abUL; c->h[7]=0x5be0cd19UL;\\r\\nc->Nl=0; c->Nh=0;\\r\\nc->num=0; c->md_len=SHA256_DIGEST_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nunsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA256_CTX c;\\r\\nstatic unsigned char m[SHA224_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA224_Init(&c);\\r\\nSHA256_Update(&c,d,n);\\r\\nSHA256_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}\\r\\nunsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA256_CTX c;\\r\\nstatic unsigned char m[SHA256_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA256_Init(&c);\\r\\nSHA256_Update(&c,d,n);\\r\\nSHA256_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}\\r\\nint SHA224_Update(SHA256_CTX *c, const void *data, size_t len)\\r\\n{ return SHA256_Update (c,data,len); }\\r\\nint SHA224_Final (unsigned char *md, SHA256_CTX *c)\\r\\n{ return SHA256_Final (md,c); }\\r\\nstatic void sha256_block (SHA256_CTX *ctx, const void *in, size_t num, int host)\\r\\n{\\r\\nunsigned MD32_REG_T a,b,c,d,e,f,g,h,s0,s1,T1,T2;\\r\\nSHA_LONG X[16];\\r\\nint i;\\r\\nconst unsigned char *data=in;\\r\\nwhile (num--) {\\r\\na = ctx->h[0]; b = ctx->h[1]; c = ctx->h[2]; d = ctx->h[3];\\r\\ne = ctx->h[4]; f = ctx->h[5]; g = ctx->h[6]; h = ctx->h[7];\\r\\nif (host)\\r\\n{\\r\\nconst SHA_LONG *W=(const SHA_LONG *)data;\\r\\nfor (i=0;i<16;i++)\\r\\n{\\r\\nT1 = X[i] = W[i];\\r\\nT1 += h + Sigma1(e) + Ch(e,f,g) + K256[i];\\r\\nT2 = Sigma0(a) + Maj(a,b,c);\\r\\nh = g; g = f; f = e; e = d + T1;\\r\\nd = c; c = b; b = a; a = T1 + T2;\\r\\n}\\r\\ndata += SHA256_CBLOCK;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSHA_LONG l;\\r\\nfor (i=0;i<16;i++)\\r\\n{\\r\\nHOST_c2l(data,l); T1 = X[i] = l;\\r\\nT1 += h + Sigma1(e) + Ch(e,f,g) + K256[i];\\r\\nT2 = Sigma0(a) + Maj(a,b,c);\\r\\nh = g; g = f; f = e; e = d + T1;\\r\\nd = c; c = b; b = a; a = T1 + T2;\\r\\n}\\r\\n}\\r\\nfor (;i<64;i++)\\r\\n{\\r\\ns0 = X[(i+1)&0x0f]; s0 = sigma0(s0);\\r\\ns1 = X[(i+14)&0x0f]; s1 = sigma1(s1);\\r\\nT1 = X[i&0xf] += s0 + s1 + X[(i+9)&0xf];\\r\\nT1 += h + Sigma1(e) + Ch(e,f,g) + K256[i];\\r\\nT2 = Sigma0(a) + Maj(a,b,c);\\r\\nh = g; g = f; f = e; e = d + T1;\\r\\nd = c; c = b; b = a; a = T1 + T2;\\r\\n}\\r\\nctx->h[0] += a; ctx->h[1] += b; ctx->h[2] += c; ctx->h[3] += d;\\r\\nctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;\\r\\n}\\r\\n}\\r\\nstatic void sha256_block (SHA256_CTX *ctx, const void *in, size_t num, int host)\\r\\n{\\r\\nunsigned MD32_REG_T a,b,c,d,e,f,g,h,s0,s1,T1;\\r\\nSHA_LONG X[16];\\r\\nint i;\\r\\nconst unsigned char *data=in;\\r\\nwhile (num--) {\\r\\na = ctx->h[0]; b = ctx->h[1]; c = ctx->h[2]; d = ctx->h[3];\\r\\ne = ctx->h[4]; f = ctx->h[5]; g = ctx->h[6]; h = ctx->h[7];\\r\\nif (host)\\r\\n{\\r\\nconst SHA_LONG *W=(const SHA_LONG *)data;\\r\\nT1 = X[0] = W[0]; ROUND_00_15(0,a,b,c,d,e,f,g,h);\\r\\nT1 = X[1] = W[1]; ROUND_00_15(1,h,a,b,c,d,e,f,g);\\r\\nT1 = X[2] = W[2]; ROUND_00_15(2,g,h,a,b,c,d,e,f);\\r\\nT1 = X[3] = W[3]; ROUND_00_15(3,f,g,h,a,b,c,d,e);\\r\\nT1 = X[4] = W[4]; ROUND_00_15(4,e,f,g,h,a,b,c,d);\\r\\nT1 = X[5] = W[5]; ROUND_00_15(5,d,e,f,g,h,a,b,c);\\r\\nT1 = X[6] = W[6]; ROUND_00_15(6,c,d,e,f,g,h,a,b);\\r\\nT1 = X[7] = W[7]; ROUND_00_15(7,b,c,d,e,f,g,h,a);\\r\\nT1 = X[8] = W[8]; ROUND_00_15(8,a,b,c,d,e,f,g,h);\\r\\nT1 = X[9] = W[9]; ROUND_00_15(9,h,a,b,c,d,e,f,g);\\r\\nT1 = X[10] = W[10]; ROUND_00_15(10,g,h,a,b,c,d,e,f);\\r\\nT1 = X[11] = W[11]; ROUND_00_15(11,f,g,h,a,b,c,d,e);\\r\\nT1 = X[12] = W[12]; ROUND_00_15(12,e,f,g,h,a,b,c,d);\\r\\nT1 = X[13] = W[13]; ROUND_00_15(13,d,e,f,g,h,a,b,c);\\r\\nT1 = X[14] = W[14]; ROUND_00_15(14,c,d,e,f,g,h,a,b);\\r\\nT1 = X[15] = W[15]; ROUND_00_15(15,b,c,d,e,f,g,h,a);\\r\\ndata += SHA256_CBLOCK;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSHA_LONG l;\\r\\nHOST_c2l(data,l); T1 = X[0] = l; ROUND_00_15(0,a,b,c,d,e,f,g,h);\\r\\nHOST_c2l(data,l); T1 = X[1] = l; ROUND_00_15(1,h,a,b,c,d,e,f,g);\\r\\nHOST_c2l(data,l); T1 = X[2] = l; ROUND_00_15(2,g,h,a,b,c,d,e,f);\\r\\nHOST_c2l(data,l); T1 = X[3] = l; ROUND_00_15(3,f,g,h,a,b,c,d,e);\\r\\nHOST_c2l(data,l); T1 = X[4] = l; ROUND_00_15(4,e,f,g,h,a,b,c,d);\\r\\nHOST_c2l(data,l); T1 = X[5] = l; ROUND_00_15(5,d,e,f,g,h,a,b,c);\\r\\nHOST_c2l(data,l); T1 = X[6] = l; ROUND_00_15(6,c,d,e,f,g,h,a,b);\\r\\nHOST_c2l(data,l); T1 = X[7] = l; ROUND_00_15(7,b,c,d,e,f,g,h,a);\\r\\nHOST_c2l(data,l); T1 = X[8] = l; ROUND_00_15(8,a,b,c,d,e,f,g,h);\\r\\nHOST_c2l(data,l); T1 = X[9] = l; ROUND_00_15(9,h,a,b,c,d,e,f,g);\\r\\nHOST_c2l(data,l); T1 = X[10] = l; ROUND_00_15(10,g,h,a,b,c,d,e,f);\\r\\nHOST_c2l(data,l); T1 = X[11] = l; ROUND_00_15(11,f,g,h,a,b,c,d,e);\\r\\nHOST_c2l(data,l); T1 = X[12] = l; ROUND_00_15(12,e,f,g,h,a,b,c,d);\\r\\nHOST_c2l(data,l); T1 = X[13] = l; ROUND_00_15(13,d,e,f,g,h,a,b,c);\\r\\nHOST_c2l(data,l); T1 = X[14] = l; ROUND_00_15(14,c,d,e,f,g,h,a,b);\\r\\nHOST_c2l(data,l); T1 = X[15] = l; ROUND_00_15(15,b,c,d,e,f,g,h,a);\\r\\n}\\r\\nfor (i=16;i<64;i+=8)\\r\\n{\\r\\nROUND_16_63(i+0,a,b,c,d,e,f,g,h,X);\\r\\nROUND_16_63(i+1,h,a,b,c,d,e,f,g,X);\\r\\nROUND_16_63(i+2,g,h,a,b,c,d,e,f,X);\\r\\nROUND_16_63(i+3,f,g,h,a,b,c,d,e,X);\\r\\nROUND_16_63(i+4,e,f,g,h,a,b,c,d,X);\\r\\nROUND_16_63(i+5,d,e,f,g,h,a,b,c,X);\\r\\nROUND_16_63(i+6,c,d,e,f,g,h,a,b,X);\\r\\nROUND_16_63(i+7,b,c,d,e,f,g,h,a,X);\\r\\n}\\r\\nctx->h[0] += a; ctx->h[1] += b; ctx->h[2] += c; ctx->h[3] += d;\\r\\nctx->h[4] += e; ctx->h[5] += f; ctx->h[6] += g; ctx->h[7] += h;\\r\\n}\\r\\n}\\r\\nvoid HASH_BLOCK_HOST_ORDER (SHA256_CTX *ctx, const void *in, size_t num)\\r\\n{ sha256_block (ctx,in,num,1); }\\r\\nvoid HASH_BLOCK_DATA_ORDER (SHA256_CTX *ctx, const void *in, size_t num)\\r\\n{ sha256_block (ctx,in,num,0); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s_server_c", "target": 0, "func": "static DH *get_dh512(void)\\r\\n{\\r\\nDH *dh=NULL;\\r\\nif ((dh=DH_new()) == NULL) return(NULL);\\r\\ndh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);\\r\\ndh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);\\r\\nif ((dh->p == NULL) || (dh->g == NULL))\\r\\nreturn(NULL);\\r\\nreturn(dh);\\r\\n}\\r\\nstatic void s_server_init(void)\\r\\n{\\r\\naccept_socket=-1;\\r\\ncipher=NULL;\\r\\ns_server_verify=SSL_VERIFY_NONE;\\r\\ns_dcert_file=NULL;\\r\\ns_dkey_file=NULL;\\r\\ns_cert_file=TEST_CERT;\\r\\ns_key_file=NULL;\\r\\n#ifdef FIONBIO\\r\\ns_nbio=0;\\r\\n#endif\\r\\ns_nbio_test=0;\\r\\nctx=NULL;\\r\\nwww=0;\\r\\nbio_s_out=NULL;\\r\\ns_debug=0;\\r\\ns_msg=0;\\r\\ns_quiet=0;\\r\\nhack=0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nengine_id=NULL;\\r\\n#endif\\r\\n}\\r\\nstatic void sv_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"usage: s_server [args ...]\\n\");\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nBIO_printf(bio_err,\" -accept arg - port to accept on (default is %d)\\n\",PORT);\\r\\nBIO_printf(bio_err,\" -context arg - set session ID context\\n\");\\r\\nBIO_printf(bio_err,\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\" -Verify arg - turn on peer certificate verification, must have a cert.\\n\");\\r\\nBIO_printf(bio_err,\" -cert arg - certificate file to use\\n\");\\r\\nBIO_printf(bio_err,\" (default is %s)\\n\",TEST_CERT);\\r\\nBIO_printf(bio_err,\" -certform arg - certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -key arg - Private Key file to use, in cert file if\\n\");\\r\\nBIO_printf(bio_err,\" not specified (default is %s)\\n\",TEST_CERT);\\r\\nBIO_printf(bio_err,\" -keyform arg - key format (PEM, DER or ENGINE) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -pass arg - private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -dcert arg - second certificate file to use (usually for DSA)\\n\");\\r\\nBIO_printf(bio_err,\" -dcertform x - second certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -dkey arg - second private key file to use (usually for DSA)\\n\");\\r\\nBIO_printf(bio_err,\" -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\\n\");\\r\\nBIO_printf(bio_err,\" -dpass arg - second private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -dhparam arg - DH parameter file to use, in cert file if not specified\\n\");\\r\\nBIO_printf(bio_err,\" or a default set of parameters is used\\n\");\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBIO_printf(bio_err,\" -named_curve arg - Elliptic curve name to use for ephemeral ECDH keys.\\n\" \\\\r\\n\" Use \\\"openssl ecparam -list_curves\\\" for all names\\n\" \\\\r\\n\" (default is sect163r2).\\n\");\\r\\n#endif\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err,\" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -nbio_test - test with the non-blocking test bio\\n\");\\r\\nBIO_printf(bio_err,\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\nBIO_printf(bio_err,\" -debug - Print more output\\n\");\\r\\nBIO_printf(bio_err,\" -msg - Show protocol messages\\n\");\\r\\nBIO_printf(bio_err,\" -state - Print the SSL states\\n\");\\r\\nBIO_printf(bio_err,\" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -nocert - Don't use any certificates (Anon-DH)\\n\");\\r\\nBIO_printf(bio_err,\" -cipher arg - play with 'openssl ciphers' to see what goes here\\n\");\\r\\nBIO_printf(bio_err,\" -serverpref - Use server's cipher preferences\\n\");\\r\\nBIO_printf(bio_err,\" -quiet - No server output\\n\");\\r\\nBIO_printf(bio_err,\" -no_tmp_rsa - Do not generate a tmp RSA key\\n\");\\r\\nBIO_printf(bio_err,\" -ssl2 - Just talk SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -ssl3 - Just talk SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -tls1 - Just talk TLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -dtls1 - Just talk DTLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -timeout - Enable timeouts\\n\");\\r\\nBIO_printf(bio_err,\" -mtu - Set MTU\\n\");\\r\\nBIO_printf(bio_err,\" -chain - Read a certificate chain\\n\");\\r\\nBIO_printf(bio_err,\" -no_ssl2 - Just disable SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -no_ssl3 - Just disable SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -no_tls1 - Just disable TLSv1\\n\");\\r\\n#ifndef OPENSSL_NO_DH\\r\\nBIO_printf(bio_err,\" -no_dhe - Disable ephemeral DH\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBIO_printf(bio_err,\" -no_ecdhe - Disable ephemeral ECDH\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -bugs - Turn on SSL bug compatibility\\n\");\\r\\nBIO_printf(bio_err,\" -www - Respond to a 'GET /' with a status page\\n\");\\r\\nBIO_printf(bio_err,\" -WWW - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\\n\");\\r\\nBIO_printf(bio_err,\" -HTTP - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\\n\");\\r\\nBIO_printf(bio_err,\" with the assumption it contains a complete HTTP response.\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine id - Initialise and use the specified engine\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\\n\");\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\n}\\r\\nBIO_METHOD *BIO_f_ebcdic_filter()\\r\\n{\\r\\nreturn(&methods_ebcdic);\\r\\n}\\r\\nstatic int ebcdic_new(BIO *bi)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nwbuf = (EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);\\r\\nwbuf->alloced = 1024;\\r\\nwbuf->buff[0] = '\\0';\\r\\nbi->ptr=(char *)wbuf;\\r\\nbi->init=1;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ebcdic_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ebcdic_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out == NULL || outl == 0) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (ret > 0)\\r\\nascii2ebcdic(out,out,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ebcdic_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nint ret=0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nwbuf=(EBCDIC_OUTBUFF *)b->ptr;\\r\\nif (inl > (num = wbuf->alloced))\\r\\n{\\r\\nnum = num + num;\\r\\nif (num < inl)\\r\\nnum = inl;\\r\\nOPENSSL_free(wbuf);\\r\\nwbuf=(EBCDIC_OUTBUFF *)OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + num);\\r\\nwbuf->alloced = num;\\r\\nwbuf->buff[0] = '\\0';\\r\\nb->ptr=(char *)wbuf;\\r\\n}\\r\\nebcdic2ascii(wbuf->buff, in, inl);\\r\\nret=BIO_write(b->next_bio, wbuf->buff, inl);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ebcdic_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i, ret=0;\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nfor (i=0; i<size-1; ++i)\\r\\n{\\r\\nret = ebcdic_read(bp,&buf[i],1);\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nelse if (buf[i] == '\\n')\\r\\n{\\r\\n++i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i < size)\\r\\nbuf[i] = '\\0';\\r\\nreturn (ret < 0 && i == 0) ? ret : i;\\r\\n}\\r\\nstatic int ebcdic_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn ebcdic_write(bp, str, strlen(str));\\r\\n}\\r\\nint MAIN(int argc, char *argv[])\\r\\n{\\r\\nX509_STORE *store = NULL;\\r\\nint vflags = 0;\\r\\nshort port=PORT;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nunsigned char *context = NULL;\\r\\nchar *dhfile = NULL;\\r\\nchar *named_curve = NULL;\\r\\nint badop=0,bugs=0;\\r\\nint ret=1;\\r\\nint off=0;\\r\\nint no_tmp_rsa=0,no_dhe=0,no_ecdhe=0,nocert=0;\\r\\nint state=0;\\r\\nSSL_METHOD *meth=NULL;\\r\\n#ifdef sock_type\\r\\n#undef sock_type\\r\\n#endif\\r\\nint sock_type=SOCK_STREAM;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e=NULL;\\r\\n#endif\\r\\nchar *inrand=NULL;\\r\\nint s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM;\\r\\nchar *passarg = NULL, *pass = NULL;\\r\\nchar *dpassarg = NULL, *dpass = NULL;\\r\\nint s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;\\r\\nX509 *s_cert = NULL, *s_dcert = NULL;\\r\\nEVP_PKEY *s_key = NULL, *s_dkey = NULL;\\r\\n#if !defined(OPENSSL_NO_SSL2) && !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv23_server_method();\\r\\n#elif !defined(OPENSSL_NO_SSL3)\\r\\nmeth=SSLv3_server_method();\\r\\n#elif !defined(OPENSSL_NO_SSL2)\\r\\nmeth=SSLv2_server_method();\\r\\n#endif\\r\\nlocal_argc=argc;\\r\\nlocal_argv=argv;\\r\\napps_startup();\\r\\n#ifdef MONOLITH\\r\\ns_server_init();\\r\\n#endif\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nverify_depth=0;\\r\\n#ifdef FIONBIO\\r\\ns_nbio=0;\\r\\n#endif\\r\\ns_nbio_test=0;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif ((strcmp(*argv,\"-port\") == 0) ||\\r\\n(strcmp(*argv,\"-accept\") == 0))\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!extract_port(*(++argv),&port))\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\n{\\r\\ns_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-Verify\") == 0)\\r\\n{\\r\\ns_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|\\r\\nSSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d, must return a certificate\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-context\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncontext= (unsigned char *)*(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_cert_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-certform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_cert_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_key_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_key_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-pass\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassarg = *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dhparam\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndhfile = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nelse if (strcmp(*argv,\"-named_curve\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nnamed_curve = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-dcertform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dcert_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dcert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dcert_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dkeyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dkey_format = str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dpass\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndpassarg = *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dkey_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-nocert\") == 0)\\r\\n{\\r\\nnocert=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_check\") == 0)\\r\\n{\\r\\nvflags |= X509_V_FLAG_CRL_CHECK;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crl_check\") == 0)\\r\\n{\\r\\nvflags |= X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-serverpref\") == 0)\\r\\n{ off|=SSL_OP_CIPHER_SERVER_PREFERENCE; }\\r\\nelse if (strcmp(*argv,\"-cipher\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncipher= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv,\"-nbio\") == 0)\\r\\n{ s_nbio=1; }\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-nbio_test\") == 0)\\r\\n{\\r\\n#ifdef FIONBIO\\r\\ns_nbio=1;\\r\\n#endif\\r\\ns_nbio_test=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\n{ s_debug=1; }\\r\\nelse if (strcmp(*argv,\"-msg\") == 0)\\r\\n{ s_msg=1; }\\r\\nelse if (strcmp(*argv,\"-hack\") == 0)\\r\\n{ hack=1; }\\r\\nelse if (strcmp(*argv,\"-state\") == 0)\\r\\n{ state=1; }\\r\\nelse if (strcmp(*argv,\"-crlf\") == 0)\\r\\n{ s_crlf=1; }\\r\\nelse if (strcmp(*argv,\"-quiet\") == 0)\\r\\n{ s_quiet=1; }\\r\\nelse if (strcmp(*argv,\"-bugs\") == 0)\\r\\n{ bugs=1; }\\r\\nelse if (strcmp(*argv,\"-no_tmp_rsa\") == 0)\\r\\n{ no_tmp_rsa=1; }\\r\\nelse if (strcmp(*argv,\"-no_dhe\") == 0)\\r\\n{ no_dhe=1; }\\r\\nelse if (strcmp(*argv,\"-no_ecdhe\") == 0)\\r\\n{ no_ecdhe=1; }\\r\\nelse if (strcmp(*argv,\"-www\") == 0)\\r\\n{ www=1; }\\r\\nelse if (strcmp(*argv,\"-WWW\") == 0)\\r\\n{ www=2; }\\r\\nelse if (strcmp(*argv,\"-HTTP\") == 0)\\r\\n{ www=3; }\\r\\nelse if (strcmp(*argv,\"-no_ssl2\") == 0)\\r\\n{ off|=SSL_OP_NO_SSLv2; }\\r\\nelse if (strcmp(*argv,\"-no_ssl3\") == 0)\\r\\n{ off|=SSL_OP_NO_SSLv3; }\\r\\nelse if (strcmp(*argv,\"-no_tls1\") == 0)\\r\\n{ off|=SSL_OP_NO_TLSv1; }\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\n{ meth=SSLv2_server_method(); }\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\n{ meth=SSLv3_server_method(); }\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv,\"-tls1\") == 0)\\r\\n{ meth=TLSv1_server_method(); }\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DTLS1\\r\\nelse if (strcmp(*argv,\"-dtls1\") == 0)\\r\\n{\\r\\nmeth=DTLSv1_server_method();\\r\\nsock_type = SOCK_DGRAM;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-timeout\") == 0)\\r\\nenable_timeouts = 1;\\r\\nelse if (strcmp(*argv,\"-mtu\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nmtu = atol(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv, \"-chain\") == 0)\\r\\ncert_chain = 1;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-id_prefix\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsession_id_prefix = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine_id= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop)\\r\\n{\\r\\nbad:\\r\\nsv_usage();\\r\\ngoto end;\\r\\n}\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine_id, 1);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass))\\r\\n{\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (s_key_file == NULL)\\r\\ns_key_file = s_cert_file;\\r\\ns_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,\\r\\n\"server certificate private key file\");\\r\\nif (!s_key)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ns_cert = load_cert(bio_err,s_cert_file,s_cert_format,\\r\\nNULL, e, \"server certificate file\");\\r\\nif (!s_cert)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (s_dcert_file)\\r\\n{\\r\\nif (s_dkey_file == NULL)\\r\\ns_dkey_file = s_dcert_file;\\r\\ns_dkey = load_key(bio_err, s_dkey_file, s_dkey_format,\\r\\n0, dpass, e,\\r\\n\"second certificate private key file\");\\r\\nif (!s_dkey)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ns_dcert = load_cert(bio_err,s_dcert_file,s_dcert_format,\\r\\nNULL, e, \"second server certificate file\");\\r\\nif (!s_dcert)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status())\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nif (bio_s_out == NULL)\\r\\n{\\r\\nif (s_quiet && !s_debug && !s_msg)\\r\\n{\\r\\nbio_s_out=BIO_new(BIO_s_null());\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bio_s_out == NULL)\\r\\nbio_s_out=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)\\r\\nif (nocert)\\r\\n#endif\\r\\n{\\r\\ns_cert_file=NULL;\\r\\ns_key_file=NULL;\\r\\ns_dcert_file=NULL;\\r\\ns_dkey_file=NULL;\\r\\n}\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (session_id_prefix)\\r\\n{\\r\\nif(strlen(session_id_prefix) >= 32)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long, only one new session will be possible\\n\");\\r\\nelse if(strlen(session_id_prefix) >= 16)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long if you use SSLv2\\n\");\\r\\nif(!SSL_CTX_set_generate_session_id(ctx, generate_session_id))\\r\\n{\\r\\nBIO_printf(bio_err,\"error setting 'id_prefix'\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"id_prefix '%s' set.\\n\", session_id_prefix);\\r\\n}\\r\\nSSL_CTX_set_quiet_shutdown(ctx,1);\\r\\nif (bugs) SSL_CTX_set_options(ctx,SSL_OP_ALL);\\r\\nif (hack) SSL_CTX_set_options(ctx,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);\\r\\nSSL_CTX_set_options(ctx,off);\\r\\nif (sock_type == SOCK_DGRAM) SSL_CTX_set_read_ahead(ctx, 1);\\r\\nif (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);\\r\\nSSL_CTX_sess_set_cache_size(ctx,128);\\r\\n#if 0\\r\\nif (cipher == NULL) cipher=getenv(\"SSL_CIPHER\");\\r\\n#endif\\r\\n#if 0\\r\\nif (s_cert_file == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"You must specify a certificate file for the server to use\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nif ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nstore = SSL_CTX_get_cert_store(ctx);\\r\\nX509_STORE_set_flags(store, vflags);\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (!no_dhe)\\r\\n{\\r\\nDH *dh=NULL;\\r\\nif (dhfile)\\r\\ndh = load_dh_param(dhfile);\\r\\nelse if (s_cert_file)\\r\\ndh = load_dh_param(s_cert_file);\\r\\nif (dh != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Setting temp DH parameters\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Using default temp DH parameters\\n\");\\r\\ndh=get_dh512();\\r\\n}\\r\\n(void)BIO_flush(bio_s_out);\\r\\nSSL_CTX_set_tmp_dh(ctx,dh);\\r\\nDH_free(dh);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (!no_ecdhe)\\r\\n{\\r\\nEC_KEY *ecdh=NULL;\\r\\nif (named_curve)\\r\\n{\\r\\nint nid = OBJ_sn2nid(named_curve);\\r\\nif (nid == 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"unknown curve name (%s)\\n\",\\r\\nnamed_curve);\\r\\ngoto end;\\r\\n}\\r\\necdh = EC_KEY_new_by_curve_name(nid);\\r\\nif (ecdh == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"unable to create curve (%s)\\n\",\\r\\nnamed_curve);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (ecdh != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Setting temp ECDH parameters\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Using default temp ECDH parameters\\n\");\\r\\necdh = EC_KEY_new_by_curve_name(NID_sect163r2);\\r\\nif (ecdh == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"unable to create curve (sect163r2)\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n(void)BIO_flush(bio_s_out);\\r\\nSSL_CTX_set_tmp_ecdh(ctx,ecdh);\\r\\nEC_KEY_free(ecdh);\\r\\n}\\r\\n#endif\\r\\nif (!set_cert_key_stuff(ctx,s_cert,s_key))\\r\\ngoto end;\\r\\nif (s_dcert != NULL)\\r\\n{\\r\\nif (!set_cert_key_stuff(ctx,s_dcert,s_dkey))\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n#if 1\\r\\nif (!no_tmp_rsa)\\r\\nSSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);\\r\\n#else\\r\\nif (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx))\\r\\n{\\r\\nRSA *rsa;\\r\\nBIO_printf(bio_s_out,\"Generating temp (512 bit) RSA key...\");\\r\\nBIO_flush(bio_s_out);\\r\\nrsa=RSA_generate_key(512,RSA_F4,NULL);\\r\\nif (!SSL_CTX_set_tmp_rsa(ctx,rsa))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nRSA_free(rsa);\\r\\nBIO_printf(bio_s_out,\"\\n\");\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\nif (cipher != NULL)\\r\\nif(!SSL_CTX_set_cipher_list(ctx,cipher)) {\\r\\nBIO_printf(bio_err,\"error setting cipher list\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nSSL_CTX_set_verify(ctx,s_server_verify,verify_callback);\\r\\nSSL_CTX_set_session_id_context(ctx,(void*)&s_server_session_id_context,\\r\\nsizeof s_server_session_id_context);\\r\\nif (CAfile != NULL)\\r\\nSSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nif (www)\\r\\ndo_server(port,sock_type,&accept_socket,www_body, context);\\r\\nelse\\r\\ndo_server(port,sock_type,&accept_socket,sv_body, context);\\r\\nprint_stats(bio_s_out,ctx);\\r\\nret=0;\\r\\nend:\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (s_cert)\\r\\nX509_free(s_cert);\\r\\nif (s_dcert)\\r\\nX509_free(s_dcert);\\r\\nif (s_key)\\r\\nEVP_PKEY_free(s_key);\\r\\nif (s_dkey)\\r\\nEVP_PKEY_free(s_dkey);\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\nif (dpass)\\r\\nOPENSSL_free(dpass);\\r\\nif (bio_s_out != NULL)\\r\\n{\\r\\nBIO_free(bio_s_out);\\r\\nbio_s_out=NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void print_stats(BIO *bio, SSL_CTX *ssl_ctx)\\r\\n{\\r\\nBIO_printf(bio,\"%4ld items in the session cache\\n\",\\r\\nSSL_CTX_sess_number(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld client connects (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld client renegotiates (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld client connects that finished\\n\",\\r\\nSSL_CTX_sess_connect_good(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld server accepts (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld server renegotiates (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld server accepts that finished\\n\",\\r\\nSSL_CTX_sess_accept_good(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld session cache hits\\n\",SSL_CTX_sess_hits(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld session cache misses\\n\",SSL_CTX_sess_misses(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld session cache timeouts\\n\",SSL_CTX_sess_timeouts(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld callback cache hits\\n\",SSL_CTX_sess_cb_hits(ssl_ctx));\\r\\nBIO_printf(bio,\"%4ld cache full overflows (%ld allowed)\\n\",\\r\\nSSL_CTX_sess_cache_full(ssl_ctx),\\r\\nSSL_CTX_sess_get_cache_size(ssl_ctx));\\r\\n}\\r\\nstatic int sv_body(char *hostname, int s, unsigned char *context)\\r\\n{\\r\\nchar *buf=NULL;\\r\\nfd_set readfds;\\r\\nint ret=1,width;\\r\\nint k,i;\\r\\nunsigned long l;\\r\\nSSL *con=NULL;\\r\\nBIO *sbio;\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\\r\\nstruct timeval tv;\\r\\n#endif\\r\\nif ((buf=OPENSSL_malloc(bufsize)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio)\\r\\n{\\r\\nunsigned long sl=1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (con == NULL) {\\r\\ncon=SSL_new(ctx);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif ((con->kssl_ctx = kssl_ctx_new()) != NULL)\\r\\n{\\r\\nkssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE,\\r\\nKRB5SVC);\\r\\nkssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB,\\r\\nKRB5KEYTAB);\\r\\n}\\r\\n#endif\\r\\nif(context)\\r\\nSSL_set_session_id_context(con, context,\\r\\nstrlen((char *)context));\\r\\n}\\r\\nSSL_clear(con);\\r\\nif (SSL_version(con) == DTLS1_VERSION)\\r\\n{\\r\\nstruct timeval timeout;\\r\\nsbio=BIO_new_dgram(s,BIO_NOCLOSE);\\r\\nif ( enable_timeouts)\\r\\n{\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_RCV_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_SND_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\\r\\n}\\r\\nif ( mtu > 0)\\r\\n{\\r\\nSSL_set_options(con, SSL_OP_NO_QUERY_MTU);\\r\\nSSL_set_mtu(con, mtu);\\r\\n}\\r\\nelse\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\\r\\nSSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);\\r\\n}\\r\\nelse\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (s_nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_accept_state(con);\\r\\nif (s_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(SSL_get_rbio(con),bio_dump_callback);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);\\r\\n}\\r\\nif (s_msg)\\r\\n{\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_s_out);\\r\\n}\\r\\nwidth=s+1;\\r\\nfor (;;)\\r\\n{\\r\\nint read_from_terminal;\\r\\nint read_from_sslcon;\\r\\nread_from_terminal = 0;\\r\\nread_from_sslcon = SSL_pending(con);\\r\\nif (!read_from_sslcon)\\r\\n{\\r\\nFD_ZERO(&readfds);\\r\\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE)\\r\\nFD_SET(fileno(stdin),&readfds);\\r\\n#endif\\r\\nFD_SET(s,&readfds);\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni=select(width,(void *)&readfds,NULL,NULL,&tv);\\r\\nif((i < 0) || (!i && !_kbhit() ) )continue;\\r\\nif(_kbhit())\\r\\nread_from_terminal = 1;\\r\\n#else\\r\\ni=select(width,(void *)&readfds,NULL,NULL,NULL);\\r\\nif (i <= 0) continue;\\r\\nif (FD_ISSET(fileno(stdin),&readfds))\\r\\nread_from_terminal = 1;\\r\\n#endif\\r\\nif (FD_ISSET(s,&readfds))\\r\\nread_from_sslcon = 1;\\r\\n}\\r\\nif (read_from_terminal)\\r\\n{\\r\\nif (s_crlf)\\r\\n{\\r\\nint j, lf_num;\\r\\ni=read(fileno(stdin), buf, bufsize/2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (buf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i-1; j >= 0; j--)\\r\\n{\\r\\nbuf[j+lf_num] = buf[j];\\r\\nif (buf[j] == '\\n')\\r\\n{\\r\\nlf_num--;\\r\\ni++;\\r\\nbuf[j+lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n}\\r\\nelse\\r\\ni=read(fileno(stdin),buf,bufsize);\\r\\nif (!s_quiet)\\r\\n{\\r\\nif ((i <= 0) || (buf[0] == 'Q'))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nSHUTDOWN(s);\\r\\nclose_accept_socket();\\r\\nret= -11;\\r\\ngoto err;\\r\\n}\\r\\nif ((i <= 0) || (buf[0] == 'q'))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nif (SSL_version(con) != DTLS1_VERSION)\\r\\nSHUTDOWN(s);\\r\\ngoto err;\\r\\n}\\r\\nif ((buf[0] == 'r') &&\\r\\n((buf[1] == '\\n') || (buf[1] == '\\r')))\\r\\n{\\r\\nSSL_renegotiate(con);\\r\\ni=SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\",i);\\r\\ni=0;\\r\\ncontinue;\\r\\n}\\r\\nif ((buf[0] == 'R') &&\\r\\n((buf[1] == '\\n') || (buf[1] == '\\r')))\\r\\n{\\r\\nSSL_set_verify(con,\\r\\nSSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,NULL);\\r\\nSSL_renegotiate(con);\\r\\ni=SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\",i);\\r\\ni=0;\\r\\ncontinue;\\r\\n}\\r\\nif (buf[0] == 'P')\\r\\n{\\r\\nstatic const char *str=\"Lets print some clear text\\n\";\\r\\nBIO_write(SSL_get_wbio(con),str,strlen(str));\\r\\n}\\r\\nif (buf[0] == 'S')\\r\\n{\\r\\nprint_stats(bio_s_out,SSL_get_SSL_CTX(con));\\r\\n}\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf,buf,i);\\r\\n#endif\\r\\nl=k=0;\\r\\nfor (;;)\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static count=0; if (++count == 100) { count=0; SSL_renegotiate(con); } }\\r\\n#endif\\r\\nk=SSL_write(con,&(buf[l]),(unsigned int)i);\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_s_out,\"Write BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out,\"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret=1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\nl+=k;\\r\\ni-=k;\\r\\nif (i <= 0) break;\\r\\n}\\r\\n}\\r\\nif (read_from_sslcon)\\r\\n{\\r\\nif (!SSL_is_init_finished(con))\\r\\n{\\r\\ni=init_ssl_connection(con);\\r\\nif (i < 0)\\r\\n{\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nagain:\\r\\ni=SSL_read(con,(char *)buf,bufsize);\\r\\nswitch (SSL_get_error(con,i))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(buf,buf,i);\\r\\n#endif\\r\\nwrite(fileno(stdout),buf,\\r\\n(unsigned int)i);\\r\\nif (SSL_pending(con)) goto again;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_s_out,\"Read BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out,\"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret=1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nBIO_printf(bio_s_out,\"shutting down SSL\\n\");\\r\\n#if 1\\r\\nSSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(con);\\r\\n#endif\\r\\nif (con != NULL) SSL_free(con);\\r\\nBIO_printf(bio_s_out,\"CONNECTION CLOSED\\n\");\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,bufsize);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void close_accept_socket(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"shutdown accept socket\\n\");\\r\\nif (accept_socket >= 0)\\r\\n{\\r\\nSHUTDOWN2(accept_socket);\\r\\n}\\r\\n}\\r\\nstatic int init_ssl_connection(SSL *con)\\r\\n{\\r\\nint i;\\r\\nconst char *str;\\r\\nX509 *peer;\\r\\nlong verify_error;\\r\\nMS_STATIC char buf[BUFSIZ];\\r\\nif ((i=SSL_accept(con)) <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(i))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DELAY\\n\");\\r\\nreturn(1);\\r\\n}\\r\\nBIO_printf(bio_err,\"ERROR\\n\");\\r\\nverify_error=SSL_get_verify_result(con);\\r\\nif (verify_error != X509_V_OK)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\n}\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nPEM_write_bio_SSL_SESSION(bio_s_out,SSL_get_session(con));\\r\\npeer=SSL_get_peer_certificate(con);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Client certificate\\n\");\\r\\nPEM_write_bio_X509(bio_s_out,peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer),buf,sizeof buf);\\r\\nBIO_printf(bio_s_out,\"subject=%s\\n\",buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer),buf,sizeof buf);\\r\\nBIO_printf(bio_s_out,\"issuer=%s\\n\",buf);\\r\\nX509_free(peer);\\r\\n}\\r\\nif (SSL_get_shared_ciphers(con,buf,sizeof buf) != NULL)\\r\\nBIO_printf(bio_s_out,\"Shared ciphers:%s\\n\",buf);\\r\\nstr=SSL_CIPHER_get_name(SSL_get_current_cipher(con));\\r\\nBIO_printf(bio_s_out,\"CIPHER is %s\\n\",(str != NULL)?str:\"(NONE)\");\\r\\nif (con->hit) BIO_printf(bio_s_out,\"Reused session-id\\n\");\\r\\nif (SSL_ctrl(con,SSL_CTRL_GET_FLAGS,0,NULL) &\\r\\nTLS1_FLAGS_TLS_PADDING_BUG)\\r\\nBIO_printf(bio_s_out,\"Peer has incorrect TLSv1 block padding\\n\");\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (con->kssl_ctx->client_princ != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Kerberos peer principal is %s\\n\",\\r\\ncon->kssl_ctx->client_princ);\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nstatic DH *load_dh_param(const char *dhfile)\\r\\n{\\r\\nDH *ret=NULL;\\r\\nBIO *bio;\\r\\nif ((bio=BIO_new_file(dhfile,\"r\")) == NULL)\\r\\ngoto err;\\r\\nret=PEM_read_bio_DHparams(bio,NULL,NULL,NULL);\\r\\nerr:\\r\\nif (bio != NULL) BIO_free(bio);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int www_body(char *hostname, int s, unsigned char *context)\\r\\n{\\r\\nchar *buf=NULL;\\r\\nint ret=1;\\r\\nint i,j,k,blank,dot;\\r\\nstruct stat st_buf;\\r\\nSSL *con;\\r\\nSSL_CIPHER *c;\\r\\nBIO *io,*ssl_bio,*sbio;\\r\\nlong total_bytes;\\r\\nbuf=OPENSSL_malloc(bufsize);\\r\\nif (buf == NULL) return(0);\\r\\nio=BIO_new(BIO_f_buffer());\\r\\nssl_bio=BIO_new(BIO_f_ssl());\\r\\nif ((io == NULL) || (ssl_bio == NULL)) goto err;\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio)\\r\\n{\\r\\nunsigned long sl=1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (!BIO_set_write_buffer_size(io,bufsize)) goto err;\\r\\nif ((con=SSL_new(ctx)) == NULL) goto err;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif ((con->kssl_ctx = kssl_ctx_new()) != NULL)\\r\\n{\\r\\nkssl_ctx_setstring(con->kssl_ctx, KSSL_SERVICE, KRB5SVC);\\r\\nkssl_ctx_setstring(con->kssl_ctx, KSSL_KEYTAB, KRB5KEYTAB);\\r\\n}\\r\\n#endif\\r\\nif(context) SSL_set_session_id_context(con, context,\\r\\nstrlen((char *)context));\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (s_nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_accept_state(con);\\r\\nBIO_set_ssl(ssl_bio,con,BIO_CLOSE);\\r\\nBIO_push(io,ssl_bio);\\r\\n#ifdef CHARSET_EBCDIC\\r\\nio = BIO_push(BIO_new(BIO_f_ebcdic_filter()),io);\\r\\n#endif\\r\\nif (s_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(SSL_get_rbio(con),bio_dump_callback);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);\\r\\n}\\r\\nif (s_msg)\\r\\n{\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_s_out);\\r\\n}\\r\\nblank=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (hack)\\r\\n{\\r\\ni=SSL_accept(con);\\r\\nswitch (SSL_get_error(con,i))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\ncontinue;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\nSSL_renegotiate(con);\\r\\nSSL_write(con,NULL,0);\\r\\n}\\r\\ni=BIO_gets(io,buf,bufsize-1);\\r\\nif (i < 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\n{\\r\\nif (!s_quiet)\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"read R BLOCK\\n\");\\r\\n#if defined(OPENSSL_SYS_NETWARE)\\r\\ndelay(1000);\\r\\n#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)\\r\\nsleep(1);\\r\\n#endif\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif ( ((www == 1) && (strncmp(\"GET \",buf,4) == 0)) ||\\r\\n((www == 2) && (strncmp(\"GET /stats \",buf,10) == 0)))\\r\\n{\\r\\nchar *p;\\r\\nX509 *peer;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nstatic const char *space=\" \";\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nBIO_puts(io,\"<HTML><BODY BGCOLOR=\\\"#ffffff\\\">\\n\");\\r\\nBIO_puts(io,\"<pre>\\n\");\\r\\nBIO_puts(io,\"\\n\");\\r\\nfor (i=0; i<local_argc; i++)\\r\\n{\\r\\nBIO_puts(io,local_argv[i]);\\r\\nBIO_write(io,\" \",1);\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\nBIO_printf(io,\"Ciphers supported in s_server binary\\n\");\\r\\nsk=SSL_get_ciphers(con);\\r\\nj=sk_SSL_CIPHER_num(sk);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nBIO_printf(io,\"%-11s:%-25s\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nif ((((i+1)%2) == 0) && (i+1 != j))\\r\\nBIO_puts(io,\"\\n\");\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\np=SSL_get_shared_ciphers(con,buf,bufsize);\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO_printf(io,\"---\\nCiphers common between both SSL end points:\\n\");\\r\\nj=i=0;\\r\\nwhile (*p)\\r\\n{\\r\\nif (*p == ':')\\r\\n{\\r\\nBIO_write(io,space,26-j);\\r\\ni++;\\r\\nj=0;\\r\\nBIO_write(io,((i%3)?\" \":\"\\n\"),1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_write(io,p,1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\n}\\r\\nBIO_printf(io,((con->hit)\\r\\n?\"---\\nReused, \"\\r\\n:\"---\\nNew, \"));\\r\\nc=SSL_get_current_cipher(con);\\r\\nBIO_printf(io,\"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nSSL_SESSION_print(io,SSL_get_session(con));\\r\\nBIO_printf(io,\"---\\n\");\\r\\nprint_stats(io,SSL_get_SSL_CTX(con));\\r\\nBIO_printf(io,\"---\\n\");\\r\\npeer=SSL_get_peer_certificate(con);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(io,\"Client certificate\\n\");\\r\\nX509_print(io,peer);\\r\\nPEM_write_bio_X509(io,peer);\\r\\n}\\r\\nelse\\r\\nBIO_puts(io,\"no client certificate available\\n\");\\r\\nBIO_puts(io,\"</BODY></HTML>\\r\\n\\r\\n\");\\r\\nbreak;\\r\\n}\\r\\nelse if ((www == 2 || www == 3)\\r\\n&& (strncmp(\"GET /\",buf,5) == 0))\\r\\n{\\r\\nBIO *file;\\r\\nchar *p,*e;\\r\\nstatic const char *text=\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\";\\r\\np= &(buf[5]);\\r\\ndot = 1;\\r\\nfor (e=p; *e != '\\0'; e++)\\r\\n{\\r\\nif (e[0] == ' ')\\r\\nbreak;\\r\\nswitch (dot)\\r\\n{\\r\\ncase 1:\\r\\ndot = (e[0] == '.') ? 2 : 0;\\r\\nbreak;\\r\\ncase 2:\\r\\ndot = (e[0] == '.') ? 3 : 0;\\r\\nbreak;\\r\\ncase 3:\\r\\ndot = (e[0] == '/') ? -1 : 0;\\r\\nbreak;\\r\\n}\\r\\nif (dot == 0)\\r\\ndot = (e[0] == '/') ? 1 : 0;\\r\\n}\\r\\ndot = (dot == 3) || (dot == -1);\\r\\nif (*e == '\\0')\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' is an invalid file name\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\n*e='\\0';\\r\\nif (dot)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' contains '..' reference\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\nif (*p == '/')\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' is an invalid path\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\n#if 0\\r\\nif (e[-1] == '/')\\r\\nstrcat(p,\"index.html\");\\r\\n#endif\\r\\nif (stat(p,&st_buf) < 0)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"Error accessing '%s'\\r\\n\",p);\\r\\nERR_print_errors(io);\\r\\nbreak;\\r\\n}\\r\\nif (S_ISDIR(st_buf.st_mode))\\r\\n{\\r\\n#if 0\\r\\nstrcat(p,\"/index.html\");\\r\\n#else\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' is a directory\\r\\n\",p);\\r\\nbreak;\\r\\n#endif\\r\\n}\\r\\nif ((file=BIO_new_file(p,\"r\")) == NULL)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"Error opening '%s'\\r\\n\",p);\\r\\nERR_print_errors(io);\\r\\nbreak;\\r\\n}\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"FILE:%s\\n\",p);\\r\\nif (www == 2)\\r\\n{\\r\\ni=strlen(p);\\r\\nif ( ((i > 5) && (strcmp(&(p[i-5]),\".html\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i-4]),\".php\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i-4]),\".htm\") == 0)))\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nelse\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\");\\r\\n}\\r\\ntotal_bytes=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(file,buf,bufsize);\\r\\nif (i <= 0) break;\\r\\n#ifdef RENEG\\r\\ntotal_bytes+=i;\\r\\nfprintf(stderr,\"%d\\n\",i);\\r\\nif (total_bytes > 3*1024)\\r\\n{\\r\\ntotal_bytes=0;\\r\\nfprintf(stderr,\"RENEGOTIATE\\n\");\\r\\nSSL_renegotiate(con);\\r\\n}\\r\\n#endif\\r\\nfor (j=0; j<i; )\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static count=0; if (++count == 13) { SSL_renegotiate(con); } }\\r\\n#endif\\r\\nk=BIO_write(io,&(buf[j]),i-j);\\r\\nif (k <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\ngoto write_error;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"rwrite W BLOCK\\n\");\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nj+=k;\\r\\n}\\r\\n}\\r\\n}\\r\\nwrite_error:\\r\\nBIO_free(file);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=(int)BIO_flush(io);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nend:\\r\\n#if 1\\r\\nSSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\n#endif\\r\\nerr:\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nif (buf != NULL) OPENSSL_free(buf);\\r\\nif (io != NULL) BIO_free_all(io);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)\\r\\n{\\r\\nBIGNUM *bn = NULL;\\r\\nstatic RSA *rsa_tmp=NULL;\\r\\nif (!rsa_tmp && ((bn = BN_new()) == NULL))\\r\\nBIO_printf(bio_err,\"Allocation error in generating RSA key\\n\");\\r\\nif (!rsa_tmp && bn)\\r\\n{\\r\\nif (!s_quiet)\\r\\n{\\r\\nBIO_printf(bio_err,\"Generating temp (%d bit) RSA key...\",keylength);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nif(!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||\\r\\n!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))\\r\\n{\\r\\nif(rsa_tmp) RSA_free(rsa_tmp);\\r\\nrsa_tmp = NULL;\\r\\n}\\r\\nif (!s_quiet)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nBN_free(bn);\\r\\n}\\r\\nreturn(rsa_tmp);\\r\\n}\\r\\nstatic int generate_session_id(const SSL *ssl, unsigned char *id,\\r\\nunsigned int *id_len)\\r\\n{\\r\\nunsigned int count = 0;\\r\\ndo {\\r\\nRAND_pseudo_bytes(id, *id_len);\\r\\nmemcpy(id, session_id_prefix,\\r\\n(strlen(session_id_prefix) < *id_len) ?\\r\\nstrlen(session_id_prefix) : *id_len);\\r\\n}\\r\\nwhile(SSL_has_matching_session_id(ssl, id, *id_len) &&\\r\\n(++count < MAX_SESSION_ID_ATTEMPTS));\\r\\nif(count >= MAX_SESSION_ID_ATTEMPTS)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_lib_c", "target": 0, "func": "int EVP_PKEY_bits(EVP_PKEY *pkey)\\r\\n{\\r\\nif (0)\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (pkey->type == EVP_PKEY_RSA)\\r\\nreturn(BN_num_bits(pkey->pkey.rsa->n));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nelse if (pkey->type == EVP_PKEY_DSA)\\r\\nreturn(BN_num_bits(pkey->pkey.dsa->p));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nelse if (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nBIGNUM *order = BN_new();\\r\\nconst EC_GROUP *group;\\r\\nint ret;\\r\\nif (!order)\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 0;\\r\\n}\\r\\ngroup = EC_KEY_get0_group(pkey->pkey.ec);\\r\\nif (!EC_GROUP_get_order(group, order, NULL))\\r\\n{\\r\\nERR_clear_error();\\r\\nreturn 0;\\r\\n}\\r\\nret = BN_num_bits(order);\\r\\nBN_free(order);\\r\\nreturn ret;\\r\\n}\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_size(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey == NULL)\\r\\nreturn(0);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nreturn(RSA_size(pkey->pkey.rsa));\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nreturn(DSA_size(pkey->pkey.dsa));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\nreturn(ECDSA_size(pkey->pkey.ec));\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nint ret=pkey->save_parameters;\\r\\nif (mode >= 0)\\r\\npkey->save_parameters=mode;\\r\\nreturn(ret);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nint ret = pkey->save_parameters;\\r\\nif (mode >= 0)\\r\\npkey->save_parameters = mode;\\r\\nreturn(ret);\\r\\n}\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\\r\\n{\\r\\nif (to->type != from->type)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_DIFFERENT_KEY_TYPES);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_missing_parameters(from))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (to->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIGNUM *a;\\r\\nif ((a=BN_dup(from->pkey.dsa->p)) == NULL) goto err;\\r\\nif (to->pkey.dsa->p != NULL) BN_free(to->pkey.dsa->p);\\r\\nto->pkey.dsa->p=a;\\r\\nif ((a=BN_dup(from->pkey.dsa->q)) == NULL) goto err;\\r\\nif (to->pkey.dsa->q != NULL) BN_free(to->pkey.dsa->q);\\r\\nto->pkey.dsa->q=a;\\r\\nif ((a=BN_dup(from->pkey.dsa->g)) == NULL) goto err;\\r\\nif (to->pkey.dsa->g != NULL) BN_free(to->pkey.dsa->g);\\r\\nto->pkey.dsa->g=a;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (to->type == EVP_PKEY_EC)\\r\\n{\\r\\nEC_GROUP *group = EC_GROUP_dup(EC_KEY_get0_group(from->pkey.ec));\\r\\nif (group == NULL)\\r\\ngoto err;\\r\\nif (EC_KEY_set_group(to->pkey.ec, group) == 0)\\r\\ngoto err;\\r\\nEC_GROUP_free(group);\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nDSA *dsa;\\r\\ndsa=pkey->pkey.dsa;\\r\\nif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nif (EC_KEY_get0_group(pkey->pkey.ec) == NULL)\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif ((a->type == EVP_PKEY_DSA) && (b->type == EVP_PKEY_DSA))\\r\\n{\\r\\nif ( BN_cmp(a->pkey.dsa->p,b->pkey.dsa->p) ||\\r\\nBN_cmp(a->pkey.dsa->q,b->pkey.dsa->q) ||\\r\\nBN_cmp(a->pkey.dsa->g,b->pkey.dsa->g))\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (a->type == EVP_PKEY_EC && b->type == EVP_PKEY_EC)\\r\\n{\\r\\nconst EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec),\\r\\n*group_b = EC_KEY_get0_group(b->pkey.ec);\\r\\nif (EC_GROUP_cmp(group_a, group_b, NULL))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nint EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (a->type != b->type)\\r\\nreturn -1;\\r\\nif (EVP_PKEY_cmp_parameters(a, b) == 0)\\r\\nreturn 0;\\r\\nswitch (a->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0\\r\\n|| BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif (BN_cmp(b->pkey.dsa->pub_key,a->pkey.dsa->pub_key) != 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\n{\\r\\nint r;\\r\\nconst EC_GROUP *group = EC_KEY_get0_group(b->pkey.ec);\\r\\nconst EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec),\\r\\n*pb = EC_KEY_get0_public_key(b->pkey.ec);\\r\\nr = EC_POINT_cmp(group, pa, pb, NULL);\\r\\nif (r != 0)\\r\\n{\\r\\nif (r == 1)\\r\\nreturn 0;\\r\\nelse\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase EVP_PKEY_DH:\\r\\nreturn -2;\\r\\n#endif\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_new(void)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nret=(EVP_PKEY *)OPENSSL_malloc(sizeof(EVP_PKEY));\\r\\nif (ret == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->type=EVP_PKEY_NONE;\\r\\nret->references=1;\\r\\nret->pkey.ptr=NULL;\\r\\nret->attributes=NULL;\\r\\nret->save_parameters=1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)\\r\\n{\\r\\nif (pkey == NULL) return(0);\\r\\nif (pkey->pkey.ptr != NULL)\\r\\nEVP_PKEY_free_it(pkey);\\r\\npkey->type=EVP_PKEY_type(type);\\r\\npkey->save_type=type;\\r\\npkey->pkey.ptr=key;\\r\\nreturn(key != NULL);\\r\\n}\\r\\nint EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_RSA(pkey, key);\\r\\nif(ret)\\r\\nRSA_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nRSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey)\\r\\n{\\r\\nif(pkey->type != EVP_PKEY_RSA) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_RSA, EVP_R_EXPECTING_AN_RSA_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nRSA_up_ref(pkey->pkey.rsa);\\r\\nreturn pkey->pkey.rsa;\\r\\n}\\r\\nint EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_DSA(pkey, key);\\r\\nif(ret)\\r\\nDSA_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nDSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)\\r\\n{\\r\\nif(pkey->type != EVP_PKEY_DSA) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_DSA, EVP_R_EXPECTING_A_DSA_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nDSA_up_ref(pkey->pkey.dsa);\\r\\nreturn pkey->pkey.dsa;\\r\\n}\\r\\nint EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_EC_KEY(pkey,key);\\r\\nif (ret)\\r\\nEC_KEY_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->type != EVP_PKEY_EC)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_KEY_up_ref(pkey->pkey.ec);\\r\\nreturn pkey->pkey.ec;\\r\\n}\\r\\nint EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_DH(pkey, key);\\r\\nif(ret)\\r\\nDH_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nDH *EVP_PKEY_get1_DH(EVP_PKEY *pkey)\\r\\n{\\r\\nif(pkey->type != EVP_PKEY_DH) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_DH, EVP_R_EXPECTING_A_DH_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nDH_up_ref(pkey->pkey.dh);\\r\\nreturn pkey->pkey.dh;\\r\\n}\\r\\nint EVP_PKEY_type(int type)\\r\\n{\\r\\nswitch (type)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\ncase EVP_PKEY_RSA2:\\r\\nreturn(EVP_PKEY_RSA);\\r\\ncase EVP_PKEY_DSA:\\r\\ncase EVP_PKEY_DSA1:\\r\\ncase EVP_PKEY_DSA2:\\r\\ncase EVP_PKEY_DSA3:\\r\\ncase EVP_PKEY_DSA4:\\r\\nreturn(EVP_PKEY_DSA);\\r\\ncase EVP_PKEY_DH:\\r\\nreturn(EVP_PKEY_DH);\\r\\ncase EVP_PKEY_EC:\\r\\nreturn(EVP_PKEY_EC);\\r\\ndefault:\\r\\nreturn(NID_undef);\\r\\n}\\r\\n}\\r\\nvoid EVP_PKEY_free(EVP_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"EVP_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nEVP_PKEY_free_it(x);\\r\\nif (x->attributes)\\r\\nsk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\\r\\nOPENSSL_free(x);\\r\\n}\\r\\nstatic void EVP_PKEY_free_it(EVP_PKEY *x)\\r\\n{\\r\\nswitch (x->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\ncase EVP_PKEY_RSA2:\\r\\nRSA_free(x->pkey.rsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\ncase EVP_PKEY_DSA2:\\r\\ncase EVP_PKEY_DSA3:\\r\\ncase EVP_PKEY_DSA4:\\r\\nDSA_free(x->pkey.dsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nEC_KEY_free(x->pkey.ec);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase EVP_PKEY_DH:\\r\\nDH_free(x->pkey.dh);\\r\\nbreak;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_aep_err_c", "target": 0, "func": "static void ERR_load_AEPHK_strings(void)\\r\\n{\\r\\nif (AEPHK_lib_error_code == 0)\\r\\nAEPHK_lib_error_code=ERR_get_next_error_library();\\r\\nif (AEPHK_error_init)\\r\\n{\\r\\nAEPHK_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(AEPHK_lib_error_code,AEPHK_str_functs);\\r\\nERR_load_strings(AEPHK_lib_error_code,AEPHK_str_reasons);\\r\\n#endif\\r\\n#ifdef AEPHK_LIB_NAME\\r\\nAEPHK_lib_name->error = ERR_PACK(AEPHK_lib_error_code,0,0);\\r\\nERR_load_strings(0,AEPHK_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_AEPHK_strings(void)\\r\\n{\\r\\nif (AEPHK_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(AEPHK_lib_error_code,AEPHK_str_functs);\\r\\nERR_unload_strings(AEPHK_lib_error_code,AEPHK_str_reasons);\\r\\n#endif\\r\\n#ifdef AEPHK_LIB_NAME\\r\\nERR_unload_strings(0,AEPHK_lib_name);\\r\\n#endif\\r\\nAEPHK_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_AEPHK_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (AEPHK_lib_error_code == 0)\\r\\nAEPHK_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(AEPHK_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_lbuf_c", "target": 0, "func": "BIO_METHOD *BIO_f_linebuffer(void)\\r\\n{\\r\\nreturn(&methods_linebuffer);\\r\\n}\\r\\nstatic int linebuffer_new(BIO *bi)\\r\\n{\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nctx=(BIO_LINEBUFFER_CTX *)OPENSSL_malloc(sizeof(BIO_LINEBUFFER_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->obuf=(char *)OPENSSL_malloc(DEFAULT_LINEBUFFER_SIZE);\\r\\nif (ctx->obuf == NULL) { OPENSSL_free(ctx); return(0); }\\r\\nctx->obuf_size=DEFAULT_LINEBUFFER_SIZE;\\r\\nctx->obuf_len=0;\\r\\nbi->init=1;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int linebuffer_free(BIO *a)\\r\\n{\\r\\nBIO_LINEBUFFER_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_LINEBUFFER_CTX *)a->ptr;\\r\\nif (b->obuf != NULL) OPENSSL_free(b->obuf);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int linebuffer_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out == NULL) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int linebuffer_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint i,num=0,foundnl;\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx=(BIO_LINEBUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nBIO_clear_retry_flags(b);\\r\\ndo\\r\\n{\\r\\nconst char *p;\\r\\nfor(p = in; p < in + inl && *p != '\\n'; p++)\\r\\n;\\r\\nif (*p == '\\n')\\r\\n{\\r\\np++;\\r\\nfoundnl = 1;\\r\\n}\\r\\nelse\\r\\nfoundnl = 0;\\r\\nwhile ((foundnl || p - in > ctx->obuf_size - ctx->obuf_len)\\r\\n&& ctx->obuf_len > 0)\\r\\n{\\r\\nint orig_olen = ctx->obuf_len;\\r\\ni = ctx->obuf_size - ctx->obuf_len;\\r\\nif (p - in > 0)\\r\\n{\\r\\nif (i >= p - in)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),\\r\\nin,p - in);\\r\\nctx->obuf_len += p - in;\\r\\ninl -= p - in;\\r\\nnum += p - in;\\r\\nin = p;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),\\r\\nin,i);\\r\\nctx->obuf_len += i;\\r\\ninl -= i;\\r\\nin += i;\\r\\nnum += i;\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \"<*<\", 3);\\r\\n#endif\\r\\ni=BIO_write(b->next_bio,\\r\\nctx->obuf, ctx->obuf_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nctx->obuf_len = orig_olen;\\r\\nBIO_copy_next_retry(b);\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < ctx->obuf_len)\\r\\nmemmove(ctx->obuf, ctx->obuf + i,\\r\\nctx->obuf_len - i);\\r\\nctx->obuf_len-=i;\\r\\n}\\r\\nif ((foundnl || p - in > ctx->obuf_size) && p - in > 0)\\r\\n{\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \"<*<\", 3);\\r\\n#endif\\r\\ni=BIO_write(b->next_bio,in,p - in);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nnum+=i;\\r\\nin+=i;\\r\\ninl-=i;\\r\\n}\\r\\n}\\r\\nwhile(foundnl && inl > 0);\\r\\nif (inl > 0)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]), in, inl);\\r\\nctx->obuf_len += inl;\\r\\nnum += inl;\\r\\n}\\r\\nreturn num;\\r\\n}\\r\\nstatic long linebuffer_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nlong ret=1;\\r\\nchar *p;\\r\\nint r;\\r\\nint obs;\\r\\nctx=(BIO_LINEBUFFER_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->obuf_len=0;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)ctx->obuf_len;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=(long)ctx->obuf_len;\\r\\nif (ret == 0)\\r\\n{\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nobs=(int)num;\\r\\np=ctx->obuf;\\r\\nif ((obs > DEFAULT_LINEBUFFER_SIZE) && (obs != ctx->obuf_size))\\r\\n{\\r\\np=(char *)OPENSSL_malloc((int)num);\\r\\nif (p == NULL)\\r\\ngoto malloc_error;\\r\\n}\\r\\nif (ctx->obuf != p)\\r\\n{\\r\\nif (ctx->obuf_len > obs)\\r\\n{\\r\\nctx->obuf_len = obs;\\r\\n}\\r\\nmemcpy(p, ctx->obuf, ctx->obuf_len);\\r\\nOPENSSL_free(ctx->obuf);\\r\\nctx->obuf=p;\\r\\nctx->obuf_size=obs;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nif (ctx->obuf_len <= 0)\\r\\n{\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->obuf_len > 0)\\r\\n{\\r\\nr=BIO_write(b->next_bio,\\r\\nctx->obuf, ctx->obuf_len);\\r\\n#if 0\\r\\nfprintf(stderr,\"FLUSH %3d -> %3d\\n\",ctx->obuf_len,r);\\r\\n#endif\\r\\nBIO_copy_next_retry(b);\\r\\nif (r <= 0) return((long)r);\\r\\nif (r < ctx->obuf_len)\\r\\nmemmove(ctx->obuf, ctx->obuf + r,\\r\\nctx->obuf_len - r);\\r\\nctx->obuf_len-=r;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->obuf_len=0;\\r\\nret=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif ( !BIO_set_write_buffer_size(dbio,ctx->obuf_size))\\r\\nret=0;\\r\\nbreak;\\r\\ndefault:\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\nmalloc_error:\\r\\nBIOerr(BIO_F_LINEBUFFER_CTRL,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nstatic long linebuffer_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int linebuffer_gets(BIO *b, char *buf, int size)\\r\\n{\\r\\nif (b->next_bio == NULL) return(0);\\r\\nreturn(BIO_gets(b->next_bio,buf,size));\\r\\n}\\r\\nstatic int linebuffer_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn(linebuffer_write(b,str,strlen(str)));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_kssl_c", "target": 0, "func": "void\\r\\nload_krb5_dll(void)\\r\\n{\\r\\nHANDLE hKRB5_32;\\r\\nkrb5_loaded++;\\r\\nhKRB5_32 = LoadLibrary(TEXT(\"KRB5_32\"));\\r\\nif (!hKRB5_32)\\r\\nreturn;\\r\\n(FARPROC) p_krb5_free_data_contents =\\r\\nGetProcAddress( hKRB5_32, \"krb5_free_data_contents\" );\\r\\n(FARPROC) p_krb5_free_context =\\r\\nGetProcAddress( hKRB5_32, \"krb5_free_context\" );\\r\\n(FARPROC) p_krb5_auth_con_free =\\r\\nGetProcAddress( hKRB5_32, \"krb5_auth_con_free\" );\\r\\n(FARPROC) p_krb5_free_principal =\\r\\nGetProcAddress( hKRB5_32, \"krb5_free_principal\" );\\r\\n(FARPROC) p_krb5_mk_req_extended =\\r\\nGetProcAddress( hKRB5_32, \"krb5_mk_req_extended\" );\\r\\n(FARPROC) p_krb5_get_credentials =\\r\\nGetProcAddress( hKRB5_32, \"krb5_get_credentials\" );\\r\\n(FARPROC) p_krb5_cc_get_principal =\\r\\nGetProcAddress( hKRB5_32, \"krb5_cc_get_principal\" );\\r\\n(FARPROC) p_krb5_cc_default =\\r\\nGetProcAddress( hKRB5_32, \"krb5_cc_default\" );\\r\\n(FARPROC) p_krb5_sname_to_principal =\\r\\nGetProcAddress( hKRB5_32, \"krb5_sname_to_principal\" );\\r\\n(FARPROC) p_krb5_init_context =\\r\\nGetProcAddress( hKRB5_32, \"krb5_init_context\" );\\r\\n(FARPROC) p_krb5_free_ticket =\\r\\nGetProcAddress( hKRB5_32, \"krb5_free_ticket\" );\\r\\n(FARPROC) p_krb5_rd_req =\\r\\nGetProcAddress( hKRB5_32, \"krb5_rd_req\" );\\r\\n(FARPROC) p_krb5_principal_compare =\\r\\nGetProcAddress( hKRB5_32, \"krb5_principal_compare\" );\\r\\n(FARPROC) p_krb5_decrypt_tkt_part =\\r\\nGetProcAddress( hKRB5_32, \"krb5_decrypt_tkt_part\" );\\r\\n(FARPROC) p_krb5_timeofday =\\r\\nGetProcAddress( hKRB5_32, \"krb5_timeofday\" );\\r\\n(FARPROC) p_krb5_rc_default =\\r\\nGetProcAddress( hKRB5_32, \"krb5_rc_default\" );\\r\\n(FARPROC) p_krb5_rc_initialize =\\r\\nGetProcAddress( hKRB5_32, \"krb5_rc_initialize\" );\\r\\n(FARPROC) p_krb5_rc_get_lifespan =\\r\\nGetProcAddress( hKRB5_32, \"krb5_rc_get_lifespan\" );\\r\\n(FARPROC) p_krb5_rc_destroy =\\r\\nGetProcAddress( hKRB5_32, \"krb5_rc_destroy\" );\\r\\n(FARPROC) p_krb5_kt_default =\\r\\nGetProcAddress( hKRB5_32, \"krb5_kt_default\" );\\r\\n(FARPROC) p_krb5_kt_resolve =\\r\\nGetProcAddress( hKRB5_32, \"krb5_kt_resolve\" );\\r\\n(FARPROC) p_krb5_auth_con_init =\\r\\nGetProcAddress( hKRB5_32, \"krb5_auth_con_init\" );\\r\\n(FARPROC) p_valid_cksumtype =\\r\\nGetProcAddress( hKRB5_32, \"valid_cksumtype\" );\\r\\n(FARPROC) p_krb5_checksum_size =\\r\\nGetProcAddress( hKRB5_32, \"krb5_checksum_size\" );\\r\\n(FARPROC) p_krb5_kt_free_entry =\\r\\nGetProcAddress( hKRB5_32, \"krb5_kt_free_entry\" );\\r\\n(FARPROC) p_krb5_auth_con_setrcache =\\r\\nGetProcAddress( hKRB5_32, \"krb5_auth_con_setrcache\" );\\r\\n(FARPROC) p_krb5_get_server_rcache =\\r\\nGetProcAddress( hKRB5_32, \"krb5_get_server_rcache\" );\\r\\n(FARPROC) p_krb5_auth_con_getrcache =\\r\\nGetProcAddress( hKRB5_32, \"krb5_auth_con_getrcache\" );\\r\\n(FARPROC) p_krb5_kt_close =\\r\\nGetProcAddress( hKRB5_32, \"krb5_kt_close\" );\\r\\n(FARPROC) p_krb5_kt_get_entry =\\r\\nGetProcAddress( hKRB5_32, \"krb5_kt_get_entry\" );\\r\\n}\\r\\nvoid\\r\\nkssl_krb5_free_data_contents(krb5_context CO, krb5_data * data)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_free_data_contents )\\r\\np_krb5_free_data_contents(CO,data);\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_mk_req_extended (krb5_context CO,\\r\\nkrb5_auth_context * pACO,\\r\\nkrb5_const krb5_flags F,\\r\\nkrb5_data * pD1,\\r\\nkrb5_creds * pC,\\r\\nkrb5_data * pD2)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_mk_req_extended )\\r\\nreturn(p_krb5_mk_req_extended(CO,pACO,F,pD1,pC,pD2));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_auth_con_init(krb5_context CO,\\r\\nkrb5_auth_context * pACO)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_auth_con_init )\\r\\nreturn(p_krb5_auth_con_init(CO,pACO));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_auth_con_free (krb5_context CO,\\r\\nkrb5_auth_context ACO)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_auth_con_free )\\r\\nreturn(p_krb5_auth_con_free(CO,ACO));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_get_credentials(krb5_context CO,\\r\\nkrb5_const krb5_flags F,\\r\\nkrb5_ccache CC,\\r\\nkrb5_creds * pCR,\\r\\nkrb5_creds ** ppCR)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_get_credentials )\\r\\nreturn(p_krb5_get_credentials(CO,F,CC,pCR,ppCR));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_sname_to_principal(krb5_context CO,\\r\\nkrb5_const char * pC1,\\r\\nkrb5_const char * pC2,\\r\\nkrb5_int32 I,\\r\\nkrb5_principal * pPR)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_sname_to_principal )\\r\\nreturn(p_krb5_sname_to_principal(CO,pC1,pC2,I,pPR));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_cc_default(krb5_context CO,\\r\\nkrb5_ccache * pCC)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_cc_default )\\r\\nreturn(p_krb5_cc_default(CO,pCC));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_init_context(krb5_context * pCO)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_init_context )\\r\\nreturn(p_krb5_init_context(pCO));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nvoid\\r\\nkssl_krb5_free_context(krb5_context CO)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_free_context )\\r\\np_krb5_free_context(CO);\\r\\n}\\r\\nvoid\\r\\nkssl_krb5_free_principal(krb5_context c, krb5_principal p)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_free_principal )\\r\\np_krb5_free_principal(c,p);\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_kt_resolve(krb5_context con,\\r\\nkrb5_const char * sz,\\r\\nkrb5_keytab * kt)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_kt_resolve )\\r\\nreturn(p_krb5_kt_resolve(con,sz,kt));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_kt_default(krb5_context con,\\r\\nkrb5_keytab * kt)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_kt_default )\\r\\nreturn(p_krb5_kt_default(con,kt));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_free_ticket(krb5_context con,\\r\\nkrb5_ticket * kt)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_free_ticket )\\r\\nreturn(p_krb5_free_ticket(con,kt));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_rd_req(krb5_context con, krb5_auth_context * pacon,\\r\\nkrb5_const krb5_data * data,\\r\\nkrb5_const_principal princ, krb5_keytab keytab,\\r\\nkrb5_flags * flags, krb5_ticket ** pptkt)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_rd_req )\\r\\nreturn(p_krb5_rd_req(con,pacon,data,princ,keytab,flags,pptkt));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_boolean\\r\\nkrb5_principal_compare(krb5_context con, krb5_const_principal princ1,\\r\\nkrb5_const_principal princ2)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_principal_compare )\\r\\nreturn(p_krb5_principal_compare(con,princ1,princ2));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_decrypt_tkt_part(krb5_context con, krb5_const krb5_keyblock *keys,\\r\\nkrb5_ticket *ticket)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_decrypt_tkt_part )\\r\\nreturn(p_krb5_decrypt_tkt_part(con,keys,ticket));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_timeofday(krb5_context con, krb5_int32 *timeret)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_timeofday )\\r\\nreturn(p_krb5_timeofday(con,timeret));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_rc_default(krb5_context con, krb5_rcache *rc)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_rc_default )\\r\\nreturn(p_krb5_rc_default(con,rc));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_rc_initialize(krb5_context con, krb5_rcache rc, krb5_deltat lifespan)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_rc_initialize )\\r\\nreturn(p_krb5_rc_initialize(con, rc, lifespan));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_rc_get_lifespan(krb5_context con, krb5_rcache rc, krb5_deltat *lifespanp)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_rc_get_lifespan )\\r\\nreturn(p_krb5_rc_get_lifespan(con, rc, lifespanp));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_rc_destroy(krb5_context con, krb5_rcache rc)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_rc_destroy )\\r\\nreturn(p_krb5_rc_destroy(con, rc));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nsize_t\\r\\nkrb5_checksum_size(krb5_context context,krb5_cksumtype ctype)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_checksum_size )\\r\\nreturn(p_krb5_checksum_size(context, ctype));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_boolean\\r\\nvalid_cksumtype(krb5_cksumtype ctype)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_valid_cksumtype )\\r\\nreturn(p_valid_cksumtype(ctype));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkrb5_kt_free_entry(krb5_context con,krb5_keytab_entry * entry)\\r\\n{\\r\\nif (!krb5_loaded)\\r\\nload_krb5_dll();\\r\\nif ( p_krb5_kt_free_entry )\\r\\nreturn(p_krb5_kt_free_entry(con,entry));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_cc_get_principal\\r\\n(krb5_context context, krb5_ccache cache,\\r\\nkrb5_principal *principal)\\r\\n{\\r\\nif ( p_krb5_cc_get_principal )\\r\\nreturn(p_krb5_cc_get_principal(context,cache,principal));\\r\\nelse\\r\\nreturn(krb5_x\\r\\n((cache)->ops->get_princ,(context, cache, principal)));\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_auth_con_setrcache(krb5_context con, krb5_auth_context acon,\\r\\nkrb5_rcache rcache)\\r\\n{\\r\\nif ( p_krb5_auth_con_setrcache )\\r\\nreturn(p_krb5_auth_con_setrcache(con,acon,rcache));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_get_server_rcache(krb5_context con, krb5_const krb5_data * data,\\r\\nkrb5_rcache * rcache)\\r\\n{\\r\\nif ( p_krb5_get_server_rcache )\\r\\nreturn(p_krb5_get_server_rcache(con,data,rcache));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_auth_con_getrcache(krb5_context con, krb5_auth_context acon,\\r\\nkrb5_rcache * prcache)\\r\\n{\\r\\nif ( p_krb5_auth_con_getrcache )\\r\\nreturn(p_krb5_auth_con_getrcache(con,acon, prcache));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_kt_close(krb5_context context, krb5_keytab keytab)\\r\\n{\\r\\nif ( p_krb5_kt_close )\\r\\nreturn(p_krb5_kt_close(context,keytab));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_krb5_kt_get_entry(krb5_context context, krb5_keytab keytab,\\r\\nkrb5_const_principal principal, krb5_kvno vno,\\r\\nkrb5_enctype enctype, krb5_keytab_entry *entry)\\r\\n{\\r\\nif ( p_krb5_kt_get_entry )\\r\\nreturn(p_krb5_kt_get_entry(context,keytab,principal,vno,enctype,entry));\\r\\nelse\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nchar\\r\\n*kstring(char *string)\\r\\n{\\r\\nstatic char *null = \"[NULL]\";\\r\\nreturn ((string == NULL)? null: string);\\r\\n}\\r\\nconst EVP_CIPHER *\\r\\nkssl_map_enc(krb5_enctype enctype)\\r\\n{\\r\\nswitch (enctype)\\r\\n{\\r\\ncase ENCTYPE_DES_HMAC_SHA1:\\r\\ncase ENCTYPE_DES_CBC_CRC:\\r\\ncase ENCTYPE_DES_CBC_MD4:\\r\\ncase ENCTYPE_DES_CBC_MD5:\\r\\ncase ENCTYPE_DES_CBC_RAW:\\r\\nreturn EVP_des_cbc();\\r\\nbreak;\\r\\ncase ENCTYPE_DES3_CBC_SHA1:\\r\\ncase ENCTYPE_DES3_CBC_SHA:\\r\\ncase ENCTYPE_DES3_CBC_RAW:\\r\\nreturn EVP_des_ede3_cbc();\\r\\nbreak;\\r\\ndefault: return NULL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint kssl_test_confound(unsigned char *p)\\r\\n{\\r\\nint len = 2;\\r\\nint xx = 0, yy = 0;\\r\\nif (*p++ != 0x62) return 0;\\r\\nif (*p > 0x82) return 0;\\r\\nswitch(*p) {\\r\\ncase 0x82: p++; xx = (*p++ << 8); xx += *p++; break;\\r\\ncase 0x81: p++; xx = *p++; break;\\r\\ncase 0x80: return 0;\\r\\ndefault: xx = *p++; break;\\r\\n}\\r\\nif (*p++ != 0x30) return 0;\\r\\nif (*p > 0x82) return 0;\\r\\nswitch(*p) {\\r\\ncase 0x82: p++; len+=2; yy = (*p++ << 8); yy += *p++; break;\\r\\ncase 0x81: p++; len++; yy = *p++; break;\\r\\ncase 0x80: return 0;\\r\\ndefault: yy = *p++; break;\\r\\n}\\r\\nreturn (xx - len == yy)? 1: 0;\\r\\n}\\r\\nsize_t *populate_cksumlens(void)\\r\\n{\\r\\nint i, j, n;\\r\\nstatic size_t *cklens = NULL;\\r\\n#ifdef KRB5_MIT_OLD11\\r\\nn = krb5_max_cksum;\\r\\n#else\\r\\nn = 0x0010;\\r\\n#endif\\r\\n#ifdef KRB5CHECKAUTH\\r\\nif (!cklens && !(cklens = (size_t *) calloc(sizeof(int),n+1))) return NULL;\\r\\nfor (i=0; i < n; i++) {\\r\\nif (!valid_cksumtype(i)) continue;\\r\\nfor (j=0; j < n; j++) {\\r\\nif (cklens[j] == 0) {\\r\\ncklens[j] = krb5_checksum_size(NULL,i);\\r\\nbreak;\\r\\n}\\r\\nif (cklens[j] == krb5_checksum_size(NULL,i)) {\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn cklens;\\r\\n}\\r\\nunsigned char *kssl_skip_confound(krb5_enctype etype, unsigned char *a)\\r\\n{\\r\\nint i, conlen;\\r\\nsize_t cklen;\\r\\nstatic size_t *cksumlens = NULL;\\r\\nunsigned char *test_auth;\\r\\nconlen = (etype)? 8: 0;\\r\\nif (!cksumlens && !(cksumlens = populate_cksumlens())) return NULL;\\r\\nfor (i=0; (cklen = cksumlens[i]) != 0; i++)\\r\\n{\\r\\ntest_auth = a + conlen + cklen;\\r\\nif (kssl_test_confound(test_auth)) return test_auth;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid\\r\\nkssl_err_set(KSSL_ERR *kssl_err, int reason, char *text)\\r\\n{\\r\\nif (kssl_err == NULL) return;\\r\\nkssl_err->reason = reason;\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX, text);\\r\\nreturn;\\r\\n}\\r\\nvoid\\r\\nprint_krb5_data(char *label, krb5_data *kdata)\\r\\n{\\r\\nint i;\\r\\nprintf(\"%s[%d] \", label, kdata->length);\\r\\nfor (i=0; i < (int)kdata->length; i++)\\r\\n{\\r\\nif (0 && isprint((int) kdata->data[i]))\\r\\nprintf( \"%c \", kdata->data[i]);\\r\\nelse\\r\\nprintf( \"%02x \", (unsigned char) kdata->data[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nvoid\\r\\nprint_krb5_authdata(char *label, krb5_authdata **adata)\\r\\n{\\r\\nif (adata == NULL)\\r\\n{\\r\\nprintf(\"%s, authdata==0\\n\", label);\\r\\nreturn;\\r\\n}\\r\\nprintf(\"%s [%p]\\n\", label, (void *)adata);\\r\\n#if 0\\r\\n{\\r\\nint i;\\r\\nprintf(\"%s[at%d:%d] \", label, adata->ad_type, adata->length);\\r\\nfor (i=0; i < adata->length; i++)\\r\\n{\\r\\nprintf((isprint(adata->contents[i]))? \"%c \": \"%02x\",\\r\\nadata->contents[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\n}\\r\\nvoid\\r\\nprint_krb5_keyblock(char *label, krb5_keyblock *keyblk)\\r\\n{\\r\\nint i;\\r\\nif (keyblk == NULL)\\r\\n{\\r\\nprintf(\"%s, keyblk==0\\n\", label);\\r\\nreturn;\\r\\n}\\r\\n#ifdef KRB5_HEIMDAL\\r\\nprintf(\"%s\\n\\t[et%d:%d]: \", label, keyblk->keytype,\\r\\nkeyblk->keyvalue->length);\\r\\nfor (i=0; i < (int)keyblk->keyvalue->length; i++)\\r\\n{\\r\\nprintf(\"%02x\",(unsigned char *)(keyblk->keyvalue->contents)[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n#else\\r\\nprintf(\"%s\\n\\t[et%d:%d]: \", label, keyblk->enctype, keyblk->length);\\r\\nfor (i=0; i < (int)keyblk->length; i++)\\r\\n{\\r\\nprintf(\"%02x\",keyblk->contents[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\n}\\r\\nvoid\\r\\nprint_krb5_princ(char *label, krb5_principal_data *princ)\\r\\n{\\r\\nint i, ui, uj;\\r\\nprintf(\"%s principal Realm: \", label);\\r\\nif (princ == NULL) return;\\r\\nfor (ui=0; ui < (int)princ->realm.length; ui++) putchar(princ->realm.data[ui]);\\r\\nprintf(\" (nametype %d) has %d strings:\\n\", princ->type,princ->length);\\r\\nfor (i=0; i < (int)princ->length; i++)\\r\\n{\\r\\nprintf(\"\\t%d [%d]: \", i, princ->data[i].length);\\r\\nfor (uj=0; uj < (int)princ->data[i].length; uj++) {\\r\\nputchar(princ->data[i].data[uj]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_cget_tkt( KSSL_CTX *kssl_ctx,\\r\\nkrb5_data **enc_ticketp,\\r\\nkrb5_data *authenp,\\r\\nKSSL_ERR *kssl_err)\\r\\n{\\r\\nkrb5_error_code krb5rc = KRB5KRB_ERR_GENERIC;\\r\\nkrb5_context krb5context = NULL;\\r\\nkrb5_auth_context krb5auth_context = NULL;\\r\\nkrb5_ccache krb5ccdef = NULL;\\r\\nkrb5_creds krb5creds, *krb5credsp = NULL;\\r\\nkrb5_data krb5_app_req;\\r\\nkssl_err_set(kssl_err, 0, \"\");\\r\\nmemset((char *)&krb5creds, 0, sizeof(krb5creds));\\r\\nif (!kssl_ctx)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"No kssl_ctx defined.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nelse if (!kssl_ctx->service_host)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"kssl_ctx service_host undefined.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_init_context(&krb5context)) != 0)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text,KSSL_ERR_MAX,\\r\\n\"krb5_init_context() fails: %d\\n\", krb5rc);\\r\\nkssl_err->reason = SSL_R_KRB5_C_INIT;\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_sname_to_principal(krb5context,\\r\\nkssl_ctx->service_host,\\r\\n(kssl_ctx->service_name)? kssl_ctx->service_name: KRB5SVC,\\r\\nKRB5_NT_SRV_HST, &krb5creds.server)) != 0)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text,KSSL_ERR_MAX,\\r\\n\"krb5_sname_to_principal() fails for %s/%s\\n\",\\r\\nkssl_ctx->service_host,\\r\\n(kssl_ctx->service_name)? kssl_ctx->service_name:\\r\\nKRB5SVC);\\r\\nkssl_err->reason = SSL_R_KRB5_C_INIT;\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_cc_default(krb5context, &krb5ccdef)) != 0)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_CC_PRINC,\\r\\n\"krb5_cc_default fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_cc_get_principal(krb5context, krb5ccdef,\\r\\n&krb5creds.client)) != 0)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_CC_PRINC,\\r\\n\"krb5_cc_get_principal() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_get_credentials(krb5context, 0, krb5ccdef,\\r\\n&krb5creds, &krb5credsp)) != 0)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_GET_CRED,\\r\\n\"krb5_get_credentials() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\n*enc_ticketp = &krb5credsp->ticket;\\r\\n#ifdef KRB5_HEIMDAL\\r\\nkssl_ctx->enctype = krb5credsp->session.keytype;\\r\\n#else\\r\\nkssl_ctx->enctype = krb5credsp->keyblock.enctype;\\r\\n#endif\\r\\nkrb5rc = KRB5KRB_ERR_GENERIC;\\r\\nkrb5_app_req.length = 0;\\r\\nif (authenp)\\r\\n{\\r\\nkrb5_data krb5in_data;\\r\\nconst unsigned char *p;\\r\\nlong arlen;\\r\\nKRB5_APREQBODY *ap_req;\\r\\nauthenp->length = 0;\\r\\nkrb5in_data.data = NULL;\\r\\nkrb5in_data.length = 0;\\r\\nif ((krb5rc = krb5_mk_req_extended(krb5context,\\r\\n&krb5auth_context, 0, &krb5in_data, krb5credsp,\\r\\n&krb5_app_req)) != 0)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_MK_REQ,\\r\\n\"krb5_mk_req_extended() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\narlen = krb5_app_req.length;\\r\\np = (unsigned char *)krb5_app_req.data;\\r\\nap_req = (KRB5_APREQBODY *) d2i_KRB5_APREQ(NULL, &p, arlen);\\r\\nif (ap_req)\\r\\n{\\r\\nauthenp->length = i2d_KRB5_ENCDATA(\\r\\nap_req->authenticator, NULL);\\r\\nif (authenp->length &&\\r\\n(authenp->data = malloc(authenp->length)))\\r\\n{\\r\\nunsigned char *adp = (unsigned char *)authenp->data;\\r\\nauthenp->length = i2d_KRB5_ENCDATA(\\r\\nap_req->authenticator, &adp);\\r\\n}\\r\\n}\\r\\nif (ap_req) KRB5_APREQ_free((KRB5_APREQ *) ap_req);\\r\\nif (krb5_app_req.length)\\r\\nkssl_krb5_free_data_contents(krb5context,&krb5_app_req);\\r\\n}\\r\\n#ifdef KRB5_HEIMDAL\\r\\nif (kssl_ctx_setkey(kssl_ctx, &krb5credsp->session))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_INIT,\\r\\n\"kssl_ctx_setkey() fails.\\n\");\\r\\n}\\r\\n#else\\r\\nif (kssl_ctx_setkey(kssl_ctx, &krb5credsp->keyblock))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_C_INIT,\\r\\n\"kssl_ctx_setkey() fails.\\n\");\\r\\n}\\r\\n#endif\\r\\nelse krb5rc = 0;\\r\\nerr:\\r\\n#ifdef KSSL_DEBUG\\r\\nkssl_ctx_show(kssl_ctx);\\r\\n#endif\\r\\nif (krb5creds.client) krb5_free_principal(krb5context,\\r\\nkrb5creds.client);\\r\\nif (krb5creds.server) krb5_free_principal(krb5context,\\r\\nkrb5creds.server);\\r\\nif (krb5auth_context) krb5_auth_con_free(krb5context,\\r\\nkrb5auth_context);\\r\\nif (krb5context) krb5_free_context(krb5context);\\r\\nreturn (krb5rc);\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_TKT2tkt( krb5_context krb5context,\\r\\nKRB5_TKTBODY *asn1ticket,\\r\\nkrb5_ticket **krb5ticket,\\r\\nKSSL_ERR *kssl_err )\\r\\n{\\r\\nkrb5_error_code krb5rc = KRB5KRB_ERR_GENERIC;\\r\\nkrb5_ticket *new5ticket = NULL;\\r\\nASN1_GENERALSTRING *gstr_svc, *gstr_host;\\r\\n*krb5ticket = NULL;\\r\\nif (asn1ticket == NULL || asn1ticket->realm == NULL ||\\r\\nasn1ticket->sname == NULL ||\\r\\nsk_ASN1_GENERALSTRING_num(asn1ticket->sname->namestring) < 2)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"Null field in asn1ticket.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nif ((new5ticket = (krb5_ticket *) calloc(1, sizeof(krb5_ticket)))==NULL)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"Unable to allocate new krb5_ticket.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\nreturn ENOMEM;\\r\\n}\\r\\ngstr_svc = sk_ASN1_GENERALSTRING_value(asn1ticket->sname->namestring, 0);\\r\\ngstr_host = sk_ASN1_GENERALSTRING_value(asn1ticket->sname->namestring, 1);\\r\\nif ((krb5rc = kssl_build_principal_2(krb5context,\\r\\n&new5ticket->server,\\r\\nasn1ticket->realm->length, (char *)asn1ticket->realm->data,\\r\\ngstr_svc->length, (char *)gstr_svc->data,\\r\\ngstr_host->length, (char *)gstr_host->data)) != 0)\\r\\n{\\r\\nfree(new5ticket);\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"Error building ticket server principal.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\nreturn krb5rc;\\r\\n}\\r\\nkrb5_princ_type(krb5context, new5ticket->server) =\\r\\nasn1ticket->sname->nametype->data[0];\\r\\nnew5ticket->enc_part.enctype = asn1ticket->encdata->etype->data[0];\\r\\nnew5ticket->enc_part.kvno = asn1ticket->encdata->kvno->data[0];\\r\\nnew5ticket->enc_part.ciphertext.length =\\r\\nasn1ticket->encdata->cipher->length;\\r\\nif ((new5ticket->enc_part.ciphertext.data =\\r\\ncalloc(1, asn1ticket->encdata->cipher->length)) == NULL)\\r\\n{\\r\\nfree(new5ticket);\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"Error allocating cipher in krb5ticket.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\nreturn KRB5KRB_ERR_GENERIC;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(new5ticket->enc_part.ciphertext.data,\\r\\nasn1ticket->encdata->cipher->data,\\r\\nasn1ticket->encdata->cipher->length);\\r\\n}\\r\\n*krb5ticket = new5ticket;\\r\\nreturn 0;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_sget_tkt( KSSL_CTX *kssl_ctx,\\r\\nkrb5_data *indata,\\r\\nkrb5_ticket_times *ttimes,\\r\\nKSSL_ERR *kssl_err )\\r\\n{\\r\\nkrb5_error_code krb5rc = KRB5KRB_ERR_GENERIC;\\r\\nstatic krb5_context krb5context = NULL;\\r\\nstatic krb5_auth_context krb5auth_context = NULL;\\r\\nkrb5_ticket *krb5ticket = NULL;\\r\\nKRB5_TKTBODY *asn1ticket = NULL;\\r\\nconst unsigned char *p;\\r\\nkrb5_keytab krb5keytab = NULL;\\r\\nkrb5_keytab_entry kt_entry;\\r\\nkrb5_principal krb5server;\\r\\nkrb5_rcache rcache = NULL;\\r\\nkssl_err_set(kssl_err, 0, \"\");\\r\\nif (!kssl_ctx)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"No kssl_ctx defined.\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"in kssl_sget_tkt(%s)\\n\", kstring(kssl_ctx->service_name));\\r\\n#endif\\r\\nif (!krb5context && (krb5rc = krb5_init_context(&krb5context)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_init_context() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (krb5auth_context &&\\r\\n(krb5rc = krb5_auth_con_free(krb5context, krb5auth_context)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_auth_con_free() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nelse krb5auth_context = NULL;\\r\\nif (!krb5auth_context &&\\r\\n(krb5rc = krb5_auth_con_init(krb5context, &krb5auth_context)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_auth_con_init() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_auth_con_getrcache(krb5context, krb5auth_context,\\r\\n&rcache)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_auth_con_getrcache() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_sname_to_principal(krb5context, NULL,\\r\\n(kssl_ctx->service_name)? kssl_ctx->service_name: KRB5SVC,\\r\\nKRB5_NT_SRV_HST, &krb5server)) != 0)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_sname_to_principal() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (rcache == NULL)\\r\\n{\\r\\nif ((krb5rc = krb5_get_server_rcache(krb5context,\\r\\nkrb5_princ_component(krb5context, krb5server, 0),\\r\\n&rcache)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_get_server_rcache() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((krb5rc = krb5_auth_con_setrcache(krb5context, krb5auth_context, rcache)))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_auth_con_setrcache() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (kssl_ctx->keytab_file)\\r\\n{\\r\\nkrb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\\r\\n&krb5keytab);\\r\\nif (krb5rc)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_kt_resolve() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nkrb5rc = krb5_kt_default(krb5context,&krb5keytab);\\r\\nif (krb5rc)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"krb5_kt_default() fails.\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\np = (unsigned char *)indata->data;\\r\\nif ((asn1ticket = (KRB5_TKTBODY *) d2i_KRB5_TICKET(NULL, &p,\\r\\n(long) indata->length)) == NULL)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"d2i_KRB5_TICKET() ASN.1 decode failure.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = kssl_TKT2tkt(krb5context, asn1ticket, &krb5ticket,\\r\\nkssl_err)) != 0)\\r\\n{\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"Error converting ASN.1 ticket to krb5_ticket.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\ngoto err;\\r\\n}\\r\\nif (! krb5_principal_compare(krb5context, krb5server,\\r\\nkrb5ticket->server)) {\\r\\nkrb5rc = KRB5_PRINC_NOMATCH;\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"server principal != ticket principal\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_kt_get_entry(krb5context, krb5keytab,\\r\\nkrb5ticket->server, krb5ticket->enc_part.kvno,\\r\\nkrb5ticket->enc_part.enctype, &kt_entry)) != 0) {\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"krb5_kt_get_entry() fails with %x.\\n\", krb5rc);\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = krb5_decrypt_tkt_part(krb5context, &kt_entry.key,\\r\\nkrb5ticket)) != 0) {\\r\\nBIO_snprintf(kssl_err->text, KSSL_ERR_MAX,\\r\\n\"krb5_decrypt_tkt_part() failed.\\n\");\\r\\nkssl_err->reason = SSL_R_KRB5_S_RD_REQ;\\r\\ngoto err;\\r\\n}\\r\\nelse {\\r\\nkrb5_kt_free_entry(krb5context, &kt_entry);\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nint i; krb5_address **paddr = krb5ticket->enc_part2->caddrs;\\r\\nprintf(\"Decrypted ticket fields:\\n\");\\r\\nprintf(\"\\tflags: %X, transit-type: %X\",\\r\\nkrb5ticket->enc_part2->flags,\\r\\nkrb5ticket->enc_part2->transited.tr_type);\\r\\nprint_krb5_data(\"\\ttransit-data: \",\\r\\n&(krb5ticket->enc_part2->transited.tr_contents));\\r\\nprintf(\"\\tcaddrs: %p, authdata: %p\\n\",\\r\\nkrb5ticket->enc_part2->caddrs,\\r\\nkrb5ticket->enc_part2->authorization_data);\\r\\nif (paddr)\\r\\n{\\r\\nprintf(\"\\tcaddrs:\\n\");\\r\\nfor (i=0; paddr[i] != NULL; i++)\\r\\n{\\r\\nkrb5_data d;\\r\\nd.length=paddr[i]->length;\\r\\nd.data=paddr[i]->contents;\\r\\nprint_krb5_data(\"\\t\\tIP: \", &d);\\r\\n}\\r\\n}\\r\\nprintf(\"\\tstart/auth/end times: %d / %d / %d\\n\",\\r\\nkrb5ticket->enc_part2->times.starttime,\\r\\nkrb5ticket->enc_part2->times.authtime,\\r\\nkrb5ticket->enc_part2->times.endtime);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nkrb5rc = KRB5_NO_TKT_SUPPLIED;\\r\\nif (!krb5ticket || !krb5ticket->enc_part2 ||\\r\\n!krb5ticket->enc_part2->client ||\\r\\n!krb5ticket->enc_part2->client->data ||\\r\\n!krb5ticket->enc_part2->session)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_BAD_TICKET,\\r\\n\"bad ticket from krb5_rd_req.\\n\");\\r\\n}\\r\\nelse if (kssl_ctx_setprinc(kssl_ctx, KSSL_CLIENT,\\r\\n&krb5ticket->enc_part2->client->realm,\\r\\nkrb5ticket->enc_part2->client->data,\\r\\nkrb5ticket->enc_part2->client->length))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_BAD_TICKET,\\r\\n\"kssl_ctx_setprinc() fails.\\n\");\\r\\n}\\r\\nelse if (kssl_ctx_setkey(kssl_ctx, krb5ticket->enc_part2->session))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_BAD_TICKET,\\r\\n\"kssl_ctx_setkey() fails.\\n\");\\r\\n}\\r\\nelse if (krb5ticket->enc_part2->flags & TKT_FLG_INVALID)\\r\\n{\\r\\nkrb5rc = KRB5KRB_AP_ERR_TKT_INVALID;\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_BAD_TICKET,\\r\\n\"invalid ticket from krb5_rd_req.\\n\");\\r\\n}\\r\\nelse krb5rc = 0;\\r\\nkssl_ctx->enctype = krb5ticket->enc_part.enctype;\\r\\nttimes->authtime = krb5ticket->enc_part2->times.authtime;\\r\\nttimes->starttime = krb5ticket->enc_part2->times.starttime;\\r\\nttimes->endtime = krb5ticket->enc_part2->times.endtime;\\r\\nttimes->renew_till = krb5ticket->enc_part2->times.renew_till;\\r\\nerr:\\r\\n#ifdef KSSL_DEBUG\\r\\nkssl_ctx_show(kssl_ctx);\\r\\n#endif\\r\\nif (asn1ticket) KRB5_TICKET_free((KRB5_TICKET *) asn1ticket);\\r\\nif (krb5keytab) krb5_kt_close(krb5context, krb5keytab);\\r\\nif (krb5ticket) krb5_free_ticket(krb5context, krb5ticket);\\r\\nif (krb5server) krb5_free_principal(krb5context, krb5server);\\r\\nreturn (krb5rc);\\r\\n}\\r\\nKSSL_CTX *\\r\\nkssl_ctx_new(void)\\r\\n{\\r\\nreturn ((KSSL_CTX *) calloc(1, sizeof(KSSL_CTX)));\\r\\n}\\r\\nKSSL_CTX *\\r\\nkssl_ctx_free(KSSL_CTX *kssl_ctx)\\r\\n{\\r\\nif (kssl_ctx == NULL) return kssl_ctx;\\r\\nif (kssl_ctx->key) OPENSSL_cleanse(kssl_ctx->key,\\r\\nkssl_ctx->length);\\r\\nif (kssl_ctx->key) free(kssl_ctx->key);\\r\\nif (kssl_ctx->client_princ) free(kssl_ctx->client_princ);\\r\\nif (kssl_ctx->service_host) free(kssl_ctx->service_host);\\r\\nif (kssl_ctx->service_name) free(kssl_ctx->service_name);\\r\\nif (kssl_ctx->keytab_file) free(kssl_ctx->keytab_file);\\r\\nfree(kssl_ctx);\\r\\nreturn (KSSL_CTX *) NULL;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_ctx_setprinc(KSSL_CTX *kssl_ctx, int which,\\r\\nkrb5_data *realm, krb5_data *entity, int nentities)\\r\\n{\\r\\nchar **princ;\\r\\nint length;\\r\\nint i;\\r\\nif (kssl_ctx == NULL || entity == NULL) return KSSL_CTX_ERR;\\r\\nswitch (which)\\r\\n{\\r\\ncase KSSL_CLIENT: princ = &kssl_ctx->client_princ; break;\\r\\ncase KSSL_SERVER: princ = &kssl_ctx->service_host; break;\\r\\ndefault: return KSSL_CTX_ERR; break;\\r\\n}\\r\\nif (*princ) free(*princ);\\r\\nlength = 0;\\r\\nfor (i=0; i < nentities; i++)\\r\\n{\\r\\nlength += entity[i].length;\\r\\n}\\r\\nlength += nentities-1;\\r\\nlength += ((realm)? realm->length + 2: 1);\\r\\nif ((*princ = calloc(1, length)) == NULL)\\r\\nreturn KSSL_CTX_ERR;\\r\\nelse\\r\\n{\\r\\nfor (i = 0; i < nentities; i++)\\r\\n{\\r\\nstrncat(*princ, entity[i].data, entity[i].length);\\r\\nif (i < nentities-1)\\r\\n{\\r\\nstrcat (*princ, \"/\");\\r\\n}\\r\\n}\\r\\nif (realm)\\r\\n{\\r\\nstrcat (*princ, \"@\");\\r\\n(void) strncat(*princ, realm->data, realm->length);\\r\\n}\\r\\n}\\r\\nreturn KSSL_CTX_OK;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_ctx_setstring(KSSL_CTX *kssl_ctx, int which, char *text)\\r\\n{\\r\\nchar **string;\\r\\nif (!kssl_ctx) return KSSL_CTX_ERR;\\r\\nswitch (which)\\r\\n{\\r\\ncase KSSL_SERVICE: string = &kssl_ctx->service_name; break;\\r\\ncase KSSL_SERVER: string = &kssl_ctx->service_host; break;\\r\\ncase KSSL_CLIENT: string = &kssl_ctx->client_princ; break;\\r\\ncase KSSL_KEYTAB: string = &kssl_ctx->keytab_file; break;\\r\\ndefault: return KSSL_CTX_ERR; break;\\r\\n}\\r\\nif (*string) free(*string);\\r\\nif (!text)\\r\\n{\\r\\n*string = '\\0';\\r\\nreturn KSSL_CTX_OK;\\r\\n}\\r\\nif ((*string = calloc(1, strlen(text) + 1)) == NULL)\\r\\nreturn KSSL_CTX_ERR;\\r\\nelse\\r\\nstrcpy(*string, text);\\r\\nreturn KSSL_CTX_OK;\\r\\n}\\r\\nkrb5_error_code\\r\\nkssl_ctx_setkey(KSSL_CTX *kssl_ctx, krb5_keyblock *session)\\r\\n{\\r\\nint length;\\r\\nkrb5_enctype enctype;\\r\\nkrb5_octet FAR *contents = NULL;\\r\\nif (!kssl_ctx) return KSSL_CTX_ERR;\\r\\nif (kssl_ctx->key)\\r\\n{\\r\\nOPENSSL_cleanse(kssl_ctx->key, kssl_ctx->length);\\r\\nfree(kssl_ctx->key);\\r\\n}\\r\\nif (session)\\r\\n{\\r\\n#ifdef KRB5_HEIMDAL\\r\\nlength = session->keyvalue->length;\\r\\nenctype = session->keytype;\\r\\ncontents = session->keyvalue->contents;\\r\\n#else\\r\\nlength = session->length;\\r\\nenctype = session->enctype;\\r\\ncontents = session->contents;\\r\\n#endif\\r\\nkssl_ctx->enctype = enctype;\\r\\nkssl_ctx->length = length;\\r\\n}\\r\\nelse\\r\\n{\\r\\nkssl_ctx->enctype = ENCTYPE_UNKNOWN;\\r\\nkssl_ctx->length = 0;\\r\\nreturn KSSL_CTX_OK;\\r\\n}\\r\\nif ((kssl_ctx->key =\\r\\n(krb5_octet FAR *) calloc(1, kssl_ctx->length)) == NULL)\\r\\n{\\r\\nkssl_ctx->length = 0;\\r\\nreturn KSSL_CTX_ERR;\\r\\n}\\r\\nelse\\r\\nmemcpy(kssl_ctx->key, contents, length);\\r\\nreturn KSSL_CTX_OK;\\r\\n}\\r\\nvoid\\r\\nkssl_ctx_show(KSSL_CTX *kssl_ctx)\\r\\n{\\r\\nint i;\\r\\nprintf(\"kssl_ctx: \");\\r\\nif (kssl_ctx == NULL)\\r\\n{\\r\\nprintf(\"NULL\\n\");\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\nprintf(\"%p\\n\", (void *)kssl_ctx);\\r\\nprintf(\"\\tservice:\\t%s\\n\",\\r\\n(kssl_ctx->service_name)? kssl_ctx->service_name: \"NULL\");\\r\\nprintf(\"\\tclient:\\t%s\\n\",\\r\\n(kssl_ctx->client_princ)? kssl_ctx->client_princ: \"NULL\");\\r\\nprintf(\"\\tserver:\\t%s\\n\",\\r\\n(kssl_ctx->service_host)? kssl_ctx->service_host: \"NULL\");\\r\\nprintf(\"\\tkeytab:\\t%s\\n\",\\r\\n(kssl_ctx->keytab_file)? kssl_ctx->keytab_file: \"NULL\");\\r\\nprintf(\"\\tkey [%d:%d]:\\t\",\\r\\nkssl_ctx->enctype, kssl_ctx->length);\\r\\nfor (i=0; i < kssl_ctx->length && kssl_ctx->key; i++)\\r\\n{\\r\\nprintf(\"%02x\", kssl_ctx->key[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\nreturn;\\r\\n}\\r\\nint\\r\\nkssl_keytab_is_available(KSSL_CTX *kssl_ctx)\\r\\n{\\r\\nkrb5_context krb5context = NULL;\\r\\nkrb5_keytab krb5keytab = NULL;\\r\\nkrb5_keytab_entry entry;\\r\\nkrb5_principal princ = NULL;\\r\\nkrb5_error_code krb5rc = KRB5KRB_ERR_GENERIC;\\r\\nint rc = 0;\\r\\nif ((krb5rc = krb5_init_context(&krb5context)))\\r\\nreturn(0);\\r\\nif (kssl_ctx->keytab_file)\\r\\n{\\r\\nkrb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\\r\\n&krb5keytab);\\r\\nif (krb5rc)\\r\\ngoto exit;\\r\\n}\\r\\nelse\\r\\n{\\r\\nkrb5rc = krb5_kt_default(krb5context,&krb5keytab);\\r\\nif (krb5rc)\\r\\ngoto exit;\\r\\n}\\r\\nkrb5rc = krb5_sname_to_principal(krb5context, NULL,\\r\\nkssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\\r\\nKRB5_NT_SRV_HST, &princ);\\r\\nkrb5rc = krb5_kt_get_entry(krb5context, krb5keytab,\\r\\nprinc,\\r\\n0 ,\\r\\n0 ,\\r\\n&entry);\\r\\nif ( krb5rc == KRB5_KT_NOTFOUND ) {\\r\\nrc = 1;\\r\\ngoto exit;\\r\\n} else if ( krb5rc )\\r\\ngoto exit;\\r\\nkrb5_kt_free_entry(krb5context, &entry);\\r\\nrc = 1;\\r\\nexit:\\r\\nif (krb5keytab) krb5_kt_close(krb5context, krb5keytab);\\r\\nif (princ) krb5_free_principal(krb5context, princ);\\r\\nif (krb5context) krb5_free_context(krb5context);\\r\\nreturn(rc);\\r\\n}\\r\\nint\\r\\nkssl_tgt_is_available(KSSL_CTX *kssl_ctx)\\r\\n{\\r\\nkrb5_error_code krb5rc = KRB5KRB_ERR_GENERIC;\\r\\nkrb5_context krb5context = NULL;\\r\\nkrb5_ccache krb5ccdef = NULL;\\r\\nkrb5_creds krb5creds, *krb5credsp = NULL;\\r\\nint rc = 0;\\r\\nmemset((char *)&krb5creds, 0, sizeof(krb5creds));\\r\\nif (!kssl_ctx)\\r\\nreturn(0);\\r\\nif (!kssl_ctx->service_host)\\r\\nreturn(0);\\r\\nif ((krb5rc = krb5_init_context(&krb5context)) != 0)\\r\\ngoto err;\\r\\nif ((krb5rc = krb5_sname_to_principal(krb5context,\\r\\nkssl_ctx->service_host,\\r\\n(kssl_ctx->service_name)? kssl_ctx->service_name: KRB5SVC,\\r\\nKRB5_NT_SRV_HST, &krb5creds.server)) != 0)\\r\\ngoto err;\\r\\nif ((krb5rc = krb5_cc_default(krb5context, &krb5ccdef)) != 0)\\r\\ngoto err;\\r\\nif ((krb5rc = krb5_cc_get_principal(krb5context, krb5ccdef,\\r\\n&krb5creds.client)) != 0)\\r\\ngoto err;\\r\\nif ((krb5rc = krb5_get_credentials(krb5context, 0, krb5ccdef,\\r\\n&krb5creds, &krb5credsp)) != 0)\\r\\ngoto err;\\r\\nrc = 1;\\r\\nerr:\\r\\n#ifdef KSSL_DEBUG\\r\\nkssl_ctx_show(kssl_ctx);\\r\\n#endif\\r\\nif (krb5creds.client) krb5_free_principal(krb5context, krb5creds.client);\\r\\nif (krb5creds.server) krb5_free_principal(krb5context, krb5creds.server);\\r\\nif (krb5context) krb5_free_context(krb5context);\\r\\nreturn(rc);\\r\\n}\\r\\nvoid kssl_krb5_free_data_contents(krb5_context context, krb5_data *data)\\r\\n{\\r\\n#ifdef KRB5_HEIMDAL\\r\\ndata->length = 0;\\r\\nif (data->data)\\r\\nfree(data->data);\\r\\n#elif defined(KRB5_MIT_OLD11)\\r\\nif (data->data) {\\r\\nkrb5_xfree(data->data);\\r\\ndata->data = 0;\\r\\n}\\r\\n#else\\r\\nkrb5_free_data_contents(NULL, data);\\r\\n#endif\\r\\n}\\r\\nstruct tm *k_gmtime(ASN1_GENERALIZEDTIME *gtime, struct tm *k_tm)\\r\\n{\\r\\nchar c, *p;\\r\\nif (!k_tm) return NULL;\\r\\nif (gtime == NULL || gtime->length < 14) return NULL;\\r\\nif (gtime->data == NULL) return NULL;\\r\\np = (char *)&gtime->data[14];\\r\\nc = *p; *p = '\\0'; p -= 2; k_tm->tm_sec = atoi(p); *(p+2) = c;\\r\\nc = *p; *p = '\\0'; p -= 2; k_tm->tm_min = atoi(p); *(p+2) = c;\\r\\nc = *p; *p = '\\0'; p -= 2; k_tm->tm_hour = atoi(p); *(p+2) = c;\\r\\nc = *p; *p = '\\0'; p -= 2; k_tm->tm_mday = atoi(p); *(p+2) = c;\\r\\nc = *p; *p = '\\0'; p -= 2; k_tm->tm_mon = atoi(p)-1; *(p+2) = c;\\r\\nc = *p; *p = '\\0'; p -= 4; k_tm->tm_year = atoi(p)-1900; *(p+4) = c;\\r\\nreturn k_tm;\\r\\n}\\r\\nkrb5_deltat get_rc_clockskew(krb5_context context)\\r\\n{\\r\\nkrb5_rcache rc;\\r\\nkrb5_deltat clockskew;\\r\\nif (krb5_rc_default(context, &rc)) return KSSL_CLOCKSKEW;\\r\\nif (krb5_rc_initialize(context, rc, 0)) return KSSL_CLOCKSKEW;\\r\\nif (krb5_rc_get_lifespan(context, rc, &clockskew)) {\\r\\nclockskew = KSSL_CLOCKSKEW;\\r\\n}\\r\\n(void) krb5_rc_destroy(context, rc);\\r\\nreturn clockskew;\\r\\n}\\r\\nkrb5_error_code kssl_validate_times( krb5_timestamp atime,\\r\\nkrb5_ticket_times *ttimes)\\r\\n{\\r\\nkrb5_deltat skew;\\r\\nkrb5_timestamp start, now;\\r\\nkrb5_error_code rc;\\r\\nkrb5_context context;\\r\\nif ((rc = krb5_init_context(&context))) return SSL_R_KRB5_S_BAD_TICKET;\\r\\nskew = get_rc_clockskew(context);\\r\\nif ((rc = krb5_timeofday(context,&now))) return SSL_R_KRB5_S_BAD_TICKET;\\r\\nkrb5_free_context(context);\\r\\nif (atime && labs(atime - now) >= skew) return SSL_R_KRB5_S_TKT_SKEW;\\r\\nif (! ttimes) return 0;\\r\\nstart = (ttimes->starttime != 0)? ttimes->starttime: ttimes->authtime;\\r\\nif (start - now > skew) return SSL_R_KRB5_S_TKT_NYV;\\r\\nif ((now - ttimes->endtime) > skew) return SSL_R_KRB5_S_TKT_EXPIRED;\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"kssl_validate_times: %d |<- | %d - %d | < %d ->| %d\\n\",\\r\\nstart, atime, now, skew, ttimes->endtime);\\r\\n#endif\\r\\nreturn 0;\\r\\n}\\r\\nkrb5_error_code kssl_check_authent(\\r\\nKSSL_CTX *kssl_ctx,\\r\\nkrb5_data *authentp,\\r\\nkrb5_timestamp *atimep,\\r\\nKSSL_ERR *kssl_err )\\r\\n{\\r\\nkrb5_error_code krb5rc = 0;\\r\\nKRB5_ENCDATA *dec_authent = NULL;\\r\\nKRB5_AUTHENTBODY *auth = NULL;\\r\\nkrb5_enctype enctype;\\r\\nEVP_CIPHER_CTX ciph_ctx;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nconst unsigned char *p;\\r\\nunsigned char *unenc_authent;\\r\\nint outl, unencbufsize;\\r\\nstruct tm tm_time, *tm_l, *tm_g;\\r\\ntime_t now, tl, tg, tr, tz_offset;\\r\\nEVP_CIPHER_CTX_init(&ciph_ctx);\\r\\n*atimep = 0;\\r\\nkssl_err_set(kssl_err, 0, \"\");\\r\\n#ifndef KRB5CHECKAUTH\\r\\nauthentp = NULL;\\r\\n#else\\r\\n#if KRB5CHECKAUTH == 0\\r\\nauthentp = NULL;\\r\\n#endif\\r\\n#endif\\r\\nif (authentp == NULL || authentp->length == 0) return 0;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned int ui;\\r\\nprintf(\"kssl_check_authent: authenticator[%d]:\\n\",authentp->length);\\r\\np = authentp->data;\\r\\nfor (ui=0; ui < authentp->length; ui++) printf(\"%02x \",p[ui]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\n#endif\\r\\nunencbufsize = 2 * authentp->length;\\r\\nif ((unenc_authent = calloc(1, unencbufsize)) == NULL)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"Unable to allocate authenticator buffer.\\n\");\\r\\nkrb5rc = KRB5KRB_ERR_GENERIC;\\r\\ngoto err;\\r\\n}\\r\\np = (unsigned char *)authentp->data;\\r\\nif ((dec_authent = d2i_KRB5_ENCDATA(NULL, &p,\\r\\n(long) authentp->length)) == NULL)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"Error decoding authenticator.\\n\");\\r\\nkrb5rc = KRB5KRB_AP_ERR_BAD_INTEGRITY;\\r\\ngoto err;\\r\\n}\\r\\nenctype = dec_authent->etype->data[0];\\r\\n#if !defined(KRB5_MIT_OLD11)\\r\\nswitch ( enctype ) {\\r\\ncase ENCTYPE_DES3_CBC_SHA1:\\r\\ncase ENCTYPE_DES3_CBC_SHA:\\r\\ncase ENCTYPE_DES3_CBC_RAW:\\r\\nkrb5rc = 0;\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nenc = kssl_map_enc(enctype);\\r\\nmemset(iv, 0, sizeof iv);\\r\\nif (enc == NULL)\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_CipherInit(&ciph_ctx,enc,kssl_ctx->key,iv,0))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"EVP_CipherInit error decrypting authenticator.\\n\");\\r\\nkrb5rc = KRB5KRB_AP_ERR_BAD_INTEGRITY;\\r\\ngoto err;\\r\\n}\\r\\noutl = dec_authent->cipher->length;\\r\\nif (!EVP_Cipher(&ciph_ctx,unenc_authent,dec_authent->cipher->data,outl))\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"EVP_Cipher error decrypting authenticator.\\n\");\\r\\nkrb5rc = KRB5KRB_AP_ERR_BAD_INTEGRITY;\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&ciph_ctx);\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"kssl_check_authent: decrypted authenticator[%d] =\\n\", outl);\\r\\nfor (padl=0; padl < outl; padl++) printf(\"%02x \",unenc_authent[padl]);\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nif ((p = kssl_skip_confound(enctype, unenc_authent)) == NULL)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"confounded by authenticator.\\n\");\\r\\nkrb5rc = KRB5KRB_AP_ERR_BAD_INTEGRITY;\\r\\ngoto err;\\r\\n}\\r\\noutl -= p - unenc_authent;\\r\\nif ((auth = (KRB5_AUTHENTBODY *) d2i_KRB5_AUTHENT(NULL, &p,\\r\\n(long) outl))==NULL)\\r\\n{\\r\\nkssl_err_set(kssl_err, SSL_R_KRB5_S_INIT,\\r\\n\"Error decoding authenticator body.\\n\");\\r\\nkrb5rc = KRB5KRB_AP_ERR_BAD_INTEGRITY;\\r\\ngoto err;\\r\\n}\\r\\nmemset(&tm_time,0,sizeof(struct tm));\\r\\nif (k_gmtime(auth->ctime, &tm_time) &&\\r\\n((tr = mktime(&tm_time)) != (time_t)(-1)))\\r\\n{\\r\\nnow = time(&now);\\r\\ntm_l = localtime(&now); tl = mktime(tm_l);\\r\\ntm_g = gmtime(&now); tg = mktime(tm_g);\\r\\ntz_offset = tg - tl;\\r\\n*atimep = tr - tz_offset;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"kssl_check_authent: returns %d for client time \", *atimep);\\r\\nif (auth && auth->ctime && auth->ctime->length && auth->ctime->data)\\r\\nprintf(\"%.*s\\n\", auth->ctime->length, auth->ctime->data);\\r\\nelse printf(\"NULL\\n\");\\r\\n#endif\\r\\nerr:\\r\\nif (auth) KRB5_AUTHENT_free((KRB5_AUTHENT *) auth);\\r\\nif (dec_authent) KRB5_ENCDATA_free(dec_authent);\\r\\nif (unenc_authent) free(unenc_authent);\\r\\nEVP_CIPHER_CTX_cleanup(&ciph_ctx);\\r\\nreturn krb5rc;\\r\\n}\\r\\nkrb5_error_code kssl_build_principal_2(\\r\\nkrb5_context context,\\r\\nkrb5_principal *princ,\\r\\nint rlen, const char *realm,\\r\\nint slen, const char *svc,\\r\\nint hlen, const char *host)\\r\\n{\\r\\nkrb5_data *p_data = NULL;\\r\\nkrb5_principal new_p = NULL;\\r\\nchar *new_r = NULL;\\r\\nif ((p_data = (krb5_data *) calloc(2, sizeof(krb5_data))) == NULL ||\\r\\n(new_p = (krb5_principal) calloc(1, sizeof(krb5_principal_data)))\\r\\n== NULL) goto err;\\r\\nnew_p->length = 2;\\r\\nnew_p->data = p_data;\\r\\nif ((new_r = calloc(1, rlen + 1)) == NULL) goto err;\\r\\nmemcpy(new_r, realm, rlen);\\r\\nkrb5_princ_set_realm_length(context, new_p, rlen);\\r\\nkrb5_princ_set_realm_data(context, new_p, new_r);\\r\\nif ((new_p->data[0].data = calloc(1, slen + 1)) == NULL) goto err;\\r\\nmemcpy(new_p->data[0].data, svc, slen);\\r\\nnew_p->data[0].length = slen;\\r\\nif ((new_p->data[1].data = calloc(1, hlen + 1)) == NULL) goto err;\\r\\nmemcpy(new_p->data[1].data, host, hlen);\\r\\nnew_p->data[1].length = hlen;\\r\\nkrb5_princ_type(context, new_p) = KRB5_NT_UNKNOWN;\\r\\n*princ = new_p;\\r\\nreturn 0;\\r\\nerr:\\r\\nif (new_p && new_p[0].data) free(new_p[0].data);\\r\\nif (new_p && new_p[1].data) free(new_p[1].data);\\r\\nif (new_p) free(new_p);\\r\\nif (new_r) free(new_r);\\r\\nreturn ENOMEM;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_fd_c", "target": 0, "func": "BIO_METHOD *BIO_s_fd(void)\\r\\n{\\r\\nreturn(&methods_fdp);\\r\\n}\\r\\nBIO *BIO_new_fd(int fd,int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_fd());\\r\\nif (ret == NULL) return(NULL);\\r\\nBIO_set_fd(ret,fd,close_flag);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int fd_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=-1;\\r\\nbi->ptr=NULL;\\r\\nbi->flags=BIO_FLAGS_UPLINK;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int fd_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif (a->init)\\r\\n{\\r\\nUP_close(a->num);\\r\\n}\\r\\na->init=0;\\r\\na->flags=BIO_FLAGS_UPLINK;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int fd_read(BIO *b, char *out,int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out != NULL)\\r\\n{\\r\\nclear_sys_error();\\r\\nret=UP_read(b->num,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_fd_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int fd_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nclear_sys_error();\\r\\nret=UP_write(b->num,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_fd_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nint *ip;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nnum=0;\\r\\ncase BIO_C_FILE_SEEK:\\r\\nret=(long)UP_lseek(b->num,num,0);\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)UP_lseek(b->num,0,1);\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nfd_free(b);\\r\\nb->num= *((int *)ptr);\\r\\nb->shutdown=(int)num;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL) *ip=b->num;\\r\\nret=b->num;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int fd_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=fd_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_fd_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1))\\r\\n{\\r\\nerr=get_last_sys_error();\\r\\n#if defined(OPENSSL_SYS_WINDOWS) && 0\\r\\nif ((i == -1) && (err == 0))\\r\\nreturn(1);\\r\\n#endif\\r\\nreturn(BIO_fd_non_fatal_error(err));\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BIO_fd_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err)\\r\\n{\\r\\n#ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n#endif\\r\\n#if defined(ENOTCONN)\\r\\ncase ENOTCONN:\\r\\n#endif\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\n#if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n#endif\\r\\n#ifdef EPROTO\\r\\ncase EPROTO:\\r\\n#endif\\r\\n#ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n#endif\\r\\n#ifdef EALREADY\\r\\ncase EALREADY:\\r\\n#endif\\r\\nreturn(1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_rand_c", "target": 0, "func": "static int bnrand(int pseudorand, BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nunsigned char *buf=NULL;\\r\\nint ret=0,bit,bytes,mask;\\r\\ntime_t tim;\\r\\nif (bits == 0)\\r\\n{\\r\\nBN_zero(rnd);\\r\\nreturn 1;\\r\\n}\\r\\nbytes=(bits+7)/8;\\r\\nbit=(bits-1)%8;\\r\\nmask=0xff<<(bit+1);\\r\\nbuf=(unsigned char *)OPENSSL_malloc(bytes);\\r\\nif (buf == NULL)\\r\\n{\\r\\nBNerr(BN_F_BNRAND,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntime(&tim);\\r\\nRAND_add(&tim,sizeof(tim),0.0);\\r\\nif (pseudorand)\\r\\n{\\r\\nif (RAND_pseudo_bytes(buf, bytes) == -1)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (RAND_bytes(buf, bytes) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n#if 1\\r\\nif (pseudorand == 2)\\r\\n{\\r\\nint i;\\r\\nunsigned char c;\\r\\nfor (i = 0; i < bytes; i++)\\r\\n{\\r\\nRAND_pseudo_bytes(&c, 1);\\r\\nif (c >= 128 && i > 0)\\r\\nbuf[i] = buf[i-1];\\r\\nelse if (c < 42)\\r\\nbuf[i] = 0;\\r\\nelse if (c < 84)\\r\\nbuf[i] = 255;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (top != -1)\\r\\n{\\r\\nif (top)\\r\\n{\\r\\nif (bit == 0)\\r\\n{\\r\\nbuf[0]=1;\\r\\nbuf[1]|=0x80;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]|=(3<<(bit-1));\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]|=(1<<bit);\\r\\n}\\r\\n}\\r\\nbuf[0] &= ~mask;\\r\\nif (bottom)\\r\\nbuf[bytes-1]|=1;\\r\\nif (!BN_bin2bn(buf,bytes,rnd)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (buf != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(buf,bytes);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nbn_check_top(rnd);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(0, rnd, bits, top, bottom);\\r\\n}\\r\\nint BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(1, rnd, bits, top, bottom);\\r\\n}\\r\\nint BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(2, rnd, bits, top, bottom);\\r\\n}\\r\\nstatic int bn_rand_range(int pseudo, BIGNUM *r, BIGNUM *range)\\r\\n{\\r\\nint (*bn_rand)(BIGNUM *, int, int, int) = pseudo ? BN_pseudo_rand : BN_rand;\\r\\nint n;\\r\\nint count = 100;\\r\\nif (range->neg || BN_is_zero(range))\\r\\n{\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_INVALID_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nn = BN_num_bits(range);\\r\\nif (n == 1)\\r\\nBN_zero(r);\\r\\nelse if (!BN_is_bit_set(range, n - 2) && !BN_is_bit_set(range, n - 3))\\r\\n{\\r\\ndo\\r\\n{\\r\\nif (!bn_rand(r, n + 1, -1, 0)) return 0;\\r\\nif (BN_cmp(r ,range) >= 0)\\r\\n{\\r\\nif (!BN_sub(r, r, range)) return 0;\\r\\nif (BN_cmp(r, range) >= 0)\\r\\nif (!BN_sub(r, r, range)) return 0;\\r\\n}\\r\\nif (!--count)\\r\\n{\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nwhile (BN_cmp(r, range) >= 0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ndo\\r\\n{\\r\\nif (!bn_rand(r, n, -1, 0)) return 0;\\r\\nif (!--count)\\r\\n{\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nwhile (BN_cmp(r, range) >= 0);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_rand_range(BIGNUM *r, BIGNUM *range)\\r\\n{\\r\\nreturn bn_rand_range(0, r, range);\\r\\n}\\r\\nint BN_pseudo_rand_range(BIGNUM *r, BIGNUM *range)\\r\\n{\\r\\nreturn bn_rand_range(1, r, range);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_gcd_c", "target": 0, "func": "int BN_gcd(BIGNUM *r, const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *a,*b,*t;\\r\\nint ret=0;\\r\\nbn_check_top(in_a);\\r\\nbn_check_top(in_b);\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nif (a == NULL || b == NULL) goto err;\\r\\nif (BN_copy(a,in_a) == NULL) goto err;\\r\\nif (BN_copy(b,in_b) == NULL) goto err;\\r\\na->neg = 0;\\r\\nb->neg = 0;\\r\\nif (BN_cmp(a,b) < 0) { t=a; a=b; b=t; }\\r\\nt=euclid(a,b);\\r\\nif (t == NULL) goto err;\\r\\nif (BN_copy(r,t) == NULL) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic BIGNUM *euclid(BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint shifts=0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nwhile (!BN_is_zero(b))\\r\\n{\\r\\nif (BN_is_odd(a))\\r\\n{\\r\\nif (BN_is_odd(b))\\r\\n{\\r\\nif (!BN_sub(a,a,b)) goto err;\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(b,b)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_is_odd(b))\\r\\n{\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (!BN_rshift1(b,b)) goto err;\\r\\nshifts++;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (shifts)\\r\\n{\\r\\nif (!BN_lshift(a,a,shifts)) goto err;\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn(a);\\r\\nerr:\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *BN_mod_inverse(BIGNUM *in,\\r\\nconst BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *A,*B,*X,*Y,*M,*D,*T,*R=NULL;\\r\\nBIGNUM *ret=NULL;\\r\\nint sign;\\r\\nbn_check_top(a);\\r\\nbn_check_top(n);\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nB = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nD = BN_CTX_get(ctx);\\r\\nM = BN_CTX_get(ctx);\\r\\nY = BN_CTX_get(ctx);\\r\\nT = BN_CTX_get(ctx);\\r\\nif (T == NULL) goto err;\\r\\nif (in == NULL)\\r\\nR=BN_new();\\r\\nelse\\r\\nR=in;\\r\\nif (R == NULL) goto err;\\r\\nBN_one(X);\\r\\nBN_zero(Y);\\r\\nif (BN_copy(B,a) == NULL) goto err;\\r\\nif (BN_copy(A,n) == NULL) goto err;\\r\\nA->neg = 0;\\r\\nif (B->neg || (BN_ucmp(B, A) >= 0))\\r\\n{\\r\\nif (!BN_nnmod(B, B, A, ctx)) goto err;\\r\\n}\\r\\nsign = -1;\\r\\nif (BN_is_odd(n) && (BN_num_bits(n) <= (BN_BITS <= 32 ? 450 : 2048)))\\r\\n{\\r\\nint shift;\\r\\nwhile (!BN_is_zero(B))\\r\\n{\\r\\nshift = 0;\\r\\nwhile (!BN_is_bit_set(B, shift))\\r\\n{\\r\\nshift++;\\r\\nif (BN_is_odd(X))\\r\\n{\\r\\nif (!BN_uadd(X, X, n)) goto err;\\r\\n}\\r\\nif (!BN_rshift1(X, X)) goto err;\\r\\n}\\r\\nif (shift > 0)\\r\\n{\\r\\nif (!BN_rshift(B, B, shift)) goto err;\\r\\n}\\r\\nshift = 0;\\r\\nwhile (!BN_is_bit_set(A, shift))\\r\\n{\\r\\nshift++;\\r\\nif (BN_is_odd(Y))\\r\\n{\\r\\nif (!BN_uadd(Y, Y, n)) goto err;\\r\\n}\\r\\nif (!BN_rshift1(Y, Y)) goto err;\\r\\n}\\r\\nif (shift > 0)\\r\\n{\\r\\nif (!BN_rshift(A, A, shift)) goto err;\\r\\n}\\r\\nif (BN_ucmp(B, A) >= 0)\\r\\n{\\r\\nif (!BN_uadd(X, X, Y)) goto err;\\r\\nif (!BN_usub(B, B, A)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_uadd(Y, Y, X)) goto err;\\r\\nif (!BN_usub(A, A, B)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (!BN_is_zero(B))\\r\\n{\\r\\nBIGNUM *tmp;\\r\\nif (BN_num_bits(A) == BN_num_bits(B))\\r\\n{\\r\\nif (!BN_one(D)) goto err;\\r\\nif (!BN_sub(M,A,B)) goto err;\\r\\n}\\r\\nelse if (BN_num_bits(A) == BN_num_bits(B) + 1)\\r\\n{\\r\\nif (!BN_lshift1(T,B)) goto err;\\r\\nif (BN_ucmp(A,T) < 0)\\r\\n{\\r\\nif (!BN_one(D)) goto err;\\r\\nif (!BN_sub(M,A,B)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_sub(M,A,T)) goto err;\\r\\nif (!BN_add(D,T,B)) goto err;\\r\\nif (BN_ucmp(A,D) < 0)\\r\\n{\\r\\nif (!BN_set_word(D,2)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_set_word(D,3)) goto err;\\r\\nif (!BN_sub(M,M,B)) goto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_div(D,M,A,B,ctx)) goto err;\\r\\n}\\r\\ntmp=A;\\r\\nA=B;\\r\\nB=M;\\r\\nif (BN_is_one(D))\\r\\n{\\r\\nif (!BN_add(tmp,X,Y)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_is_word(D,2))\\r\\n{\\r\\nif (!BN_lshift1(tmp,X)) goto err;\\r\\n}\\r\\nelse if (BN_is_word(D,4))\\r\\n{\\r\\nif (!BN_lshift(tmp,X,2)) goto err;\\r\\n}\\r\\nelse if (D->top == 1)\\r\\n{\\r\\nif (!BN_copy(tmp,X)) goto err;\\r\\nif (!BN_mul_word(tmp,D->d[0])) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mul(tmp,D,X,ctx)) goto err;\\r\\n}\\r\\nif (!BN_add(tmp,tmp,Y)) goto err;\\r\\n}\\r\\nM=Y;\\r\\nY=X;\\r\\nX=tmp;\\r\\nsign = -sign;\\r\\n}\\r\\n}\\r\\nif (sign < 0)\\r\\n{\\r\\nif (!BN_sub(Y,n,Y)) goto err;\\r\\n}\\r\\nif (BN_is_one(A))\\r\\n{\\r\\nif (!Y->neg && BN_ucmp(Y,n) < 0)\\r\\n{\\r\\nif (!BN_copy(R,Y)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_nnmod(R,Y,n,ctx)) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_INVERSE,BN_R_NO_INVERSE);\\r\\ngoto err;\\r\\n}\\r\\nret=R;\\r\\nerr:\\r\\nif ((ret == NULL) && (in == NULL)) BN_free(R);\\r\\nBN_CTX_end(ctx);\\r\\nif (ret)\\r\\nbn_check_top(ret);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_pss_c", "target": 0, "func": "int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,\\r\\nconst EVP_MD *Hash, const unsigned char *EM, int sLen)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nint hLen, maskedDBLen, MSBits, emLen;\\r\\nconst unsigned char *H;\\r\\nunsigned char *DB = NULL;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char H_[EVP_MAX_MD_SIZE];\\r\\nhLen = EVP_MD_size(Hash);\\r\\nif (sLen == -1) sLen = hLen;\\r\\nelse if (sLen == -2) sLen = -2;\\r\\nelse if (sLen < -2)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nMSBits = (BN_num_bits(rsa->n) - 1) & 0x7;\\r\\nemLen = RSA_size(rsa);\\r\\nif (EM[0] & (0xFF << MSBits))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_FIRST_OCTET_INVALID);\\r\\ngoto err;\\r\\n}\\r\\nif (MSBits == 0)\\r\\n{\\r\\nEM++;\\r\\nemLen--;\\r\\n}\\r\\nif (emLen < (hLen + sLen + 2))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_DATA_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (EM[emLen - 1] != 0xbc)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_LAST_OCTET_INVALID);\\r\\ngoto err;\\r\\n}\\r\\nmaskedDBLen = emLen - hLen - 1;\\r\\nH = EM + maskedDBLen;\\r\\nDB = OPENSSL_malloc(maskedDBLen);\\r\\nif (!DB)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nPKCS1_MGF1(DB, maskedDBLen, H, hLen, Hash);\\r\\nfor (i = 0; i < maskedDBLen; i++)\\r\\nDB[i] ^= EM[i];\\r\\nif (MSBits)\\r\\nDB[0] &= 0xFF >> (8 - MSBits);\\r\\nfor (i = 0; DB[i] == 0 && i < (maskedDBLen-1); i++) ;\\r\\nif (DB[i++] != 0x1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_RECOVERY_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (sLen >= 0 && (maskedDBLen - i) != sLen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_DigestInit_ex(&ctx, Hash, NULL);\\r\\nEVP_DigestUpdate(&ctx, zeroes, sizeof zeroes);\\r\\nEVP_DigestUpdate(&ctx, mHash, hLen);\\r\\nif (maskedDBLen - i)\\r\\nEVP_DigestUpdate(&ctx, DB + i, maskedDBLen - i);\\r\\nEVP_DigestFinal(&ctx, H_, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (memcmp(H_, H, hLen))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS, RSA_R_BAD_SIGNATURE);\\r\\nret = 0;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\nerr:\\r\\nif (DB)\\r\\nOPENSSL_free(DB);\\r\\nreturn ret;\\r\\n}\\r\\nint RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,\\r\\nconst unsigned char *mHash,\\r\\nconst EVP_MD *Hash, int sLen)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nint hLen, maskedDBLen, MSBits, emLen;\\r\\nunsigned char *H, *salt = NULL, *p;\\r\\nEVP_MD_CTX ctx;\\r\\nhLen = EVP_MD_size(Hash);\\r\\nif (sLen == -1) sLen = hLen;\\r\\nelse if (sLen == -2) sLen = -2;\\r\\nelse if (sLen < -2)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nMSBits = (BN_num_bits(rsa->n) - 1) & 0x7;\\r\\nemLen = RSA_size(rsa);\\r\\nif (MSBits == 0)\\r\\n{\\r\\n*EM++ = 0;\\r\\nemLen--;\\r\\n}\\r\\nif (sLen == -2)\\r\\n{\\r\\nsLen = emLen - hLen - 2;\\r\\n}\\r\\nelse if (emLen < (hLen + sLen + 2))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\ngoto err;\\r\\n}\\r\\nif (sLen > 0)\\r\\n{\\r\\nsalt = OPENSSL_malloc(sLen);\\r\\nif (!salt)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!RAND_bytes(salt, sLen))\\r\\ngoto err;\\r\\n}\\r\\nmaskedDBLen = emLen - hLen - 1;\\r\\nH = EM + maskedDBLen;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_DigestInit_ex(&ctx, Hash, NULL);\\r\\nEVP_DigestUpdate(&ctx, zeroes, sizeof zeroes);\\r\\nEVP_DigestUpdate(&ctx, mHash, hLen);\\r\\nif (sLen)\\r\\nEVP_DigestUpdate(&ctx, salt, sLen);\\r\\nEVP_DigestFinal(&ctx, H, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nPKCS1_MGF1(EM, maskedDBLen, H, hLen, Hash);\\r\\np = EM;\\r\\np += emLen - sLen - hLen - 2;\\r\\n*p++ ^= 0x1;\\r\\nif (sLen > 0)\\r\\n{\\r\\nfor (i = 0; i < sLen; i++)\\r\\n*p++ ^= salt[i];\\r\\n}\\r\\nif (MSBits)\\r\\nEM[0] &= 0xFF >> (8 - MSBits);\\r\\nEM[emLen - 1] = 0xbc;\\r\\nret = 1;\\r\\nerr:\\r\\nif (salt)\\r\\nOPENSSL_free(salt);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_add_c", "target": 0, "func": "int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nconst BIGNUM *tmp;\\r\\nint a_neg = a->neg, ret;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a_neg ^ b->neg)\\r\\n{\\r\\nif (a_neg)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nif (BN_ucmp(a,b) < 0)\\r\\n{\\r\\nif (!BN_usub(r,b,a)) return(0);\\r\\nr->neg=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_usub(r,a,b)) return(0);\\r\\nr->neg=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nret = BN_uadd(r,a,b);\\r\\nr->neg = a_neg;\\r\\nbn_check_top(r);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max,min,dif;\\r\\nBN_ULONG *ap,*bp,*rp,carry,t1,t2;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nmax = a->top;\\r\\nmin = b->top;\\r\\ndif = max - min;\\r\\nif (bn_wexpand(r,max+1) == NULL)\\r\\nreturn 0;\\r\\nr->top=max;\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nrp=r->d;\\r\\ncarry=bn_add_words(rp,ap,bp,min);\\r\\nrp+=min;\\r\\nap+=min;\\r\\nbp+=min;\\r\\nif (carry)\\r\\n{\\r\\nwhile (dif)\\r\\n{\\r\\ndif--;\\r\\nt1 = *(ap++);\\r\\nt2 = (t1+1) & BN_MASK2;\\r\\n*(rp++) = t2;\\r\\nif (t2)\\r\\n{\\r\\ncarry=0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (carry)\\r\\n{\\r\\n*rp = 1;\\r\\nr->top++;\\r\\n}\\r\\n}\\r\\nif (dif && rp != ap)\\r\\nwhile (dif--)\\r\\n*(rp++) = *(ap++);\\r\\nr->neg = 0;\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max,min,dif;\\r\\nregister BN_ULONG t1,t2,*ap,*bp,*rp;\\r\\nint i,carry;\\r\\n#if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\nint dummy;\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nmax = a->top;\\r\\nmin = b->top;\\r\\ndif = max - min;\\r\\nif (dif < 0)\\r\\n{\\r\\nBNerr(BN_F_BN_USUB,BN_R_ARG2_LT_ARG3);\\r\\nreturn(0);\\r\\n}\\r\\nif (bn_wexpand(r,max) == NULL) return(0);\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nrp=r->d;\\r\\n#if 1\\r\\ncarry=0;\\r\\nfor (i = min; i != 0; i--)\\r\\n{\\r\\nt1= *(ap++);\\r\\nt2= *(bp++);\\r\\nif (carry)\\r\\n{\\r\\ncarry=(t1 <= t2);\\r\\nt1=(t1-t2-1)&BN_MASK2;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncarry=(t1 < t2);\\r\\nt1=(t1-t2)&BN_MASK2;\\r\\n}\\r\\n#if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\ndummy=t1;\\r\\n#endif\\r\\n*(rp++)=t1&BN_MASK2;\\r\\n}\\r\\n#else\\r\\ncarry=bn_sub_words(rp,ap,bp,min);\\r\\nap+=min;\\r\\nbp+=min;\\r\\nrp+=min;\\r\\n#endif\\r\\nif (carry)\\r\\n{\\r\\nif (!dif)\\r\\nreturn 0;\\r\\nwhile (dif)\\r\\n{\\r\\ndif--;\\r\\nt1 = *(ap++);\\r\\nt2 = (t1-1)&BN_MASK2;\\r\\n*(rp++) = t2;\\r\\nif (t1)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nmemcpy(rp,ap,sizeof(*rp)*(max-i));\\r\\n#else\\r\\nif (rp != ap)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (!dif--) break;\\r\\nrp[0]=ap[0];\\r\\nif (!dif--) break;\\r\\nrp[1]=ap[1];\\r\\nif (!dif--) break;\\r\\nrp[2]=ap[2];\\r\\nif (!dif--) break;\\r\\nrp[3]=ap[3];\\r\\nrp+=4;\\r\\nap+=4;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nr->top=max;\\r\\nr->neg=0;\\r\\nbn_correct_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max;\\r\\nint add=0,neg=0;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg)\\r\\n{\\r\\nif (b->neg)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nelse\\r\\n{ add=1; neg=1; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (b->neg) { add=1; neg=0; }\\r\\n}\\r\\nif (add)\\r\\n{\\r\\nif (!BN_uadd(r,a,b)) return(0);\\r\\nr->neg=neg;\\r\\nreturn(1);\\r\\n}\\r\\nmax=(a->top > b->top)?a->top:b->top;\\r\\nif (bn_wexpand(r,max) == NULL) return(0);\\r\\nif (BN_ucmp(a,b) < 0)\\r\\n{\\r\\nif (!BN_usub(r,b,a)) return(0);\\r\\nr->neg=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_usub(r,a,b)) return(0);\\r\\nr->neg=0;\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_check_c", "target": 0, "func": "int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *order;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nEC_POINT *point = NULL;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((order = BN_CTX_get(ctx)) == NULL) goto err;\\r\\nif (!EC_GROUP_check_discriminant(group, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_DISCRIMINANT_IS_ZERO);\\r\\ngoto err;\\r\\n}\\r\\nif (group->generator == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, group->generator, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_POINT_new(group)) == NULL) goto err;\\r\\nif (!EC_GROUP_get_order(group, order, ctx)) goto err;\\r\\nif (BN_is_zero(order))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(group, point, order, NULL, NULL, ctx)) goto err;\\r\\nif (!EC_POINT_is_at_infinity(group, point))\\r\\n{\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5_enc_c", "target": 0, "func": "void RC5_32_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *ks, unsigned char *iv,\\r\\nint encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC5_32_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC5_32_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC5_32_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC5_32_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid RC5_32_encrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a,b,*s;\\r\\ns=key->data;\\r\\na=d[0]+s[0];\\r\\nb=d[1]+s[1];\\r\\nE_RC5_32(a,b,s, 2);\\r\\nE_RC5_32(a,b,s, 4);\\r\\nE_RC5_32(a,b,s, 6);\\r\\nE_RC5_32(a,b,s, 8);\\r\\nE_RC5_32(a,b,s,10);\\r\\nE_RC5_32(a,b,s,12);\\r\\nE_RC5_32(a,b,s,14);\\r\\nE_RC5_32(a,b,s,16);\\r\\nif (key->rounds == 12)\\r\\n{\\r\\nE_RC5_32(a,b,s,18);\\r\\nE_RC5_32(a,b,s,20);\\r\\nE_RC5_32(a,b,s,22);\\r\\nE_RC5_32(a,b,s,24);\\r\\n}\\r\\nelse if (key->rounds == 16)\\r\\n{\\r\\nE_RC5_32(a,b,s,18);\\r\\nE_RC5_32(a,b,s,20);\\r\\nE_RC5_32(a,b,s,22);\\r\\nE_RC5_32(a,b,s,24);\\r\\nE_RC5_32(a,b,s,26);\\r\\nE_RC5_32(a,b,s,28);\\r\\nE_RC5_32(a,b,s,30);\\r\\nE_RC5_32(a,b,s,32);\\r\\n}\\r\\nd[0]=a;\\r\\nd[1]=b;\\r\\n}\\r\\nvoid RC5_32_decrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a,b,*s;\\r\\ns=key->data;\\r\\na=d[0];\\r\\nb=d[1];\\r\\nif (key->rounds == 16)\\r\\n{\\r\\nD_RC5_32(a,b,s,32);\\r\\nD_RC5_32(a,b,s,30);\\r\\nD_RC5_32(a,b,s,28);\\r\\nD_RC5_32(a,b,s,26);\\r\\nD_RC5_32(a,b,s,24);\\r\\nD_RC5_32(a,b,s,22);\\r\\nD_RC5_32(a,b,s,20);\\r\\nD_RC5_32(a,b,s,18);\\r\\n}\\r\\nelse if (key->rounds == 12)\\r\\n{\\r\\nD_RC5_32(a,b,s,24);\\r\\nD_RC5_32(a,b,s,22);\\r\\nD_RC5_32(a,b,s,20);\\r\\nD_RC5_32(a,b,s,18);\\r\\n}\\r\\nD_RC5_32(a,b,s,16);\\r\\nD_RC5_32(a,b,s,14);\\r\\nD_RC5_32(a,b,s,12);\\r\\nD_RC5_32(a,b,s,10);\\r\\nD_RC5_32(a,b,s, 8);\\r\\nD_RC5_32(a,b,s, 6);\\r\\nD_RC5_32(a,b,s, 4);\\r\\nD_RC5_32(a,b,s, 2);\\r\\nd[0]=a-s[0];\\r\\nd[1]=b-s[1];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_eng_fat_c", "target": 0, "func": "int ENGINE_set_default(ENGINE *e, unsigned int flags)\\r\\n{\\r\\nif((flags & ENGINE_METHOD_CIPHERS) && !ENGINE_set_default_ciphers(e))\\r\\nreturn 0;\\r\\nif((flags & ENGINE_METHOD_DIGESTS) && !ENGINE_set_default_digests(e))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif((flags & ENGINE_METHOD_RSA) && !ENGINE_set_default_RSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif((flags & ENGINE_METHOD_DSA) && !ENGINE_set_default_DSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif((flags & ENGINE_METHOD_DH) && !ENGINE_set_default_DH(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif((flags & ENGINE_METHOD_ECDH) && !ENGINE_set_default_ECDH(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif((flags & ENGINE_METHOD_ECDSA) && !ENGINE_set_default_ECDSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\nif((flags & ENGINE_METHOD_RAND) && !ENGINE_set_default_RAND(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_def_cb(const char *alg, int len, void *arg)\\r\\n{\\r\\nunsigned int *pflags = arg;\\r\\nif (!strncmp(alg, \"ALL\", len))\\r\\n*pflags |= ENGINE_METHOD_ALL;\\r\\nelse if (!strncmp(alg, \"RSA\", len))\\r\\n*pflags |= ENGINE_METHOD_RSA;\\r\\nelse if (!strncmp(alg, \"DSA\", len))\\r\\n*pflags |= ENGINE_METHOD_DSA;\\r\\nelse if (!strncmp(alg, \"ECDH\", len))\\r\\n*pflags |= ENGINE_METHOD_ECDH;\\r\\nelse if (!strncmp(alg, \"ECDSA\", len))\\r\\n*pflags |= ENGINE_METHOD_ECDSA;\\r\\nelse if (!strncmp(alg, \"DH\", len))\\r\\n*pflags |= ENGINE_METHOD_DH;\\r\\nelse if (!strncmp(alg, \"RAND\", len))\\r\\n*pflags |= ENGINE_METHOD_RAND;\\r\\nelse if (!strncmp(alg, \"CIPHERS\", len))\\r\\n*pflags |= ENGINE_METHOD_CIPHERS;\\r\\nelse if (!strncmp(alg, \"DIGESTS\", len))\\r\\n*pflags |= ENGINE_METHOD_DIGESTS;\\r\\nelse\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_default_string(ENGINE *e, const char *def_list)\\r\\n{\\r\\nunsigned int flags = 0;\\r\\nif (!CONF_parse_list(def_list, ',', 1, int_def_cb, &flags))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_DEFAULT_STRING,\\r\\nENGINE_R_INVALID_STRING);\\r\\nERR_add_error_data(2, \"str=\",def_list);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ENGINE_set_default(e, flags);\\r\\n}\\r\\nint ENGINE_register_complete(ENGINE *e)\\r\\n{\\r\\nENGINE_register_ciphers(e);\\r\\nENGINE_register_digests(e);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nENGINE_register_RSA(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nENGINE_register_DSA(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nENGINE_register_DH(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nENGINE_register_ECDH(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nENGINE_register_ECDSA(e);\\r\\n#endif\\r\\nENGINE_register_RAND(e);\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_register_all_complete(void)\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_complete(e);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_genrsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nBN_GENCB cb;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nint ret=1;\\r\\nint i,num=DEFBITS;\\r\\nlong l;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nunsigned long f4=RSA_F4;\\r\\nchar *outfile=NULL;\\r\\nchar *passargout = NULL, *passout = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine=NULL;\\r\\n#endif\\r\\nchar *inrand=NULL;\\r\\nBIO *out=NULL;\\r\\nBIGNUM *bn = BN_new();\\r\\nRSA *rsa = RSA_new();\\r\\nif(!bn || !rsa) goto err;\\r\\napps_startup();\\r\\nBN_GENCB_set(&cb, genrsa_cb, bio_err);\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nif ((out=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to create BIO for output\\n\");\\r\\ngoto err;\\r\\n}\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-3\") == 0)\\r\\nf4=3;\\r\\nelse if (strcmp(*argv,\"-F4\") == 0 || strcmp(*argv,\"-f4\") == 0)\\r\\nf4=RSA_F4;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv,\"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_DES\\r\\nelse if (strcmp(*argv,\"-des\") == 0)\\r\\nenc=EVP_des_cbc();\\r\\nelse if (strcmp(*argv,\"-des3\") == 0)\\r\\nenc=EVP_des_ede3_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nelse if (strcmp(*argv,\"-idea\") == 0)\\r\\nenc=EVP_idea_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nelse if (strcmp(*argv,\"-aes128\") == 0)\\r\\nenc=EVP_aes_128_cbc();\\r\\nelse if (strcmp(*argv,\"-aes192\") == 0)\\r\\nenc=EVP_aes_192_cbc();\\r\\nelse if (strcmp(*argv,\"-aes256\") == 0)\\r\\nenc=EVP_aes_256_cbc();\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-passout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npassargout= *(++argv);\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: genrsa [args] [numbits]\\n\");\\r\\nBIO_printf(bio_err,\" -des encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err,\" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -out file output the key to 'file\\n\");\\r\\nBIO_printf(bio_err,\" -passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\" -f4 use F4 (0x10001) for the E value\\n\");\\r\\nBIO_printf(bio_err,\" -3 use 3 for the E value\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif(!app_passwd(bio_err, NULL, passargout, NULL, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status())\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nBIO_printf(bio_err,\"Generating RSA private key, %d bit long modulus\\n\",\\r\\nnum);\\r\\nif(!BN_set_word(bn, f4) || !RSA_generate_key_ex(rsa, num, bn, &cb))\\r\\ngoto err;\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nl=0L;\\r\\nfor (i=0; i<rsa->e->top; i++)\\r\\n{\\r\\n#ifndef SIXTY_FOUR_BIT\\r\\nl<<=BN_BITS4;\\r\\nl<<=BN_BITS4;\\r\\n#endif\\r\\nl+=rsa->e->d[i];\\r\\n}\\r\\nBIO_printf(bio_err,\"e is %ld (0x%lX)\\n\",l,l);\\r\\n{\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = passout;\\r\\ncb_data.prompt_info = outfile;\\r\\nif (!PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,0,\\r\\n(pem_password_cb *)password_callback,&cb_data))\\r\\ngoto err;\\r\\n}\\r\\nret=0;\\r\\nerr:\\r\\nif (bn) BN_free(bn);\\r\\nif (rsa) RSA_free(rsa);\\r\\nif (out) BIO_free_all(out);\\r\\nif(passout) OPENSSL_free(passout);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK genrsa_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write(cb->arg,&c,1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_obj_dat_c", "target": 0, "func": "static int sn_cmp(const void *a, const void *b)\\r\\n{\\r\\nconst ASN1_OBJECT * const *ap = a, * const *bp = b;\\r\\nreturn(strcmp((*ap)->sn,(*bp)->sn));\\r\\n}\\r\\nstatic int ln_cmp(const void *a, const void *b)\\r\\n{\\r\\nconst ASN1_OBJECT * const *ap = a, * const *bp = b;\\r\\nreturn(strcmp((*ap)->ln,(*bp)->ln));\\r\\n}\\r\\nstatic unsigned long add_hash(const void *ca_void)\\r\\n{\\r\\nconst ASN1_OBJECT *a;\\r\\nint i;\\r\\nunsigned long ret=0;\\r\\nunsigned char *p;\\r\\nconst ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;\\r\\na=ca->obj;\\r\\nswitch (ca->type)\\r\\n{\\r\\ncase ADDED_DATA:\\r\\nret=a->length<<20L;\\r\\np=(unsigned char *)a->data;\\r\\nfor (i=0; i<a->length; i++)\\r\\nret^=p[i]<<((i*3)%24);\\r\\nbreak;\\r\\ncase ADDED_SNAME:\\r\\nret=lh_strhash(a->sn);\\r\\nbreak;\\r\\ncase ADDED_LNAME:\\r\\nret=lh_strhash(a->ln);\\r\\nbreak;\\r\\ncase ADDED_NID:\\r\\nret=a->nid;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nret&=0x3fffffffL;\\r\\nret|=ca->type<<30L;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int add_cmp(const void *ca_void, const void *cb_void)\\r\\n{\\r\\nASN1_OBJECT *a,*b;\\r\\nint i;\\r\\nconst ADDED_OBJ *ca = (const ADDED_OBJ *)ca_void;\\r\\nconst ADDED_OBJ *cb = (const ADDED_OBJ *)cb_void;\\r\\ni=ca->type-cb->type;\\r\\nif (i) return(i);\\r\\na=ca->obj;\\r\\nb=cb->obj;\\r\\nswitch (ca->type)\\r\\n{\\r\\ncase ADDED_DATA:\\r\\ni=(a->length - b->length);\\r\\nif (i) return(i);\\r\\nreturn(memcmp(a->data,b->data,(size_t)a->length));\\r\\ncase ADDED_SNAME:\\r\\nif (a->sn == NULL) return(-1);\\r\\nelse if (b->sn == NULL) return(1);\\r\\nelse return(strcmp(a->sn,b->sn));\\r\\ncase ADDED_LNAME:\\r\\nif (a->ln == NULL) return(-1);\\r\\nelse if (b->ln == NULL) return(1);\\r\\nelse return(strcmp(a->ln,b->ln));\\r\\ncase ADDED_NID:\\r\\nreturn(a->nid-b->nid);\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nstatic int init_added(void)\\r\\n{\\r\\nif (added != NULL) return(1);\\r\\nadded=lh_new(add_hash,add_cmp);\\r\\nreturn(added != NULL);\\r\\n}\\r\\nstatic void cleanup1(ADDED_OBJ *a)\\r\\n{\\r\\na->obj->nid=0;\\r\\na->obj->flags|=ASN1_OBJECT_FLAG_DYNAMIC|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\n}\\r\\nstatic void cleanup2(ADDED_OBJ *a)\\r\\n{ a->obj->nid++; }\\r\\nstatic void cleanup3(ADDED_OBJ *a)\\r\\n{\\r\\nif (--a->obj->nid == 0)\\r\\nASN1_OBJECT_free(a->obj);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nint OBJ_add_object(const ASN1_OBJECT *obj)\\r\\n{\\r\\nASN1_OBJECT *o;\\r\\nADDED_OBJ *ao[4]={NULL,NULL,NULL,NULL},*aop;\\r\\nint i;\\r\\nif (added == NULL)\\r\\nif (!init_added()) return(0);\\r\\nif ((o=OBJ_dup(obj)) == NULL) goto err;\\r\\nif (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\\r\\nif ((o->length != 0) && (obj->data != NULL))\\r\\nif (!(ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\\r\\nif (o->sn != NULL)\\r\\nif (!(ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\\r\\nif (o->ln != NULL)\\r\\nif (!(ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\\r\\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\\r\\n{\\r\\nif (ao[i] != NULL)\\r\\n{\\r\\nao[i]->type=i;\\r\\nao[i]->obj=o;\\r\\naop=(ADDED_OBJ *)lh_insert(added,ao[i]);\\r\\nif (aop != NULL)\\r\\nOPENSSL_free(aop);\\r\\n}\\r\\n}\\r\\no->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn(o->nid);\\r\\nerr2:\\r\\nOBJerr(OBJ_F_OBJ_ADD_OBJECT,ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\\r\\nif (ao[i] != NULL) OPENSSL_free(ao[i]);\\r\\nif (o != NULL) OPENSSL_free(o);\\r\\nreturn(NID_undef);\\r\\n}\\r\\nASN1_OBJECT *OBJ_nid2obj(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn((ASN1_OBJECT *)&(nid_objs[n]));\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2sn(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(nid_objs[n].sn);\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj->sn);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2ln(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(nid_objs[n].ln);\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj->ln);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nint OBJ_obj2nid(const ASN1_OBJECT *a)\\r\\n{\\r\\nASN1_OBJECT **op;\\r\\nADDED_OBJ ad,*adp;\\r\\nif (a == NULL)\\r\\nreturn(NID_undef);\\r\\nif (a->nid != 0)\\r\\nreturn(a->nid);\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_DATA;\\r\\nad.obj=(ASN1_OBJECT *)a;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((const char *)&a,(const char *)obj_objs,\\r\\nNUM_OBJ, sizeof(ASN1_OBJECT *),obj_cmp);\\r\\nif (op == NULL)\\r\\nreturn(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\\r\\n{\\r\\nint nid = NID_undef;\\r\\nASN1_OBJECT *op=NULL;\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nint i, j;\\r\\nif(!no_name) {\\r\\nif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\\r\\n((nid = OBJ_ln2nid(s)) != NID_undef) )\\r\\nreturn OBJ_nid2obj(nid);\\r\\n}\\r\\ni=a2d_ASN1_OBJECT(NULL,0,s,-1);\\r\\nif (i <= 0) {\\r\\nERR_clear_error();\\r\\nreturn NULL;\\r\\n}\\r\\nj = ASN1_object_size(0,i,V_ASN1_OBJECT);\\r\\nif((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;\\r\\np = buf;\\r\\nASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\\r\\na2d_ASN1_OBJECT(p,i,s,-1);\\r\\ncp=buf;\\r\\nop=d2i_ASN1_OBJECT(NULL,&cp,j);\\r\\nOPENSSL_free(buf);\\r\\nreturn op;\\r\\n}\\r\\nint OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\\r\\n{\\r\\nint i,idx=0,n=0,len,nid;\\r\\nunsigned long l;\\r\\nunsigned char *p;\\r\\nconst char *s;\\r\\nchar tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];\\r\\nif (buf_len <= 0) return(0);\\r\\nif ((a == NULL) || (a->data == NULL)) {\\r\\nbuf[0]='\\0';\\r\\nreturn(0);\\r\\n}\\r\\nif (no_name || (nid=OBJ_obj2nid(a)) == NID_undef) {\\r\\nlen=a->length;\\r\\np=a->data;\\r\\nidx=0;\\r\\nl=0;\\r\\nwhile (idx < a->length) {\\r\\nl|=(p[idx]&0x7f);\\r\\nif (!(p[idx] & 0x80)) break;\\r\\nl<<=7L;\\r\\nidx++;\\r\\n}\\r\\nidx++;\\r\\ni=(int)(l/40);\\r\\nif (i > 2) i=2;\\r\\nl-=(long)(i*40);\\r\\nBIO_snprintf(tbuf,sizeof tbuf,\"%d.%lu\",i,l);\\r\\ni=strlen(tbuf);\\r\\nBUF_strlcpy(buf,tbuf,buf_len);\\r\\nbuf_len-=i;\\r\\nbuf+=i;\\r\\nn+=i;\\r\\nl=0;\\r\\nfor (; idx<len; idx++) {\\r\\nl|=p[idx]&0x7f;\\r\\nif (!(p[idx] & 0x80)) {\\r\\nBIO_snprintf(tbuf,sizeof tbuf,\".%lu\",l);\\r\\ni=strlen(tbuf);\\r\\nif (buf_len > 0)\\r\\nBUF_strlcpy(buf,tbuf,buf_len);\\r\\nbuf_len-=i;\\r\\nbuf+=i;\\r\\nn+=i;\\r\\nl=0;\\r\\n}\\r\\nl<<=7L;\\r\\n}\\r\\n} else {\\r\\ns=OBJ_nid2ln(nid);\\r\\nif (s == NULL)\\r\\ns=OBJ_nid2sn(nid);\\r\\nBUF_strlcpy(buf,s,buf_len);\\r\\nn=strlen(s);\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\nint OBJ_txt2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint nid;\\r\\nobj = OBJ_txt2obj(s, 0);\\r\\nnid = OBJ_obj2nid(obj);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nid;\\r\\n}\\r\\nint OBJ_ln2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o,*oo= &o,**op;\\r\\nADDED_OBJ ad,*adp;\\r\\no.ln=s;\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_LNAME;\\r\\nad.obj= &o;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)ln_objs, NUM_LN,\\r\\nsizeof(ASN1_OBJECT *),ln_cmp);\\r\\nif (op == NULL) return(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nint OBJ_sn2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o,*oo= &o,**op;\\r\\nADDED_OBJ ad,*adp;\\r\\no.sn=s;\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_SNAME;\\r\\nad.obj= &o;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)sn_objs,NUM_SN,\\r\\nsizeof(ASN1_OBJECT *),sn_cmp);\\r\\nif (op == NULL) return(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nstatic int obj_cmp(const void *ap, const void *bp)\\r\\n{\\r\\nint j;\\r\\nconst ASN1_OBJECT *a= *(ASN1_OBJECT * const *)ap;\\r\\nconst ASN1_OBJECT *b= *(ASN1_OBJECT * const *)bp;\\r\\nj=(a->length - b->length);\\r\\nif (j) return(j);\\r\\nreturn(memcmp(a->data,b->data,a->length));\\r\\n}\\r\\nconst char *OBJ_bsearch(const char *key, const char *base, int num, int size,\\r\\nint (*cmp)(const void *, const void *))\\r\\n{\\r\\nreturn OBJ_bsearch_ex(key, base, num, size, cmp, 0);\\r\\n}\\r\\nconst char *OBJ_bsearch_ex(const char *key, const char *base, int num,\\r\\nint size, int (*cmp)(const void *, const void *), int flags)\\r\\n{\\r\\nint l,h,i=0,c=0;\\r\\nconst char *p = NULL;\\r\\nif (num == 0) return(NULL);\\r\\nl=0;\\r\\nh=num;\\r\\nwhile (l < h)\\r\\n{\\r\\ni=(l+h)/2;\\r\\np= &(base[i*size]);\\r\\nc=(*cmp)(key,p);\\r\\nif (c < 0)\\r\\nh=i;\\r\\nelse if (c > 0)\\r\\nl=i+1;\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nif (c != 0)\\r\\n{\\r\\nfor (i=0; i<num; ++i)\\r\\n{\\r\\np= &(base[i*size]);\\r\\nc = (*cmp)(key,p);\\r\\nif (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))\\r\\nreturn p;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))\\r\\np = NULL;\\r\\nelse if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH))\\r\\n{\\r\\nwhile(i > 0 && (*cmp)(key,&(base[(i-1)*size])) == 0)\\r\\ni--;\\r\\np = &(base[i*size]);\\r\\n}\\r\\nreturn(p);\\r\\n}\\r\\nint OBJ_create_objects(BIO *in)\\r\\n{\\r\\nMS_STATIC char buf[512];\\r\\nint i,num=0;\\r\\nchar *o,*s,*l=NULL;\\r\\nfor (;;)\\r\\n{\\r\\ns=o=NULL;\\r\\ni=BIO_gets(in,buf,512);\\r\\nif (i <= 0) return(num);\\r\\nbuf[i-1]='\\0';\\r\\nif (!isalnum((unsigned char)buf[0])) return(num);\\r\\no=s=buf;\\r\\nwhile (isdigit((unsigned char)*s) || (*s == '.'))\\r\\ns++;\\r\\nif (*s != '\\0')\\r\\n{\\r\\n*(s++)='\\0';\\r\\nwhile (isspace((unsigned char)*s))\\r\\ns++;\\r\\nif (*s == '\\0')\\r\\ns=NULL;\\r\\nelse\\r\\n{\\r\\nl=s;\\r\\nwhile ((*l != '\\0') && !isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l != '\\0')\\r\\n{\\r\\n*(l++)='\\0';\\r\\nwhile (isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l == '\\0') l=NULL;\\r\\n}\\r\\nelse\\r\\nl=NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nif ((o == NULL) || (*o == '\\0')) return(num);\\r\\nif (!OBJ_create(o,s,l)) return(num);\\r\\nnum++;\\r\\n}\\r\\n}\\r\\nint OBJ_create(const char *oid, const char *sn, const char *ln)\\r\\n{\\r\\nint ok=0;\\r\\nASN1_OBJECT *op=NULL;\\r\\nunsigned char *buf;\\r\\nint i;\\r\\ni=a2d_ASN1_OBJECT(NULL,0,oid,-1);\\r\\nif (i <= 0) return(0);\\r\\nif ((buf=(unsigned char *)OPENSSL_malloc(i)) == NULL)\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\ni=a2d_ASN1_OBJECT(buf,i,oid,-1);\\r\\nif (i == 0)\\r\\ngoto err;\\r\\nop=(ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1),buf,i,sn,ln);\\r\\nif (op == NULL)\\r\\ngoto err;\\r\\nok=OBJ_add_object(op);\\r\\nerr:\\r\\nASN1_OBJECT_free(op);\\r\\nOPENSSL_free(buf);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_store_c", "target": 0, "func": "void ENGINE_unregister_STORE(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&store_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_STORE(void)\\r\\n{\\r\\nengine_table_cleanup(&store_table);\\r\\n}\\r\\nint ENGINE_register_STORE(ENGINE *e)\\r\\n{\\r\\nif(e->store_meth)\\r\\nreturn engine_table_register(&store_table,\\r\\nengine_unregister_all_STORE, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_STORE()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_STORE(e);\\r\\n}\\r\\nconst STORE_METHOD *ENGINE_get_STORE(const ENGINE *e)\\r\\n{\\r\\nreturn e->store_meth;\\r\\n}\\r\\nint ENGINE_set_STORE(ENGINE *e, const STORE_METHOD *store_meth)\\r\\n{\\r\\ne->store_meth = store_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_div_c", "target": 0, "func": "int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint norm_shift,i,loop;\\r\\nBIGNUM *tmp,wnum,*snum,*sdiv,*res;\\r\\nBN_ULONG *resp,*wnump;\\r\\nBN_ULONG d0,d1;\\r\\nint num_n,div_n;\\r\\nif (dv)\\r\\nbn_check_top(dv);\\r\\nif (rm)\\r\\nbn_check_top(rm);\\r\\nbn_check_top(num);\\r\\nbn_check_top(divisor);\\r\\nif (BN_is_zero(divisor))\\r\\n{\\r\\nBNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO);\\r\\nreturn(0);\\r\\n}\\r\\nif (BN_ucmp(num,divisor) < 0)\\r\\n{\\r\\nif (rm != NULL)\\r\\n{ if (BN_copy(rm,num) == NULL) return(0); }\\r\\nif (dv != NULL) BN_zero(dv);\\r\\nreturn(1);\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp=BN_CTX_get(ctx);\\r\\nsnum=BN_CTX_get(ctx);\\r\\nsdiv=BN_CTX_get(ctx);\\r\\nif (dv == NULL)\\r\\nres=BN_CTX_get(ctx);\\r\\nelse res=dv;\\r\\nif (sdiv == NULL || res == NULL) goto err;\\r\\nnorm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);\\r\\nif (!(BN_lshift(sdiv,divisor,norm_shift))) goto err;\\r\\nsdiv->neg=0;\\r\\nnorm_shift+=BN_BITS2;\\r\\nif (!(BN_lshift(snum,num,norm_shift))) goto err;\\r\\nsnum->neg=0;\\r\\ndiv_n=sdiv->top;\\r\\nnum_n=snum->top;\\r\\nloop=num_n-div_n;\\r\\nwnum.neg = 0;\\r\\nwnum.d = &(snum->d[loop]);\\r\\nwnum.top = div_n;\\r\\nwnum.dmax = snum->dmax - loop;\\r\\nd0=sdiv->d[div_n-1];\\r\\nd1=(div_n == 1)?0:sdiv->d[div_n-2];\\r\\nwnump= &(snum->d[num_n-1]);\\r\\nres->neg= (num->neg^divisor->neg);\\r\\nif (!bn_wexpand(res,(loop+1))) goto err;\\r\\nres->top=loop;\\r\\nresp= &(res->d[loop-1]);\\r\\nif (!bn_wexpand(tmp,(div_n+1))) goto err;\\r\\nif (BN_ucmp(&wnum,sdiv) >= 0)\\r\\n{\\r\\nbn_clear_top2max(&wnum);\\r\\nbn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);\\r\\n*resp=1;\\r\\n}\\r\\nelse\\r\\nres->top--;\\r\\nif (res->top == 0)\\r\\nres->neg = 0;\\r\\nelse\\r\\nresp--;\\r\\nfor (i=0; i<loop-1; i++, wnump--, resp--)\\r\\n{\\r\\nBN_ULONG q,l0;\\r\\n#if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)\\r\\nBN_ULONG bn_div_3_words(BN_ULONG*,BN_ULONG,BN_ULONG);\\r\\nq=bn_div_3_words(wnump,d1,d0);\\r\\n#else\\r\\nBN_ULONG n0,n1,rem=0;\\r\\nn0=wnump[0];\\r\\nn1=wnump[-1];\\r\\nif (n0 == d0)\\r\\nq=BN_MASK2;\\r\\nelse\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t2;\\r\\n#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)\\r\\nq=(BN_ULONG)(((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0);\\r\\n#else\\r\\nq=bn_div_words(n0,n1,d0);\\r\\n#ifdef BN_DEBUG_LEVITTE\\r\\nfprintf(stderr,\"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\\r\\nX) -> 0x%08X\\n\",\\r\\nn0, n1, d0, q);\\r\\n#endif\\r\\n#endif\\r\\n#ifndef REMAINDER_IS_ALREADY_CALCULATED\\r\\nrem=(n1-q*d0)&BN_MASK2;\\r\\n#endif\\r\\nt2=(BN_ULLONG)d1*q;\\r\\nfor (;;)\\r\\n{\\r\\nif (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0) break;\\r\\nt2 -= d1;\\r\\n}\\r\\n#else\\r\\nBN_ULONG t2l,t2h,ql,qh;\\r\\nq=bn_div_words(n0,n1,d0);\\r\\n#ifdef BN_DEBUG_LEVITTE\\r\\nfprintf(stderr,\"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\\r\\nX) -> 0x%08X\\n\",\\r\\nn0, n1, d0, q);\\r\\n#endif\\r\\n#ifndef REMAINDER_IS_ALREADY_CALCULATED\\r\\nrem=(n1-q*d0)&BN_MASK2;\\r\\n#endif\\r\\n#if defined(BN_UMULT_LOHI)\\r\\nBN_UMULT_LOHI(t2l,t2h,d1,q);\\r\\n#elif defined(BN_UMULT_HIGH)\\r\\nt2l = d1 * q;\\r\\nt2h = BN_UMULT_HIGH(d1,q);\\r\\n#else\\r\\nt2l=LBITS(d1); t2h=HBITS(d1);\\r\\nql =LBITS(q); qh =HBITS(q);\\r\\nmul64(t2l,t2h,ql,qh);\\r\\n#endif\\r\\nfor (;;)\\r\\n{\\r\\nif ((t2h < rem) ||\\r\\n((t2h == rem) && (t2l <= wnump[-2])))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0) break;\\r\\nif (t2l < d1) t2h--; t2l -= d1;\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#endif\\r\\nl0=bn_mul_words(tmp->d,sdiv->d,div_n,q);\\r\\ntmp->d[div_n]=l0;\\r\\nwnum.d--;\\r\\nif (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n+1))\\r\\n{\\r\\nq--;\\r\\nif (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))\\r\\n(*wnump)++;\\r\\n}\\r\\n*resp = q;\\r\\n}\\r\\nbn_correct_top(snum);\\r\\nif (rm != NULL)\\r\\n{\\r\\nint neg = num->neg;\\r\\nBN_rshift(rm,snum,norm_shift);\\r\\nif (!BN_is_zero(rm))\\r\\nrm->neg = neg;\\r\\nbn_check_top(rm);\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (rm)\\r\\nbn_check_top(rm);\\r\\nBN_CTX_end(ctx);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_time_c", "target": 0, "func": "ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t)\\r\\n{\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nts=OPENSSL_gmtime(&t,&data);\\r\\nif (ts == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TIME_SET, ASN1_R_ERROR_GETTING_TIME);\\r\\nreturn NULL;\\r\\n}\\r\\nif((ts->tm_year >= 50) && (ts->tm_year < 150))\\r\\nreturn ASN1_UTCTIME_set(s, t);\\r\\nreturn ASN1_GENERALIZEDTIME_set(s,t);\\r\\n}\\r\\nint ASN1_TIME_check(ASN1_TIME *t)\\r\\n{\\r\\nif (t->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_check(t);\\r\\nelse if (t->type == V_ASN1_UTCTIME)\\r\\nreturn ASN1_UTCTIME_check(t);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out)\\r\\n{\\r\\nASN1_GENERALIZEDTIME *ret;\\r\\nchar *str;\\r\\nint newlen;\\r\\nif (!ASN1_TIME_check(t)) return NULL;\\r\\nif (!out || !*out)\\r\\n{\\r\\nif (!(ret = ASN1_GENERALIZEDTIME_new ()))\\r\\nreturn NULL;\\r\\nif (out) *out = ret;\\r\\n}\\r\\nelse ret = *out;\\r\\nif (t->type == V_ASN1_GENERALIZEDTIME)\\r\\n{\\r\\nif(!ASN1_STRING_set(ret, t->data, t->length))\\r\\nreturn NULL;\\r\\nreturn ret;\\r\\n}\\r\\nif (!ASN1_STRING_set(ret, NULL, t->length + 2))\\r\\nreturn NULL;\\r\\nnewlen = t->length + 2 + 1;\\r\\nstr = (char *)ret->data;\\r\\nif (t->data[0] >= '5') BUF_strlcpy(str, \"19\", newlen);\\r\\nelse BUF_strlcpy(str, \"20\", newlen);\\r\\nBUF_strlcat(str, (char *)t->data, newlen);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sha512t_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nprintf(\"No SHA512 support\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nint main ()\\r\\n{ unsigned char md[SHA512_DIGEST_LENGTH];\\r\\nint i;\\r\\nEVP_MD_CTX evp;\\r\\n#ifdef OPENSSL_IA32_SSE2\\r\\n{ char *env;\\r\\nif ((env=getenv(\"OPENSSL_ia32cap\")))\\r\\nOPENSSL_ia32cap = strtoul (env,NULL,0);\\r\\n}\\r\\n#endif\\r\\nfprintf(stdout,\"Testing SHA-512 \");\\r\\nEVP_Digest (\"abc\",3,md,NULL,EVP_sha512(),NULL);\\r\\nif (memcmp(md,app_c1,sizeof(app_c1)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 1 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_Digest (\"abcdefgh\"\"bcdefghi\"\"cdefghij\"\"defghijk\"\\r\\n\"efghijkl\"\"fghijklm\"\"ghijklmn\"\"hijklmno\"\\r\\n\"ijklmnop\"\"jklmnopq\"\"klmnopqr\"\"lmnopqrs\"\\r\\n\"mnopqrst\"\"nopqrstu\",112,md,NULL,EVP_sha512(),NULL);\\r\\nif (memcmp(md,app_c2,sizeof(app_c2)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 2 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_MD_CTX_init (&evp);\\r\\nEVP_DigestInit_ex (&evp,EVP_sha512(),NULL);\\r\\nfor (i=0;i<1000000;i+=288)\\r\\nEVP_DigestUpdate (&evp, \"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\",\\r\\n(1000000-i)<288?1000000-i:288);\\r\\nEVP_DigestFinal_ex (&evp,md,NULL);\\r\\nEVP_MD_CTX_cleanup (&evp);\\r\\nif (memcmp(md,app_c3,sizeof(app_c3)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 3 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nfprintf(stdout,\" passed.\\n\"); fflush(stdout);\\r\\nfprintf(stdout,\"Testing SHA-384 \");\\r\\nEVP_Digest (\"abc\",3,md,NULL,EVP_sha384(),NULL);\\r\\nif (memcmp(md,app_d1,sizeof(app_d1)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 1 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_Digest (\"abcdefgh\"\"bcdefghi\"\"cdefghij\"\"defghijk\"\\r\\n\"efghijkl\"\"fghijklm\"\"ghijklmn\"\"hijklmno\"\\r\\n\"ijklmnop\"\"jklmnopq\"\"klmnopqr\"\"lmnopqrs\"\\r\\n\"mnopqrst\"\"nopqrstu\",112,md,NULL,EVP_sha384(),NULL);\\r\\nif (memcmp(md,app_d2,sizeof(app_d2)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 2 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nEVP_MD_CTX_init (&evp);\\r\\nEVP_DigestInit_ex (&evp,EVP_sha384(),NULL);\\r\\nfor (i=0;i<1000000;i+=64)\\r\\nEVP_DigestUpdate (&evp, \"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\\r\\n\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\"\"aaaaaaaa\",\\r\\n(1000000-i)<64?1000000-i:64);\\r\\nEVP_DigestFinal_ex (&evp,md,NULL);\\r\\nEVP_MD_CTX_cleanup (&evp);\\r\\nif (memcmp(md,app_d3,sizeof(app_d3)))\\r\\n{ fflush(stdout);\\r\\nfprintf(stderr,\"\\nTEST 3 of 3 failed.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nelse\\r\\nfprintf(stdout,\".\"); fflush(stdout);\\r\\nfprintf(stdout,\" passed.\\n\""
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecs_err_c", "target": 0, "func": "void ERR_load_ECDSA_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,ECDSA_str_functs);\\r\\nERR_load_strings(0,ECDSA_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_bignum_c", "target": 0, "func": "static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(!*pval) return;\\r\\nif(it->size & BN_SENSITIVE) BN_clear_free((BIGNUM *)*pval);\\r\\nelse BN_free((BIGNUM *)*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nstatic int bn_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it)\\r\\n{\\r\\nBIGNUM *bn;\\r\\nint pad;\\r\\nif(!*pval) return -1;\\r\\nbn = (BIGNUM *)*pval;\\r\\nif(BN_num_bits(bn) & 0x7) pad = 0;\\r\\nelse pad = 1;\\r\\nif(cont) {\\r\\nif(pad) *cont++ = 0;\\r\\nBN_bn2bin(bn, cont);\\r\\n}\\r\\nreturn pad + BN_num_bytes(bn);\\r\\n}\\r\\nstatic int bn_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nBIGNUM *bn;\\r\\nif(!*pval) bn_new(pval, it);\\r\\nbn = (BIGNUM *)*pval;\\r\\nif(!BN_bin2bn(cont, len, bn)) {\\r\\nbn_free(pval, it);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_mpi_c", "target": 0, "func": "int BN_bn2mpi(const BIGNUM *a, unsigned char *d)\\r\\n{\\r\\nint bits;\\r\\nint num=0;\\r\\nint ext=0;\\r\\nlong l;\\r\\nbits=BN_num_bits(a);\\r\\nnum=(bits+7)/8;\\r\\nif (bits > 0)\\r\\n{\\r\\next=((bits & 0x07) == 0);\\r\\n}\\r\\nif (d == NULL)\\r\\nreturn(num+4+ext);\\r\\nl=num+ext;\\r\\nd[0]=(unsigned char)(l>>24)&0xff;\\r\\nd[1]=(unsigned char)(l>>16)&0xff;\\r\\nd[2]=(unsigned char)(l>> 8)&0xff;\\r\\nd[3]=(unsigned char)(l )&0xff;\\r\\nif (ext) d[4]=0;\\r\\nnum=BN_bn2bin(a,&(d[4+ext]));\\r\\nif (a->neg)\\r\\nd[4]|=0x80;\\r\\nreturn(num+4+ext);\\r\\n}\\r\\nBIGNUM *BN_mpi2bn(const unsigned char *d, int n, BIGNUM *a)\\r\\n{\\r\\nlong len;\\r\\nint neg=0;\\r\\nif (n < 4)\\r\\n{\\r\\nBNerr(BN_F_BN_MPI2BN,BN_R_INVALID_LENGTH);\\r\\nreturn(NULL);\\r\\n}\\r\\nlen=((long)d[0]<<24)|((long)d[1]<<16)|((int)d[2]<<8)|(int)d[3];\\r\\nif ((len+4) != n)\\r\\n{\\r\\nBNerr(BN_F_BN_MPI2BN,BN_R_ENCODING_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (a == NULL) a=BN_new();\\r\\nif (a == NULL) return(NULL);\\r\\nif (len == 0)\\r\\n{\\r\\na->neg=0;\\r\\na->top=0;\\r\\nreturn(a);\\r\\n}\\r\\nd+=4;\\r\\nif ((*d) & 0x80)\\r\\nneg=1;\\r\\nif (BN_bin2bn(d,(int)len,a) == NULL)\\r\\nreturn(NULL);\\r\\na->neg=neg;\\r\\nif (neg)\\r\\n{\\r\\nBN_clear_bit(a,BN_num_bits(a)-1);\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_allc_c", "target": 0, "func": "void OpenSSL_add_all_ciphers(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DES\\r\\nEVP_add_cipher(EVP_des_cfb());\\r\\nEVP_add_cipher(EVP_des_cfb1());\\r\\nEVP_add_cipher(EVP_des_cfb8());\\r\\nEVP_add_cipher(EVP_des_ede_cfb());\\r\\nEVP_add_cipher(EVP_des_ede3_cfb());\\r\\nEVP_add_cipher(EVP_des_ofb());\\r\\nEVP_add_cipher(EVP_des_ede_ofb());\\r\\nEVP_add_cipher(EVP_des_ede3_ofb());\\r\\nEVP_add_cipher(EVP_desx_cbc());\\r\\nEVP_add_cipher_alias(SN_desx_cbc,\"DESX\");\\r\\nEVP_add_cipher_alias(SN_desx_cbc,\"desx\");\\r\\nEVP_add_cipher(EVP_des_cbc());\\r\\nEVP_add_cipher_alias(SN_des_cbc,\"DES\");\\r\\nEVP_add_cipher_alias(SN_des_cbc,\"des\");\\r\\nEVP_add_cipher(EVP_des_ede_cbc());\\r\\nEVP_add_cipher(EVP_des_ede3_cbc());\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc,\"DES3\");\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc,\"des3\");\\r\\nEVP_add_cipher(EVP_des_ecb());\\r\\nEVP_add_cipher(EVP_des_ede());\\r\\nEVP_add_cipher(EVP_des_ede3());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nEVP_add_cipher(EVP_rc4());\\r\\nEVP_add_cipher(EVP_rc4_40());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nEVP_add_cipher(EVP_idea_ecb());\\r\\nEVP_add_cipher(EVP_idea_cfb());\\r\\nEVP_add_cipher(EVP_idea_ofb());\\r\\nEVP_add_cipher(EVP_idea_cbc());\\r\\nEVP_add_cipher_alias(SN_idea_cbc,\"IDEA\");\\r\\nEVP_add_cipher_alias(SN_idea_cbc,\"idea\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nEVP_add_cipher(EVP_rc2_ecb());\\r\\nEVP_add_cipher(EVP_rc2_cfb());\\r\\nEVP_add_cipher(EVP_rc2_ofb());\\r\\nEVP_add_cipher(EVP_rc2_cbc());\\r\\nEVP_add_cipher(EVP_rc2_40_cbc());\\r\\nEVP_add_cipher(EVP_rc2_64_cbc());\\r\\nEVP_add_cipher_alias(SN_rc2_cbc,\"RC2\");\\r\\nEVP_add_cipher_alias(SN_rc2_cbc,\"rc2\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_BF\\r\\nEVP_add_cipher(EVP_bf_ecb());\\r\\nEVP_add_cipher(EVP_bf_cfb());\\r\\nEVP_add_cipher(EVP_bf_ofb());\\r\\nEVP_add_cipher(EVP_bf_cbc());\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"BF\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"bf\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"blowfish\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_CAST\\r\\nEVP_add_cipher(EVP_cast5_ecb());\\r\\nEVP_add_cipher(EVP_cast5_cfb());\\r\\nEVP_add_cipher(EVP_cast5_ofb());\\r\\nEVP_add_cipher(EVP_cast5_cbc());\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"CAST\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"cast\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"CAST-cbc\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"cast-cbc\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC5\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ecb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cfb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ofb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cbc());\\r\\nEVP_add_cipher_alias(SN_rc5_cbc,\"rc5\");\\r\\nEVP_add_cipher_alias(SN_rc5_cbc,\"RC5\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nEVP_add_cipher(EVP_aes_128_ecb());\\r\\nEVP_add_cipher(EVP_aes_128_cbc());\\r\\nEVP_add_cipher(EVP_aes_128_cfb());\\r\\nEVP_add_cipher(EVP_aes_128_cfb1());\\r\\nEVP_add_cipher(EVP_aes_128_cfb8());\\r\\nEVP_add_cipher(EVP_aes_128_ofb());\\r\\n#if 0\\r\\nEVP_add_cipher(EVP_aes_128_ctr());\\r\\n#endif\\r\\nEVP_add_cipher_alias(SN_aes_128_cbc,\"AES128\");\\r\\nEVP_add_cipher_alias(SN_aes_128_cbc,\"aes128\");\\r\\nEVP_add_cipher(EVP_aes_192_ecb());\\r\\nEVP_add_cipher(EVP_aes_192_cbc());\\r\\nEVP_add_cipher(EVP_aes_192_cfb());\\r\\nEVP_add_cipher(EVP_aes_192_cfb1());\\r\\nEVP_add_cipher(EVP_aes_192_cfb8());\\r\\nEVP_add_cipher(EVP_aes_192_ofb());\\r\\n#if 0\\r\\nEVP_add_cipher(EVP_aes_192_ctr());\\r\\n#endif\\r\\nEVP_add_cipher_alias(SN_aes_192_cbc,\"AES192\");\\r\\nEVP_add_cipher_alias(SN_aes_192_cbc,\"aes192\");\\r\\nEVP_add_cipher(EVP_aes_256_ecb());\\r\\nEVP_add_cipher(EVP_aes_256_cbc());\\r\\nEVP_add_cipher(EVP_aes_256_cfb());\\r\\nEVP_add_cipher(EVP_aes_256_cfb1());\\r\\nEVP_add_cipher(EVP_aes_256_cfb8());\\r\\nEVP_add_cipher(EVP_aes_256_ofb());\\r\\n#if 0\\r\\nEVP_add_cipher(EVP_aes_256_ctr());\\r\\n#endif\\r\\nEVP_add_cipher_alias(SN_aes_256_cbc,\"AES256\");\\r\\nEVP_add_cipher_alias(SN_aes_256_cbc,\"aes256\");\\r\\n#endif\\r\\nPKCS12_PBE_add();\\r\\nPKCS5_PBE_add();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_md2_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"MD2(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\nreturn(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nMD2_CTX c;\\r\\nunsigned char md[MD2_DIGEST_LENGTH];\\r\\nint fd,i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nMD2_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nMD2_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nMD2_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<MD2_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ech_lib_c", "target": 0, "func": "void ECDH_set_default_method(const ECDH_METHOD *meth)\\r\\n{\\r\\ndefault_ECDH_method = meth;\\r\\n}\\r\\nconst ECDH_METHOD *ECDH_get_default_method(void)\\r\\n{\\r\\nif(!default_ECDH_method)\\r\\ndefault_ECDH_method = ECDH_OpenSSL();\\r\\nreturn default_ECDH_method;\\r\\n}\\r\\nint ECDH_set_method(EC_KEY *eckey, const ECDH_METHOD *meth)\\r\\n{\\r\\nconst ECDH_METHOD *mtmp;\\r\\nECDH_DATA *ecdh;\\r\\necdh = ecdh_check(eckey);\\r\\nif (ecdh == NULL)\\r\\nreturn 0;\\r\\nmtmp = ecdh->meth;\\r\\n#if 0\\r\\nif (mtmp->finish)\\r\\nmtmp->finish(eckey);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ecdh->engine)\\r\\n{\\r\\nENGINE_finish(ecdh->engine);\\r\\necdh->engine = NULL;\\r\\n}\\r\\n#endif\\r\\necdh->meth = meth;\\r\\n#if 0\\r\\nif (meth->init)\\r\\nmeth->init(eckey);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic ECDH_DATA *ECDH_DATA_new_method(ENGINE *engine)\\r\\n{\\r\\nECDH_DATA *ret;\\r\\nret=(ECDH_DATA *)OPENSSL_malloc(sizeof(ECDH_DATA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_DATA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->init = NULL;\\r\\nret->meth = ECDH_get_default_method();\\r\\nret->engine = engine;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (!ret->engine)\\r\\nret->engine = ENGINE_get_default_ECDH();\\r\\nif (ret->engine)\\r\\n{\\r\\nret->meth = ENGINE_get_ECDH(ret->engine);\\r\\nif (!ret->meth)\\r\\n{\\r\\nECDHerr(ECDH_F_ECDH_DATA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->flags = ret->meth->flags;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_ECDH, ret, &ret->ex_data);\\r\\n#if 0\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ECDH, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void *ecdh_data_new(void)\\r\\n{\\r\\nreturn (void *)ECDH_DATA_new_method(NULL);\\r\\n}\\r\\nstatic void *ecdh_data_dup(void *data)\\r\\n{\\r\\nECDH_DATA *r = (ECDH_DATA *)data;\\r\\nif (r == NULL)\\r\\nreturn NULL;\\r\\nreturn (void *)ecdh_data_new();\\r\\n}\\r\\nvoid ecdh_data_free(void *data)\\r\\n{\\r\\nECDH_DATA *r = (ECDH_DATA *)data;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ECDH, r, &r->ex_data);\\r\\nOPENSSL_cleanse((void *)r, sizeof(ECDH_DATA));\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nECDH_DATA *ecdh_check(EC_KEY *key)\\r\\n{\\r\\nECDH_DATA *ecdh_data;\\r\\nvoid *data = EC_KEY_get_key_method_data(key, ecdh_data_dup,\\r\\necdh_data_free, ecdh_data_free);\\r\\nif (data == NULL)\\r\\n{\\r\\necdh_data = (ECDH_DATA *)ecdh_data_new();\\r\\nif (ecdh_data == NULL)\\r\\nreturn NULL;\\r\\nEC_KEY_insert_key_method_data(key, (void *)ecdh_data,\\r\\necdh_data_dup, ecdh_data_free, ecdh_data_free);\\r\\n}\\r\\nelse\\r\\necdh_data = (ECDH_DATA *)data;\\r\\nreturn ecdh_data;\\r\\n}\\r\\nint ECDH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ECDH, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint ECDH_set_ex_data(EC_KEY *d, int idx, void *arg)\\r\\n{\\r\\nECDH_DATA *ecdh;\\r\\necdh = ecdh_check(d);\\r\\nif (ecdh == NULL)\\r\\nreturn 0;\\r\\nreturn(CRYPTO_set_ex_data(&ecdh->ex_data,idx,arg));\\r\\n}\\r\\nvoid *ECDH_get_ex_data(EC_KEY *d, int idx)\\r\\n{\\r\\nECDH_DATA *ecdh;\\r\\necdh = ecdh_check(d);\\r\\nif (ecdh == NULL)\\r\\nreturn NULL;\\r\\nreturn(CRYPTO_get_ex_data(&ecdh->ex_data,idx));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3prin_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nint i, count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif(!argv[1]) {\\r\\nfprintf(stderr, \"Usage v3prin cert.pem\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif(!(inf = fopen(argv[1], \"r\"))) {\\r\\nfprintf(stderr, \"Can't open %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nif(!(cert = PEM_read_X509(inf, NULL, NULL))) {\\r\\nfprintf(stderr, \"Can't read certificate %s\\n\", argv[1]);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor(i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\\n\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif(!X509V3_EXT_print_fp(stdout, ext, 0, 0)) ERR_print_errors_fp(stderr);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_cbc_c", "target": 0, "func": "void BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0,tin1;\\r\\nregister BF_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(ivec,tout0);\\r\\nn2l(ivec,tout1);\\r\\nivec-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,schedule);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,schedule);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,ivec);\\r\\nl2n(tout1,ivec);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(ivec,xor0);\\r\\nn2l(ivec,xor1);\\r\\nivec-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,schedule);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,schedule);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,ivec);\\r\\nl2n(xor1,ivec);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cb_c", "target": 0, "func": "void cb_ssl_info(const SSL *s, int where, int ret)\\r\\n{\\r\\nconst char *str1, *str2;\\r\\nint w;\\r\\nif(!fp_cb_ssl_info)\\r\\nreturn;\\r\\nw = where & ~SSL_ST_MASK;\\r\\nstr1 = (w & SSL_ST_CONNECT ? \"SSL_connect\" : (w & SSL_ST_ACCEPT ?\\r\\n\"SSL_accept\" : \"undefined\")),\\r\\nstr2 = SSL_state_string_long(s);\\r\\nif (where & SSL_CB_LOOP)\\r\\nfprintf(fp_cb_ssl_info, \"(%s) %s\\n\", str1, str2);\\r\\nelse if (where & SSL_CB_EXIT) {\\r\\nif (ret == 0)\\r\\nfprintf(fp_cb_ssl_info, \"(%s) failed in %s\\n\", str1, str2);\\r\\n#if 0\\r\\nelse if (ret < 0)\\r\\nfprintf(fp_cb_ssl_info, \"%s:error in %s\\n\", str1, str2);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nvoid cb_ssl_info_set_output(FILE *fp)\\r\\n{\\r\\nfp_cb_ssl_info = fp;\\r\\n}\\r\\nint cb_ssl_verify(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf1[256];\\r\\nchar buf2[256];\\r\\nconst char *reason = NULL;\\r\\nX509 *err_cert;\\r\\nint err, depth;\\r\\nif(!fp_cb_ssl_verify || (cb_ssl_verify_level == 0))\\r\\nreturn ok;\\r\\nerr_cert = X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr = X509_STORE_CTX_get_error(ctx);\\r\\ndepth = X509_STORE_CTX_get_error_depth(ctx);\\r\\nbuf1[0] = buf2[0] = '\\0';\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert), buf1, 256);\\r\\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), buf2, 256);\\r\\nswitch (ctx->error) {\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nreason = int_reason_no_issuer;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\nreason = int_reason_not_yet;\\r\\nbreak;\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nreason = int_reason_before;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\nreason = int_reason_expired;\\r\\nbreak;\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nreason = int_reason_after;\\r\\nbreak;\\r\\n}\\r\\nif((cb_ssl_verify_level == 1) && ok)\\r\\nreturn ok;\\r\\nfprintf(fp_cb_ssl_verify, \"chain-depth=%d, \", depth);\\r\\nif(reason)\\r\\nfprintf(fp_cb_ssl_verify, \"error=%s\\n\", reason);\\r\\nelse\\r\\nfprintf(fp_cb_ssl_verify, \"error=%d\\n\", err);\\r\\nif(cb_ssl_verify_level < 3)\\r\\nreturn ok;\\r\\nfprintf(fp_cb_ssl_verify, \"--> subject = %s\\n\", buf1);\\r\\nfprintf(fp_cb_ssl_verify, \"--> issuer = %s\\n\", buf2);\\r\\nif(!ok)\\r\\nfprintf(fp_cb_ssl_verify,\"--> verify error:num=%d:%s\\n\",err,\\r\\nX509_verify_cert_error_string(err));\\r\\nfprintf(fp_cb_ssl_verify, \"--> verify return:%d\\n\",ok);\\r\\nreturn ok;\\r\\n}\\r\\nvoid cb_ssl_verify_set_output(FILE *fp)\\r\\n{\\r\\nfp_cb_ssl_verify = fp;\\r\\n}\\r\\nvoid cb_ssl_verify_set_depth(unsigned int verify_depth)\\r\\n{\\r\\nint_verify_depth = verify_depth;\\r\\n}\\r\\nvoid cb_ssl_verify_set_level(unsigned int level)\\r\\n{\\r\\nif(level < 4)\\r\\ncb_ssl_verify_level = level;\\r\\n}\\r\\nRSA *cb_generate_tmp_rsa(SSL *s, int is_export, int keylength)\\r\\n{\\r\\nstatic RSA *rsa_tmp = NULL;\\r\\nif(!rsa_tmp)\\r\\nrsa_tmp = RSA_generate_key(keylength, RSA_F4, NULL, NULL);\\r\\nreturn rsa_tmp;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_new_c", "target": 0, "func": "ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_VALUE *ret = NULL;\\r\\nif (ASN1_item_ex_new(&ret, it) > 0)\\r\\nreturn ret;\\r\\nreturn NULL;\\r\\n}\\r\\nint ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_ex_combine_new(pval, it, 0);\\r\\n}\\r\\nstatic int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nint combine)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nASN1_VALUE **pseqval;\\r\\nint i;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse\\r\\nasn1_cb = 0;\\r\\nif (!combine) *pval = NULL;\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_push_info(it->sname);\\r\\n#endif\\r\\nswitch(it->itype)\\r\\n{\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_new)\\r\\n{\\r\\nif (!ef->asn1_ex_new(pval, it))\\r\\ngoto memerr;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (cf && cf->asn1_new) {\\r\\n*pval = cf->asn1_new();\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\n{\\r\\nif (!ASN1_template_new(pval, it->templates))\\r\\ngoto memerr;\\r\\n}\\r\\nelse if (!ASN1_primitive_new(pval, it))\\r\\ngoto memerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nif (!ASN1_primitive_new(pval, it))\\r\\ngoto memerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb)\\r\\n{\\r\\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it);\\r\\nif (!i)\\r\\ngoto auxerr;\\r\\nif (i==2)\\r\\n{\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (!combine)\\r\\n{\\r\\n*pval = OPENSSL_malloc(it->size);\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\nmemset(*pval, 0, it->size);\\r\\n}\\r\\nasn1_set_choice_selector(pval, -1, it);\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it))\\r\\ngoto auxerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\nif (asn1_cb)\\r\\n{\\r\\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it);\\r\\nif (!i)\\r\\ngoto auxerr;\\r\\nif (i==2)\\r\\n{\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (!combine)\\r\\n{\\r\\n*pval = OPENSSL_malloc(it->size);\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\nmemset(*pval, 0, it->size);\\r\\nasn1_do_lock(pval, 0, it);\\r\\nasn1_enc_init(pval, it);\\r\\n}\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\\r\\n{\\r\\npseqval = asn1_get_field_ptr(pval, tt);\\r\\nif (!ASN1_template_new(pseqval, tt))\\r\\ngoto memerr;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it))\\r\\ngoto auxerr;\\r\\nbreak;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname) CRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\nmemerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ERR_R_MALLOC_FAILURE);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname) CRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 0;\\r\\nauxerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ASN1_R_AUX_ERROR);\\r\\nASN1_item_ex_free(pval, it);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname) CRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 0;\\r\\n}\\r\\nstatic void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nswitch(it->itype)\\r\\n{\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_clear)\\r\\nef->asn1_ex_clear(pval, it);\\r\\nelse *pval = NULL;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nasn1_template_clear(pval, it->templates);\\r\\nelse\\r\\nasn1_primitive_clear(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nasn1_primitive_clear(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\n*pval = NULL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nconst ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);\\r\\nint ret;\\r\\nif (tt->flags & ASN1_TFLG_OPTIONAL)\\r\\n{\\r\\nasn1_template_clear(pval, tt);\\r\\nreturn 1;\\r\\n}\\r\\nif (tt->flags & ASN1_TFLG_ADB_MASK)\\r\\n{\\r\\n*pval = NULL;\\r\\nreturn 1;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (tt->field_name)\\r\\nCRYPTO_push_info(tt->field_name);\\r\\n#endif\\r\\nif (tt->flags & ASN1_TFLG_SK_MASK)\\r\\n{\\r\\nSTACK_OF(ASN1_VALUE) *skval;\\r\\nskval = sk_ASN1_VALUE_new_null();\\r\\nif (!skval)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);\\r\\nret = 0;\\r\\ngoto done;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)skval;\\r\\nret = 1;\\r\\ngoto done;\\r\\n}\\r\\nret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);\\r\\ndone:\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nstatic void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nif (tt->flags & (ASN1_TFLG_ADB_MASK|ASN1_TFLG_SK_MASK))\\r\\n*pval = NULL;\\r\\nelse\\r\\nasn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));\\r\\n}\\r\\nint ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_TYPE *typ;\\r\\nint utype;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_new)\\r\\nreturn pf->prim_new(pval, it);\\r\\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\\r\\nutype = -1;\\r\\nelse\\r\\nutype = it->utype;\\r\\nswitch(utype)\\r\\n{\\r\\ncase V_ASN1_OBJECT:\\r\\n*pval = (ASN1_VALUE *)OBJ_nid2obj(NID_undef);\\r\\nreturn 1;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (it)\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nelse\\r\\n*(ASN1_BOOLEAN *)pval = -1;\\r\\nreturn 1;\\r\\ncase V_ASN1_NULL:\\r\\n*pval = (ASN1_VALUE *)1;\\r\\nreturn 1;\\r\\ncase V_ASN1_ANY:\\r\\ntyp = OPENSSL_malloc(sizeof(ASN1_TYPE));\\r\\nif (!typ)\\r\\nreturn 0;\\r\\ntyp->value.ptr = NULL;\\r\\ntyp->type = -1;\\r\\n*pval = (ASN1_VALUE *)typ;\\r\\nbreak;\\r\\ndefault:\\r\\n*pval = (ASN1_VALUE *)ASN1_STRING_type_new(utype);\\r\\nbreak;\\r\\n}\\r\\nif (*pval)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nvoid asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint utype;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf)\\r\\n{\\r\\nif (pf->prim_clear)\\r\\npf->prim_clear(pval, it);\\r\\nelse\\r\\n*pval = NULL;\\r\\nreturn;\\r\\n}\\r\\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\\r\\nutype = -1;\\r\\nelse\\r\\nutype = it->utype;\\r\\nif (utype == V_ASN1_BOOLEAN)\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nelse *pval = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_both_c", "target": 0, "func": "static hm_fragment *\\r\\ndtls1_hm_fragment_new(unsigned long frag_len)\\r\\n{\\r\\nhm_fragment *frag = NULL;\\r\\nunsigned char *buf = NULL;\\r\\nfrag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));\\r\\nif ( frag == NULL)\\r\\nreturn NULL;\\r\\nbuf = (unsigned char *)OPENSSL_malloc(frag_len\\r\\n+ DTLS1_HM_HEADER_LENGTH);\\r\\nif ( buf == NULL)\\r\\n{\\r\\nOPENSSL_free(frag);\\r\\nreturn NULL;\\r\\n}\\r\\nfrag->fragment = buf;\\r\\nreturn frag;\\r\\n}\\r\\nstatic void\\r\\ndtls1_hm_fragment_free(hm_fragment *frag)\\r\\n{\\r\\nOPENSSL_free(frag->fragment);\\r\\nOPENSSL_free(frag);\\r\\n}\\r\\nint dtls1_do_write(SSL *s, int type)\\r\\n{\\r\\nint ret;\\r\\nint curr_mtu;\\r\\nunsigned int len, frag_off;\\r\\nif ( ! (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU))\\r\\n{\\r\\ns->d1->mtu =\\r\\nBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\\r\\nif ( s->d1->mtu < dtls1_min_mtu())\\r\\n{\\r\\ns->d1->mtu = 0;\\r\\ns->d1->mtu = dtls1_guess_mtu(s->d1->mtu);\\r\\nBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SET_MTU,\\r\\ns->d1->mtu, NULL);\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nmtu = s->d1->mtu;\\r\\nfprintf(stderr, \"using MTU = %d\\n\", mtu);\\r\\nmtu -= (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);\\r\\ncurr_mtu = mtu - BIO_wpending(SSL_get_wbio(s));\\r\\nif ( curr_mtu > 0)\\r\\nmtu = curr_mtu;\\r\\nelse if ( ( ret = BIO_flush(SSL_get_wbio(s))) <= 0)\\r\\nreturn ret;\\r\\nif ( BIO_wpending(SSL_get_wbio(s)) + s->init_num >= mtu)\\r\\n{\\r\\nret = BIO_flush(SSL_get_wbio(s));\\r\\nif ( ret <= 0)\\r\\nreturn ret;\\r\\nmtu = s->d1->mtu - (DTLS1_HM_HEADER_LENGTH + DTLS1_RT_HEADER_LENGTH);\\r\\n}\\r\\nOPENSSL_assert(mtu > 0);\\r\\n#endif\\r\\nif ( s->init_off == 0 && type == SSL3_RT_HANDSHAKE)\\r\\nOPENSSL_assert(s->init_num ==\\r\\n(int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);\\r\\nfrag_off = 0;\\r\\nwhile( s->init_num)\\r\\n{\\r\\ncurr_mtu = s->d1->mtu - BIO_wpending(SSL_get_wbio(s)) -\\r\\nDTLS1_RT_HEADER_LENGTH;\\r\\nif ( curr_mtu <= DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\nret = BIO_flush(SSL_get_wbio(s));\\r\\nif ( ret <= 0)\\r\\nreturn ret;\\r\\ncurr_mtu = s->d1->mtu - DTLS1_RT_HEADER_LENGTH;\\r\\n}\\r\\nif ( s->init_num > curr_mtu)\\r\\nlen = curr_mtu;\\r\\nelse\\r\\nlen = s->init_num;\\r\\nif ( type == SSL3_RT_HANDSHAKE)\\r\\n{\\r\\nif ( s->init_off != 0)\\r\\n{\\r\\nOPENSSL_assert(s->init_off > DTLS1_HM_HEADER_LENGTH);\\r\\ns->init_off -= DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_num += DTLS1_HM_HEADER_LENGTH;\\r\\nif ( len <= DTLS1_HM_HEADER_LENGTH)\\r\\nlen += DTLS1_HM_HEADER_LENGTH;\\r\\n}\\r\\ndtls1_fix_message_header(s, frag_off,\\r\\nlen - DTLS1_HM_HEADER_LENGTH);\\r\\ndtls1_write_message_header(s, (unsigned char *)&s->init_buf->data[s->init_off]);\\r\\nOPENSSL_assert(len >= DTLS1_HM_HEADER_LENGTH);\\r\\n}\\r\\nret=dtls1_write_bytes(s,type,&s->init_buf->data[s->init_off],\\r\\nlen);\\r\\nif (ret < 0)\\r\\n{\\r\\nif ( BIO_ctrl(SSL_get_wbio(s),\\r\\nBIO_CTRL_DGRAM_MTU_EXCEEDED, 0, NULL))\\r\\ns->d1->mtu = BIO_ctrl(SSL_get_wbio(s),\\r\\nBIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\\r\\nelse\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nOPENSSL_assert(len == (unsigned int)ret);\\r\\nif (type == SSL3_RT_HANDSHAKE && ! s->d1->retransmitting)\\r\\nssl3_finish_mac(s,\\r\\n(unsigned char *)&s->init_buf->data[s->init_off +\\r\\nDTLS1_HM_HEADER_LENGTH], ret - DTLS1_HM_HEADER_LENGTH);\\r\\nif (ret == s->init_num)\\r\\n{\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, type, s->init_buf->data,\\r\\n(size_t)(s->init_off + s->init_num), s,\\r\\ns->msg_callback_arg);\\r\\ns->init_off = 0;\\r\\ns->init_num = 0;\\r\\nreturn(1);\\r\\n}\\r\\ns->init_off+=ret;\\r\\ns->init_num-=ret;\\r\\nfrag_off += (ret -= DTLS1_HM_HEADER_LENGTH);\\r\\n}\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nlong dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\\r\\n{\\r\\nint i, al;\\r\\nif (s->s3->tmp.reuse_message)\\r\\n{\\r\\ns->s3->tmp.reuse_message=0;\\r\\nif ((mt >= 0) && (s->s3->tmp.message_type != mt))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n*ok=1;\\r\\ns->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_num = (int)s->s3->tmp.message_size;\\r\\nreturn s->init_num;\\r\\n}\\r\\ndo\\r\\n{\\r\\nif ( s->d1->r_msg_hdr.frag_off == 0)\\r\\n{\\r\\nmemset(&(s->d1->r_msg_hdr), 0x00, sizeof(struct hm_header_st));\\r\\n}\\r\\ni = dtls1_get_message_fragment(s, st1, stn, max, ok);\\r\\nif ( i == DTLS1_HM_BAD_FRAGMENT ||\\r\\ni == DTLS1_HM_FRAGMENT_RETRY)\\r\\ncontinue;\\r\\nelse if ( i <= 0 && !*ok)\\r\\nreturn i;\\r\\nif (s->d1->r_msg_hdr.msg_len == (unsigned int)s->init_num - DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\nmemset(&(s->d1->r_msg_hdr), 0x00, sizeof(struct hm_header_st));\\r\\ns->d1->handshake_read_seq++;\\r\\ndtls1_clear_record_buffer(s);\\r\\ns->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\\r\\nreturn s->init_num - DTLS1_HM_HEADER_LENGTH;\\r\\n}\\r\\nelse\\r\\ns->d1->r_msg_hdr.frag_off = i;\\r\\n} while(1) ;\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n*ok = 0;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int\\r\\ndtls1_retrieve_buffered_fragment(SSL *s, unsigned long *copied)\\r\\n{\\r\\npitem *item;\\r\\nhm_fragment *frag;\\r\\nunsigned long overlap;\\r\\nunsigned char *p;\\r\\nitem = pqueue_peek(s->d1->buffered_messages);\\r\\nif ( item == NULL)\\r\\nreturn 0;\\r\\nfrag = (hm_fragment *)item->data;\\r\\nif ( s->d1->handshake_read_seq == frag->msg_header.seq &&\\r\\nfrag->msg_header.frag_off <= (unsigned int)s->init_num - DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\npqueue_pop(s->d1->buffered_messages);\\r\\noverlap = s->init_num - DTLS1_HM_HEADER_LENGTH\\r\\n- frag->msg_header.frag_off;\\r\\np = frag->fragment;\\r\\nmemcpy(&s->init_buf->data[s->init_num],\\r\\np + DTLS1_HM_HEADER_LENGTH + overlap,\\r\\nfrag->msg_header.frag_len - overlap);\\r\\nOPENSSL_free(frag->fragment);\\r\\nOPENSSL_free(frag);\\r\\npitem_free(item);\\r\\n*copied = frag->msg_header.frag_len - overlap;\\r\\nreturn *copied;\\r\\n}\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic int\\r\\ndtls1_buffer_handshake_fragment(SSL *s, struct hm_header_st* msg_hdr)\\r\\n{\\r\\nhm_fragment *frag = NULL;\\r\\npitem *item = NULL;\\r\\nPQ_64BIT seq64;\\r\\nfrag = dtls1_hm_fragment_new(msg_hdr->frag_len);\\r\\nif ( frag == NULL)\\r\\ngoto err;\\r\\nmemcpy(frag->fragment, &(s->init_buf->data[s->init_num]),\\r\\nmsg_hdr->frag_len + DTLS1_HM_HEADER_LENGTH);\\r\\nmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\\r\\npq_64bit_init(&seq64);\\r\\npq_64bit_assign_word(&seq64, msg_hdr->seq);\\r\\nitem = pitem_new(seq64, frag);\\r\\nif ( item == NULL)\\r\\ngoto err;\\r\\npq_64bit_free(&seq64);\\r\\npqueue_insert(s->d1->buffered_messages, item);\\r\\nreturn 1;\\r\\nerr:\\r\\nif ( frag != NULL) dtls1_hm_fragment_free(frag);\\r\\nif ( item != NULL) OPENSSL_free(item);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void\\r\\ndtls1_process_handshake_fragment(SSL *s, int frag_len)\\r\\n{\\r\\nunsigned char *p;\\r\\np = (unsigned char *)s->init_buf->data;\\r\\nssl3_finish_mac(s, &p[s->init_num - frag_len], frag_len);\\r\\n}\\r\\nstatic int\\r\\ndtls1_process_out_of_seq_message(SSL *s, struct hm_header_st *msg_hdr, int *ok)\\r\\n{\\r\\nint i;\\r\\nunsigned char *p;\\r\\nif ( (int)msg_hdr->frag_len && !BUF_MEM_grow_clean(s->init_buf,\\r\\n(int)msg_hdr->frag_len + DTLS1_HM_HEADER_LENGTH + s->init_num))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np = (unsigned char *)s->init_buf->data;\\r\\nif ( msg_hdr->frag_len > 0)\\r\\n{\\r\\ni=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\\r\\n&p[s->init_num],\\r\\nmsg_hdr->frag_len,0);\\r\\nif (i <= 0)\\r\\n{\\r\\n*ok = 0;\\r\\nreturn i;\\r\\n}\\r\\n}\\r\\nif ( msg_hdr->seq > s->d1->handshake_read_seq)\\r\\ndtls1_buffer_handshake_fragment(s, msg_hdr);\\r\\nelse\\r\\nOPENSSL_assert(msg_hdr->seq < s->d1->handshake_read_seq);\\r\\nreturn DTLS1_HM_FRAGMENT_RETRY;\\r\\nerr:\\r\\n*ok = 0;\\r\\nreturn -1;\\r\\n}\\r\\nstatic long\\r\\ndtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned long l, frag_off, frag_len;\\r\\nint i,al;\\r\\nstruct hm_header_st msg_hdr;\\r\\nunsigned long overlap;\\r\\nif (dtls1_retrieve_buffered_fragment(s, &l))\\r\\n{\\r\\ndtls1_process_handshake_fragment(s, l);\\r\\ns->init_msg = s->init_buf->data + DTLS1_HM_HEADER_LENGTH;\\r\\ns->state = stn;\\r\\nreturn 1;\\r\\n}\\r\\np = (unsigned char *)s->init_buf->data;\\r\\ni=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\\r\\nDTLS1_HM_HEADER_LENGTH, 0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\n*ok = 0;\\r\\nreturn i;\\r\\n}\\r\\nOPENSSL_assert(i == DTLS1_HM_HEADER_LENGTH);\\r\\np += s->init_num;\\r\\ndtls1_get_message_header(p, &msg_hdr);\\r\\nif ( msg_hdr.seq != s->d1->handshake_read_seq)\\r\\nreturn dtls1_process_out_of_seq_message(s, &msg_hdr, ok);\\r\\nl = msg_hdr.msg_len;\\r\\nfrag_off = msg_hdr.frag_off;\\r\\nfrag_len = msg_hdr.frag_len;\\r\\nif ( frag_off + frag_len > l)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&\\r\\np[0] == SSL3_MT_HELLO_REQUEST)\\r\\n{\\r\\nif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\\r\\n{\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,\\r\\np, DTLS1_HM_HEADER_LENGTH, s,\\r\\ns->msg_callback_arg);\\r\\ns->init_num = 0;\\r\\nreturn dtls1_get_message_fragment(s, st1, stn,\\r\\nmax, ok);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\ns->init_num += i;\\r\\nif ( s->d1->r_msg_hdr.frag_off == 0)\\r\\n{\\r\\nif (l > (INT_MAX-DTLS1_HM_HEADER_LENGTH))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (l && !BUF_MEM_grow_clean(s->init_buf,(int)l\\r\\n+ DTLS1_HM_HEADER_LENGTH))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ( l > (unsigned long)max)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.message_size=l;\\r\\n}\\r\\nif ( frag_len > (unsigned long)max)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif ( frag_len + s->init_num > (INT_MAX - DTLS1_HM_HEADER_LENGTH))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif ( frag_len & !BUF_MEM_grow_clean(s->init_buf, (int)frag_len\\r\\n+ DTLS1_HM_HEADER_LENGTH + s->init_num))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ( s->d1->r_msg_hdr.frag_off == 0)\\r\\n{\\r\\ns->s3->tmp.message_type = msg_hdr.type;\\r\\ns->d1->r_msg_hdr.type = msg_hdr.type;\\r\\ns->d1->r_msg_hdr.msg_len = l;\\r\\n}\\r\\ns->state=stn;\\r\\np = (unsigned char *)s->init_buf->data;\\r\\nif ( frag_len > 0)\\r\\n{\\r\\ni=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\\r\\n&p[s->init_num],\\r\\nfrag_len,0);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\n*ok = 0;\\r\\nreturn i;\\r\\n}\\r\\n}\\r\\nelse\\r\\ni = 0;\\r\\nOPENSSL_assert(i == (int)frag_len);\\r\\n#if 0\\r\\nif ( msg_hdr.seq > s->d1->handshake_read_seq ||\\r\\nfrag_off > s->init_num - DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\ndtls1_buffer_handshake_fragment(s, &msg_hdr);\\r\\nreturn DTLS1_HM_FRAGMENT_RETRY;\\r\\n}\\r\\nif ( msg_hdr.seq < s->d1->handshake_read_seq ||\\r\\nfrag_off + frag_len < s->init_num - DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\ns->init_num -= DTLS1_HM_HEADER_LENGTH;\\r\\nreturn DTLS1_HM_FRAGMENT_RETRY;\\r\\n}\\r\\n#endif\\r\\noverlap = (s->init_num - DTLS1_HM_HEADER_LENGTH) - frag_off;\\r\\nif ( s->init_num > DTLS1_HM_HEADER_LENGTH)\\r\\n{\\r\\nmemmove(&(s->init_buf->data[s->init_num]),\\r\\n&(s->init_buf->data[s->init_num + DTLS1_HM_HEADER_LENGTH + overlap]),\\r\\nfrag_len - overlap);\\r\\ns->init_num += frag_len - overlap;\\r\\n}\\r\\nelse\\r\\ns->init_num += frag_len;\\r\\ndtls1_process_handshake_fragment(s, frag_len - overlap);\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data,\\r\\n(size_t)s->init_num, s,\\r\\ns->msg_callback_arg);\\r\\n*ok=1;\\r\\nreturn s->init_num;\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\ns->init_num = 0;\\r\\nerr:\\r\\n*ok=0;\\r\\nreturn(-1);\\r\\n}\\r\\nint dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == a)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[DTLS1_HM_HEADER_LENGTH]);\\r\\ni=s->method->ssl3_enc->final_finish_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->finish_dgst2),\\r\\nsender,slen,s->s3->tmp.finish_md);\\r\\ns->s3->tmp.finish_md_len = i;\\r\\nmemcpy(p, s->s3->tmp.finish_md, i);\\r\\np+=i;\\r\\nl=i;\\r\\n#ifdef OPENSSL_SYS_WIN16\\r\\nl&=0xffff;\\r\\n#endif\\r\\nd = dtls1_set_message_header(s, d, SSL3_MT_FINISHED, l, 0, l);\\r\\ns->init_num=(int)l+DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\ns->state=b;\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint dtls1_send_change_cipher_spec(SSL *s, int a, int b)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == a)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*p++=SSL3_MT_CCS;\\r\\ns->d1->handshake_write_seq = s->d1->next_handshake_write_seq;\\r\\ns->d1->next_handshake_write_seq++;\\r\\ns2n(s->d1->handshake_write_seq,p);\\r\\ns->init_num=DTLS1_CCS_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_set_message_header_int(s, SSL3_MT_CCS, 0,\\r\\ns->d1->handshake_write_seq, 0, 0);\\r\\ndtls1_buffer_message(s, 1);\\r\\ns->state=b;\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));\\r\\n}\\r\\nunsigned long dtls1_output_cert_chain(SSL *s, X509 *x)\\r\\n{\\r\\nunsigned char *p;\\r\\nint n,i;\\r\\nunsigned long l= 3 + DTLS1_HM_HEADER_LENGTH;\\r\\nBUF_MEM *buf;\\r\\nX509_STORE_CTX xs_ctx;\\r\\nX509_OBJECT obj;\\r\\nbuf=s->init_buf;\\r\\nif (!BUF_MEM_grow_clean(buf,10))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nif(!X509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_X509_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),\\r\\nX509_get_issuer_name(x)) == 0) break;\\r\\ni=X509_STORE_get_by_subject(&xs_ctx,X509_LU_X509,\\r\\nX509_get_issuer_name(x),&obj);\\r\\nif (i <= 0) break;\\r\\nx=obj.data.x509;\\r\\nX509_free(x);\\r\\n}\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\n}\\r\\nif (s->ctx->extra_certs != NULL)\\r\\nfor (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)\\r\\n{\\r\\nx=sk_X509_value(s->ctx->extra_certs,i);\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\n}\\r\\nl-= (3 + DTLS1_HM_HEADER_LENGTH);\\r\\np=(unsigned char *)&(buf->data[DTLS1_HM_HEADER_LENGTH]);\\r\\nl2n3(l,p);\\r\\nl+=3;\\r\\np=(unsigned char *)&(buf->data[0]);\\r\\np = dtls1_set_message_header(s, p, SSL3_MT_CERTIFICATE, l, 0, l);\\r\\nl+=DTLS1_HM_HEADER_LENGTH;\\r\\nreturn(l);\\r\\n}\\r\\nint dtls1_read_failed(SSL *s, int code)\\r\\n{\\r\\nDTLS1_STATE *state;\\r\\nBIO *bio;\\r\\nint send_alert = 0;\\r\\nif ( code > 0)\\r\\n{\\r\\nfprintf( stderr, \"invalid state reached %s:%d\", __FILE__, __LINE__);\\r\\nreturn 1;\\r\\n}\\r\\nbio = SSL_get_rbio(s);\\r\\nif ( ! BIO_dgram_recv_timedout(bio))\\r\\n{\\r\\nreturn code;\\r\\n}\\r\\nif ( ! SSL_in_init(s))\\r\\n{\\r\\nBIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\\r\\nreturn code;\\r\\n}\\r\\nstate = s->d1;\\r\\nstate->timeout.num_alerts++;\\r\\nif ( state->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_READ_FAILED,SSL_R_READ_TIMEOUT_EXPIRED);\\r\\nreturn 0;\\r\\n}\\r\\nstate->timeout.read_timeouts++;\\r\\nif ( state->timeout.read_timeouts > DTLS1_TMO_READ_COUNT)\\r\\n{\\r\\nsend_alert = 1;\\r\\nstate->timeout.read_timeouts = 1;\\r\\n}\\r\\n#if 0\\r\\nitem = pqueue_peek(state->rcvd_records);\\r\\nif ( item )\\r\\n{\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#if 0\\r\\nif ( send_alert)\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,\\r\\nDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\\r\\n#endif\\r\\nreturn dtls1_retransmit_buffered_messages(s) ;\\r\\n}\\r\\nstatic int\\r\\ndtls1_retransmit_buffered_messages(SSL *s)\\r\\n{\\r\\npqueue sent = s->d1->sent_messages;\\r\\npiterator iter;\\r\\npitem *item;\\r\\nhm_fragment *frag;\\r\\nint found = 0;\\r\\niter = pqueue_iterator(sent);\\r\\nfor ( item = pqueue_next(&iter); item != NULL; item = pqueue_next(&iter))\\r\\n{\\r\\nfrag = (hm_fragment *)item->data;\\r\\nif ( dtls1_retransmit_message(s, frag->msg_header.seq, 0, &found) <= 0 &&\\r\\nfound)\\r\\n{\\r\\nfprintf(stderr, \"dtls1_retransmit_message() failed\\n\");\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint\\r\\ndtls1_buffer_message(SSL *s, int is_ccs)\\r\\n{\\r\\npitem *item;\\r\\nhm_fragment *frag;\\r\\nPQ_64BIT seq64;\\r\\nOPENSSL_assert(s->init_off == 0);\\r\\nfrag = dtls1_hm_fragment_new(s->init_num);\\r\\nmemcpy(frag->fragment, s->init_buf->data, s->init_num);\\r\\nif ( is_ccs)\\r\\n{\\r\\nOPENSSL_assert(s->d1->w_msg_hdr.msg_len +\\r\\nDTLS1_CCS_HEADER_LENGTH == (unsigned int)s->init_num);\\r\\n}\\r\\nelse\\r\\n{\\r\\nOPENSSL_assert(s->d1->w_msg_hdr.msg_len +\\r\\nDTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);\\r\\n}\\r\\nfrag->msg_header.msg_len = s->d1->w_msg_hdr.msg_len;\\r\\nfrag->msg_header.seq = s->d1->w_msg_hdr.seq;\\r\\nfrag->msg_header.type = s->d1->w_msg_hdr.type;\\r\\nfrag->msg_header.frag_off = 0;\\r\\nfrag->msg_header.frag_len = s->d1->w_msg_hdr.msg_len;\\r\\nfrag->msg_header.is_ccs = is_ccs;\\r\\npq_64bit_init(&seq64);\\r\\npq_64bit_assign_word(&seq64, frag->msg_header.seq);\\r\\nitem = pitem_new(seq64, frag);\\r\\npq_64bit_free(&seq64);\\r\\nif ( item == NULL)\\r\\n{\\r\\ndtls1_hm_fragment_free(frag);\\r\\nreturn 0;\\r\\n}\\r\\n#if 0\\r\\nfprintf( stderr, \"buffered messge: \\ttype = %xx\\n\", msg_buf->type);\\r\\nfprintf( stderr, \"\\t\\t\\t\\t\\tlen = %d\\n\", msg_buf->len);\\r\\nfprintf( stderr, \"\\t\\t\\t\\t\\tseq_num = %d\\n\", msg_buf->seq_num);\\r\\n#endif\\r\\npqueue_insert(s->d1->sent_messages, item);\\r\\nreturn 1;\\r\\n}\\r\\nint\\r\\ndtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,\\r\\nint *found)\\r\\n{\\r\\nint ret;\\r\\npitem *item;\\r\\nhm_fragment *frag ;\\r\\nunsigned long header_length;\\r\\nPQ_64BIT seq64;\\r\\npq_64bit_init(&seq64);\\r\\npq_64bit_assign_word(&seq64, seq);\\r\\nitem = pqueue_find(s->d1->sent_messages, seq64);\\r\\npq_64bit_free(&seq64);\\r\\nif ( item == NULL)\\r\\n{\\r\\nfprintf(stderr, \"retransmit: message %d non-existant\\n\", seq);\\r\\n*found = 0;\\r\\nreturn 0;\\r\\n}\\r\\n*found = 1;\\r\\nfrag = (hm_fragment *)item->data;\\r\\nif ( frag->msg_header.is_ccs)\\r\\nheader_length = DTLS1_CCS_HEADER_LENGTH;\\r\\nelse\\r\\nheader_length = DTLS1_HM_HEADER_LENGTH;\\r\\nmemcpy(s->init_buf->data, frag->fragment,\\r\\nfrag->msg_header.msg_len + header_length);\\r\\ns->init_num = frag->msg_header.msg_len + header_length;\\r\\ndtls1_set_message_header_int(s, frag->msg_header.type,\\r\\nfrag->msg_header.msg_len, frag->msg_header.seq, 0,\\r\\nfrag->msg_header.frag_len);\\r\\ns->d1->retransmitting = 1;\\r\\nret = dtls1_do_write(s, frag->msg_header.is_ccs ?\\r\\nSSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);\\r\\ns->d1->retransmitting = 0;\\r\\nBIO_flush(SSL_get_wbio(s));\\r\\nreturn ret;\\r\\n}\\r\\nvoid\\r\\ndtls1_clear_record_buffer(SSL *s)\\r\\n{\\r\\npitem *item;\\r\\nfor(item = pqueue_pop(s->d1->sent_messages);\\r\\nitem != NULL; item = pqueue_pop(s->d1->sent_messages))\\r\\n{\\r\\ndtls1_hm_fragment_free((hm_fragment *)item->data);\\r\\npitem_free(item);\\r\\n}\\r\\n}\\r\\nunsigned char *\\r\\ndtls1_set_message_header(SSL *s, unsigned char *p, unsigned char mt,\\r\\nunsigned long len, unsigned long frag_off, unsigned long frag_len)\\r\\n{\\r\\nif ( frag_off == 0)\\r\\n{\\r\\ns->d1->handshake_write_seq = s->d1->next_handshake_write_seq;\\r\\ns->d1->next_handshake_write_seq++;\\r\\n}\\r\\ndtls1_set_message_header_int(s, mt, len, s->d1->handshake_write_seq,\\r\\nfrag_off, frag_len);\\r\\nreturn p += DTLS1_HM_HEADER_LENGTH;\\r\\n}\\r\\nstatic void\\r\\ndtls1_set_message_header_int(SSL *s, unsigned char mt,\\r\\nunsigned long len, unsigned short seq_num, unsigned long frag_off,\\r\\nunsigned long frag_len)\\r\\n{\\r\\nstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\\r\\nmsg_hdr->type = mt;\\r\\nmsg_hdr->msg_len = len;\\r\\nmsg_hdr->seq = seq_num;\\r\\nmsg_hdr->frag_off = frag_off;\\r\\nmsg_hdr->frag_len = frag_len;\\r\\n}\\r\\nstatic void\\r\\ndtls1_fix_message_header(SSL *s, unsigned long frag_off,\\r\\nunsigned long frag_len)\\r\\n{\\r\\nstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\\r\\nmsg_hdr->frag_off = frag_off;\\r\\nmsg_hdr->frag_len = frag_len;\\r\\n}\\r\\nstatic unsigned char *\\r\\ndtls1_write_message_header(SSL *s, unsigned char *p)\\r\\n{\\r\\nstruct hm_header_st *msg_hdr = &s->d1->w_msg_hdr;\\r\\n*p++ = msg_hdr->type;\\r\\nl2n3(msg_hdr->msg_len, p);\\r\\ns2n(msg_hdr->seq, p);\\r\\nl2n3(msg_hdr->frag_off, p);\\r\\nl2n3(msg_hdr->frag_len, p);\\r\\nreturn p;\\r\\n}\\r\\nstatic unsigned int\\r\\ndtls1_min_mtu(void)\\r\\n{\\r\\nreturn\\r\\ng_probable_mtu[(sizeof(g_probable_mtu) /\\r\\nsizeof(g_probable_mtu[0])) - 1];\\r\\n}\\r\\nstatic unsigned int\\r\\ndtls1_guess_mtu(unsigned int curr_mtu)\\r\\n{\\r\\nint i;\\r\\nif ( curr_mtu == 0 )\\r\\nreturn g_probable_mtu[0] ;\\r\\nfor ( i = 0; i < sizeof(g_probable_mtu)/sizeof(g_probable_mtu[0]); i++)\\r\\nif ( curr_mtu > g_probable_mtu[i])\\r\\nreturn g_probable_mtu[i];\\r\\nreturn curr_mtu;\\r\\n}\\r\\nvoid\\r\\ndtls1_get_message_header(unsigned char *data, struct hm_header_st *msg_hdr)\\r\\n{\\r\\nmemset(msg_hdr, 0x00, sizeof(struct hm_header_st));\\r\\nmsg_hdr->type = *(data++);\\r\\nn2l3(data, msg_hdr->msg_len);\\r\\nn2s(data, msg_hdr->seq);\\r\\nn2l3(data, msg_hdr->frag_off);\\r\\nn2l3(data, msg_hdr->frag_len);\\r\\n}\\r\\nvoid\\r\\ndtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr)\\r\\n{\\r\\nmemset(ccs_hdr, 0x00, sizeof(struct ccs_header_st));\\r\\nccs_hdr->type = *(data++);\\r\\nn2s(data, ccs_hdr->seq);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ocsp_prn_c", "target": 0, "func": "static int ocsp_certid_print(BIO *bp, OCSP_CERTID* a, int indent)\\r\\n{\\r\\nBIO_printf(bp, \"%*sCertificate ID:\\n\", indent, \"\");\\r\\nindent += 2;\\r\\nBIO_printf(bp, \"%*sHash Algorithm: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(bp, a->hashAlgorithm->algorithm);\\r\\nBIO_printf(bp, \"\\n%*sIssuer Name Hash: \", indent, \"\");\\r\\ni2a_ASN1_STRING(bp, a->issuerNameHash, V_ASN1_OCTET_STRING);\\r\\nBIO_printf(bp, \"\\n%*sIssuer Key Hash: \", indent, \"\");\\r\\ni2a_ASN1_STRING(bp, a->issuerKeyHash, V_ASN1_OCTET_STRING);\\r\\nBIO_printf(bp, \"\\n%*sSerial Number: \", indent, \"\");\\r\\ni2a_ASN1_INTEGER(bp, a->serialNumber);\\r\\nBIO_printf(bp, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic char *table2string(long s, OCSP_TBLSTR *ts, int len)\\r\\n{\\r\\nOCSP_TBLSTR *p;\\r\\nfor (p=ts; p < ts + len; p++)\\r\\nif (p->t == s)\\r\\nreturn p->m;\\r\\nreturn \"(UNKNOWN)\";\\r\\n}\\r\\nchar *OCSP_response_status_str(long s)\\r\\n{\\r\\nstatic OCSP_TBLSTR rstat_tbl[] = {\\r\\n{ OCSP_RESPONSE_STATUS_SUCCESSFUL, \"successful\" },\\r\\n{ OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, \"malformedrequest\" },\\r\\n{ OCSP_RESPONSE_STATUS_INTERNALERROR, \"internalerror\" },\\r\\n{ OCSP_RESPONSE_STATUS_TRYLATER, \"trylater\" },\\r\\n{ OCSP_RESPONSE_STATUS_SIGREQUIRED, \"sigrequired\" },\\r\\n{ OCSP_RESPONSE_STATUS_UNAUTHORIZED, \"unauthorized\" } };\\r\\nreturn table2string(s, rstat_tbl, 6);\\r\\n}\\r\\nchar *OCSP_cert_status_str(long s)\\r\\n{\\r\\nstatic OCSP_TBLSTR cstat_tbl[] = {\\r\\n{ V_OCSP_CERTSTATUS_GOOD, \"good\" },\\r\\n{ V_OCSP_CERTSTATUS_REVOKED, \"revoked\" },\\r\\n{ V_OCSP_CERTSTATUS_UNKNOWN, \"unknown\" } };\\r\\nreturn table2string(s, cstat_tbl, 3);\\r\\n}\\r\\nchar *OCSP_crl_reason_str(long s)\\r\\n{\\r\\nOCSP_TBLSTR reason_tbl[] = {\\r\\n{ OCSP_REVOKED_STATUS_UNSPECIFIED, \"unspecified\" },\\r\\n{ OCSP_REVOKED_STATUS_KEYCOMPROMISE, \"keyCompromise\" },\\r\\n{ OCSP_REVOKED_STATUS_CACOMPROMISE, \"cACompromise\" },\\r\\n{ OCSP_REVOKED_STATUS_AFFILIATIONCHANGED, \"affiliationChanged\" },\\r\\n{ OCSP_REVOKED_STATUS_SUPERSEDED, \"superseded\" },\\r\\n{ OCSP_REVOKED_STATUS_CESSATIONOFOPERATION, \"cessationOfOperation\" },\\r\\n{ OCSP_REVOKED_STATUS_CERTIFICATEHOLD, \"certificateHold\" },\\r\\n{ OCSP_REVOKED_STATUS_REMOVEFROMCRL, \"removeFromCRL\" } };\\r\\nreturn table2string(s, reason_tbl, 8);\\r\\n}\\r\\nint OCSP_REQUEST_print(BIO *bp, OCSP_REQUEST* o, unsigned long flags)\\r\\n{\\r\\nint i;\\r\\nlong l;\\r\\nOCSP_CERTID* cid = NULL;\\r\\nOCSP_ONEREQ *one = NULL;\\r\\nOCSP_REQINFO *inf = o->tbsRequest;\\r\\nOCSP_SIGNATURE *sig = o->optionalSignature;\\r\\nif (BIO_write(bp,\"OCSP Request Data:\\n\",19) <= 0) goto err;\\r\\nl=ASN1_INTEGER_get(inf->version);\\r\\nif (BIO_printf(bp,\" Version: %lu (0x%lx)\",l+1,l) <= 0) goto err;\\r\\nif (inf->requestorName != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\"\\n Requestor Name: \",21) <= 0)\\r\\ngoto err;\\r\\nGENERAL_NAME_print(bp, inf->requestorName);\\r\\n}\\r\\nif (BIO_write(bp,\"\\n Requestor List:\\n\",21) <= 0) goto err;\\r\\nfor (i = 0; i < sk_OCSP_ONEREQ_num(inf->requestList); i++)\\r\\n{\\r\\none = sk_OCSP_ONEREQ_value(inf->requestList, i);\\r\\ncid = one->reqCert;\\r\\nocsp_certid_print(bp, cid, 8);\\r\\nif (!X509V3_extensions_print(bp,\\r\\n\"Request Single Extensions\",\\r\\none->singleRequestExtensions, flags, 8))\\r\\ngoto err;\\r\\n}\\r\\nif (!X509V3_extensions_print(bp, \"Request Extensions\",\\r\\ninf->requestExtensions, flags, 4))\\r\\ngoto err;\\r\\nif (sig)\\r\\n{\\r\\nX509_signature_print(bp, sig->signatureAlgorithm, sig->signature);\\r\\nfor (i=0; i<sk_X509_num(sig->certs); i++)\\r\\n{\\r\\nX509_print(bp, sk_X509_value(sig->certs,i));\\r\\nPEM_write_bio_X509(bp,sk_X509_value(sig->certs,i));\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint OCSP_RESPONSE_print(BIO *bp, OCSP_RESPONSE* o, unsigned long flags)\\r\\n{\\r\\nint i, ret = 0;\\r\\nlong l;\\r\\nunsigned char *p;\\r\\nOCSP_CERTID *cid = NULL;\\r\\nOCSP_BASICRESP *br = NULL;\\r\\nOCSP_RESPID *rid = NULL;\\r\\nOCSP_RESPDATA *rd = NULL;\\r\\nOCSP_CERTSTATUS *cst = NULL;\\r\\nOCSP_REVOKEDINFO *rev = NULL;\\r\\nOCSP_SINGLERESP *single = NULL;\\r\\nOCSP_RESPBYTES *rb = o->responseBytes;\\r\\nif (BIO_puts(bp,\"OCSP Response Data:\\n\") <= 0) goto err;\\r\\nl=ASN1_ENUMERATED_get(o->responseStatus);\\r\\nif (BIO_printf(bp,\" OCSP Response Status: %s (0x%lx)\\n\",\\r\\nOCSP_response_status_str(l), l) <= 0) goto err;\\r\\nif (rb == NULL) return 1;\\r\\nif (BIO_puts(bp,\" Response Type: \") <= 0)\\r\\ngoto err;\\r\\nif(i2a_ASN1_OBJECT(bp, rb->responseType) <= 0)\\r\\ngoto err;\\r\\nif (OBJ_obj2nid(rb->responseType) != NID_id_pkix_OCSP_basic)\\r\\n{\\r\\nBIO_puts(bp,\" (unknown response type)\\n\");\\r\\nreturn 1;\\r\\n}\\r\\np = ASN1_STRING_data(rb->response);\\r\\ni = ASN1_STRING_length(rb->response);\\r\\nif (!(br = OCSP_response_get1_basic(o))) goto err;\\r\\nrd = br->tbsResponseData;\\r\\nl=ASN1_INTEGER_get(rd->version);\\r\\nif (BIO_printf(bp,\"\\n Version: %lu (0x%lx)\\n\",\\r\\nl+1,l) <= 0) goto err;\\r\\nif (BIO_puts(bp,\" Responder Id: \") <= 0) goto err;\\r\\nrid = rd->responderId;\\r\\nswitch (rid->type)\\r\\n{\\r\\ncase V_OCSP_RESPID_NAME:\\r\\nX509_NAME_print_ex(bp, rid->value.byName, 0, XN_FLAG_ONELINE);\\r\\nbreak;\\r\\ncase V_OCSP_RESPID_KEY:\\r\\ni2a_ASN1_STRING(bp, rid->value.byKey, V_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\n}\\r\\nif (BIO_printf(bp,\"\\n Produced At: \")<=0) goto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, rd->producedAt)) goto err;\\r\\nif (BIO_printf(bp,\"\\n Responses:\\n\") <= 0) goto err;\\r\\nfor (i = 0; i < sk_OCSP_SINGLERESP_num(rd->responses); i++)\\r\\n{\\r\\nif (! sk_OCSP_SINGLERESP_value(rd->responses, i)) continue;\\r\\nsingle = sk_OCSP_SINGLERESP_value(rd->responses, i);\\r\\ncid = single->certId;\\r\\nif(ocsp_certid_print(bp, cid, 4) <= 0) goto err;\\r\\ncst = single->certStatus;\\r\\nif (BIO_printf(bp,\" Cert Status: %s\",\\r\\nOCSP_cert_status_str(cst->type)) <= 0)\\r\\ngoto err;\\r\\nif (cst->type == V_OCSP_CERTSTATUS_REVOKED)\\r\\n{\\r\\nrev = cst->value.revoked;\\r\\nif (BIO_printf(bp, \"\\n Revocation Time: \") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp,\\r\\nrev->revocationTime))\\r\\ngoto err;\\r\\nif (rev->revocationReason)\\r\\n{\\r\\nl=ASN1_ENUMERATED_get(rev->revocationReason);\\r\\nif (BIO_printf(bp,\\r\\n\"\\n Revocation Reason: %s (0x%lx)\",\\r\\nOCSP_crl_reason_str(l), l) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (BIO_printf(bp,\"\\n This Update: \") <= 0) goto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, single->thisUpdate))\\r\\ngoto err;\\r\\nif (single->nextUpdate)\\r\\n{\\r\\nif (BIO_printf(bp,\"\\n Next Update: \") <= 0)goto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp,single->nextUpdate))\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_write(bp,\"\\n\",1)) goto err;\\r\\nif (!X509V3_extensions_print(bp,\\r\\n\"Response Single Extensions\",\\r\\nsingle->singleExtensions, flags, 8))\\r\\ngoto err;\\r\\nif (!BIO_write(bp,\"\\n\",1)) goto err;\\r\\n}\\r\\nif (!X509V3_extensions_print(bp, \"Response Extensions\",\\r\\nrd->responseExtensions, flags, 4))\\r\\nif(X509_signature_print(bp, br->signatureAlgorithm, br->signature) <= 0)\\r\\ngoto err;\\r\\nfor (i=0; i<sk_X509_num(br->certs); i++)\\r\\n{\\r\\nX509_print(bp, sk_X509_value(br->certs,i));\\r\\nPEM_write_bio_X509(bp,sk_X509_value(br->certs,i));\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nOCSP_BASICRESP_free(br);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc5speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC5_32_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC5_32_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC5_32_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC5_32_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC5_32_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC5_32_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC5_32_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC5_32_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC5_32_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),RC5_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC5_32/12/16 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC5_32/12/16 raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"RC5_32/12/16 cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d2i_pr_c", "target": 0, "func": "EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL))\\r\\n{\\r\\nif ((ret=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nelse ret= *a;\\r\\nret->save_type=type;\\r\\nret->type=EVP_PKEY_type(type);\\r\\nswitch (ret->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif ((ret->pkey.rsa=d2i_RSAPrivateKey(NULL,\\r\\n(const unsigned char **)pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif ((ret->pkey.dsa=d2i_DSAPrivateKey(NULL,\\r\\n(const unsigned char **)pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nif ((ret->pkey.ec = d2i_ECPrivateKey(NULL,\\r\\n(const unsigned char **)pp, length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) EVP_PKEY_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nEVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nSTACK_OF(ASN1_TYPE) *inkey;\\r\\nconst unsigned char *p;\\r\\nint keytype;\\r\\np = *pp;\\r\\ninkey = d2i_ASN1_SET_OF_ASN1_TYPE(NULL, &p, length, d2i_ASN1_TYPE,\\r\\nASN1_TYPE_free, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\\r\\nif(sk_ASN1_TYPE_num(inkey) == 6)\\r\\nkeytype = EVP_PKEY_DSA;\\r\\nelse if (sk_ASN1_TYPE_num(inkey) == 4)\\r\\nkeytype = EVP_PKEY_EC;\\r\\nelse keytype = EVP_PKEY_RSA;\\r\\nsk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);\\r\\nreturn d2i_PrivateKey(keytype, a, pp, length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_f_int_c", "target": 0, "func": "int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->type & V_ASN1_NEG)\\r\\n{\\r\\nif (BIO_write(bp, \"-\", 1) != 1) goto err;\\r\\nn = 1;\\r\\n}\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) != 2) goto err;\\r\\nn += 2;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbs->type=V_ASN1_INTEGER;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1) goto err_sl;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nif (first)\\r\\n{\\r\\nfirst=0;\\r\\nif ((bufp[0] == '0') && (buf[1] == '0'))\\r\\n{\\r\\nbufp+=2;\\r\\ni-=2;\\r\\n}\\r\\n}\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)OPENSSL_malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=OPENSSL_realloc_clean(s,slen,num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) OPENSSL_free(s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ofb64enc_c", "target": 0, "func": "void DES_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length,\\r\\nDES_key_schedule *schedule, DES_cblock *ivec, int *num)\\r\\n{\\r\\nregister DES_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nDES_cblock d;\\r\\nregister unsigned char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nDES_encrypt1(ti,schedule,DES_ENCRYPT);\\r\\ndp=d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_rsa_c", "target": 0, "func": "int SSL_use_certificate(SSL *ssl, X509 *x)\\r\\n{\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_cert(ssl->cert,x));\\r\\n}\\r\\nint SSL_use_certificate_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nx=d2i_X509_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nx=PEM_read_bio_X509(in,NULL,ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_certificate(ssl,x);\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx=d2i_X509(NULL,&d,(long)len);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_certificate(ssl,x);\\r\\nX509_free(x);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint ret;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((pkey=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\nEVP_PKEY_assign_RSA(pkey,rsa);\\r\\nret=ssl_set_pkey(ssl->cert,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)\\r\\n{\\r\\nint i;\\r\\ni=ssl_cert_type(NULL,pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_PKEY,SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(c->pkeys[i].x509);\\r\\nEVP_PKEY_copy_parameters(pktmp,pkey);\\r\\nEVP_PKEY_free(pktmp);\\r\\nERR_clear_error();\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((pkey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(pkey->pkey.rsa) & RSA_METHOD_FLAG_NO_CHECK))\\r\\n;\\r\\nelse\\r\\n#endif\\r\\nif (!X509_check_private_key(c->pkeys[i].x509,pkey))\\r\\n{\\r\\nX509_free(c->pkeys[i].x509);\\r\\nc->pkeys[i].x509 = NULL;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nCRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\nc->pkeys[i].privatekey=pkey;\\r\\nc->key= &(c->pkeys[i]);\\r\\nc->valid=0;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nRSA *rsa=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nrsa=d2i_RSAPrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nrsa=PEM_read_bio_RSAPrivateKey(in,NULL,\\r\\nssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_RSAPrivateKey(ssl,rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nRSA *rsa;\\r\\np=d;\\r\\nif ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_RSAPrivateKey(ssl,rsa);\\r\\nRSA_free(rsa);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)\\r\\n{\\r\\nint ret;\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nret=ssl_set_pkey(ssl->cert,pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,\\r\\nssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj = ERR_R_ASN1_LIB;\\r\\npkey = d2i_PrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_PrivateKey(ssl,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np=d;\\r\\nif ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_PrivateKey(ssl,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)\\r\\n{\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_cert(ctx->cert, x));\\r\\n}\\r\\nstatic int ssl_set_cert(CERT *c, X509 *x)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint i;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_CERT,SSL_R_X509_LIB);\\r\\nreturn(0);\\r\\n}\\r\\ni=ssl_cert_type(x,pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_CERT,SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(0);\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\n{\\r\\nEVP_PKEY_copy_parameters(pkey,c->pkeys[i].privatekey);\\r\\nERR_clear_error();\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((c->pkeys[i].privatekey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(c->pkeys[i].privatekey->pkey.rsa) &\\r\\nRSA_METHOD_FLAG_NO_CHECK))\\r\\n;\\r\\nelse\\r\\n#endif\\r\\nif (!X509_check_private_key(x,c->pkeys[i].privatekey))\\r\\n{\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nc->pkeys[i].privatekey=NULL;\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\nX509_free(c->pkeys[i].x509);\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\nc->pkeys[i].x509=x;\\r\\nc->key= &(c->pkeys[i]);\\r\\nc->valid=0;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nx=d2i_X509_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nx=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx=d2i_X509(NULL,&d,(long)len);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nX509_free(x);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)\\r\\n{\\r\\nint ret;\\r\\nEVP_PKEY *pkey;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((pkey=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\nEVP_PKEY_assign_RSA(pkey,rsa);\\r\\nret=ssl_set_pkey(ctx->cert, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nRSA *rsa=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nrsa=d2i_RSAPrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nrsa=PEM_read_bio_RSAPrivateKey(in,NULL,\\r\\nctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nRSA *rsa;\\r\\np=d;\\r\\nif ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);\\r\\nRSA_free(rsa);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_pkey(ctx->cert,pkey));\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,\\r\\nctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj = ERR_R_ASN1_LIB;\\r\\npkey = d2i_PrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_PrivateKey(ctx,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, const unsigned char *d,\\r\\nlong len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np=d;\\r\\nif ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_PrivateKey(ctx,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)\\r\\n{\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nx=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_PEM_LIB);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nif (ERR_peek_error() != 0)\\r\\nret = 0;\\r\\nif (ret)\\r\\n{\\r\\nX509 *ca;\\r\\nint r;\\r\\nunsigned long err;\\r\\nif (ctx->extra_certs != NULL)\\r\\n{\\r\\nsk_X509_pop_free(ctx->extra_certs, X509_free);\\r\\nctx->extra_certs = NULL;\\r\\n}\\r\\nwhile ((ca = PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata))\\r\\n!= NULL)\\r\\n{\\r\\nr = SSL_CTX_add_extra_chain_cert(ctx, ca);\\r\\nif (!r)\\r\\n{\\r\\nX509_free(ca);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nerr = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)\\r\\nERR_clear_error();\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_type_c", "target": 0, "func": "int ASN1_TYPE_get(ASN1_TYPE *a)\\r\\n{\\r\\nif ((a->value.ptr != NULL) || (a->type == V_ASN1_NULL))\\r\\nreturn(a->type);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nvoid ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)\\r\\n{\\r\\nif (a->value.ptr != NULL)\\r\\n{\\r\\nASN1_TYPE **tmp_a = &a;\\r\\nASN1_primitive_free((ASN1_VALUE **)tmp_a, NULL);\\r\\n}\\r\\na->type=type;\\r\\na->value.ptr=value;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_err_c", "target": 0, "func": "void ERR_load_EVP_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,EVP_str_functs);\\r\\nERR_load_strings(0,EVP_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_conf_mall_c", "target": 0, "func": "void OPENSSL_load_builtin_modules(void)\\r\\n{\\r\\nASN1_add_oid_module();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_add_conf_module();\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_lib_c", "target": 0, "func": "void BN_set_params(int mult, int high, int low, int mont)\\r\\n{\\r\\nif (mult >= 0)\\r\\n{\\r\\nif (mult > (int)(sizeof(int)*8)-1)\\r\\nmult=sizeof(int)*8-1;\\r\\nbn_limit_bits=mult;\\r\\nbn_limit_num=1<<mult;\\r\\n}\\r\\nif (high >= 0)\\r\\n{\\r\\nif (high > (int)(sizeof(int)*8)-1)\\r\\nhigh=sizeof(int)*8-1;\\r\\nbn_limit_bits_high=high;\\r\\nbn_limit_num_high=1<<high;\\r\\n}\\r\\nif (low >= 0)\\r\\n{\\r\\nif (low > (int)(sizeof(int)*8)-1)\\r\\nlow=sizeof(int)*8-1;\\r\\nbn_limit_bits_low=low;\\r\\nbn_limit_num_low=1<<low;\\r\\n}\\r\\nif (mont >= 0)\\r\\n{\\r\\nif (mont > (int)(sizeof(int)*8)-1)\\r\\nmont=sizeof(int)*8-1;\\r\\nbn_limit_bits_mont=mont;\\r\\nbn_limit_num_mont=1<<mont;\\r\\n}\\r\\n}\\r\\nint BN_get_params(int which)\\r\\n{\\r\\nif (which == 0) return(bn_limit_bits);\\r\\nelse if (which == 1) return(bn_limit_bits_high);\\r\\nelse if (which == 2) return(bn_limit_bits_low);\\r\\nelse if (which == 3) return(bn_limit_bits_mont);\\r\\nelse return(0);\\r\\n}\\r\\nconst BIGNUM *BN_value_one(void)\\r\\n{\\r\\nstatic BN_ULONG data_one=1L;\\r\\nstatic BIGNUM const_one={&data_one,1,1,0,BN_FLG_STATIC_DATA};\\r\\nreturn(&const_one);\\r\\n}\\r\\nchar *BN_options(void)\\r\\n{\\r\\nstatic int init=0;\\r\\nstatic char data[16];\\r\\nif (!init)\\r\\n{\\r\\ninit++;\\r\\n#ifdef BN_LLONG\\r\\nBIO_snprintf(data,sizeof data,\"bn(%d,%d)\",\\r\\n(int)sizeof(BN_ULLONG)*8,(int)sizeof(BN_ULONG)*8);\\r\\n#else\\r\\nBIO_snprintf(data,sizeof data,\"bn(%d,%d)\",\\r\\n(int)sizeof(BN_ULONG)*8,(int)sizeof(BN_ULONG)*8);\\r\\n#endif\\r\\n}\\r\\nreturn(data);\\r\\n}\\r\\nint BN_num_bits_word(BN_ULONG l)\\r\\n{\\r\\nstatic const char bits[256]={\\r\\n0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,\\r\\n5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\\r\\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\r\\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n};\\r\\n#if defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffffffff00000000L)\\r\\n{\\r\\nif (l & 0xffff000000000000L)\\r\\n{\\r\\nif (l & 0xff00000000000000L)\\r\\n{\\r\\nreturn(bits[(int)(l>>56)]+56);\\r\\n}\\r\\nelse return(bits[(int)(l>>48)]+48);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (l & 0x0000ff0000000000L)\\r\\n{\\r\\nreturn(bits[(int)(l>>40)]+40);\\r\\n}\\r\\nelse return(bits[(int)(l>>32)]+32);\\r\\n}\\r\\n}\\r\\nelse\\r\\n#else\\r\\n#ifdef SIXTY_FOUR_BIT\\r\\nif (l & 0xffffffff00000000LL)\\r\\n{\\r\\nif (l & 0xffff000000000000LL)\\r\\n{\\r\\nif (l & 0xff00000000000000LL)\\r\\n{\\r\\nreturn(bits[(int)(l>>56)]+56);\\r\\n}\\r\\nelse return(bits[(int)(l>>48)]+48);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (l & 0x0000ff0000000000LL)\\r\\n{\\r\\nreturn(bits[(int)(l>>40)]+40);\\r\\n}\\r\\nelse return(bits[(int)(l>>32)]+32);\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#endif\\r\\n{\\r\\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffff0000L)\\r\\n{\\r\\nif (l & 0xff000000L)\\r\\nreturn(bits[(int)(l>>24L)]+24);\\r\\nelse return(bits[(int)(l>>16L)]+16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\n#if defined(SIXTEEN_BIT) || defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xff00L)\\r\\nreturn(bits[(int)(l>>8)]+8);\\r\\nelse\\r\\n#endif\\r\\nreturn(bits[(int)(l )] );\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_num_bits(const BIGNUM *a)\\r\\n{\\r\\nint i = a->top - 1;\\r\\nbn_check_top(a);\\r\\nif (BN_is_zero(a)) return 0;\\r\\nreturn ((i*BN_BITS2) + BN_num_bits_word(a->d[i]));\\r\\n}\\r\\nvoid BN_clear_free(BIGNUM *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\nbn_check_top(a);\\r\\nif (a->d != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(a->d,a->dmax*sizeof(a->d[0]));\\r\\nif (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))\\r\\nOPENSSL_free(a->d);\\r\\n}\\r\\ni=BN_get_flags(a,BN_FLG_MALLOCED);\\r\\nOPENSSL_cleanse(a,sizeof(BIGNUM));\\r\\nif (i)\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid BN_free(BIGNUM *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nbn_check_top(a);\\r\\nif ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))\\r\\nOPENSSL_free(a->d);\\r\\nif (a->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(a);\\r\\nelse\\r\\n{\\r\\n#ifndef OPENSSL_NO_DEPRECATED\\r\\na->flags|=BN_FLG_FREE;\\r\\n#endif\\r\\na->d = NULL;\\r\\n}\\r\\n}\\r\\nvoid BN_init(BIGNUM *a)\\r\\n{\\r\\nmemset(a,0,sizeof(BIGNUM));\\r\\nbn_check_top(a);\\r\\n}\\r\\nBIGNUM *BN_new(void)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=(BIGNUM *)OPENSSL_malloc(sizeof(BIGNUM))) == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nret->top=0;\\r\\nret->neg=0;\\r\\nret->dmax=0;\\r\\nret->d=NULL;\\r\\nbn_check_top(ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)\\r\\n{\\r\\nBN_ULONG *A,*a = NULL;\\r\\nconst BN_ULONG *B;\\r\\nint i;\\r\\nbn_check_top(b);\\r\\nif (words > (INT_MAX/(4*BN_BITS2)))\\r\\n{\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_BIGNUM_TOO_LONG);\\r\\nreturn NULL;\\r\\n}\\r\\nif (BN_get_flags(b,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);\\r\\nreturn(NULL);\\r\\n}\\r\\na=A=(BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG)*words);\\r\\nif (A == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\n#if 1\\r\\nB=b->d;\\r\\nif (B != NULL)\\r\\n{\\r\\nfor (i=b->top>>2; i>0; i--,A+=4,B+=4)\\r\\n{\\r\\nBN_ULONG a0,a1,a2,a3;\\r\\na0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];\\r\\nA[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;\\r\\n}\\r\\nswitch (b->top&3)\\r\\n{\\r\\ncase 3: A[2]=B[2];\\r\\ncase 2: A[1]=B[1];\\r\\ncase 1: A[0]=B[0];\\r\\ncase 0:\\r\\n;\\r\\n}\\r\\n}\\r\\n#else\\r\\nmemset(A,0,sizeof(BN_ULONG)*words);\\r\\nmemcpy(A,b->d,sizeof(b->d[0])*b->top);\\r\\n#endif\\r\\nreturn(a);\\r\\n}\\r\\nBIGNUM *bn_dup_expand(const BIGNUM *b, int words)\\r\\n{\\r\\nBIGNUM *r = NULL;\\r\\nbn_check_top(b);\\r\\nif (words > b->dmax)\\r\\n{\\r\\nBN_ULONG *a = bn_expand_internal(b, words);\\r\\nif (a)\\r\\n{\\r\\nr = BN_new();\\r\\nif (r)\\r\\n{\\r\\nr->top = b->top;\\r\\nr->dmax = words;\\r\\nr->neg = b->neg;\\r\\nr->d = a;\\r\\n}\\r\\nelse\\r\\n{\\r\\nOPENSSL_free(a);\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nr = BN_dup(b);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn r;\\r\\n}\\r\\nBIGNUM *bn_expand2(BIGNUM *b, int words)\\r\\n{\\r\\nbn_check_top(b);\\r\\nif (words > b->dmax)\\r\\n{\\r\\nBN_ULONG *a = bn_expand_internal(b, words);\\r\\nif(!a) return NULL;\\r\\nif(b->d) OPENSSL_free(b->d);\\r\\nb->d=a;\\r\\nb->dmax=words;\\r\\n}\\r\\n#if 0\\r\\nif (b->top < b->dmax)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *A = &(b->d[b->top]);\\r\\nfor (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)\\r\\n{\\r\\nA[0]=0; A[1]=0; A[2]=0; A[3]=0;\\r\\nA[4]=0; A[5]=0; A[6]=0; A[7]=0;\\r\\n}\\r\\nfor (i=(b->dmax - b->top)&7; i>0; i--,A++)\\r\\nA[0]=0;\\r\\nassert(A == &(b->d[b->dmax]));\\r\\n}\\r\\n#endif\\r\\nbn_check_top(b);\\r\\nreturn b;\\r\\n}\\r\\nBIGNUM *BN_dup(const BIGNUM *a)\\r\\n{\\r\\nBIGNUM *t;\\r\\nif (a == NULL) return NULL;\\r\\nbn_check_top(a);\\r\\nt = BN_new();\\r\\nif (t == NULL) return NULL;\\r\\nif(!BN_copy(t, a))\\r\\n{\\r\\nBN_free(t);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(t);\\r\\nreturn t;\\r\\n}\\r\\nBIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *A;\\r\\nconst BN_ULONG *B;\\r\\nbn_check_top(b);\\r\\nif (a == b) return(a);\\r\\nif (bn_wexpand(a,b->top) == NULL) return(NULL);\\r\\n#if 1\\r\\nA=a->d;\\r\\nB=b->d;\\r\\nfor (i=b->top>>2; i>0; i--,A+=4,B+=4)\\r\\n{\\r\\nBN_ULONG a0,a1,a2,a3;\\r\\na0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];\\r\\nA[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;\\r\\n}\\r\\nswitch (b->top&3)\\r\\n{\\r\\ncase 3: A[2]=B[2];\\r\\ncase 2: A[1]=B[1];\\r\\ncase 1: A[0]=B[0];\\r\\ncase 0: ;\\r\\n}\\r\\n#else\\r\\nmemcpy(a->d,b->d,sizeof(b->d[0])*b->top);\\r\\n#endif\\r\\na->top=b->top;\\r\\na->neg=b->neg;\\r\\nbn_check_top(a);\\r\\nreturn(a);\\r\\n}\\r\\nvoid BN_swap(BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nint flags_old_a, flags_old_b;\\r\\nBN_ULONG *tmp_d;\\r\\nint tmp_top, tmp_dmax, tmp_neg;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nflags_old_a = a->flags;\\r\\nflags_old_b = b->flags;\\r\\ntmp_d = a->d;\\r\\ntmp_top = a->top;\\r\\ntmp_dmax = a->dmax;\\r\\ntmp_neg = a->neg;\\r\\na->d = b->d;\\r\\na->top = b->top;\\r\\na->dmax = b->dmax;\\r\\na->neg = b->neg;\\r\\nb->d = tmp_d;\\r\\nb->top = tmp_top;\\r\\nb->dmax = tmp_dmax;\\r\\nb->neg = tmp_neg;\\r\\na->flags = (flags_old_a & BN_FLG_MALLOCED) | (flags_old_b & BN_FLG_STATIC_DATA);\\r\\nb->flags = (flags_old_b & BN_FLG_MALLOCED) | (flags_old_a & BN_FLG_STATIC_DATA);\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\n}\\r\\nvoid BN_clear(BIGNUM *a)\\r\\n{\\r\\nbn_check_top(a);\\r\\nif (a->d != NULL)\\r\\nmemset(a->d,0,a->dmax*sizeof(a->d[0]));\\r\\na->top=0;\\r\\na->neg=0;\\r\\n}\\r\\nBN_ULONG BN_get_word(const BIGNUM *a)\\r\\n{\\r\\nif (a->top > 1)\\r\\nreturn BN_MASK2;\\r\\nelse if (a->top == 1)\\r\\nreturn a->d[0];\\r\\nreturn 0;\\r\\n}\\r\\nint BN_set_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nbn_check_top(a);\\r\\nif (bn_expand(a,(int)sizeof(BN_ULONG)*8) == NULL) return(0);\\r\\na->neg = 0;\\r\\na->d[0] = w;\\r\\na->top = (w ? 1 : 0);\\r\\nbn_check_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nBIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)\\r\\n{\\r\\nunsigned int i,m;\\r\\nunsigned int n;\\r\\nBN_ULONG l;\\r\\nBIGNUM *bn = NULL;\\r\\nif (ret == NULL)\\r\\nret = bn = BN_new();\\r\\nif (ret == NULL) return(NULL);\\r\\nbn_check_top(ret);\\r\\nl=0;\\r\\nn=len;\\r\\nif (n == 0)\\r\\n{\\r\\nret->top=0;\\r\\nreturn(ret);\\r\\n}\\r\\ni=((n-1)/BN_BYTES)+1;\\r\\nm=((n-1)%(BN_BYTES));\\r\\nif (bn_wexpand(ret, (int)i) == NULL)\\r\\n{\\r\\nif (bn) BN_free(bn);\\r\\nreturn NULL;\\r\\n}\\r\\nret->top=i;\\r\\nret->neg=0;\\r\\nwhile (n--)\\r\\n{\\r\\nl=(l<<8L)| *(s++);\\r\\nif (m-- == 0)\\r\\n{\\r\\nret->d[--i]=l;\\r\\nl=0;\\r\\nm=BN_BYTES-1;\\r\\n}\\r\\n}\\r\\nbn_correct_top(ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_bn2bin(const BIGNUM *a, unsigned char *to)\\r\\n{\\r\\nint n,i;\\r\\nBN_ULONG l;\\r\\nbn_check_top(a);\\r\\nn=i=BN_num_bytes(a);\\r\\nwhile (i--)\\r\\n{\\r\\nl=a->d[i/BN_BYTES];\\r\\n*(to++)=(unsigned char)(l>>(8*(i%BN_BYTES)))&0xff;\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\nint BN_ucmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG t1,t2,*ap,*bp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\ni=a->top-b->top;\\r\\nif (i != 0) return(i);\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt1= ap[i];\\r\\nt2= bp[i];\\r\\nif (t1 != t2)\\r\\nreturn((t1 > t2) ? 1 : -1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BN_cmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nint gt,lt;\\r\\nBN_ULONG t1,t2;\\r\\nif ((a == NULL) || (b == NULL))\\r\\n{\\r\\nif (a != NULL)\\r\\nreturn(-1);\\r\\nelse if (b != NULL)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg != b->neg)\\r\\n{\\r\\nif (a->neg)\\r\\nreturn(-1);\\r\\nelse return(1);\\r\\n}\\r\\nif (a->neg == 0)\\r\\n{ gt=1; lt= -1; }\\r\\nelse { gt= -1; lt=1; }\\r\\nif (a->top > b->top) return(gt);\\r\\nif (a->top < b->top) return(lt);\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt1=a->d[i];\\r\\nt2=b->d[i];\\r\\nif (t1 > t2) return(gt);\\r\\nif (t1 < t2) return(lt);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BN_set_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i,j,k;\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i)\\r\\n{\\r\\nif (bn_wexpand(a,i+1) == NULL) return(0);\\r\\nfor(k=a->top; k<i+1; k++)\\r\\na->d[k]=0;\\r\\na->top=i+1;\\r\\n}\\r\\na->d[i]|=(((BN_ULONG)1)<<j);\\r\\nbn_check_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_clear_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i,j;\\r\\nbn_check_top(a);\\r\\nif (n < 0) return 0;\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i) return(0);\\r\\na->d[i]&=(~(((BN_ULONG)1)<<j));\\r\\nbn_correct_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_is_bit_set(const BIGNUM *a, int n)\\r\\n{\\r\\nint i,j;\\r\\nbn_check_top(a);\\r\\nif (n < 0) return 0;\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i) return 0;\\r\\nreturn((a->d[i]&(((BN_ULONG)1)<<j))?1:0);\\r\\n}\\r\\nint BN_mask_bits(BIGNUM *a, int n)\\r\\n{\\r\\nint b,w;\\r\\nbn_check_top(a);\\r\\nif (n < 0) return 0;\\r\\nw=n/BN_BITS2;\\r\\nb=n%BN_BITS2;\\r\\nif (w >= a->top) return 0;\\r\\nif (b == 0)\\r\\na->top=w;\\r\\nelse\\r\\n{\\r\\na->top=w+1;\\r\\na->d[w]&= ~(BN_MASK2<<b);\\r\\n}\\r\\nbn_correct_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nvoid BN_set_negative(BIGNUM *a, int b)\\r\\n{\\r\\nif (b && !BN_is_zero(a))\\r\\na->neg = 1;\\r\\nelse\\r\\na->neg = 0;\\r\\n}\\r\\nint bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG aa,bb;\\r\\naa=a[n-1];\\r\\nbb=b[n-1];\\r\\nif (aa != bb) return((aa > bb)?1:-1);\\r\\nfor (i=n-2; i>=0; i--)\\r\\n{\\r\\naa=a[i];\\r\\nbb=b[i];\\r\\nif (aa != bb) return((aa > bb)?1:-1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b,\\r\\nint cl, int dl)\\r\\n{\\r\\nint n,i;\\r\\nn = cl-1;\\r\\nif (dl < 0)\\r\\n{\\r\\nfor (i=dl; i<0; i++)\\r\\n{\\r\\nif (b[n-i] != 0)\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (dl > 0)\\r\\n{\\r\\nfor (i=dl; i>0; i--)\\r\\n{\\r\\nif (a[n+i] != 0)\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn bn_cmp_words(a,b,cl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_core_c", "target": 0, "func": "int AES_set_encrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key) {\\r\\nu32 *rk;\\r\\nint i = 0;\\r\\nu32 temp;\\r\\nif (!userKey || !key)\\r\\nreturn -1;\\r\\nif (bits != 128 && bits != 192 && bits != 256)\\r\\nreturn -2;\\r\\nrk = key->rd_key;\\r\\nif (bits==128)\\r\\nkey->rounds = 10;\\r\\nelse if (bits==192)\\r\\nkey->rounds = 12;\\r\\nelse\\r\\nkey->rounds = 14;\\r\\nrk[0] = GETU32(userKey );\\r\\nrk[1] = GETU32(userKey + 4);\\r\\nrk[2] = GETU32(userKey + 8);\\r\\nrk[3] = GETU32(userKey + 12);\\r\\nif (bits == 128) {\\r\\nwhile (1) {\\r\\ntemp = rk[3];\\r\\nrk[4] = rk[0] ^\\r\\n(Te4[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[5] = rk[1] ^ rk[4];\\r\\nrk[6] = rk[2] ^ rk[5];\\r\\nrk[7] = rk[3] ^ rk[6];\\r\\nif (++i == 10) {\\r\\nreturn 0;\\r\\n}\\r\\nrk += 4;\\r\\n}\\r\\n}\\r\\nrk[4] = GETU32(userKey + 16);\\r\\nrk[5] = GETU32(userKey + 20);\\r\\nif (bits == 192) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 5];\\r\\nrk[ 6] = rk[ 0] ^\\r\\n(Te4[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[ 7] = rk[ 1] ^ rk[ 6];\\r\\nrk[ 8] = rk[ 2] ^ rk[ 7];\\r\\nrk[ 9] = rk[ 3] ^ rk[ 8];\\r\\nif (++i == 8) {\\r\\nreturn 0;\\r\\n}\\r\\nrk[10] = rk[ 4] ^ rk[ 9];\\r\\nrk[11] = rk[ 5] ^ rk[10];\\r\\nrk += 6;\\r\\n}\\r\\n}\\r\\nrk[6] = GETU32(userKey + 24);\\r\\nrk[7] = GETU32(userKey + 28);\\r\\nif (bits == 256) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 7];\\r\\nrk[ 8] = rk[ 0] ^\\r\\n(Te4[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te4[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[ 9] = rk[ 1] ^ rk[ 8];\\r\\nrk[10] = rk[ 2] ^ rk[ 9];\\r\\nrk[11] = rk[ 3] ^ rk[10];\\r\\nif (++i == 7) {\\r\\nreturn 0;\\r\\n}\\r\\ntemp = rk[11];\\r\\nrk[12] = rk[ 4] ^\\r\\n(Te4[(temp >> 24) ] & 0xff000000) ^\\r\\n(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(temp >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(temp ) & 0xff] & 0x000000ff);\\r\\nrk[13] = rk[ 5] ^ rk[12];\\r\\nrk[14] = rk[ 6] ^ rk[13];\\r\\nrk[15] = rk[ 7] ^ rk[14];\\r\\nrk += 8;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key) {\\r\\nu32 *rk;\\r\\nint i, j, status;\\r\\nu32 temp;\\r\\nstatus = AES_set_encrypt_key(userKey, bits, key);\\r\\nif (status < 0)\\r\\nreturn status;\\r\\nrk = key->rd_key;\\r\\nfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\\r\\ntemp = rk[i ]; rk[i ] = rk[j ]; rk[j ] = temp;\\r\\ntemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\\r\\ntemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\\r\\ntemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\\r\\n}\\r\\nfor (i = 1; i < (key->rounds); i++) {\\r\\nrk += 4;\\r\\nrk[0] =\\r\\nTd0[Te4[(rk[0] >> 24) ] & 0xff] ^\\r\\nTd1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te4[(rk[0] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te4[(rk[0] ) & 0xff] & 0xff];\\r\\nrk[1] =\\r\\nTd0[Te4[(rk[1] >> 24) ] & 0xff] ^\\r\\nTd1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te4[(rk[1] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te4[(rk[1] ) & 0xff] & 0xff];\\r\\nrk[2] =\\r\\nTd0[Te4[(rk[2] >> 24) ] & 0xff] ^\\r\\nTd1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te4[(rk[2] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te4[(rk[2] ) & 0xff] & 0xff];\\r\\nrk[3] =\\r\\nTd0[Te4[(rk[3] >> 24) ] & 0xff] ^\\r\\nTd1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te4[(rk[3] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te4[(rk[3] ) & 0xff] & 0xff];\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key) {\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t0, t1, t2, t3;\\r\\n#ifndef FULL_UNROLL\\r\\nint r;\\r\\n#endif\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#ifdef FULL_UNROLL\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\\r\\nif (key->rounds > 10) {\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\\r\\nif (key->rounds > 12) {\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\\r\\n}\\r\\n}\\r\\nrk += key->rounds << 2;\\r\\n#else\\r\\nr = key->rounds >> 1;\\r\\nfor (;;) {\\r\\nt0 =\\r\\nTe0[(s0 >> 24) ] ^\\r\\nTe1[(s1 >> 16) & 0xff] ^\\r\\nTe2[(s2 >> 8) & 0xff] ^\\r\\nTe3[(s3 ) & 0xff] ^\\r\\nrk[4];\\r\\nt1 =\\r\\nTe0[(s1 >> 24) ] ^\\r\\nTe1[(s2 >> 16) & 0xff] ^\\r\\nTe2[(s3 >> 8) & 0xff] ^\\r\\nTe3[(s0 ) & 0xff] ^\\r\\nrk[5];\\r\\nt2 =\\r\\nTe0[(s2 >> 24) ] ^\\r\\nTe1[(s3 >> 16) & 0xff] ^\\r\\nTe2[(s0 >> 8) & 0xff] ^\\r\\nTe3[(s1 ) & 0xff] ^\\r\\nrk[6];\\r\\nt3 =\\r\\nTe0[(s3 >> 24) ] ^\\r\\nTe1[(s0 >> 16) & 0xff] ^\\r\\nTe2[(s1 >> 8) & 0xff] ^\\r\\nTe3[(s2 ) & 0xff] ^\\r\\nrk[7];\\r\\nrk += 8;\\r\\nif (--r == 0) {\\r\\nbreak;\\r\\n}\\r\\ns0 =\\r\\nTe0[(t0 >> 24) ] ^\\r\\nTe1[(t1 >> 16) & 0xff] ^\\r\\nTe2[(t2 >> 8) & 0xff] ^\\r\\nTe3[(t3 ) & 0xff] ^\\r\\nrk[0];\\r\\ns1 =\\r\\nTe0[(t1 >> 24) ] ^\\r\\nTe1[(t2 >> 16) & 0xff] ^\\r\\nTe2[(t3 >> 8) & 0xff] ^\\r\\nTe3[(t0 ) & 0xff] ^\\r\\nrk[1];\\r\\ns2 =\\r\\nTe0[(t2 >> 24) ] ^\\r\\nTe1[(t3 >> 16) & 0xff] ^\\r\\nTe2[(t0 >> 8) & 0xff] ^\\r\\nTe3[(t1 ) & 0xff] ^\\r\\nrk[2];\\r\\ns3 =\\r\\nTe0[(t3 >> 24) ] ^\\r\\nTe1[(t0 >> 16) & 0xff] ^\\r\\nTe2[(t1 >> 8) & 0xff] ^\\r\\nTe3[(t2 ) & 0xff] ^\\r\\nrk[3];\\r\\n}\\r\\n#endif\\r\\ns0 =\\r\\n(Te4[(t0 >> 24) ] & 0xff000000) ^\\r\\n(Te4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(t2 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(t3 ) & 0xff] & 0x000000ff) ^\\r\\nrk[0];\\r\\nPUTU32(out , s0);\\r\\ns1 =\\r\\n(Te4[(t1 >> 24) ] & 0xff000000) ^\\r\\n(Te4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(t3 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(t0 ) & 0xff] & 0x000000ff) ^\\r\\nrk[1];\\r\\nPUTU32(out + 4, s1);\\r\\ns2 =\\r\\n(Te4[(t2 >> 24) ] & 0xff000000) ^\\r\\n(Te4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(t0 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(t1 ) & 0xff] & 0x000000ff) ^\\r\\nrk[2];\\r\\nPUTU32(out + 8, s2);\\r\\ns3 =\\r\\n(Te4[(t3 >> 24) ] & 0xff000000) ^\\r\\n(Te4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te4[(t1 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te4[(t2 ) & 0xff] & 0x000000ff) ^\\r\\nrk[3];\\r\\nPUTU32(out + 12, s3);\\r\\n}\\r\\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key) {\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t0, t1, t2, t3;\\r\\n#ifndef FULL_UNROLL\\r\\nint r;\\r\\n#endif\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#ifdef FULL_UNROLL\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\\r\\nif (key->rounds > 10) {\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\\r\\nif (key->rounds > 12) {\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\\r\\n}\\r\\n}\\r\\nrk += key->rounds << 2;\\r\\n#else\\r\\nr = key->rounds >> 1;\\r\\nfor (;;) {\\r\\nt0 =\\r\\nTd0[(s0 >> 24) ] ^\\r\\nTd1[(s3 >> 16) & 0xff] ^\\r\\nTd2[(s2 >> 8) & 0xff] ^\\r\\nTd3[(s1 ) & 0xff] ^\\r\\nrk[4];\\r\\nt1 =\\r\\nTd0[(s1 >> 24) ] ^\\r\\nTd1[(s0 >> 16) & 0xff] ^\\r\\nTd2[(s3 >> 8) & 0xff] ^\\r\\nTd3[(s2 ) & 0xff] ^\\r\\nrk[5];\\r\\nt2 =\\r\\nTd0[(s2 >> 24) ] ^\\r\\nTd1[(s1 >> 16) & 0xff] ^\\r\\nTd2[(s0 >> 8) & 0xff] ^\\r\\nTd3[(s3 ) & 0xff] ^\\r\\nrk[6];\\r\\nt3 =\\r\\nTd0[(s3 >> 24) ] ^\\r\\nTd1[(s2 >> 16) & 0xff] ^\\r\\nTd2[(s1 >> 8) & 0xff] ^\\r\\nTd3[(s0 ) & 0xff] ^\\r\\nrk[7];\\r\\nrk += 8;\\r\\nif (--r == 0) {\\r\\nbreak;\\r\\n}\\r\\ns0 =\\r\\nTd0[(t0 >> 24) ] ^\\r\\nTd1[(t3 >> 16) & 0xff] ^\\r\\nTd2[(t2 >> 8) & 0xff] ^\\r\\nTd3[(t1 ) & 0xff] ^\\r\\nrk[0];\\r\\ns1 =\\r\\nTd0[(t1 >> 24) ] ^\\r\\nTd1[(t0 >> 16) & 0xff] ^\\r\\nTd2[(t3 >> 8) & 0xff] ^\\r\\nTd3[(t2 ) & 0xff] ^\\r\\nrk[1];\\r\\ns2 =\\r\\nTd0[(t2 >> 24) ] ^\\r\\nTd1[(t1 >> 16) & 0xff] ^\\r\\nTd2[(t0 >> 8) & 0xff] ^\\r\\nTd3[(t3 ) & 0xff] ^\\r\\nrk[2];\\r\\ns3 =\\r\\nTd0[(t3 >> 24) ] ^\\r\\nTd1[(t2 >> 16) & 0xff] ^\\r\\nTd2[(t1 >> 8) & 0xff] ^\\r\\nTd3[(t0 ) & 0xff] ^\\r\\nrk[3];\\r\\n}\\r\\n#endif\\r\\ns0 =\\r\\n(Td4[(t0 >> 24) ] & 0xff000000) ^\\r\\n(Td4[(t3 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Td4[(t2 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Td4[(t1 ) & 0xff] & 0x000000ff) ^\\r\\nrk[0];\\r\\nPUTU32(out , s0);\\r\\ns1 =\\r\\n(Td4[(t1 >> 24) ] & 0xff000000) ^\\r\\n(Td4[(t0 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Td4[(t3 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Td4[(t2 ) & 0xff] & 0x000000ff) ^\\r\\nrk[1];\\r\\nPUTU32(out + 4, s1);\\r\\ns2 =\\r\\n(Td4[(t2 >> 24) ] & 0xff000000) ^\\r\\n(Td4[(t1 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Td4[(t0 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Td4[(t3 ) & 0xff] & 0x000000ff) ^\\r\\nrk[2];\\r\\nPUTU32(out + 8, s2);\\r\\ns3 =\\r\\n(Td4[(t3 >> 24) ] & 0xff000000) ^\\r\\n(Td4[(t2 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Td4[(t1 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Td4[(t0 ) & 0xff] & 0x000000ff) ^\\r\\nrk[3];\\r\\nPUTU32(out + 12, s3);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_enc_c", "target": 0, "func": "int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_flags_i2d(val, out, it, ASN1_TFLG_NDEF);\\r\\n}\\r\\nint ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_flags_i2d(val, out, it, 0);\\r\\n}\\r\\nstatic int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int flags)\\r\\n{\\r\\nif (out && !*out)\\r\\n{\\r\\nunsigned char *p, *buf;\\r\\nint len;\\r\\nlen = ASN1_item_ex_i2d(&val, NULL, it, -1, flags);\\r\\nif (len <= 0)\\r\\nreturn len;\\r\\nbuf = OPENSSL_malloc(len);\\r\\nif (!buf)\\r\\nreturn -1;\\r\\np = buf;\\r\\nASN1_item_ex_i2d(&val, &p, it, -1, flags);\\r\\n*out = buf;\\r\\nreturn len;\\r\\n}\\r\\nreturn ASN1_item_ex_i2d(&val, out, it, -1, flags);\\r\\n}\\r\\nint ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL;\\r\\nunsigned char *p = NULL;\\r\\nint i, seqcontlen, seqlen, ndef = 1;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb = 0;\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\\r\\nreturn 0;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nswitch(it->itype)\\r\\n{\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nreturn asn1_template_ex_i2d(pval, out, it->templates,\\r\\ntag, aclass);\\r\\nreturn asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nreturn asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))\\r\\nreturn 0;\\r\\ni = asn1_get_choice_selector(pval, it);\\r\\nif ((i >= 0) && (i < it->tcount))\\r\\n{\\r\\nASN1_VALUE **pchval;\\r\\nconst ASN1_TEMPLATE *chtt;\\r\\nchtt = it->templates + i;\\r\\npchval = asn1_get_field_ptr(pval, chtt);\\r\\nreturn asn1_template_ex_i2d(pchval, out, chtt,\\r\\n-1, aclass);\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nreturn ef->asn1_ex_i2d(pval, out, it, tag, aclass);\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (out)\\r\\np = *out;\\r\\ni = cf->asn1_i2d(*pval, out);\\r\\nif (out && (tag != -1))\\r\\n*p = aclass | tag | (*p & V_ASN1_CONSTRUCTED);\\r\\nreturn i;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\nif (aclass & ASN1_TFLG_NDEF) ndef = 2;\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\ni = asn1_enc_restore(&seqcontlen, out, pval, it);\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nif (i > 0)\\r\\nreturn seqcontlen;\\r\\nseqcontlen = 0;\\r\\nif (tag == -1)\\r\\n{\\r\\ntag = V_ASN1_SEQUENCE;\\r\\naclass = (aclass & ~ASN1_TFLG_TAG_CLASS)\\r\\n| V_ASN1_UNIVERSAL;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it))\\r\\nreturn 0;\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\\r\\n{\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\nreturn 0;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nseqcontlen += asn1_template_ex_i2d(pseqval, NULL, seqtt,\\r\\n-1, aclass);\\r\\n}\\r\\nseqlen = ASN1_object_size(ndef, seqcontlen, tag);\\r\\nif (!out)\\r\\nreturn seqlen;\\r\\nASN1_put_object(out, ndef, seqcontlen, tag, aclass);\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\\r\\n{\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\nreturn 0;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nasn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\\r\\n}\\r\\nif (ndef == 2)\\r\\nASN1_put_eoc(out);\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it))\\r\\nreturn 0;\\r\\nreturn seqlen;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_TEMPLATE *tt)\\r\\n{\\r\\nreturn asn1_template_ex_i2d(pval, out, tt, -1, 0);\\r\\n}\\r\\nstatic int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_TEMPLATE *tt, int tag, int iclass)\\r\\n{\\r\\nint i, ret, flags, ttag, tclass, ndef;\\r\\nflags = tt->flags;\\r\\nif (flags & ASN1_TFLG_TAG_MASK)\\r\\n{\\r\\nif (tag != -1)\\r\\nreturn -1;\\r\\nttag = tt->tag;\\r\\ntclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\n}\\r\\nelse if (tag != -1)\\r\\n{\\r\\nttag = tag;\\r\\ntclass = iclass & ASN1_TFLG_TAG_CLASS;\\r\\n}\\r\\nelse\\r\\n{\\r\\nttag = -1;\\r\\ntclass = 0;\\r\\n}\\r\\niclass &= ~ASN1_TFLG_TAG_CLASS;\\r\\nif ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))\\r\\nndef = 2;\\r\\nelse ndef = 1;\\r\\nif (flags & ASN1_TFLG_SK_MASK)\\r\\n{\\r\\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\\r\\nint isset, sktag, skaclass;\\r\\nint skcontlen, sklen;\\r\\nASN1_VALUE *skitem;\\r\\nif (!*pval)\\r\\nreturn 0;\\r\\nif (flags & ASN1_TFLG_SET_OF)\\r\\n{\\r\\nisset = 1;\\r\\nif (flags & ASN1_TFLG_SEQUENCE_OF)\\r\\nisset = 2;\\r\\n}\\r\\nelse isset = 0;\\r\\nif ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG))\\r\\n{\\r\\nsktag = ttag;\\r\\nskaclass = tclass;\\r\\n}\\r\\nelse\\r\\n{\\r\\nskaclass = V_ASN1_UNIVERSAL;\\r\\nif (isset)\\r\\nsktag = V_ASN1_SET;\\r\\nelse sktag = V_ASN1_SEQUENCE;\\r\\n}\\r\\nskcontlen = 0;\\r\\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++)\\r\\n{\\r\\nskitem = sk_ASN1_VALUE_value(sk, i);\\r\\nskcontlen += ASN1_item_ex_i2d(&skitem, NULL,\\r\\nASN1_ITEM_ptr(tt->item),\\r\\n-1, iclass);\\r\\n}\\r\\nsklen = ASN1_object_size(ndef, skcontlen, sktag);\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nret = ASN1_object_size(ndef, sklen, ttag);\\r\\nelse ret = sklen;\\r\\nif (!out)\\r\\nreturn ret;\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nASN1_put_object(out, ndef, sklen, ttag, tclass);\\r\\nASN1_put_object(out, ndef, skcontlen, sktag, skaclass);\\r\\nasn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),\\r\\nisset, iclass);\\r\\nif (ndef == 2)\\r\\n{\\r\\nASN1_put_eoc(out);\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nASN1_put_eoc(out);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\n{\\r\\ni = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item),\\r\\n-1, iclass);\\r\\nif (!i)\\r\\nreturn 0;\\r\\nret = ASN1_object_size(ndef, i, ttag);\\r\\nif (out)\\r\\n{\\r\\nASN1_put_object(out, ndef, i, ttag, tclass);\\r\\nASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),\\r\\n-1, iclass);\\r\\nif (ndef == 2)\\r\\nASN1_put_eoc(out);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nreturn ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),\\r\\nttag, tclass | iclass);\\r\\n}\\r\\nstatic int der_cmp(const void *a, const void *b)\\r\\n{\\r\\nconst DER_ENC *d1 = a, *d2 = b;\\r\\nint cmplen, i;\\r\\ncmplen = (d1->length < d2->length) ? d1->length : d2->length;\\r\\ni = memcmp(d1->data, d2->data, cmplen);\\r\\nif (i)\\r\\nreturn i;\\r\\nreturn d1->length - d2->length;\\r\\n}\\r\\nstatic int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nint len;\\r\\nint utype;\\r\\nint usetag;\\r\\nint ndef = 0;\\r\\nutype = it->utype;\\r\\nlen = asn1_ex_i2c(pval, NULL, &utype, it);\\r\\nif ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||\\r\\n(utype == V_ASN1_OTHER))\\r\\nusetag = 0;\\r\\nelse usetag = 1;\\r\\nif (len == -1)\\r\\nreturn 0;\\r\\nif (len == -2)\\r\\n{\\r\\nndef = 2;\\r\\nlen = 0;\\r\\n}\\r\\nif (tag == -1) tag = utype;\\r\\nif (out)\\r\\n{\\r\\nif (usetag)\\r\\nASN1_put_object(out, ndef, len, tag, aclass);\\r\\nasn1_ex_i2c(pval, *out, &utype, it);\\r\\nif (ndef)\\r\\nASN1_put_eoc(out);\\r\\nelse\\r\\n*out += len;\\r\\n}\\r\\nif (usetag)\\r\\nreturn ASN1_object_size(ndef, len, tag);\\r\\nreturn len;\\r\\n}\\r\\nint asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_BOOLEAN *tbool = NULL;\\r\\nASN1_STRING *strtmp;\\r\\nASN1_OBJECT *otmp;\\r\\nint utype;\\r\\nunsigned char *cont, c;\\r\\nint len;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_i2c)\\r\\nreturn pf->prim_i2c(pval, cout, putype, it);\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE)\\r\\n|| (it->utype != V_ASN1_BOOLEAN))\\r\\n{\\r\\nif (!*pval) return -1;\\r\\n}\\r\\nif (it->itype == ASN1_ITYPE_MSTRING)\\r\\n{\\r\\nstrtmp = (ASN1_STRING *)*pval;\\r\\nutype = strtmp->type;\\r\\n*putype = utype;\\r\\n}\\r\\nelse if (it->utype == V_ASN1_ANY)\\r\\n{\\r\\nASN1_TYPE *typ;\\r\\ntyp = (ASN1_TYPE *)*pval;\\r\\nutype = typ->type;\\r\\n*putype = utype;\\r\\npval = (ASN1_VALUE **)&typ->value.ptr;\\r\\n}\\r\\nelse utype = *putype;\\r\\nswitch(utype)\\r\\n{\\r\\ncase V_ASN1_OBJECT:\\r\\notmp = (ASN1_OBJECT *)*pval;\\r\\ncont = otmp->data;\\r\\nlen = otmp->length;\\r\\nbreak;\\r\\ncase V_ASN1_NULL:\\r\\ncont = NULL;\\r\\nlen = 0;\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\ntbool = (ASN1_BOOLEAN *)pval;\\r\\nif (*tbool == -1)\\r\\nreturn -1;\\r\\nif (*tbool && (it->size > 0))\\r\\nreturn -1;\\r\\nif (!*tbool && !it->size)\\r\\nreturn -1;\\r\\nc = (unsigned char)*tbool;\\r\\ncont = &c;\\r\\nlen = 1;\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nreturn i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,\\r\\ncout ? &cout : NULL);\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\nreturn i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval,\\r\\ncout ? &cout : NULL);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ncase V_ASN1_SET:\\r\\ndefault:\\r\\nstrtmp = (ASN1_STRING *)*pval;\\r\\nif ((it->size == ASN1_TFLG_NDEF)\\r\\n&& (strtmp->flags & ASN1_STRING_FLAG_NDEF))\\r\\n{\\r\\nif (cout)\\r\\n{\\r\\nstrtmp->data = cout;\\r\\nstrtmp->length = 0;\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\ncont = strtmp->data;\\r\\nlen = strtmp->length;\\r\\nbreak;\\r\\n}\\r\\nif (cout && len)\\r\\nmemcpy(cout, cont, len);\\r\\nreturn len;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_buf_err_c", "target": 0, "func": "void ERR_load_BUF_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,BUF_str_functs);\\r\\nERR_load_strings(0,BUF_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_cswift_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth2;\\r\\n#endif\\r\\nif(!ENGINE_set_id(e, engine_cswift_id) ||\\r\\n!ENGINE_set_name(e, engine_cswift_name) ||\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &cswift_rsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\n!ENGINE_set_DSA(e, &cswift_dsa) ||\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &cswift_dh) ||\\r\\n#endif\\r\\n!ENGINE_set_RAND(e, &cswift_random) ||\\r\\n!ENGINE_set_destroy_function(e, cswift_destroy) ||\\r\\n!ENGINE_set_init_function(e, cswift_init) ||\\r\\n!ENGINE_set_finish_function(e, cswift_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, cswift_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(e, cswift_cmd_defns))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\ncswift_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\ncswift_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\ncswift_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\ncswift_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nmeth2 = DH_OpenSSL();\\r\\ncswift_dh.generate_key = meth2->generate_key;\\r\\ncswift_dh.compute_key = meth2->compute_key;\\r\\n#endif\\r\\nERR_load_CSWIFT_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_cswift(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif(!ret)\\r\\nreturn NULL;\\r\\nif(!bind_helper(ret))\\r\\n{\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_cswift(void)\\r\\n{\\r\\nENGINE *toadd = engine_cswift();\\r\\nif(!toadd) return;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic const char *get_CSWIFT_LIBNAME(void)\\r\\n{\\r\\nif(CSWIFT_LIBNAME)\\r\\nreturn CSWIFT_LIBNAME;\\r\\nreturn \"swift\";\\r\\n}\\r\\nstatic void free_CSWIFT_LIBNAME(void)\\r\\n{\\r\\nif(CSWIFT_LIBNAME)\\r\\nOPENSSL_free((void*)CSWIFT_LIBNAME);\\r\\nCSWIFT_LIBNAME = NULL;\\r\\n}\\r\\nstatic long set_CSWIFT_LIBNAME(const char *name)\\r\\n{\\r\\nfree_CSWIFT_LIBNAME();\\r\\nreturn (((CSWIFT_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int get_context(SW_CONTEXT_HANDLE *hac)\\r\\n{\\r\\nSW_STATUS status;\\r\\nstatus = p_CSwift_AcquireAccContext(hac);\\r\\nif(status != SW_OK)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void release_context(SW_CONTEXT_HANDLE hac)\\r\\n{\\r\\np_CSwift_ReleaseAccContext(hac);\\r\\n}\\r\\nstatic int cswift_destroy(ENGINE *e)\\r\\n{\\r\\nfree_CSWIFT_LIBNAME();\\r\\nERR_unload_CSWIFT_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cswift_init(ENGINE *e)\\r\\n{\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nt_swAcquireAccContext *p1;\\r\\nt_swAttachKeyParam *p2;\\r\\nt_swSimpleRequest *p3;\\r\\nt_swReleaseAccContext *p4;\\r\\nif(cswift_dso != NULL)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_INIT,CSWIFT_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\ncswift_dso = DSO_load(NULL, get_CSWIFT_LIBNAME(), NULL, 0);\\r\\nif(cswift_dso == NULL)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_INIT,CSWIFT_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif(!(p1 = (t_swAcquireAccContext *)\\r\\nDSO_bind_func(cswift_dso, CSWIFT_F1)) ||\\r\\n!(p2 = (t_swAttachKeyParam *)\\r\\nDSO_bind_func(cswift_dso, CSWIFT_F2)) ||\\r\\n!(p3 = (t_swSimpleRequest *)\\r\\nDSO_bind_func(cswift_dso, CSWIFT_F3)) ||\\r\\n!(p4 = (t_swReleaseAccContext *)\\r\\nDSO_bind_func(cswift_dso, CSWIFT_F4)))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_INIT,CSWIFT_R_NOT_LOADED);\\r\\ngoto err;\\r\\n}\\r\\np_CSwift_AcquireAccContext = p1;\\r\\np_CSwift_AttachKeyParam = p2;\\r\\np_CSwift_SimpleRequest = p3;\\r\\np_CSwift_ReleaseAccContext = p4;\\r\\nif(!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_INIT,CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nrelease_context(hac);\\r\\nreturn 1;\\r\\nerr:\\r\\nif(cswift_dso)\\r\\n{\\r\\nDSO_free(cswift_dso);\\r\\ncswift_dso = NULL;\\r\\n}\\r\\np_CSwift_AcquireAccContext = NULL;\\r\\np_CSwift_AttachKeyParam = NULL;\\r\\np_CSwift_SimpleRequest = NULL;\\r\\np_CSwift_ReleaseAccContext = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int cswift_finish(ENGINE *e)\\r\\n{\\r\\nfree_CSWIFT_LIBNAME();\\r\\nif(cswift_dso == NULL)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_FINISH,CSWIFT_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif(!DSO_free(cswift_dso))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_FINISH,CSWIFT_R_UNIT_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ncswift_dso = NULL;\\r\\np_CSwift_AcquireAccContext = NULL;\\r\\np_CSwift_AttachKeyParam = NULL;\\r\\np_CSwift_SimpleRequest = NULL;\\r\\np_CSwift_ReleaseAccContext = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cswift_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\\r\\n{\\r\\nint initialised = ((cswift_dso == NULL) ? 0 : 1);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase CSWIFT_CMD_SO_PATH:\\r\\nif(p == NULL)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif(initialised)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_CTRL,CSWIFT_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_CSWIFT_LIBNAME((const char *)p);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_CTRL,CSWIFT_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int cswift_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *modulus;\\r\\nBIGNUM *exponent;\\r\\nBIGNUM *argument;\\r\\nBIGNUM *result;\\r\\nSW_STATUS sw_status;\\r\\nSW_LARGENUMBER arg, res;\\r\\nSW_PARAM sw_param;\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nint to_return, acquired;\\r\\nmodulus = exponent = argument = result = NULL;\\r\\nto_return = 0;\\r\\nacquired = 0;\\r\\nif(!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nacquired = 1;\\r\\nBN_CTX_start(ctx);\\r\\nmodulus = BN_CTX_get(ctx);\\r\\nexponent = BN_CTX_get(ctx);\\r\\nargument = BN_CTX_get(ctx);\\r\\nresult = BN_CTX_get(ctx);\\r\\nif(!result)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(modulus, m->top) || !bn_wexpand(exponent, p->top) ||\\r\\n!bn_wexpand(argument, a->top) || !bn_wexpand(result, m->top))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nsw_param.type = SW_ALG_EXP;\\r\\nsw_param.up.exp.modulus.nbytes = BN_bn2bin(m,\\r\\n(unsigned char *)modulus->d);\\r\\nsw_param.up.exp.modulus.value = (unsigned char *)modulus->d;\\r\\nsw_param.up.exp.exponent.nbytes = BN_bn2bin(p,\\r\\n(unsigned char *)exponent->d);\\r\\nsw_param.up.exp.exponent.value = (unsigned char *)exponent->d;\\r\\nsw_status = p_CSwift_AttachKeyParam(hac, &sw_param);\\r\\nswitch(sw_status)\\r\\n{\\r\\ncase SW_OK:\\r\\nbreak;\\r\\ncase SW_ERR_INPUT_SIZE:\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_BAD_KEY_SIZE);\\r\\ngoto err;\\r\\ndefault:\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\narg.nbytes = BN_bn2bin(a, (unsigned char *)argument->d);\\r\\narg.value = (unsigned char *)argument->d;\\r\\nres.nbytes = BN_num_bytes(m);\\r\\nmemset(result->d, 0, res.nbytes);\\r\\nres.value = (unsigned char *)result->d;\\r\\nif((sw_status = p_CSwift_SimpleRequest(hac, SW_CMD_MODEXP, &arg, 1,\\r\\n&res, 1)) != SW_OK)\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nBN_bin2bn((unsigned char *)result->d, res.nbytes, r);\\r\\nto_return = 1;\\r\\nerr:\\r\\nif(acquired)\\r\\nrelease_context(hac);\\r\\nBN_CTX_end(ctx);\\r\\nreturn to_return;\\r\\n}\\r\\nint cswift_bn_32copy(SW_LARGENUMBER * out, const BIGNUM * in)\\r\\n{\\r\\nint mod;\\r\\nint numbytes = BN_num_bytes(in);\\r\\nmod = 0;\\r\\nwhile( ((out->nbytes = (numbytes+mod)) % 32) )\\r\\n{\\r\\nmod++;\\r\\n}\\r\\nout->value = (unsigned char*)OPENSSL_malloc(out->nbytes);\\r\\nif(!out->value)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nBN_bn2bin(in, &out->value[mod]);\\r\\nif(mod)\\r\\nmemset(out->value, 0, mod);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cswift_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *q, const BIGNUM *dmp1,\\r\\nconst BIGNUM *dmq1, const BIGNUM *iqmp, BN_CTX *ctx)\\r\\n{\\r\\nSW_STATUS sw_status;\\r\\nSW_LARGENUMBER arg, res;\\r\\nSW_PARAM sw_param;\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nBIGNUM *result = NULL;\\r\\nBIGNUM *argument = NULL;\\r\\nint to_return = 0;\\r\\nint acquired = 0;\\r\\nsw_param.up.crt.p.value = NULL;\\r\\nsw_param.up.crt.q.value = NULL;\\r\\nsw_param.up.crt.dmp1.value = NULL;\\r\\nsw_param.up.crt.dmq1.value = NULL;\\r\\nsw_param.up.crt.iqmp.value = NULL;\\r\\nif(!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nacquired = 1;\\r\\nargument = BN_new();\\r\\nresult = BN_new();\\r\\nif(!result || !argument)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nsw_param.type = SW_ALG_CRT;\\r\\nif(!cswift_bn_32copy(&sw_param.up.crt.p, p))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif(!cswift_bn_32copy(&sw_param.up.crt.q, q))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif(!cswift_bn_32copy(&sw_param.up.crt.dmp1, dmp1))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif(!cswift_bn_32copy(&sw_param.up.crt.dmq1, dmq1))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif(!cswift_bn_32copy(&sw_param.up.crt.iqmp, iqmp))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nif( !bn_wexpand(argument, a->top) ||\\r\\n!bn_wexpand(result, p->top + q->top))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nsw_status = p_CSwift_AttachKeyParam(hac, &sw_param);\\r\\nswitch(sw_status)\\r\\n{\\r\\ncase SW_OK:\\r\\nbreak;\\r\\ncase SW_ERR_INPUT_SIZE:\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_BAD_KEY_SIZE);\\r\\ngoto err;\\r\\ndefault:\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\narg.nbytes = BN_bn2bin(a, (unsigned char *)argument->d);\\r\\narg.value = (unsigned char *)argument->d;\\r\\nres.nbytes = 2 * BN_num_bytes(p);\\r\\nmemset(result->d, 0, res.nbytes);\\r\\nres.value = (unsigned char *)result->d;\\r\\nif((sw_status = p_CSwift_SimpleRequest(hac, SW_CMD_MODEXP_CRT, &arg, 1,\\r\\n&res, 1)) != SW_OK)\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_MOD_EXP_CRT,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nBN_bin2bn((unsigned char *)result->d, res.nbytes, r);\\r\\nto_return = 1;\\r\\nerr:\\r\\nif(sw_param.up.crt.p.value)\\r\\nOPENSSL_free(sw_param.up.crt.p.value);\\r\\nif(sw_param.up.crt.q.value)\\r\\nOPENSSL_free(sw_param.up.crt.q.value);\\r\\nif(sw_param.up.crt.dmp1.value)\\r\\nOPENSSL_free(sw_param.up.crt.dmp1.value);\\r\\nif(sw_param.up.crt.dmq1.value)\\r\\nOPENSSL_free(sw_param.up.crt.dmq1.value);\\r\\nif(sw_param.up.crt.iqmp.value)\\r\\nOPENSSL_free(sw_param.up.crt.iqmp.value);\\r\\nif(result)\\r\\nBN_free(result);\\r\\nif(argument)\\r\\nBN_free(argument);\\r\\nif(acquired)\\r\\nrelease_context(hac);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int cswift_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint to_return = 0;\\r\\nconst RSA_METHOD * def_rsa_method;\\r\\nif(BN_num_bytes(rsa->p) > 128 ||\\r\\nBN_num_bytes(rsa->q) > 128 ||\\r\\nBN_num_bytes(rsa->dmp1) > 128 ||\\r\\nBN_num_bytes(rsa->dmq1) > 128 ||\\r\\nBN_num_bytes(rsa->iqmp) > 128)\\r\\n{\\r\\n#ifdef RSA_NULL\\r\\ndef_rsa_method=RSA_null_method();\\r\\n#else\\r\\n#if 0\\r\\ndef_rsa_method=RSA_PKCS1_RSAref();\\r\\n#else\\r\\ndef_rsa_method=RSA_PKCS1_SSLeay();\\r\\n#endif\\r\\n#endif\\r\\nif(def_rsa_method)\\r\\nreturn def_rsa_method->rsa_mod_exp(r0, I, rsa, ctx);\\r\\n}\\r\\nif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_RSA_MOD_EXP,CSWIFT_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nto_return = cswift_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\\r\\nrsa->dmq1, rsa->iqmp, ctx);\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int cswift_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nconst RSA_METHOD * def_rsa_method;\\r\\nif(BN_num_bytes(r) > 256 ||\\r\\nBN_num_bytes(a) > 256 ||\\r\\nBN_num_bytes(m) > 256)\\r\\n{\\r\\n#ifdef RSA_NULL\\r\\ndef_rsa_method=RSA_null_method();\\r\\n#else\\r\\n#if 0\\r\\ndef_rsa_method=RSA_PKCS1_RSAref();\\r\\n#else\\r\\ndef_rsa_method=RSA_PKCS1_SSLeay();\\r\\n#endif\\r\\n#endif\\r\\nif(def_rsa_method)\\r\\nreturn def_rsa_method->bn_mod_exp(r, a, p, m, ctx, m_ctx);\\r\\n}\\r\\nreturn cswift_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic DSA_SIG *cswift_dsa_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nSW_PARAM sw_param;\\r\\nSW_STATUS sw_status;\\r\\nSW_LARGENUMBER arg, res;\\r\\nunsigned char *ptr;\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *dsa_p = NULL;\\r\\nBIGNUM *dsa_q = NULL;\\r\\nBIGNUM *dsa_g = NULL;\\r\\nBIGNUM *dsa_key = NULL;\\r\\nBIGNUM *result = NULL;\\r\\nDSA_SIG *to_return = NULL;\\r\\nint acquired = 0;\\r\\nif((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif(!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nacquired = 1;\\r\\nBN_CTX_start(ctx);\\r\\ndsa_p = BN_CTX_get(ctx);\\r\\ndsa_q = BN_CTX_get(ctx);\\r\\ndsa_g = BN_CTX_get(ctx);\\r\\ndsa_key = BN_CTX_get(ctx);\\r\\nresult = BN_CTX_get(ctx);\\r\\nif(!result)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(dsa_p, dsa->p->top) ||\\r\\n!bn_wexpand(dsa_q, dsa->q->top) ||\\r\\n!bn_wexpand(dsa_g, dsa->g->top) ||\\r\\n!bn_wexpand(dsa_key, dsa->priv_key->top) ||\\r\\n!bn_wexpand(result, dsa->p->top))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nsw_param.type = SW_ALG_DSA;\\r\\nsw_param.up.dsa.p.nbytes = BN_bn2bin(dsa->p,\\r\\n(unsigned char *)dsa_p->d);\\r\\nsw_param.up.dsa.p.value = (unsigned char *)dsa_p->d;\\r\\nsw_param.up.dsa.q.nbytes = BN_bn2bin(dsa->q,\\r\\n(unsigned char *)dsa_q->d);\\r\\nsw_param.up.dsa.q.value = (unsigned char *)dsa_q->d;\\r\\nsw_param.up.dsa.g.nbytes = BN_bn2bin(dsa->g,\\r\\n(unsigned char *)dsa_g->d);\\r\\nsw_param.up.dsa.g.value = (unsigned char *)dsa_g->d;\\r\\nsw_param.up.dsa.key.nbytes = BN_bn2bin(dsa->priv_key,\\r\\n(unsigned char *)dsa_key->d);\\r\\nsw_param.up.dsa.key.value = (unsigned char *)dsa_key->d;\\r\\nsw_status = p_CSwift_AttachKeyParam(hac, &sw_param);\\r\\nswitch(sw_status)\\r\\n{\\r\\ncase SW_OK:\\r\\nbreak;\\r\\ncase SW_ERR_INPUT_SIZE:\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_BAD_KEY_SIZE);\\r\\ngoto err;\\r\\ndefault:\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\narg.nbytes = dlen;\\r\\narg.value = (unsigned char *)dgst;\\r\\nres.nbytes = BN_num_bytes(dsa->p);\\r\\nmemset(result->d, 0, res.nbytes);\\r\\nres.value = (unsigned char *)result->d;\\r\\nsw_status = p_CSwift_SimpleRequest(hac, SW_CMD_DSS_SIGN, &arg, 1,\\r\\n&res, 1);\\r\\nif(sw_status != SW_OK)\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_SIGN,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nptr = (unsigned char *)result->d;\\r\\nif((to_return = DSA_SIG_new()) == NULL)\\r\\ngoto err;\\r\\nto_return->r = BN_bin2bn((unsigned char *)result->d, 20, NULL);\\r\\nto_return->s = BN_bin2bn((unsigned char *)result->d + 20, 20, NULL);\\r\\nerr:\\r\\nif(acquired)\\r\\nrelease_context(hac);\\r\\nif(ctx)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int cswift_dsa_verify(const unsigned char *dgst, int dgst_len,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nSW_PARAM sw_param;\\r\\nSW_STATUS sw_status;\\r\\nSW_LARGENUMBER arg[2], res;\\r\\nunsigned long sig_result;\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *dsa_p = NULL;\\r\\nBIGNUM *dsa_q = NULL;\\r\\nBIGNUM *dsa_g = NULL;\\r\\nBIGNUM *dsa_key = NULL;\\r\\nBIGNUM *argument = NULL;\\r\\nint to_return = -1;\\r\\nint acquired = 0;\\r\\nif((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif(!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nacquired = 1;\\r\\nBN_CTX_start(ctx);\\r\\ndsa_p = BN_CTX_get(ctx);\\r\\ndsa_q = BN_CTX_get(ctx);\\r\\ndsa_g = BN_CTX_get(ctx);\\r\\ndsa_key = BN_CTX_get(ctx);\\r\\nargument = BN_CTX_get(ctx);\\r\\nif(!argument)\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_BN_CTX_FULL);\\r\\ngoto err;\\r\\n}\\r\\nif(!bn_wexpand(dsa_p, dsa->p->top) ||\\r\\n!bn_wexpand(dsa_q, dsa->q->top) ||\\r\\n!bn_wexpand(dsa_g, dsa->g->top) ||\\r\\n!bn_wexpand(dsa_key, dsa->pub_key->top) ||\\r\\n!bn_wexpand(argument, 40))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_BN_EXPAND_FAIL);\\r\\ngoto err;\\r\\n}\\r\\nsw_param.type = SW_ALG_DSA;\\r\\nsw_param.up.dsa.p.nbytes = BN_bn2bin(dsa->p,\\r\\n(unsigned char *)dsa_p->d);\\r\\nsw_param.up.dsa.p.value = (unsigned char *)dsa_p->d;\\r\\nsw_param.up.dsa.q.nbytes = BN_bn2bin(dsa->q,\\r\\n(unsigned char *)dsa_q->d);\\r\\nsw_param.up.dsa.q.value = (unsigned char *)dsa_q->d;\\r\\nsw_param.up.dsa.g.nbytes = BN_bn2bin(dsa->g,\\r\\n(unsigned char *)dsa_g->d);\\r\\nsw_param.up.dsa.g.value = (unsigned char *)dsa_g->d;\\r\\nsw_param.up.dsa.key.nbytes = BN_bn2bin(dsa->pub_key,\\r\\n(unsigned char *)dsa_key->d);\\r\\nsw_param.up.dsa.key.value = (unsigned char *)dsa_key->d;\\r\\nsw_status = p_CSwift_AttachKeyParam(hac, &sw_param);\\r\\nswitch(sw_status)\\r\\n{\\r\\ncase SW_OK:\\r\\nbreak;\\r\\ncase SW_ERR_INPUT_SIZE:\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_BAD_KEY_SIZE);\\r\\ngoto err;\\r\\ndefault:\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\narg[0].nbytes = dgst_len;\\r\\narg[0].value = (unsigned char *)dgst;\\r\\narg[1].nbytes = 40;\\r\\narg[1].value = (unsigned char *)argument->d;\\r\\nmemset(arg[1].value, 0, 40);\\r\\nBN_bn2bin(sig->r, arg[1].value + 20 - BN_num_bytes(sig->r));\\r\\nBN_bn2bin(sig->s, arg[1].value + 40 - BN_num_bytes(sig->s));\\r\\nres.nbytes = 4;\\r\\nres.value = (unsigned char *)(&sig_result);\\r\\nsw_status = p_CSwift_SimpleRequest(hac, SW_CMD_DSS_VERIFY, arg, 2,\\r\\n&res, 1);\\r\\nif(sw_status != SW_OK)\\r\\n{\\r\\nchar tmpbuf[DECIMAL_SIZE(sw_status)+1];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_DSA_VERIFY,CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", sw_status);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \",tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nto_return = ((sig_result == 0) ? 0 : 1);\\r\\nerr:\\r\\nif(acquired)\\r\\nrelease_context(hac);\\r\\nif(ctx)\\r\\n{\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int cswift_mod_exp_dh(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn cswift_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int cswift_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nSW_CONTEXT_HANDLE hac;\\r\\nSW_STATUS swrc;\\r\\nSW_LARGENUMBER largenum;\\r\\nint acquired = 0;\\r\\nint to_return = 0;\\r\\nunsigned char buf32[1024];\\r\\nif (!get_context(&hac))\\r\\n{\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_RAND_BYTES, CSWIFT_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nacquired = 1;\\r\\nwhile(num >= sizeof(buf32))\\r\\n{\\r\\nlargenum.value = buf;\\r\\nlargenum.nbytes = sizeof(buf32);\\r\\nswrc = p_CSwift_SimpleRequest(hac, SW_CMD_RAND, NULL, 0, &largenum, 1);\\r\\nif (swrc != SW_OK)\\r\\n{\\r\\nchar tmpbuf[20];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_RAND_BYTES, CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", swrc);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \", tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nbuf += sizeof(buf32);\\r\\nnum -= sizeof(buf32);\\r\\n}\\r\\nif(num)\\r\\n{\\r\\nlargenum.nbytes = sizeof(buf32);\\r\\nlargenum.value = buf32;\\r\\nswrc = p_CSwift_SimpleRequest(hac, SW_CMD_RAND, NULL, 0, &largenum, 1);\\r\\nif (swrc != SW_OK)\\r\\n{\\r\\nchar tmpbuf[20];\\r\\nCSWIFTerr(CSWIFT_F_CSWIFT_CTRL, CSWIFT_R_REQUEST_FAILED);\\r\\nsprintf(tmpbuf, \"%ld\", swrc);\\r\\nERR_add_error_data(2, \"CryptoSwift error number is \", tmpbuf);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(buf, largenum.value, num);\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nif (acquired)\\r\\nrelease_context(hac);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int cswift_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif(id && (strcmp(id, engine_cswift_id) != 0))\\r\\nreturn 0;\\r\\nif(!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_clnt_c", "target": 0, "func": "static SSL_METHOD *dtls1_get_client_method(int ver)\\r\\n{\\r\\nif (ver == DTLS1_VERSION)\\r\\nreturn(DTLSv1_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *DTLSv1_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD DTLSv1_client_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&DTLSv1_client_data,(char *)dtlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nDTLSv1_client_data.ssl_connect=dtls1_connect;\\r\\nDTLSv1_client_data.get_ssl_method=dtls1_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&DTLSv1_client_data);\\r\\n}\\r\\nint dtls1_connect(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf=NULL;\\r\\nunsigned long Time=time(NULL),l;\\r\\nlong num1;\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ns->state=SSL_ST_CONNECT;\\r\\ns->ctx->stats.sess_connect_renegotiate++;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version & 0xff00 ) != (DTLS1_VERSION & 0xff00))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_CONNECT, ERR_R_INTERNAL_ERROR);\\r\\nret = -1;\\r\\ngoto end;\\r\\n}\\r\\ns->type=SSL_ST_CONNECT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\nbuf=NULL;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\\r\\nif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A:\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=dtls1_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif ( s->d1->send_cookie)\\r\\n{\\r\\ns->state=SSL3_ST_CW_FLUSH;\\r\\ns->s3->tmp.next_state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\n}\\r\\nelse\\r\\ns->state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nif (s->bbio != s->wbio)\\r\\ns->wbio=BIO_push(s->bbio,s->wbio);\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A:\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B:\\r\\nret=ssl3_get_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nelse\\r\\n{\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CR_FINISHED_A;\\r\\nelse\\r\\ns->state=DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:\\r\\nret = dtls1_get_hello_verify(s);\\r\\nif ( ret <= 0)\\r\\ngoto end;\\r\\nif ( s->d1->send_cookie)\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_A;\\r\\nelse\\r\\ns->state = SSL3_ST_CR_CERT_A;\\r\\ns->init_num = 0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_A:\\r\\ncase SSL3_ST_CR_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=ssl3_get_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_CR_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A:\\r\\ncase SSL3_ST_CR_KEY_EXCH_B:\\r\\nret=ssl3_get_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nif (!ssl3_check_cert_and_algorithm(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_A:\\r\\ncase SSL3_ST_CR_CERT_REQ_B:\\r\\nret=ssl3_get_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_SRVR_DONE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A:\\r\\ncase SSL3_ST_CR_SRVR_DONE_B:\\r\\nret=ssl3_get_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->s3->tmp.cert_req)\\r\\ns->state=SSL3_ST_CW_CERT_A;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_A:\\r\\ncase SSL3_ST_CW_CERT_B:\\r\\ncase SSL3_ST_CW_CERT_C:\\r\\ncase SSL3_ST_CW_CERT_D:\\r\\nret=dtls1_send_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A:\\r\\ncase SSL3_ST_CW_KEY_EXCH_B:\\r\\nret=dtls1_send_client_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (s->s3->tmp.cert_req == 1)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_VRFY_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->s3->change_cipher_spec=0;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A:\\r\\ncase SSL3_ST_CW_CERT_VRFY_B:\\r\\nret=dtls1_send_client_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->init_num=0;\\r\\ns->s3->change_cipher_spec=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\nret=dtls1_send_change_cipher_spec(s,\\r\\nSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FINISHED_A;\\r\\ns->init_num=0;\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ns->session->compress_meth=0;\\r\\nelse\\r\\ns->session->compress_meth=\\r\\ns->s3->tmp.new_compression->id;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_CLIENT_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ndtls1_reset_seq_numbers(s, SSL3_CC_WRITE);\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\nret=dtls1_send_finished(s,\\r\\nSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\\r\\ns->method->ssl3_enc->client_finished_label,\\r\\ns->method->ssl3_enc->client_finished_label_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FLUSH;\\r\\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\\r\\nif (s->hit)\\r\\n{\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\nif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\\r\\n{\\r\\ns->state=SSL_ST_OK;\\r\\ns->s3->flags|=SSL3_FLAGS_POP_BUFFER;\\r\\ns->s3->delay_buf_pop_ret=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\\r\\nSSL3_ST_CR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\n#if 0\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\n#endif\\r\\nif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_num=0;\\r\\ns->new_session=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\\r\\nif (s->hit) s->ctx->stats.sess_hit++;\\r\\nret=1;\\r\\ns->handshake_func=dtls1_connect;\\r\\ns->ctx->stats.sess_connect_good++;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ns->d1->handshake_read_seq = 0;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_DTLS1_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint dtls1_client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,j;\\r\\nunsigned long Time,l;\\r\\nSSL_COMP *comp;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL3_ST_CW_CLNT_HELLO_A)\\r\\n{\\r\\nif ((s->session == NULL) ||\\r\\n(s->session->ssl_version != s->version) ||\\r\\n(s->session->not_resumable))\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\ngoto err;\\r\\n}\\r\\np=s->s3->client_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nRAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));\\r\\nd=p= &(buf[DTLS1_HM_HEADER_LENGTH]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\ns->client_version=s->version;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (s->new_session)\\r\\ni=0;\\r\\nelse\\r\\ni=s->session->session_id_length;\\r\\n*(p++)=i;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i > sizeof s->session->session_id)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(p,s->session->session_id,i);\\r\\np+=i;\\r\\n}\\r\\nif ( s->d1->cookie_len > sizeof(s->d1->cookie))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*(p++) = s->d1->cookie_len;\\r\\nmemcpy(p, s->d1->cookie, s->d1->cookie_len);\\r\\np += s->d1->cookie_len;\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]),0);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\np+=i;\\r\\nif (s->ctx->comp_methods == NULL)\\r\\nj=0;\\r\\nelse\\r\\nj=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\n*(p++)=1+j;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,i);\\r\\n*(p++)=comp->id;\\r\\n}\\r\\n*(p++)=0;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\nd = dtls1_set_message_header(s, d, SSL3_MT_CLIENT_HELLO, l, 0, l);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int dtls1_get_hello_verify(SSL *s)\\r\\n{\\r\\nint n, al, ok = 0;\\r\\nunsigned char *data;\\r\\nunsigned int cookie_len;\\r\\nn=s->method->ssl_get_message(s,\\r\\nDTLS1_ST_CR_HELLO_VERIFY_REQUEST_A,\\r\\nDTLS1_ST_CR_HELLO_VERIFY_REQUEST_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type != DTLS1_MT_HELLO_VERIFY_REQUEST)\\r\\n{\\r\\ns->d1->send_cookie = 0;\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\ndata = (unsigned char *)s->init_msg;\\r\\nif ((data[0] != (s->version>>8)) || (data[1] != (s->version&0xff)))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_GET_HELLO_VERIFY,SSL_R_WRONG_SSL_VERSION);\\r\\ns->version=(s->version&0xff00)|data[1];\\r\\nal = SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\ndata+=2;\\r\\ncookie_len = *(data++);\\r\\nif ( cookie_len > sizeof(s->d1->cookie))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\ngoto f_err;\\r\\n}\\r\\nmemcpy(s->d1->cookie, data, cookie_len);\\r\\ns->d1->cookie_len = cookie_len;\\r\\ns->d1->send_cookie = 1;\\r\\nreturn 1;\\r\\nf_err:\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn -1;\\r\\n}\\r\\nint dtls1_send_client_key_exchange(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint n;\\r\\nunsigned long l;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned char *q;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_ERR kssl_err;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_KEY_EXCH_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[DTLS1_HM_HEADER_LENGTH]);\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (0) {}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (l & SSL_kRSA)\\r\\n{\\r\\nRSA *rsa;\\r\\nunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nif (s->session->sess_cert->peer_rsa_tmp != NULL)\\r\\nrsa=s->session->sess_cert->peer_rsa_tmp;\\r\\nelse\\r\\n{\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nif ((pkey == NULL) ||\\r\\n(pkey->type != EVP_PKEY_RSA) ||\\r\\n(pkey->pkey.rsa == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nrsa=pkey->pkey.rsa;\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\ntmp_buf[0]=s->client_version>>8;\\r\\ntmp_buf[1]=s->client_version&0xff;\\r\\nif (RAND_bytes(&(tmp_buf[2]),sizeof tmp_buf-2) <= 0)\\r\\ngoto err;\\r\\ns->session->master_key_length=sizeof tmp_buf;\\r\\nq=p;\\r\\nif (s->version > SSL3_VERSION)\\r\\np+=2;\\r\\nn=RSA_public_encrypt(sizeof tmp_buf,\\r\\ntmp_buf,p,rsa,RSA_PKCS1_PADDING);\\r\\n#ifdef PKCS1_CHECK\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\\r\\n#endif\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\\r\\ngoto err;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\ns2n(n,q);\\r\\nn+=2;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\ntmp_buf,sizeof tmp_buf);\\r\\nOPENSSL_cleanse(tmp_buf,sizeof tmp_buf);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nelse if (l & SSL_kKRB5)\\r\\n{\\r\\nkrb5_error_code krb5rc;\\r\\nKSSL_CTX *kssl_ctx = s->kssl_ctx;\\r\\nkrb5_data *enc_ticket;\\r\\nkrb5_data authenticator, *authp = NULL;\\r\\nEVP_CIPHER_CTX ciph_ctx;\\r\\nEVP_CIPHER *enc = NULL;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nunsigned char epms[SSL_MAX_MASTER_KEY_LENGTH\\r\\n+ EVP_MAX_IV_LENGTH];\\r\\nint padl, outl = sizeof(epms);\\r\\nEVP_CIPHER_CTX_init(&ciph_ctx);\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"ssl3_send_client_key_exchange(%lx & %lx)\\n\",\\r\\nl, SSL_kKRB5);\\r\\n#endif\\r\\nauthp = NULL;\\r\\n#ifdef KRB5SENDAUTH\\r\\nif (KRB5SENDAUTH) authp = &authenticator;\\r\\n#endif\\r\\nkrb5rc = kssl_cget_tkt(kssl_ctx, &enc_ticket, authp,\\r\\n&kssl_err);\\r\\nenc = kssl_map_enc(kssl_ctx->enctype);\\r\\nif (enc == NULL)\\r\\ngoto err;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nprintf(\"kssl_cget_tkt rtn %d\\n\", krb5rc);\\r\\nif (krb5rc && kssl_err.text)\\r\\nprintf(\"kssl_cget_tkt kssl_err=%s\\n\", kssl_err.text);\\r\\n}\\r\\n#endif\\r\\nif (krb5rc)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,\\r\\nSSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,\\r\\nkssl_err.reason);\\r\\ngoto err;\\r\\n}\\r\\ns2n(enc_ticket->length,p);\\r\\nmemcpy(p, enc_ticket->data, enc_ticket->length);\\r\\np+= enc_ticket->length;\\r\\nn = enc_ticket->length + 2;\\r\\nif (authp && authp->length)\\r\\n{\\r\\ns2n(authp->length,p);\\r\\nmemcpy(p, authp->data, authp->length);\\r\\np+= authp->length;\\r\\nn+= authp->length + 2;\\r\\nfree(authp->data);\\r\\nauthp->data = NULL;\\r\\nauthp->length = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns2n(0,p);\\r\\nn+=2;\\r\\n}\\r\\nif (RAND_bytes(tmp_buf,sizeof tmp_buf) <= 0)\\r\\ngoto err;\\r\\nmemset(iv, 0, sizeof iv);\\r\\nEVP_EncryptInit_ex(&ciph_ctx,enc, NULL,\\r\\nkssl_ctx->key,iv);\\r\\nEVP_EncryptUpdate(&ciph_ctx,epms,&outl,tmp_buf,\\r\\nsizeof tmp_buf);\\r\\nEVP_EncryptFinal_ex(&ciph_ctx,&(epms[outl]),&padl);\\r\\noutl += padl;\\r\\nif (outl > sizeof epms)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&ciph_ctx);\\r\\ns2n(outl,p);\\r\\nmemcpy(p, epms, outl);\\r\\np+=outl;\\r\\nn+=outl + 2;\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\ntmp_buf, sizeof tmp_buf);\\r\\nOPENSSL_cleanse(tmp_buf, sizeof tmp_buf);\\r\\nOPENSSL_cleanse(epms, outl);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nelse if (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nDH *dh_srvr,*dh_clnt;\\r\\nif (s->session->sess_cert->peer_dh_tmp != NULL)\\r\\ndh_srvr=s->session->sess_cert->peer_dh_tmp;\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!DH_generate_key(dh_clnt))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,p,n);\\r\\nmemset(p,0,n);\\r\\nn=BN_num_bytes(dh_clnt->pub_key);\\r\\ns2n(n,p);\\r\\nBN_bn2bin(dh_clnt->pub_key,p);\\r\\nn+=2;\\r\\nDH_free(dh_clnt);\\r\\n}\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nd = dtls1_set_message_header(s, d,\\r\\nSSL3_MT_CLIENT_KEY_EXCHANGE, n, 0, n);\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_B;\\r\\ns->init_num=n+DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint dtls1_send_client_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nEVP_PKEY *pkey;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned u=0;\\r\\n#endif\\r\\nunsigned long n;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nint j;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_CERT_VRFY_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[DTLS1_HM_HEADER_LENGTH]);\\r\\npkey=s->cert->key->privatekey;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),\\r\\n&(data[MD5_DIGEST_LENGTH]));\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),&(data[0]));\\r\\nif (RSA_sign(NID_md5_sha1, data,\\r\\nMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\\r\\n&(p[2]), &u, pkey->pkey.rsa) <= 0 )\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(u,p);\\r\\nn=u+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nif (!DSA_sign(pkey->save_type,\\r\\n&(data[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,&(p[2]),\\r\\n(unsigned int *)&j,pkey->pkey.dsa))\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(j,p);\\r\\nn=j+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nd = dtls1_set_message_header(s, d,\\r\\nSSL3_MT_CERTIFICATE_VERIFY, n, 0, n) ;\\r\\ns->init_num=(int)n+DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\ns->state = SSL3_ST_CW_CERT_VRFY_B;\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint dtls1_send_client_certificate(SSL *s)\\r\\n{\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == SSL3_ST_CW_CERT_A)\\r\\n{\\r\\nif ((s->cert == NULL) ||\\r\\n(s->cert->key->x509 == NULL) ||\\r\\n(s->cert->key->privatekey == NULL))\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_B)\\r\\n{\\r\\ni=0;\\r\\nif (s->ctx->client_cert_cb != NULL)\\r\\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\\r\\nif (i < 0)\\r\\n{\\r\\ns->rwstate=SSL_X509_LOOKUP;\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nif ( !SSL_use_certificate(s,x509) ||\\r\\n!SSL_use_PrivateKey(s,pkey))\\r\\ni=0;\\r\\n}\\r\\nelse if (i == 1)\\r\\n{\\r\\ni=0;\\r\\nSSLerr(SSL_F_DTLS1_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\\r\\n}\\r\\nif (x509 != NULL) X509_free(x509);\\r\\nif (pkey != NULL) EVP_PKEY_free(pkey);\\r\\nif (i == 0)\\r\\n{\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\ns->s3->tmp.cert_req=0;\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_req=2;\\r\\n}\\r\\n}\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_C)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_D;\\r\\nl=dtls1_output_cert_chain(s,\\r\\n(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nreturn(dtls1_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dso_lib_c", "target": 0, "func": "DSO *DSO_new(void)\\r\\n{\\r\\nreturn(DSO_new_method(NULL));\\r\\n}\\r\\nvoid DSO_set_default_method(DSO_METHOD *meth)\\r\\n{\\r\\ndefault_DSO_meth = meth;\\r\\n}\\r\\nDSO_METHOD *DSO_get_default_method(void)\\r\\n{\\r\\nreturn(default_DSO_meth);\\r\\n}\\r\\nDSO_METHOD *DSO_get_method(DSO *dso)\\r\\n{\\r\\nreturn(dso->meth);\\r\\n}\\r\\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth)\\r\\n{\\r\\nDSO_METHOD *mtmp;\\r\\nmtmp = dso->meth;\\r\\ndso->meth = meth;\\r\\nreturn(mtmp);\\r\\n}\\r\\nDSO *DSO_new_method(DSO_METHOD *meth)\\r\\n{\\r\\nDSO *ret;\\r\\nif(default_DSO_meth == NULL)\\r\\ndefault_DSO_meth = DSO_METHOD_openssl();\\r\\nret = (DSO *)OPENSSL_malloc(sizeof(DSO));\\r\\nif(ret == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(DSO));\\r\\nret->meth_data = sk_new_null();\\r\\nif(ret->meth_data == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(meth == NULL)\\r\\nret->meth = default_DSO_meth;\\r\\nelse\\r\\nret->meth = meth;\\r\\nret->references = 1;\\r\\nif((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint DSO_free(DSO *dso)\\r\\n{\\r\\nint i;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_FREE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\ni=CRYPTO_add(&dso->references,-1,CRYPTO_LOCK_DSO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSO\",dso);\\r\\n#endif\\r\\nif(i > 0) return(1);\\r\\n#ifdef REF_CHECK\\r\\nif(i < 0)\\r\\n{\\r\\nfprintf(stderr,\"DSO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif((dso->meth->dso_unload != NULL) && !dso->meth->dso_unload(dso))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_FREE,DSO_R_UNLOAD_FAILED);\\r\\nreturn(0);\\r\\n}\\r\\nif((dso->meth->finish != NULL) && !dso->meth->finish(dso))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_FREE,DSO_R_FINISH_FAILED);\\r\\nreturn(0);\\r\\n}\\r\\nsk_free(dso->meth_data);\\r\\nif(dso->filename != NULL)\\r\\nOPENSSL_free(dso->filename);\\r\\nif(dso->loaded_filename != NULL)\\r\\nOPENSSL_free(dso->loaded_filename);\\r\\nOPENSSL_free(dso);\\r\\nreturn(1);\\r\\n}\\r\\nint DSO_flags(DSO *dso)\\r\\n{\\r\\nreturn((dso == NULL) ? 0 : dso->flags);\\r\\n}\\r\\nint DSO_up_ref(DSO *dso)\\r\\n{\\r\\nif (dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_UP_REF,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_add(&dso->references,1,CRYPTO_LOCK_DSO);\\r\\nreturn(1);\\r\\n}\\r\\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)\\r\\n{\\r\\nDSO *ret;\\r\\nint allocated = 0;\\r\\nif(dso == NULL)\\r\\n{\\r\\nret = DSO_new_method(meth);\\r\\nif(ret == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nallocated = 1;\\r\\nif(DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) < 0)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_CTRL_FAILED);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret = dso;\\r\\nif(ret->filename != NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_DSO_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif(filename != NULL)\\r\\nif(!DSO_set_filename(ret, filename))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_SET_FILENAME_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nfilename = ret->filename;\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nif(ret->meth->dso_load == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_UNSUPPORTED);\\r\\ngoto err;\\r\\n}\\r\\nif(!ret->meth->dso_load(ret))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_LOAD,DSO_R_LOAD_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif(allocated)\\r\\nDSO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid *DSO_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(dso->meth->dso_bind_var == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_VAR,DSO_R_UNSUPPORTED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif((ret = dso->meth->dso_bind_var(dso, symname)) == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_VAR,DSO_R_SYM_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nDSO_FUNC_TYPE ret = NULL;\\r\\nif((dso == NULL) || (symname == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(dso->meth->dso_bind_func == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC,DSO_R_UNSUPPORTED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif((ret = dso->meth->dso_bind_func(dso, symname)) == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC,DSO_R_SYM_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)\\r\\n{\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_CTRL,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(-1);\\r\\n}\\r\\nswitch(cmd)\\r\\n{\\r\\ncase DSO_CTRL_GET_FLAGS:\\r\\nreturn dso->flags;\\r\\ncase DSO_CTRL_SET_FLAGS:\\r\\ndso->flags = (int)larg;\\r\\nreturn(0);\\r\\ncase DSO_CTRL_OR_FLAGS:\\r\\ndso->flags |= (int)larg;\\r\\nreturn(0);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif((dso->meth == NULL) || (dso->meth->dso_ctrl == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_CTRL,DSO_R_UNSUPPORTED);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(dso->meth->dso_ctrl(dso,cmd,larg,parg));\\r\\n}\\r\\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\\r\\nDSO_NAME_CONVERTER_FUNC *oldcb)\\r\\n{\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_SET_NAME_CONVERTER,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(oldcb)\\r\\n*oldcb = dso->name_converter;\\r\\ndso->name_converter = cb;\\r\\nreturn(1);\\r\\n}\\r\\nconst char *DSO_get_filename(DSO *dso)\\r\\n{\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_GET_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(dso->filename);\\r\\n}\\r\\nint DSO_set_filename(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *copied;\\r\\nif((dso == NULL) || (filename == NULL))\\r\\n{\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif(dso->loaded_filename)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME,DSO_R_DSO_ALREADY_LOADED);\\r\\nreturn(0);\\r\\n}\\r\\ncopied = OPENSSL_malloc(strlen(filename) + 1);\\r\\nif(copied == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nBUF_strlcpy(copied, filename, strlen(filename) + 1);\\r\\nif(dso->filename)\\r\\nOPENSSL_free(dso->filename);\\r\\ndso->filename = copied;\\r\\nreturn(1);\\r\\n}\\r\\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nchar *result = NULL;\\r\\nif(dso == NULL || filespec1 == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_MERGE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(filespec1 == NULL)\\r\\nfilespec1 = dso->filename;\\r\\nif(filespec1 == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_MERGE,DSO_R_NO_FILE_SPECIFICATION);\\r\\nreturn(NULL);\\r\\n}\\r\\nif((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0)\\r\\n{\\r\\nif(dso->merger != NULL)\\r\\nresult = dso->merger(dso, filespec1, filespec2);\\r\\nelse if(dso->meth->dso_merger != NULL)\\r\\nresult = dso->meth->dso_merger(dso,\\r\\nfilespec1, filespec2);\\r\\n}\\r\\nreturn(result);\\r\\n}\\r\\nchar *DSO_convert_filename(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *result = NULL;\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nif(filename == NULL)\\r\\nfilename = dso->filename;\\r\\nif(filename == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME);\\r\\nreturn(NULL);\\r\\n}\\r\\nif((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0)\\r\\n{\\r\\nif(dso->name_converter != NULL)\\r\\nresult = dso->name_converter(dso, filename);\\r\\nelse if(dso->meth->dso_name_converter != NULL)\\r\\nresult = dso->meth->dso_name_converter(dso, filename);\\r\\n}\\r\\nif(result == NULL)\\r\\n{\\r\\nresult = OPENSSL_malloc(strlen(filename) + 1);\\r\\nif(result == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nBUF_strlcpy(result, filename, strlen(filename) + 1);\\r\\n}\\r\\nreturn(result);\\r\\n}\\r\\nconst char *DSO_get_loaded_filename(DSO *dso)\\r\\n{\\r\\nif(dso == NULL)\\r\\n{\\r\\nDSOerr(DSO_F_DSO_GET_LOADED_FILENAME,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(dso->loaded_filename);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rmd_one_c", "target": 0, "func": "unsigned char *RIPEMD160(const unsigned char *d, size_t n,\\r\\nunsigned char *md)\\r\\n{\\r\\nRIPEMD160_CTX c;\\r\\nstatic unsigned char m[RIPEMD160_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nif (!RIPEMD160_Init(&c))\\r\\nreturn NULL;\\r\\nRIPEMD160_Update(&c,d,n);\\r\\nRIPEMD160_Final(md,&c);\\r\\nOPENSSL_cleanse(&c,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bio_enc_c", "target": 0, "func": "BIO_METHOD *BIO_f_cipher(void)\\r\\n{\\r\\nreturn(&methods_enc);\\r\\n}\\r\\nstatic int enc_new(BIO *bi)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)OPENSSL_malloc(sizeof(BIO_ENC_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nEVP_CIPHER_CTX_init(&ctx->cipher);\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->ok=1;\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int enc_free(BIO *a)\\r\\n{\\r\\nBIO_ENC_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_ENC_CTX *)a->ptr;\\r\\nEVP_CIPHER_CTX_cleanup(&(b->cipher));\\r\\nOPENSSL_cleanse(a->ptr,sizeof(BIO_ENC_CTX));\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int enc_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->buf_len > 0)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\n}\\r\\nwhile (outl > 0)\\r\\n{\\r\\nif (ctx->cont <= 0) break;\\r\\ni=BIO_read(b->next_bio,&(ctx->buf[BUF_OFFSET]),ENC_BLOCK_SIZE);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(b->next_bio))\\r\\n{\\r\\nctx->cont=i;\\r\\ni=EVP_CipherFinal_ex(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=i;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=(ret == 0)?i:ret;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)&(ctx->buf[BUF_OFFSET]),i);\\r\\nctx->cont=1;\\r\\nif(ctx->buf_len == 0) continue;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni=ctx->buf_len;\\r\\nelse\\r\\ni=outl;\\r\\nif (i <= 0) break;\\r\\nmemcpy(out,ctx->buf,i);\\r\\nret+=i;\\r\\nctx->buf_off=i;\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?ctx->cont:ret);\\r\\n}\\r\\nstatic int enc_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nret=inl;\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx->buf_off=0;\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret == inl) ? i : ret - inl;\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_ENC_CTX *ctx,*dctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nEVP_CIPHER_CTX **c_ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ok=1;\\r\\nctx->finished=0;\\r\\nEVP_CipherInit_ex(&(ctx->cipher),NULL,NULL,NULL,NULL,\\r\\nctx->cipher.encrypt);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=enc_write(b,NULL,0);\\r\\nif (i < 0)\\r\\nreturn i;\\r\\n}\\r\\nif (!ctx->finished)\\r\\n{\\r\\nctx->finished=1;\\r\\nctx->buf_off=0;\\r\\nret=EVP_CipherFinal_ex(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=(int)ret;\\r\\nif (ret <= 0) break;\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_STATUS:\\r\\nret=(long)ctx->ok;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_CTX:\\r\\nc_ctx=(EVP_CIPHER_CTX **)ptr;\\r\\n(*c_ctx)= &(ctx->cipher);\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\ndctx=(BIO_ENC_CTX *)dbio->ptr;\\r\\nmemcpy(&(dctx->cipher),&(ctx->cipher),sizeof(ctx->cipher));\\r\\ndbio->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long enc_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret=1;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ndefault:\\r\\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,\\r\\nconst unsigned char *i, int e)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (b == NULL) return;\\r\\nif ((b->callback != NULL) &&\\r\\n(b->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,0L) <= 0))\\r\\nreturn;\\r\\nb->init=1;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nEVP_CipherInit_ex(&(ctx->cipher),c,NULL, k,i,e);\\r\\nif (b->callback != NULL)\\r\\nb->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,1L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecs_ossl_c", "target": 0, "func": "const ECDSA_METHOD *ECDSA_OpenSSL(void)\\r\\n{\\r\\nreturn &openssl_ecdsa_meth;\\r\\n}\\r\\nstatic int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,\\r\\nBIGNUM **rp)\\r\\n{\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *k = NULL, *r = NULL, *order = NULL, *X = NULL;\\r\\nEC_POINT *tmp_point=NULL;\\r\\nconst EC_GROUP *group;\\r\\nint ret = 0;\\r\\nif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx_in == NULL)\\r\\n{\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse\\r\\nctx = ctx_in;\\r\\nk = BN_new();\\r\\nr = BN_new();\\r\\norder = BN_new();\\r\\nX = BN_new();\\r\\nif (!k || !r || !order || !X)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((tmp_point = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\ndo\\r\\n{\\r\\ndo\\r\\nif (!BN_rand_range(k, order))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,\\r\\nECDSA_R_RANDOM_NUMBER_GENERATION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nwhile (BN_is_zero(k));\\r\\nif (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group,\\r\\ntmp_point, X, NULL, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group,\\r\\ntmp_point, X, NULL, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP,ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_nnmod(r, X, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nwhile (BN_is_zero(r));\\r\\nif (!BN_mod_inverse(k, k, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (*rp != NULL)\\r\\nBN_clear_free(*rp);\\r\\nif (*kinvp != NULL)\\r\\nBN_clear_free(*kinvp);\\r\\n*rp = r;\\r\\n*kinvp = k;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nif (k != NULL) BN_clear_free(k);\\r\\nif (r != NULL) BN_clear_free(r);\\r\\n}\\r\\nif (ctx_in == NULL)\\r\\nBN_CTX_free(ctx);\\r\\nif (order != NULL)\\r\\nBN_free(order);\\r\\nif (tmp_point != NULL)\\r\\nEC_POINT_free(tmp_point);\\r\\nif (X)\\r\\nBN_clear_free(X);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic ECDSA_SIG *ecdsa_do_sign(const unsigned char *dgst, int dgst_len,\\r\\nconst BIGNUM *in_kinv, const BIGNUM *in_r, EC_KEY *eckey)\\r\\n{\\r\\nint ok = 0;\\r\\nBIGNUM *kinv=NULL, *s, *m=NULL,*tmp=NULL,*order=NULL;\\r\\nconst BIGNUM *ckinv;\\r\\nBN_CTX *ctx = NULL;\\r\\nconst EC_GROUP *group;\\r\\nECDSA_SIG *ret;\\r\\nECDSA_DATA *ecdsa;\\r\\nconst BIGNUM *priv_key;\\r\\necdsa = ecdsa_check(eckey);\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\npriv_key = EC_KEY_get0_private_key(eckey);\\r\\nif (group == NULL || priv_key == NULL || ecdsa == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nret = ECDSA_SIG_new();\\r\\nif (!ret)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\ns = ret->s;\\r\\nif ((ctx = BN_CTX_new()) == NULL || (order = BN_new()) == NULL ||\\r\\n(tmp = BN_new()) == NULL || (m = BN_new()) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (dgst_len > BN_num_bytes(order))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN,\\r\\nECDSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_bin2bn(dgst, dgst_len, m))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\ndo\\r\\n{\\r\\nif (in_kinv == NULL || in_r == NULL)\\r\\n{\\r\\nif (!ECDSA_sign_setup(eckey, ctx, &kinv, &ret->r))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN,ERR_R_ECDSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\nckinv = kinv;\\r\\n}\\r\\nelse\\r\\n{\\r\\nckinv = in_kinv;\\r\\nif (BN_copy(ret->r, in_r) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_mul(tmp, priv_key, ret->r, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_add_quick(s, tmp, m, order))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(s, s, ckinv, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_SIGN, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nwhile (BN_is_zero(s));\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nECDSA_SIG_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (m)\\r\\nBN_clear_free(m);\\r\\nif (tmp)\\r\\nBN_clear_free(tmp);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (kinv)\\r\\nBN_clear_free(kinv);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ecdsa_do_verify(const unsigned char *dgst, int dgst_len,\\r\\nconst ECDSA_SIG *sig, EC_KEY *eckey)\\r\\n{\\r\\nint ret = -1;\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *order, *u1, *u2, *m, *X;\\r\\nEC_POINT *point = NULL;\\r\\nconst EC_GROUP *group;\\r\\nconst EC_POINT *pub_key;\\r\\nif (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||\\r\\n(pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ECDSA_R_MISSING_PARAMETERS);\\r\\nreturn -1;\\r\\n}\\r\\nctx = BN_CTX_new();\\r\\nif (!ctx)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nu1 = BN_CTX_get(ctx);\\r\\nu2 = BN_CTX_get(ctx);\\r\\nm = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nif (!X)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||\\r\\nBN_ucmp(sig->r, order) >= 0 || BN_is_zero(sig->s) ||\\r\\nBN_is_negative(sig->s) || BN_ucmp(sig->s, order) >= 0)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ECDSA_R_BAD_SIGNATURE);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_inverse(u2, sig->s, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_bin2bn(dgst, dgst_len, m))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(u1, m, u2, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(u2, sig->r, u2, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(group, point, u1, pub_key, u2, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) == NID_X9_62_prime_field)\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group,\\r\\npoint, X, NULL, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group,\\r\\npoint, X, NULL, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_nnmod(u1, X, order, ctx))\\r\\n{\\r\\nECDSAerr(ECDSA_F_ECDSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = (BN_ucmp(u1, sig->r) == 0);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_c_ofb64_c", "target": 0, "func": "void CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, CAST_KEY *schedule, unsigned char *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister CAST_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mkreq_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *bio_err;\\r\\nX509_REQ *req=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\nbio_err=BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nmkreq(&req,&pkey,512,0,365);\\r\\nRSA_print_fp(stdout,pkey->pkey.rsa,0);\\r\\nX509_REQ_print_fp(stdout,req);\\r\\nPEM_write_X509_REQ(stdout,req);\\r\\nX509_REQ_free(req);\\r\\nEVP_PKEY_free(pkey);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_cleanup();\\r\\n#endif\\r\\nCRYPTO_cleanup_all_ex_data();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nBIO_free(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void callback(int p, int n, void *arg)\\r\\n{\\r\\nchar c='B';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nfputc(c,stderr);\\r\\n}\\r\\nint mkreq(X509_REQ **req, EVP_PKEY **pkeyp, int bits, int serial, int days)\\r\\n{\\r\\nX509_REQ *x;\\r\\nEVP_PKEY *pk;\\r\\nRSA *rsa;\\r\\nX509_NAME *name=NULL;\\r\\nSTACK_OF(X509_EXTENSION) *exts = NULL;\\r\\nif ((pk=EVP_PKEY_new()) == NULL)\\r\\ngoto err;\\r\\nif ((x=X509_REQ_new()) == NULL)\\r\\ngoto err;\\r\\nrsa=RSA_generate_key(bits,RSA_F4,callback,NULL);\\r\\nif (!EVP_PKEY_assign_RSA(pk,rsa))\\r\\ngoto err;\\r\\nrsa=NULL;\\r\\nX509_REQ_set_pubkey(x,pk);\\r\\nname=X509_REQ_get_subject_name(x);\\r\\nX509_NAME_add_entry_by_txt(name,\"C\",\\r\\nMBSTRING_ASC, \"UK\", -1, -1, 0);\\r\\nX509_NAME_add_entry_by_txt(name,\"CN\",\\r\\nMBSTRING_ASC, \"OpenSSL Group\", -1, -1, 0);\\r\\n#ifdef REQUEST_EXTENSIONS\\r\\nexts = sk_X509_EXTENSION_new_null();\\r\\nadd_ext(exts, NID_key_usage, \"critical,digitalSignature,keyEncipherment\");\\r\\nadd_ext(exts, NID_subject_alt_name, \"email:steve@openssl.org\");\\r\\nadd_ext(exts, NID_netscape_cert_type, \"client,email\");\\r\\n#ifdef CUSTOM_EXT\\r\\n{\\r\\nint nid;\\r\\nnid = OBJ_create(\"1.2.3.4\", \"MyAlias\", \"My Test Alias Extension\");\\r\\nX509V3_EXT_add_alias(nid, NID_netscape_comment);\\r\\nadd_ext(x, nid, \"example comment alias\");\\r\\n}\\r\\n#endif\\r\\nX509_REQ_add_extensions(x, exts);\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\n#endif\\r\\nif (!X509_REQ_sign(x,pk,EVP_md5()))\\r\\ngoto err;\\r\\n*req=x;\\r\\n*pkeyp=pk;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nEC_GROUP *group = NULL;\\r\\npoint_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nint new_form = 0;\\r\\nint asn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nint new_asn1_flag = 0;\\r\\nchar *curve_name = NULL, *inrand = NULL;\\r\\nint list_curves = 0, no_seed = 0, check = 0,\\r\\nbadops = 0, text = 0, i, need_rand = 0, genkey = 0;\\r\\nchar *infile = NULL, *outfile = NULL, *prog;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, noout = 0, C = 0, ret = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n#endif\\r\\nchar *engine = NULL;\\r\\nBIGNUM *ec_p = NULL, *ec_a = NULL, *ec_b = NULL,\\r\\n*ec_gen = NULL, *ec_order = NULL, *ec_cofactor = NULL;\\r\\nunsigned char *buffer = NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC = 1;\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck = 1;\\r\\nelse if (strcmp (*argv, \"-name\") == 0)\\r\\n{\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncurve_name = *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv, \"-list_curves\") == 0)\\r\\nlist_curves = 1;\\r\\nelse if (strcmp(*argv, \"-conv_form\") == 0)\\r\\n{\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_form = 1;\\r\\nif (strcmp(*argv, \"compressed\") == 0)\\r\\nform = POINT_CONVERSION_COMPRESSED;\\r\\nelse if (strcmp(*argv, \"uncompressed\") == 0)\\r\\nform = POINT_CONVERSION_UNCOMPRESSED;\\r\\nelse if (strcmp(*argv, \"hybrid\") == 0)\\r\\nform = POINT_CONVERSION_HYBRID;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-param_enc\") == 0)\\r\\n{\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_asn1_flag = 1;\\r\\nif (strcmp(*argv, \"named_curve\") == 0)\\r\\nasn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nelse if (strcmp(*argv, \"explicit\") == 0)\\r\\nasn1_flag = 0;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-no_seed\") == 0)\\r\\nno_seed = 1;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-genkey\") == 0)\\r\\n{\\r\\ngenkey=1;\\r\\nneed_rand=1;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\nneed_rand=1;\\r\\n}\\r\\nelse if(strcmp(*argv, \"-engine\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - \"\\r\\n\"default PEM (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - \"\\r\\n\"default PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file - \"\\r\\n\"default stdin\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file - \"\\r\\n\"default stdout\\n\");\\r\\nBIO_printf(bio_err, \" -noout do not print the \"\\r\\n\"ec parameter\\n\");\\r\\nBIO_printf(bio_err, \" -text print the ec \"\\r\\n\"parameters in text form\\n\");\\r\\nBIO_printf(bio_err, \" -check validate the ec \"\\r\\n\"parameters\\n\");\\r\\nBIO_printf(bio_err, \" -C print a 'C' \"\\r\\n\"function creating the parameters\\n\");\\r\\nBIO_printf(bio_err, \" -name arg use the \"\\r\\n\"ec parameters with 'short name' name\\n\");\\r\\nBIO_printf(bio_err, \" -list_curves prints a list of \"\\r\\n\"all currently available curve 'short names'\\n\");\\r\\nBIO_printf(bio_err, \" -conv_form arg specifies the \"\\r\\n\"point conversion form \\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" compressed\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" uncompressed (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" hybrid\\n\");\\r\\nBIO_printf(bio_err, \" -param_enc arg specifies the way\"\\r\\n\" the ec parameters are encoded\\n\");\\r\\nBIO_printf(bio_err, \" in the asn1 der \"\\r\\n\"encoding\\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" named_curve (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" explicit\\n\");\\r\\nBIO_printf(bio_err, \" -no_seed if 'explicit'\"\\r\\n\" parameters are choosen do not\"\\r\\n\" use the seed\\n\");\\r\\nBIO_printf(bio_err, \" -genkey generate ec\"\\r\\n\" key\\n\");\\r\\nBIO_printf(bio_err, \" -rand file files to use for\"\\r\\n\" random number input\\n\");\\r\\nBIO_printf(bio_err, \" -engine e use engine e, \"\\r\\n\"possibly a hardware device\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (list_curves)\\r\\n{\\r\\nEC_builtin_curve *curves = NULL;\\r\\nsize_t crv_len = 0;\\r\\nsize_t n = 0;\\r\\ncrv_len = EC_get_builtin_curves(NULL, 0);\\r\\ncurves = OPENSSL_malloc((int)(sizeof(EC_builtin_curve) * crv_len));\\r\\nif (curves == NULL)\\r\\ngoto end;\\r\\nif (!EC_get_builtin_curves(curves, crv_len))\\r\\n{\\r\\nOPENSSL_free(curves);\\r\\ngoto end;\\r\\n}\\r\\nfor (n = 0; n < crv_len; n++)\\r\\n{\\r\\nconst char *comment;\\r\\nconst char *sname;\\r\\ncomment = curves[n].comment;\\r\\nsname = OBJ_nid2sn(curves[n].nid);\\r\\nif (comment == NULL)\\r\\ncomment = \"CURVE DESCRIPTION NOT AVAILABLE\";\\r\\nif (sname == NULL)\\r\\nsname = \"\";\\r\\nBIO_printf(out, \" %-10s: \", sname);\\r\\nBIO_printf(out, \"%s\\n\", comment);\\r\\n}\\r\\nOPENSSL_free(curves);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (curve_name != NULL)\\r\\n{\\r\\nint nid;\\r\\nif (!strcmp(curve_name, \"secp192r1\"))\\r\\n{\\r\\nBIO_printf(bio_err, \"using curve name prime192v1 \"\\r\\n\"instead of secp192r1\\n\");\\r\\nnid = NID_X9_62_prime192v1;\\r\\n}\\r\\nelse if (!strcmp(curve_name, \"secp256r1\"))\\r\\n{\\r\\nBIO_printf(bio_err, \"using curve name prime256v1 \"\\r\\n\"instead of secp256r1\\n\");\\r\\nnid = NID_X9_62_prime256v1;\\r\\n}\\r\\nelse\\r\\nnid = OBJ_sn2nid(curve_name);\\r\\nif (nid == 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"unknown curve name (%s)\\n\",\\r\\ncurve_name);\\r\\ngoto end;\\r\\n}\\r\\ngroup = EC_GROUP_new_by_curve_name(nid);\\r\\nif (group == NULL)\\r\\n{\\r\\nBIO_printf(bio_err, \"unable to create curve (%s)\\n\",\\r\\ncurve_name);\\r\\ngoto end;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(group, asn1_flag);\\r\\nEC_GROUP_set_point_conversion_form(group, form);\\r\\n}\\r\\nelse if (informat == FORMAT_ASN1)\\r\\n{\\r\\ngroup = d2i_ECPKParameters_bio(in, NULL);\\r\\n}\\r\\nelse if (informat == FORMAT_PEM)\\r\\n{\\r\\ngroup = PEM_read_bio_ECPKParameters(in,NULL,NULL,NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (group == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"unable to load elliptic curve parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (new_form)\\r\\nEC_GROUP_set_point_conversion_form(group, form);\\r\\nif (new_asn1_flag)\\r\\nEC_GROUP_set_asn1_flag(group, asn1_flag);\\r\\nif (no_seed)\\r\\n{\\r\\nEC_GROUP_set_seed(group, NULL, 0);\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nif (!ECPKParameters_print(out, group, 0))\\r\\ngoto end;\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nif (group == NULL)\\r\\nBIO_printf(bio_err, \"no elliptic curve parameters\\n\");\\r\\nBIO_printf(bio_err, \"checking elliptic curve parameters: \");\\r\\nif (!EC_GROUP_check(group, NULL))\\r\\n{\\r\\nBIO_printf(bio_err, \"failed\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio_err, \"ok\\n\");\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nsize_t buf_len = 0, tmp_len = 0;\\r\\nconst EC_POINT *point;\\r\\nint is_prime, len = 0;\\r\\nconst EC_METHOD *meth = EC_GROUP_method_of(group);\\r\\nif ((ec_p = BN_new()) == NULL || (ec_a = BN_new()) == NULL ||\\r\\n(ec_b = BN_new()) == NULL || (ec_gen = BN_new()) == NULL ||\\r\\n(ec_order = BN_new()) == NULL ||\\r\\n(ec_cofactor = BN_new()) == NULL )\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nis_prime = (EC_METHOD_get_field_type(meth) ==\\r\\nNID_X9_62_prime_field);\\r\\nif (is_prime)\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GFp(group, ec_p, ec_a,\\r\\nec_b, NULL))\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(group)) == NULL)\\r\\ngoto end;\\r\\nif (!EC_POINT_point2bn(group, point,\\r\\nEC_GROUP_get_point_conversion_form(group), ec_gen,\\r\\nNULL))\\r\\ngoto end;\\r\\nif (!EC_GROUP_get_order(group, ec_order, NULL))\\r\\ngoto end;\\r\\nif (!EC_GROUP_get_cofactor(group, ec_cofactor, NULL))\\r\\ngoto end;\\r\\nif (!ec_p || !ec_a || !ec_b || !ec_gen ||\\r\\n!ec_order || !ec_cofactor)\\r\\ngoto end;\\r\\nlen = BN_num_bits(ec_order);\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_p)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_a)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_b)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_gen)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_order)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_cofactor)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nbuffer = (unsigned char *)OPENSSL_malloc(buf_len);\\r\\nif (buffer == NULL)\\r\\n{\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\necparam_print_var(out, ec_p, \"ec_p\", len, buffer);\\r\\necparam_print_var(out, ec_a, \"ec_a\", len, buffer);\\r\\necparam_print_var(out, ec_b, \"ec_b\", len, buffer);\\r\\necparam_print_var(out, ec_gen, \"ec_gen\", len, buffer);\\r\\necparam_print_var(out, ec_order, \"ec_order\", len, buffer);\\r\\necparam_print_var(out, ec_cofactor, \"ec_cofactor\", len,\\r\\nbuffer);\\r\\nBIO_printf(out, \"\\n\\n\");\\r\\nBIO_printf(out, \"EC_GROUP *get_ec_group_%d(void)\\n\\t{\\n\", len);\\r\\nBIO_printf(out, \"\\tint ok=0;\\n\");\\r\\nBIO_printf(out, \"\\tEC_GROUP *group = NULL;\\n\");\\r\\nBIO_printf(out, \"\\tEC_POINT *point = NULL;\\n\");\\r\\nBIO_printf(out, \"\\tBIGNUM *tmp_1 = NULL, *tmp_2 = NULL, \"\\r\\n\"*tmp_3 = NULL;\\n\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_1 = BN_bin2bn(ec_p_%d, \"\\r\\n\"sizeof(ec_p_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_2 = BN_bin2bn(ec_a_%d, \"\\r\\n\"sizeof(ec_a_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_3 = BN_bin2bn(ec_b_%d, \"\\r\\n\"sizeof(ec_b_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nif (is_prime)\\r\\n{\\r\\nBIO_printf(out, \"\\tif ((group = EC_GROUP_new_curve_\"\\r\\n\"GFp(tmp_1, tmp_2, tmp_3, NULL)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(out, \"\\t/* build generator */\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_1 = BN_bin2bn(ec_gen_%d, \"\\r\\n\"sizeof(ec_gen_%d), tmp_1)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tpoint = EC_POINT_bn2point(group, tmp_1, \"\\r\\n\"NULL, NULL);\\n\");\\r\\nBIO_printf(out, \"\\tif (point == NULL)\\n\\t\\tgoto err;\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_2 = BN_bin2bn(ec_order_%d, \"\\r\\n\"sizeof(ec_order_%d), tmp_2)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_3 = BN_bin2bn(ec_cofactor_%d, \"\\r\\n\"sizeof(ec_cofactor_%d), tmp_3)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif (!EC_GROUP_set_generator(group, point,\"\\r\\n\" tmp_2, tmp_3))\\n\\t\\tgoto err;\\n\");\\r\\nBIO_printf(out, \"\\n\\tok=1;\\n\");\\r\\nBIO_printf(out, \"err:\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_1)\\n\\t\\tBN_free(tmp_1);\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_2)\\n\\t\\tBN_free(tmp_2);\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_3)\\n\\t\\tBN_free(tmp_3);\\n\");\\r\\nBIO_printf(out, \"\\tif (point)\\n\\t\\tEC_POINT_free(point);\\n\");\\r\\nBIO_printf(out, \"\\tif (!ok)\\n\");\\r\\nBIO_printf(out, \"\\t\\t{\\n\");\\r\\nBIO_printf(out, \"\\t\\tEC_GROUP_free(group);\\n\");\\r\\nBIO_printf(out, \"\\t\\tgroup = NULL;\\n\");\\r\\nBIO_printf(out, \"\\t\\t}\\n\");\\r\\nBIO_printf(out, \"\\treturn(group);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_ECPKParameters_bio(out, group);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_ECPKParameters(out, group);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad output format specified for\"\\r\\n\" outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err, \"unable to write elliptic \"\\r\\n\"curve parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (need_rand)\\r\\n{\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nif (genkey)\\r\\n{\\r\\nEC_KEY *eckey = EC_KEY_new();\\r\\nif (eckey == NULL)\\r\\ngoto end;\\r\\nassert(need_rand);\\r\\nif (EC_KEY_set_group(eckey, group) == 0)\\r\\ngoto end;\\r\\nif (!EC_KEY_generate_key(eckey))\\r\\n{\\r\\nEC_KEY_free(eckey);\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_ECPrivateKey_bio(out, eckey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_ECPrivateKey(out, eckey, NULL,\\r\\nNULL, 0, NULL, NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err, \"bad output format specified \"\\r\\n\"for outfile\\n\");\\r\\nEC_KEY_free(eckey);\\r\\ngoto end;\\r\\n}\\r\\nEC_KEY_free(eckey);\\r\\n}\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret=0;\\r\\nend:\\r\\nif (ec_p)\\r\\nBN_free(ec_p);\\r\\nif (ec_a)\\r\\nBN_free(ec_a);\\r\\nif (ec_b)\\r\\nBN_free(ec_b);\\r\\nif (ec_gen)\\r\\nBN_free(ec_gen);\\r\\nif (ec_order)\\r\\nBN_free(ec_order);\\r\\nif (ec_cofactor)\\r\\nBN_free(ec_cofactor);\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (group != NULL)\\r\\nEC_GROUP_free(group);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int ecparam_print_var(BIO *out, BIGNUM *in, const char *var,\\r\\nint len, unsigned char *buffer)\\r\\n{\\r\\nBIO_printf(out, \"static unsigned char %s_%d[] = {\", var, len);\\r\\nif (BN_is_zero(in))\\r\\nBIO_printf(out, \"\\n\\t0x00\");\\r\\nelse\\r\\n{\\r\\nint i, l;\\r\\nl = BN_bn2bin(in, buffer);\\r\\nfor (i=0; i<l-1; i++)\\r\\n{\\r\\nif ((i%12) == 0)\\r\\nBIO_printf(out, \"\\n\\t\");\\r\\nBIO_printf(out, \"0x%02X,\", buffer[i]);\\r\\n}\\r\\nif ((i%12) == 0)\\r\\nBIO_printf(out, \"\\n\\t\");\\r\\nBIO_printf(out, \"0x%02X\", buffer[i]);\\r\\n}\\r\\nBIO_printf(out, \"\\n\\t};\\n\\n\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc4_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nFILE *in=NULL,*out=NULL;\\r\\nchar *infile=NULL,*outfile=NULL,*keystr=NULL;\\r\\nRC4_KEY key;\\r\\nchar buf[BUFSIZ];\\r\\nint badops=0,i;\\r\\nchar **pp;\\r\\nunsigned char md[MD5_DIGEST_LENGTH];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeystr= *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=usage; (*pp != NULL); pp++)\\r\\nfprintf(stderr,\"%s\",*pp);\\r\\nexit(1);\\r\\n}\\r\\nif (infile == NULL)\\r\\nin=stdin;\\r\\nelse\\r\\n{\\r\\nin=fopen(infile,\"r\");\\r\\nif (in == NULL)\\r\\n{\\r\\nperror(\"open\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\nout=stdout;\\r\\nelse\\r\\n{\\r\\nout=fopen(outfile,\"w\");\\r\\nif (out == NULL)\\r\\n{\\r\\nperror(\"open\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\n#ifdef OPENSSL_SYS_MSDOS\\r\\n{\\r\\n#include <fcntl.h>\\r\\nsetmode(fileno(in),O_BINARY);\\r\\nsetmode(fileno(out),O_BINARY);\\r\\n}\\r\\n#endif\\r\\nif (keystr == NULL)\\r\\n{\\r\\ni=EVP_read_pw_string(buf,BUFSIZ,\"Enter RC4 password:\",0);\\r\\nif (i != 0)\\r\\n{\\r\\nOPENSSL_cleanse(buf,BUFSIZ);\\r\\nfprintf(stderr,\"bad password read\\n\");\\r\\nexit(1);\\r\\n}\\r\\nkeystr=buf;\\r\\n}\\r\\nEVP_Digest((unsigned char *)keystr,strlen(keystr),md,NULL,EVP_md5(),NULL);\\r\\nOPENSSL_cleanse(keystr,strlen(keystr));\\r\\nRC4_set_key(&key,MD5_DIGEST_LENGTH,md);\\r\\nfor(;;)\\r\\n{\\r\\ni=fread(buf,1,BUFSIZ,in);\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\nRC4(&key,(unsigned int)i,(unsigned char *)buf,\\r\\n(unsigned char *)buf);\\r\\ni=fwrite(buf,(unsigned int)i,1,out);\\r\\nif (i != 1)\\r\\n{\\r\\nperror(\"write\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nfclose(out);\\r\\nfclose(in);\\r\\nexit(0);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_spkigen_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nRSA *rsa=NULL;\\r\\nNETSCAPE_SPKI *spki=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nchar buf[128];\\r\\nint ok=0,i;\\r\\nFILE *fp;\\r\\npkey=EVP_PKEY_new();\\r\\nif (argc < 2)\\r\\n{\\r\\nfprintf(stderr,\"generating RSA key, could take some time...\\n\");\\r\\nif ((rsa=RSA_generate_key(512,RSA_F4,NULL)) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((fp=fopen(argv[1],\"r\")) == NULL)\\r\\n{ perror(argv[1]); goto err; }\\r\\nif ((rsa=PEM_read_RSAPrivateKey(fp,NULL,NULL)) == NULL)\\r\\ngoto err;\\r\\nfclose(fp);\\r\\n}\\r\\nif (!EVP_PKEY_assign_RSA(pkey,rsa)) goto err;\\r\\nrsa=NULL;\\r\\nif ((spki=NETSCAPE_SPKI_new()) == NULL) goto err;\\r\\nif (!SPKI_set_pubkey(spki,pkey)) goto err;\\r\\nfprintf(stderr,\"please enter challenge string:\");\\r\\nfflush(stderr);\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,sizeof buf,stdin);\\r\\ni=strlen(buf);\\r\\nif (i > 0) buf[--i]='\\0';\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)spki->spkac->challenge,\\r\\nbuf,i)) goto err;\\r\\nif (!NETSCAPE_SPKI_sign(spki,pkey,EVP_md5())) goto err;\\r\\nPEM_write_SPKI(stdout,spki);\\r\\nif (argc < 2)\\r\\nPEM_write_RSAPrivateKey(stdout,pkey->pkey.rsa,NULL,NULL,0,NULL);\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nfprintf(stderr,\"something bad happened....\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nNETSCAPE_SPKI_free(spki);\\r\\nEVP_PKEY_free(pkey);\\r\\nexit(!ok);\\r\\n}\\r\\nint EVP_PKEY_assign(pkey,type,key)\\r\\nEVP_PKEY *pkey;\\r\\nint type;\\r\\nchar *key;\\r\\n{\\r\\nif (pkey == NULL) return(0);\\r\\nif (pkey->pkey.ptr != NULL)\\r\\n{\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nRSA_free(pkey->pkey.rsa);\\r\\n}\\r\\npkey->type=type;\\r\\npkey->pkey.ptr=key;\\r\\nreturn(1);\\r\\n}\\r\\nint SPKI_set_pubkey(x,pkey)\\r\\nNETSCAPE_SPKI *x;\\r\\nEVP_PKEY *pkey;\\r\\n{\\r\\nint ok=0;\\r\\nX509_PUBKEY *pk;\\r\\nX509_ALGOR *a;\\r\\nASN1_OBJECT *o;\\r\\nunsigned char *s,*p;\\r\\nint i;\\r\\nif (x == NULL) return(0);\\r\\nif ((pk=X509_PUBKEY_new()) == NULL) goto err;\\r\\na=pk->algor;\\r\\nif ((o=OBJ_nid2obj(pkey->type)) == NULL) goto err;\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=o;\\r\\nif ((a->parameter == NULL) || (a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter=ASN1_TYPE_new();\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\ni=i2d_PublicKey(pkey,NULL);\\r\\nif ((s=(unsigned char *)malloc(i+1)) == NULL) goto err;\\r\\np=s;\\r\\ni2d_PublicKey(pkey,&p);\\r\\nif (!ASN1_BIT_STRING_set(pk->public_key,s,i)) goto err;\\r\\nfree(s);\\r\\nX509_PUBKEY_free(x->spkac->pubkey);\\r\\nx->spkac->pubkey=pk;\\r\\npk=NULL;\\r\\nok=1;\\r\\nerr:\\r\\nif (pk != NULL) X509_PUBKEY_free(pk);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_nuron_err_c", "target": 0, "func": "static void ERR_load_NURON_strings(void)\\r\\n{\\r\\nif (NURON_lib_error_code == 0)\\r\\nNURON_lib_error_code=ERR_get_next_error_library();\\r\\nif (NURON_error_init)\\r\\n{\\r\\nNURON_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(NURON_lib_error_code,NURON_str_functs);\\r\\nERR_load_strings(NURON_lib_error_code,NURON_str_reasons);\\r\\n#endif\\r\\n#ifdef NURON_LIB_NAME\\r\\nNURON_lib_name->error = ERR_PACK(NURON_lib_error_code,0,0);\\r\\nERR_load_strings(0,NURON_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_NURON_strings(void)\\r\\n{\\r\\nif (NURON_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(NURON_lib_error_code,NURON_str_functs);\\r\\nERR_unload_strings(NURON_lib_error_code,NURON_str_reasons);\\r\\n#endif\\r\\n#ifdef NURON_LIB_NAME\\r\\nERR_unload_strings(0,NURON_lib_name);\\r\\n#endif\\r\\nNURON_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_NURON_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (NURON_lib_error_code == 0)\\r\\nNURON_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(NURON_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_mem_clr_c", "target": 0, "func": "void OPENSSL_cleanse(void *ptr, size_t len)\\r\\n{\\r\\nunsigned char *p = ptr;\\r\\nsize_t loop = len;\\r\\nwhile(loop--)\\r\\n{\\r\\n*(p++) = cleanse_ctr;\\r\\ncleanse_ctr += (17 + (unsigned char)((unsigned long)p & 0xF));\\r\\n}\\r\\nif(memchr(ptr, cleanse_ctr, len))\\r\\ncleanse_ctr += 63;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_aes_misc_c", "target": 0, "func": "const char *AES_options(void) {\\r\\n#ifdef FULL_UNROLL\\r\\nreturn \"aes(full)\";\\r\\n#else\\r\\nreturn \"aes(partial)\";\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_d1_meth_c", "target": 0, "func": "static SSL_METHOD *dtls1_get_method(int ver)\\r\\n{\\r\\nif (ver == DTLS1_VERSION)\\r\\nreturn(DTLSv1_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *DTLSv1_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD DTLSv1_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&DTLSv1_data,(char *)dtlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nDTLSv1_data.ssl_connect=dtls1_connect;\\r\\nDTLSv1_data.ssl_accept=dtls1_accept;\\r\\nDTLSv1_data.get_ssl_method=dtls1_get_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&DTLSv1_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_sconnect_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *host;\\r\\nBIO *out;\\r\\nchar buf[1024*10],*p;\\r\\nSSL_CTX *ssl_ctx=NULL;\\r\\nSSL *ssl;\\r\\nBIO *ssl_bio;\\r\\nint i,len,off,ret=1;\\r\\nif (argc <= 1)\\r\\nhost=\"localhost:4433\";\\r\\nelse\\r\\nhost=argv[1];\\r\\n#ifdef WATT32\\r\\ndbug_init();\\r\\nsock_init();\\r\\n#endif\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nssl_ctx=SSL_CTX_new(SSLv23_client_method());\\r\\nssl=SSL_new(ssl_ctx);\\r\\nSSL_set_connect_state(ssl);\\r\\nssl_bio=BIO_new(BIO_f_ssl());\\r\\nBIO_set_ssl(ssl_bio,ssl,BIO_CLOSE);\\r\\nout=BIO_new(BIO_s_connect());\\r\\nBIO_set_conn_hostname(out,host);\\r\\nBIO_set_nbio(out,1);\\r\\nout=BIO_push(ssl_bio,out);\\r\\np=\"GET / HTTP/1.0\\r\\n\\r\\n\";\\r\\nlen=strlen(p);\\r\\noff=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(out,&(p[off]),len);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (BIO_should_retry(out))\\r\\n{\\r\\nfprintf(stderr,\"write DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\noff+=i;\\r\\nlen-=i;\\r\\nif (len <= 0) break;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(out,buf,sizeof(buf));\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nif (BIO_should_retry(out))\\r\\n{\\r\\nfprintf(stderr,\"read DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf,1,i,stdout);\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ERR_peek_error() == 0)\\r\\n{\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"error\");\\r\\n}\\r\\nelse\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nBIO_free_all(out);\\r\\nif (ssl_ctx != NULL) SSL_CTX_free(ssl_ctx);\\r\\nexit(!ret);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_depr_c", "target": 0, "func": "DSA *DSA_generate_parameters(int bits,\\r\\nunsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret,\\r\\nvoid (*callback)(int, int, void *),\\r\\nvoid *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nDSA *ret;\\r\\nif ((ret=DSA_new()) == NULL) return NULL;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif(DSA_generate_parameters_ex(ret, bits, seed_in, seed_len,\\r\\ncounter_ret, h_ret, &cb))\\r\\nreturn ret;\\r\\nDSA_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dsa_vrf_c", "target": 0, "func": "int DSA_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,\\r\\nDSA *dsa)\\r\\n{\\r\\nreturn dsa->meth->dsa_do_verify(dgst, dgst_len, sig, dsa);\\r\\n}\\r\\nint DSA_verify(int type, const unsigned char *dgst, int dgst_len,\\r\\nconst unsigned char *sigbuf, int siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\nint ret=-1;\\r\\ns = DSA_SIG_new();\\r\\nif (s == NULL) return(ret);\\r\\nif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\\r\\nret=DSA_do_verify(dgst,dgst_len,s,dsa);\\r\\nerr:\\r\\nDSA_SIG_free(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cversion_c", "target": 0, "func": "const char *SSLeay_version(int t)\\r\\n{\\r\\nif (t == SSLEAY_VERSION)\\r\\nreturn OPENSSL_VERSION_TEXT;\\r\\nif (t == SSLEAY_BUILT_ON)\\r\\n{\\r\\n#ifdef DATE\\r\\nstatic char buf[sizeof(DATE)+11];\\r\\nBIO_snprintf(buf,sizeof buf,\"built on: %s\",DATE);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"built on: date not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_CFLAGS)\\r\\n{\\r\\n#ifdef CFLAGS\\r\\nstatic char buf[sizeof(CFLAGS)+11];\\r\\nBIO_snprintf(buf,sizeof buf,\"compiler: %s\",CFLAGS);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"compiler: information not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_PLATFORM)\\r\\n{\\r\\n#ifdef PLATFORM\\r\\nstatic char buf[sizeof(PLATFORM)+11];\\r\\nBIO_snprintf(buf,sizeof buf,\"platform: %s\", PLATFORM);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"platform: information not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_DIR)\\r\\n{\\r\\n#ifdef OPENSSLDIR\\r\\nreturn \"OPENSSLDIR: \\\"\" OPENSSLDIR \"\\\"\";\\r\\n#else\\r\\nreturn \"OPENSSLDIR: N/A\";\\r\\n#endif\\r\\n}\\r\\nreturn(\"not available\");\\r\\n}\\r\\nunsigned long SSLeay(void)\\r\\n{\\r\\nreturn(SSLEAY_VERSION_NUMBER);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_xcbc_enc_c", "target": 0, "func": "void DES_xwhite_in2out(const_DES_cblock *des_key, const_DES_cblock *in_white,\\r\\nDES_cblock *out_white)\\r\\n{\\r\\nint out0,out1;\\r\\nint i;\\r\\nconst unsigned char *key = &(*des_key)[0];\\r\\nconst unsigned char *in = &(*in_white)[0];\\r\\nunsigned char *out = &(*out_white)[0];\\r\\nout[0]=out[1]=out[2]=out[3]=out[4]=out[5]=out[6]=out[7]=0;\\r\\nout0=out1=0;\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nout[i]=key[i]^desx_white_in2out[out0^out1];\\r\\nout0=out1;\\r\\nout1=(int)out[i&0x07];\\r\\n}\\r\\nout0=out[0];\\r\\nout1=out[i];\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nout[i]=in[i]^desx_white_in2out[out0^out1];\\r\\nout0=out1;\\r\\nout1=(int)out[i&0x07];\\r\\n}\\r\\n}\\r\\nvoid DES_xcbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, const_DES_cblock *inw,\\r\\nconst_DES_cblock *outw, int enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1;\\r\\nregister DES_LONG inW0,inW1,outW0,outW1;\\r\\nregister const unsigned char *in2;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin2 = &(*inw)[0];\\r\\nc2l(in2,inW0);\\r\\nc2l(in2,inW1);\\r\\nin2 = &(*outw)[0];\\r\\nc2l(in2,outW0);\\r\\nc2l(in2,outW1);\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0^inW0; tin[0]=tin0;\\r\\ntin1^=tout1^inW1; tin[1]=tin1;\\r\\nDES_encrypt1(tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0]^outW0; l2c(tout0,out);\\r\\ntout1=tin[1]^outW1; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0^inW0; tin[0]=tin0;\\r\\ntin1^=tout1^inW1; tin[1]=tin1;\\r\\nDES_encrypt1(tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0]^outW0; l2c(tout0,out);\\r\\ntout1=tin[1]^outW1; l2c(tout1,out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (l-=8; l>0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0^outW0;\\r\\nc2l(in,tin1); tin[1]=tin1^outW1;\\r\\nDES_encrypt1(tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0^inW0;\\r\\ntout1=tin[1]^xor1^inW1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0^outW0;\\r\\nc2l(in,tin1); tin[1]=tin1^outW1;\\r\\nDES_encrypt1(tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0^inW0;\\r\\ntout1=tin[1]^xor1^inW1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ninW0=inW1=outW0=outW1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_pubkey_c", "target": 0, "func": "static int pubkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif (operation == ASN1_OP_FREE_POST)\\r\\n{\\r\\nX509_PUBKEY *pubkey = (X509_PUBKEY *)*pval;\\r\\nEVP_PKEY_free(pubkey->pkey);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nRSA *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey) return NULL;\\r\\nkey = EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key) return NULL;\\r\\n*pp = q;\\r\\nif (a)\\r\\n{\\r\\nRSA_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn key;\\r\\n}\\r\\nint i2d_RSA_PUBKEY(RSA *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif (!a) return 0;\\r\\npktmp = EVP_PKEY_new();\\r\\nif (!pktmp)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSA_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_set1_RSA(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn ret;\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nDSA *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey) return NULL;\\r\\nkey = EVP_PKEY_get1_DSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key) return NULL;\\r\\n*pp = q;\\r\\nif (a)\\r\\n{\\r\\nDSA_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn key;\\r\\n}\\r\\nint i2d_DSA_PUBKEY(DSA *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif(!a) return 0;\\r\\npktmp = EVP_PKEY_new();\\r\\nif(!pktmp)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_DSA_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_set1_DSA(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nEC_KEY *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey) return(NULL);\\r\\nkey = EVP_PKEY_get1_EC_KEY(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key) return(NULL);\\r\\n*pp = q;\\r\\nif (a)\\r\\n{\\r\\nEC_KEY_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn(key);\\r\\n}\\r\\nint i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif (!a) return(0);\\r\\nif ((pktmp = EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_EC_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nEVP_PKEY_set1_EC_KEY(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s_cb_c", "target": 0, "func": "int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nX509 *err_cert;\\r\\nint err,depth;\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr= X509_STORE_CTX_get_error(ctx);\\r\\ndepth= X509_STORE_CTX_get_error_depth(ctx);\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,sizeof buf);\\r\\nBIO_printf(bio_err,\"depth=%d %s\\n\",depth,buf);\\r\\nif (!ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:num=%d:%s\\n\",err,\\r\\nX509_verify_cert_error_string(err));\\r\\nif (verify_depth >= depth)\\r\\n{\\r\\nok=1;\\r\\nverify_error=X509_V_OK;\\r\\n}\\r\\nelse\\r\\n{\\r\\nok=0;\\r\\nverify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG;\\r\\n}\\r\\n}\\r\\nswitch (ctx->error)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,sizeof buf);\\r\\nBIO_printf(bio_err,\"issuer= %s\\n\",buf);\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nBIO_printf(bio_err,\"notBefore=\");\\r\\nASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nBIO_printf(bio_err,\"notAfter=\");\\r\\nASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\n}\\r\\nBIO_printf(bio_err,\"verify return:%d\\n\",ok);\\r\\nreturn(ok);\\r\\n}\\r\\nint set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)\\r\\n{\\r\\nif (cert_file != NULL)\\r\\n{\\r\\nif (SSL_CTX_use_certificate_file(ctx,cert_file,\\r\\nSSL_FILETYPE_PEM) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get certificate from '%s'\\n\",cert_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nif (key_file == NULL) key_file=cert_file;\\r\\nif (SSL_CTX_use_PrivateKey_file(ctx,key_file,\\r\\nSSL_FILETYPE_PEM) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get private key from '%s'\\n\",key_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\n{\\r\\nBIO_printf(bio_err,\"Private key does not match the certificate public key\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key)\\r\\n{\\r\\nif (cert == NULL)\\r\\nreturn 1;\\r\\nif (SSL_CTX_use_certificate(ctx,cert) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"error setting certificate\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 0;\\r\\n}\\r\\nif (SSL_CTX_use_PrivateKey(ctx,key) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"error setting private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 0;\\r\\n}\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\n{\\r\\nBIO_printf(bio_err,\"Private key does not match the certificate public key\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nlong MS_CALLBACK bio_dump_callback(BIO *bio, int cmd, const char *argp,\\r\\nint argi, long argl, long ret)\\r\\n{\\r\\nBIO *out;\\r\\nout=(BIO *)BIO_get_callback_arg(bio);\\r\\nif (out == NULL) return(ret);\\r\\nif (cmd == (BIO_CB_READ|BIO_CB_RETURN))\\r\\n{\\r\\nBIO_printf(out,\"read from %p [%p] (%d bytes => %ld (0x%lX))\\n\",\\r\\n(void *)bio,argp,argi,ret,ret);\\r\\nBIO_dump(out,argp,(int)ret);\\r\\nreturn(ret);\\r\\n}\\r\\nelse if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))\\r\\n{\\r\\nBIO_printf(out,\"write to %p [%p] (%d bytes => %ld (0x%lX))\\n\",\\r\\n(void *)bio,argp,argi,ret,ret);\\r\\nBIO_dump(out,argp,(int)ret);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid MS_CALLBACK apps_ssl_info_callback(const SSL *s, int where, int ret)\\r\\n{\\r\\nconst char *str;\\r\\nint w;\\r\\nw=where& ~SSL_ST_MASK;\\r\\nif (w & SSL_ST_CONNECT) str=\"SSL_connect\";\\r\\nelse if (w & SSL_ST_ACCEPT) str=\"SSL_accept\";\\r\\nelse str=\"undefined\";\\r\\nif (where & SSL_CB_LOOP)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s:%s\\n\",str,SSL_state_string_long(s));\\r\\n}\\r\\nelse if (where & SSL_CB_ALERT)\\r\\n{\\r\\nstr=(where & SSL_CB_READ)?\"read\":\"write\";\\r\\nBIO_printf(bio_err,\"SSL3 alert %s:%s:%s\\n\",\\r\\nstr,\\r\\nSSL_alert_type_string_long(ret),\\r\\nSSL_alert_desc_string_long(ret));\\r\\n}\\r\\nelse if (where & SSL_CB_EXIT)\\r\\n{\\r\\nif (ret == 0)\\r\\nBIO_printf(bio_err,\"%s:failed in %s\\n\",\\r\\nstr,SSL_state_string_long(s));\\r\\nelse if (ret < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s:error in %s\\n\",\\r\\nstr,SSL_state_string_long(s));\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid MS_CALLBACK msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)\\r\\n{\\r\\nBIO *bio = arg;\\r\\nconst char *str_write_p, *str_version, *str_content_type = \"\", *str_details1 = \"\", *str_details2= \"\";\\r\\nstr_write_p = write_p ? \">>>\" : \"<<<\";\\r\\nswitch (version)\\r\\n{\\r\\ncase SSL2_VERSION:\\r\\nstr_version = \"SSL 2.0\";\\r\\nbreak;\\r\\ncase SSL3_VERSION:\\r\\nstr_version = \"SSL 3.0 \";\\r\\nbreak;\\r\\ncase TLS1_VERSION:\\r\\nstr_version = \"TLS 1.0 \";\\r\\nbreak;\\r\\ndefault:\\r\\nstr_version = \"???\";\\r\\n}\\r\\nif (version == SSL2_VERSION)\\r\\n{\\r\\nstr_details1 = \"???\";\\r\\nif (len > 0)\\r\\n{\\r\\nswitch (((const unsigned char*)buf)[0])\\r\\n{\\r\\ncase 0:\\r\\nstr_details1 = \", ERROR:\";\\r\\nstr_details2 = \" ???\";\\r\\nif (len >= 3)\\r\\n{\\r\\nunsigned err = (((const unsigned char*)buf)[1]<<8) + ((const unsigned char*)buf)[2];\\r\\nswitch (err)\\r\\n{\\r\\ncase 0x0001:\\r\\nstr_details2 = \" NO-CIPHER-ERROR\";\\r\\nbreak;\\r\\ncase 0x0002:\\r\\nstr_details2 = \" NO-CERTIFICATE-ERROR\";\\r\\nbreak;\\r\\ncase 0x0004:\\r\\nstr_details2 = \" BAD-CERTIFICATE-ERROR\";\\r\\nbreak;\\r\\ncase 0x0006:\\r\\nstr_details2 = \" UNSUPPORTED-CERTIFICATE-TYPE-ERROR\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase 1:\\r\\nstr_details1 = \", CLIENT-HELLO\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", CLIENT-MASTER-KEY\";\\r\\nbreak;\\r\\ncase 3:\\r\\nstr_details1 = \", CLIENT-FINISHED\";\\r\\nbreak;\\r\\ncase 4:\\r\\nstr_details1 = \", SERVER-HELLO\";\\r\\nbreak;\\r\\ncase 5:\\r\\nstr_details1 = \", SERVER-VERIFY\";\\r\\nbreak;\\r\\ncase 6:\\r\\nstr_details1 = \", SERVER-FINISHED\";\\r\\nbreak;\\r\\ncase 7:\\r\\nstr_details1 = \", REQUEST-CERTIFICATE\";\\r\\nbreak;\\r\\ncase 8:\\r\\nstr_details1 = \", CLIENT-CERTIFICATE\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (version == SSL3_VERSION || version == TLS1_VERSION)\\r\\n{\\r\\nswitch (content_type)\\r\\n{\\r\\ncase 20:\\r\\nstr_content_type = \"ChangeCipherSpec\";\\r\\nbreak;\\r\\ncase 21:\\r\\nstr_content_type = \"Alert\";\\r\\nbreak;\\r\\ncase 22:\\r\\nstr_content_type = \"Handshake\";\\r\\nbreak;\\r\\n}\\r\\nif (content_type == 21)\\r\\n{\\r\\nstr_details1 = \", ???\";\\r\\nif (len == 2)\\r\\n{\\r\\nswitch (((const unsigned char*)buf)[0])\\r\\n{\\r\\ncase 1:\\r\\nstr_details1 = \", warning\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", fatal\";\\r\\nbreak;\\r\\n}\\r\\nstr_details2 = \" ???\";\\r\\nswitch (((const unsigned char*)buf)[1])\\r\\n{\\r\\ncase 0:\\r\\nstr_details2 = \" close_notify\";\\r\\nbreak;\\r\\ncase 10:\\r\\nstr_details2 = \" unexpected_message\";\\r\\nbreak;\\r\\ncase 20:\\r\\nstr_details2 = \" bad_record_mac\";\\r\\nbreak;\\r\\ncase 21:\\r\\nstr_details2 = \" decryption_failed\";\\r\\nbreak;\\r\\ncase 22:\\r\\nstr_details2 = \" record_overflow\";\\r\\nbreak;\\r\\ncase 30:\\r\\nstr_details2 = \" decompression_failure\";\\r\\nbreak;\\r\\ncase 40:\\r\\nstr_details2 = \" handshake_failure\";\\r\\nbreak;\\r\\ncase 42:\\r\\nstr_details2 = \" bad_certificate\";\\r\\nbreak;\\r\\ncase 43:\\r\\nstr_details2 = \" unsupported_certificate\";\\r\\nbreak;\\r\\ncase 44:\\r\\nstr_details2 = \" certificate_revoked\";\\r\\nbreak;\\r\\ncase 45:\\r\\nstr_details2 = \" certificate_expired\";\\r\\nbreak;\\r\\ncase 46:\\r\\nstr_details2 = \" certificate_unknown\";\\r\\nbreak;\\r\\ncase 47:\\r\\nstr_details2 = \" illegal_parameter\";\\r\\nbreak;\\r\\ncase 48:\\r\\nstr_details2 = \" unknown_ca\";\\r\\nbreak;\\r\\ncase 49:\\r\\nstr_details2 = \" access_denied\";\\r\\nbreak;\\r\\ncase 50:\\r\\nstr_details2 = \" decode_error\";\\r\\nbreak;\\r\\ncase 51:\\r\\nstr_details2 = \" decrypt_error\";\\r\\nbreak;\\r\\ncase 60:\\r\\nstr_details2 = \" export_restriction\";\\r\\nbreak;\\r\\ncase 70:\\r\\nstr_details2 = \" protocol_version\";\\r\\nbreak;\\r\\ncase 71:\\r\\nstr_details2 = \" insufficient_security\";\\r\\nbreak;\\r\\ncase 80:\\r\\nstr_details2 = \" internal_error\";\\r\\nbreak;\\r\\ncase 90:\\r\\nstr_details2 = \" user_canceled\";\\r\\nbreak;\\r\\ncase 100:\\r\\nstr_details2 = \" no_renegotiation\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (content_type == 22)\\r\\n{\\r\\nstr_details1 = \"???\";\\r\\nif (len > 0)\\r\\n{\\r\\nswitch (((const unsigned char*)buf)[0])\\r\\n{\\r\\ncase 0:\\r\\nstr_details1 = \", HelloRequest\";\\r\\nbreak;\\r\\ncase 1:\\r\\nstr_details1 = \", ClientHello\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", ServerHello\";\\r\\nbreak;\\r\\ncase 11:\\r\\nstr_details1 = \", Certificate\";\\r\\nbreak;\\r\\ncase 12:\\r\\nstr_details1 = \", ServerKeyExchange\";\\r\\nbreak;\\r\\ncase 13:\\r\\nstr_details1 = \", CertificateRequest\";\\r\\nbreak;\\r\\ncase 14:\\r\\nstr_details1 = \", ServerHelloDone\";\\r\\nbreak;\\r\\ncase 15:\\r\\nstr_details1 = \", CertificateVerify\";\\r\\nbreak;\\r\\ncase 16:\\r\\nstr_details1 = \", ClientKeyExchange\";\\r\\nbreak;\\r\\ncase 20:\\r\\nstr_details1 = \", Finished\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nBIO_printf(bio, \"%s %s%s [length %04lx]%s%s\\n\", str_write_p, str_version, str_content_type, (unsigned long)len, str_details1, str_details2);\\r\\nif (len > 0)\\r\\n{\\r\\nsize_t num, i;\\r\\nBIO_printf(bio, \" \");\\r\\nnum = len;\\r\\n#if 0\\r\\nif (num > 16)\\r\\nnum = 16;\\r\\n#endif\\r\\nfor (i = 0; i < num; i++)\\r\\n{\\r\\nif (i % 16 == 0 && i > 0)\\r\\nBIO_printf(bio, \"\\n \");\\r\\nBIO_printf(bio, \" %02x\", ((const unsigned char*)buf)[i]);\\r\\n}\\r\\nif (i < len)\\r\\nBIO_printf(bio, \" ...\");\\r\\nBIO_printf(bio, \"\\n\");\\r\\n}\\r\\nBIO_flush(bio);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_obj_c", "target": 0, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint i;\\r\\nint n,lold,l,l1,l2,num,j,type;\\r\\nconst char *s;\\r\\nchar *p;\\r\\nunsigned char *q;\\r\\nBUF_MEM *b=NULL;\\r\\nstatic char hex[17]=\"0123456789ABCDEF\";\\r\\nint gs_doit[4];\\r\\nchar tmp_buf[80];\\r\\n#ifdef CHARSET_EBCDIC\\r\\nchar ebcdic_buf[1024];\\r\\n#endif\\r\\nif (buf == NULL)\\r\\n{\\r\\nif ((b=BUF_MEM_new()) == NULL) goto err;\\r\\nif (!BUF_MEM_grow(b,200)) goto err;\\r\\nb->data[0]='\\0';\\r\\nlen=200;\\r\\n}\\r\\nif (a == NULL)\\r\\n{\\r\\nif(b)\\r\\n{\\r\\nbuf=b->data;\\r\\nOPENSSL_free(b);\\r\\n}\\r\\nstrncpy(buf,\"NO X509_NAME\",len);\\r\\nbuf[len-1]='\\0';\\r\\nreturn buf;\\r\\n}\\r\\nlen--;\\r\\nl=0;\\r\\nfor (i=0; i<sk_X509_NAME_ENTRY_num(a->entries); i++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nn=OBJ_obj2nid(ne->object);\\r\\nif ((n == NID_undef) || ((s=OBJ_nid2sn(n)) == NULL))\\r\\n{\\r\\ni2t_ASN1_OBJECT(tmp_buf,sizeof(tmp_buf),ne->object);\\r\\ns=tmp_buf;\\r\\n}\\r\\nl1=strlen(s);\\r\\ntype=ne->value->type;\\r\\nnum=ne->value->length;\\r\\nq=ne->value->data;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nif (type == V_ASN1_GENERALSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING ||\\r\\ntype == V_ASN1_PRINTABLESTRING ||\\r\\ntype == V_ASN1_TELETEXSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING ||\\r\\ntype == V_ASN1_IA5STRING) {\\r\\nascii2ebcdic(ebcdic_buf, q,\\r\\n(num > sizeof ebcdic_buf)\\r\\n? sizeof ebcdic_buf : num);\\r\\nq=ebcdic_buf;\\r\\n}\\r\\n#endif\\r\\nif ((type == V_ASN1_GENERALSTRING) && ((num%4) == 0))\\r\\n{\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=0;\\r\\nfor (j=0; j<num; j++)\\r\\nif (q[j] != 0) gs_doit[j&3]=1;\\r\\nif (gs_doit[0]|gs_doit[1]|gs_doit[2])\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\\r\\nelse\\r\\n{\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=0;\\r\\ngs_doit[3]=1;\\r\\n}\\r\\n}\\r\\nelse\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\\r\\nfor (l2=j=0; j<num; j++)\\r\\n{\\r\\nif (!gs_doit[j&3]) continue;\\r\\nl2++;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ((q[j] < ' ') || (q[j] > '~')) l2+=3;\\r\\n#else\\r\\nif ((os_toascii[q[j]] < os_toascii[' ']) ||\\r\\n(os_toascii[q[j]] > os_toascii['~'])) l2+=3;\\r\\n#endif\\r\\n}\\r\\nlold=l;\\r\\nl+=1+l1+1+l2;\\r\\nif (b != NULL)\\r\\n{\\r\\nif (!BUF_MEM_grow(b,l+1)) goto err;\\r\\np= &(b->data[lold]);\\r\\n}\\r\\nelse if (l > len)\\r\\n{\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\np= &(buf[lold]);\\r\\n*(p++)='/';\\r\\nmemcpy(p,s,(unsigned int)l1); p+=l1;\\r\\n*(p++)='=';\\r\\n#ifndef CHARSET_EBCDIC\\r\\nq=ne->value->data;\\r\\n#endif\\r\\nfor (j=0; j<num; j++)\\r\\n{\\r\\nif (!gs_doit[j&3]) continue;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nn=q[j];\\r\\nif ((n < ' ') || (n > '~'))\\r\\n{\\r\\n*(p++)='\\\\';\\r\\n*(p++)='x';\\r\\n*(p++)=hex[(n>>4)&0x0f];\\r\\n*(p++)=hex[n&0x0f];\\r\\n}\\r\\nelse\\r\\n*(p++)=n;\\r\\n#else\\r\\nn=os_toascii[q[j]];\\r\\nif ((n < os_toascii[' ']) ||\\r\\n(n > os_toascii['~']))\\r\\n{\\r\\n*(p++)='\\\\';\\r\\n*(p++)='x';\\r\\n*(p++)=hex[(n>>4)&0x0f];\\r\\n*(p++)=hex[n&0x0f];\\r\\n}\\r\\nelse\\r\\n*(p++)=q[j];\\r\\n#endif\\r\\n}\\r\\n*p='\\0';\\r\\n}\\r\\nif (b != NULL)\\r\\n{\\r\\np=b->data;\\r\\nOPENSSL_free(b);\\r\\n}\\r\\nelse\\r\\np=buf;\\r\\nif (i == 0)\\r\\n*p = '\\0';\\r\\nreturn(p);\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_s3_srvr_c", "target": 0, "func": "static SSL_METHOD *ssl3_get_server_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_server_data;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv3_server_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_server_data.ssl_accept=ssl3_accept;\\r\\nSSLv3_server_data.get_ssl_method=ssl3_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\\r\\n}\\r\\nreturn(&SSLv3_server_data);\\r\\n}\\r\\nint ssl3_accept(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long l,Time=time(NULL);\\r\\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\\r\\nlong num1;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;\\r\\nRAND_add(&Time,sizeof(Time),0);\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ns->in_handshake++;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version>>8) != 3)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (s->state != SSL_ST_RENEGOTIATE)\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_accept++;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->ctx->stats.sess_accept_renegotiate++;\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_A;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A:\\r\\ncase SSL3_ST_SW_HELLO_REQ_B:\\r\\ns->shutdown=0;\\r\\nret=ssl3_send_hello_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nssl3_init_finished_mac(s);\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C:\\r\\ns->state=SSL_ST_OK;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C:\\r\\ns->shutdown=0;\\r\\nret=ssl3_get_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->new_session = 2;\\r\\ns->state=SSL3_ST_SW_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A:\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B:\\r\\nret=ssl3_send_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CERT_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_A:\\r\\ncase SSL3_ST_SW_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=ssl3_send_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A:\\r\\ncase SSL3_ST_SW_KEY_EXCH_B:\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif ((s->options & SSL_OP_EPHEMERAL_RSA)\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\n&& !(l & SSL_KRB5)\\r\\n#endif\\r\\n)\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\nelse\\r\\ns->s3->tmp.use_rsa_tmp=0;\\r\\nif (s->s3->tmp.use_rsa_tmp\\r\\n|| (l & SSL_kECDHE)\\r\\n|| (l & (SSL_DH|SSL_kFZA))\\r\\n|| ((l & SSL_kRSA)\\r\\n&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\\r\\n|| (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\\r\\n&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\\r\\n)\\r\\n)\\r\\n)\\r\\n)\\r\\n{\\r\\nret=ssl3_send_server_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_A:\\r\\ncase SSL3_ST_SW_CERT_REQ_B:\\r\\nif (\\r\\n!(s->verify_mode & SSL_VERIFY_PEER) ||\\r\\n((s->session->peer != NULL) &&\\r\\n(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\\r\\n((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&\\r\\n!(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\\r\\n(s->s3->tmp.new_cipher->algorithms & SSL_aKRB5))\\r\\n{\\r\\nskip=1;\\r\\ns->s3->tmp.cert_request=0;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_request=1;\\r\\nret=ssl3_send_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\n#ifndef NETSCAPE_HANG_BUG\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\n#else\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\\r\\n#endif\\r\\ns->init_num=0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A:\\r\\ncase SSL3_ST_SW_SRVR_DONE_B:\\r\\nret=ssl3_send_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_A:\\r\\ncase SSL3_ST_SR_CERT_B:\\r\\nret = ssl3_check_client_hello(s);\\r\\nif (ret <= 0)\\r\\ngoto end;\\r\\nif (ret == 2)\\r\\ns->state = SSL3_ST_SR_CLNT_HELLO_C;\\r\\nelse {\\r\\nif (s->s3->tmp.cert_request)\\r\\n{\\r\\nret=ssl3_get_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\ns->init_num=0;\\r\\ns->state=SSL3_ST_SR_KEY_EXCH_A;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A:\\r\\ncase SSL3_ST_SR_KEY_EXCH_B:\\r\\nret=ssl3_get_client_key_exchange(s);\\r\\nif (ret <= 0)\\r\\ngoto end;\\r\\nif (ret == 2)\\r\\n{\\r\\ns->state=SSL3_ST_SR_FINISHED_A;\\r\\ns->init_num = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL3_ST_SR_CERT_VRFY_A;\\r\\ns->init_num=0;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->tmp.cert_verify_md[0]));\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst2),\\r\\n&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A:\\r\\ncase SSL3_ST_SR_CERT_VRFY_B:\\r\\nret=ssl3_get_cert_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SR_FINISHED_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\\r\\nSSL3_ST_SR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL_ST_OK;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{ ret= -1; goto end; }\\r\\nret=ssl3_send_change_cipher_spec(s,\\r\\nSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FINISHED_A;\\r\\ns->init_num=0;\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_SERVER_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\nret=ssl3_send_finished(s,\\r\\nSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\\r\\ns->method->ssl3_enc->server_finished_label,\\r\\ns->method->ssl3_enc->server_finished_label_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\nif (s->hit)\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\\r\\nelse\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_num=0;\\r\\nif (s->new_session == 2)\\r\\n{\\r\\ns->new_session=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_SERVER);\\r\\ns->ctx->stats.sess_accept_good++;\\r\\ns->handshake_func=ssl3_accept;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\n}\\r\\nret = 1;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_send_hello_request(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_HELLO_REQ_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL3_MT_HELLO_REQUEST;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_B;\\r\\ns->init_num=4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_check_client_hello(SSL *s)\\r\\n{\\r\\nint ok;\\r\\nlong n;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_SR_CERT_A,\\r\\nSSL3_ST_SR_CERT_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\ns->s3->tmp.reuse_message = 1;\\r\\nif (s->s3->tmp.message_type == SSL3_MT_CLIENT_HELLO)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->s3->tmp.dh != NULL)\\r\\n{\\r\\nDH_free(s->s3->tmp.dh);\\r\\ns->s3->tmp.dh = NULL;\\r\\n}\\r\\n#endif\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ssl3_get_client_hello(SSL *s)\\r\\n{\\r\\nint i,j,ok,al,ret= -1;\\r\\nunsigned int cookie_len;\\r\\nlong n;\\r\\nunsigned long id;\\r\\nunsigned char *p,*d,*q;\\r\\nSSL_CIPHER *c;\\r\\nSSL_COMP *comp=NULL;\\r\\nSTACK_OF(SSL_CIPHER) *ciphers=NULL;\\r\\nif (s->state == SSL3_ST_SR_CLNT_HELLO_A)\\r\\n{\\r\\ns->first_packet=1;\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_SR_CLNT_HELLO_B,\\r\\nSSL3_ST_SR_CLNT_HELLO_C,\\r\\nSSL3_MT_CLIENT_HELLO,\\r\\nSSL3_RT_MAX_PLAIN_LENGTH,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nd=p=(unsigned char *)s->init_msg;\\r\\ns->client_version=(((int)p[0])<<8)|(int)p[1];\\r\\np+=2;\\r\\nif (s->client_version < s->version)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);\\r\\nif ((s->client_version>>8) == SSL3_VERSION_MAJOR)\\r\\n{\\r\\ns->version = s->client_version;\\r\\n}\\r\\nal = SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\nmemcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nj= *(p++);\\r\\ns->hit=0;\\r\\nif (j == 0 || (s->new_session && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION)))\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_get_prev_session(s,p,j);\\r\\nif (i == 1)\\r\\n{\\r\\ns->hit=1;\\r\\n}\\r\\nelse if (i == -1)\\r\\ngoto err;\\r\\nelse\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\np+=j;\\r\\nif (SSL_version(s) == DTLS1_VERSION)\\r\\n{\\r\\ncookie_len = *(p++);\\r\\nif ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&\\r\\ns->d1->send_cookie == 0)\\r\\n{\\r\\nif ( cookie_len != s->d1->cookie_len)\\r\\n{\\r\\nal = SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif ( cookie_len > sizeof(s->d1->rcvd_cookie))\\r\\n{\\r\\nal = SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif ( (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) &&\\r\\ncookie_len > 0)\\r\\n{\\r\\nmemcpy(s->d1->rcvd_cookie, p, cookie_len);\\r\\nif ( s->ctx->app_verify_cookie_cb != NULL)\\r\\n{\\r\\nif ( s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,\\r\\ncookie_len) == 0)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\\r\\nSSL_R_COOKIE_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse if ( memcmp(s->d1->rcvd_cookie, s->d1->cookie,\\r\\ns->d1->cookie_len) != 0)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\\r\\nSSL_R_COOKIE_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\np += cookie_len;\\r\\n}\\r\\nn2s(p,i);\\r\\nif ((i == 0) && (j != 0))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((p+i) >= (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))\\r\\n== NULL))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nif ((s->hit) && (i > 0))\\r\\n{\\r\\nj=0;\\r\\nid=s->session->cipher->id;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"client sent %d ciphers\\n\",sk_num(ciphers));\\r\\n#endif\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(ciphers,i);\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"client [%2d of %2d]:%s\\n\",\\r\\ni,sk_num(ciphers),SSL_CIPHER_get_name(c));\\r\\n#endif\\r\\nif (c->id == id)\\r\\n{\\r\\nj=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (j == 0)\\r\\n{\\r\\nif ((s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))\\r\\n{\\r\\ns->session->cipher=sk_SSL_CIPHER_value(ciphers, 0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n}\\r\\ni= *(p++);\\r\\nif ((p+i) > (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nq=p;\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (p[j] == 0) break;\\r\\n}\\r\\np+=i;\\r\\nif (j >= i)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_COMPRESSION_SPECIFIED);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.new_compression=NULL;\\r\\nif (s->ctx->comp_methods != NULL)\\r\\n{\\r\\nint m,nn,o,v,done=0;\\r\\nnn=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\nfor (m=0; m<nn; m++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,m);\\r\\nv=comp->id;\\r\\nfor (o=0; o<i; o++)\\r\\n{\\r\\nif (v == q[o])\\r\\n{\\r\\ndone=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (done) break;\\r\\n}\\r\\nif (done)\\r\\ns->s3->tmp.new_compression=comp;\\r\\nelse\\r\\ncomp=NULL;\\r\\n}\\r\\n#if 0\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\nif (p < (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (!s->hit)\\r\\n{\\r\\ns->session->compress_meth=(comp == NULL)?0:comp->id;\\r\\nif (s->session->ciphers != NULL)\\r\\nsk_SSL_CIPHER_free(s->session->ciphers);\\r\\ns->session->ciphers=ciphers;\\r\\nif (ciphers == NULL)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_PASSED);\\r\\ngoto f_err;\\r\\n}\\r\\nciphers=NULL;\\r\\nc=ssl3_choose_cipher(s,s->session->ciphers,\\r\\nSSL_get_ciphers(s));\\r\\nif (c == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.new_cipher=c;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef REUSE_CIPHER_BUG\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *nc=NULL;\\r\\nSSL_CIPHER *ec=NULL;\\r\\nif (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)\\r\\n{\\r\\nsk=s->session->ciphers;\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nif (c->algorithms & SSL_eNULL)\\r\\nnc=c;\\r\\nif (SSL_C_IS_EXPORT(c))\\r\\nec=c;\\r\\n}\\r\\nif (nc != NULL)\\r\\ns->s3->tmp.new_cipher=nc;\\r\\nelse if (ec != NULL)\\r\\ns->s3->tmp.new_cipher=ec;\\r\\nelse\\r\\ns->s3->tmp.new_cipher=s->session->cipher;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ns->s3->tmp.new_cipher=s->session->cipher;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nif (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_send_server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,sl;\\r\\nunsigned long l,Time;\\r\\nif (s->state == SSL3_ST_SW_SRVR_HELLO_A)\\r\\n{\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=s->s3->server_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nif (RAND_pseudo_bytes(p,SSL3_RANDOM_SIZE-4) <= 0)\\r\\nreturn -1;\\r\\nd=p= &(buf[4]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER))\\r\\ns->session->session_id_length=0;\\r\\nsl=s->session->session_id_length;\\r\\nif (sl > (int)sizeof(s->session->session_id))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\n*(p++)=sl;\\r\\nmemcpy(p,s->session->session_id,sl);\\r\\np+=sl;\\r\\ni=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);\\r\\np+=i;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\n*(p++)=0;\\r\\nelse\\r\\n*(p++)=s->s3->tmp.new_compression->id;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\n*(d++)=SSL3_MT_SERVER_HELLO;\\r\\nl2n3(l,d);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_send_server_done(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_SRVR_DONE_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL3_MT_SERVER_DONE;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_B;\\r\\ns->init_num=4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_send_server_key_exchange(SSL *s)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nunsigned char *q;\\r\\nint j,num;\\r\\nRSA *rsa;\\r\\nunsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nunsigned int u;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nDH *dh=NULL,*dhp;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nEC_KEY *ecdh=NULL, *ecdhp;\\r\\nunsigned char *encodedPoint = NULL;\\r\\nint encodedlen = 0;\\r\\nint curve_id = 0;\\r\\nBN_CTX *bn_ctx = NULL;\\r\\n#endif\\r\\nEVP_PKEY *pkey;\\r\\nunsigned char *p,*d;\\r\\nint al,i;\\r\\nunsigned long type;\\r\\nint n;\\r\\nCERT *cert;\\r\\nBIGNUM *r[4];\\r\\nint nr[4],kn;\\r\\nBUF_MEM *buf;\\r\\nEVP_MD_CTX md_ctx;\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nif (s->state == SSL3_ST_SW_KEY_EXCH_A)\\r\\n{\\r\\ntype=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;\\r\\ncert=s->cert;\\r\\nbuf=s->init_buf;\\r\\nr[0]=r[1]=r[2]=r[3]=NULL;\\r\\nn=0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (type & SSL_kRSA)\\r\\n{\\r\\nrsa=cert->rsa_tmp;\\r\\nif ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))\\r\\n{\\r\\nrsa=s->cert->rsa_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nif(rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ERROR_GENERATING_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\ncert->rsa_tmp=rsa;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nr[0]=rsa->n;\\r\\nr[1]=rsa->e;\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (type & SSL_kEDH)\\r\\n{\\r\\ndhp=cert->dh_tmp;\\r\\nif ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))\\r\\ndhp=s->cert->dh_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nif (dhp == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->tmp.dh != NULL)\\r\\n{\\r\\nDH_free(dh);\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh=DHparams_dup(dhp)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.dh=dh;\\r\\nif ((dhp->pub_key == NULL ||\\r\\ndhp->priv_key == NULL ||\\r\\n(s->options & SSL_OP_SINGLE_DH_USE)))\\r\\n{\\r\\nif(!DH_generate_key(dh))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\\r\\nERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ndh->pub_key=BN_dup(dhp->pub_key);\\r\\ndh->priv_key=BN_dup(dhp->priv_key);\\r\\nif ((dh->pub_key == NULL) ||\\r\\n(dh->priv_key == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr[0]=dh->p;\\r\\nr[1]=dh->g;\\r\\nr[2]=dh->pub_key;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (type & SSL_kECDHE)\\r\\n{\\r\\nconst EC_GROUP *group;\\r\\necdhp=cert->ecdh_tmp;\\r\\nif ((ecdhp == NULL) && (s->cert->ecdh_tmp_cb != NULL))\\r\\n{\\r\\necdhp=s->cert->ecdh_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\n}\\r\\nif (ecdhp == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->tmp.ecdh != NULL)\\r\\n{\\r\\nEC_KEY_free(s->s3->tmp.ecdh);\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (ecdhp == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_KEY_up_ref(ecdhp))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\necdh = ecdhp;\\r\\ns->s3->tmp.ecdh=ecdh;\\r\\nif ((EC_KEY_get0_public_key(ecdh) == NULL) ||\\r\\n(EC_KEY_get0_private_key(ecdh) == NULL) ||\\r\\n(s->options & SSL_OP_SINGLE_ECDH_USE))\\r\\n{\\r\\nif(!EC_KEY_generate_key(ecdh))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (((group = EC_KEY_get0_group(ecdh)) == NULL) ||\\r\\n(EC_KEY_get0_public_key(ecdh) == NULL) ||\\r\\n(EC_KEY_get0_private_key(ecdh) == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) &&\\r\\n(EC_GROUP_get_degree(group) > 163))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\nif ((curve_id =\\r\\nnid2curve_id(EC_GROUP_get_curve_name(group)))\\r\\n== 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNSUPPORTED_ELLIPTIC_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nencodedlen = EC_POINT_point2oct(group,\\r\\nEC_KEY_get0_public_key(ecdh),\\r\\nPOINT_CONVERSION_UNCOMPRESSED,\\r\\nNULL, 0, NULL);\\r\\nencodedPoint = (unsigned char *)\\r\\nOPENSSL_malloc(encodedlen*sizeof(unsigned char));\\r\\nbn_ctx = BN_CTX_new();\\r\\nif ((encodedPoint == NULL) || (bn_ctx == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nencodedlen = EC_POINT_point2oct(group,\\r\\nEC_KEY_get0_public_key(ecdh),\\r\\nPOINT_CONVERSION_UNCOMPRESSED,\\r\\nencodedPoint, encodedlen, bn_ctx);\\r\\nif (encodedlen == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_free(bn_ctx); bn_ctx=NULL;\\r\\nn = 3 + encodedlen;\\r\\nr[0]=NULL;\\r\\nr[1]=NULL;\\r\\nr[2]=NULL;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\nnr[i]=BN_num_bytes(r[i]);\\r\\nn+=2+nr[i];\\r\\n}\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nif ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))\\r\\n== NULL)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\nkn=EVP_PKEY_size(pkey);\\r\\n}\\r\\nelse\\r\\n{\\r\\npkey=NULL;\\r\\nkn=0;\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(buf,n+4+kn))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);\\r\\ngoto err;\\r\\n}\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\ns2n(nr[i],p);\\r\\nBN_bn2bin(r[i],p);\\r\\np+=nr[i];\\r\\n}\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (type & SSL_kECDHE)\\r\\n{\\r\\n*p = NAMED_CURVE_TYPE;\\r\\np += 1;\\r\\n*p = curve_id;\\r\\np += 1;\\r\\n*p = encodedlen;\\r\\np += 1;\\r\\nmemcpy((unsigned char*)p,\\r\\n(unsigned char *)encodedPoint,\\r\\nencodedlen);\\r\\nOPENSSL_free(encodedPoint);\\r\\np += encodedlen;\\r\\n}\\r\\n#endif\\r\\nif (pkey != NULL)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nq=md_buf;\\r\\nj=0;\\r\\nfor (num=2; num > 0; num--)\\r\\n{\\r\\nEVP_DigestInit_ex(&md_ctx,(num == 2)\\r\\n?s->ctx->md5:s->ctx->sha1, NULL);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(d[4]),n);\\r\\nEVP_DigestFinal_ex(&md_ctx,q,\\r\\n(unsigned int *)&i);\\r\\nq+=i;\\r\\nj+=i;\\r\\n}\\r\\nif (RSA_sign(NID_md5_sha1, md_buf, j,\\r\\n&(p[2]), &u, pkey->pkey.rsa) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(u,p);\\r\\nn+=u+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_DSA)\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nEVP_SignInit_ex(&md_ctx,EVP_dss1(), NULL);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(d[4]),n);\\r\\nif (!EVP_SignFinal(&md_ctx,&(p[2]),\\r\\n(unsigned int *)&i,pkey))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn+=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_ECDSA)\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nEVP_SignInit_ex(&md_ctx,EVP_ecdsa(), NULL);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(d[4]),n);\\r\\nif (!EVP_SignFinal(&md_ctx,&(p[2]),\\r\\n(unsigned int *)&i,pkey))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_ECDSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn+=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n*(d++)=SSL3_MT_SERVER_KEY_EXCHANGE;\\r\\nl2n3(n,d);\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\ns->state = SSL3_ST_SW_KEY_EXCH_B;\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (encodedPoint != NULL) OPENSSL_free(encodedPoint);\\r\\nBN_CTX_free(bn_ctx);\\r\\n#endif\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_send_certificate_request(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i,j,nl,off,n;\\r\\nSTACK_OF(X509_NAME) *sk=NULL;\\r\\nX509_NAME *name;\\r\\nBUF_MEM *buf;\\r\\nif (s->state == SSL3_ST_SW_CERT_REQ_A)\\r\\n{\\r\\nbuf=s->init_buf;\\r\\nd=p=(unsigned char *)&(buf->data[4]);\\r\\np++;\\r\\nn=ssl3_get_req_cert_type(s,p);\\r\\nd[0]=n;\\r\\np+=n;\\r\\nn++;\\r\\noff=n;\\r\\np+=2;\\r\\nn+=2;\\r\\nsk=SSL_get_client_CA_list(s);\\r\\nnl=0;\\r\\nif (sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_NAME_num(sk); i++)\\r\\n{\\r\\nname=sk_X509_NAME_value(sk,i);\\r\\nj=i2d_X509_NAME(name,NULL);\\r\\nif (!BUF_MEM_grow_clean(buf,4+n+j+2))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np=(unsigned char *)&(buf->data[4+n]);\\r\\nif (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\\r\\n{\\r\\ns2n(j,p);\\r\\ni2d_X509_NAME(name,&p);\\r\\nn+=2+j;\\r\\nnl+=2+j;\\r\\n}\\r\\nelse\\r\\n{\\r\\nd=p;\\r\\ni2d_X509_NAME(name,&p);\\r\\nj-=2; s2n(j,d); j+=2;\\r\\nn+=j;\\r\\nnl+=j;\\r\\n}\\r\\n}\\r\\n}\\r\\np=(unsigned char *)&(buf->data[4+off]);\\r\\ns2n(nl,p);\\r\\nd=(unsigned char *)buf->data;\\r\\n*(d++)=SSL3_MT_CERTIFICATE_REQUEST;\\r\\nl2n3(n,d);\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n#ifdef NETSCAPE_HANG_BUG\\r\\np=(unsigned char *)s->init_buf->data + s->init_num;\\r\\n*(p++)=SSL3_MT_SERVER_DONE;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->init_num += 4;\\r\\n#endif\\r\\ns->state = SSL3_ST_SW_CERT_REQ_B;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic void *KDF1_SHA1(const void *in, size_t inlen, void *out, size_t *outlen)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nif (*outlen < SHA_DIGEST_LENGTH)\\r\\nreturn NULL;\\r\\nelse\\r\\n*outlen = SHA_DIGEST_LENGTH;\\r\\nreturn SHA1(in, inlen, out);\\r\\n#else\\r\\nreturn NULL;\\r\\n#endif\\r\\n}\\r\\nint ssl3_get_client_key_exchange(SSL *s)\\r\\n{\\r\\nint i,al,ok;\\r\\nlong n;\\r\\nunsigned long l;\\r\\nunsigned char *p;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nRSA *rsa=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nBIGNUM *pub=NULL;\\r\\nDH *dh_srvr;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_ERR kssl_err;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nEC_KEY *srvr_ecdh = NULL;\\r\\nEVP_PKEY *clnt_pub_pkey = NULL;\\r\\nEC_POINT *clnt_ecpoint = NULL;\\r\\nBN_CTX *bn_ctx = NULL;\\r\\n#endif\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_SR_KEY_EXCH_A,\\r\\nSSL3_ST_SR_KEY_EXCH_B,\\r\\nSSL3_MT_CLIENT_KEY_EXCHANGE,\\r\\n2048,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\np=(unsigned char *)s->init_msg;\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (l & SSL_kRSA)\\r\\n{\\r\\nif (s->s3->tmp.use_rsa_tmp)\\r\\n{\\r\\nif ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))\\r\\nrsa=s->cert->rsa_tmp;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\npkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;\\r\\nif ( (pkey == NULL) ||\\r\\n(pkey->type != EVP_PKEY_RSA) ||\\r\\n(pkey->pkey.rsa == NULL))\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);\\r\\ngoto f_err;\\r\\n}\\r\\nrsa=pkey->pkey.rsa;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\nn2s(p,i);\\r\\nif (n != i+2)\\r\\n{\\r\\nif (!(s->options & SSL_OP_TLS_D5_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\np-=2;\\r\\n}\\r\\nelse\\r\\nn=i;\\r\\n}\\r\\ni=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);\\r\\nal = -1;\\r\\nif (i != SSL_MAX_MASTER_KEY_LENGTH)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\n}\\r\\nif ((al == -1) && !((p[0] == (s->client_version>>8)) && (p[1] == (s->client_version & 0xff))))\\r\\n{\\r\\nif (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&\\r\\n(p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\n}\\r\\n}\\r\\nif (al != -1)\\r\\n{\\r\\nERR_clear_error();\\r\\ni = SSL_MAX_MASTER_KEY_LENGTH;\\r\\np[0] = s->client_version >> 8;\\r\\np[1] = s->client_version & 0xff;\\r\\nif (RAND_pseudo_bytes(p+2, i-2) <= 0)\\r\\ngoto err;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\np,i);\\r\\nOPENSSL_cleanse(p,i);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nn2s(p,i);\\r\\nif (n != i+2)\\r\\n{\\r\\nif (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\np-=2;\\r\\ni=(int)n;\\r\\n}\\r\\n}\\r\\nif (n == 0L)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_DECODE_DH_CERTS);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->s3->tmp.dh == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\ndh_srvr=s->s3->tmp.dh;\\r\\n}\\r\\npub=BN_bin2bn(p,i,NULL);\\r\\nif (pub == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=DH_compute_key(p,pub,dh_srvr);\\r\\nif (i <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nDH_free(s->s3->tmp.dh);\\r\\ns->s3->tmp.dh=NULL;\\r\\nBN_clear_free(pub);\\r\\npub=NULL;\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,p,i);\\r\\nOPENSSL_cleanse(p,i);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (l & SSL_kKRB5)\\r\\n{\\r\\nkrb5_error_code krb5rc;\\r\\nkrb5_data enc_ticket;\\r\\nkrb5_data authenticator;\\r\\nkrb5_data enc_pms;\\r\\nKSSL_CTX *kssl_ctx = s->kssl_ctx;\\r\\nEVP_CIPHER_CTX ciph_ctx;\\r\\nEVP_CIPHER *enc = NULL;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char pms[SSL_MAX_MASTER_KEY_LENGTH\\r\\n+ EVP_MAX_BLOCK_LENGTH];\\r\\nint padl, outl;\\r\\nkrb5_timestamp authtime = 0;\\r\\nkrb5_ticket_times ttimes;\\r\\nEVP_CIPHER_CTX_init(&ciph_ctx);\\r\\nif (!kssl_ctx) kssl_ctx = kssl_ctx_new();\\r\\nn2s(p,i);\\r\\nenc_ticket.length = i;\\r\\nif (n < (int)enc_ticket.length + 6)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nenc_ticket.data = (char *)p;\\r\\np+=enc_ticket.length;\\r\\nn2s(p,i);\\r\\nauthenticator.length = i;\\r\\nif (n < (int)(enc_ticket.length + authenticator.length) + 6)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nauthenticator.data = (char *)p;\\r\\np+=authenticator.length;\\r\\nn2s(p,i);\\r\\nenc_pms.length = i;\\r\\nenc_pms.data = (char *)p;\\r\\np+=enc_pms.length;\\r\\nif(enc_pms.length > sizeof pms)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nif (n != (long)(enc_ticket.length + authenticator.length +\\r\\nenc_pms.length + 6))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = kssl_sget_tkt(kssl_ctx, &enc_ticket, &ttimes,\\r\\n&kssl_err)) != 0)\\r\\n{\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"kssl_sget_tkt rtn %d [%d]\\n\",\\r\\nkrb5rc, kssl_err.reason);\\r\\nif (kssl_err.text)\\r\\nprintf(\"kssl_err text= %s\\n\", kssl_err.text);\\r\\n#endif\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nkssl_err.reason);\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = kssl_check_authent(kssl_ctx, &authenticator,\\r\\n&authtime, &kssl_err)) != 0)\\r\\n{\\r\\n#ifdef KSSL_DEBUG\\r\\nprintf(\"kssl_check_authent rtn %d [%d]\\n\",\\r\\nkrb5rc, kssl_err.reason);\\r\\nif (kssl_err.text)\\r\\nprintf(\"kssl_err text= %s\\n\", kssl_err.text);\\r\\n#endif\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nkssl_err.reason);\\r\\ngoto err;\\r\\n}\\r\\nif ((krb5rc = kssl_validate_times(authtime, &ttimes)) != 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, krb5rc);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nkssl_ctx_show(kssl_ctx);\\r\\n#endif\\r\\nenc = kssl_map_enc(kssl_ctx->enctype);\\r\\nif (enc == NULL)\\r\\ngoto err;\\r\\nmemset(iv, 0, sizeof iv);\\r\\nif (!EVP_DecryptInit_ex(&ciph_ctx,enc,NULL,kssl_ctx->key,iv))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DECRYPTION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DecryptUpdate(&ciph_ctx, pms,&outl,\\r\\n(unsigned char *)enc_pms.data, enc_pms.length))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DECRYPTION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (outl > SSL_MAX_MASTER_KEY_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DecryptFinal_ex(&ciph_ctx,&(pms[outl]),&padl))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DECRYPTION_FAILED);\\r\\ngoto err;\\r\\n}\\r\\noutl += padl;\\r\\nif (outl > SSL_MAX_MASTER_KEY_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&ciph_ctx);\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key, pms, outl);\\r\\nif (kssl_ctx->client_princ)\\r\\n{\\r\\nint len = strlen(kssl_ctx->client_princ);\\r\\nif ( len < SSL_MAX_KRB5_PRINCIPAL_LENGTH )\\r\\n{\\r\\ns->session->krb5_client_princ_len = len;\\r\\nmemcpy(s->session->krb5_client_princ,kssl_ctx->client_princ,len);\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif ((l & SSL_kECDH) || (l & SSL_kECDHE))\\r\\n{\\r\\nint ret = 1;\\r\\nint field_size = 0;\\r\\nconst EC_KEY *tkey;\\r\\nconst EC_GROUP *group;\\r\\nconst BIGNUM *priv_key;\\r\\nif ((srvr_ecdh = EC_KEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (l & SSL_kECDH)\\r\\n{\\r\\ntkey = s->cert->key->privatekey->pkey.ec;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntkey = s->s3->tmp.ecdh;\\r\\n}\\r\\ngroup = EC_KEY_get0_group(tkey);\\r\\npriv_key = EC_KEY_get0_private_key(tkey);\\r\\nif (!EC_KEY_set_group(srvr_ecdh, group) ||\\r\\n!EC_KEY_set_private_key(srvr_ecdh, priv_key))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((clnt_ecpoint = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (n == 0L)\\r\\n{\\r\\nif (l & SSL_kECDHE)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_ECDH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nif (((clnt_pub_pkey=X509_get_pubkey(s->session->peer))\\r\\n== NULL) ||\\r\\n(clnt_pub_pkey->type != EVP_PKEY_EC))\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_UNABLE_TO_DECODE_ECDH_CERTS);\\r\\ngoto f_err;\\r\\n}\\r\\nEC_POINT_copy(clnt_ecpoint,\\r\\nEC_KEY_get0_public_key(clnt_pub_pkey->pkey.ec));\\r\\nret = 2;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((bn_ctx = BN_CTX_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni = *p;\\r\\np += 1;\\r\\nif (EC_POINT_oct2point(group,\\r\\nclnt_ecpoint, p, i, bn_ctx) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n}\\r\\nfield_size = EC_GROUP_get_degree(group);\\r\\nif (field_size <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (field_size <= 24 * 8)\\r\\ni = ECDH_compute_key(p, KDF1_SHA1_len, clnt_ecpoint, srvr_ecdh, KDF1_SHA1);\\r\\nelse\\r\\ni = ECDH_compute_key(p, (field_size+7)/8, clnt_ecpoint, srvr_ecdh, NULL);\\r\\nif (i <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nERR_R_ECDH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nEVP_PKEY_free(clnt_pub_pkey);\\r\\nEC_POINT_free(clnt_ecpoint);\\r\\nif (srvr_ecdh != NULL)\\r\\nEC_KEY_free(srvr_ecdh);\\r\\nBN_CTX_free(bn_ctx);\\r\\ns->session->master_key_length = s->method->ssl3_enc-> \\\\r\\ngenerate_master_secret(s, s->session->master_key, p, i);\\r\\nOPENSSL_cleanse(p, i);\\r\\nreturn (ret);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\\r\\nSSL_R_UNKNOWN_CIPHER_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_ECDH)\\r\\nerr:\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nEVP_PKEY_free(clnt_pub_pkey);\\r\\nEC_POINT_free(clnt_ecpoint);\\r\\nif (srvr_ecdh != NULL)\\r\\nEC_KEY_free(srvr_ecdh);\\r\\nBN_CTX_free(bn_ctx);\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl3_get_cert_verify(SSL *s)\\r\\n{\\r\\nEVP_PKEY *pkey=NULL;\\r\\nunsigned char *p;\\r\\nint al,ok,ret=0;\\r\\nlong n;\\r\\nint type=0,i,j;\\r\\nX509 *peer;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_SR_CERT_VRFY_A,\\r\\nSSL3_ST_SR_CERT_VRFY_B,\\r\\n-1,\\r\\n514,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->session->peer != NULL)\\r\\n{\\r\\npeer=s->session->peer;\\r\\npkey=X509_get_pubkey(peer);\\r\\ntype=X509_certificate_type(peer,pkey);\\r\\n}\\r\\nelse\\r\\n{\\r\\npeer=NULL;\\r\\npkey=NULL;\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nif ((peer != NULL) && (type | EVP_PKT_SIGN))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif (peer == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(type & EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->change_cipher_spec)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\np=(unsigned char *)s->init_msg;\\r\\nn2s(p,i);\\r\\nn-=2;\\r\\nif (i > n)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\nj=EVP_PKEY_size(pkey);\\r\\nif ((i > j) || (n > j) || (n <= 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\ni=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\\r\\nMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i,\\r\\npkey->pkey.rsa);\\r\\nif (i < 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\\r\\ngoto f_err;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nj=DSA_verify(pkey->save_type,\\r\\n&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\\r\\nif (j <= 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (pkey->type == EVP_PKEY_EC)\\r\\n{\\r\\nj=ECDSA_verify(pkey->save_type,\\r\\n&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\\r\\nif (j <= 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\\r\\nSSL_R_BAD_ECDSA_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\\r\\nal=SSL_AD_UNSUPPORTED_CERTIFICATE;\\r\\ngoto f_err;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_get_client_certificate(SSL *s)\\r\\n{\\r\\nint i,ok,al,ret= -1;\\r\\nX509 *x=NULL;\\r\\nunsigned long l,nc,llen,n;\\r\\nconst unsigned char *p,*q;\\r\\nunsigned char *d;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nn=s->method->ssl_get_message(s,\\r\\nSSL3_ST_SR_CERT_A,\\r\\nSSL3_ST_SR_CERT_B,\\r\\n-1,\\r\\ns->max_cert_list,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE)\\r\\n{\\r\\nif ( (s->verify_mode & SSL_VERIFY_PEER) &&\\r\\n(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\ngoto f_err;\\r\\n}\\r\\nif ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_WRONG_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\np=d=(unsigned char *)s->init_msg;\\r\\nif ((sk=sk_X509_new_null()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2l3(p,llen);\\r\\nif (llen+3 != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2l3(p,l);\\r\\nif ((l+nc+3) > llen)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nq=p;\\r\\nx=d2i_X509(NULL,&p,l);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (p != (q+l))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!sk_X509_push(sk,x))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nx=NULL;\\r\\nnc+=l+3;\\r\\n}\\r\\nif (sk_X509_num(sk) <= 0)\\r\\n{\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATES_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\nelse if ((s->verify_mode & SSL_VERIFY_PEER) &&\\r\\n(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif (!i)\\r\\n{\\r\\nal=ssl_verify_alarm_type(s->verify_result);\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATE_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\ns->session->peer=sk_X509_shift(sk);\\r\\ns->session->verify_result = s->verify_result;\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\ns->session->sess_cert = ssl_sess_cert_new();\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (s->session->sess_cert->cert_chain != NULL)\\r\\nsk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);\\r\\ns->session->sess_cert->cert_chain=sk;\\r\\nsk=NULL;\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (sk != NULL) sk_X509_pop_free(sk,X509_free);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_send_server_certificate(SSL *s)\\r\\n{\\r\\nunsigned long l;\\r\\nX509 *x;\\r\\nif (s->state == SSL3_ST_SW_CERT_A)\\r\\n{\\r\\nx=ssl_get_server_send_cert(s);\\r\\nif (x == NULL &&\\r\\n(s->s3->tmp.new_cipher->algorithms\\r\\n& (SSL_MKEY_MASK|SSL_AUTH_MASK))\\r\\n!= (SSL_aKRB5|SSL_kKRB5))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,ERR_R_INTERNAL_ERROR);\\r\\nreturn(0);\\r\\n}\\r\\nl=ssl3_output_cert_chain(s,x);\\r\\ns->state=SSL3_ST_SW_CERT_B;\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nstatic int nid2curve_id(int nid)\\r\\n{\\r\\nswitch (nid) {\\r\\ncase NID_sect163k1:\\r\\nreturn 1;\\r\\ncase NID_sect163r1:\\r\\nreturn 2;\\r\\ncase NID_sect163r2:\\r\\nreturn 3;\\r\\ncase NID_sect193r1:\\r\\nreturn 4;\\r\\ncase NID_sect193r2:\\r\\nreturn 5;\\r\\ncase NID_sect233k1:\\r\\nreturn 6;\\r\\ncase NID_sect233r1:\\r\\nreturn 7;\\r\\ncase NID_sect239k1:\\r\\nreturn 8;\\r\\ncase NID_sect283k1:\\r\\nreturn 9;\\r\\ncase NID_sect283r1:\\r\\nreturn 10;\\r\\ncase NID_sect409k1:\\r\\nreturn 11;\\r\\ncase NID_sect409r1:\\r\\nreturn 12;\\r\\ncase NID_sect571k1:\\r\\nreturn 13;\\r\\ncase NID_sect571r1:\\r\\nreturn 14;\\r\\ncase NID_secp160k1:\\r\\nreturn 15;\\r\\ncase NID_secp160r1:\\r\\nreturn 16;\\r\\ncase NID_secp160r2:\\r\\nreturn 17;\\r\\ncase NID_secp192k1:\\r\\nreturn 18;\\r\\ncase NID_X9_62_prime192v1:\\r\\nreturn 19;\\r\\ncase NID_secp224k1:\\r\\nreturn 20;\\r\\ncase NID_secp224r1:\\r\\nreturn 21;\\r\\ncase NID_secp256k1:\\r\\nreturn 22;\\r\\ncase NID_X9_62_prime256v1:\\r\\nreturn 23;\\r\\ncase NID_secp384r1:\\r\\nreturn 24;\\r\\ncase NID_secp521r1:\\r\\nreturn 25;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_v3err_c", "target": 0, "func": "void ERR_load_X509V3_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,X509V3_str_functs);\\r\\nERR_load_strings(0,X509V3_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_cnf_save_c", "target": 0, "func": "main()\\r\\n{\\r\\nLHASH *conf;\\r\\nlong l;\\r\\nconf=CONF_load(NULL,\"../../apps/openssl.cnf\",&l);\\r\\nif (conf == NULL)\\r\\n{\\r\\nfprintf(stderr,\"error loading config, line %ld\\n\",l);\\r\\nexit(1);\\r\\n}\\r\\nlh_doall(conf,LHASH_DOALL_FN(print_conf));\\r\\n}\\r\\nstatic void print_conf(CONF_VALUE *cv)\\r\\n{\\r\\nint i;\\r\\nCONF_VALUE *v;\\r\\nchar *section;\\r\\nchar *name;\\r\\nchar *value;\\r\\nSTACK *s;\\r\\nif (cv->name != NULL) return;\\r\\nprintf(\"[ %s ]\\n\",cv->section);\\r\\ns=(STACK *)cv->value;\\r\\nfor (i=0; i<sk_num(s); i++)\\r\\n{\\r\\nv=(CONF_VALUE *)sk_value(s,i);\\r\\nsection=(v->section == NULL)?\"None\":v->section;\\r\\nname=(v->name == NULL)?\"None\":v->name;\\r\\nvalue=(v->value == NULL)?\"None\":v->value;\\r\\nprintf(\"%s=%s\\n\",name,value);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_ubsec_err_c", "target": 0, "func": "static void ERR_load_UBSEC_strings(void)\\r\\n{\\r\\nif (UBSEC_lib_error_code == 0)\\r\\nUBSEC_lib_error_code=ERR_get_next_error_library();\\r\\nif (UBSEC_error_init)\\r\\n{\\r\\nUBSEC_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(UBSEC_lib_error_code,UBSEC_str_functs);\\r\\nERR_load_strings(UBSEC_lib_error_code,UBSEC_str_reasons);\\r\\n#endif\\r\\n#ifdef UBSEC_LIB_NAME\\r\\nUBSEC_lib_name->error = ERR_PACK(UBSEC_lib_error_code,0,0);\\r\\nERR_load_strings(0,UBSEC_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_UBSEC_strings(void)\\r\\n{\\r\\nif (UBSEC_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(UBSEC_lib_error_code,UBSEC_str_functs);\\r\\nERR_unload_strings(UBSEC_lib_error_code,UBSEC_str_reasons);\\r\\n#endif\\r\\n#ifdef UBSEC_LIB_NAME\\r\\nERR_unload_strings(0,UBSEC_lib_name);\\r\\n#endif\\r\\nUBSEC_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_UBSEC_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (UBSEC_lib_error_code == 0)\\r\\nUBSEC_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(UBSEC_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_example2_c", "target": 0, "func": "int main()\\r\\n{\\r\\nchar *ct = \"This the clear text\";\\r\\nchar *buf;\\r\\nchar *buf2;\\r\\nEVP_PKEY *pubKey;\\r\\nEVP_PKEY *privKey;\\r\\nint len;\\r\\nERR_load_crypto_strings();\\r\\nprivKey = ReadPrivateKey(PRIVFILE);\\r\\nif (!privKey)\\r\\n{\\r\\nERR_print_errors_fp (stderr);\\r\\nexit (1);\\r\\n}\\r\\npubKey = ReadPublicKey(PUBFILE);\\r\\nif(!pubKey)\\r\\n{\\r\\nEVP_PKEY_free(privKey);\\r\\nfprintf(stderr,\"Error: can't load public key\");\\r\\nexit(1);\\r\\n}\\r\\nbuf = malloc(EVP_PKEY_size(pubKey));\\r\\nbuf2 = malloc(EVP_PKEY_size(pubKey));\\r\\nlen = RSA_public_encrypt(strlen(ct)+1, ct, buf, pubKey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nif (len != EVP_PKEY_size(pubKey))\\r\\n{\\r\\nfprintf(stderr,\"Error: ciphertext should match length of key\\n\");\\r\\nexit(1);\\r\\n}\\r\\nRSA_private_decrypt(len, buf, buf2, privKey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nprintf(\"%s\\n\", buf2);\\r\\nEVP_PKEY_free(privKey);\\r\\nEVP_PKEY_free(pubKey);\\r\\nfree(buf);\\r\\nfree(buf2);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_all_c", "target": 0, "func": "int X509_verify(X509 *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\\r\\na->signature,a->cert_info,r));\\r\\n}\\r\\nint X509_REQ_verify(X509_REQ *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn( ASN1_item_verify(ASN1_ITEM_rptr(X509_REQ_INFO),\\r\\na->sig_alg,a->signature,a->req_info,r));\\r\\n}\\r\\nint X509_CRL_verify(X509_CRL *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CRL_INFO),\\r\\na->sig_alg, a->signature,a->crl,r));\\r\\n}\\r\\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_item_verify(ASN1_ITEM_rptr(NETSCAPE_SPKAC),\\r\\na->sig_algor,a->signature,a->spkac,r));\\r\\n}\\r\\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_item_sign(ASN1_ITEM_rptr(X509_CINF), x->cert_info->signature,\\r\\nx->sig_alg, x->signature, x->cert_info,pkey,md));\\r\\n}\\r\\nint X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_item_sign(ASN1_ITEM_rptr(X509_REQ_INFO),x->sig_alg, NULL,\\r\\nx->signature, x->req_info,pkey,md));\\r\\n}\\r\\nint X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nx->crl->enc.modified = 1;\\r\\nreturn(ASN1_item_sign(ASN1_ITEM_rptr(X509_CRL_INFO),x->crl->sig_alg,\\r\\nx->sig_alg, x->signature, x->crl,pkey,md));\\r\\n}\\r\\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_item_sign(ASN1_ITEM_rptr(NETSCAPE_SPKAC), x->sig_algor,NULL,\\r\\nx->signature, x->spkac,pkey,md));\\r\\n}\\r\\nX509 *d2i_X509_fp(FILE *fp, X509 **x509)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509), fp, x509);\\r\\n}\\r\\nint i2d_X509_fp(FILE *fp, X509 *x509)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509), fp, x509);\\r\\n}\\r\\nX509 *d2i_X509_bio(BIO *bp, X509 **x509)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509), bp, x509);\\r\\n}\\r\\nint i2d_X509_bio(BIO *bp, X509 *x509)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509_CRL), fp, crl);\\r\\n}\\r\\nint i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509_CRL), fp, crl);\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509_CRL), bp, crl);\\r\\n}\\r\\nint i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509_CRL), bp, crl);\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(PKCS7), fp, p7);\\r\\n}\\r\\nint i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(PKCS7), fp, p7);\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(PKCS7), bp, p7);\\r\\n}\\r\\nint i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(PKCS7), bp, p7);\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509_REQ), fp, req);\\r\\n}\\r\\nint i2d_X509_REQ_fp(FILE *fp, X509_REQ *req)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509_REQ), fp, req);\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509_REQ), bp, req);\\r\\n}\\r\\nint i2d_X509_REQ_bio(BIO *bp, X509_REQ *req)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509_REQ), bp, req);\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(RSAPrivateKey), fp, rsa);\\r\\n}\\r\\nint i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(RSAPrivateKey), fp, rsa);\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(RSAPublicKey), fp, rsa);\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp((void *(*)(void))\\r\\nRSA_new,(D2I_OF(void))d2i_RSA_PUBKEY, fp,\\r\\n(void **)rsa);\\r\\n}\\r\\nint i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(RSAPublicKey), fp, rsa);\\r\\n}\\r\\nint i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp((I2D_OF(void))i2d_RSA_PUBKEY,fp,rsa);\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(RSAPrivateKey), bp, rsa);\\r\\n}\\r\\nint i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(RSAPrivateKey), bp, rsa);\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(RSAPublicKey), bp, rsa);\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(RSA,RSA_new,d2i_RSA_PUBKEY,bp,rsa);\\r\\n}\\r\\nint i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(RSAPublicKey), bp, rsa);\\r\\n}\\r\\nint i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(RSA,i2d_RSA_PUBKEY,bp,rsa);\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(DSA,DSA_new,d2i_DSAPrivateKey,fp,dsa);\\r\\n}\\r\\nint i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(DSA,i2d_DSAPrivateKey,fp,dsa);\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(DSA,DSA_new,d2i_DSA_PUBKEY,fp,dsa);\\r\\n}\\r\\nint i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(DSA,i2d_DSA_PUBKEY,fp,dsa);\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(DSA,DSA_new,d2i_DSAPrivateKey,bp,dsa\\r\\n);\\r\\n}\\r\\nint i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(DSA,i2d_DSAPrivateKey,bp,dsa);\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(DSA,DSA_new,d2i_DSA_PUBKEY,bp,dsa);\\r\\n}\\r\\nint i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(DSA,i2d_DSA_PUBKEY,bp,dsa);\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EC_KEY,EC_KEY_new,d2i_EC_PUBKEY,fp,eckey);\\r\\n}\\r\\nint i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EC_KEY,i2d_EC_PUBKEY,fp,eckey);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EC_KEY,EC_KEY_new,d2i_ECPrivateKey,fp,eckey);\\r\\n}\\r\\nint i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EC_KEY,i2d_ECPrivateKey,fp,eckey);\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EC_KEY,EC_KEY_new,d2i_EC_PUBKEY,bp,eckey);\\r\\n}\\r\\nint i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *ecdsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EC_KEY,i2d_EC_PUBKEY,bp,ecdsa);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EC_KEY,EC_KEY_new,d2i_ECPrivateKey,bp,eckey);\\r\\n}\\r\\nint i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EC_KEY,i2d_ECPrivateKey,bp,eckey);\\r\\n}\\r\\nint X509_pubkey_digest(const X509 *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nASN1_BIT_STRING *key;\\r\\nkey = X509_get0_pubkey_bitstr(data);\\r\\nif(!key) return 0;\\r\\nreturn EVP_Digest(key->data, key->length, md, len, type, NULL);\\r\\n}\\r\\nint X509_digest(const X509 *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_item_digest(ASN1_ITEM_rptr(X509),type,(char *)data,md,len));\\r\\n}\\r\\nint X509_CRL_digest(const X509_CRL *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_item_digest(ASN1_ITEM_rptr(X509_CRL),type,(char *)data,md,len));\\r\\n}\\r\\nint X509_REQ_digest(const X509_REQ *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_item_digest(ASN1_ITEM_rptr(X509_REQ),type,(char *)data,md,len));\\r\\n}\\r\\nint X509_NAME_digest(const X509_NAME *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_item_digest(ASN1_ITEM_rptr(X509_NAME),type,(char *)data,md,len));\\r\\n}\\r\\nint PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data, const EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nreturn(ASN1_item_digest(ASN1_ITEM_rptr(PKCS7_ISSUER_AND_SERIAL),type,\\r\\n(char *)data,md,len));\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(X509_SIG,X509_SIG_new,d2i_X509_SIG,fp,p8);\\r\\n}\\r\\nint i2d_PKCS8_fp(FILE *fp, X509_SIG *p8)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(X509_SIG,i2d_X509_SIG,fp,p8);\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(X509_SIG,X509_SIG_new,d2i_X509_SIG,bp,p8);\\r\\n}\\r\\nint i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(X509_SIG,i2d_X509_SIG,bp,p8);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(PKCS8_PRIV_KEY_INFO,PKCS8_PRIV_KEY_INFO_new,\\r\\nd2i_PKCS8_PRIV_KEY_INFO,fp,p8inf);\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(PKCS8_PRIV_KEY_INFO,i2d_PKCS8_PRIV_KEY_INFO,fp,\\r\\np8inf);\\r\\n}\\r\\nint i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nint ret;\\r\\np8inf = EVP_PKEY2PKCS8(key);\\r\\nif(!p8inf) return 0;\\r\\nret = i2d_PKCS8_PRIV_KEY_INFO_fp(fp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EVP_PKEY,i2d_PrivateKey,fp,pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EVP_PKEY,EVP_PKEY_new,d2i_AutoPrivateKey,fp,a);\\r\\n}\\r\\nint i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EVP_PKEY,i2d_PUBKEY,fp,pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EVP_PKEY,EVP_PKEY_new,d2i_PUBKEY,fp,a);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(PKCS8_PRIV_KEY_INFO,PKCS8_PRIV_KEY_INFO_new,\\r\\nd2i_PKCS8_PRIV_KEY_INFO,bp,p8inf);\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(PKCS8_PRIV_KEY_INFO,i2d_PKCS8_PRIV_KEY_INFO,bp,\\r\\np8inf);\\r\\n}\\r\\nint i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nint ret;\\r\\np8inf = EVP_PKEY2PKCS8(key);\\r\\nif(!p8inf) return 0;\\r\\nret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EVP_PKEY,i2d_PrivateKey,bp,pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EVP_PKEY,EVP_PKEY_new,d2i_AutoPrivateKey,bp,a);\\r\\n}\\r\\nint i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EVP_PKEY,i2d_PUBKEY,bp,pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EVP_PKEY,EVP_PKEY_new,d2i_PUBKEY,bp,a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_cipher_c", "target": 0, "func": "void ENGINE_unregister_ciphers(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&cipher_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_ciphers(void)\\r\\n{\\r\\nengine_table_cleanup(&cipher_table);\\r\\n}\\r\\nint ENGINE_register_ciphers(ENGINE *e)\\r\\n{\\r\\nif(e->ciphers)\\r\\n{\\r\\nconst int *nids;\\r\\nint num_nids = e->ciphers(e, NULL, &nids, 0);\\r\\nif(num_nids > 0)\\r\\nreturn engine_table_register(&cipher_table,\\r\\nengine_unregister_all_ciphers, e, nids,\\r\\nnum_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_ciphers()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_ciphers(e);\\r\\n}\\r\\nint ENGINE_set_default_ciphers(ENGINE *e)\\r\\n{\\r\\nif(e->ciphers)\\r\\n{\\r\\nconst int *nids;\\r\\nint num_nids = e->ciphers(e, NULL, &nids, 0);\\r\\nif(num_nids > 0)\\r\\nreturn engine_table_register(&cipher_table,\\r\\nengine_unregister_all_ciphers, e, nids,\\r\\nnum_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_cipher_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&cipher_table, nid);\\r\\n}\\r\\nconst EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid)\\r\\n{\\r\\nconst EVP_CIPHER *ret;\\r\\nENGINE_CIPHERS_PTR fn = ENGINE_get_ciphers(e);\\r\\nif(!fn || !fn(e, &ret, NULL, nid))\\r\\n{\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_CIPHER,\\r\\nENGINE_R_UNIMPLEMENTED_CIPHER);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e)\\r\\n{\\r\\nreturn e->ciphers;\\r\\n}\\r\\nint ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f)\\r\\n{\\r\\ne->ciphers = f;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_LPdir_unix_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nstruct dirent *direntry = NULL;\\r\\nif (ctx == NULL || directory == NULL)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL)\\r\\n{\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL)\\r\\n{\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\n(*ctx)->dir = opendir(directory);\\r\\nif ((*ctx)->dir == NULL)\\r\\n{\\r\\nint save_errno = errno;\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = save_errno;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\ndirentry = readdir((*ctx)->dir);\\r\\nif (direntry == NULL)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstrncpy((*ctx)->entry_name, direntry->d_name, sizeof((*ctx)->entry_name) - 1);\\r\\n(*ctx)->entry_name[sizeof((*ctx)->entry_name) - 1] = '\\0';\\r\\nreturn (*ctx)->entry_name;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL)\\r\\n{\\r\\nint ret = closedir((*ctx)->dir);\\r\\nfree(*ctx);\\r\\nswitch (ret)\\r\\n{\\r\\ncase 0:\\r\\nreturn 1;\\r\\ncase -1:\\r\\nreturn 0;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_sqrt_c", "target": 0, "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret = in;\\r\\nint err = 1;\\r\\nint r;\\r\\nBIGNUM *A, *b, *q, *t, *x, *y;\\r\\nint e, i, j;\\r\\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1))\\r\\n{\\r\\nif (BN_abs_is_word(p, 2))\\r\\n{\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (!BN_set_word(ret, BN_is_bit_set(a, 0)))\\r\\n{\\r\\nBN_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (BN_is_zero(a) || BN_is_one(a))\\r\\n{\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (!BN_set_word(ret, BN_is_one(a)))\\r\\n{\\r\\nBN_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL) goto end;\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL) goto end;\\r\\nif (!BN_nnmod(A, a, p, ctx)) goto end;\\r\\ne = 1;\\r\\nwhile (!BN_is_bit_set(p, e))\\r\\ne++;\\r\\nif (e == 1)\\r\\n{\\r\\nif (!BN_rshift(q, p, 2)) goto end;\\r\\nq->neg = 0;\\r\\nif (!BN_add_word(q, 1)) goto end;\\r\\nif (!BN_mod_exp(ret, A, q, p, ctx)) goto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\nif (e == 2)\\r\\n{\\r\\nif (!BN_mod_lshift1_quick(t, A, p)) goto end;\\r\\nif (!BN_rshift(q, p, 3)) goto end;\\r\\nq->neg = 0;\\r\\nif (!BN_mod_exp(b, t, q, p, ctx)) goto end;\\r\\nif (!BN_mod_sqr(y, b, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(t, t, y, p, ctx)) goto end;\\r\\nif (!BN_sub_word(t, 1)) goto end;\\r\\nif (!BN_mod_mul(x, A, b, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(x, x, t, p, ctx)) goto end;\\r\\nif (!BN_copy(ret, x)) goto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\nif (!BN_copy(q, p)) goto end;\\r\\nq->neg = 0;\\r\\ni = 2;\\r\\ndo\\r\\n{\\r\\nif (i < 22)\\r\\n{\\r\\nif (!BN_set_word(y, i)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;\\r\\nif (BN_ucmp(y, p) >= 0)\\r\\n{\\r\\nif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;\\r\\n}\\r\\nif (BN_is_zero(y))\\r\\nif (!BN_set_word(y, i)) goto end;\\r\\n}\\r\\nr = BN_kronecker(y, q, ctx);\\r\\nif (r < -1) goto end;\\r\\nif (r == 0)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nwhile (r == 1 && ++i < 82);\\r\\nif (r != -1)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_rshift(q, q, e)) goto end;\\r\\nif (!BN_mod_exp(y, y, q, p, ctx)) goto end;\\r\\nif (BN_is_one(y))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_rshift1(t, q)) goto end;\\r\\nif (BN_is_zero(t))\\r\\n{\\r\\nif (!BN_nnmod(t, A, p, ctx)) goto end;\\r\\nif (BN_is_zero(t))\\r\\n{\\r\\nBN_zero(ret);\\r\\nerr = 0;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\nif (!BN_one(x)) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_exp(x, A, t, p, ctx)) goto end;\\r\\nif (BN_is_zero(x))\\r\\n{\\r\\nBN_zero(ret);\\r\\nerr = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_sqr(b, x, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(b, b, A, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(x, x, A, p, ctx)) goto end;\\r\\nwhile (1)\\r\\n{\\r\\nif (BN_is_one(b))\\r\\n{\\r\\nif (!BN_copy(ret, x)) goto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\ni = 1;\\r\\nif (!BN_mod_sqr(t, b, p, ctx)) goto end;\\r\\nwhile (!BN_is_one(t))\\r\\n{\\r\\ni++;\\r\\nif (i == e)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_mod_mul(t, t, t, p, ctx)) goto end;\\r\\n}\\r\\nif (!BN_copy(t, y)) goto end;\\r\\nfor (j = e - i - 1; j > 0; j--)\\r\\n{\\r\\nif (!BN_mod_sqr(t, t, p, ctx)) goto end;\\r\\n}\\r\\nif (!BN_mod_mul(y, t, t, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(x, x, t, p, ctx)) goto end;\\r\\nif (!BN_mod_mul(b, b, y, p, ctx)) goto end;\\r\\ne = i;\\r\\n}\\r\\nvrfy:\\r\\nif (!err)\\r\\n{\\r\\nif (!BN_mod_sqr(x, ret, p, ctx))\\r\\nerr = 1;\\r\\nif (!err && 0 != BN_cmp(x, A))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\\r\\nerr = 1;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (err)\\r\\n{\\r\\nif (ret != NULL && ret != in)\\r\\n{\\r\\nBN_clear_free(ret);\\r\\n}\\r\\nret = NULL;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_err_c", "target": 0, "func": "void ERR_load_BN_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,BN_str_functs);\\r\\nERR_load_strings(0,BN_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bn_blind_c", "target": 0, "func": "BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)\\r\\n{\\r\\nBN_BLINDING *ret=NULL;\\r\\nbn_check_top(mod);\\r\\nif ((ret=(BN_BLINDING *)OPENSSL_malloc(sizeof(BN_BLINDING))) == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(BN_BLINDING));\\r\\nif (A != NULL)\\r\\n{\\r\\nif ((ret->A = BN_dup(A)) == NULL) goto err;\\r\\n}\\r\\nif (Ai != NULL)\\r\\n{\\r\\nif ((ret->Ai = BN_dup(Ai)) == NULL) goto err;\\r\\n}\\r\\nret->mod = mod;\\r\\nret->counter = BN_BLINDING_COUNTER;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL) BN_BLINDING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid BN_BLINDING_free(BN_BLINDING *r)\\r\\n{\\r\\nif(r == NULL)\\r\\nreturn;\\r\\nif (r->A != NULL) BN_free(r->A );\\r\\nif (r->Ai != NULL) BN_free(r->Ai);\\r\\nif (r->e != NULL) BN_free(r->e );\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_UPDATE,BN_R_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nif (--(b->counter) == 0 && b->e != NULL &&\\r\\n!(b->flags & BN_BLINDING_NO_RECREATE))\\r\\n{\\r\\nif (!BN_BLINDING_create_param(b, NULL, NULL, ctx, NULL, NULL))\\r\\ngoto err;\\r\\n}\\r\\nelse if (!(b->flags & BN_BLINDING_NO_UPDATE))\\r\\n{\\r\\nif (!BN_mod_mul(b->A,b->A,b->A,b->mod,ctx)) goto err;\\r\\nif (!BN_mod_mul(b->Ai,b->Ai,b->Ai,b->mod,ctx)) goto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (b->counter == 0)\\r\\nb->counter = BN_BLINDING_COUNTER;\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_BLINDING_convert_ex(n, NULL, b, ctx);\\r\\n}\\r\\nint BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 1;\\r\\nbn_check_top(n);\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_CONVERT_EX,BN_R_NOT_INITIALIZED);\\r\\nreturn(0);\\r\\n}\\r\\nif (r != NULL)\\r\\n{\\r\\nif (!BN_copy(r, b->Ai)) ret=0;\\r\\n}\\r\\nif (!BN_mod_mul(n,n,b->A,b->mod,ctx)) ret=0;\\r\\nreturn ret;\\r\\n}\\r\\nint BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_BLINDING_invert_ex(n, NULL, b, ctx);\\r\\n}\\r\\nint BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(n);\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_INVERT_EX,BN_R_NOT_INITIALIZED);\\r\\nreturn(0);\\r\\n}\\r\\nif (r != NULL)\\r\\nret = BN_mod_mul(n, n, r, b->mod, ctx);\\r\\nelse\\r\\nret = BN_mod_mul(n, n, b->Ai, b->mod, ctx);\\r\\nif (ret >= 0)\\r\\n{\\r\\nif (!BN_BLINDING_update(b,ctx))\\r\\nreturn(0);\\r\\n}\\r\\nbn_check_top(n);\\r\\nreturn(ret);\\r\\n}\\r\\nunsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *b)\\r\\n{\\r\\nreturn b->thread_id;\\r\\n}\\r\\nvoid BN_BLINDING_set_thread_id(BN_BLINDING *b, unsigned long n)\\r\\n{\\r\\nb->thread_id = n;\\r\\n}\\r\\nunsigned long BN_BLINDING_get_flags(const BN_BLINDING *b)\\r\\n{\\r\\nreturn b->flags;\\r\\n}\\r\\nvoid BN_BLINDING_set_flags(BN_BLINDING *b, unsigned long flags)\\r\\n{\\r\\nb->flags = flags;\\r\\n}\\r\\nBN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\\r\\nconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\\r\\nint (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nint retry_counter = 32;\\r\\nBN_BLINDING *ret = NULL;\\r\\nif (b == NULL)\\r\\nret = BN_BLINDING_new(NULL, NULL, m);\\r\\nelse\\r\\nret = b;\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (ret->A == NULL && (ret->A = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (ret->Ai == NULL && (ret->Ai = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (e != NULL)\\r\\n{\\r\\nif (ret->e != NULL)\\r\\nBN_free(ret->e);\\r\\nret->e = BN_dup(e);\\r\\n}\\r\\nif (ret->e == NULL)\\r\\ngoto err;\\r\\nif (bn_mod_exp != NULL)\\r\\nret->bn_mod_exp = bn_mod_exp;\\r\\nif (m_ctx != NULL)\\r\\nret->m_ctx = m_ctx;\\r\\ndo {\\r\\nif (!BN_rand_range(ret->A, ret->mod)) goto err;\\r\\nif (BN_mod_inverse(ret->Ai, ret->A, ret->mod, ctx) == NULL)\\r\\n{\\r\\nunsigned long error = ERR_peek_last_error();\\r\\nif (ERR_GET_REASON(error) == BN_R_NO_INVERSE)\\r\\n{\\r\\nif (retry_counter-- == 0)\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_CREATE_PARAM,\\r\\nBN_R_TOO_MANY_ITERATIONS);\\r\\ngoto err;\\r\\n}\\r\\nERR_clear_error();\\r\\n}\\r\\nelse\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n} while (1);\\r\\nif (ret->bn_mod_exp != NULL && ret->m_ctx != NULL)\\r\\n{\\r\\nif (!ret->bn_mod_exp(ret->A, ret->A, ret->e, ret->mod, ctx, ret->m_ctx))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mod_exp(ret->A, ret->A, ret->e, ret->mod, ctx))\\r\\ngoto err;\\r\\n}\\r\\nreturn ret;\\r\\nerr:\\r\\nif (b == NULL && ret != NULL)\\r\\n{\\r\\nBN_BLINDING_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_set_c", "target": 0, "func": "int X509_set_version(X509 *x, long version)\\r\\n{\\r\\nif (x == NULL) return(0);\\r\\nif (x->cert_info->version == NULL)\\r\\n{\\r\\nif ((x->cert_info->version=M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ASN1_INTEGER_set(x->cert_info->version,version));\\r\\n}\\r\\nint X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->cert_info->serialNumber;\\r\\nif (in != serial)\\r\\n{\\r\\nin=M_ASN1_INTEGER_dup(serial);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_INTEGER_free(x->cert_info->serialNumber);\\r\\nx->cert_info->serialNumber=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_issuer_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->cert_info->issuer,name));\\r\\n}\\r\\nint X509_set_subject_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->cert_info->subject,name));\\r\\n}\\r\\nint X509_set_notBefore(X509 *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL)) return(0);\\r\\nin=x->cert_info->validity->notBefore;\\r\\nif (in != tm)\\r\\n{\\r\\nin=M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_TIME_free(x->cert_info->validity->notBefore);\\r\\nx->cert_info->validity->notBefore=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_notAfter(X509 *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL)) return(0);\\r\\nin=x->cert_info->validity->notAfter;\\r\\nif (in != tm)\\r\\n{\\r\\nin=M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nM_ASN1_TIME_free(x->cert_info->validity->notAfter);\\r\\nx->cert_info->validity->notAfter=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_pubkey(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_PUBKEY_set(&(x->cert_info->key),pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rc2cfb64_c", "target": 0, "func": "void RC2_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC2_KEY *schedule, unsigned char *ivec,\\r\\nint *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i_ecb_c", "target": 0, "func": "const char *idea_options(void)\\r\\n{\\r\\nif (sizeof(short) != sizeof(IDEA_INT))\\r\\nreturn(\"idea(int)\");\\r\\nelse\\r\\nreturn(\"idea(short)\");\\r\\n}\\r\\nvoid idea_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nIDEA_KEY_SCHEDULE *ks)\\r\\n{\\r\\nunsigned long l0,l1,d[2];\\r\\nn2l(in,l0); d[0]=l0;\\r\\nn2l(in,l1); d[1]=l1;\\r\\nidea_encrypt(d,ks);\\r\\nl0=d[0]; l2n(l0,out);\\r\\nl1=d[1]; l2n(l1,out);\\r\\nl0=l1=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tasn_fre_c", "target": 0, "func": "void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)\\r\\n{\\r\\nasn1_item_combine_free(&val, it, 0);\\r\\n}\\r\\nvoid ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nasn1_item_combine_free(pval, it, 0);\\r\\n}\\r\\nstatic void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int combine)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL, *seqtt;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nint i;\\r\\nif (!pval)\\r\\nreturn;\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\\r\\nreturn;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse\\r\\nasn1_cb = 0;\\r\\nswitch(it->itype)\\r\\n{\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nASN1_template_free(pval, it->templates);\\r\\nelse\\r\\nASN1_primitive_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nASN1_primitive_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb)\\r\\n{\\r\\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it);\\r\\nif (i == 2)\\r\\nreturn;\\r\\n}\\r\\ni = asn1_get_choice_selector(pval, it);\\r\\nif (asn1_cb)\\r\\nasn1_cb(ASN1_OP_FREE_PRE, pval, it);\\r\\nif ((i >= 0) && (i < it->tcount))\\r\\n{\\r\\nASN1_VALUE **pchval;\\r\\ntt = it->templates + i;\\r\\npchval = asn1_get_field_ptr(pval, tt);\\r\\nASN1_template_free(pchval, tt);\\r\\n}\\r\\nif (asn1_cb)\\r\\nasn1_cb(ASN1_OP_FREE_POST, pval, it);\\r\\nif (!combine)\\r\\n{\\r\\nOPENSSL_free(*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (cf && cf->asn1_free)\\r\\ncf->asn1_free(*pval);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_free)\\r\\nef->asn1_ex_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\nif (asn1_do_lock(pval, -1, it) > 0)\\r\\nreturn;\\r\\nif (asn1_cb)\\r\\n{\\r\\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it);\\r\\nif (i == 2)\\r\\nreturn;\\r\\n}\\r\\nasn1_enc_free(pval, it);\\r\\ntt = it->templates + it->tcount - 1;\\r\\nfor (i = 0; i < it->tcount; tt--, i++)\\r\\n{\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 0);\\r\\nif (!seqtt)\\r\\ncontinue;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nASN1_template_free(pseqval, seqtt);\\r\\n}\\r\\nif (asn1_cb)\\r\\nasn1_cb(ASN1_OP_FREE_POST, pval, it);\\r\\nif (!combine)\\r\\n{\\r\\nOPENSSL_free(*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nint i;\\r\\nif (tt->flags & ASN1_TFLG_SK_MASK)\\r\\n{\\r\\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\\r\\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++)\\r\\n{\\r\\nASN1_VALUE *vtmp;\\r\\nvtmp = sk_ASN1_VALUE_value(sk, i);\\r\\nasn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item),\\r\\n0);\\r\\n}\\r\\nsk_ASN1_VALUE_free(sk);\\r\\n*pval = NULL;\\r\\n}\\r\\nelse\\r\\nasn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\\r\\ntt->flags & ASN1_TFLG_COMBINE);\\r\\n}\\r\\nvoid ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint utype;\\r\\nif (it)\\r\\n{\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_free)\\r\\n{\\r\\npf->prim_free(pval, it);\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nif (!it)\\r\\n{\\r\\nASN1_TYPE *typ = (ASN1_TYPE *)*pval;\\r\\nutype = typ->type;\\r\\npval = (ASN1_VALUE **)&typ->value.ptr;\\r\\nif (!*pval)\\r\\nreturn;\\r\\n}\\r\\nelse if (it->itype == ASN1_ITYPE_MSTRING)\\r\\n{\\r\\nutype = -1;\\r\\nif (!*pval)\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\n{\\r\\nutype = it->utype;\\r\\nif ((utype != V_ASN1_BOOLEAN) && !*pval)\\r\\nreturn;\\r\\n}\\r\\nswitch(utype)\\r\\n{\\r\\ncase V_ASN1_OBJECT:\\r\\nASN1_OBJECT_free((ASN1_OBJECT *)*pval);\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (it)\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nelse\\r\\n*(ASN1_BOOLEAN *)pval = -1;\\r\\nreturn;\\r\\ncase V_ASN1_NULL:\\r\\nbreak;\\r\\ncase V_ASN1_ANY:\\r\\nASN1_primitive_free(pval, NULL);\\r\\nOPENSSL_free(*pval);\\r\\nbreak;\\r\\ndefault:\\r\\nASN1_STRING_free((ASN1_STRING *)*pval);\\r\\n*pval = NULL;\\r\\nbreak;\\r\\n}\\r\\n*pval = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_mdc2_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return MDC2_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return MDC2_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return MDC2_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_mdc2(void)\\r\\n{\\r\\nreturn(&mdc2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_buffer_c", "target": 0, "func": "BUF_MEM *BUF_MEM_new(void)\\r\\n{\\r\\nBUF_MEM *ret;\\r\\nret=OPENSSL_malloc(sizeof(BUF_MEM));\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEM_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->max=0;\\r\\nret->data=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BUF_MEM_free(BUF_MEM *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->data != NULL)\\r\\n{\\r\\nmemset(a->data,0,(unsigned int)a->max);\\r\\nOPENSSL_free(a->data);\\r\\n}\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nint BUF_MEM_grow(BUF_MEM *str, int len)\\r\\n{\\r\\nchar *ret;\\r\\nunsigned int n;\\r\\nif (str->length >= len)\\r\\n{\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nif (str->max >= len)\\r\\n{\\r\\nmemset(&str->data[str->length],0,len-str->length);\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nn=(len+3)/3*4;\\r\\nif (str->data == NULL)\\r\\nret=OPENSSL_malloc(n);\\r\\nelse\\r\\nret=OPENSSL_realloc(str->data,n);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEM_GROW,ERR_R_MALLOC_FAILURE);\\r\\nlen=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nstr->data=ret;\\r\\nstr->max=n;\\r\\nmemset(&str->data[str->length],0,len-str->length);\\r\\nstr->length=len;\\r\\n}\\r\\nreturn(len);\\r\\n}\\r\\nint BUF_MEM_grow_clean(BUF_MEM *str, int len)\\r\\n{\\r\\nchar *ret;\\r\\nunsigned int n;\\r\\nif (str->length >= len)\\r\\n{\\r\\nmemset(&str->data[len],0,str->length-len);\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nif (str->max >= len)\\r\\n{\\r\\nmemset(&str->data[str->length],0,len-str->length);\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nn=(len+3)/3*4;\\r\\nif (str->data == NULL)\\r\\nret=OPENSSL_malloc(n);\\r\\nelse\\r\\nret=OPENSSL_realloc_clean(str->data,str->max,n);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEM_GROW_CLEAN,ERR_R_MALLOC_FAILURE);\\r\\nlen=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nstr->data=ret;\\r\\nstr->max=n;\\r\\nmemset(&str->data[str->length],0,len-str->length);\\r\\nstr->length=len;\\r\\n}\\r\\nreturn(len);\\r\\n}\\r\\nchar *BUF_strdup(const char *str)\\r\\n{\\r\\nif (str == NULL) return(NULL);\\r\\nreturn BUF_strndup(str, strlen(str));\\r\\n}\\r\\nchar *BUF_strndup(const char *str, size_t siz)\\r\\n{\\r\\nchar *ret;\\r\\nif (str == NULL) return(NULL);\\r\\nret=OPENSSL_malloc(siz+1);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_STRNDUP,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nBUF_strlcpy(ret,str,siz+1);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *BUF_memdup(const void *data, size_t siz)\\r\\n{\\r\\nvoid *ret;\\r\\nif (data == NULL) return(NULL);\\r\\nret=OPENSSL_malloc(siz);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEMDUP,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn memcpy(ret, data, siz);\\r\\n}\\r\\nsize_t BUF_strlcpy(char *dst, const char *src, size_t size)\\r\\n{\\r\\nsize_t l = 0;\\r\\nfor(; size > 1 && *src; size--)\\r\\n{\\r\\n*dst++ = *src++;\\r\\nl++;\\r\\n}\\r\\nif (size)\\r\\n*dst = '\\0';\\r\\nreturn l + strlen(src);\\r\\n}\\r\\nsize_t BUF_strlcat(char *dst, const char *src, size_t size)\\r\\n{\\r\\nsize_t l = 0;\\r\\nfor(; size > 0 && *dst; size--, dst++)\\r\\nl++;\\r\\nreturn l + BUF_strlcpy(dst, src, size);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_rand_c", "target": 0, "func": "void ENGINE_unregister_RAND(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&rand_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_RAND(void)\\r\\n{\\r\\nengine_table_cleanup(&rand_table);\\r\\n}\\r\\nint ENGINE_register_RAND(ENGINE *e)\\r\\n{\\r\\nif(e->rand_meth)\\r\\nreturn engine_table_register(&rand_table,\\r\\nengine_unregister_all_RAND, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_RAND()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_RAND(e);\\r\\n}\\r\\nint ENGINE_set_default_RAND(ENGINE *e)\\r\\n{\\r\\nif(e->rand_meth)\\r\\nreturn engine_table_register(&rand_table,\\r\\nengine_unregister_all_RAND, e, &dummy_nid, 1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_RAND(void)\\r\\n{\\r\\nreturn engine_table_select(&rand_table, dummy_nid);\\r\\n}\\r\\nconst RAND_METHOD *ENGINE_get_RAND(const ENGINE *e)\\r\\n{\\r\\nreturn e->rand_meth;\\r\\n}\\r\\nint ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth)\\r\\n{\\r\\ne->rand_meth = rand_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bf_ecb_c", "target": 0, "func": "const char *BF_options(void)\\r\\n{\\r\\n#ifdef BF_PTR\\r\\nreturn(\"blowfish(ptr)\");\\r\\n#elif defined(BF_PTR2)\\r\\nreturn(\"blowfish(ptr2)\");\\r\\n#else\\r\\nreturn(\"blowfish(idx)\");\\r\\n#endif\\r\\n}\\r\\nvoid BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst BF_KEY *key, int encrypt)\\r\\n{\\r\\nBF_LONG l,d[2];\\r\\nn2l(in,l); d[0]=l;\\r\\nn2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nBF_encrypt(d,key);\\r\\nelse\\r\\nBF_decrypt(d,key);\\r\\nl=d[0]; l2n(l,out);\\r\\nl=d[1]; l2n(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_evp_key_c", "target": 0, "func": "void EVP_set_pw_prompt(const char *prompt)\\r\\n{\\r\\nif (prompt == NULL)\\r\\nprompt_string[0]='\\0';\\r\\nelse\\r\\n{\\r\\nstrncpy(prompt_string,prompt,79);\\r\\nprompt_string[79]='\\0';\\r\\n}\\r\\n}\\r\\nchar *EVP_get_pw_prompt(void)\\r\\n{\\r\\nif (prompt_string[0] == '\\0')\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(prompt_string);\\r\\n}\\r\\nint EVP_read_pw_string(char *buf, int len, const char *prompt, int verify)\\r\\n{\\r\\nint ret;\\r\\nchar buff[BUFSIZ];\\r\\nUI *ui;\\r\\nif ((prompt == NULL) && (prompt_string[0] != '\\0'))\\r\\nprompt=prompt_string;\\r\\nui = UI_new();\\r\\nUI_add_input_string(ui,prompt,0,buf,0,(len>=BUFSIZ)?BUFSIZ-1:len);\\r\\nif (verify)\\r\\nUI_add_verify_string(ui,prompt,0,\\r\\nbuff,0,(len>=BUFSIZ)?BUFSIZ-1:len,buf);\\r\\nret = UI_process(ui);\\r\\nUI_free(ui);\\r\\nOPENSSL_cleanse(buff,BUFSIZ);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,\\r\\nconst unsigned char *salt, const unsigned char *data, int datal,\\r\\nint count, unsigned char *key, unsigned char *iv)\\r\\n{\\r\\nEVP_MD_CTX c;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nint niv,nkey,addmd=0;\\r\\nunsigned int mds=0,i;\\r\\nnkey=type->key_len;\\r\\nniv=type->iv_len;\\r\\nOPENSSL_assert(nkey <= EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_assert(niv <= EVP_MAX_IV_LENGTH);\\r\\nif (data == NULL) return(nkey);\\r\\nEVP_MD_CTX_init(&c);\\r\\nfor (;;)\\r\\n{\\r\\nEVP_DigestInit_ex(&c,md, NULL);\\r\\nif (addmd++)\\r\\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\\r\\nEVP_DigestUpdate(&c,data,datal);\\r\\nif (salt != NULL)\\r\\nEVP_DigestUpdate(&c,salt,PKCS5_SALT_LEN);\\r\\nEVP_DigestFinal_ex(&c,&(md_buf[0]),&mds);\\r\\nfor (i=1; i<(unsigned int)count; i++)\\r\\n{\\r\\nEVP_DigestInit_ex(&c,md, NULL);\\r\\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\\r\\nEVP_DigestFinal_ex(&c,&(md_buf[0]),&mds);\\r\\n}\\r\\ni=0;\\r\\nif (nkey)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (nkey == 0) break;\\r\\nif (i == mds) break;\\r\\nif (key != NULL)\\r\\n*(key++)=md_buf[i];\\r\\nnkey--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif (niv && (i != mds))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (niv == 0) break;\\r\\nif (i == mds) break;\\r\\nif (iv != NULL)\\r\\n*(iv++)=md_buf[i];\\r\\nniv--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif ((nkey == 0) && (niv == 0)) break;\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&c);\\r\\nOPENSSL_cleanse(&(md_buf[0]),EVP_MAX_MD_SIZE);\\r\\nreturn(type->key_len);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_pem_pkey_c", "target": 0, "func": "EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nchar *nm=NULL;\\r\\nconst unsigned char *p=NULL;\\r\\nunsigned char *data=NULL;\\r\\nlong len;\\r\\nEVP_PKEY *ret=NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u))\\r\\nreturn NULL;\\r\\np = data;\\r\\nif (strcmp(nm,PEM_STRING_RSA) == 0)\\r\\nret=d2i_PrivateKey(EVP_PKEY_RSA,x,&p,len);\\r\\nelse if (strcmp(nm,PEM_STRING_DSA) == 0)\\r\\nret=d2i_PrivateKey(EVP_PKEY_DSA,x,&p,len);\\r\\nelse if (strcmp(nm,PEM_STRING_ECPRIVATEKEY) == 0)\\r\\nret=d2i_PrivateKey(EVP_PKEY_EC,x,&p,len);\\r\\nelse if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\np8inf=d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);\\r\\nif(!p8inf) goto p8err;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nif(x) {\\r\\nif(*x) EVP_PKEY_free((EVP_PKEY *)*x);\\r\\n*x = ret;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nX509_SIG *p8;\\r\\nint klen;\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\np8 = d2i_X509_SIG(NULL, &p, len);\\r\\nif(!p8) goto p8err;\\r\\nif (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);\\r\\nelse klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,\\r\\nPEM_R_BAD_PASSWORD_READ);\\r\\nX509_SIG_free(p8);\\r\\ngoto err;\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, psbuf, klen);\\r\\nX509_SIG_free(p8);\\r\\nif(!p8inf) goto p8err;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nif(x) {\\r\\nif(*x) EVP_PKEY_free((EVP_PKEY *)*x);\\r\\n*x = ret;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n}\\r\\np8err:\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,ERR_R_ASN1_LIB);\\r\\nerr:\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(data);\\r\\nreturn(ret);\\r\\n}\\r\\nEVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nEVP_PKEY *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_PRIVATEKEY,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_read_bio_PrivateKey(b,x,cb,u);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_randfile_c", "target": 0, "func": "int RAND_load_file(const char *file, long bytes)\\r\\n{\\r\\nMS_STATIC unsigned char buf[BUFSIZE];\\r\\nstruct stat sb;\\r\\nint i,ret=0,n;\\r\\nFILE *in;\\r\\nif (file == NULL) return(0);\\r\\ni=stat(file,&sb);\\r\\nRAND_add(&sb,sizeof(sb),0.0);\\r\\nif (i < 0) return(0);\\r\\nif (bytes == 0) return(ret);\\r\\nin=fopen(file,\"rb\");\\r\\nif (in == NULL) goto err;\\r\\n#if defined(S_IFBLK) && defined(S_IFCHR)\\r\\nif (sb.st_mode & (S_IFBLK | S_IFCHR)) {\\r\\nbytes = (bytes == -1) ? 2048 : bytes;\\r\\nsetvbuf(in, NULL, _IONBF, 0);\\r\\n}\\r\\n#endif\\r\\nfor (;;)\\r\\n{\\r\\nif (bytes > 0)\\r\\nn = (bytes < BUFSIZE)?(int)bytes:BUFSIZE;\\r\\nelse\\r\\nn = BUFSIZE;\\r\\ni=fread(buf,1,n,in);\\r\\nif (i <= 0) break;\\r\\nRAND_add(buf,n,(double)i);\\r\\nret+=i;\\r\\nif (bytes > 0)\\r\\n{\\r\\nbytes-=n;\\r\\nif (bytes <= 0) break;\\r\\n}\\r\\n}\\r\\nfclose(in);\\r\\nOPENSSL_cleanse(buf,BUFSIZE);\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint RAND_write_file(const char *file)\\r\\n{\\r\\nunsigned char buf[BUFSIZE];\\r\\nint i,ret=0,rand_err=0;\\r\\nFILE *out = NULL;\\r\\nint n;\\r\\nstruct stat sb;\\r\\ni=stat(file,&sb);\\r\\nif (i != -1) {\\r\\n#if defined(S_IFBLK) && defined(S_IFCHR)\\r\\nif (sb.st_mode & (S_IFBLK | S_IFCHR)) {\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#if defined(O_CREAT) && !defined(OPENSSL_SYS_WIN32)\\r\\n{\\r\\nint fd = open(file, O_CREAT, 0600);\\r\\nif (fd != -1)\\r\\nout = fdopen(fd, \"wb\");\\r\\n}\\r\\n#endif\\r\\nif (out == NULL)\\r\\nout = fopen(file,\"wb\");\\r\\nif (out == NULL) goto err;\\r\\n#ifndef NO_CHMOD\\r\\nchmod(file,0600);\\r\\n#endif\\r\\nn=RAND_DATA;\\r\\nfor (;;)\\r\\n{\\r\\ni=(n > BUFSIZE)?BUFSIZE:n;\\r\\nn-=BUFSIZE;\\r\\nif (RAND_bytes(buf,i) <= 0)\\r\\nrand_err=1;\\r\\ni=fwrite(buf,1,i,out);\\r\\nif (i <= 0)\\r\\n{\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nret+=i;\\r\\nif (n <= 0) break;\\r\\n}\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nchar *tmpf;\\r\\ntmpf = OPENSSL_malloc(strlen(file) + 4);\\r\\nif (tmpf)\\r\\n{\\r\\nstrcpy(tmpf, file);\\r\\nstrcat(tmpf, \";-1\");\\r\\nwhile(delete(tmpf) == 0)\\r\\n;\\r\\nrename(file,\";1\");\\r\\n}\\r\\n}\\r\\n#endif\\r\\nfclose(out);\\r\\nOPENSSL_cleanse(buf,BUFSIZE);\\r\\nerr:\\r\\nreturn (rand_err ? -1 : ret);\\r\\n}\\r\\nconst char *RAND_file_name(char *buf, size_t size)\\r\\n{\\r\\nchar *s=NULL;\\r\\nint ok = 0;\\r\\n#ifdef __OpenBSD__\\r\\nstruct stat sb;\\r\\n#endif\\r\\nif (OPENSSL_issetugid() == 0)\\r\\ns=getenv(\"RANDFILE\");\\r\\nif (s != NULL && *s && strlen(s) + 1 < size)\\r\\n{\\r\\nif (BUF_strlcpy(buf,s,size) >= size)\\r\\nreturn NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (OPENSSL_issetugid() == 0)\\r\\ns=getenv(\"HOME\");\\r\\n#ifdef DEFAULT_HOME\\r\\nif (s == NULL)\\r\\n{\\r\\ns = DEFAULT_HOME;\\r\\n}\\r\\n#endif\\r\\nif (s && *s && strlen(s)+strlen(RFILE)+2 < size)\\r\\n{\\r\\nBUF_strlcpy(buf,s,size);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(buf,\"/\",size);\\r\\n#endif\\r\\nBUF_strlcat(buf,RFILE,size);\\r\\nok = 1;\\r\\n}\\r\\nelse\\r\\nbuf[0] = '\\0';\\r\\n}\\r\\n#ifdef __OpenBSD__\\r\\nif (!ok)\\r\\nif (BUF_strlcpy(buf,\"/dev/arandom\",size) >= size) {\\r\\nreturn(NULL);\\r\\n}\\r\\nif (stat(buf,&sb) == -1)\\r\\nif (BUF_strlcpy(buf,\"/dev/arandom\",size) >= size) {\\r\\nreturn(NULL);\\r\\n}\\r\\n#endif\\r\\nreturn(buf);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_des_c", "target": 0, "func": "static int des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nDES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i), ctx->cipher_data, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data, (DES_cblock *)ctx->iv, &ctx->num);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int n;\\r\\nunsigned char c[1],d[1];\\r\\nfor(n=0 ; n < inl ; ++n)\\r\\n{\\r\\nc[0]=(in[n/8]&(1 << (7-n%8))) ? 0x80 : 0;\\r\\nDES_cfb_encrypt(c,d,1,1,ctx->cipher_data,(DES_cblock *)ctx->iv,\\r\\nctx->encrypt);\\r\\nout[n/8]=(out[n/8]&~(0x80 >> (n%8)))|((d[0]&0x80) >> (n%8));\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nDES_cfb_encrypt(in,out,8,inl,ctx->cipher_data,(DES_cblock *)ctx->iv,\\r\\nctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\n#ifdef EVP_CHECK_DES_KEY\\r\\nif(DES_set_key_checked(deskey,ctx->cipher_data) != 0)\\r\\nreturn 0;\\r\\n#else\\r\\nDES_set_key_unchecked(deskey,ctx->cipher_data);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch(type)\\r\\n{\\r\\ncase EVP_CTRL_RAND_KEY:\\r\\nif (RAND_bytes(ptr, 8) <= 0)\\r\\nreturn 0;\\r\\nDES_set_odd_parity((DES_cblock *)ptr);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_int_c", "target": 0, "func": "ASN1_INTEGER *ASN1_INTEGER_dup(ASN1_INTEGER *x)\\r\\n{ return M_ASN1_INTEGER_dup(x);}\\r\\nint ASN1_INTEGER_cmp(ASN1_INTEGER *x, ASN1_INTEGER *y)\\r\\n{\\r\\nint neg, ret;\\r\\nneg = x->type & V_ASN1_NEG;\\r\\nif (neg != (y->type & V_ASN1_NEG))\\r\\n{\\r\\nif (neg)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nret = ASN1_STRING_cmp(x, y);\\r\\nif (neg)\\r\\nreturn -ret;\\r\\nelse\\r\\nreturn ret;\\r\\n}\\r\\nint i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)\\r\\n{\\r\\nint pad=0,ret,i,neg;\\r\\nunsigned char *p,*n,pb=0;\\r\\nif ((a == NULL) || (a->data == NULL)) return(0);\\r\\nneg=a->type & V_ASN1_NEG;\\r\\nif (a->length == 0)\\r\\nret=1;\\r\\nelse\\r\\n{\\r\\nret=a->length;\\r\\ni=a->data[0];\\r\\nif (!neg && (i > 127)) {\\r\\npad=1;\\r\\npb=0;\\r\\n} else if(neg) {\\r\\nif(i>128) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\n} else if(i == 128) {\\r\\nfor(i = 1; i < a->length; i++) if(a->data[i]) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nret+=pad;\\r\\n}\\r\\nif (pp == NULL) return(ret);\\r\\np= *pp;\\r\\nif (pad) *(p++)=pb;\\r\\nif (a->length == 0) *(p++)=0;\\r\\nelse if (!neg) memcpy(p,a->data,(unsigned int)a->length);\\r\\nelse {\\r\\nn=a->data + a->length - 1;\\r\\np += a->length - 1;\\r\\ni = a->length;\\r\\nwhile(!*n) {\\r\\n*(p--) = 0;\\r\\nn--;\\r\\ni--;\\r\\n}\\r\\n*(p--) = ((*(n--)) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(p--) = *(n--) ^ 0xff;\\r\\n}\\r\\n*pp+=ret;\\r\\nreturn(ret);\\r\\n}\\r\\nASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,\\r\\nlong len)\\r\\n{\\r\\nASN1_INTEGER *ret=NULL;\\r\\nconst unsigned char *p, *pend;\\r\\nunsigned char *to,*s;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=M_ASN1_INTEGER_new()) == NULL) return(NULL);\\r\\nret->type=V_ASN1_INTEGER;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\npend = p + len;\\r\\ns=(unsigned char *)OPENSSL_malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto=s;\\r\\nif(!len) {\\r\\nret->type=V_ASN1_INTEGER;\\r\\n} else if (*p & 0x80)\\r\\n{\\r\\nret->type=V_ASN1_NEG_INTEGER;\\r\\nif ((*p == 0xff) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\ni = len;\\r\\np += i - 1;\\r\\nto += i - 1;\\r\\nwhile((!*p) && i) {\\r\\n*(to--) = 0;\\r\\ni--;\\r\\np--;\\r\\n}\\r\\nif(!i) {\\r\\n*s = 1;\\r\\ns[len] = 0;\\r\\nlen++;\\r\\n} else {\\r\\n*(to--) = (*(p--) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(to--) = *(p--) ^ 0xff;\\r\\n}\\r\\n} else {\\r\\nret->type=V_ASN1_INTEGER;\\r\\nif ((*p == 0) && (len != 1))\\r\\n{\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\n}\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\nret->data=s;\\r\\nret->length=(int)len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=pend;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_INTEGER,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_INTEGER *ret=NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *to,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=M_ASN1_INTEGER_new()) == NULL) return(NULL);\\r\\nret->type=V_ASN1_INTEGER;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_INTEGER)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_INTEGER;\\r\\ngoto err;\\r\\n}\\r\\ns=(unsigned char *)OPENSSL_malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto=s;\\r\\nret->type=V_ASN1_INTEGER;\\r\\nif(len) {\\r\\nif ((*p == 0) && (len != 1))\\r\\n{\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\np+=len;\\r\\n}\\r\\nif (ret->data != NULL) OPENSSL_free(ret->data);\\r\\nret->data=s;\\r\\nret->length=(int)len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_UINTEGER,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_INTEGER_set(ASN1_INTEGER *a, long v)\\r\\n{\\r\\nint j,k;\\r\\nunsigned int i;\\r\\nunsigned char buf[sizeof(long)+1];\\r\\nlong d;\\r\\na->type=V_ASN1_INTEGER;\\r\\nif (a->length < (int)(sizeof(long)+1))\\r\\n{\\r\\nif (a->data != NULL)\\r\\nOPENSSL_free(a->data);\\r\\nif ((a->data=(unsigned char *)OPENSSL_malloc(sizeof(long)+1)) != NULL)\\r\\nmemset((char *)a->data,0,sizeof(long)+1);\\r\\n}\\r\\nif (a->data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_INTEGER_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nd=v;\\r\\nif (d < 0)\\r\\n{\\r\\nd= -d;\\r\\na->type=V_ASN1_NEG_INTEGER;\\r\\n}\\r\\nfor (i=0; i<sizeof(long); i++)\\r\\n{\\r\\nif (d == 0) break;\\r\\nbuf[i]=(int)d&0xff;\\r\\nd>>=8;\\r\\n}\\r\\nj=0;\\r\\nfor (k=i-1; k >=0; k--)\\r\\na->data[j++]=buf[k];\\r\\na->length=j;\\r\\nreturn(1);\\r\\n}\\r\\nlong ASN1_INTEGER_get(ASN1_INTEGER *a)\\r\\n{\\r\\nint neg=0,i;\\r\\nlong r=0;\\r\\nif (a == NULL) return(0L);\\r\\ni=a->type;\\r\\nif (i == V_ASN1_NEG_INTEGER)\\r\\nneg=1;\\r\\nelse if (i != V_ASN1_INTEGER)\\r\\nreturn -1;\\r\\nif (a->length > (int)sizeof(long))\\r\\n{\\r\\nreturn(0xffffffffL);\\r\\n}\\r\\nif (a->data == NULL)\\r\\nreturn 0;\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nr<<=8;\\r\\nr|=(unsigned char)a->data[i];\\r\\n}\\r\\nif (neg) r= -r;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *bn, ASN1_INTEGER *ai)\\r\\n{\\r\\nASN1_INTEGER *ret;\\r\\nint len,j;\\r\\nif (ai == NULL)\\r\\nret=M_ASN1_INTEGER_new();\\r\\nelse\\r\\nret=ai;\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_INTEGER,ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_negative(bn))\\r\\nret->type = V_ASN1_NEG_INTEGER;\\r\\nelse ret->type=V_ASN1_INTEGER;\\r\\nj=BN_num_bits(bn);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (ret->length < len+4)\\r\\n{\\r\\nunsigned char *new_data=OPENSSL_realloc(ret->data, len+4);\\r\\nif (!new_data)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nret->data=new_data;\\r\\n}\\r\\nret->length=BN_bn2bin(bn,ret->data);\\r\\nif(!ret->length)\\r\\n{\\r\\nret->data[0] = 0;\\r\\nret->length = 1;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != ai) M_ASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *ai, BIGNUM *bn)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=BN_bin2bn(ai->data,ai->length,bn)) == NULL)\\r\\nASN1err(ASN1_F_ASN1_INTEGER_TO_BN,ASN1_R_BN_LIB);\\r\\nelse if(ai->type == V_ASN1_NEG_INTEGER)\\r\\nBN_set_negative(ret, 1);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_asn_pack_c", "target": 0, "func": "STACK *ASN1_seq_unpack(const unsigned char *buf, int len,\\r\\nd2i_of_void *d2i,void (*free_func)(void *))\\r\\n{\\r\\nSTACK *sk;\\r\\nconst unsigned char *pbuf;\\r\\npbuf = buf;\\r\\nif (!(sk = d2i_ASN1_SET(NULL, &pbuf, len, d2i, free_func,\\r\\nV_ASN1_SEQUENCE, V_ASN1_UNIVERSAL)))\\r\\nASN1err(ASN1_F_ASN1_SEQ_UNPACK,ASN1_R_DECODE_ERROR);\\r\\nreturn sk;\\r\\n}\\r\\nunsigned char *ASN1_seq_pack(STACK *safes, i2d_of_void *i2d,\\r\\nunsigned char **buf, int *len)\\r\\n{\\r\\nint safelen;\\r\\nunsigned char *safe, *p;\\r\\nif (!(safelen = i2d_ASN1_SET(safes, NULL, i2d, V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL, IS_SEQUENCE))) {\\r\\nASN1err(ASN1_F_ASN1_SEQ_PACK,ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(safe = OPENSSL_malloc (safelen))) {\\r\\nASN1err(ASN1_F_ASN1_SEQ_PACK,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np = safe;\\r\\ni2d_ASN1_SET(safes, &p, i2d, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL,\\r\\nIS_SEQUENCE);\\r\\nif (len) *len = safelen;\\r\\nif (buf) *buf = safe;\\r\\nreturn safe;\\r\\n}\\r\\nvoid *ASN1_unpack_string(ASN1_STRING *oct, d2i_of_void *d2i)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nchar *ret;\\r\\np = oct->data;\\r\\nif(!(ret = d2i(NULL, &p, oct->length)))\\r\\nASN1err(ASN1_F_ASN1_UNPACK_STRING,ASN1_R_DECODE_ERROR);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_STRING *ASN1_pack_string(void *obj, i2d_of_void *i2d, ASN1_STRING **oct)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_STRING *octmp;\\r\\nif (!oct || !*oct) {\\r\\nif (!(octmp = ASN1_STRING_new ())) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (oct) *oct = octmp;\\r\\n} else octmp = *oct;\\r\\nif (!(octmp->length = i2d(obj, NULL))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(p = OPENSSL_malloc (octmp->length))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\noctmp->data = p;\\r\\ni2d (obj, &p);\\r\\nreturn octmp;\\r\\n}\\r\\nASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_STRING **oct)\\r\\n{\\r\\nASN1_STRING *octmp;\\r\\nif (!oct || !*oct) {\\r\\nif (!(octmp = ASN1_STRING_new ())) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (oct) *oct = octmp;\\r\\n} else octmp = *oct;\\r\\nif(octmp->data) {\\r\\nOPENSSL_free(octmp->data);\\r\\noctmp->data = NULL;\\r\\n}\\r\\nif (!(octmp->length = ASN1_item_i2d(obj, &octmp->data, it))) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK,ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!octmp->data) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn octmp;\\r\\n}\\r\\nvoid *ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nvoid *ret;\\r\\np = oct->data;\\r\\nif(!(ret = ASN1_item_d2i(NULL, &p, oct->length, it)))\\r\\nASN1err(ASN1_F_ASN1_ITEM_UNPACK,ASN1_R_DECODE_ERROR);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ecp_mont_c", "target": 0, "func": "const EC_METHOD *EC_GFp_mont_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_mont_group_init,\\r\\nec_GFp_mont_group_finish,\\r\\nec_GFp_mont_group_clear_finish,\\r\\nec_GFp_mont_group_copy,\\r\\nec_GFp_mont_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\nec_GFp_simple_set_compressed_coordinates,\\r\\nec_GFp_simple_point2oct,\\r\\nec_GFp_simple_oct2point,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_mont_field_mul,\\r\\nec_GFp_mont_field_sqr,\\r\\n0 ,\\r\\nec_GFp_mont_field_encode,\\r\\nec_GFp_mont_field_decode,\\r\\nec_GFp_mont_field_set_to_one };\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_mont_group_init(EC_GROUP *group)\\r\\n{\\r\\nint ok;\\r\\nok = ec_GFp_simple_group_init(group);\\r\\ngroup->field_data1 = NULL;\\r\\ngroup->field_data2 = NULL;\\r\\nreturn ok;\\r\\n}\\r\\nvoid ec_GFp_mont_group_finish(EC_GROUP *group)\\r\\n{\\r\\nif (group->field_data1 != NULL)\\r\\n{\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL)\\r\\n{\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nec_GFp_simple_group_finish(group);\\r\\n}\\r\\nvoid ec_GFp_mont_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nif (group->field_data1 != NULL)\\r\\n{\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL)\\r\\n{\\r\\nBN_clear_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nec_GFp_simple_group_clear_finish(group);\\r\\n}\\r\\nint ec_GFp_mont_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nif (dest->field_data1 != NULL)\\r\\n{\\r\\nBN_MONT_CTX_free(dest->field_data1);\\r\\ndest->field_data1 = NULL;\\r\\n}\\r\\nif (dest->field_data2 != NULL)\\r\\n{\\r\\nBN_clear_free(dest->field_data2);\\r\\ndest->field_data2 = NULL;\\r\\n}\\r\\nif (!ec_GFp_simple_group_copy(dest, src)) return 0;\\r\\nif (src->field_data1 != NULL)\\r\\n{\\r\\ndest->field_data1 = BN_MONT_CTX_new();\\r\\nif (dest->field_data1 == NULL) return 0;\\r\\nif (!BN_MONT_CTX_copy(dest->field_data1, src->field_data1)) goto err;\\r\\n}\\r\\nif (src->field_data2 != NULL)\\r\\n{\\r\\ndest->field_data2 = BN_dup(src->field_data2);\\r\\nif (dest->field_data2 == NULL) goto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (dest->field_data1 != NULL)\\r\\n{\\r\\nBN_MONT_CTX_free(dest->field_data1);\\r\\ndest->field_data1 = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nBIGNUM *one = NULL;\\r\\nint ret = 0;\\r\\nif (group->field_data1 != NULL)\\r\\n{\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL)\\r\\n{\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nif (ctx == NULL)\\r\\n{\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nmont = BN_MONT_CTX_new();\\r\\nif (mont == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont, p, ctx))\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_GROUP_SET_CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\none = BN_new();\\r\\nif (one == NULL) goto err;\\r\\nif (!BN_to_montgomery(one, BN_value_one(), mont, ctx)) goto err;\\r\\ngroup->field_data1 = mont;\\r\\nmont = NULL;\\r\\ngroup->field_data2 = one;\\r\\none = NULL;\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nif (!ret)\\r\\n{\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_MUL, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_mod_mul_montgomery(r, a, b, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_SQR, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_mod_mul_montgomery(r, a, a, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_ENCODE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_to_montgomery(r, a, (BN_MONT_CTX *)group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_DECODE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_from_montgomery(r, a, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data2 == NULL)\\r\\n{\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nif (!BN_copy(r, group->field_data2)) return 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_applink_c", "target": 0, "func": "static void *app_stdin(void) { return stdin; }\\r\\nstatic void *app_stdout(void) { return stdout; }\\r\\nstatic void *app_stderr(void) { return stderr; }\\r\\nstatic int app_feof(FILE *fp) { return feof(fp); }\\r\\nstatic int app_ferror(FILE *fp) { return ferror(fp); }\\r\\nstatic void app_clearerr(FILE *fp) { clearerr(fp); }\\r\\nstatic int app_fileno(FILE *fp) { return _fileno(fp); }\\r\\nstatic int app_fsetmod(FILE *fp,char mod)\\r\\n{ return _setmode (_fileno(fp),mod=='b'?_O_BINARY:_O_TEXT); }\\r\\nvoid **OPENSSL_Applink(void)\\r\\n{ static int once=1;\\r\\nstatic void *OPENSSL_ApplinkTable[APPLINK_MAX+1]={(void *)APPLINK_MAX};\\r\\nif (once)\\r\\n{ OPENSSL_ApplinkTable[APPLINK_STDIN] = app_stdin;\\r\\nOPENSSL_ApplinkTable[APPLINK_STDOUT] = app_stdout;\\r\\nOPENSSL_ApplinkTable[APPLINK_STDERR] = app_stderr;\\r\\nOPENSSL_ApplinkTable[APPLINK_FPRINTF] = fprintf;\\r\\nOPENSSL_ApplinkTable[APPLINK_FGETS] = fgets;\\r\\nOPENSSL_ApplinkTable[APPLINK_FREAD] = fread;\\r\\nOPENSSL_ApplinkTable[APPLINK_FWRITE] = fwrite;\\r\\nOPENSSL_ApplinkTable[APPLINK_FSETMOD] = app_fsetmod;\\r\\nOPENSSL_ApplinkTable[APPLINK_FEOF] = app_feof;\\r\\nOPENSSL_ApplinkTable[APPLINK_FCLOSE] = fclose;\\r\\nOPENSSL_ApplinkTable[APPLINK_FOPEN] = fopen;\\r\\nOPENSSL_ApplinkTable[APPLINK_FSEEK] = fseek;\\r\\nOPENSSL_ApplinkTable[APPLINK_FTELL] = ftell;\\r\\nOPENSSL_ApplinkTable[APPLINK_FFLUSH] = fflush;\\r\\nOPENSSL_ApplinkTable[APPLINK_FERROR] = app_ferror;\\r\\nOPENSSL_ApplinkTable[APPLINK_CLEARERR] = app_clearerr;\\r\\nOPENSSL_ApplinkTable[APPLINK_FILENO] = app_fileno;\\r\\nOPENSSL_ApplinkTable[APPLINK_OPEN] = _open;\\r\\nOPENSSL_ApplinkTable[APPLINK_READ] = _read;\\r\\nOPENSSL_ApplinkTable[APPLINK_WRITE] = _write;\\r\\nOPENSSL_ApplinkTable[APPLINK_LSEEK] = _lseek;\\r\\nOPENSSL_ApplinkTable[APPLINK_CLOSE] = _close;\\r\\nonce = 0;\\r\\n}\\r\\nreturn OPENSSL_ApplinkTable;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i_cbc_c", "target": 0, "func": "void idea_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nIDEA_KEY_SCHEDULE *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2n(tout0,out);\\r\\ntout1=tin[1]; l2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2n(tout0,out);\\r\\ntout1=tin[1]; l2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0); tin[0]=tin0;\\r\\nn2l(in,tin1); tin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0); tin[0]=tin0;\\r\\nn2l(in,tin1); tin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)\\r\\n{\\r\\nregister IDEA_INT *p;\\r\\nregister unsigned long x1,x2,x3,x4,t0,t1,ul;\\r\\nx2=d[0];\\r\\nx1=(x2>>16);\\r\\nx4=d[1];\\r\\nx3=(x4>>16);\\r\\np= &(key->data[0][0]);\\r\\nE_IDEA(0);\\r\\nE_IDEA(1);\\r\\nE_IDEA(2);\\r\\nE_IDEA(3);\\r\\nE_IDEA(4);\\r\\nE_IDEA(5);\\r\\nE_IDEA(6);\\r\\nE_IDEA(7);\\r\\nx1&=0xffff;\\r\\nidea_mul(x1,x1,*p,ul); p++;\\r\\nt0= x3+ *(p++);\\r\\nt1= x2+ *(p++);\\r\\nx4&=0xffff;\\r\\nidea_mul(x4,x4,*p,ul);\\r\\nd[0]=(t0&0xffff)|((x1&0xffff)<<16);\\r\\nd[1]=(x4&0xffff)|((t1&0xffff)<<16);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_o_names_c", "target": 0, "func": "int OBJ_NAME_init(void)\\r\\n{\\r\\nif (names_lh != NULL) return(1);\\r\\nMemCheck_off();\\r\\nnames_lh=lh_new(obj_name_hash, obj_name_cmp);\\r\\nMemCheck_on();\\r\\nreturn(names_lh != NULL);\\r\\n}\\r\\nstatic int obj_name_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nint ret;\\r\\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\\r\\nconst OBJ_NAME *b = (const OBJ_NAME *)b_void;\\r\\nret=a->type-b->type;\\r\\nif (ret == 0)\\r\\n{\\r\\nif ((name_funcs_stack != NULL)\\r\\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))\\r\\n{\\r\\nret=sk_NAME_FUNCS_value(name_funcs_stack,\\r\\na->type)->cmp_func(a->name,b->name);\\r\\n}\\r\\nelse\\r\\nret=strcmp(a->name,b->name);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic unsigned long obj_name_hash(const void *a_void)\\r\\n{\\r\\nunsigned long ret;\\r\\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\\r\\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))\\r\\n{\\r\\nret=sk_NAME_FUNCS_value(name_funcs_stack,\\r\\na->type)->hash_func(a->name);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=lh_strhash(a->name);\\r\\n}\\r\\nret^=a->type;\\r\\nreturn(ret);\\r\\n}\\r\\nconst char *OBJ_NAME_get(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on,*ret;\\r\\nint num=0,alias;\\r\\nif (name == NULL) return(NULL);\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(NULL);\\r\\nalias=type&OBJ_NAME_ALIAS;\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\non.name=name;\\r\\non.type=type;\\r\\nfor (;;)\\r\\n{\\r\\nret=(OBJ_NAME *)lh_retrieve(names_lh,&on);\\r\\nif (ret == NULL) return(NULL);\\r\\nif ((ret->alias) && !alias)\\r\\n{\\r\\nif (++num > 10) return(NULL);\\r\\non.name=ret->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nreturn(ret->data);\\r\\n}\\r\\n}\\r\\n}\\r\\nint OBJ_NAME_add(const char *name, int type, const char *data)\\r\\n{\\r\\nOBJ_NAME *onp,*ret;\\r\\nint alias;\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(0);\\r\\nalias=type&OBJ_NAME_ALIAS;\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\nonp=(OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));\\r\\nif (onp == NULL)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nonp->name=name;\\r\\nonp->alias=alias;\\r\\nonp->type=type;\\r\\nonp->data=data;\\r\\nret=(OBJ_NAME *)lh_insert(names_lh,onp);\\r\\nif (ret != NULL)\\r\\n{\\r\\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))\\r\\n{\\r\\nsk_NAME_FUNCS_value(name_funcs_stack,\\r\\nret->type)->free_func(ret->name,ret->type,ret->data);\\r\\n}\\r\\nOPENSSL_free(ret);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (lh_error(names_lh))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint OBJ_NAME_remove(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on,*ret;\\r\\nif (names_lh == NULL) return(0);\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\non.name=name;\\r\\non.type=type;\\r\\nret=(OBJ_NAME *)lh_delete(names_lh,&on);\\r\\nif (ret != NULL)\\r\\n{\\r\\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))\\r\\n{\\r\\nsk_NAME_FUNCS_value(name_funcs_stack,\\r\\nret->type)->free_func(ret->name,ret->type,ret->data);\\r\\n}\\r\\nOPENSSL_free(ret);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nstatic void do_all_fn(const OBJ_NAME *name,struct doall *d)\\r\\n{\\r\\nif(name->type == d->type)\\r\\nd->fn(name,d->arg);\\r\\n}\\r\\nstatic void do_all_sorted_fn(const OBJ_NAME *name,void *d_)\\r\\n{\\r\\nstruct doall_sorted *d=d_;\\r\\nif(name->type != d->type)\\r\\nreturn;\\r\\nd->names[d->n++]=name;\\r\\n}\\r\\nstatic int do_all_sorted_cmp(const void *n1_,const void *n2_)\\r\\n{\\r\\nconst OBJ_NAME * const *n1=n1_;\\r\\nconst OBJ_NAME * const *n2=n2_;\\r\\nreturn strcmp((*n1)->name,(*n2)->name);\\r\\n}\\r\\nvoid OBJ_NAME_do_all_sorted(int type,void (*fn)(const OBJ_NAME *,void *arg),\\r\\nvoid *arg)\\r\\n{\\r\\nstruct doall_sorted d;\\r\\nint n;\\r\\nd.type=type;\\r\\nd.names=OPENSSL_malloc(lh_num_items(names_lh)*sizeof *d.names);\\r\\nd.n=0;\\r\\nOBJ_NAME_do_all(type,do_all_sorted_fn,&d);\\r\\nqsort((void *)d.names,d.n,sizeof *d.names,do_all_sorted_cmp);\\r\\nfor(n=0 ; n < d.n ; ++n)\\r\\nfn(d.names[n],arg);\\r\\nOPENSSL_free((void *)d.names);\\r\\n}\\r\\nstatic void names_lh_free(OBJ_NAME *onp)\\r\\n{\\r\\nif(onp == NULL)\\r\\nreturn;\\r\\nif ((free_type < 0) || (free_type == onp->type))\\r\\n{\\r\\nOBJ_NAME_remove(onp->name,onp->type);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_oaep_c", "target": 0, "func": "int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nconst unsigned char *param, int plen)\\r\\n{\\r\\nint i, emlen = tlen - 1;\\r\\nunsigned char *db, *seed;\\r\\nunsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];\\r\\nif (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn 0;\\r\\n}\\r\\nif (emlen < 2 * SHA_DIGEST_LENGTH + 1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\ndbmask = OPENSSL_malloc(emlen - SHA_DIGEST_LENGTH);\\r\\nif (dbmask == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nto[0] = 0;\\r\\nseed = to + 1;\\r\\ndb = to + SHA_DIGEST_LENGTH + 1;\\r\\nEVP_Digest((void *)param, plen, db, NULL, EVP_sha1(), NULL);\\r\\nmemset(db + SHA_DIGEST_LENGTH, 0,\\r\\nemlen - flen - 2 * SHA_DIGEST_LENGTH - 1);\\r\\ndb[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;\\r\\nmemcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);\\r\\nif (RAND_bytes(seed, SHA_DIGEST_LENGTH) <= 0)\\r\\nreturn 0;\\r\\n#ifdef PKCS_TESTVECT\\r\\nmemcpy(seed,\\r\\n\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\\xf0\\x6c\\xb5\\x8f\",\\r\\n20);\\r\\n#endif\\r\\nMGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)\\r\\ndb[i] ^= dbmask[i];\\r\\nMGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < SHA_DIGEST_LENGTH; i++)\\r\\nseed[i] ^= seedmask[i];\\r\\nOPENSSL_free(dbmask);\\r\\nreturn 1;\\r\\n}\\r\\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num,\\r\\nconst unsigned char *param, int plen)\\r\\n{\\r\\nint i, dblen, mlen = -1;\\r\\nconst unsigned char *maskeddb;\\r\\nint lzero;\\r\\nunsigned char *db = NULL, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];\\r\\nint bad = 0;\\r\\nif (--num < 2 * SHA_DIGEST_LENGTH + 1)\\r\\ngoto decoding_err;\\r\\nlzero = num - flen;\\r\\nif (lzero < 0)\\r\\n{\\r\\nbad = 1;\\r\\nlzero = 0;\\r\\n}\\r\\nmaskeddb = from - lzero + SHA_DIGEST_LENGTH;\\r\\ndblen = num - SHA_DIGEST_LENGTH;\\r\\ndb = OPENSSL_malloc(dblen);\\r\\nif (db == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nMGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);\\r\\nfor (i = lzero; i < SHA_DIGEST_LENGTH; i++)\\r\\nseed[i] ^= from[i - lzero];\\r\\nMGF1(db, dblen, seed, SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < dblen; i++)\\r\\ndb[i] ^= maskeddb[i];\\r\\nEVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL);\\r\\nif (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)\\r\\ngoto decoding_err;\\r\\nelse\\r\\n{\\r\\nfor (i = SHA_DIGEST_LENGTH; i < dblen; i++)\\r\\nif (db[i] != 0x00)\\r\\nbreak;\\r\\nif (db[i] != 0x01 || i++ >= dblen)\\r\\ngoto decoding_err;\\r\\nelse\\r\\n{\\r\\nmlen = dblen - i;\\r\\nif (tlen < mlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);\\r\\nmlen = -1;\\r\\n}\\r\\nelse\\r\\nmemcpy(to, db + i, mlen);\\r\\n}\\r\\n}\\r\\nOPENSSL_free(db);\\r\\nreturn mlen;\\r\\ndecoding_err:\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);\\r\\nif (db != NULL) OPENSSL_free(db);\\r\\nreturn -1;\\r\\n}\\r\\nint PKCS1_MGF1(unsigned char *mask, long len,\\r\\nconst unsigned char *seed, long seedlen, const EVP_MD *dgst)\\r\\n{\\r\\nlong i, outlen = 0;\\r\\nunsigned char cnt[4];\\r\\nEVP_MD_CTX c;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nint mdlen;\\r\\nEVP_MD_CTX_init(&c);\\r\\nmdlen = EVP_MD_size(dgst);\\r\\nfor (i = 0; outlen < len; i++)\\r\\n{\\r\\ncnt[0] = (unsigned char)((i >> 24) & 255);\\r\\ncnt[1] = (unsigned char)((i >> 16) & 255);\\r\\ncnt[2] = (unsigned char)((i >> 8)) & 255;\\r\\ncnt[3] = (unsigned char)(i & 255);\\r\\nEVP_DigestInit_ex(&c,dgst, NULL);\\r\\nEVP_DigestUpdate(&c, seed, seedlen);\\r\\nEVP_DigestUpdate(&c, cnt, 4);\\r\\nif (outlen + mdlen <= len)\\r\\n{\\r\\nEVP_DigestFinal_ex(&c, mask + outlen, NULL);\\r\\noutlen += mdlen;\\r\\n}\\r\\nelse\\r\\n{\\r\\nEVP_DigestFinal_ex(&c, md, NULL);\\r\\nmemcpy(mask + outlen, md, len - outlen);\\r\\noutlen = len;\\r\\n}\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&c);\\r\\nreturn 0;\\r\\n}\\r\\nint MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)\\r\\n{\\r\\nreturn PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_zencod_err_c", "target": 0, "func": "static void ERR_load_ZENCOD_strings(void)\\r\\n{\\r\\nif (ZENCOD_lib_error_code == 0)\\r\\nZENCOD_lib_error_code=ERR_get_next_error_library();\\r\\nif (ZENCOD_error_init)\\r\\n{\\r\\nZENCOD_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(ZENCOD_lib_error_code,ZENCOD_str_functs);\\r\\nERR_load_strings(ZENCOD_lib_error_code,ZENCOD_str_reasons);\\r\\n#endif\\r\\n#ifdef ZENCOD_LIB_NAME\\r\\nZENCOD_lib_name->error = ERR_PACK(ZENCOD_lib_error_code,0,0);\\r\\nERR_load_strings(0,ZENCOD_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_ZENCOD_strings(void)\\r\\n{\\r\\nif (ZENCOD_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(ZENCOD_lib_error_code,ZENCOD_str_functs);\\r\\nERR_unload_strings(ZENCOD_lib_error_code,ZENCOD_str_reasons);\\r\\n#endif\\r\\n#ifdef ZENCOD_LIB_NAME\\r\\nERR_unload_strings(0,ZENCOD_lib_name);\\r\\n#endif\\r\\nZENCOD_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_ZENCOD_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (ZENCOD_lib_error_code == 0)\\r\\nZENCOD_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(ZENCOD_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_i2d_pu_c", "target": 0, "func": "int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nreturn(i2d_RSAPublicKey(a->pkey.rsa,pp));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nreturn(i2d_DSAPublicKey(a->pkey.dsa,pp));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nreturn(i2o_ECPublicKey(a->pkey.ec, pp));\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_I2D_PUBLICKEY,ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_bio_c", "target": 0, "func": "BIO_METHOD *BIO_s_bio(void)\\r\\n{\\r\\nreturn &methods_biop;\\r\\n}\\r\\nstatic int bio_new(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nb = OPENSSL_malloc(sizeof *b);\\r\\nif (b == NULL)\\r\\nreturn 0;\\r\\nb->peer = NULL;\\r\\nb->size = 17*1024;\\r\\nb->buf = NULL;\\r\\nbio->ptr = b;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_free(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nif (bio == NULL)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nif (b->peer)\\r\\nbio_destroy_pair(bio);\\r\\nif (b->buf != NULL)\\r\\n{\\r\\nOPENSSL_free(b->buf);\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_read(BIO *bio, char *buf, int size_)\\r\\n{\\r\\nsize_t size = size_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\npeer_b = b->peer->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->request = 0;\\r\\nif (buf == NULL || size == 0)\\r\\nreturn 0;\\r\\nif (peer_b->len == 0)\\r\\n{\\r\\nif (peer_b->closed)\\r\\nreturn 0;\\r\\nelse\\r\\n{\\r\\nBIO_set_retry_read(bio);\\r\\nif (size <= peer_b->size)\\r\\npeer_b->request = size;\\r\\nelse\\r\\npeer_b->request = peer_b->size;\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (peer_b->len < size)\\r\\nsize = peer_b->len;\\r\\nrest = size;\\r\\nassert(rest > 0);\\r\\ndo\\r\\n{\\r\\nsize_t chunk;\\r\\nassert(rest <= peer_b->len);\\r\\nif (peer_b->offset + rest <= peer_b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = peer_b->size - peer_b->offset;\\r\\nassert(peer_b->offset + chunk <= peer_b->size);\\r\\nmemcpy(buf, peer_b->buf + peer_b->offset, chunk);\\r\\npeer_b->len -= chunk;\\r\\nif (peer_b->len)\\r\\n{\\r\\npeer_b->offset += chunk;\\r\\nassert(peer_b->offset <= peer_b->size);\\r\\nif (peer_b->offset == peer_b->size)\\r\\npeer_b->offset = 0;\\r\\nbuf += chunk;\\r\\n}\\r\\nelse\\r\\n{\\r\\nassert(chunk == rest);\\r\\npeer_b->offset = 0;\\r\\n}\\r\\nrest -= chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn size;\\r\\n}\\r\\nstatic ssize_t bio_nread0(BIO *bio, char **buf)\\r\\n{\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nssize_t num;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\npeer_b = b->peer->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->request = 0;\\r\\nif (peer_b->len == 0)\\r\\n{\\r\\nchar dummy;\\r\\nreturn bio_read(bio, &dummy, 1);\\r\\n}\\r\\nnum = peer_b->len;\\r\\nif (peer_b->size < peer_b->offset + num)\\r\\nnum = peer_b->size - peer_b->offset;\\r\\nassert(num > 0);\\r\\nif (buf != NULL)\\r\\n*buf = peer_b->buf + peer_b->offset;\\r\\nreturn num;\\r\\n}\\r\\nstatic ssize_t bio_nread(BIO *bio, char **buf, size_t num_)\\r\\n{\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nssize_t num, available;\\r\\nif (num_ > SSIZE_MAX)\\r\\nnum = SSIZE_MAX;\\r\\nelse\\r\\nnum = (ssize_t)num_;\\r\\navailable = bio_nread0(bio, buf);\\r\\nif (num > available)\\r\\nnum = available;\\r\\nif (num <= 0)\\r\\nreturn num;\\r\\nb = bio->ptr;\\r\\npeer_b = b->peer->ptr;\\r\\npeer_b->len -= num;\\r\\nif (peer_b->len)\\r\\n{\\r\\npeer_b->offset += num;\\r\\nassert(peer_b->offset <= peer_b->size);\\r\\nif (peer_b->offset == peer_b->size)\\r\\npeer_b->offset = 0;\\r\\n}\\r\\nelse\\r\\npeer_b->offset = 0;\\r\\nreturn num;\\r\\n}\\r\\nstatic int bio_write(BIO *bio, const char *buf, int num_)\\r\\n{\\r\\nsize_t num = num_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init || buf == NULL || num == 0)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\nassert(b->buf != NULL);\\r\\nb->request = 0;\\r\\nif (b->closed)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE, BIO_R_BROKEN_PIPE);\\r\\nreturn -1;\\r\\n}\\r\\nassert(b->len <= b->size);\\r\\nif (b->len == b->size)\\r\\n{\\r\\nBIO_set_retry_write(bio);\\r\\nreturn -1;\\r\\n}\\r\\nif (num > b->size - b->len)\\r\\nnum = b->size - b->len;\\r\\nrest = num;\\r\\nassert(rest > 0);\\r\\ndo\\r\\n{\\r\\nsize_t write_offset;\\r\\nsize_t chunk;\\r\\nassert(b->len + rest <= b->size);\\r\\nwrite_offset = b->offset + b->len;\\r\\nif (write_offset >= b->size)\\r\\nwrite_offset -= b->size;\\r\\nif (write_offset + rest <= b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = b->size - write_offset;\\r\\nmemcpy(b->buf + write_offset, buf, chunk);\\r\\nb->len += chunk;\\r\\nassert(b->len <= b->size);\\r\\nrest -= chunk;\\r\\nbuf += chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn num;\\r\\n}\\r\\nstatic ssize_t bio_nwrite0(BIO *bio, char **buf)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nsize_t num;\\r\\nsize_t write_offset;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\nassert(b->buf != NULL);\\r\\nb->request = 0;\\r\\nif (b->closed)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NWRITE0, BIO_R_BROKEN_PIPE);\\r\\nreturn -1;\\r\\n}\\r\\nassert(b->len <= b->size);\\r\\nif (b->len == b->size)\\r\\n{\\r\\nBIO_set_retry_write(bio);\\r\\nreturn -1;\\r\\n}\\r\\nnum = b->size - b->len;\\r\\nwrite_offset = b->offset + b->len;\\r\\nif (write_offset >= b->size)\\r\\nwrite_offset -= b->size;\\r\\nif (write_offset + num > b->size)\\r\\nnum = b->size - write_offset;\\r\\nif (buf != NULL)\\r\\n*buf = b->buf + write_offset;\\r\\nassert(write_offset + num <= b->size);\\r\\nreturn num;\\r\\n}\\r\\nstatic ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nssize_t num, space;\\r\\nif (num_ > SSIZE_MAX)\\r\\nnum = SSIZE_MAX;\\r\\nelse\\r\\nnum = (ssize_t)num_;\\r\\nspace = bio_nwrite0(bio, buf);\\r\\nif (num > space)\\r\\nnum = space;\\r\\nif (num <= 0)\\r\\nreturn num;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nb->len += num;\\r\\nassert(b->len <= b->size);\\r\\nreturn num;\\r\\n}\\r\\nstatic long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nassert(b != NULL);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_SET_WRITE_BUF_SIZE:\\r\\nif (b->peer)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);\\r\\nret = 0;\\r\\n}\\r\\nelse if (num == 0)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);\\r\\nret = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsize_t new_size = num;\\r\\nif (b->size != new_size)\\r\\n{\\r\\nif (b->buf)\\r\\n{\\r\\nOPENSSL_free(b->buf);\\r\\nb->buf = NULL;\\r\\n}\\r\\nb->size = new_size;\\r\\n}\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_BUF_SIZE:\\r\\nret = (long) b->size;\\r\\nbreak;\\r\\ncase BIO_C_MAKE_BIO_PAIR:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (bio_make_pair(bio, other_bio))\\r\\nret = 1;\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DESTROY_BIO_PAIR:\\r\\nbio_destroy_pair(bio);\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_GUARANTEE:\\r\\nif (b->peer == NULL || b->closed)\\r\\nret = 0;\\r\\nelse\\r\\nret = (long) b->size - b->len;\\r\\nbreak;\\r\\ncase BIO_C_GET_READ_REQUEST:\\r\\nret = (long) b->request;\\r\\nbreak;\\r\\ncase BIO_C_RESET_READ_REQUEST:\\r\\nb->request = 0;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_SHUTDOWN_WR:\\r\\nb->closed = 1;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_NREAD0:\\r\\nret = (long) bio_nread0(bio, ptr);\\r\\nbreak;\\r\\ncase BIO_C_NREAD:\\r\\nret = (long) bio_nread(bio, ptr, (size_t) num);\\r\\nbreak;\\r\\ncase BIO_C_NWRITE0:\\r\\nret = (long) bio_nwrite0(bio, ptr);\\r\\nbreak;\\r\\ncase BIO_C_NWRITE:\\r\\nret = (long) bio_nwrite(bio, ptr, (size_t) num);\\r\\nbreak;\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->buf != NULL)\\r\\n{\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = bio->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nbio->shutdown = (int) num;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nif (b->peer != NULL)\\r\\n{\\r\\nstruct bio_bio_st *peer_b = b->peer->ptr;\\r\\nret = (long) peer_b->len;\\r\\n}\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nif (b->buf != NULL)\\r\\nret = (long) b->len;\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nstruct bio_bio_st *other_b;\\r\\nassert(other_bio != NULL);\\r\\nother_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nassert(other_b->buf == NULL);\\r\\nother_b->size = b->size;\\r\\n}\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (other_bio)\\r\\n{\\r\\nstruct bio_bio_st *other_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nret = other_b->len == 0 && other_b->closed;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int bio_puts(BIO *bio, const char *str)\\r\\n{\\r\\nreturn bio_write(bio, str, strlen(str));\\r\\n}\\r\\nstatic int bio_make_pair(BIO *bio1, BIO *bio2)\\r\\n{\\r\\nstruct bio_bio_st *b1, *b2;\\r\\nassert(bio1 != NULL);\\r\\nassert(bio2 != NULL);\\r\\nb1 = bio1->ptr;\\r\\nb2 = bio2->ptr;\\r\\nif (b1->peer != NULL || b2->peer != NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, BIO_R_IN_USE);\\r\\nreturn 0;\\r\\n}\\r\\nif (b1->buf == NULL)\\r\\n{\\r\\nb1->buf = OPENSSL_malloc(b1->size);\\r\\nif (b1->buf == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb1->len = 0;\\r\\nb1->offset = 0;\\r\\n}\\r\\nif (b2->buf == NULL)\\r\\n{\\r\\nb2->buf = OPENSSL_malloc(b2->size);\\r\\nif (b2->buf == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb2->len = 0;\\r\\nb2->offset = 0;\\r\\n}\\r\\nb1->peer = bio2;\\r\\nb1->closed = 0;\\r\\nb1->request = 0;\\r\\nb2->peer = bio1;\\r\\nb2->closed = 0;\\r\\nb2->request = 0;\\r\\nbio1->init = 1;\\r\\nbio2->init = 1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void bio_destroy_pair(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nif (b != NULL)\\r\\n{\\r\\nBIO *peer_bio = b->peer;\\r\\nif (peer_bio != NULL)\\r\\n{\\r\\nstruct bio_bio_st *peer_b = peer_bio->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->peer == bio);\\r\\npeer_b->peer = NULL;\\r\\npeer_bio->init = 0;\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->len = 0;\\r\\npeer_b->offset = 0;\\r\\nb->peer = NULL;\\r\\nbio->init = 0;\\r\\nassert(b->buf != NULL);\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nint BIO_new_bio_pair(BIO **bio1_p, size_t writebuf1,\\r\\nBIO **bio2_p, size_t writebuf2)\\r\\n{\\r\\nBIO *bio1 = NULL, *bio2 = NULL;\\r\\nlong r;\\r\\nint ret = 0;\\r\\nbio1 = BIO_new(BIO_s_bio());\\r\\nif (bio1 == NULL)\\r\\ngoto err;\\r\\nbio2 = BIO_new(BIO_s_bio());\\r\\nif (bio2 == NULL)\\r\\ngoto err;\\r\\nif (writebuf1)\\r\\n{\\r\\nr = BIO_set_write_buf_size(bio1, writebuf1);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nif (writebuf2)\\r\\n{\\r\\nr = BIO_set_write_buf_size(bio2, writebuf2);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nr = BIO_make_bio_pair(bio1, bio2);\\r\\nif (!r)\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ret == 0)\\r\\n{\\r\\nif (bio1)\\r\\n{\\r\\nBIO_free(bio1);\\r\\nbio1 = NULL;\\r\\n}\\r\\nif (bio2)\\r\\n{\\r\\nBIO_free(bio2);\\r\\nbio2 = NULL;\\r\\n}\\r\\n}\\r\\n*bio1_p = bio1;\\r\\n*bio2_p = bio2;\\r\\nreturn ret;\\r\\n}\\r\\nsize_t BIO_ctrl_get_write_guarantee(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_WRITE_GUARANTEE, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_get_read_request(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_READ_REQUEST, 0, NULL);\\r\\n}\\r\\nint BIO_ctrl_reset_read_request(BIO *bio)\\r\\n{\\r\\nreturn (BIO_ctrl(bio, BIO_C_RESET_READ_REQUEST, 0, NULL) != 0);\\r\\n}\\r\\nint BIO_nread0(BIO *bio, char **buf)\\r\\n{\\r\\nlong ret;\\r\\nif (!bio->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NREAD0, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NREAD0, 0, buf);\\r\\nif (ret > INT_MAX)\\r\\nreturn INT_MAX;\\r\\nelse\\r\\nreturn (int) ret;\\r\\n}\\r\\nint BIO_nread(BIO *bio, char **buf, int num)\\r\\n{\\r\\nint ret;\\r\\nif (!bio->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NREAD, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = (int) BIO_ctrl(bio, BIO_C_NREAD, num, buf);\\r\\nif (ret > 0)\\r\\nbio->num_read += ret;\\r\\nreturn ret;\\r\\n}\\r\\nint BIO_nwrite0(BIO *bio, char **buf)\\r\\n{\\r\\nlong ret;\\r\\nif (!bio->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NWRITE0, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NWRITE0, 0, buf);\\r\\nif (ret > INT_MAX)\\r\\nreturn INT_MAX;\\r\\nelse\\r\\nreturn (int) ret;\\r\\n}\\r\\nint BIO_nwrite(BIO *bio, char **buf, int num)\\r\\n{\\r\\nint ret;\\r\\nif (!bio->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NWRITE, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NWRITE, num, buf);\\r\\nif (ret > 0)\\r\\nbio->num_read += ret;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_sha1_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return SHA1_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA1_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA1_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_sha1(void)\\r\\n{\\r\\nreturn(&sha1_md);\\r\\n}\\r\\nstatic int init224(EVP_MD_CTX *ctx)\\r\\n{ return SHA224_Init(ctx->md_data); }\\r\\nstatic int init256(EVP_MD_CTX *ctx)\\r\\n{ return SHA256_Init(ctx->md_data); }\\r\\nstatic int update256(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA256_Update(ctx->md_data,data,count); }\\r\\nstatic int final256(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA256_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_sha224(void)\\r\\n{ return(&sha224_md); }\\r\\nconst EVP_MD *EVP_sha256(void)\\r\\n{ return(&sha256_md); }\\r\\nstatic int init384(EVP_MD_CTX *ctx)\\r\\n{ return SHA384_Init(ctx->md_data); }\\r\\nstatic int init512(EVP_MD_CTX *ctx)\\r\\n{ return SHA512_Init(ctx->md_data); }\\r\\nstatic int update512(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return SHA512_Update(ctx->md_data,data,count); }\\r\\nstatic int final512(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return SHA512_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_sha384(void)\\r\\n{ return(&sha384_md); }\\r\\nconst EVP_MD *EVP_sha512(void)\\r\\n{ return(&sha512_md); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_read2pwd_c", "target": 0, "func": "int DES_read_password(DES_cblock *key, const char *prompt, int verify)\\r\\n{\\r\\nint ok;\\r\\nchar buf[BUFSIZ],buff[BUFSIZ];\\r\\nif ((ok=UI_UTIL_read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)\\r\\nDES_string_to_key(buf,key);\\r\\nOPENSSL_cleanse(buf,BUFSIZ);\\r\\nOPENSSL_cleanse(buff,BUFSIZ);\\r\\nreturn(ok);\\r\\n}\\r\\nint DES_read_2passwords(DES_cblock *key1, DES_cblock *key2, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nint ok;\\r\\nchar buf[BUFSIZ],buff[BUFSIZ];\\r\\nif ((ok=UI_UTIL_read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)\\r\\nDES_string_to_2keys(buf,key1,key2);\\r\\nOPENSSL_cleanse(buf,BUFSIZ);\\r\\nOPENSSL_cleanse(buff,BUFSIZ);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_err_c", "target": 0, "func": "void ERR_load_SSL_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,SSL_str_functs);\\r\\nERR_load_strings(0,SSL_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_dh_err_c", "target": 0, "func": "void ERR_load_DH_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,DH_str_functs);\\r\\nERR_load_strings(0,DH_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x_x509a_c", "target": 0, "func": "int X509_keyid_set1(X509 *x, unsigned char *id, int len)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nif (!id)\\r\\n{\\r\\nif (!x || !x->aux || !x->aux->keyid)\\r\\nreturn 1;\\r\\nASN1_OCTET_STRING_free(x->aux->keyid);\\r\\nx->aux->keyid = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nif(!(aux = aux_get(x))) return 0;\\r\\nif(!aux->keyid && !(aux->keyid = ASN1_OCTET_STRING_new())) return 0;\\r\\nreturn ASN1_STRING_set(aux->keyid, id, len);\\r\\n}\\r\\nunsigned char *X509_alias_get0(X509 *x, int *len)\\r\\n{\\r\\nif(!x->aux || !x->aux->alias) return NULL;\\r\\nif(len) *len = x->aux->alias->length;\\r\\nreturn x->aux->alias->data;\\r\\n}\\r\\nunsigned char *X509_keyid_get0(X509 *x, int *len)\\r\\n{\\r\\nif(!x->aux || !x->aux->keyid) return NULL;\\r\\nif(len) *len = x->aux->keyid->length;\\r\\nreturn x->aux->keyid->data;\\r\\n}\\r\\nint X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nASN1_OBJECT *objtmp;\\r\\nif(!(objtmp = OBJ_dup(obj))) return 0;\\r\\nif(!(aux = aux_get(x))) return 0;\\r\\nif(!aux->trust\\r\\n&& !(aux->trust = sk_ASN1_OBJECT_new_null())) return 0;\\r\\nreturn sk_ASN1_OBJECT_push(aux->trust, objtmp);\\r\\n}\\r\\nint X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nASN1_OBJECT *objtmp;\\r\\nif(!(objtmp = OBJ_dup(obj))) return 0;\\r\\nif(!(aux = aux_get(x))) return 0;\\r\\nif(!aux->reject\\r\\n&& !(aux->reject = sk_ASN1_OBJECT_new_null())) return 0;\\r\\nreturn sk_ASN1_OBJECT_push(aux->reject, objtmp);\\r\\n}\\r\\nvoid X509_trust_clear(X509 *x)\\r\\n{\\r\\nif(x->aux && x->aux->trust) {\\r\\nsk_ASN1_OBJECT_pop_free(x->aux->trust, ASN1_OBJECT_free);\\r\\nx->aux->trust = NULL;\\r\\n}\\r\\n}\\r\\nvoid X509_reject_clear(X509 *x)\\r\\n{\\r\\nif(x->aux && x->aux->reject) {\\r\\nsk_ASN1_OBJECT_pop_free(x->aux->reject, ASN1_OBJECT_free);\\r\\nx->aux->reject = NULL;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_stream_c", "target": 0, "func": "main()\\r\\n{\\r\\nfprintf(stderr,\"rc4\\n\");\\r\\nrc4();\\r\\nfprintf(stderr,\"cfb des\\n\");\\r\\ndes();\\r\\n}\\r\\nint des()\\r\\n{\\r\\ndes_key_schedule ks;\\r\\ndes_cblock iv,key;\\r\\nint num;\\r\\nstatic char *keystr=\"01234567\";\\r\\nstatic char *in1=\"0123456789ABCEDFdata 12345\";\\r\\nstatic char *in2=\"9876543210abcdefdata 12345\";\\r\\nunsigned char out[100];\\r\\nint i;\\r\\ndes_set_key((des_cblock *)keystr,ks);\\r\\nnum=0;\\r\\nmemset(iv,0,8);\\r\\ndes_cfb64_encrypt(in1,out,26,ks,(des_cblock *)iv,&num,1);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\nnum=0;\\r\\nmemset(iv,0,8);\\r\\ndes_cfb64_encrypt(in2,out,26,ks,(des_cblock *)iv,&num,1);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\nint rc4()\\r\\n{\\r\\nstatic char *keystr=\"0123456789abcdef\";\\r\\nRC4_KEY key;\\r\\nunsigned char in[100],out[100];\\r\\nint i;\\r\\nRC4_set_key(&key,16,keystr);\\r\\nin[0]='\\0';\\r\\nstrcpy(in,\"0123456789ABCEDFdata 12345\");\\r\\nRC4(key,26,in,out);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\nRC4_set_key(&key,16,keystr);\\r\\nin[0]='\\0';\\r\\nstrcpy(in,\"9876543210abcdefdata 12345\");\\r\\nRC4(key,26,in,out);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_LPdir_win_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nstruct dirent *direntry = NULL;\\r\\nif (ctx == NULL || directory == NULL)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL)\\r\\n{\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL)\\r\\n{\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\nif (sizeof(TCHAR) != sizeof(char))\\r\\n{\\r\\nTCHAR *wdir = NULL;\\r\\nsize_t index = 0,len_0 = strlen(directory) + 1;\\r\\nwdir = (TCHAR *)malloc(len_0 * sizeof(TCHAR));\\r\\nif (wdir == NULL)\\r\\n{\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef LP_MULTIBYTE_AVAILABLE\\r\\nif (!MultiByteToWideChar(CP_ACP, 0, directory, len_0, (WCHAR *)wdir, len_0))\\r\\n#endif\\r\\nfor (index = 0; index < len_0; index++)\\r\\nwdir[index] = (TCHAR)directory[index];\\r\\n(*ctx)->handle = FindFirstFile(wdir, &(*ctx)->ctx);\\r\\nfree(wdir);\\r\\n}\\r\\nelse\\r\\n(*ctx)->handle = FindFirstFile((TCHAR *)directory, &(*ctx)->ctx);\\r\\nif ((*ctx)->handle == INVALID_HANDLE_VALUE)\\r\\n{\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (FindNextFile((*ctx)->handle, &(*ctx)->ctx) == FALSE)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (sizeof(TCHAR) != sizeof(char))\\r\\n{\\r\\nTCHAR *wdir = (*ctx)->ctx.cFileName;\\r\\nsize_t index, len_0 = 0;\\r\\nwhile (wdir[len_0] && len_0 < (sizeof((*ctx)->entry_name) - 1)) len_0++;\\r\\nlen_0++;\\r\\n#ifdef LP_MULTIBYTE_AVAILABLE\\r\\nif (!WideCharToMultiByte(CP_ACP, 0, (WCHAR *)wdir, len_0, (*ctx)->entry_name,\\r\\nsizeof((*ctx)->entry_name), NULL, 0))\\r\\n#endif\\r\\nfor (index = 0; index < len_0; index++)\\r\\n(*ctx)->entry_name[index] = (char)wdir[index];\\r\\n}\\r\\nelse\\r\\nstrncpy((*ctx)->entry_name, (const char *)(*ctx)->ctx.cFileName,\\r\\nsizeof((*ctx)->entry_name)-1);\\r\\n(*ctx)->entry_name[sizeof((*ctx)->entry_name)-1] = '\\0';\\r\\nreturn (*ctx)->entry_name;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL)\\r\\n{\\r\\nFindClose((*ctx)->handle);\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p5_crpt_c", "target": 0, "func": "void PKCS5_PBE_add(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DES\\r\\n# ifndef OPENSSL_NO_MD5\\r\\nEVP_PBE_alg_add(NID_pbeWithMD5AndDES_CBC, EVP_des_cbc(), EVP_md5(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_MD2\\r\\nEVP_PBE_alg_add(NID_pbeWithMD2AndDES_CBC, EVP_des_cbc(), EVP_md2(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SHA\\r\\nEVP_PBE_alg_add(NID_pbeWithSHA1AndDES_CBC, EVP_des_cbc(), EVP_sha1(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\n# ifndef OPENSSL_NO_MD5\\r\\nEVP_PBE_alg_add(NID_pbeWithMD5AndRC2_CBC, EVP_rc2_64_cbc(), EVP_md5(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_MD2\\r\\nEVP_PBE_alg_add(NID_pbeWithMD2AndRC2_CBC, EVP_rc2_64_cbc(), EVP_md2(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SHA\\r\\nEVP_PBE_alg_add(NID_pbeWithSHA1AndRC2_CBC, EVP_rc2_64_cbc(), EVP_sha1(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_HMAC\\r\\nEVP_PBE_alg_add(NID_pbes2, NULL, NULL, PKCS5_v2_PBE_keyivgen);\\r\\n#endif\\r\\n}\\r\\nint PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md,\\r\\nint en_de)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char md_tmp[EVP_MAX_MD_SIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\nint i;\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter;\\r\\nunsigned char *salt;\\r\\nconst unsigned char *pbuf;\\r\\npbuf = param->value.sequence->data;\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe = d2i_PBEPARAM (NULL, &pbuf, param->value.sequence->length))) {\\r\\nEVPerr(EVP_F_PKCS5_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nif(!pass) passlen = 0;\\r\\nelse if(passlen == -1) passlen = strlen(pass);\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_DigestInit_ex(&ctx, md, NULL);\\r\\nEVP_DigestUpdate(&ctx, pass, passlen);\\r\\nEVP_DigestUpdate(&ctx, salt, saltlen);\\r\\nPBEPARAM_free(pbe);\\r\\nEVP_DigestFinal_ex(&ctx, md_tmp, NULL);\\r\\nfor (i = 1; i < iter; i++) {\\r\\nEVP_DigestInit_ex(&ctx, md, NULL);\\r\\nEVP_DigestUpdate(&ctx, md_tmp, EVP_MD_size(md));\\r\\nEVP_DigestFinal_ex (&ctx, md_tmp, NULL);\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nOPENSSL_assert(EVP_CIPHER_key_length(cipher) <= (int)sizeof(md_tmp));\\r\\nmemcpy(key, md_tmp, EVP_CIPHER_key_length(cipher));\\r\\nOPENSSL_assert(EVP_CIPHER_iv_length(cipher) <= 16);\\r\\nmemcpy(iv, md_tmp + (16 - EVP_CIPHER_iv_length(cipher)),\\r\\nEVP_CIPHER_iv_length(cipher));\\r\\nEVP_CipherInit_ex(cctx, cipher, NULL, key, iv, en_de);\\r\\nOPENSSL_cleanse(md_tmp, EVP_MAX_MD_SIZE);\\r\\nOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_hw_cluster_labs_err_c", "target": 0, "func": "static void ERR_load_CL_strings(void)\\r\\n{\\r\\nif (CL_lib_error_code == 0)\\r\\nCL_lib_error_code=ERR_get_next_error_library();\\r\\nif (CL_error_init)\\r\\n{\\r\\nCL_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(CL_lib_error_code,CL_str_functs);\\r\\nERR_load_strings(CL_lib_error_code,CL_str_reasons);\\r\\n#endif\\r\\n#ifdef CL_LIB_NAME\\r\\nCL_lib_name->error = ERR_PACK(CL_lib_error_code,0,0);\\r\\nERR_load_strings(0,CL_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_CL_strings(void)\\r\\n{\\r\\nif (CL_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(CL_lib_error_code,CL_str_functs);\\r\\nERR_unload_strings(CL_lib_error_code,CL_str_reasons);\\r\\n#endif\\r\\n#ifdef CL_LIB_NAME\\r\\nERR_unload_strings(0,CL_lib_name);\\r\\n#endif\\r\\nCL_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_CL_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (CL_lib_error_code == 0)\\r\\nCL_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(CL_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ssl_algs_c", "target": 0, "func": "int SSL_library_init(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DES\\r\\nEVP_add_cipher(EVP_des_cbc());\\r\\nEVP_add_cipher(EVP_des_ede3_cbc());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nEVP_add_cipher(EVP_idea_cbc());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nEVP_add_cipher(EVP_rc4());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nEVP_add_cipher(EVP_rc2_cbc());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nEVP_add_cipher(EVP_aes_128_cbc());\\r\\nEVP_add_cipher(EVP_aes_192_cbc());\\r\\nEVP_add_cipher(EVP_aes_256_cbc());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD2\\r\\nEVP_add_digest(EVP_md2());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest_alias(SN_md5,\"ssl2-md5\");\\r\\nEVP_add_digest_alias(SN_md5,\"ssl3-md5\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");\\r\\nEVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)\\r\\nEVP_add_digest(EVP_dss1());\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"DSS1\");\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"dss1\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nEVP_add_digest(EVP_ecdsa());\\r\\n#endif\\r\\n#if 0\\r\\nEVP_add_digest(EVP_sha());\\r\\nEVP_add_digest(EVP_dss());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_COMP\\r\\n(void)SSL_COMP_get_compression_methods();\\r\\n#endif\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_err_c", "target": 0, "func": "void ERR_load_X509_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(0,X509_str_functs);\\r\\nERR_load_strings(0,X509_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_mbstr_c", "target": 0, "func": "int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,\\r\\nint inform, unsigned long mask)\\r\\n{\\r\\nreturn ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);\\r\\n}\\r\\nint ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,\\r\\nint inform, unsigned long mask,\\r\\nlong minsize, long maxsize)\\r\\n{\\r\\nint str_type;\\r\\nint ret;\\r\\nchar free_out;\\r\\nint outform, outlen;\\r\\nASN1_STRING *dest;\\r\\nunsigned char *p;\\r\\nint nchar;\\r\\nchar strbuf[32];\\r\\nint (*cpyfunc)(unsigned long,void *) = NULL;\\r\\nif(len == -1) len = strlen((const char *)in);\\r\\nif(!mask) mask = DIRSTRING_TYPE;\\r\\nswitch(inform) {\\r\\ncase MBSTRING_BMP:\\r\\nif(len & 1) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nASN1_R_INVALID_BMPSTRING_LENGTH);\\r\\nreturn -1;\\r\\n}\\r\\nnchar = len >> 1;\\r\\nbreak;\\r\\ncase MBSTRING_UNIV:\\r\\nif(len & 3) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nASN1_R_INVALID_UNIVERSALSTRING_LENGTH);\\r\\nreturn -1;\\r\\n}\\r\\nnchar = len >> 2;\\r\\nbreak;\\r\\ncase MBSTRING_UTF8:\\r\\nnchar = 0;\\r\\nret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &nchar);\\r\\nif(ret < 0) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nASN1_R_INVALID_UTF8STRING);\\r\\nreturn -1;\\r\\n}\\r\\nbreak;\\r\\ncase MBSTRING_ASC:\\r\\nnchar = len;\\r\\nbreak;\\r\\ndefault:\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);\\r\\nreturn -1;\\r\\n}\\r\\nif((minsize > 0) && (nchar < minsize)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);\\r\\nBIO_snprintf(strbuf, sizeof strbuf, \"%ld\", minsize);\\r\\nERR_add_error_data(2, \"minsize=\", strbuf);\\r\\nreturn -1;\\r\\n}\\r\\nif((maxsize > 0) && (nchar > maxsize)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);\\r\\nBIO_snprintf(strbuf, sizeof strbuf, \"%ld\", maxsize);\\r\\nERR_add_error_data(2, \"maxsize=\", strbuf);\\r\\nreturn -1;\\r\\n}\\r\\nif(traverse_string(in, len, inform, type_str, &mask) < 0) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);\\r\\nreturn -1;\\r\\n}\\r\\noutform = MBSTRING_ASC;\\r\\nif(mask & B_ASN1_PRINTABLESTRING) str_type = V_ASN1_PRINTABLESTRING;\\r\\nelse if(mask & B_ASN1_IA5STRING) str_type = V_ASN1_IA5STRING;\\r\\nelse if(mask & B_ASN1_T61STRING) str_type = V_ASN1_T61STRING;\\r\\nelse if(mask & B_ASN1_BMPSTRING) {\\r\\nstr_type = V_ASN1_BMPSTRING;\\r\\noutform = MBSTRING_BMP;\\r\\n} else if(mask & B_ASN1_UNIVERSALSTRING) {\\r\\nstr_type = V_ASN1_UNIVERSALSTRING;\\r\\noutform = MBSTRING_UNIV;\\r\\n} else {\\r\\nstr_type = V_ASN1_UTF8STRING;\\r\\noutform = MBSTRING_UTF8;\\r\\n}\\r\\nif(!out) return str_type;\\r\\nif(*out) {\\r\\nfree_out = 0;\\r\\ndest = *out;\\r\\nif(dest->data) {\\r\\ndest->length = 0;\\r\\nOPENSSL_free(dest->data);\\r\\ndest->data = NULL;\\r\\n}\\r\\ndest->type = str_type;\\r\\n} else {\\r\\nfree_out = 1;\\r\\ndest = ASN1_STRING_type_new(str_type);\\r\\nif(!dest) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n*out = dest;\\r\\n}\\r\\nif(inform == outform) {\\r\\nif(!ASN1_STRING_set(dest, in, len)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nreturn str_type;\\r\\n}\\r\\nswitch(outform) {\\r\\ncase MBSTRING_ASC:\\r\\noutlen = nchar;\\r\\ncpyfunc = cpy_asc;\\r\\nbreak;\\r\\ncase MBSTRING_BMP:\\r\\noutlen = nchar << 1;\\r\\ncpyfunc = cpy_bmp;\\r\\nbreak;\\r\\ncase MBSTRING_UNIV:\\r\\noutlen = nchar << 2;\\r\\ncpyfunc = cpy_univ;\\r\\nbreak;\\r\\ncase MBSTRING_UTF8:\\r\\noutlen = 0;\\r\\ntraverse_string(in, len, inform, out_utf8, &outlen);\\r\\ncpyfunc = cpy_utf8;\\r\\nbreak;\\r\\n}\\r\\nif(!(p = OPENSSL_malloc(outlen + 1))) {\\r\\nif(free_out) ASN1_STRING_free(dest);\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\ndest->length = outlen;\\r\\ndest->data = p;\\r\\np[outlen] = 0;\\r\\ntraverse_string(in, len, inform, cpyfunc, &p);\\r\\nreturn str_type;\\r\\n}\\r\\nstatic int traverse_string(const unsigned char *p, int len, int inform,\\r\\nint (*rfunc)(unsigned long value, void *in), void *arg)\\r\\n{\\r\\nunsigned long value;\\r\\nint ret;\\r\\nwhile(len) {\\r\\nif(inform == MBSTRING_ASC) {\\r\\nvalue = *p++;\\r\\nlen--;\\r\\n} else if(inform == MBSTRING_BMP) {\\r\\nvalue = *p++ << 8;\\r\\nvalue |= *p++;\\r\\nlen -= 2;\\r\\n} else if(inform == MBSTRING_UNIV) {\\r\\nvalue = ((unsigned long)*p++) << 24;\\r\\nvalue |= ((unsigned long)*p++) << 16;\\r\\nvalue |= *p++ << 8;\\r\\nvalue |= *p++;\\r\\nlen -= 4;\\r\\n} else {\\r\\nret = UTF8_getc(p, len, &value);\\r\\nif(ret < 0) return -1;\\r\\nlen -= ret;\\r\\np += ret;\\r\\n}\\r\\nif(rfunc) {\\r\\nret = rfunc(value, arg);\\r\\nif(ret <= 0) return ret;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int in_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nint *nchar;\\r\\nnchar = arg;\\r\\n(*nchar)++;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int out_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nint *outlen;\\r\\noutlen = arg;\\r\\n*outlen += UTF8_putc(NULL, -1, value);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int type_str(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned long types;\\r\\ntypes = *((unsigned long *)arg);\\r\\nif((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\\r\\ntypes &= ~B_ASN1_PRINTABLESTRING;\\r\\nif((types & B_ASN1_IA5STRING) && (value > 127))\\r\\ntypes &= ~B_ASN1_IA5STRING;\\r\\nif((types & B_ASN1_T61STRING) && (value > 0xff))\\r\\ntypes &= ~B_ASN1_T61STRING;\\r\\nif((types & B_ASN1_BMPSTRING) && (value > 0xffff))\\r\\ntypes &= ~B_ASN1_BMPSTRING;\\r\\nif(!types) return -1;\\r\\n*((unsigned long *)arg) = types;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_asc(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q = (unsigned char) value;\\r\\n(*p)++;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_bmp(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q++ = (unsigned char) ((value >> 8) & 0xff);\\r\\n*q = (unsigned char) (value & 0xff);\\r\\n*p += 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_univ(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q++ = (unsigned char) ((value >> 24) & 0xff);\\r\\n*q++ = (unsigned char) ((value >> 16) & 0xff);\\r\\n*q++ = (unsigned char) ((value >> 8) & 0xff);\\r\\n*q = (unsigned char) (value & 0xff);\\r\\n*p += 4;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p;\\r\\nint ret;\\r\\np = arg;\\r\\nret = UTF8_putc(*p, 0xff, value);\\r\\n*p += ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int is_printable(unsigned long value)\\r\\n{\\r\\nint ch;\\r\\nif(value > 0x7f) return 0;\\r\\nch = (int) value;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif((ch >= 'a') && (ch <= 'z')) return 1;\\r\\nif((ch >= 'A') && (ch <= 'Z')) return 1;\\r\\nif((ch >= '0') && (ch <= '9')) return 1;\\r\\nif ((ch == ' ') || strchr(\"'()+,-./:=?\", ch)) return 1;\\r\\n#else\\r\\nif((ch >= os_toascii['a']) && (ch <= os_toascii['z'])) return 1;\\r\\nif((ch >= os_toascii['A']) && (ch <= os_toascii['Z'])) return 1;\\r\\nif((ch >= os_toascii['0']) && (ch <= os_toascii['9'])) return 1;\\r\\nif ((ch == os_toascii[' ']) || strchr(\"'()+,-./:=?\", os_toebcdic[ch])) return 1;\\r\\n#endif\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_p_open_c", "target": 0, "func": "int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\\r\\nconst unsigned char *ek, int ekl, const unsigned char *iv,\\r\\nEVP_PKEY *priv)\\r\\n{\\r\\nunsigned char *key=NULL;\\r\\nint i,size=0,ret=0;\\r\\nif(type) {\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nif(!EVP_DecryptInit_ex(ctx,type,NULL, NULL,NULL)) return 0;\\r\\n}\\r\\nif(!priv) return 1;\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_OPENINIT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\ngoto err;\\r\\n}\\r\\nsize=RSA_size(priv->pkey.rsa);\\r\\nkey=(unsigned char *)OPENSSL_malloc(size+2);\\r\\nif (key == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_OPENINIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=EVP_PKEY_decrypt(key,ek,ekl,priv);\\r\\nif ((i <= 0) || !EVP_CIPHER_CTX_set_key_length(ctx, i))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\nif(!EVP_DecryptInit_ex(ctx,NULL,NULL,key,iv)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (key != NULL) OPENSSL_cleanse(key,size);\\r\\nOPENSSL_free(key);\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\ni=EVP_DecryptFinal_ex(ctx,out,outl);\\r\\nEVP_DecryptInit_ex(ctx,NULL,NULL,NULL,NULL);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_x509_v3_c", "target": 0, "func": "int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit)\\r\\n{\\r\\nif (ex == NULL) return(0);\\r\\nex->critical=(crit)?0xFF:-1;\\r\\nreturn(1);\\r\\n}\\r\\nint X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data)\\r\\n{\\r\\nint i;\\r\\nif (ex == NULL) return(0);\\r\\ni=M_ASN1_OCTET_STRING_set(ex->value,data->data,data->length);\\r\\nif (!i) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(NULL);\\r\\nreturn(ex->object);\\r\\n}\\r\\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(NULL);\\r\\nreturn(ex->value);\\r\\n}\\r\\nint X509_EXTENSION_get_critical(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(0);\\r\\nif(ex->critical > 0) return 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_example4_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nif ((argc == 1))\\r\\n{\\r\\ndo_encode();\\r\\n}\\r\\nelse if ((argc == 2) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\ndo_decode();\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"%s\", usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid do_encode()\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN+24];\\r\\nunsigned int ebuflen;\\r\\nEVP_ENCODE_CTX ectx;\\r\\nEVP_EncodeInit(&ectx);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nEVP_EncodeUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_EncodeFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nvoid do_decode()\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN+24];\\r\\nunsigned int ebuflen;\\r\\nEVP_ENCODE_CTX ectx;\\r\\nEVP_DecodeInit(&ectx);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nint rc;\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nrc = EVP_DecodeUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nif (rc <= 0)\\r\\n{\\r\\nif (!rc)\\r\\n{\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\nbreak;\\r\\n}\\r\\nfprintf(stderr, \"Error: decoding message\\n\");\\r\\nreturn;\\r\\n}\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_DecodeFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_rc5_c", "target": 0, "func": "static int rc5_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch(type)\\r\\n{\\r\\ncase EVP_CTRL_INIT:\\r\\ndata(c)->rounds = RC5_12_ROUNDS;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GET_RC5_ROUNDS:\\r\\n*(int *)ptr = data(c)->rounds;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_SET_RC5_ROUNDS:\\r\\nswitch(arg)\\r\\n{\\r\\ncase RC5_8_ROUNDS:\\r\\ncase RC5_12_ROUNDS:\\r\\ncase RC5_16_ROUNDS:\\r\\ndata(c)->rounds = arg;\\r\\nreturn 1;\\r\\ndefault:\\r\\nEVPerr(EVP_F_RC5_CTRL, EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS);\\r\\nreturn 0;\\r\\n}\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nstatic int r_32_12_16_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC5_32_set_key(&data(ctx)->ks,EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,data(ctx)->rounds);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_err_c", "target": 0, "func": "static void err_fns_check(void)\\r\\n{\\r\\nif (err_fns) return;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!err_fns)\\r\\nerr_fns = &err_defaults;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nconst ERR_FNS *ERR_get_implementation(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn err_fns;\\r\\n}\\r\\nint ERR_set_implementation(const ERR_FNS *fns)\\r\\n{\\r\\nint ret = 0;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!err_fns)\\r\\n{\\r\\nerr_fns = fns;\\r\\nret = 1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic LHASH *int_err_get(int create)\\r\\n{\\r\\nLHASH *ret = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!int_error_hash && create)\\r\\n{\\r\\nCRYPTO_push_info(\"int_err_get (err.c)\");\\r\\nint_error_hash = lh_new(err_hash, err_cmp);\\r\\nCRYPTO_pop_info();\\r\\n}\\r\\nif (int_error_hash)\\r\\nret = int_error_hash;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void int_err_del(void)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (int_error_hash)\\r\\n{\\r\\nlh_free(int_error_hash);\\r\\nint_error_hash = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get)(0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STRING_DATA *)lh_retrieve(hash, d);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get)(1);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STRING_DATA *)lh_insert(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get)(0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STRING_DATA *)lh_delete(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic LHASH *int_thread_get(int create)\\r\\n{\\r\\nLHASH *ret = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!int_thread_hash && create)\\r\\n{\\r\\nCRYPTO_push_info(\"int_thread_get (err.c)\");\\r\\nint_thread_hash = lh_new(pid_hash, pid_cmp);\\r\\nCRYPTO_pop_info();\\r\\n}\\r\\nif (int_thread_hash)\\r\\n{\\r\\nint_thread_hash_references++;\\r\\nret = int_thread_hash;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void int_thread_release(LHASH **hash)\\r\\n{\\r\\nint i;\\r\\nif (hash == NULL || *hash == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);\\r\\n#ifdef REF_PRINT\\r\\nfprintf(stderr,\"%4d:%s\\n\",int_thread_hash_references,\"ERR\");\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"int_thread_release, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n*hash = NULL;\\r\\n}\\r\\nstatic ERR_STATE *int_thread_get_item(const ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get)(0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STATE *)lh_retrieve(hash, d);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release)(&hash);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STATE *int_thread_set_item(ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get)(1);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STATE *)lh_insert(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release)(&hash);\\r\\nreturn p;\\r\\n}\\r\\nstatic void int_thread_del_item(const ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get)(0);\\r\\nif (!hash)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = (ERR_STATE *)lh_delete(hash, d);\\r\\nif (int_thread_hash_references == 1\\r\\n&& int_thread_hash && (lh_num_items(int_thread_hash) == 0))\\r\\n{\\r\\nlh_free(int_thread_hash);\\r\\nint_thread_hash = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release)(&hash);\\r\\nif (p)\\r\\nERR_STATE_free(p);\\r\\n}\\r\\nstatic int int_err_get_next_lib(void)\\r\\n{\\r\\nint ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nret = int_err_library_number++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void build_SYS_str_reasons(void)\\r\\n{\\r\\nstatic char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];\\r\\nint i;\\r\\nstatic int init = 1;\\r\\nif (!init) return;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nfor (i = 1; i <= NUM_SYS_STR_REASONS; i++)\\r\\n{\\r\\nERR_STRING_DATA *str = &SYS_str_reasons[i - 1];\\r\\nstr->error = (unsigned long)i;\\r\\nif (str->string == NULL)\\r\\n{\\r\\nchar (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);\\r\\nchar *src = strerror(i);\\r\\nif (src != NULL)\\r\\n{\\r\\nstrncpy(*dest, src, sizeof *dest);\\r\\n(*dest)[sizeof *dest - 1] = '\\0';\\r\\nstr->string = *dest;\\r\\n}\\r\\n}\\r\\nif (str->string == NULL)\\r\\nstr->string = \"unknown\";\\r\\n}\\r\\ninit = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nstatic void ERR_STATE_free(ERR_STATE *s)\\r\\n{\\r\\nint i;\\r\\nif (s == NULL)\\r\\nreturn;\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nerr_clear_data(s,i);\\r\\n}\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nvoid ERR_load_ERR_strings(void)\\r\\n{\\r\\nerr_fns_check();\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nerr_load_strings(0,ERR_str_libraries);\\r\\nerr_load_strings(0,ERR_str_reasons);\\r\\nerr_load_strings(ERR_LIB_SYS,ERR_str_functs);\\r\\nbuild_SYS_str_reasons();\\r\\nerr_load_strings(ERR_LIB_SYS,SYS_str_reasons);\\r\\n#endif\\r\\n}\\r\\nstatic void err_load_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nwhile (str->error)\\r\\n{\\r\\nif (lib)\\r\\nstr->error|=ERR_PACK(lib,0,0);\\r\\nERRFN(err_set_item)(str);\\r\\nstr++;\\r\\n}\\r\\n}\\r\\nvoid ERR_load_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nERR_load_ERR_strings();\\r\\nerr_load_strings(lib, str);\\r\\n}\\r\\nvoid ERR_unload_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nwhile (str->error)\\r\\n{\\r\\nif (lib)\\r\\nstr->error|=ERR_PACK(lib,0,0);\\r\\nERRFN(err_del_item)(str);\\r\\nstr++;\\r\\n}\\r\\n}\\r\\nvoid ERR_free_strings(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nERRFN(err_del)();\\r\\n}\\r\\nvoid ERR_put_error(int lib, int func, int reason, const char *file,\\r\\nint line)\\r\\n{\\r\\nERR_STATE *es;\\r\\n#ifdef _OSD_POSIX\\r\\nif (strncmp(file,\"*POSIX(\", sizeof(\"*POSIX(\")-1) == 0) {\\r\\nchar *end;\\r\\nfile += sizeof(\"*POSIX(\")-1;\\r\\nend = &file[strlen(file)-1];\\r\\nif (*end == ')')\\r\\n*end = '\\0';\\r\\nif ((end = strrchr(file, '/')) != NULL)\\r\\nfile = &end[1];\\r\\n}\\r\\n#endif\\r\\nes=ERR_get_state();\\r\\nes->top=(es->top+1)%ERR_NUM_ERRORS;\\r\\nif (es->top == es->bottom)\\r\\nes->bottom=(es->bottom+1)%ERR_NUM_ERRORS;\\r\\nes->err_flags[es->top]=0;\\r\\nes->err_buffer[es->top]=ERR_PACK(lib,func,reason);\\r\\nes->err_file[es->top]=file;\\r\\nes->err_line[es->top]=line;\\r\\nerr_clear_data(es,es->top);\\r\\n}\\r\\nvoid ERR_clear_error(void)\\r\\n{\\r\\nint i;\\r\\nERR_STATE *es;\\r\\nes=ERR_get_state();\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nerr_clear(es,i);\\r\\n}\\r\\nes->top=es->bottom=0;\\r\\n}\\r\\nunsigned long ERR_get_error(void)\\r\\n{ return(get_error_values(1,0,NULL,NULL,NULL,NULL)); }\\r\\nunsigned long ERR_get_error_line(const char **file,\\r\\nint *line)\\r\\n{ return(get_error_values(1,0,file,line,NULL,NULL)); }\\r\\nunsigned long ERR_get_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{ return(get_error_values(1,0,file,line,data,flags)); }\\r\\nunsigned long ERR_peek_error(void)\\r\\n{ return(get_error_values(0,0,NULL,NULL,NULL,NULL)); }\\r\\nunsigned long ERR_peek_error_line(const char **file, int *line)\\r\\n{ return(get_error_values(0,0,file,line,NULL,NULL)); }\\r\\nunsigned long ERR_peek_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{ return(get_error_values(0,0,file,line,data,flags)); }\\r\\nunsigned long ERR_peek_last_error(void)\\r\\n{ return(get_error_values(0,1,NULL,NULL,NULL,NULL)); }\\r\\nunsigned long ERR_peek_last_error_line(const char **file, int *line)\\r\\n{ return(get_error_values(0,1,file,line,NULL,NULL)); }\\r\\nunsigned long ERR_peek_last_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{ return(get_error_values(0,1,file,line,data,flags)); }\\r\\nstatic unsigned long get_error_values(int inc, int top, const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{\\r\\nint i=0;\\r\\nERR_STATE *es;\\r\\nunsigned long ret;\\r\\nes=ERR_get_state();\\r\\nif (inc && top)\\r\\n{\\r\\nif (file) *file = \"\";\\r\\nif (line) *line = 0;\\r\\nif (data) *data = \"\";\\r\\nif (flags) *flags = 0;\\r\\nreturn ERR_R_INTERNAL_ERROR;\\r\\n}\\r\\nif (es->bottom == es->top) return 0;\\r\\nif (top)\\r\\ni=es->top;\\r\\nelse\\r\\ni=(es->bottom+1)%ERR_NUM_ERRORS;\\r\\nret=es->err_buffer[i];\\r\\nif (inc)\\r\\n{\\r\\nes->bottom=i;\\r\\nes->err_buffer[i]=0;\\r\\n}\\r\\nif ((file != NULL) && (line != NULL))\\r\\n{\\r\\nif (es->err_file[i] == NULL)\\r\\n{\\r\\n*file=\"NA\";\\r\\nif (line != NULL) *line=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*file=es->err_file[i];\\r\\nif (line != NULL) *line=es->err_line[i];\\r\\n}\\r\\n}\\r\\nif (data == NULL)\\r\\n{\\r\\nif (inc)\\r\\n{\\r\\nerr_clear_data(es, i);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (es->err_data[i] == NULL)\\r\\n{\\r\\n*data=\"\";\\r\\nif (flags != NULL) *flags=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*data=es->err_data[i];\\r\\nif (flags != NULL) *flags=es->err_data_flags[i];\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ERR_error_string_n(unsigned long e, char *buf, size_t len)\\r\\n{\\r\\nchar lsbuf[64], fsbuf[64], rsbuf[64];\\r\\nconst char *ls,*fs,*rs;\\r\\nunsigned long l,f,r;\\r\\nl=ERR_GET_LIB(e);\\r\\nf=ERR_GET_FUNC(e);\\r\\nr=ERR_GET_REASON(e);\\r\\nls=ERR_lib_error_string(e);\\r\\nfs=ERR_func_error_string(e);\\r\\nrs=ERR_reason_error_string(e);\\r\\nif (ls == NULL)\\r\\nBIO_snprintf(lsbuf, sizeof(lsbuf), \"lib(%lu)\", l);\\r\\nif (fs == NULL)\\r\\nBIO_snprintf(fsbuf, sizeof(fsbuf), \"func(%lu)\", f);\\r\\nif (rs == NULL)\\r\\nBIO_snprintf(rsbuf, sizeof(rsbuf), \"reason(%lu)\", r);\\r\\nBIO_snprintf(buf, len,\"error:%08lX:%s:%s:%s\", e, ls?ls:lsbuf,\\r\\nfs?fs:fsbuf, rs?rs:rsbuf);\\r\\nif (strlen(buf) == len-1)\\r\\n{\\r\\n#define NUM_COLONS 4\\r\\nif (len > NUM_COLONS)\\r\\n{\\r\\nint i;\\r\\nchar *s = buf;\\r\\nfor (i = 0; i < NUM_COLONS; i++)\\r\\n{\\r\\nchar *colon = strchr(s, ':');\\r\\nif (colon == NULL || colon > &buf[len-1] - NUM_COLONS + i)\\r\\n{\\r\\ncolon = &buf[len-1] - NUM_COLONS + i;\\r\\n*colon = ':';\\r\\n}\\r\\ns = colon + 1;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nchar *ERR_error_string(unsigned long e, char *ret)\\r\\n{\\r\\nstatic char buf[256];\\r\\nif (ret == NULL) ret=buf;\\r\\nERR_error_string_n(e, ret, 256);\\r\\nreturn ret;\\r\\n}\\r\\nLHASH *ERR_get_string_table(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn ERRFN(err_get)(0);\\r\\n}\\r\\nLHASH *ERR_get_err_state_table(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn ERRFN(thread_get)(0);\\r\\n}\\r\\nvoid ERR_release_err_state_table(LHASH **hash)\\r\\n{\\r\\nerr_fns_check();\\r\\nERRFN(thread_release)(hash);\\r\\n}\\r\\nconst char *ERR_lib_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p;\\r\\nunsigned long l;\\r\\nerr_fns_check();\\r\\nl=ERR_GET_LIB(e);\\r\\nd.error=ERR_PACK(l,0,0);\\r\\np=ERRFN(err_get_item)(&d);\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nconst char *ERR_func_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p;\\r\\nunsigned long l,f;\\r\\nerr_fns_check();\\r\\nl=ERR_GET_LIB(e);\\r\\nf=ERR_GET_FUNC(e);\\r\\nd.error=ERR_PACK(l,f,0);\\r\\np=ERRFN(err_get_item)(&d);\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nconst char *ERR_reason_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p=NULL;\\r\\nunsigned long l,r;\\r\\nerr_fns_check();\\r\\nl=ERR_GET_LIB(e);\\r\\nr=ERR_GET_REASON(e);\\r\\nd.error=ERR_PACK(l,0,r);\\r\\np=ERRFN(err_get_item)(&d);\\r\\nif (!p)\\r\\n{\\r\\nd.error=ERR_PACK(0,0,r);\\r\\np=ERRFN(err_get_item)(&d);\\r\\n}\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nstatic unsigned long err_hash(const void *a_void)\\r\\n{\\r\\nunsigned long ret,l;\\r\\nl=((const ERR_STRING_DATA *)a_void)->error;\\r\\nret=l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);\\r\\nreturn(ret^ret%19*13);\\r\\n}\\r\\nstatic int err_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nreturn((int)(((const ERR_STRING_DATA *)a_void)->error -\\r\\n((const ERR_STRING_DATA *)b_void)->error));\\r\\n}\\r\\nstatic unsigned long pid_hash(const void *a_void)\\r\\n{\\r\\nreturn(((const ERR_STATE *)a_void)->pid*13);\\r\\n}\\r\\nstatic int pid_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nreturn((int)((long)((const ERR_STATE *)a_void)->pid -\\r\\n(long)((const ERR_STATE *)b_void)->pid));\\r\\n}\\r\\nvoid ERR_remove_state(unsigned long pid)\\r\\n{\\r\\nERR_STATE tmp;\\r\\nerr_fns_check();\\r\\nif (pid == 0)\\r\\npid=(unsigned long)CRYPTO_thread_id();\\r\\ntmp.pid=pid;\\r\\nERRFN(thread_del_item)(&tmp);\\r\\n}\\r\\nERR_STATE *ERR_get_state(void)\\r\\n{\\r\\nstatic ERR_STATE fallback;\\r\\nERR_STATE *ret,tmp,*tmpp=NULL;\\r\\nint i;\\r\\nunsigned long pid;\\r\\nerr_fns_check();\\r\\npid=(unsigned long)CRYPTO_thread_id();\\r\\ntmp.pid=pid;\\r\\nret=ERRFN(thread_get_item)(&tmp);\\r\\nif (ret == NULL)\\r\\n{\\r\\nret=(ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));\\r\\nif (ret == NULL) return(&fallback);\\r\\nret->pid=pid;\\r\\nret->top=0;\\r\\nret->bottom=0;\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nret->err_data[i]=NULL;\\r\\nret->err_data_flags[i]=0;\\r\\n}\\r\\ntmpp = ERRFN(thread_set_item)(ret);\\r\\nif (ERRFN(thread_get_item)(ret) != ret)\\r\\n{\\r\\nERR_STATE_free(ret);\\r\\nreturn(&fallback);\\r\\n}\\r\\nif (tmpp)\\r\\nERR_STATE_free(tmpp);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ERR_get_next_error_library(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn ERRFN(get_next_lib)();\\r\\n}\\r\\nvoid ERR_set_error_data(char *data, int flags)\\r\\n{\\r\\nERR_STATE *es;\\r\\nint i;\\r\\nes=ERR_get_state();\\r\\ni=es->top;\\r\\nif (i == 0)\\r\\ni=ERR_NUM_ERRORS-1;\\r\\nerr_clear_data(es,i);\\r\\nes->err_data[i]=data;\\r\\nes->err_data_flags[i]=flags;\\r\\n}\\r\\nvoid ERR_add_error_data(int num, ...)\\r\\n{\\r\\nva_list args;\\r\\nint i,n,s;\\r\\nchar *str,*p,*a;\\r\\ns=80;\\r\\nstr=OPENSSL_malloc(s+1);\\r\\nif (str == NULL) return;\\r\\nstr[0]='\\0';\\r\\nva_start(args, num);\\r\\nn=0;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\na=va_arg(args, char*);\\r\\nif (a != NULL)\\r\\n{\\r\\nn+=strlen(a);\\r\\nif (n > s)\\r\\n{\\r\\ns=n+20;\\r\\np=OPENSSL_realloc(str,s+1);\\r\\nif (p == NULL)\\r\\n{\\r\\nOPENSSL_free(str);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nstr=p;\\r\\n}\\r\\nBUF_strlcat(str,a,(size_t)s+1);\\r\\n}\\r\\n}\\r\\nERR_set_error_data(str,ERR_TXT_MALLOCED|ERR_TXT_STRING);\\r\\nerr:\\r\\nva_end(args);\\r\\n}\\r\\nint ERR_set_mark(void)\\r\\n{\\r\\nERR_STATE *es;\\r\\nes=ERR_get_state();\\r\\nif (es->bottom == es->top) return 0;\\r\\nes->err_flags[es->top]|=ERR_FLAG_MARK;\\r\\nreturn 1;\\r\\n}\\r\\nint ERR_pop_to_mark(void)\\r\\n{\\r\\nERR_STATE *es;\\r\\nes=ERR_get_state();\\r\\nwhile(es->bottom != es->top\\r\\n&& (es->err_flags[es->top] & ERR_FLAG_MARK) == 0)\\r\\n{\\r\\nerr_clear(es,es->top);\\r\\nes->top-=1;\\r\\nif (es->top == -1) es->top=ERR_NUM_ERRORS;\\r\\n}\\r\\nif (es->bottom == es->top) return 0;\\r\\nes->err_flags[es->top]&=~ERR_FLAG_MARK;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_4758cca_err_c", "target": 0, "func": "static void ERR_load_CCA4758_strings(void)\\r\\n{\\r\\nif (CCA4758_lib_error_code == 0)\\r\\nCCA4758_lib_error_code=ERR_get_next_error_library();\\r\\nif (CCA4758_error_init)\\r\\n{\\r\\nCCA4758_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(CCA4758_lib_error_code,CCA4758_str_functs);\\r\\nERR_load_strings(CCA4758_lib_error_code,CCA4758_str_reasons);\\r\\n#endif\\r\\n#ifdef CCA4758_LIB_NAME\\r\\nCCA4758_lib_name->error = ERR_PACK(CCA4758_lib_error_code,0,0);\\r\\nERR_load_strings(0,CCA4758_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_CCA4758_strings(void)\\r\\n{\\r\\nif (CCA4758_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(CCA4758_lib_error_code,CCA4758_str_functs);\\r\\nERR_unload_strings(CCA4758_lib_error_code,CCA4758_str_reasons);\\r\\n#endif\\r\\n#ifdef CCA4758_LIB_NAME\\r\\nERR_unload_strings(0,CCA4758_lib_name);\\r\\n#endif\\r\\nCCA4758_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_CCA4758_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (CCA4758_lib_error_code == 0)\\r\\nCCA4758_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(CCA4758_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_easy-tls_c", "target": 0, "func": "static void\\r\\ntls_app_errflush(int child_p, char *errbuf, size_t num, void *apparg)\\r\\n{\\r\\nfputs(errbuf, stderr);\\r\\n}\\r\\nstruct tls_start_proxy_args\\r\\ntls_start_proxy_defaultargs(void)\\r\\n{\\r\\nstruct tls_start_proxy_args ret;\\r\\nret.fd = -1;\\r\\nret.client_p = -1;\\r\\nret.ctx = NULL;\\r\\nret.pid = NULL;\\r\\nret.infofd = NULL;\\r\\nreturn ret;\\r\\n}\\r\\nint\\r\\ntls_start_proxy(struct tls_start_proxy_args a, void *apparg)\\r\\n{\\r\\nint fds[2] = {-1, -1};\\r\\nint infofds[2] = {-1, -1};\\r\\nint r, getfd, getfl;\\r\\nint ret;\\r\\nDEBUG_MSG2(\"tls_start_proxy fd\", a.fd);\\r\\nDEBUG_MSG2(\"tls_start_proxy client_p\", a.client_p);\\r\\nif (a.fd == -1 || a.client_p == -1 || a.ctx == NULL)\\r\\nreturn 1;\\r\\nif (a.pid != NULL) {\\r\\n*a.pid = 0;\\r\\n}\\r\\nif (a.infofd != NULL) {\\r\\n*a.infofd = -1;\\r\\n}\\r\\nr = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\\r\\nif (r == -1)\\r\\nreturn -1;\\r\\nif (a.fd >= FD_SETSIZE || fds[0] >= FD_SETSIZE) {\\r\\nret = 2;\\r\\ngoto err;\\r\\n}\\r\\nif (a.infofd != NULL) {\\r\\nr = pipe(infofds);\\r\\nif (r == -1) {\\r\\nret = -3;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr = fork();\\r\\nif (r == -1) {\\r\\nret = -4;\\r\\ngoto err;\\r\\n}\\r\\nif (r == 0) {\\r\\nDEBUG_MSG(\"fork\");\\r\\ntls_child_p = 1;\\r\\ntls_child_apparg = apparg;\\r\\nclose(fds[1]);\\r\\nif (infofds[0] != -1)\\r\\nclose(infofds[0]);\\r\\nTLS_APP_PROCESS_INIT(a.fd, a.client_p, apparg);\\r\\nDEBUG_MSG(\"TLS_APP_PROCESS_INIT\");\\r\\ntls_proxy(fds[0], a.fd, infofds[1], a.ctx, a.client_p);\\r\\nexit(0);\\r\\n}\\r\\nif (a.pid != NULL)\\r\\n*a.pid = r;\\r\\nif (infofds[1] != -1) {\\r\\nclose(infofds[1]);\\r\\ninfofds[1] = -1;\\r\\n}\\r\\nclose(fds[0]);\\r\\nfds[0] = -1;\\r\\ngetfd = fcntl(a.fd, F_GETFD);\\r\\ngetfl = fcntl(a.fd, F_GETFL);\\r\\nr = dup2(fds[1], a.fd);\\r\\nclose(fds[1]);\\r\\nfds[1] = -1;\\r\\nif (r == -1) {\\r\\nret = -5;\\r\\ngoto err;\\r\\n}\\r\\nif (getfd != 1)\\r\\nfcntl(a.fd, F_SETFD, getfd);\\r\\nif (getfl & O_NONBLOCK)\\r\\n(void)tls_socket_nonblocking(a.fd);\\r\\nif (a.infofd != NULL)\\r\\n*a.infofd = infofds[0];\\r\\nreturn 0;\\r\\nerr:\\r\\nif (fds[0] != -1)\\r\\nclose(fds[0]);\\r\\nif (fds[1] != -1)\\r\\nclose(fds[1]);\\r\\nif (infofds[0] != -1)\\r\\nclose(infofds[0]);\\r\\nif (infofds[1] != -1)\\r\\nclose(infofds[1]);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void\\r\\ntls_errflush(void *apparg)\\r\\n{\\r\\nif (errbuf_i == 0)\\r\\nreturn;\\r\\nassert(errbuf_i < sizeof errbuf);\\r\\nassert(errbuf[errbuf_i] == 0);\\r\\nif (errbuf_i == sizeof errbuf - 1) {\\r\\nerrbuf[errbuf_i - 1] = '\\n';\\r\\n}\\r\\nTLS_APP_ERRFLUSH(tls_child_p, errbuf, errbuf_i, apparg);\\r\\nerrbuf_i = 0;\\r\\n}\\r\\nstatic void\\r\\ntls_errprintf(int flush, void *apparg, const char *fmt, ...)\\r\\n{\\r\\nva_list args;\\r\\nint r;\\r\\nif (errbuf_i < sizeof errbuf - 1) {\\r\\nsize_t n;\\r\\nva_start(args, fmt);\\r\\nn = (sizeof errbuf) - errbuf_i;\\r\\nr = vsnprintf(errbuf + errbuf_i, n, fmt, args);\\r\\nif (r >= n)\\r\\nr = n - 1;\\r\\nif (r >= 0) {\\r\\nerrbuf_i += r;\\r\\n} else {\\r\\nerrbuf_i = sizeof errbuf - 1;\\r\\nerrbuf[errbuf_i] = '\\0';\\r\\n}\\r\\nassert(errbuf_i < sizeof errbuf);\\r\\nassert(errbuf[errbuf_i] == 0);\\r\\n}\\r\\n#ifndef TLS_CUMULATE_ERRORS\\r\\ntls_errflush(apparg);\\r\\n#else\\r\\nif (flush)\\r\\ntls_errflush(apparg);\\r\\n#endif\\r\\n}\\r\\nstatic char *\\r\\ntls_openssl_errors(const char *app_prefix_1, const char *app_prefix_2, const char *default_text, void *apparg)\\r\\n{\\r\\nstatic char reasons[255];\\r\\nsize_t reasons_i;\\r\\nunsigned long err;\\r\\nconst char *file;\\r\\nint line;\\r\\nconst char *data;\\r\\nint flags;\\r\\nchar *errstring;\\r\\nint printed_something = 0;\\r\\nreasons_i = 0;\\r\\nassert(app_prefix_1 != NULL);\\r\\nassert(app_prefix_2 != NULL);\\r\\nif (default_text == NULL)\\r\\ndefault_text = \"?\"\"?\"\"?\";\\r\\nwhile ((err = ERR_get_error_line_data(&file,&line,&data,&flags)) != 0) {\\r\\nif (reasons_i < sizeof reasons) {\\r\\nsize_t n;\\r\\nint r;\\r\\nn = (sizeof reasons) - reasons_i;\\r\\nr = snprintf(reasons + reasons_i, n, \"%s%s\", (reasons_i > 0 ? \", \" : \"\"), ERR_reason_error_string(err)\\r\\nstatic int\\r\\ntls_init(void *apparg)\\r\\n{\\r\\nif (tls_init_done)\\r\\nreturn 0;\\r\\nSSL_load_error_strings();\\r\\nif (!SSL_library_init() ) {\\r\\ntls_errprintf(1, apparg, \"SSL_library_init failed.\\n\");\\r\\nreturn -1;\\r\\n}\\r\\ntls_init_done = 1;\\r\\ntls_rand_seed();\\r\\nreturn 0;\\r\\n}\\r\\nstatic void\\r\\ntls_rand_seed_uniquely(void)\\r\\n{\\r\\nstruct {\\r\\npid_t pid;\\r\\ntime_t time;\\r\\nvoid *stack;\\r\\n} data;\\r\\ndata.pid = getpid();\\r\\ndata.time = time(NULL);\\r\\ndata.stack = (void *)&data;\\r\\nRAND_seed((const void *)&data, sizeof data);\\r\\n}\\r\\nvoid\\r\\ntls_rand_seed(void)\\r\\n{\\r\\nstruct {\\r\\nstruct utsname uname;\\r\\nint uname_1;\\r\\nint uname_2;\\r\\nuid_t uid;\\r\\nuid_t euid;\\r\\ngid_t gid;\\r\\ngid_t egid;\\r\\n} data;\\r\\ndata.uname_1 = uname(&data.uname);\\r\\ndata.uname_2 = errno;\\r\\ndata.uid = getuid();\\r\\ndata.euid = geteuid();\\r\\ndata.gid = getgid();\\r\\ndata.egid = getegid();\\r\\nRAND_seed((const void *)&data, sizeof data);\\r\\ntls_rand_seed_uniquely();\\r\\n}\\r\\nint\\r\\ntls_rand_seed_from_file(const char *filename, size_t n, void *apparg)\\r\\n{\\r\\nint r;\\r\\nif (tls_init(apparg) == -1)\\r\\nreturn -1;\\r\\ntls_rand_seed();\\r\\nr = RAND_load_file(filename, (n > 0 && n < LONG_MAX) ? (long)n : LONG_MAX);\\r\\nassert(1 < my_MIN_SEED_BYTES);\\r\\nif (n == 0)\\r\\nn = my_MIN_SEED_BYTES;\\r\\nif (r < n) {\\r\\ntls_errprintf(1, apparg, \"rand_seed_from_file: could not read %d bytes from %s.\\n\", n, filename);\\r\\nreturn -1;\\r\\n} else {\\r\\ntls_rand_seeded_p = 1;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nvoid\\r\\ntls_rand_seed_from_memory(const void *buf, size_t n)\\r\\n{\\r\\nsize_t i = 0;\\r\\nwhile (i < n) {\\r\\nsize_t rest = n - i;\\r\\nint chunk = rest < INT_MAX ? (int)rest : INT_MAX;\\r\\nRAND_seed((const char *)buf + i, chunk);\\r\\ni += chunk;\\r\\n}\\r\\ntls_rand_seeded_p = 1;\\r\\n}\\r\\nstatic void\\r\\ntls_get_x509_subject_name_oneline(X509 *cert, struct tls_x509_name_string *namestring)\\r\\n{\\r\\nX509_NAME *name;\\r\\nif (cert == NULL) {\\r\\nnamestring->str[0] = '\\0';\\r\\nreturn;\\r\\n}\\r\\nname = X509_get_subject_name(cert);\\r\\nassert(sizeof namestring->str >= 4);\\r\\nif (name == NULL) {\\r\\nnamestring->str[0] = '?';\\r\\nnamestring->str[1] = 0;\\r\\n} else {\\r\\nsize_t len;\\r\\nX509_NAME_oneline(name, namestring->str, sizeof namestring->str);\\r\\nlen = strlen(namestring->str);\\r\\nassert(namestring->str[len] == 0);\\r\\nassert(len < sizeof namestring->str);\\r\\nif (len+1 == sizeof namestring->str) {\\r\\nassert(namestring->str[len] == 0);\\r\\nnamestring->str[--len] = '.';\\r\\nnamestring->str[--len] = '.';\\r\\nnamestring->str[--len] = '.';\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int\\r\\nno_passphrase_callback(char *buf, int num, int w, void *arg)\\r\\n{\\r\\nreturn -1;\\r\\n}\\r\\nvoid\\r\\ntls_set_dhe1024(int i, void *apparg)\\r\\n{\\r\\nDSA *dsaparams;\\r\\nDH *dhparams;\\r\\nconst char *seed[] = { \";-) :-( :-) :-( \",\\r\\n\";-) :-( :-) :-( \",\\r\\n\"Random String no. 12\",\\r\\n\";-) :-( :-) :-( \",\\r\\n\"hackers have even mo\",\\r\\n};\\r\\nunsigned char seedbuf[20];\\r\\ntls_init(apparg);\\r\\nif (i >= 0) {\\r\\ni %= sizeof seed / sizeof seed[0];\\r\\nassert(strlen(seed[i]) == 20);\\r\\nmemcpy(seedbuf, seed[i], 20);\\r\\ndsaparams = DSA_generate_parameters(1024, seedbuf, 20, NULL, NULL, 0, NULL);\\r\\n} else {\\r\\ndsaparams = DSA_generate_parameters(1024, NULL, 0, NULL, NULL, 0, NULL);\\r\\n}\\r\\nif (dsaparams == NULL) {\\r\\ntls_openssl_errors(\"\", \"\", NULL, apparg);\\r\\nreturn;\\r\\n}\\r\\ndhparams = DSA_dup_DH(dsaparams);\\r\\nDSA_free(dsaparams);\\r\\nif (dhparams == NULL) {\\r\\ntls_openssl_errors(\"\", \"\", NULL, apparg);\\r\\nreturn;\\r\\n}\\r\\nif (tls_dhe1024 != NULL)\\r\\nDH_free(tls_dhe1024);\\r\\ntls_dhe1024 = dhparams;\\r\\n}\\r\\nstruct tls_create_ctx_args\\r\\ntls_create_ctx_defaultargs(void)\\r\\n{\\r\\nstruct tls_create_ctx_args ret;\\r\\nret.client_p = 0;\\r\\nret.certificate_file = NULL;\\r\\nret.key_file = NULL;\\r\\nret.ca_file = NULL;\\r\\nret.verify_depth = -1;\\r\\nret.fail_unless_verified = 0;\\r\\nret.export_p = 0;\\r\\nreturn ret;\\r\\n}\\r\\nSSL_CTX *\\r\\ntls_create_ctx(struct tls_create_ctx_args a, void *apparg)\\r\\n{\\r\\nint r;\\r\\nstatic long context_num = 0;\\r\\nSSL_CTX *ret;\\r\\nconst char *err_pref_1 = \"\", *err_pref_2 = \"\";\\r\\nif (tls_init(apparg) == -1)\\r\\nreturn NULL;\\r\\nret = SSL_CTX_new((a.client_p? SSLv23_client_method:SSLv23_server_method)());\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nSSL_CTX_set_default_passwd_cb(ret, no_passphrase_callback);\\r\\nSSL_CTX_set_mode(ret, SSL_MODE_ENABLE_PARTIAL_WRITE);\\r\\nif ((a.certificate_file != NULL) || (a.key_file != NULL)) {\\r\\nif (a.key_file == NULL) {\\r\\ntls_errprintf(1, apparg, \"Need a key file.\\n\");\\r\\ngoto err_return;\\r\\n}\\r\\nif (a.certificate_file == NULL) {\\r\\ntls_errprintf(1, apparg, \"Need a certificate chain file.\\n\");\\r\\ngoto err_return;\\r\\n}\\r\\nif (!SSL_CTX_use_PrivateKey_file(ret, a.key_file, SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!tls_rand_seeded_p) {\\r\\nif (tls_rand_seed_from_file(a.key_file, 0, apparg) == -1)\\r\\ngoto err_return;\\r\\n}\\r\\nif (!SSL_CTX_use_certificate_chain_file(ret, a.certificate_file))\\r\\ngoto err;\\r\\nif (!SSL_CTX_check_private_key(ret)) {\\r\\ntls_errprintf(1, apparg, \"Private key \\\"%s\\\" does not match certificate \\\"%s\\\".\\n\", a.key_file, a.certificate_file);\\r\\ngoto err_peek;\\r\\n}\\r\\n}\\r\\nif ((a.ca_file != NULL) || (a.verify_depth > 0)) {\\r\\ncontext_num++;\\r\\nr = SSL_CTX_set_session_id_context(ret, (const void *)&context_num, (unsigned int)sizeof context_num);\\r\\nif (!r)\\r\\ngoto err;\\r\\nSSL_CTX_set_verify(ret, SSL_VERIFY_PEER | (a.fail_unless_verified ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0), 0);\\r\\nif (!a.fail_unless_verified)\\r\\nSSL_CTX_set_cert_verify_callback(ret, verify_dont_fail_cb, NULL);\\r\\nif (a.verify_depth > 0)\\r\\nSSL_CTX_set_verify_depth(ret, a.verify_depth);\\r\\nif (a.ca_file != NULL) {\\r\\nr = SSL_CTX_load_verify_locations(ret, a.ca_file, NULL );\\r\\nif (!r) {\\r\\nerr_pref_1 = \" while processing certificate file \";\\r\\nerr_pref_2 = a.ca_file;\\r\\ngoto err;\\r\\n}\\r\\nif (!a.client_p) {\\r\\nSSL_CTX_set_client_CA_list(ret, SSL_load_client_CA_file(a.ca_file));\\r\\nif (SSL_CTX_get_client_CA_list(ret) == NULL) {\\r\\ntls_errprintf(1, apparg, \"Could not set client CA list from \\\"%s\\\".\\n\", a.ca_file);\\r\\ngoto err_peek;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!a.client_p) {\\r\\nif (tls_dhe1024 == NULL) {\\r\\nint i;\\r\\nRAND_bytes((unsigned char *) &i, sizeof i);\\r\\nif (i < 0)\\r\\ni = -i;\\r\\nif (i < 0)\\r\\ni = 0;\\r\\ntls_set_dhe1024(i, apparg);\\r\\nif (tls_dhe1024 == NULL)\\r\\ngoto err_return;\\r\\n}\\r\\nif (!SSL_CTX_set_tmp_dh(ret, tls_dhe1024))\\r\\ngoto err;\\r\\nSSL_CTX_set_options(ret, SSL_OP_SINGLE_DH_USE);\\r\\n}\\r\\n#ifndef NO_RSA\\r\\nif (!a.client_p && a.export_p) {\\r\\nRSA *tmpkey;\\r\\ntmpkey = RSA_generate_key(512, RSA_F4, 0, NULL);\\r\\nif (tmpkey == NULL)\\r\\ngoto err;\\r\\nif (!SSL_CTX_set_tmp_rsa(ret, tmpkey)) {\\r\\nRSA_free(tmpkey);\\r\\ngoto err;\\r\\n}\\r\\nRSA_free(tmpkey);\\r\\n}\\r\\n#endif\\r\\nreturn ret;\\r\\nerr_peek:\\r\\nif (!ERR_peek_error())\\r\\ngoto err_return;\\r\\nerr:\\r\\ntls_openssl_errors(err_pref_1, err_pref_2, NULL, apparg);\\r\\nerr_return:\\r\\nif (ret != NULL)\\r\\nSSL_CTX_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int\\r\\ntls_socket_nonblocking(int fd)\\r\\n{\\r\\nint v, r;\\r\\nv = fcntl(fd, F_GETFL, 0);\\r\\nif (v == -1) {\\r\\nif (errno == EINVAL)\\r\\nreturn 0;\\r\\nreturn -1;\\r\\n}\\r\\nr = fcntl(fd, F_SETFL, v | O_NONBLOCK);\\r\\nif (r == -1) {\\r\\nif (errno == EINVAL)\\r\\nreturn 0;\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int\\r\\nmax(int a, int b)\\r\\n{\\r\\nreturn a > b ? a : b;\\r\\n}\\r\\nstatic void\\r\\ntls_sockets_select(int read_select_1, int read_select_2, int write_select_1, int write_select_2, int seconds )\\r\\n{\\r\\nint maxfd, n;\\r\\nfd_set reads, writes;\\r\\nstruct timeval timeout;\\r\\nstruct timeval *timeout_p;\\r\\nassert(read_select_1 >= -1 && read_select_2 >= -1 && write_select_1 >= -1 && write_select_2 >= -1);\\r\\nassert(read_select_1 < FD_SETSIZE && read_select_2 < FD_SETSIZE -1 && write_select_1 < FD_SETSIZE -1 && write_select_2 < FD_SETSIZE -1);\\r\\nmaxfd = max(max(read_select_1, read_select_2), max(write_select_1, write_select_2));\\r\\nassert(maxfd >= 0);\\r\\nFD_ZERO(&reads);\\r\\nFD_ZERO(&writes);\\r\\nfor(n = 0; n < 4; ++n) {\\r\\nint i = n % 2;\\r\\nint w = n >= 2;\\r\\nint fd;\\r\\nif (i == 0 && w == 0)\\r\\nfd = read_select_1;\\r\\nelse if (i == 1 && w == 0)\\r\\nfd = read_select_2;\\r\\nelse if (i == 0 && w == 1)\\r\\nfd = write_select_1;\\r\\nelse {\\r\\nassert(i == 1 && w == 1);\\r\\nfd = write_select_2;\\r\\n}\\r\\nif (fd >= 0) {\\r\\nif (w == 0)\\r\\nFD_SET(fd, &reads);\\r\\nelse\\r\\nFD_SET(fd, &writes);\\r\\n}\\r\\n}\\r\\nif (seconds >= 0) {\\r\\ntimeout.tv_sec = seconds;\\r\\ntimeout.tv_usec = 0;\\r\\ntimeout_p = &timeout;\\r\\n} else\\r\\ntimeout_p = NULL;\\r\\nDEBUG_MSG2(\"select no.\", ++tls_select_count);\\r\\nselect(maxfd + 1, &reads, &writes, (fd_set *) NULL, timeout_p);\\r\\nDEBUG_MSG(\"cont.\");\\r\\n}\\r\\nstatic void write_info(SSL *ssl, int *info_fd)\\r\\n{\\r\\nif (*info_fd != -1) {\\r\\nlong v;\\r\\nint v_ok;\\r\\nstruct tls_x509_name_string peer;\\r\\nchar infobuf[TLS_INFO_SIZE];\\r\\nint r;\\r\\nDEBUG_MSG(\"write_info\");\\r\\nv = SSL_get_verify_result(ssl);\\r\\nv_ok = (v == X509_V_OK) ? 'A' : 'E';\\r\\n{\\r\\nX509 *peercert;\\r\\npeercert = SSL_get_peer_certificate(ssl);\\r\\ntls_get_x509_subject_name_oneline(peercert, &peer);\\r\\nif (peercert != NULL)\\r\\nX509_free(peercert);\\r\\n}\\r\\nif (peer.str[0] == '\\0')\\r\\nv_ok = '0';\\r\\nelse\\r\\nif (strchr(peer.str, '\\n')) {\\r\\n*strchr(peer.str, '\\n') = '\\0';\\r\\n}\\r\\nr = snprintf(infobuf, sizeof infobuf, \"%c:%s\\n%s\\n\", v_ok, X509_verify_cert_error_string(v), peer.str);\\r\\nDEBUG_MSG2(\"snprintf\", r);\\r\\nif (r == -1 || r >= sizeof infobuf)\\r\\nr = sizeof infobuf - 1;\\r\\nwrite(*info_fd, infobuf, r);\\r\\nclose (*info_fd);\\r\\n*info_fd = -1;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\ntls_proxy(int clear_fd, int tls_fd, int info_fd, SSL_CTX *ctx, int client_p)\\r\\n{\\r\\nstruct tunnelbuf clear_to_tls, tls_to_clear;\\r\\nSSL *ssl;\\r\\nBIO *rbio, *wbio;\\r\\nint closed, in_handshake;\\r\\nconst char *err_pref_1 = \"\", *err_pref_2 = \"\";\\r\\nconst char *err_def = NULL;\\r\\nassert(clear_fd != -1);\\r\\nassert(tls_fd != -1);\\r\\nassert(clear_fd < FD_SETSIZE);\\r\\nassert(tls_fd < FD_SETSIZE);\\r\\nassert(ctx != NULL);\\r\\ntls_rand_seed_uniquely();\\r\\ntls_socket_nonblocking(clear_fd);\\r\\nDEBUG_MSG2(\"clear_fd\", clear_fd);\\r\\ntls_socket_nonblocking(tls_fd);\\r\\nDEBUG_MSG2(\"tls_fd\", tls_fd);\\r\\nssl = SSL_new(ctx);\\r\\nif (ssl == NULL)\\r\\ngoto err;\\r\\nDEBUG_MSG(\"SSL_new\");\\r\\nif (!SSL_set_fd(ssl, tls_fd))\\r\\ngoto err;\\r\\nrbio = SSL_get_rbio(ssl);\\r\\nwbio = SSL_get_wbio(ssl);\\r\\nassert(rbio != NULL);\\r\\nassert(wbio != NULL);\\r\\nif (client_p)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nclosed = 0;\\r\\nin_handshake = 1;\\r\\ntls_to_clear.len = 0;\\r\\ntls_to_clear.offset = 0;\\r\\nclear_to_tls.len = 0;\\r\\nclear_to_tls.offset = 0;\\r\\nerr_def = \"I/O error\";\\r\\ndo {\\r\\nint clear_read_select = 0, clear_write_select = 0,\\r\\ntls_read_select = 0, tls_write_select = 0,\\r\\nprogress = 0;\\r\\nint r;\\r\\nunsigned long num_read = BIO_number_read(rbio),\\r\\nnum_written = BIO_number_written(wbio);\\r\\nDEBUG_MSG2(\"loop iteration\", ++tls_loop_count);\\r\\nif (in_handshake) {\\r\\nDEBUG_MSG(\"in_handshake\");\\r\\nif (client_p)\\r\\nr = tls_connect_attempt(ssl, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\\r\\nelse\\r\\nr = tls_accept_attempt(ssl, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\\r\\nif (r != 0) {\\r\\nwrite_info(ssl, &info_fd);\\r\\ngoto err;\\r\\n}\\r\\nif (closed)\\r\\ngoto err_return;\\r\\nif (!SSL_in_init(ssl)) {\\r\\nin_handshake = 0;\\r\\nwrite_info(ssl, &info_fd);\\r\\n}\\r\\n}\\r\\nif (clear_to_tls.len != 0 && !in_handshake) {\\r\\nassert(!closed);\\r\\nr = tls_write_attempt(ssl, &clear_to_tls, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nif (closed) {\\r\\nassert(progress);\\r\\ntls_to_clear.offset = 0;\\r\\ntls_to_clear.len = 0;\\r\\n}\\r\\n}\\r\\nif (tls_to_clear.len != 0) {\\r\\nassert(!closed);\\r\\nr = write_attempt(clear_fd, &tls_to_clear, &clear_write_select, &closed, &progress);\\r\\nif (r != 0)\\r\\ngoto err_return;\\r\\nif (closed) {\\r\\nassert(progress);\\r\\nclear_to_tls.offset = 0;\\r\\nclear_to_tls.len = 0;\\r\\n}\\r\\n}\\r\\nif (!closed) {\\r\\nif (clear_to_tls.offset + clear_to_tls.len < sizeof clear_to_tls.buf) {\\r\\nr = read_attempt(clear_fd, &clear_to_tls, &clear_read_select, &closed, &progress);\\r\\nif (r != 0)\\r\\ngoto err_return;\\r\\nif (closed) {\\r\\nr = SSL_shutdown(ssl);\\r\\nDEBUG_MSG2(\"SSL_shutdown\", r);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!closed && !in_handshake) {\\r\\nif (tls_to_clear.offset + tls_to_clear.len < sizeof tls_to_clear.buf) {\\r\\nr = tls_read_attempt(ssl, &tls_to_clear, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nif (closed) {\\r\\nr = SSL_shutdown(ssl);\\r\\nDEBUG_MSG2(\"SSL_shutdown\", r);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!progress) {\\r\\nDEBUG_MSG(\"!progress?\");\\r\\nif (num_read != BIO_number_read(rbio) || num_written != BIO_number_written(wbio))\\r\\nprogress = 1;\\r\\nif (!progress) {\\r\\nDEBUG_MSG(\"!progress\");\\r\\nassert(clear_read_select || tls_read_select || clear_write_select || tls_write_select);\\r\\ntls_sockets_select(clear_read_select ? clear_fd : -1, tls_read_select ? tls_fd : -1, clear_write_select ? clear_fd : -1, tls_write_select ? tls_fd : -1, -1);\\r\\n}\\r\\n}\\r\\n} while (!closed);\\r\\nreturn;\\r\\nerr:\\r\\ntls_openssl_errors(err_pref_1, err_pref_2, err_def, tls_child_apparg);\\r\\nerr_return:\\r\\nreturn;\\r\\n}\\r\\nstatic int\\r\\ntls_get_error(SSL *ssl, int r, int *write_select, int *read_select, int *closed, int *progress)\\r\\n{\\r\\nint err = SSL_get_error(ssl, r);\\r\\nif (err == SSL_ERROR_NONE) {\\r\\nassert(r > 0);\\r\\n*progress = 1;\\r\\nreturn 0;\\r\\n}\\r\\nassert(r <= 0);\\r\\nswitch (err) {\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nassert(r == 0);\\r\\n*closed = 1;\\r\\n*progress = 1;\\r\\nreturn 0;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\n*write_select = 1;\\r\\nreturn 0;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\n*read_select = 1;\\r\\nreturn 0;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic int\\r\\ntls_connect_attempt(SSL *ssl, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\\r\\n{\\r\\nint n, r;\\r\\nDEBUG_MSG(\"tls_connect_attempt\");\\r\\nn = SSL_connect(ssl);\\r\\nDEBUG_MSG2(\"SSL_connect\",n);\\r\\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\\r\\nif (r == -1)\\r\\n*err_pref = \" during SSL_connect\";\\r\\nreturn r;\\r\\n}\\r\\nstatic int\\r\\ntls_accept_attempt(SSL *ssl, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\\r\\n{\\r\\nint n, r;\\r\\nDEBUG_MSG(\"tls_accept_attempt\");\\r\\nn = SSL_accept(ssl);\\r\\nDEBUG_MSG2(\"SSL_accept\",n);\\r\\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\\r\\nif (r == -1)\\r\\n*err_pref = \" during SSL_accept\";\\r\\nreturn r;\\r\\n}\\r\\nstatic int\\r\\ntls_write_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\\r\\n{\\r\\nint n, r;\\r\\nDEBUG_MSG(\"tls_write_attempt\");\\r\\nn = SSL_write(ssl, buf->buf + buf->offset, buf->len);\\r\\nDEBUG_MSG2(\"SSL_write\",n);\\r\\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\\r\\nif (n > 0) {\\r\\nbuf->len -= n;\\r\\nassert(buf->len >= 0);\\r\\nif (buf->len == 0)\\r\\nbuf->offset = 0;\\r\\nelse\\r\\nbuf->offset += n;\\r\\n}\\r\\nif (r == -1)\\r\\n*err_pref = \" during SSL_write\";\\r\\nreturn r;\\r\\n}\\r\\nstatic int\\r\\ntls_read_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\\r\\n{\\r\\nint n, r;\\r\\nsize_t total;\\r\\nDEBUG_MSG(\"tls_read_attempt\");\\r\\ntotal = buf->offset + buf->len;\\r\\nassert(total < sizeof buf->buf);\\r\\nn = SSL_read(ssl, buf->buf + total, (sizeof buf->buf) - total);\\r\\nDEBUG_MSG2(\"SSL_read\",n);\\r\\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\\r\\nif (n > 0) {\\r\\nbuf->len += n;\\r\\nassert(buf->offset + buf->len <= sizeof buf->buf);\\r\\n}\\r\\nif (r == -1)\\r\\n*err_pref = \" during SSL_read\";\\r\\nreturn r;\\r\\n}\\r\\nstatic int\\r\\nget_error(int r, int *select, int *closed, int *progress)\\r\\n{\\r\\nif (r >= 0) {\\r\\n*progress = 1;\\r\\nif (r == 0)\\r\\n*closed = 1;\\r\\nreturn 0;\\r\\n} else {\\r\\nassert(r == -1);\\r\\nif (errno == EAGAIN || errno == EWOULDBLOCK) {\\r\\n*select = 1;\\r\\nreturn 0;\\r\\n} else if (errno == EPIPE) {\\r\\n*progress = 1;\\r\\n*closed = 1;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nstatic int write_attempt(int fd, struct tunnelbuf *buf, int *select, int *closed, int *progress)\\r\\n{\\r\\nint n, r;\\r\\nDEBUG_MSG(\"write_attempt\");\\r\\nn = write(fd, buf->buf + buf->offset, buf->len);\\r\\nDEBUG_MSG2(\"write\",n);\\r\\nr = get_error(n, select, closed, progress);\\r\\nif (n > 0) {\\r\\nbuf->len -= n;\\r\\nassert(buf->len >= 0);\\r\\nif (buf->len == 0)\\r\\nbuf->offset = 0;\\r\\nelse\\r\\nbuf->offset += n;\\r\\n}\\r\\nif (r == -1)\\r\\ntls_errprintf(1, tls_child_apparg, \"write error: %s\\n\", strerror(errno));\\r\\nreturn r;\\r\\n}\\r\\nstatic int\\r\\nread_attempt(int fd, struct tunnelbuf *buf, int *select, int *closed, int *progress)\\r\\n{\\r\\nint n, r;\\r\\nsize_t total;\\r\\nDEBUG_MSG(\"read_attempt\");\\r\\ntotal = buf->offset + buf->len;\\r\\nassert(total < sizeof buf->buf);\\r\\nn = read(fd, buf->buf + total, (sizeof buf->buf) - total);\\r\\nDEBUG_MSG2(\"read\",n);\\r\\nr = get_error(n, select, closed, progress);\\r\\nif (n > 0) {\\r\\nbuf->len += n;\\r\\nassert(buf->offset + buf->len <= sizeof buf->buf);\\r\\n}\\r\\nif (r == -1)\\r\\ntls_errprintf(1, tls_child_apparg, \"read error: %s\\n\", strerror(errno));\\r\\nreturn r;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_comp_lib_c", "target": 0, "func": "COMP_CTX *COMP_CTX_new(COMP_METHOD *meth)\\r\\n{\\r\\nCOMP_CTX *ret;\\r\\nif ((ret=(COMP_CTX *)OPENSSL_malloc(sizeof(COMP_CTX))) == NULL)\\r\\n{\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(COMP_CTX));\\r\\nret->meth=meth;\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nOPENSSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid COMP_CTX_free(COMP_CTX *ctx)\\r\\n{\\r\\nif(ctx == NULL)\\r\\nreturn;\\r\\nif (ctx->meth->finish != NULL)\\r\\nctx->meth->finish(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->compress == NULL)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nret=ctx->meth->compress(ctx,out,olen,in,ilen);\\r\\nif (ret > 0)\\r\\n{\\r\\nctx->compress_in+=ilen;\\r\\nctx->compress_out+=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->expand == NULL)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nret=ctx->meth->expand(ctx,out,olen,in,ilen);\\r\\nif (ret > 0)\\r\\n{\\r\\nctx->expand_in+=ilen;\\r\\nctx->expand_out+=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_tb_dsa_c", "target": 0, "func": "void ENGINE_unregister_DSA(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&dsa_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_DSA(void)\\r\\n{\\r\\nengine_table_cleanup(&dsa_table);\\r\\n}\\r\\nint ENGINE_register_DSA(ENGINE *e)\\r\\n{\\r\\nif(e->dsa_meth)\\r\\nreturn engine_table_register(&dsa_table,\\r\\nengine_unregister_all_DSA, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_DSA()\\r\\n{\\r\\nENGINE *e;\\r\\nfor(e=ENGINE_get_first() ; e ; e=ENGINE_get_next(e))\\r\\nENGINE_register_DSA(e);\\r\\n}\\r\\nint ENGINE_set_default_DSA(ENGINE *e)\\r\\n{\\r\\nif(e->dsa_meth)\\r\\nreturn engine_table_register(&dsa_table,\\r\\nengine_unregister_all_DSA, e, &dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_DSA(void)\\r\\n{\\r\\nreturn engine_table_select(&dsa_table, dummy_nid);\\r\\n}\\r\\nconst DSA_METHOD *ENGINE_get_DSA(const ENGINE *e)\\r\\n{\\r\\nreturn e->dsa_meth;\\r\\n}\\r\\nint ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth)\\r\\n{\\r\\ne->dsa_meth = dsa_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_strex_c", "target": 0, "func": "static int send_bio_chars(void *arg, const void *buf, int len)\\r\\n{\\r\\nif(!arg) return 1;\\r\\nif(BIO_write(arg, buf, len) != len) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int send_fp_chars(void *arg, const void *buf, int len)\\r\\n{\\r\\nif(!arg) return 1;\\r\\nif(fwrite(buf, 1, len, arg) != (unsigned int)len) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_esc_char(unsigned long c, unsigned char flags, char *do_quotes, char_io *io_ch, void *arg)\\r\\n{\\r\\nunsigned char chflgs, chtmp;\\r\\nchar tmphex[HEX_SIZE(long)+3];\\r\\nif(c > 0xffffffffL)\\r\\nreturn -1;\\r\\nif(c > 0xffff) {\\r\\nBIO_snprintf(tmphex, sizeof tmphex, \"\\\\W%08lX\", c);\\r\\nif(!io_ch(arg, tmphex, 10)) return -1;\\r\\nreturn 10;\\r\\n}\\r\\nif(c > 0xff) {\\r\\nBIO_snprintf(tmphex, sizeof tmphex, \"\\\\U%04lX\", c);\\r\\nif(!io_ch(arg, tmphex, 6)) return -1;\\r\\nreturn 6;\\r\\n}\\r\\nchtmp = (unsigned char)c;\\r\\nif(chtmp > 0x7f) chflgs = flags & ASN1_STRFLGS_ESC_MSB;\\r\\nelse chflgs = char_type[chtmp] & flags;\\r\\nif(chflgs & CHARTYPE_BS_ESC) {\\r\\nif(chflgs & ASN1_STRFLGS_ESC_QUOTE) {\\r\\nif(do_quotes) *do_quotes = 1;\\r\\nif(!io_ch(arg, &chtmp, 1)) return -1;\\r\\nreturn 1;\\r\\n}\\r\\nif(!io_ch(arg, \"\\\\\", 1)) return -1;\\r\\nif(!io_ch(arg, &chtmp, 1)) return -1;\\r\\nreturn 2;\\r\\n}\\r\\nif(chflgs & (ASN1_STRFLGS_ESC_CTRL|ASN1_STRFLGS_ESC_MSB)) {\\r\\nBIO_snprintf(tmphex, 11, \"\\\\%02X\", chtmp);\\r\\nif(!io_ch(arg, tmphex, 3)) return -1;\\r\\nreturn 3;\\r\\n}\\r\\nif(!io_ch(arg, &chtmp, 1)) return -1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_buf(unsigned char *buf, int buflen,\\r\\nint type, unsigned char flags, char *quotes, char_io *io_ch, void *arg)\\r\\n{\\r\\nint i, outlen, len;\\r\\nunsigned char orflags, *p, *q;\\r\\nunsigned long c;\\r\\np = buf;\\r\\nq = buf + buflen;\\r\\noutlen = 0;\\r\\nwhile(p != q) {\\r\\nif(p == buf) orflags = CHARTYPE_FIRST_ESC_2253;\\r\\nelse orflags = 0;\\r\\nswitch(type & BUF_TYPE_WIDTH_MASK) {\\r\\ncase 4:\\r\\nc = ((unsigned long)*p++) << 24;\\r\\nc |= ((unsigned long)*p++) << 16;\\r\\nc |= ((unsigned long)*p++) << 8;\\r\\nc |= *p++;\\r\\nbreak;\\r\\ncase 2:\\r\\nc = ((unsigned long)*p++) << 8;\\r\\nc |= *p++;\\r\\nbreak;\\r\\ncase 1:\\r\\nc = *p++;\\r\\nbreak;\\r\\ncase 0:\\r\\ni = UTF8_getc(p, buflen, &c);\\r\\nif(i < 0) return -1;\\r\\np += i;\\r\\nbreak;\\r\\n}\\r\\nif (p == q) orflags = CHARTYPE_LAST_ESC_2253;\\r\\nif(type & BUF_TYPE_CONVUTF8) {\\r\\nunsigned char utfbuf[6];\\r\\nint utflen;\\r\\nutflen = UTF8_putc(utfbuf, sizeof utfbuf, c);\\r\\nfor(i = 0; i < utflen; i++) {\\r\\nlen = do_esc_char(utfbuf[i], (unsigned char)(flags | orflags), quotes, io_ch, arg);\\r\\nif(len < 0) return -1;\\r\\noutlen += len;\\r\\n}\\r\\n} else {\\r\\nlen = do_esc_char(c, (unsigned char)(flags | orflags), quotes, io_ch, arg);\\r\\nif(len < 0) return -1;\\r\\noutlen += len;\\r\\n}\\r\\n}\\r\\nreturn outlen;\\r\\n}\\r\\nstatic int do_hex_dump(char_io *io_ch, void *arg, unsigned char *buf, int buflen)\\r\\n{\\r\\nconst static char hexdig[] = \"0123456789ABCDEF\";\\r\\nunsigned char *p, *q;\\r\\nchar hextmp[2];\\r\\nif(arg) {\\r\\np = buf;\\r\\nq = buf + buflen;\\r\\nwhile(p != q) {\\r\\nhextmp[0] = hexdig[*p >> 4];\\r\\nhextmp[1] = hexdig[*p & 0xf];\\r\\nif(!io_ch(arg, hextmp, 2)) return -1;\\r\\np++;\\r\\n}\\r\\n}\\r\\nreturn buflen << 1;\\r\\n}\\r\\nstatic int do_dump(unsigned long lflags, char_io *io_ch, void *arg, ASN1_STRING *str)\\r\\n{\\r\\nASN1_TYPE t;\\r\\nunsigned char *der_buf, *p;\\r\\nint outlen, der_len;\\r\\nif(!io_ch(arg, \"#\", 1)) return -1;\\r\\nif(!(lflags & ASN1_STRFLGS_DUMP_DER)) {\\r\\noutlen = do_hex_dump(io_ch, arg, str->data, str->length);\\r\\nif(outlen < 0) return -1;\\r\\nreturn outlen + 1;\\r\\n}\\r\\nt.type = str->type;\\r\\nt.value.ptr = (char *)str;\\r\\nder_len = i2d_ASN1_TYPE(&t, NULL);\\r\\nder_buf = OPENSSL_malloc(der_len);\\r\\nif(!der_buf) return -1;\\r\\np = der_buf;\\r\\ni2d_ASN1_TYPE(&t, &p);\\r\\noutlen = do_hex_dump(io_ch, arg, der_buf, der_len);\\r\\nOPENSSL_free(der_buf);\\r\\nif(outlen < 0) return -1;\\r\\nreturn outlen + 1;\\r\\n}\\r\\nstatic int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags, ASN1_STRING *str)\\r\\n{\\r\\nint outlen, len;\\r\\nint type;\\r\\nchar quotes;\\r\\nunsigned char flags;\\r\\nquotes = 0;\\r\\nflags = (unsigned char)(lflags & ESC_FLAGS);\\r\\ntype = str->type;\\r\\noutlen = 0;\\r\\nif(lflags & ASN1_STRFLGS_SHOW_TYPE) {\\r\\nconst char *tagname;\\r\\ntagname = ASN1_tag2str(type);\\r\\noutlen += strlen(tagname);\\r\\nif(!io_ch(arg, tagname, outlen) || !io_ch(arg, \":\", 1)) return -1;\\r\\noutlen++;\\r\\n}\\r\\nif(lflags & ASN1_STRFLGS_DUMP_ALL) type = -1;\\r\\nelse if(lflags & ASN1_STRFLGS_IGNORE_TYPE) type = 1;\\r\\nelse {\\r\\nif((type > 0) && (type < 31)) type = tag2nbyte[type];\\r\\nelse type = -1;\\r\\nif((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN)) type = 1;\\r\\n}\\r\\nif(type == -1) {\\r\\nlen = do_dump(lflags, io_ch, arg, str);\\r\\nif(len < 0) return -1;\\r\\noutlen += len;\\r\\nreturn outlen;\\r\\n}\\r\\nif(lflags & ASN1_STRFLGS_UTF8_CONVERT) {\\r\\nif(!type) type = 1;\\r\\nelse type |= BUF_TYPE_CONVUTF8;\\r\\n}\\r\\nlen = do_buf(str->data, str->length, type, flags, &quotes, io_ch, NULL);\\r\\nif(outlen < 0) return -1;\\r\\noutlen += len;\\r\\nif(quotes) outlen += 2;\\r\\nif(!arg) return outlen;\\r\\nif(quotes && !io_ch(arg, \"\\\"\", 1)) return -1;\\r\\ndo_buf(str->data, str->length, type, flags, NULL, io_ch, arg);\\r\\nif(quotes && !io_ch(arg, \"\\\"\", 1)) return -1;\\r\\nreturn outlen;\\r\\n}\\r\\nstatic int do_indent(char_io *io_ch, void *arg, int indent)\\r\\n{\\r\\nint i;\\r\\nfor(i = 0; i < indent; i++)\\r\\nif(!io_ch(arg, \" \", 1)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_name_ex(char_io *io_ch, void *arg, X509_NAME *n,\\r\\nint indent, unsigned long flags)\\r\\n{\\r\\nint i, prev = -1, orflags, cnt;\\r\\nint fn_opt, fn_nid;\\r\\nASN1_OBJECT *fn;\\r\\nASN1_STRING *val;\\r\\nX509_NAME_ENTRY *ent;\\r\\nchar objtmp[80];\\r\\nconst char *objbuf;\\r\\nint outlen, len;\\r\\nchar *sep_dn, *sep_mv, *sep_eq;\\r\\nint sep_dn_len, sep_mv_len, sep_eq_len;\\r\\nif(indent < 0) indent = 0;\\r\\noutlen = indent;\\r\\nif(!do_indent(io_ch, arg, indent)) return -1;\\r\\nswitch (flags & XN_FLAG_SEP_MASK)\\r\\n{\\r\\ncase XN_FLAG_SEP_MULTILINE:\\r\\nsep_dn = \"\\n\";\\r\\nsep_dn_len = 1;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_COMMA_PLUS:\\r\\nsep_dn = \",\";\\r\\nsep_dn_len = 1;\\r\\nsep_mv = \"+\";\\r\\nsep_mv_len = 1;\\r\\nindent = 0;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_CPLUS_SPC:\\r\\nsep_dn = \", \";\\r\\nsep_dn_len = 2;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nindent = 0;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_SPLUS_SPC:\\r\\nsep_dn = \"; \";\\r\\nsep_dn_len = 2;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nindent = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\nif(flags & XN_FLAG_SPC_EQ) {\\r\\nsep_eq = \" = \";\\r\\nsep_eq_len = 3;\\r\\n} else {\\r\\nsep_eq = \"=\";\\r\\nsep_eq_len = 1;\\r\\n}\\r\\nfn_opt = flags & XN_FLAG_FN_MASK;\\r\\ncnt = X509_NAME_entry_count(n);\\r\\nfor(i = 0; i < cnt; i++) {\\r\\nif(flags & XN_FLAG_DN_REV)\\r\\nent = X509_NAME_get_entry(n, cnt - i - 1);\\r\\nelse ent = X509_NAME_get_entry(n, i);\\r\\nif(prev != -1) {\\r\\nif(prev == ent->set) {\\r\\nif(!io_ch(arg, sep_mv, sep_mv_len)) return -1;\\r\\noutlen += sep_mv_len;\\r\\n} else {\\r\\nif(!io_ch(arg, sep_dn, sep_dn_len)) return -1;\\r\\noutlen += sep_dn_len;\\r\\nif(!do_indent(io_ch, arg, indent)) return -1;\\r\\noutlen += indent;\\r\\n}\\r\\n}\\r\\nprev = ent->set;\\r\\nfn = X509_NAME_ENTRY_get_object(ent);\\r\\nval = X509_NAME_ENTRY_get_data(ent);\\r\\nfn_nid = OBJ_obj2nid(fn);\\r\\nif(fn_opt != XN_FLAG_FN_NONE) {\\r\\nint objlen, fld_len;\\r\\nif((fn_opt == XN_FLAG_FN_OID) || (fn_nid==NID_undef) ) {\\r\\nOBJ_obj2txt(objtmp, sizeof objtmp, fn, 1);\\r\\nfld_len = 0;\\r\\nobjbuf = objtmp;\\r\\n} else {\\r\\nif(fn_opt == XN_FLAG_FN_SN) {\\r\\nfld_len = FN_WIDTH_SN;\\r\\nobjbuf = OBJ_nid2sn(fn_nid);\\r\\n} else if(fn_opt == XN_FLAG_FN_LN) {\\r\\nfld_len = FN_WIDTH_LN;\\r\\nobjbuf = OBJ_nid2ln(fn_nid);\\r\\n} else {\\r\\nfld_len = 0;\\r\\nobjbuf = \"\";\\r\\n}\\r\\n}\\r\\nobjlen = strlen(objbuf);\\r\\nif(!io_ch(arg, objbuf, objlen)) return -1;\\r\\nif ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) {\\r\\nif (!do_indent(io_ch, arg, fld_len - objlen)) return -1;\\r\\noutlen += fld_len - objlen;\\r\\n}\\r\\nif(!io_ch(arg, sep_eq, sep_eq_len)) return -1;\\r\\noutlen += objlen + sep_eq_len;\\r\\n}\\r\\nif((fn_nid == NID_undef) && (flags & XN_FLAG_DUMP_UNKNOWN_FIELDS))\\r\\norflags = ASN1_STRFLGS_DUMP_ALL;\\r\\nelse orflags = 0;\\r\\nlen = do_print_ex(io_ch, arg, flags | orflags, val);\\r\\nif(len < 0) return -1;\\r\\noutlen += len;\\r\\n}\\r\\nreturn outlen;\\r\\n}\\r\\nint X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unsigned long flags)\\r\\n{\\r\\nif(flags == XN_FLAG_COMPAT)\\r\\nreturn X509_NAME_print(out, nm, indent);\\r\\nreturn do_name_ex(send_bio_chars, out, nm, indent, flags);\\r\\n}\\r\\nint X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unsigned long flags)\\r\\n{\\r\\nif(flags == XN_FLAG_COMPAT)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nbtmp = BIO_new_fp(fp, BIO_NOCLOSE);\\r\\nif(!btmp) return -1;\\r\\nret = X509_NAME_print(btmp, nm, indent);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nreturn do_name_ex(send_fp_chars, fp, nm, indent, flags);\\r\\n}\\r\\nint ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags)\\r\\n{\\r\\nreturn do_print_ex(send_bio_chars, out, flags, str);\\r\\n}\\r\\nint ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags)\\r\\n{\\r\\nreturn do_print_ex(send_fp_chars, fp, flags, str);\\r\\n}\\r\\nint ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in)\\r\\n{\\r\\nASN1_STRING stmp, *str = &stmp;\\r\\nint mbflag, type, ret;\\r\\nif(!in) return -1;\\r\\ntype = in->type;\\r\\nif((type < 0) || (type > 30)) return -1;\\r\\nmbflag = tag2nbyte[type];\\r\\nif(mbflag == -1) return -1;\\r\\nmbflag |= MBSTRING_FLAG;\\r\\nstmp.data = NULL;\\r\\nret = ASN1_mbstring_copy(&str, in->data, in->length, mbflag, B_ASN1_UTF8STRING);\\r\\nif(ret < 0) return ret;\\r\\n*out = stmp.data;\\r\\nreturn stmp.length;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_m_md5_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{ return MD5_Init(ctx->md_data); }\\r\\nstatic int update(EVP_MD_CTX *ctx,const void *data,size_t count)\\r\\n{ return MD5_Update(ctx->md_data,data,count); }\\r\\nstatic int final(EVP_MD_CTX *ctx,unsigned char *md)\\r\\n{ return MD5_Final(md,ctx->md_data); }\\r\\nconst EVP_MD *EVP_md5(void)\\r\\n{\\r\\nreturn(&md5_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rand_egd_c", "target": 0, "func": "int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nint RAND_egd(const char *path)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nint RAND_egd_bytes(const char *path,int bytes)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nint RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\\r\\n{\\r\\nint ret = 0;\\r\\nstruct sockaddr_un addr;\\r\\nint len, num, numbytes;\\r\\nint fd = -1;\\r\\nint success;\\r\\nunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\\r\\nmemset(&addr, 0, sizeof(addr));\\r\\naddr.sun_family = AF_UNIX;\\r\\nif (strlen(path) >= sizeof(addr.sun_path))\\r\\nreturn (-1);\\r\\nBUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);\\r\\nlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\\r\\nfd = socket(AF_UNIX, SOCK_STREAM, 0);\\r\\nif (fd == -1) return (-1);\\r\\nsuccess = 0;\\r\\nwhile (!success)\\r\\n{\\r\\nif (connect(fd, (struct sockaddr *)&addr, len) == 0)\\r\\nsuccess = 1;\\r\\nelse\\r\\n{\\r\\nswitch (errno)\\r\\n{\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n#endif\\r\\n#ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n#endif\\r\\n#ifdef EALREADY\\r\\ncase EALREADY:\\r\\n#endif\\r\\nbreak;\\r\\n#ifdef EISCONN\\r\\ncase EISCONN:\\r\\nsuccess = 1;\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nwhile(bytes > 0)\\r\\n{\\r\\negdbuf[0] = 1;\\r\\negdbuf[1] = bytes < 255 ? bytes : 255;\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != 2)\\r\\n{\\r\\nnum = write(fd, egdbuf + numbytes, 2 - numbytes);\\r\\nif (num >= 0)\\r\\nnumbytes += num;\\r\\nelse\\r\\n{\\r\\nswitch (errno)\\r\\n{\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n#endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != 1)\\r\\n{\\r\\nnum = read(fd, egdbuf, 1);\\r\\nif (num == 0)\\r\\ngoto err;\\r\\nelse if (num > 0)\\r\\nnumbytes += num;\\r\\nelse\\r\\n{\\r\\nswitch (errno)\\r\\n{\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n#endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif(egdbuf[0] == 0)\\r\\ngoto err;\\r\\nif (buf)\\r\\nretrievebuf = buf + ret;\\r\\nelse\\r\\nretrievebuf = tempbuf;\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != egdbuf[0])\\r\\n{\\r\\nnum = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\\r\\nif (num == 0)\\r\\ngoto err;\\r\\nelse if (num > 0)\\r\\nnumbytes += num;\\r\\nelse\\r\\n{\\r\\nswitch (errno)\\r\\n{\\r\\n#ifdef EINTR\\r\\ncase EINTR:\\r\\n#endif\\r\\n#ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n#endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nret += egdbuf[0];\\r\\nbytes -= egdbuf[0];\\r\\nif (!buf)\\r\\nRAND_seed(tempbuf, egdbuf[0]);\\r\\n}\\r\\nerr:\\r\\nif (fd != -1) close(fd);\\r\\nreturn(ret);\\r\\n}\\r\\nint RAND_egd_bytes(const char *path, int bytes)\\r\\n{\\r\\nint num, ret = 0;\\r\\nnum = RAND_query_egd_bytes(path, NULL, bytes);\\r\\nif (num < 1) goto err;\\r\\nif (RAND_status() == 1)\\r\\nret = num;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint RAND_egd(const char *path)\\r\\n{\\r\\nreturn (RAND_egd_bytes(path, 255));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_bss_log_c", "target": 0, "func": "BIO_METHOD *BIO_s_log(void)\\r\\n{\\r\\nreturn(&methods_slg);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->ptr=NULL;\\r\\nxopenlog(bi, \"application\", LOG_DAEMON);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nxcloselog(a);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret= inl;\\r\\nchar* buf;\\r\\nchar* pp;\\r\\nint priority, i;\\r\\nstatic struct\\r\\n{\\r\\nint strl;\\r\\nchar str[10];\\r\\nint log_level;\\r\\n}\\r\\nmapping[] =\\r\\n{\\r\\n{ 6, \"PANIC \", LOG_EMERG },\\r\\n{ 6, \"EMERG \", LOG_EMERG },\\r\\n{ 4, \"EMR \", LOG_EMERG },\\r\\n{ 6, \"ALERT \", LOG_ALERT },\\r\\n{ 4, \"ALR \", LOG_ALERT },\\r\\n{ 5, \"CRIT \", LOG_CRIT },\\r\\n{ 4, \"CRI \", LOG_CRIT },\\r\\n{ 6, \"ERROR \", LOG_ERR },\\r\\n{ 4, \"ERR \", LOG_ERR },\\r\\n{ 8, \"WARNING \", LOG_WARNING },\\r\\n{ 5, \"WARN \", LOG_WARNING },\\r\\n{ 4, \"WAR \", LOG_WARNING },\\r\\n{ 7, \"NOTICE \", LOG_NOTICE },\\r\\n{ 5, \"NOTE \", LOG_NOTICE },\\r\\n{ 4, \"NOT \", LOG_NOTICE },\\r\\n{ 5, \"INFO \", LOG_INFO },\\r\\n{ 4, \"INF \", LOG_INFO },\\r\\n{ 6, \"DEBUG \", LOG_DEBUG },\\r\\n{ 4, \"DBG \", LOG_DEBUG },\\r\\n{ 0, \"\", LOG_ERR }\\r\\n};\\r\\nif((buf= (char *)OPENSSL_malloc(inl+ 1)) == NULL){\\r\\nreturn(0);\\r\\n}\\r\\nstrncpy(buf, in, inl);\\r\\nbuf[inl]= '\\0';\\r\\ni = 0;\\r\\nwhile(strncmp(buf, mapping[i].str, mapping[i].strl) != 0) i++;\\r\\npriority = mapping[i].log_level;\\r\\npp = buf + mapping[i].strl;\\r\\nxsyslog(b, priority, pp);\\r\\nOPENSSL_free(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_SET:\\r\\nxcloselog(b);\\r\\nxopenlog(b, ptr, num);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=slg_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void xopenlog(BIO* bp, char* name, int level)\\r\\n{\\r\\nif ( !register_event_source )\\r\\n{\\r\\nHANDLE advapi;\\r\\nif ( !(advapi = GetModuleHandle(\"advapi32\")) )\\r\\nreturn;\\r\\nregister_event_source = (HANDLE (WINAPI *)())DL_PROC_X(advapi,\\r\\n\"RegisterEventSource\" );\\r\\nderegister_event_source = (BOOL (WINAPI *)())DL_PROC(advapi,\\r\\n\"DeregisterEventSource\");\\r\\nreport_event = (BOOL (WINAPI *)())DL_PROC_X(advapi,\\r\\n\"ReportEvent\" );\\r\\nif ( !(register_event_source && deregister_event_source &&\\r\\nreport_event) )\\r\\n{\\r\\nregister_event_source = NULL;\\r\\nderegister_event_source = NULL;\\r\\nreport_event = NULL;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nbp->ptr= (char *)register_event_source(NULL, name);\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nLPCSTR lpszStrings[2];\\r\\nWORD evtype= EVENTLOG_ERROR_TYPE;\\r\\nint pid = _getpid();\\r\\nchar pidbuf[DECIMAL_SIZE(pid)+4];\\r\\nswitch (priority)\\r\\n{\\r\\ncase LOG_EMERG:\\r\\ncase LOG_ALERT:\\r\\ncase LOG_CRIT:\\r\\ncase LOG_ERR:\\r\\nevtype = EVENTLOG_ERROR_TYPE;\\r\\nbreak;\\r\\ncase LOG_WARNING:\\r\\nevtype = EVENTLOG_WARNING_TYPE;\\r\\nbreak;\\r\\ncase LOG_NOTICE:\\r\\ncase LOG_INFO:\\r\\ncase LOG_DEBUG:\\r\\nevtype = EVENTLOG_INFORMATION_TYPE;\\r\\nbreak;\\r\\ndefault:\\r\\nevtype = EVENTLOG_ERROR_TYPE;\\r\\nbreak;\\r\\n}\\r\\nsprintf(pidbuf, \"[%d] \", pid);\\r\\nlpszStrings[0] = pidbuf;\\r\\nlpszStrings[1] = string;\\r\\nif(report_event && bp->ptr)\\r\\nreport_event(bp->ptr, evtype, 0, 1024, NULL, 2, 0,\\r\\nlpszStrings, NULL);\\r\\n}\\r\\nstatic void xcloselog(BIO* bp)\\r\\n{\\r\\nif(deregister_event_source && bp->ptr)\\r\\nderegister_event_source((HANDLE)(bp->ptr));\\r\\nbp->ptr= NULL;\\r\\n}\\r\\nstatic void xopenlog(BIO* bp, char* name, int level)\\r\\n{\\r\\nVMS_OPC_target = level;\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nstruct dsc$descriptor_s opc_dsc;\\r\\nstruct opcdef *opcdef_p;\\r\\nchar buf[10240];\\r\\nunsigned int len;\\r\\nstruct dsc$descriptor_s buf_dsc;\\r\\n$DESCRIPTOR(fao_cmd, \"!AZ: !AZ\");\\r\\nchar *priority_tag;\\r\\nswitch (priority)\\r\\n{\\r\\ncase LOG_EMERG: priority_tag = \"Emergency\"; break;\\r\\ncase LOG_ALERT: priority_tag = \"Alert\"; break;\\r\\ncase LOG_CRIT: priority_tag = \"Critical\"; break;\\r\\ncase LOG_ERR: priority_tag = \"Error\"; break;\\r\\ncase LOG_WARNING: priority_tag = \"Warning\"; break;\\r\\ncase LOG_NOTICE: priority_tag = \"Notice\"; break;\\r\\ncase LOG_INFO: priority_tag = \"Info\"; break;\\r\\ncase LOG_DEBUG: priority_tag = \"DEBUG\"; break;\\r\\n}\\r\\nbuf_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nbuf_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nbuf_dsc.dsc$a_pointer = buf;\\r\\nbuf_dsc.dsc$w_length = sizeof(buf) - 1;\\r\\nlib$sys_fao(&fao_cmd, &len, &buf_dsc, priority_tag, string);\\r\\nopcdef_p = (struct opcdef *) OPENSSL_malloc(8 + len);\\r\\nopcdef_p->opc$b_ms_type = OPC$_RQ_RQST;\\r\\nmemcpy(opcdef_p->opc$z_ms_target_classes, &VMS_OPC_target, 3);\\r\\nopcdef_p->opc$l_ms_rqstid = 0;\\r\\nmemcpy(&opcdef_p->opc$l_ms_text, buf, len);\\r\\nopc_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nopc_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nopc_dsc.dsc$a_pointer = (char *)opcdef_p;\\r\\nopc_dsc.dsc$w_length = len + 8;\\r\\nsys$sndopr(opc_dsc, 0);\\r\\nOPENSSL_free(opcdef_p);\\r\\n}\\r\\nstatic void xcloselog(BIO* bp)\\r\\n{\\r\\n}\\r\\nstatic void xopenlog(BIO* bp, char* name, int level)\\r\\n{\\r\\n#ifdef WATT32\\r\\nopenlog(name, LOG_PID|LOG_CONS|LOG_NDELAY, level);\\r\\n#else\\r\\nopenlog(name, LOG_PID|LOG_CONS, level);\\r\\n#endif\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nsyslog(priority, \"%s\", string);\\r\\n}\\r\\nstatic void xcloselog(BIO* bp)\\r\\n{\\r\\ncloselog();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_a_octet_c", "target": 0, "func": "ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(ASN1_OCTET_STRING *x)\\r\\n{ return M_ASN1_OCTET_STRING_dup(x); }\\r\\nint ASN1_OCTET_STRING_cmp(ASN1_OCTET_STRING *a, ASN1_OCTET_STRING *b)\\r\\n{ return M_ASN1_OCTET_STRING_cmp(a, b); }\\r\\nint ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *x, const unsigned char *d, int len)\\r\\n{ return M_ASN1_OCTET_STRING_set(x, d, len); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_e_cswift_err_c", "target": 0, "func": "static void ERR_load_CSWIFT_strings(void)\\r\\n{\\r\\nif (CSWIFT_lib_error_code == 0)\\r\\nCSWIFT_lib_error_code=ERR_get_next_error_library();\\r\\nif (CSWIFT_error_init)\\r\\n{\\r\\nCSWIFT_error_init=0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(CSWIFT_lib_error_code,CSWIFT_str_functs);\\r\\nERR_load_strings(CSWIFT_lib_error_code,CSWIFT_str_reasons);\\r\\n#endif\\r\\n#ifdef CSWIFT_LIB_NAME\\r\\nCSWIFT_lib_name->error = ERR_PACK(CSWIFT_lib_error_code,0,0);\\r\\nERR_load_strings(0,CSWIFT_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_CSWIFT_strings(void)\\r\\n{\\r\\nif (CSWIFT_error_init == 0)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(CSWIFT_lib_error_code,CSWIFT_str_functs);\\r\\nERR_unload_strings(CSWIFT_lib_error_code,CSWIFT_str_reasons);\\r\\n#endif\\r\\n#ifdef CSWIFT_LIB_NAME\\r\\nERR_unload_strings(0,CSWIFT_lib_name);\\r\\n#endif\\r\\nCSWIFT_error_init=1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_CSWIFT_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (CSWIFT_lib_error_code == 0)\\r\\nCSWIFT_lib_error_code=ERR_get_next_error_library();\\r\\nERR_PUT_error(CSWIFT_lib_error_code,function,reason,file,line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_rsa_saos_c", "target": 0, "func": "int RSA_sign_ASN1_OCTET_STRING(int type,\\r\\nconst unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, RSA *rsa)\\r\\n{\\r\\nASN1_OCTET_STRING sig;\\r\\nint i,j,ret=1;\\r\\nunsigned char *p,*s;\\r\\nsig.type=V_ASN1_OCTET_STRING;\\r\\nsig.length=m_len;\\r\\nsig.data=(unsigned char *)m;\\r\\ni=i2d_ASN1_OCTET_STRING(&sig,NULL);\\r\\nj=RSA_size(rsa);\\r\\nif (i > (j-RSA_PKCS1_PADDING_SIZE))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=s;\\r\\ni2d_ASN1_OCTET_STRING(&sig,&p);\\r\\ni=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret=0;\\r\\nelse\\r\\n*siglen=i;\\r\\nOPENSSL_cleanse(s,(unsigned int)j+1);\\r\\nOPENSSL_free(s);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_verify_ASN1_OCTET_STRING(int dtype,\\r\\nconst unsigned char *m,\\r\\nunsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\\r\\nRSA *rsa)\\r\\n{\\r\\nint i,ret=0;\\r\\nunsigned char *s;\\r\\nconst unsigned char *p;\\r\\nASN1_OCTET_STRING *sig=NULL;\\r\\nif (siglen != (unsigned int)RSA_size(rsa))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0) goto err;\\r\\np=s;\\r\\nsig=d2i_ASN1_OCTET_STRING(NULL,&p,(long)i);\\r\\nif (sig == NULL) goto err;\\r\\nif ( ((unsigned int)sig->length != m_len) ||\\r\\n(memcmp(m,sig->data,m_len) != 0))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_BAD_SIGNATURE);\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\nerr:\\r\\nif (sig != NULL) M_ASN1_OCTET_STRING_free(sig);\\r\\nif (s != NULL)\\r\\n{\\r\\nOPENSSL_cleanse(s,(unsigned int)siglen);\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_8_ec_print_c", "target": 0, "func": "BIGNUM *EC_POINT_point2bn(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\npoint_conversion_form_t form,\\r\\nBIGNUM *ret,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nsize_t buf_len=0;\\r\\nunsigned char *buf;\\r\\nbuf_len = EC_POINT_point2oct(group, point, form,\\r\\nNULL, 0, ctx);\\r\\nif (buf_len == 0)\\r\\nreturn NULL;\\r\\nif ((buf = OPENSSL_malloc(buf_len)) == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_point2oct(group, point, form, buf, buf_len, ctx))\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nret = BN_bin2bn(buf, buf_len, ret);\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nEC_POINT *EC_POINT_bn2point(const EC_GROUP *group,\\r\\nconst BIGNUM *bn,\\r\\nEC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nsize_t buf_len=0;\\r\\nunsigned char *buf;\\r\\nEC_POINT *ret;\\r\\nif ((buf_len = BN_num_bytes(bn)) == 0) return NULL;\\r\\nbuf = OPENSSL_malloc(buf_len);\\r\\nif (buf == NULL)\\r\\nreturn NULL;\\r\\nif (!BN_bn2bin(bn, buf))\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nif (point == NULL)\\r\\n{\\r\\nif ((ret = EC_POINT_new(group)) == NULL)\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret = point;\\r\\nif (!EC_POINT_oct2point(group, ret, buf, buf_len, ctx))\\r\\n{\\r\\nif (point == NULL)\\r\\nEC_POINT_clear_free(ret);\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nchar *EC_POINT_point2hex(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\npoint_conversion_form_t form,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nchar *ret, *p;\\r\\nsize_t buf_len=0,i;\\r\\nunsigned char *buf, *pbuf;\\r\\nbuf_len = EC_POINT_point2oct(group, point, form,\\r\\nNULL, 0, ctx);\\r\\nif (buf_len == 0)\\r\\nreturn NULL;\\r\\nif ((buf = OPENSSL_malloc(buf_len)) == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_point2oct(group, point, form, buf, buf_len, ctx))\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nret = (char *)OPENSSL_malloc(buf_len*2+2);\\r\\nif (ret == NULL)\\r\\n{\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\np = ret;\\r\\npbuf = buf;\\r\\nfor (i=buf_len; i > 0; i--)\\r\\n{\\r\\nint v = (int) *(pbuf++);\\r\\n*(p++)=HEX_DIGITS[v>>4];\\r\\n*(p++)=HEX_DIGITS[v&0x0F];\\r\\n}\\r\\n*p='\\0';\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nEC_POINT *EC_POINT_hex2point(const EC_GROUP *group,\\r\\nconst char *buf,\\r\\nEC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nEC_POINT *ret=NULL;\\r\\nBIGNUM *tmp_bn=NULL;\\r\\nif (!BN_hex2bn(&tmp_bn, buf))\\r\\nreturn NULL;\\r\\nret = EC_POINT_bn2point(group, tmp_bn, point, ctx);\\r\\nBN_clear_free(tmp_bn);\\r\\nreturn ret;\\r\\n}"
}
]
