[
{
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc4_enc_c", "target": 0, "func": "void RC4(RC4_KEY *key, unsigned long len, unsigned char *indata,\\r\\nunsigned char *outdata)\\r\\n{\\r\\nregister RC4_INT *d;\\r\\nregister RC4_INT x,y,tx,ty;\\r\\nint i;\\r\\nx=key->x;\\r\\ny=key->y;\\r\\nd=key->data;\\r\\n#define LOOP(in,out) \\\\r\\nx=((x+1)&0xff); \\\\r\\ntx=d[x]; \\\\r\\ny=(tx+y)&0xff; \\\\r\\nd[x]=ty=d[y]; \\\\r\\nd[y]=tx; \\\\r\\n(out) = d[(tx+ty)&0xff]^ (in);\\r\\n#ifndef RC4_INDEX\\r\\n#define RC4_LOOP(a,b,i) LOOP(*((a)++),*((b)++))\\r\\n#else\\r\\n#define RC4_LOOP(a,b,i) LOOP(a[i],b[i])\\r\\n#endif\\r\\ni=(int)(len>>3L);\\r\\nif (i)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nRC4_LOOP(indata,outdata,0);\\r\\nRC4_LOOP(indata,outdata,1);\\r\\nRC4_LOOP(indata,outdata,2);\\r\\nRC4_LOOP(indata,outdata,3);\\r\\nRC4_LOOP(indata,outdata,4);\\r\\nRC4_LOOP(indata,outdata,5);\\r\\nRC4_LOOP(indata,outdata,6);\\r\\nRC4_LOOP(indata,outdata,7);\\r\\n#ifdef RC4_INDEX\\r\\nindata+=8;\\r\\noutdata+=8;\\r\\n#endif\\r\\nif (--i == 0) break;\\r\\n}\\r\\n}\\r\\ni=(int)len&0x07;\\r\\nif (i)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nRC4_LOOP(indata,outdata,0); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,1); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,2); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,3); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,4); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,5); if (--i == 0) break;\\r\\nRC4_LOOP(indata,outdata,6); if (--i == 0) break;\\r\\n}\\r\\n}\\r\\nkey->x=x;\\r\\nkey->y=y;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_apps_c", "target": 0, "func": "int args_from_file(char *file, int *argc, char **argv[])\\r\\n{\\r\\nFILE *fp;\\r\\nint num,i;\\r\\nunsigned int len;\\r\\nstatic char *buf=NULL;\\r\\nstatic char **arg=NULL;\\r\\nchar *p;\\r\\nstruct stat stbuf;\\r\\nif (stat(file,&stbuf) < 0) return(0);\\r\\nfp=fopen(file,\"r\");\\r\\nif (fp == NULL)\\r\\nreturn(0);\\r\\n*argc=0;\\r\\n*argv=NULL;\\r\\nlen=(unsigned int)stbuf.st_size;\\r\\nif (buf != NULL) Free(buf);\\r\\nbuf=(char *)Malloc(len+1);\\r\\nif (buf == NULL) return(0);\\r\\nlen=fread(buf,1,len,fp);\\r\\nif (len <= 1) return(0);\\r\\nbuf[len]='\\0';\\r\\ni=0;\\r\\nfor (p=buf; *p; p++)\\r\\nif (*p == '\\n') i++;\\r\\nif (arg != NULL) Free(arg);\\r\\narg=(char **)Malloc(sizeof(char *)*(i*2));\\r\\n*argv=arg;\\r\\nnum=0;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (!*p) break;\\r\\nif (*p == '#')\\r\\n{\\r\\nwhile (*p && (*p != '\\n')) p++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++)=p;\\r\\nnum++;\\r\\nwhile (*p && ((*p != ' ') && (*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (*p == '\\n')\\r\\n{\\r\\n*(p++)='\\0';\\r\\ncontinue;\\r\\n}\\r\\np++;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (*p == '\\n')\\r\\n{\\r\\np++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++)=p++;\\r\\nnum++;\\r\\nwhile (*p && (*p != '\\n')) p++;\\r\\nif (!*p) break;\\r\\n*(p++)='\\0';\\r\\n}\\r\\n*argc=num;\\r\\nreturn(1);\\r\\n}\\r\\nint str2fmt(char *s)\\r\\n{\\r\\nif ((*s == 'D') || (*s == 'd'))\\r\\nreturn(FORMAT_ASN1);\\r\\nelse if ((*s == 'T') || (*s == 't'))\\r\\nreturn(FORMAT_TEXT);\\r\\nelse if ((*s == 'P') || (*s == 'p'))\\r\\nreturn(FORMAT_PEM);\\r\\nelse if ((*s == 'N') || (*s == 'n'))\\r\\nreturn(FORMAT_NETSCAPE);\\r\\nelse\\r\\nreturn(FORMAT_UNDEF);\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nint i,n;\\r\\nchar *p=NULL;\\r\\nn=strlen(in);\\r\\nfor (i=n-1; i>0; i--)\\r\\n{\\r\\nif ((in[i] == '/') || (in[i] == '\\\\') || (in[i] == ':'))\\r\\n{\\r\\np= &(in[i+1]);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p == NULL)\\r\\np=in;\\r\\nn=strlen(p);\\r\\nif ((n > 4) && (p[n-4] == '.') &&\\r\\n((p[n-3] == 'e') || (p[n-3] == 'E')) &&\\r\\n((p[n-2] == 'x') || (p[n-2] == 'X')) &&\\r\\n((p[n-1] == 'e') || (p[n-1] == 'E')))\\r\\nn-=4;\\r\\nif (n > size-1)\\r\\nn=size-1;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((p[i] >= 'A') && (p[i] <= 'Z'))\\r\\nout[i]=p[i]-'A'+'a';\\r\\nelse\\r\\nout[i]=p[i];\\r\\n}\\r\\nout[n]='\\0';\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p=in, *q;\\r\\nchar *chars=\":]>\";\\r\\nwhile(*chars != '\\0')\\r\\n{\\r\\nq=strrchr(p,*chars);\\r\\nif (q > p)\\r\\np = q + 1;\\r\\nchars++;\\r\\n}\\r\\nq=strrchr(p,'.');\\r\\nif (q == NULL)\\r\\nq = in+size;\\r\\nstrncpy(out,p,q-p);\\r\\nout[q-p]='\\0';\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p;\\r\\np=strrchr(in,'/');\\r\\nif (p != NULL)\\r\\np++;\\r\\nelse\\r\\np=in;\\r\\nstrncpy(out,p,size-1);\\r\\nout[size-1]='\\0';\\r\\n}\\r\\nint WIN32_rename(char *from, char *to)\\r\\n{\\r\\n#ifdef WINNT\\r\\nint ret;\\r\\nret=MoveFileEx(from,to,MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED);\\r\\nreturn(ret?0:-1);\\r\\n#else\\r\\nunlink(to);\\r\\nreturn MoveFile(from, to);\\r\\n#endif\\r\\n}\\r\\nint chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])\\r\\n{\\r\\nint num,len,i;\\r\\nchar *p;\\r\\n*argc=0;\\r\\n*argv=NULL;\\r\\nlen=strlen(buf);\\r\\ni=0;\\r\\nif (arg->count == 0)\\r\\n{\\r\\narg->count=20;\\r\\narg->data=(char **)Malloc(sizeof(char *)*arg->count);\\r\\n}\\r\\nfor (i=0; i<arg->count; i++)\\r\\narg->data[i]=NULL;\\r\\nnum=0;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (!*p) break;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p) break;\\r\\nif (num >= arg->count)\\r\\n{\\r\\narg->count+=20;\\r\\narg->data=(char **)Realloc(arg->data,\\r\\nsizeof(char *)*arg->count);\\r\\nif (argc == 0) return(0);\\r\\n}\\r\\narg->data[num++]=p;\\r\\nif ((*p == '\\'') || (*p == '\\\"'))\\r\\n{\\r\\ni= *(p++);\\r\\narg->data[num-1]++;\\r\\nwhile (*p && (*p != i))\\r\\np++;\\r\\n*p='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (*p && ((*p != ' ') &&\\r\\n(*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (*p == '\\0')\\r\\np--;\\r\\nelse\\r\\n*p='\\0';\\r\\n}\\r\\np++;\\r\\n}\\r\\n*argc=num;\\r\\n*argv=arg->data;\\r\\nreturn(1);\\r\\n}\\r\\nint app_init(long mesgwin)\\r\\n{\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_loadkeys_c", "target": 0, "func": "EVP_PKEY * ReadPublicKey(const char *certfile)\\r\\n{\\r\\nFILE *fp = fopen (certfile, \"r\");\\r\\nX509 *x509;\\r\\nEVP_PKEY *pkey;\\r\\nif (!fp)\\r\\nreturn NULL;\\r\\nx509 = (X509 *)PEM_ASN1_read ((char *(*)())d2i_X509,\\r\\nPEM_STRING_X509,\\r\\nfp, NULL, NULL);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn NULL;\\r\\n}\\r\\nfclose (fp);\\r\\npkey=X509_extract_key(x509);\\r\\nX509_free(x509);\\r\\nif (pkey == NULL)\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn pkey;\\r\\n}\\r\\nEVP_PKEY *ReadPrivateKey(const char *keyfile)\\r\\n{\\r\\nFILE *fp = fopen(keyfile, \"r\");\\r\\nEVP_PKEY *pkey;\\r\\nif (!fp)\\r\\nreturn NULL;\\r\\npkey = (EVP_PKEY*)PEM_ASN1_read ((char *(*)())d2i_PrivateKey,\\r\\nPEM_STRING_EVP_PKEY,\\r\\nfp,\\r\\nNULL, NULL);\\r\\nfclose (fp);\\r\\nif (pkey == NULL)\\r\\nERR_print_errors_fp (stderr);\\r\\nreturn pkey;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pem_mail_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nFILE *in;\\r\\nRSA *rsa=NULL;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned int mic=0,i,n;\\r\\nunsigned char buf[1024*15];\\r\\nchar *prog,*infile=NULL,*outfile=NULL,*key=NULL;\\r\\nint badops=0;\\r\\napps_startup();\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-mic\") == 0)\\r\\nmic=1;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nEXIT(1);\\r\\n}\\r\\nif (key == NULL)\\r\\n{ BIO_printf(bio_err,\"you need to specify a key\\n\"); EXIT(1); }\\r\\nin=fopen(key,\"r\");\\r\\nif (in == NULL) { perror(key); EXIT(1); }\\r\\nrsa=PEM_read_RSAPrivateKey(in,NULL,NULL);\\r\\nif (rsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Private Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nEXIT(1);\\r\\n}\\r\\nfclose(in);\\r\\nPEM_SignInit(&ctx,EVP_md5());\\r\\nfor (;;)\\r\\n{\\r\\ni=fread(buf,1,1024*10,stdin);\\r\\nif (i <= 0) break;\\r\\nPEM_SignUpdate(&ctx,buf,i);\\r\\n}\\r\\nif (!PEM_SignFinal(&ctx,buf,&n,rsa)) goto err;\\r\\nBIO_printf(bio_err,\"%s\\n\",buf);\\r\\nEXIT(0);\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nEXIT(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_enc_c", "target": 0, "func": "int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_ENCRYPT *d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_ENCRYPT *,PKCS7_ENCRYPT_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->enc_data,d2i_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_ENCRYPT_free,ASN1_F_D2I_PKCS7_ENCRYPT);\\r\\n}\\r\\nPKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void)\\r\\n{\\r\\nPKCS7_ENCRYPT *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_ENCRYPT);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->enc_data,PKCS7_ENC_CONTENT_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_ENCRYPT_NEW);\\r\\n}\\r\\nvoid PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nPKCS7_ENC_CONTENT_free(a->enc_data);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_md2_c", "target": 0, "func": "EVP_MD *EVP_md2(void)\\r\\n{\\r\\nreturn(&md2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsagen_c", "target": 0, "func": "int cb(int p, int n)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nprintf(\"%c\",c);\\r\\nfflush(stdout);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nint i;\\r\\nBIGNUM *n;\\r\\nBN_CTX *ctx;\\r\\nunsigned char seed_buf[20];\\r\\nDSA *dsa;\\r\\nint counter,h;\\r\\nBIO *bio_err=NULL;\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nmemcpy(seed_buf,seed,20);\\r\\ndsa=DSA_generate_parameters(1024,seed,20,&counter,&h,cb);\\r\\nif (dsa == NULL)\\r\\nDSA_print(bio_err,dsa,0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pk7_lib_c", "target": 1, "func": "long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)\\r\\n{\\r\\nint nid;\\r\\nlong ret;\\r\\nnid=OBJ_obj2nid(p7->type);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase PKCS7_OP_SET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed)\\r\\n{\\r\\nret=p7->detached=(int)larg;\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret=0;\\r\\n}\\r\\nbreak;\\r\\ncase PKCS7_OP_GET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed)\\r\\n{\\r\\nret=p7->detached;\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret=0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,PKCS7_R_UNKNOWN_OPERATION);\\r\\nret=0;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint PKCS7_content_new(PKCS7 *p7, int type)\\r\\n{\\r\\nPKCS7 *ret=NULL;\\r\\nif ((ret=PKCS7_new()) == NULL) goto err;\\r\\nif (!PKCS7_set_type(ret,type)) goto err;\\r\\nif (!PKCS7_set_content(p7,ret)) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (ret != NULL) PKCS7_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)\\r\\n{\\r\\nint i;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nif (p7->d.sign->contents != NULL)\\r\\nPKCS7_content_free(p7->d.sign->contents);\\r\\np7->d.sign->contents=p7_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncase NID_pkcs7_encrypted:\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CONTENT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_set_type(PKCS7 *p7, int type)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nPKCS7_content_free(p7);\\r\\nobj=OBJ_nid2obj(type);\\r\\nswitch (type)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\np7->type=obj;\\r\\nif ((p7->d.sign=PKCS7_SIGNED_new()) == NULL)\\r\\ngoto err;\\r\\nASN1_INTEGER_set(p7->d.sign->version,1);\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\np7->type=obj;\\r\\nif ((p7->d.data=ASN1_OCTET_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\np7->type=obj;\\r\\nif ((p7->d.signed_and_enveloped=PKCS7_SIGN_ENVELOPE_new())\\r\\n== NULL) goto err;\\r\\nASN1_INTEGER_set(p7->d.signed_and_enveloped->version,1);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\np7->type=obj;\\r\\nif ((p7->d.enveloped=PKCS7_ENVELOPE_new())\\r\\n== NULL) goto err;\\r\\nASN1_INTEGER_set(p7->d.enveloped->version,0);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\ncase NID_pkcs7_encrypted:\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_TYPE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)\\r\\n{\\r\\nint i,j,nid;\\r\\nX509_ALGOR *alg;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *signer_sk;\\r\\nSTACK_OF(X509_ALGOR) *md_sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsigner_sk= p7->d.sign->signer_info;\\r\\nmd_sk= p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsigner_sk= p7->d.signed_and_enveloped->signer_info;\\r\\nmd_sk= p7->d.signed_and_enveloped->md_algs;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNER,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nnid=OBJ_obj2nid(psi->digest_alg->algorithm);\\r\\nj=0;\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\n{\\r\\nalg=sk_X509_ALGOR_value(md_sk,i);\\r\\nif (OBJ_obj2nid(alg->algorithm) == nid)\\r\\n{\\r\\nj=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!j)\\r\\n{\\r\\nalg=X509_ALGOR_new();\\r\\nalg->algorithm=OBJ_nid2obj(nid);\\r\\nsk_X509_ALGOR_push(md_sk,alg);\\r\\n}\\r\\nsk_PKCS7_SIGNER_INFO_push(signer_sk,psi);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_add_certificate(PKCS7 *p7, X509 *x509)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509) **sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsk= &(p7->d.sign->cert);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk= &(p7->d.signed_and_enveloped->cert);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk=sk_X509_new_null();\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\nsk_X509_push(*sk,x509);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_CRL) **sk;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nsk= &(p7->d.sign->crl);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk= &(p7->d.signed_and_enveloped->crl);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CRL,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk=sk_X509_CRL_new_null();\\r\\nCRYPTO_add(&crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\nsk_X509_CRL_push(*sk,crl);\\r\\nreturn(1);\\r\\n}\\r\\nint PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,\\r\\nEVP_MD *dgst)\\r\\n{\\r\\nASN1_INTEGER_set(p7i->version,1);\\r\\nX509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509));\\r\\nASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\np7i->issuer_and_serial->serial=\\r\\nASN1_INTEGER_dup(X509_get_serialNumber(x509));\\r\\nCRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\np7i->pkey=pkey;\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\np7i->digest_alg->algorithm=OBJ_nid2obj(NID_sha1);\\r\\nelse\\r\\np7i->digest_alg->algorithm=OBJ_nid2obj(EVP_MD_type(dgst));\\r\\nif (p7i->digest_alg->parameter != NULL)\\r\\nASN1_TYPE_free(p7i->digest_alg->parameter);\\r\\nif ((p7i->digest_alg->parameter=ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\np7i->digest_alg->parameter->type=V_ASN1_NULL;\\r\\np7i->digest_enc_alg->algorithm=OBJ_nid2obj(EVP_PKEY_type(pkey->type));\\r\\nif (p7i->digest_enc_alg->parameter != NULL)\\r\\nASN1_TYPE_free(p7i->digest_enc_alg->parameter);\\r\\nif ((p7i->digest_enc_alg->parameter=ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\np7i->digest_enc_alg->parameter->type=V_ASN1_NULL;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nPKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,\\r\\nEVP_MD *dgst)\\r\\n{\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nif ((si=PKCS7_SIGNER_INFO_new()) == NULL) goto err;\\r\\nif (!PKCS7_SIGNER_INFO_set(si,x509,pkey,dgst)) goto err;\\r\\nif (!PKCS7_add_signer(p7,si)) goto err;\\r\\nreturn(si);\\r\\nerr:\\r\\nreturn(NULL);\\r\\n}\\r\\nint PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)\\r\\n{\\r\\nASN1_INTEGER_set(p7i->version,0);\\r\\nX509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509));\\r\\nASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\np7i->issuer_and_serial->serial=\\r\\nASN1_INTEGER_dup(X509_get_serialNumber(x509));\\r\\nX509_ALGOR_free(p7i->key_enc_algor);\\r\\np7i->key_enc_algor=(X509_ALGOR *)ASN1_dup(i2d_X509_ALGOR,\\r\\n(char *(*)())d2i_X509_ALGOR,\\r\\n(char *)x509->cert_info->key->algor);\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\np7i->cert=x509;\\r\\nreturn(1);\\r\\n}\\r\\nX509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nif (PKCS7_type_is_signed(p7))\\r\\nreturn(X509_find_by_issuer_and_serial(p7->d.sign->cert,\\r\\nsi->issuer_and_serial->issuer,\\r\\nsi->issuer_and_serial->serial));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)\\r\\n{\\r\\nint i;\\r\\nPKCS7_ENC_CONTENT *ec;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nec=p7->d.signed_and_enveloped->enc_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nec=p7->d.enveloped->enc_data;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CIPHER,PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nec->cipher = cipher;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_cmp_c", "target": 0, "func": "int X509_issuer_and_serial_cmp(X509 *a, X509 *b)\\r\\n{\\r\\nint i;\\r\\nX509_CINF *ai,*bi;\\r\\nai=a->cert_info;\\r\\nbi=b->cert_info;\\r\\ni=ASN1_INTEGER_cmp(ai->serialNumber,bi->serialNumber);\\r\\nif (i) return(i);\\r\\nreturn(X509_NAME_cmp(ai->issuer,bi->issuer));\\r\\n}\\r\\nunsigned long X509_issuer_and_serial_hash(X509 *a)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nMD5_CTX ctx;\\r\\nunsigned char md[16];\\r\\nchar str[256];\\r\\nX509_NAME_oneline(a->cert_info->issuer,str,256);\\r\\nret=strlen(str);\\r\\nMD5_Init(&ctx);\\r\\nMD5_Update(&ctx,(unsigned char *)str,ret);\\r\\nMD5_Update(&ctx,(unsigned char *)a->cert_info->serialNumber->data,\\r\\n(unsigned long)a->cert_info->serialNumber->length);\\r\\nMD5_Final(&(md[0]),&ctx);\\r\\nret=( ((unsigned long)md[0] )|((unsigned long)md[1]<<8L)|\\r\\n((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)\\r\\n)&0xffffffffL;\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_issuer_name_cmp(X509 *a, X509 *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->cert_info->issuer,b->cert_info->issuer));\\r\\n}\\r\\nint X509_subject_name_cmp(X509 *a, X509 *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->cert_info->subject,b->cert_info->subject));\\r\\n}\\r\\nint X509_CRL_cmp(X509_CRL *a, X509_CRL *b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(a->crl->issuer,b->crl->issuer));\\r\\n}\\r\\nX509_NAME *X509_get_issuer_name(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->issuer);\\r\\n}\\r\\nunsigned long X509_issuer_name_hash(X509 *x)\\r\\n{\\r\\nreturn(X509_NAME_hash(x->cert_info->issuer));\\r\\n}\\r\\nX509_NAME *X509_get_subject_name(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->subject);\\r\\n}\\r\\nASN1_INTEGER *X509_get_serialNumber(X509 *a)\\r\\n{\\r\\nreturn(a->cert_info->serialNumber);\\r\\n}\\r\\nunsigned long X509_subject_name_hash(X509 *x)\\r\\n{\\r\\nreturn(X509_NAME_hash(x->cert_info->subject));\\r\\n}\\r\\nint X509_NAME_cmp(X509_NAME *a, X509_NAME *b)\\r\\n{\\r\\nint i,j;\\r\\nX509_NAME_ENTRY *na,*nb;\\r\\nif (sk_X509_NAME_ENTRY_num(a->entries)\\r\\n!= sk_X509_NAME_ENTRY_num(b->entries))\\r\\nreturn sk_X509_NAME_ENTRY_num(a->entries)\\r\\n-sk_X509_NAME_ENTRY_num(b->entries);\\r\\nfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\\r\\n{\\r\\nna=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nnb=sk_X509_NAME_ENTRY_value(b->entries,i);\\r\\nj=na->value->length-nb->value->length;\\r\\nif (j) return(j);\\r\\nj=memcmp(na->value->data,nb->value->data,\\r\\nna->value->length);\\r\\nif (j) return(j);\\r\\nj=na->set-nb->set;\\r\\nif (j) return(j);\\r\\n}\\r\\nfor (i=sk_X509_NAME_ENTRY_num(a->entries)-1; i>=0; i--)\\r\\n{\\r\\nna=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nnb=sk_X509_NAME_ENTRY_value(b->entries,i);\\r\\nj=OBJ_cmp(na->object,nb->object);\\r\\nif (j) return(j);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nunsigned long X509_NAME_hash(X509_NAME *x)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nunsigned char md[16];\\r\\nunsigned char str[256],*p,*pp;\\r\\nint i;\\r\\ni=i2d_X509_NAME(x,NULL);\\r\\nif (i > sizeof(str))\\r\\np=Malloc(i);\\r\\nelse\\r\\np=str;\\r\\npp=p;\\r\\ni2d_X509_NAME(x,&pp);\\r\\nMD5((unsigned char *)p,i,&(md[0]));\\r\\nif (p != str) Free(p);\\r\\nret=( ((unsigned long)md[0] )|((unsigned long)md[1]<<8L)|\\r\\n((unsigned long)md[2]<<16L)|((unsigned long)md[3]<<24L)\\r\\n)&0xffffffffL;\\r\\nreturn(ret);\\r\\n}\\r\\nEVP_PKEY *X509_get_pubkey(X509 *x)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn(NULL);\\r\\nreturn(X509_PUBKEY_get(x->cert_info->key));\\r\\n}\\r\\nint X509_check_private_key(X509 *x, EVP_PKEY *k)\\r\\n{\\r\\nEVP_PKEY *xk=NULL;\\r\\nint ok=0;\\r\\nxk=X509_get_pubkey(x);\\r\\nif (xk->type != k->type)\\r\\n{\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_KEY_TYPE_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nswitch (k->type)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif (BN_cmp(xk->pkey.rsa->n,k->pkey.rsa->n) != 0\\r\\n|| BN_cmp(xk->pkey.rsa->e,k->pkey.rsa->e) != 0)\\r\\n{\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_KEY_VALUES_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif (BN_cmp(xk->pkey.dsa->pub_key,k->pkey.dsa->pub_key) != 0)\\r\\n{\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_KEY_VALUES_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ncase EVP_PKEY_DH:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_CANT_CHECK_DH_KEY);\\r\\ngoto err;\\r\\n#endif\\r\\ndefault:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY,X509_R_UNKNOWN_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nEVP_PKEY_free(xk);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_verify_c", "target": 1, "func": "int ASN1_verify(int (*i2d)(), X509_ALGOR *a, ASN1_BIT_STRING *signature,\\r\\nchar *data, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nconst EVP_MD *type;\\r\\nunsigned char *p,*buf_in=NULL;\\r\\nint ret= -1,i,inl;\\r\\ni=OBJ_obj2nid(a->algorithm);\\r\\ntype=EVP_get_digestbyname(OBJ_nid2sn(i));\\r\\nif (type == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\ninl=i2d(data,NULL);\\r\\nbuf_in=Malloc((unsigned int)inl);\\r\\nif (buf_in == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf_in;\\r\\ni2d(data,&p);\\r\\nEVP_VerifyInit(&ctx,type);\\r\\nEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nmemset(buf_in,0,(unsigned int)inl);\\r\\nFree((char *)buf_in);\\r\\nif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\\r\\n(unsigned int)signature->length,pkey) <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_VERIFY,ERR_R_EVP_LIB);\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pkcs12_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar *infile=NULL, *outfile=NULL, *keyname = NULL;\\r\\nchar *certfile=NULL;\\r\\nBIO *in=NULL, *out = NULL, *inkey = NULL, *certsin = NULL;\\r\\nchar **args;\\r\\nchar *name = NULL;\\r\\nPKCS12 *p12 = NULL;\\r\\nchar pass[50], macpass[50];\\r\\nint export_cert = 0;\\r\\nint options = 0;\\r\\nint chain = 0;\\r\\nint badarg = 0;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint maciter = 1;\\r\\nint twopass = 0;\\r\\nint keytype = 0;\\r\\nint cert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;\\r\\nint ret = 1;\\r\\nint macver = 1;\\r\\nint noprompt = 0;\\r\\nSTACK *canames = NULL;\\r\\nchar *cpass = NULL, *mpass = NULL;\\r\\napps_startup();\\r\\nenc = EVP_des_ede3_cbc();\\r\\nif (bio_err == NULL ) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\nargs = argv + 1;\\r\\nwhile (*args) {\\r\\nif (*args[0] == '-') {\\r\\nif (!strcmp (*args, \"-nokeys\")) options |= NOKEYS;\\r\\nelse if (!strcmp (*args, \"-keyex\")) keytype = KEY_EX;\\r\\nelse if (!strcmp (*args, \"-keysig\")) keytype = KEY_SIG;\\r\\nelse if (!strcmp (*args, \"-nocerts\")) options |= NOCERTS;\\r\\nelse if (!strcmp (*args, \"-clcerts\")) options |= CLCERTS;\\r\\nelse if (!strcmp (*args, \"-cacerts\")) options |= CACERTS;\\r\\nelse if (!strcmp (*args, \"-noout\")) options |= (NOKEYS|NOCERTS);\\r\\nelse if (!strcmp (*args, \"-info\")) options |= INFO;\\r\\nelse if (!strcmp (*args, \"-chain\")) chain = 1;\\r\\nelse if (!strcmp (*args, \"-twopass\")) twopass = 1;\\r\\nelse if (!strcmp (*args, \"-nomacver\")) macver = 0;\\r\\nelse if (!strcmp (*args, \"-descert\"))\\r\\ncert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nelse if (!strcmp (*args, \"-export\")) export_cert = 1;\\r\\nelse if (!strcmp (*args, \"-des\")) enc=EVP_des_cbc();\\r\\n#ifndef NO_IDEA\\r\\nelse if (!strcmp (*args, \"-idea\")) enc=EVP_idea_cbc();\\r\\n#endif\\r\\nelse if (!strcmp (*args, \"-des3\")) enc = EVP_des_ede3_cbc();\\r\\nelse if (!strcmp (*args, \"-noiter\")) iter = 1;\\r\\nelse if (!strcmp (*args, \"-maciter\"))\\r\\nmaciter = PKCS12_DEFAULT_ITER;\\r\\nelse if (!strcmp (*args, \"-nodes\")) enc=NULL;\\r\\nelse if (!strcmp (*args, \"-inkey\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nkeyname = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-certfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncertfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-name\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nname = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-caname\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!canames) canames = sk_new(NULL);\\r\\nsk_push(canames, *args);\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-envpass\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif(!(cpass = getenv(*args))) {\\r\\nBIO_printf(bio_err,\\r\\n\"Can't read environment variable %s\\n\", *args);\\r\\ngoto end;\\r\\n}\\r\\nnoprompt = 1;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-password\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncpass = *args;\\r\\nnoprompt = 1;\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf (bio_err, \"Usage: pkcs12 [options]\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-export output PKCS12 file\\n\");\\r\\nBIO_printf (bio_err, \"-chain add certificate chain\\n\");\\r\\nBIO_printf (bio_err, \"-inkey file private key if not infile\\n\");\\r\\nBIO_printf (bio_err, \"-certfile f add all certs in f\\n\");\\r\\nBIO_printf (bio_err, \"-name \\\"name\\\" use name as friendly name\\n\");\\r\\nBIO_printf (bio_err, \"-caname \\\"nm\\\" use nm as CA friendly name (can be used more than once).\\n\");\\r\\nBIO_printf (bio_err, \"-in infile input filename\\n\");\\r\\nBIO_printf (bio_err, \"-out outfile output filename\\n\");\\r\\nBIO_printf (bio_err, \"-noout don't output anything, just verify.\\n\");\\r\\nBIO_printf (bio_err, \"-nomacver don't verify MAC.\\n\");\\r\\nBIO_printf (bio_err, \"-nocerts don't output certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-clcerts only output client certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-cacerts only output CA certificates.\\n\");\\r\\nBIO_printf (bio_err, \"-nokeys don't output private keys.\\n\");\\r\\nBIO_printf (bio_err, \"-info give info about PKCS#12 structure.\\n\");\\r\\nBIO_printf (bio_err, \"-des encrypt private keys with DES\\n\");\\r\\nBIO_printf (bio_err, \"-des3 encrypt private keys with triple DES (default)\\n\");\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf (bio_err, \"-idea encrypt private keys with idea\\n\");\\r\\n#endif\\r\\nBIO_printf (bio_err, \"-nodes don't encrypt private keys\\n\");\\r\\nBIO_printf (bio_err, \"-noiter don't use encryption iteration\\n\");\\r\\nBIO_printf (bio_err, \"-maciter use MAC iteration\\n\");\\r\\nBIO_printf (bio_err, \"-twopass separate MAC, encryption passwords\\n\");\\r\\nBIO_printf (bio_err, \"-descert encrypt PKCS#12 certificates with triple DES (default RC2-40)\\n\");\\r\\nBIO_printf (bio_err, \"-keyex set MS key exchange type\\n\");\\r\\nBIO_printf (bio_err, \"-keysig set MS key signature type\\n\");\\r\\nBIO_printf (bio_err, \"-password p set import/export password (NOT RECOMMENDED)\\n\");\\r\\nBIO_printf (bio_err, \"-envpass p set import/export password from environment\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif(cpass) mpass = cpass;\\r\\nelse {\\r\\ncpass = pass;\\r\\nmpass = macpass;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (!infile) in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nelse in = BIO_new_file(infile, \"rb\");\\r\\nif (!in) {\\r\\nBIO_printf(bio_err, \"Error opening input file %s\\n\",\\r\\ninfile ? infile : \"<stdin>\");\\r\\nperror (infile);\\r\\ngoto end;\\r\\n}\\r\\nif (certfile) {\\r\\nif(!(certsin = BIO_new_file(certfile, \"r\"))) {\\r\\nBIO_printf(bio_err, \"Can't open certificate file %s\\n\", certfile);\\r\\nperror (certfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (keyname) {\\r\\nif(!(inkey = BIO_new_file(keyname, \"r\"))) {\\r\\nBIO_printf(bio_err, \"Can't key certificate file %s\\n\", keyname);\\r\\nperror (keyname);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!outfile) out = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nelse out = BIO_new_file(outfile, \"wb\");\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file %s\\n\",\\r\\noutfile ? outfile : \"<stdout>\");\\r\\nperror (outfile);\\r\\ngoto end;\\r\\n}\\r\\nif (twopass) {\\r\\nif(EVP_read_pw_string (macpass, 50, \"Enter MAC Password:\", export_cert))\\r\\n{\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (export_cert) {\\r\\nEVP_PKEY *key;\\r\\nSTACK *bags, *safes;\\r\\nPKCS12_SAFEBAG *bag;\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nPKCS7 *authsafe;\\r\\nX509 *cert = NULL, *ucert = NULL;\\r\\nSTACK_OF(X509) *certs;\\r\\nchar *catmp;\\r\\nint i;\\r\\nunsigned char keyid[EVP_MAX_MD_SIZE];\\r\\nunsigned int keyidlen = 0;\\r\\nkey = PEM_read_bio_PrivateKey(inkey ? inkey : in, NULL, NULL, NULL);\\r\\nif (!inkey) (void) BIO_reset(in);\\r\\nif (!key) {\\r\\nBIO_printf (bio_err, \"Error loading private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ncerts = sk_X509_new(NULL);\\r\\nif(!cert_load(in, certs)) {\\r\\nBIO_printf(bio_err, \"Error loading certificates from input\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nfor(i = 0; i < sk_X509_num(certs); i++) {\\r\\nucert = sk_X509_value(certs, i);\\r\\nif(X509_check_private_key(ucert, key)) {\\r\\nX509_digest(cert, EVP_sha1(), keyid, &keyidlen);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif(!keyidlen) {\\r\\nBIO_printf(bio_err, \"No certificate matches private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nbags = sk_new (NULL);\\r\\nif (certsin) {\\r\\nif(!cert_load(certsin, certs)) {\\r\\nBIO_printf(bio_err, \"Error loading certificates from certfile\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_free(certsin);\\r\\n}\\r\\nif (chain) {\\r\\nint vret;\\r\\nSTACK_OF(X509) *chain2;\\r\\nvret = get_cert_chain (ucert, &chain2);\\r\\nif (vret) {\\r\\nBIO_printf (bio_err, \"Error %s getting chain.\\n\",\\r\\nX509_verify_cert_error_string(vret));\\r\\ngoto end;\\r\\n}\\r\\nfor (i = 1; i < sk_X509_num (chain2) ; i++)\\r\\nsk_X509_push(certs, sk_X509_value (chain2, i));\\r\\nsk_X509_free(chain2);\\r\\n}\\r\\nfor(i = 0; i < sk_X509_num(certs); i++) {\\r\\ncert = sk_X509_value(certs, i);\\r\\nbag = M_PKCS12_x5092certbag(cert);\\r\\nif(cert == ucert) {\\r\\nif(name) PKCS12_add_friendlyname(bag, name, -1);\\r\\nPKCS12_add_localkeyid(bag, keyid, keyidlen);\\r\\n} else if((catmp = sk_shift(canames)))\\r\\nPKCS12_add_friendlyname(bag, catmp, -1);\\r\\nsk_push(bags, (char *)bag);\\r\\n}\\r\\nif (canames) sk_free(canames);\\r\\nif(!noprompt &&\\r\\nEVP_read_pw_string(pass, 50, \"Enter Export Password:\", 1)) {\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!twopass) strcpy(macpass, pass);\\r\\nauthsafe = PKCS12_pack_p7encdata(cert_pbe, cpass, -1, NULL, 0,\\r\\niter, bags);\\r\\nsk_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nif (!authsafe) {\\r\\nERR_print_errors (bio_err);\\r\\ngoto end;\\r\\n}\\r\\nsafes = sk_new (NULL);\\r\\nsk_push (safes, (char *)authsafe);\\r\\np8 = EVP_PKEY2PKCS8 (key);\\r\\nEVP_PKEY_free(key);\\r\\nif(keytype) PKCS8_add_keyusage(p8, keytype);\\r\\nbag = PKCS12_MAKE_SHKEYBAG(NID_pbe_WithSHA1And3_Key_TripleDES_CBC,\\r\\ncpass, -1, NULL, 0, iter, p8);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nif (name) PKCS12_add_friendlyname (bag, name, -1);\\r\\nPKCS12_add_localkeyid (bag, keyid, keyidlen);\\r\\nbags = sk_new(NULL);\\r\\nsk_push (bags, (char *)bag);\\r\\nauthsafe = PKCS12_pack_p7data (bags);\\r\\nsk_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nsk_push (safes, (char *)authsafe);\\r\\np12 = PKCS12_init (NID_pkcs7_data);\\r\\nM_PKCS12_pack_authsafes (p12, safes);\\r\\nsk_pop_free(safes, PKCS7_free);\\r\\nPKCS12_set_mac (p12, mpass, -1, NULL, 0, maciter, NULL);\\r\\ni2d_PKCS12_bio (out, p12);\\r\\nPKCS12_free(p12);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!(p12 = d2i_PKCS12_bio (in, NULL))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif(!noprompt && EVP_read_pw_string(pass, 50, \"Enter Import Password:\", 0)) {\\r\\nBIO_printf (bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!twopass) strcpy(macpass, pass);\\r\\nif (options & INFO) BIO_printf (bio_err, \"MAC Iteration %ld\\n\", p12->mac->iter ? ASN1_INTEGER_get (p12->mac->iter) : 1);\\r\\nif(macver) {\\r\\nif (!PKCS12_verify_mac (p12, mpass, -1)) {\\r\\nBIO_printf (bio_err, \"Mac verify errror: invalid password?\\n\");\\r\\nERR_print_errors (bio_err);\\r\\ngoto end;\\r\\n} else BIO_printf (bio_err, \"MAC verified OK\\n\");\\r\\n}\\r\\nif (!dump_certs_keys_p12 (out, p12, cpass, -1, options)) {\\r\\nBIO_printf(bio_err, \"Error outputting keys and certificates\\n\");\\r\\nERR_print_errors (bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPKCS12_free(p12);\\r\\nret = 0;\\r\\nend:\\r\\nBIO_free(out);\\r\\nEXIT(ret);\\r\\n}\\r\\nint dump_cert_text (BIO *out, X509 *x)\\r\\n{\\r\\nchar buf[256];\\r\\nX509_NAME_oneline(X509_get_subject_name(x),buf,256);\\r\\nBIO_puts(out,\"subject=\");\\r\\nBIO_puts(out,buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(x),buf,256);\\r\\nBIO_puts(out,\"\\nissuer= \");\\r\\nBIO_puts(out,buf);\\r\\nBIO_puts(out,\"\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nint dump_certs_keys_p12 (BIO *out, PKCS12 *p12, char *pass,\\r\\nint passlen, int options)\\r\\n{\\r\\nSTACK *asafes, *bags;\\r\\nint i, bagnid;\\r\\nPKCS7 *p7;\\r\\nif (!( asafes = M_PKCS12_unpack_authsafes (p12))) return 0;\\r\\nfor (i = 0; i < sk_num (asafes); i++) {\\r\\np7 = (PKCS7 *) sk_value (asafes, i);\\r\\nbagnid = OBJ_obj2nid (p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = M_PKCS12_unpack_p7data (p7);\\r\\nif (options & INFO) BIO_printf (bio_err, \"PKCS7 Data\\n\");\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nif (options & INFO) {\\r\\nBIO_printf (bio_err, \"PKCS7 Encrypted data: \");\\r\\nalg_print (bio_err,\\r\\np7->d.encrypted->enc_data->algorithm);\\r\\n}\\r\\nbags = M_PKCS12_unpack_p7encdata (p7, pass, passlen);\\r\\n} else continue;\\r\\nif (!bags) return 0;\\r\\nif (!dump_certs_pkeys_bags (out, bags, pass, passlen,\\r\\noptions)) {\\r\\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\n}\\r\\nsk_pop_free (asafes, PKCS7_free);\\r\\nreturn 1;\\r\\n}\\r\\nint dump_certs_pkeys_bags (BIO *out, STACK *bags, char *pass,\\r\\nint passlen, int options)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < sk_num (bags); i++) {\\r\\nif (!dump_certs_pkeys_bag (out,\\r\\n(PKCS12_SAFEBAG *)sk_value (bags, i), pass, passlen,\\r\\noptions)) return 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint dump_certs_pkeys_bag (BIO *out, PKCS12_SAFEBAG *bag, char *pass,\\r\\nint passlen, int options)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509 *x509;\\r\\nswitch (M_PKCS12_bag_type(bag))\\r\\n{\\r\\ncase NID_keyBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Key bag\\n\");\\r\\nif (options & NOKEYS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\np8 = bag->value.keybag;\\r\\nif (!(pkey = EVP_PKCS82PKEY (p8))) return 0;\\r\\nprint_attribs (out, p8->attributes, \"Key Attributes\");\\r\\nPEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nif (options & INFO) {\\r\\nBIO_printf (bio_err, \"Shrouded Keybag: \");\\r\\nalg_print (bio_err, bag->value.shkeybag->algor);\\r\\n}\\r\\nif (options & NOKEYS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nif (!(p8 = M_PKCS12_decrypt_skey (bag, pass, passlen)))\\r\\nreturn 0;\\r\\nif (!(pkey = EVP_PKCS82PKEY (p8))) return 0;\\r\\nprint_attribs (out, p8->attributes, \"Key Attributes\");\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nPEM_write_bio_PrivateKey (out, pkey, enc, NULL, 0, NULL, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Certificate bag\\n\");\\r\\nif (options & NOCERTS) return 1;\\r\\nif (PKCS12_get_attr(bag, NID_localKeyID)) {\\r\\nif (options & CACERTS) return 1;\\r\\n} else if (options & CLCERTS) return 1;\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate )\\r\\nreturn 1;\\r\\nif (!(x509 = M_PKCS12_certbag2x509(bag))) return 0;\\r\\ndump_cert_text (out, x509);\\r\\nPEM_write_bio_X509 (out, x509);\\r\\nX509_free(x509);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nif (options & INFO) BIO_printf (bio_err, \"Safe Contents bag\\n\");\\r\\nprint_attribs (out, bag->attrib, \"Bag Attributes\");\\r\\nreturn dump_certs_pkeys_bags (out, bag->value.safes, pass,\\r\\npasslen, options);\\r\\ndefault:\\r\\nBIO_printf (bio_err, \"Warning unsupported bag type: \");\\r\\ni2a_ASN1_OBJECT (bio_err, bag->type);\\r\\nBIO_printf (bio_err, \"\\n\");\\r\\nreturn 1;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint alg_print (BIO *x, X509_ALGOR *alg)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nunsigned char *p;\\r\\np = alg->parameter->value.sequence->data;\\r\\npbe = d2i_PBEPARAM (NULL, &p, alg->parameter->value.sequence->length);\\r\\nBIO_printf (bio_err, \"%s, Iteration %d\\n\",\\r\\nOBJ_nid2ln(OBJ_obj2nid(alg->algorithm)), ASN1_INTEGER_get(pbe->iter));\\r\\nPBEPARAM_free (pbe);\\r\\nreturn 0;\\r\\n}\\r\\nvoid hex_prin(BIO *out, unsigned char *buf, int len)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < len; i++) BIO_printf (out, \"%02X \", buf[i]);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pkcs7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nPKCS7 *p7=NULL;\\r\\nint i,badops=0;\\r\\n#if !defined(NO_DES) || !defined(NO_IDEA)\\r\\nEVP_CIPHER *enc=NULL;\\r\\n#endif\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile,*outfile,*prog,buf[256];\\r\\nint print_certs=0;\\r\\nint ret=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-print_certs\") == 0)\\r\\nprint_certs=1;\\r\\n#ifndef NO_DES\\r\\nelse if (strcmp(*argv,\"-des\") == 0)\\r\\nenc=EVP_des_cbc();\\r\\nelse if (strcmp(*argv,\"-des3\") == 0)\\r\\nenc=EVP_des_ede3_cbc();\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nelse if (strcmp(*argv,\"-idea\") == 0)\\r\\nenc=EVP_idea_cbc();\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -print_certs print any certs or crl in the input\\n\");\\r\\nBIO_printf(bio_err,\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n#endif\\r\\nEXIT(1);\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\nif (in == NULL)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\np7=d2i_PKCS7_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\np7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for pkcs7 object\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (p7 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load PKCS7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (print_certs)\\r\\n{\\r\\nSTACK_OF(X509) *certs=NULL;\\r\\nSTACK_OF(X509_CRL) *crls=NULL;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\ncerts=p7->d.sign->cert;\\r\\ncrls=p7->d.sign->crl;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncerts=p7->d.signed_and_enveloped->cert;\\r\\ncrls=p7->d.signed_and_enveloped->crl;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (certs != NULL)\\r\\n{\\r\\nX509 *x;\\r\\nfor (i=0; i<sk_X509_num(certs); i++)\\r\\n{\\r\\nx=sk_X509_value(certs,i);\\r\\nX509_NAME_oneline(X509_get_subject_name(x),\\r\\nbuf,256);\\r\\nBIO_puts(out,\"subject=\");\\r\\nBIO_puts(out,buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(x),\\r\\nbuf,256);\\r\\nBIO_puts(out,\"\\nissuer= \");\\r\\nBIO_puts(out,buf);\\r\\nBIO_puts(out,\"\\n\");\\r\\nPEM_write_bio_X509(out,x);\\r\\nBIO_puts(out,\"\\n\");\\r\\n}\\r\\n}\\r\\nif (crls != NULL)\\r\\n{\\r\\nX509_CRL *crl;\\r\\nfor (i=0; i<sk_X509_CRL_num(crls); i++)\\r\\n{\\r\\ncrl=sk_X509_CRL_value(crls,i);\\r\\nX509_NAME_oneline(crl->crl->issuer,buf,256);\\r\\nBIO_puts(out,\"issuer= \");\\r\\nBIO_puts(out,buf);\\r\\nBIO_puts(out,\"\\nlast update=\");\\r\\nASN1_TIME_print(out,crl->crl->lastUpdate);\\r\\nBIO_puts(out,\"\\nnext update=\");\\r\\nASN1_TIME_print(out,crl->crl->nextUpdate);\\r\\nBIO_puts(out,\"\\n\");\\r\\nPEM_write_bio_X509_CRL(out,crl);\\r\\nBIO_puts(out,\"\\n\");\\r\\n}\\r\\n}\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_PKCS7_bio(out,p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_PKCS7(out,p7);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (p7 != NULL) PKCS7_free(p7);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_exp_c", "target": 0, "func": "int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint r=0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(m);\\r\\nt= &(ctx->bn[ctx->tos++]);\\r\\nif (a == b)\\r\\n{ if (!BN_sqr(t,a,ctx)) goto err; }\\r\\nelse\\r\\n{ if (!BN_mul(t,a,b,ctx)) goto err; }\\r\\nif (!BN_mod(ret,t,m,ctx)) goto err;\\r\\nr=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nreturn(r);\\r\\n}\\r\\nint BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint i,bits,ret=0,tos;\\r\\nBIGNUM *v,*rr;\\r\\ntos=ctx->tos;\\r\\nv= &(ctx->bn[ctx->tos++]);\\r\\nif ((r == a) || (r == p))\\r\\nrr= &(ctx->bn[ctx->tos++]);\\r\\nelse\\r\\nrr=r;\\r\\nif (BN_copy(v,a) == NULL) goto err;\\r\\nbits=BN_num_bits(p);\\r\\nif (BN_is_odd(p))\\r\\n{ if (BN_copy(rr,a) == NULL) goto err; }\\r\\nelse { if (!BN_one(rr)) goto err; }\\r\\nfor (i=1; i<bits; i++)\\r\\n{\\r\\nif (!BN_sqr(v,v,ctx)) goto err;\\r\\nif (BN_is_bit_set(p,i))\\r\\n{\\r\\nif (!BN_mul(rr,rr,v,ctx)) goto err;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos=tos;\\r\\nif (r != rr) BN_copy(r,rr);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\n#ifdef MONT_MUL_MOD\\r\\nif (BN_is_odd(m))\\r\\n{ ret=BN_mod_exp_mont(r,a,p,m,ctx,NULL); }\\r\\nelse\\r\\n#endif\\r\\n#ifdef RECP_MUL_MOD\\r\\n{ ret=BN_mod_exp_recp(r,a,p,m,ctx); }\\r\\n#else\\r\\n{ ret=BN_mod_exp_simple(r,a,p,m,ctx); }\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue;\\r\\nint start=1,ts=0;\\r\\nBIGNUM *aa;\\r\\nBIGNUM val[TABLE_SIZE];\\r\\nBN_RECP_CTX recp;\\r\\naa= &(ctx->bn[ctx->tos++]);\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nBN_one(r);\\r\\nreturn(1);\\r\\n}\\r\\nBN_RECP_CTX_init(&recp);\\r\\nif (BN_RECP_CTX_set(&recp,m,ctx) <= 0) goto err;\\r\\nBN_init(&(val[0]));\\r\\nts=1;\\r\\nif (!BN_mod(&(val[0]),a,m,ctx)) goto err;\\r\\nif (!BN_mod_mul_reciprocal(aa,&(val[0]),&(val[0]),&recp,ctx))\\r\\ngoto err;\\r\\nif (bits <= 17)\\r\\nwindow=1;\\r\\nelse if (bits >= 256)\\r\\nwindow=5;\\r\\nelse if (bits >= 128)\\r\\nwindow=4;\\r\\nelse\\r\\nwindow=3;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nBN_init(&val[i]);\\r\\nif (!BN_mod_mul_reciprocal(&(val[i]),&(val[i-1]),aa,&recp,ctx))\\r\\ngoto err;\\r\\n}\\r\\nts=i;\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_one(r)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\nif (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))\\r\\ngoto err;\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul_reciprocal(r,r,r,&recp,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_reciprocal(r,r,&(val[wvalue>>1]),&recp,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nfor (i=0; i<ts; i++)\\r\\nBN_clear_free(&(val[i]));\\r\\nBN_RECP_CTX_free(&recp);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_mont(BIGNUM *rr, BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue;\\r\\nint start=1,ts=0;\\r\\nBIGNUM *d,*r;\\r\\nBIGNUM *aa;\\r\\nBIGNUM val[TABLE_SIZE];\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\nif (!(m->d[0] & 1))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nd= &(ctx->bn[ctx->tos++]);\\r\\nr= &(ctx->bn[ctx->tos++]);\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nBN_one(r);\\r\\nreturn(1);\\r\\n}\\r\\n#if 1\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,m,ctx)) goto err;\\r\\n}\\r\\nBN_init(&val[0]);\\r\\nts=1;\\r\\nif (BN_ucmp(a,m) >= 0)\\r\\n{\\r\\nBN_mod(&(val[0]),a,m,ctx);\\r\\naa= &(val[0]);\\r\\n}\\r\\nelse\\r\\naa=a;\\r\\nif (!BN_to_montgomery(&(val[0]),aa,mont,ctx)) goto err;\\r\\nif (!BN_mod_mul_montgomery(d,&(val[0]),&(val[0]),mont,ctx)) goto err;\\r\\nif (bits <= 20)\\r\\nwindow=1;\\r\\nelse if (bits >= 256)\\r\\nwindow=5;\\r\\nelse if (bits >= 128)\\r\\nwindow=4;\\r\\nelse\\r\\nwindow=3;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nBN_init(&(val[i]));\\r\\nif (!BN_mod_mul_montgomery(&(val[i]),&(val[i-1]),d,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nts=i;\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_montgomery(r,r,&(val[wvalue>>1]),mont,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nBN_from_montgomery(rr,r,mont,ctx);\\r\\nret=1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nctx->tos-=2;\\r\\nfor (i=0; i<ts; i++)\\r\\nBN_clear_free(&(val[i]));\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_mod_exp_simple(BIGNUM *r, BIGNUM *a, BIGNUM *p, BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i,j,bits,ret=0,wstart,wend,window,wvalue,ts=0;\\r\\nint start=1;\\r\\nBIGNUM *d;\\r\\nBIGNUM val[TABLE_SIZE];\\r\\nd= &(ctx->bn[ctx->tos++]);\\r\\nbits=BN_num_bits(p);\\r\\nif (bits == 0)\\r\\n{\\r\\nBN_one(r);\\r\\nreturn(1);\\r\\n}\\r\\nBN_init(&(val[0]));\\r\\nts=1;\\r\\nif (!BN_mod(&(val[0]),a,m,ctx)) goto err;\\r\\nif (!BN_mod_mul(d,&(val[0]),&(val[0]),m,ctx))\\r\\ngoto err;\\r\\nif (bits <= 17)\\r\\nwindow=1;\\r\\nelse if (bits >= 256)\\r\\nwindow=5;\\r\\nelse if (bits >= 128)\\r\\nwindow=4;\\r\\nelse\\r\\nwindow=3;\\r\\nj=1<<(window-1);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\nBN_init(&(val[i]));\\r\\nif (!BN_mod_mul(&(val[i]),&(val[i-1]),d,m,ctx))\\r\\ngoto err;\\r\\n}\\r\\nts=i;\\r\\nstart=1;\\r\\nwvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_one(r)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_bit_set(p,wstart) == 0)\\r\\n{\\r\\nif (!start)\\r\\nif (!BN_mod_mul(r,r,r,m,ctx))\\r\\ngoto err;\\r\\nif (wstart == 0) break;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwvalue=1;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nif (BN_is_bit_set(p,wstart-i))\\r\\n{\\r\\nwvalue<<=(i-wend);\\r\\nwvalue|=1;\\r\\nwend=i;\\r\\n}\\r\\n}\\r\\nj=wend+1;\\r\\nif (!start)\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (!BN_mod_mul(r,r,r,m,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(r,r,&(val[wvalue>>1]),m,ctx))\\r\\ngoto err;\\r\\nwstart-=wend+1;\\r\\nwvalue=0;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nfor (i=0; i<ts; i++)\\r\\nBN_clear_free(&(val[i]));\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_cpols_c", "target": 0, "func": "int i2d_POLICYINFO(POLICYINFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->policyid, i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_len_SEQUENCE_type(POLICYQUALINFO, a->qualifiers,\\r\\ni2d_POLICYQUALINFO);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->policyid, i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_put_SEQUENCE_type(POLICYQUALINFO, a->qualifiers,\\r\\ni2d_POLICYQUALINFO);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPOLICYINFO *POLICYINFO_new(void)\\r\\n{\\r\\nPOLICYINFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, POLICYINFO);\\r\\nret->policyid = NULL;\\r\\nret->qualifiers = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_POLICYINFO_NEW);\\r\\n}\\r\\nPOLICYINFO *d2i_POLICYINFO(POLICYINFO **a, unsigned char **pp,long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,POLICYINFO *,POLICYINFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->policyid, d2i_ASN1_OBJECT);\\r\\nif(!M_ASN1_D2I_end_sequence()) {\\r\\nM_ASN1_D2I_get_seq_type (POLICYQUALINFO, ret->qualifiers,\\r\\nd2i_POLICYQUALINFO, POLICYQUALINFO_free);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a, POLICYINFO_free, ASN1_F_D2I_POLICYINFO);\\r\\n}\\r\\nvoid POLICYINFO_free(POLICYINFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->policyid);\\r\\nsk_POLICYQUALINFO_pop_free(a->qualifiers, POLICYQUALINFO_free);\\r\\nFree (a);\\r\\n}\\r\\nstatic void print_notice(BIO *out, USERNOTICE *notice, int indent)\\r\\n{\\r\\nint i;\\r\\nif(notice->noticeref) {\\r\\nNOTICEREF *ref;\\r\\nref = notice->noticeref;\\r\\nBIO_printf(out, \"%*sOrganization: %s\\n\", indent, \"\",\\r\\nref->organization->data);\\r\\nBIO_printf(out, \"%*sNumber%s: \", indent, \"\",\\r\\n(sk_num(ref->noticenos) > 1) ? \"s\" : \"\");\\r\\nfor(i = 0; i < sk_num(ref->noticenos); i++) {\\r\\nASN1_INTEGER *num;\\r\\nchar *tmp;\\r\\nnum = (ASN1_INTEGER *)sk_value(ref->noticenos, i);\\r\\nif(i) BIO_puts(out, \", \");\\r\\ntmp = i2s_ASN1_INTEGER(NULL, num);\\r\\nBIO_puts(out, tmp);\\r\\nFree(tmp);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\nif(notice->exptext)\\r\\nBIO_printf(out, \"%*sExplicit Text: %s\\n\", indent, \"\",\\r\\nnotice->exptext->data);\\r\\n}\\r\\nint i2d_POLICYQUALINFO(POLICYQUALINFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->pqualid, i2d_ASN1_OBJECT);\\r\\nswitch(OBJ_obj2nid(a->pqualid)) {\\r\\ncase NID_id_qt_cps:\\r\\nM_ASN1_I2D_len(a->d.cpsuri, i2d_ASN1_IA5STRING);\\r\\nbreak;\\r\\ncase NID_id_qt_unotice:\\r\\nM_ASN1_I2D_len(a->d.usernotice, i2d_USERNOTICE);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_len(a->d.other, i2d_ASN1_TYPE);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->pqualid, i2d_ASN1_OBJECT);\\r\\nswitch(OBJ_obj2nid(a->pqualid)) {\\r\\ncase NID_id_qt_cps:\\r\\nM_ASN1_I2D_put(a->d.cpsuri, i2d_ASN1_IA5STRING);\\r\\nbreak;\\r\\ncase NID_id_qt_unotice:\\r\\nM_ASN1_I2D_put(a->d.usernotice, i2d_USERNOTICE);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_put(a->d.other, i2d_ASN1_TYPE);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPOLICYQUALINFO *POLICYQUALINFO_new(void)\\r\\n{\\r\\nPOLICYQUALINFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, POLICYQUALINFO);\\r\\nret->pqualid = NULL;\\r\\nret->d.other = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_POLICYQUALINFO_NEW);\\r\\n}\\r\\nPOLICYQUALINFO *d2i_POLICYQUALINFO(POLICYQUALINFO **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,POLICYQUALINFO *,POLICYQUALINFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->pqualid, d2i_ASN1_OBJECT);\\r\\nswitch(OBJ_obj2nid(ret->pqualid)) {\\r\\ncase NID_id_qt_cps:\\r\\nM_ASN1_D2I_get(ret->d.cpsuri, d2i_ASN1_IA5STRING);\\r\\nbreak;\\r\\ncase NID_id_qt_unotice:\\r\\nM_ASN1_D2I_get(ret->d.usernotice, d2i_USERNOTICE);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_D2I_get(ret->d.other, d2i_ASN1_TYPE);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_D2I_Finish(a, POLICYQUALINFO_free, ASN1_F_D2I_POLICYQUALINFO);\\r\\n}\\r\\nvoid POLICYQUALINFO_free(POLICYQUALINFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nswitch(OBJ_obj2nid(a->pqualid)) {\\r\\ncase NID_id_qt_cps:\\r\\nASN1_IA5STRING_free(a->d.cpsuri);\\r\\nbreak;\\r\\ncase NID_id_qt_unotice:\\r\\nUSERNOTICE_free(a->d.usernotice);\\r\\nbreak;\\r\\ndefault:\\r\\nASN1_TYPE_free(a->d.other);\\r\\nbreak;\\r\\n}\\r\\nASN1_OBJECT_free(a->pqualid);\\r\\nFree (a);\\r\\n}\\r\\nint i2d_USERNOTICE(USERNOTICE *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->noticeref, i2d_NOTICEREF);\\r\\nM_ASN1_I2D_len (a->exptext, i2d_DISPLAYTEXT);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->noticeref, i2d_NOTICEREF);\\r\\nM_ASN1_I2D_put (a->exptext, i2d_DISPLAYTEXT);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nUSERNOTICE *USERNOTICE_new(void)\\r\\n{\\r\\nUSERNOTICE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, USERNOTICE);\\r\\nret->noticeref = NULL;\\r\\nret->exptext = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_USERNOTICE_NEW);\\r\\n}\\r\\nUSERNOTICE *d2i_USERNOTICE(USERNOTICE **a, unsigned char **pp,long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,USERNOTICE *,USERNOTICE_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_opt(ret->noticeref, d2i_NOTICEREF, V_ASN1_SEQUENCE);\\r\\nif (!M_ASN1_D2I_end_sequence()) {\\r\\nM_ASN1_D2I_get(ret->exptext, d2i_DISPLAYTEXT);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a, USERNOTICE_free, ASN1_F_D2I_USERNOTICE);\\r\\n}\\r\\nvoid USERNOTICE_free(USERNOTICE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nNOTICEREF_free(a->noticeref);\\r\\nDISPLAYTEXT_free(a->exptext);\\r\\nFree (a);\\r\\n}\\r\\nint i2d_NOTICEREF(NOTICEREF *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->organization, i2d_DISPLAYTEXT);\\r\\nM_ASN1_I2D_len_SEQUENCE(a->noticenos, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->organization, i2d_DISPLAYTEXT);\\r\\nM_ASN1_I2D_put_SEQUENCE(a->noticenos, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nNOTICEREF *NOTICEREF_new(void)\\r\\n{\\r\\nNOTICEREF *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, NOTICEREF);\\r\\nret->organization = NULL;\\r\\nret->noticenos = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_NOTICEREF_NEW);\\r\\n}\\r\\nNOTICEREF *d2i_NOTICEREF(NOTICEREF **a, unsigned char **pp,long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,NOTICEREF *,NOTICEREF_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_opt(ret->organization, d2i_ASN1_IA5STRING,\\r\\nV_ASN1_IA5STRING);\\r\\nif(!ret->organization) {\\r\\nM_ASN1_D2I_get(ret->organization, d2i_DISPLAYTEXT);\\r\\n}\\r\\nM_ASN1_D2I_get_seq(ret->noticenos, d2i_ASN1_INTEGER, ASN1_STRING_free);\\r\\nM_ASN1_D2I_Finish(a, NOTICEREF_free, ASN1_F_D2I_NOTICEREF);\\r\\n}\\r\\nvoid NOTICEREF_free(NOTICEREF *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nDISPLAYTEXT_free(a->organization);\\r\\nsk_pop_free(a->noticenos, ASN1_STRING_free);\\r\\nFree (a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_lib_c", "target": 1, "func": "static long ssl3_default_timeout(void)\\r\\n{\\r\\nreturn(60*60*2);\\r\\n}\\r\\nSSL_METHOD *sslv3_base_method(void)\\r\\n{\\r\\nreturn(&SSLv3_data);\\r\\n}\\r\\nint ssl3_num_ciphers(void)\\r\\n{\\r\\nreturn(SSL3_NUM_CIPHERS);\\r\\n}\\r\\nSSL_CIPHER *ssl3_get_cipher(unsigned int u)\\r\\n{\\r\\nif (u < SSL3_NUM_CIPHERS)\\r\\nreturn(&(ssl3_ciphers[SSL3_NUM_CIPHERS-1-u]));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl3_pending(SSL *s)\\r\\n{\\r\\nreturn(s->s3->rrec.length);\\r\\n}\\r\\nint ssl3_new(SSL *s)\\r\\n{\\r\\nSSL3_CTX *s3;\\r\\nif ((s3=(SSL3_CTX *)Malloc(sizeof(SSL3_CTX))) == NULL) goto err;\\r\\nmemset(s3,0,sizeof(SSL3_CTX));\\r\\ns->s3=s3;\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl3_free(SSL *s)\\r\\n{\\r\\nif(s == NULL)\\r\\nreturn;\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->rbuf.buf != NULL)\\r\\nFree(s->s3->rbuf.buf);\\r\\nif (s->s3->wbuf.buf != NULL)\\r\\nFree(s->s3->wbuf.buf);\\r\\nif (s->s3->rrec.comp != NULL)\\r\\nFree(s->s3->rrec.comp);\\r\\n#ifndef NO_DH\\r\\nif (s->s3->tmp.dh != NULL)\\r\\nDH_free(s->s3->tmp.dh);\\r\\n#endif\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\nmemset(s->s3,0,sizeof(SSL3_CTX));\\r\\nFree(s->s3);\\r\\ns->s3=NULL;\\r\\n}\\r\\nvoid ssl3_clear(SSL *s)\\r\\n{\\r\\nunsigned char *rp,*wp;\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\nif (s->s3->rrec.comp != NULL)\\r\\n{\\r\\nFree(s->s3->rrec.comp);\\r\\ns->s3->rrec.comp=NULL;\\r\\n}\\r\\nrp=s->s3->rbuf.buf;\\r\\nwp=s->s3->wbuf.buf;\\r\\nmemset(s->s3,0,sizeof(SSL3_CTX));\\r\\nif (rp != NULL) s->s3->rbuf.buf=rp;\\r\\nif (wp != NULL) s->s3->wbuf.buf=wp;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->packet_length=0;\\r\\ns->s3->renegotiate=0;\\r\\ns->s3->total_renegotiations=0;\\r\\ns->s3->num_renegotiations=0;\\r\\ns->s3->in_read_app_data=0;\\r\\ns->version=SSL3_VERSION;\\r\\n}\\r\\nlong ssl3_ctrl(SSL *s, int cmd, long larg, char *parg)\\r\\n{\\r\\nint ret=0;\\r\\n#if !defined(NO_DSA) || !defined(NO_RSA)\\r\\nif (\\r\\n#ifndef NO_RSA\\r\\ncmd == SSL_CTRL_SET_TMP_RSA ||\\r\\ncmd == SSL_CTRL_SET_TMP_RSA_CB ||\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncmd == SSL_CTRL_SET_TMP_DH ||\\r\\ncmd == SSL_CTRL_SET_TMP_DH_CB ||\\r\\n#endif\\r\\n0)\\r\\n{\\r\\nif (!ssl_cert_inst(&s->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_SESSION_REUSED:\\r\\nret=s->hit;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\\r\\nret=s->s3->num_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\\r\\nret=s->s3->num_renegotiations;\\r\\ns->s3->num_renegotiations=0;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\\r\\nret=s->s3->total_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_FLAGS:\\r\\nret=(int)(s->s3->flags);\\r\\nbreak;\\r\\n#ifndef NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\\r\\n((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8))))\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa = (RSA *)parg;\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(ret);\\r\\n}\\r\\nif ((rsa = RSAPrivateKey_dup(rsa)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\nif (s->cert->rsa_tmp != NULL)\\r\\nRSA_free(s->cert->rsa_tmp);\\r\\ns->cert->rsa_tmp = rsa;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\ns->cert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))parg;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *dh = (DH *)parg;\\r\\nif (dh == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(ret);\\r\\n}\\r\\nif ((dh = DHparams_dup(dh)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\nif (!DH_generate_key(dh)) {\\r\\nDH_free(dh);\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn(ret);\\r\\n}\\r\\nif (s->cert->dh_tmp != NULL)\\r\\nDH_free(s->cert->dh_tmp);\\r\\ns->cert->dh_tmp = dh;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\ns->cert->dh_tmp_cb = (DH *(*)(SSL *, int, int))parg;\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, char *parg)\\r\\n{\\r\\nCERT *cert;\\r\\ncert=ctx->cert;\\r\\nswitch (cmd)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ( (cert->rsa_tmp == NULL) &&\\r\\n((cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8)))\\r\\n)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa;\\r\\nint i;\\r\\nrsa=(RSA *)parg;\\r\\ni=1;\\r\\nif (rsa == NULL)\\r\\ni=0;\\r\\nelse\\r\\n{\\r\\nif ((rsa=RSAPrivateKey_dup(rsa)) == NULL)\\r\\ni=0;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_RSA_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (cert->rsa_tmp != NULL)\\r\\nRSA_free(cert->rsa_tmp);\\r\\ncert->rsa_tmp=rsa;\\r\\nreturn(1);\\r\\n}\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\ncert->rsa_tmp_cb=(RSA *(*)(SSL *, int, int))parg;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *new=NULL,*dh;\\r\\nint rret=0;\\r\\ndh=(DH *)parg;\\r\\nif ( ((new=DHparams_dup(dh)) == NULL) ||\\r\\n(!DH_generate_key(new)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\\r\\nif (new != NULL) DH_free(new);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (cert->dh_tmp != NULL)\\r\\nDH_free(cert->dh_tmp);\\r\\ncert->dh_tmp=new;\\r\\nrret=1;\\r\\n}\\r\\nreturn(rret);\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\ncert->dh_tmp_cb=(DH *(*)(SSL *, int, int))parg;\\r\\nbreak;\\r\\n#endif\\r\\ncase SSL_CTRL_EXTRA_CHAIN_CERT:\\r\\nif (ctx->extra_certs == NULL)\\r\\n{\\r\\nif ((ctx->extra_certs=sk_X509_new_null()) == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nsk_X509_push(ctx->extra_certs,(X509 *)parg);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_CIPHER *sorted[SSL3_NUM_CIPHERS];\\r\\nSSL_CIPHER c,*cp= &c,**cpp;\\r\\nunsigned long id;\\r\\nint i;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nfor (i=0; i<SSL3_NUM_CIPHERS; i++)\\r\\nsorted[i]= &(ssl3_ciphers[i]);\\r\\nqsort( (char *)sorted,\\r\\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\ninit=0;\\r\\n}\\r\\nid=0x03000000L|((unsigned long)p[0]<<8L)|(unsigned long)p[1];\\r\\nc.id=id;\\r\\ncpp=(SSL_CIPHER **)OBJ_bsearch((char *)&cp,\\r\\n(char *)sorted,\\r\\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\n(int (*)())ssl_cipher_ptr_id_cmp);\\r\\nif ((cpp == NULL) || !(*cpp)->valid)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(*cpp);\\r\\n}\\r\\nint ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\nif ((l & 0xff000000) != 0x03000000) return(0);\\r\\np[0]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[1]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(2);\\r\\n}\\r\\nint ssl3_part_read(SSL *s, int i)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\nif (i < 0)\\r\\n{\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->init_num+=i;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\\r\\n{\\r\\nint ret=0;\\r\\nunsigned long alg;\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef NO_DH\\r\\nif (alg & (SSL_kDHr|SSL_kEDH))\\r\\n{\\r\\n# ifndef NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_FIXED_DH;\\r\\n# endif\\r\\n# ifndef NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_FIXED_DH;\\r\\n# endif\\r\\n}\\r\\nif ((s->version == SSL3_VERSION) &&\\r\\n(alg & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\\r\\n{\\r\\n# ifndef NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\\r\\n# endif\\r\\n# ifndef NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_RSA\\r\\np[ret++]=SSL3_CT_RSA_SIGN;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\np[ret++]=SSL3_CT_DSS_SIGN;\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_shutdown(SSL *s)\\r\\n{\\r\\nif ((s->quiet_shutdown) || (s->state == SSL_ST_BEFORE))\\r\\n{\\r\\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\nreturn(1);\\r\\n}\\r\\nif (!(s->shutdown & SSL_SENT_SHUTDOWN))\\r\\n{\\r\\ns->shutdown|=SSL_SENT_SHUTDOWN;\\r\\n#if 1\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_CLOSE_NOTIFY);\\r\\n#endif\\r\\n}\\r\\nelse if (s->s3->alert_dispatch)\\r\\n{\\r\\n#if 1\\r\\nssl3_dispatch_alert(s);\\r\\n#endif\\r\\n}\\r\\nelse if (!(s->shutdown & SSL_RECEIVED_SHUTDOWN))\\r\\n{\\r\\nssl3_read_bytes(s,0,NULL,0);\\r\\n}\\r\\nif ((s->shutdown == (SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN)) &&\\r\\n!s->s3->alert_dispatch)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_write(SSL *s, const void *buf, int len)\\r\\n{\\r\\nint ret,n;\\r\\n#if 0\\r\\nif (s->shutdown & SSL_SEND_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\n#endif\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\\r\\nif ((s->s3->flags & SSL3_FLAGS_POP_BUFFER) && (s->wbio == s->bbio))\\r\\n{\\r\\nif (s->s3->delay_buf_pop_ret == 0)\\r\\n{\\r\\nret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\\r\\nbuf,len);\\r\\nif (ret <= 0) return(ret);\\r\\ns->s3->delay_buf_pop_ret=ret;\\r\\n}\\r\\ns->rwstate=SSL_WRITING;\\r\\nn=BIO_flush(s->wbio);\\r\\nif (n <= 0) return(n);\\r\\ns->rwstate=SSL_NOTHING;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\\r\\nret=s->s3->delay_buf_pop_ret;\\r\\ns->s3->delay_buf_pop_ret=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\\r\\nbuf,len);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nint ret;\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\\r\\ns->s3->in_read_app_data=1;\\r\\nret=ssl3_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len);\\r\\nif ((ret == -1) && (s->s3->in_read_app_data == 0))\\r\\n{\\r\\nERR_get_error();\\r\\ns->s3->in_read_app_data=0;\\r\\ns->in_handshake++;\\r\\nret=ssl3_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len);\\r\\ns->in_handshake--;\\r\\n}\\r\\nelse\\r\\ns->s3->in_read_app_data=0;\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_peek(SSL *s, char *buf, int len)\\r\\n{\\r\\nSSL3_RECORD *rr;\\r\\nint n;\\r\\nrr= &(s->s3->rrec);\\r\\nif ((rr->length == 0) || (rr->type != SSL3_RT_APPLICATION_DATA))\\r\\n{\\r\\nn=ssl3_read(s,buf,1);\\r\\nif (n <= 0) return(n);\\r\\nrr->length++;\\r\\nrr->off--;\\r\\n}\\r\\nif ((unsigned int)len > rr->length)\\r\\nn=rr->length;\\r\\nelse\\r\\nn=len;\\r\\nmemcpy(buf,&(rr->data[rr->off]),(unsigned int)n);\\r\\nreturn(n);\\r\\n}\\r\\nint ssl3_renegotiate(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == NULL)\\r\\nreturn(1);\\r\\nif (s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)\\r\\nreturn(0);\\r\\ns->s3->renegotiate=1;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_renegotiate_check(SSL *s)\\r\\n{\\r\\nint ret=0;\\r\\nif (s->s3->renegotiate)\\r\\n{\\r\\nif ( (s->s3->rbuf.left == 0) &&\\r\\n(s->s3->wbuf.left == 0) &&\\r\\n!SSL_in_init(s))\\r\\n{\\r\\ns->state=SSL_ST_RENEGOTIATE;\\r\\ns->s3->renegotiate=0;\\r\\ns->s3->num_renegotiations++;\\r\\ns->s3->total_renegotiations++;\\r\\nret=1;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_asn1_c", "target": 1, "func": "DSA_SIG *DSA_SIG_new(void)\\r\\n{\\r\\nDSA_SIG *ret;\\r\\nret = Malloc(sizeof(DSA_SIG));\\r\\nif (ret == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_SIG_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->r = NULL;\\r\\nret->s = NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid DSA_SIG_free(DSA_SIG *r)\\r\\n{\\r\\nif (r == NULL) return;\\r\\nif (r->r) BN_clear_free(r->r);\\r\\nif (r->s) BN_clear_free(r->s);\\r\\nFree(r);\\r\\n}\\r\\nint i2d_DSA_SIG(DSA_SIG *v, unsigned char **pp)\\r\\n{\\r\\nint t=0,len;\\r\\nASN1_INTEGER rbs,sbs;\\r\\nunsigned char *p;\\r\\nrbs.data=Malloc(BN_num_bits(v->r)/8+1);\\r\\nif (rbs.data == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_I2D_DSA_SIG, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nrbs.type=V_ASN1_INTEGER;\\r\\nrbs.length=BN_bn2bin(v->r,rbs.data);\\r\\nsbs.data=Malloc(BN_num_bits(v->s)/8+1);\\r\\nif (sbs.data == NULL)\\r\\n{\\r\\nFree(rbs.data);\\r\\nDSAerr(DSA_F_I2D_DSA_SIG, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nsbs.type=V_ASN1_INTEGER;\\r\\nsbs.length=BN_bn2bin(v->s,sbs.data);\\r\\nlen=i2d_ASN1_INTEGER(&rbs,NULL);\\r\\nlen+=i2d_ASN1_INTEGER(&sbs,NULL);\\r\\nif (pp)\\r\\n{\\r\\np=*pp;\\r\\nASN1_put_object(&p,1,len,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&rbs,&p);\\r\\ni2d_ASN1_INTEGER(&sbs,&p);\\r\\n}\\r\\nt=ASN1_object_size(1,len,V_ASN1_SEQUENCE);\\r\\nFree(rbs.data);\\r\\nFree(sbs.data);\\r\\nreturn(t);\\r\\n}\\r\\nDSA_SIG *d2i_DSA_SIG(DSA_SIG **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ERR_R_NESTED_ASN1_ERROR;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,DSA_SIG *,DSA_SIG_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->r=BN_bin2bn(bs->data,bs->length,ret->r)) == NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->s=BN_bin2bn(bs->data,bs->length,ret->s)) == NULL)\\r\\ngoto err_bn;\\r\\nASN1_BIT_STRING_free(bs);\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nDSAerr(DSA_F_D2I_DSA_SIG,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) DSA_SIG_free(ret);\\r\\nif (bs != NULL) ASN1_BIT_STRING_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5cfb64_c", "target": 0, "func": "void RC5_32_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC5_32_KEY *schedule, unsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_enum_c", "target": 0, "func": "int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned char **pp)\\r\\n{\\r\\nint pad=0,ret,r,i,t;\\r\\nunsigned char *p,*n,pb=0;\\r\\nif ((a == NULL) || (a->data == NULL)) return(0);\\r\\nt=a->type;\\r\\nif (a->length == 0)\\r\\nret=1;\\r\\nelse\\r\\n{\\r\\nret=a->length;\\r\\ni=a->data[0];\\r\\nif ((t == V_ASN1_ENUMERATED) && (i > 127)) {\\r\\npad=1;\\r\\npb=0;\\r\\n} else if(t == V_ASN1_NEG_ENUMERATED) {\\r\\nif(i>128) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\n} else if(i == 128) {\\r\\nfor(i = 1; i < a->length; i++) if(a->data[i]) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nret+=pad;\\r\\n}\\r\\nr=ASN1_object_size(0,ret,V_ASN1_ENUMERATED);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,ret,V_ASN1_ENUMERATED,V_ASN1_UNIVERSAL);\\r\\nif (pad) *(p++)=pb;\\r\\nif (a->length == 0)\\r\\n*(p++)=0;\\r\\nelse if (t == V_ASN1_ENUMERATED)\\r\\n{\\r\\nmemcpy(p,a->data,(unsigned int)a->length);\\r\\np+=a->length;\\r\\n}\\r\\nelse {\\r\\nn=a->data + a->length - 1;\\r\\np += a->length - 1;\\r\\ni = a->length;\\r\\nwhile(!*n) {\\r\\n*(p--) = 0;\\r\\nn--;\\r\\ni--;\\r\\n}\\r\\n*(p--) = ((*(n--)) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(p--) = *(n--) ^ 0xff;\\r\\np += a->length;\\r\\n}\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_ENUMERATED *d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_ENUMERATED *ret=NULL;\\r\\nunsigned char *p,*to,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_ENUMERATED_new()) == NULL) return(NULL);\\r\\nret->type=V_ASN1_ENUMERATED;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_ENUMERATED)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_ENUMERATED;\\r\\ngoto err;\\r\\n}\\r\\ns=(unsigned char *)Malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto=s;\\r\\nif (*p & 0x80)\\r\\n{\\r\\nret->type=V_ASN1_NEG_ENUMERATED;\\r\\nif ((*p == 0xff) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\ni = len;\\r\\np += i - 1;\\r\\nto += i - 1;\\r\\nwhile((!*p) && i) {\\r\\n*(to--) = 0;\\r\\ni--;\\r\\np--;\\r\\n}\\r\\nif(!i) {\\r\\n*s = 1;\\r\\ns[len] = 0;\\r\\np += len;\\r\\nlen++;\\r\\n} else {\\r\\n*(to--) = (*(p--) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(to--) = *(p--) ^ 0xff;\\r\\np += len;\\r\\n}\\r\\n} else {\\r\\nret->type=V_ASN1_ENUMERATED;\\r\\nif ((*p == 0) && (len != 1))\\r\\n{\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\np+=len;\\r\\n}\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->data=s;\\r\\nret->length=(int)len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_ENUMERATED,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_ENUMERATED_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v)\\r\\n{\\r\\nint i,j,k;\\r\\nunsigned char buf[sizeof(long)+1];\\r\\nlong d;\\r\\na->type=V_ASN1_ENUMERATED;\\r\\nif (a->length < (sizeof(long)+1))\\r\\n{\\r\\nif (a->data != NULL)\\r\\nFree((char *)a->data);\\r\\nif ((a->data=(unsigned char *)Malloc(sizeof(long)+1)) != NULL)\\r\\nmemset((char *)a->data,0,sizeof(long)+1);\\r\\n}\\r\\nif (a->data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_ENUMERATED_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nd=v;\\r\\nif (d < 0)\\r\\n{\\r\\nd= -d;\\r\\na->type=V_ASN1_NEG_ENUMERATED;\\r\\n}\\r\\nfor (i=0; i<sizeof(long); i++)\\r\\n{\\r\\nif (d == 0) break;\\r\\nbuf[i]=(int)d&0xff;\\r\\nd>>=8;\\r\\n}\\r\\nj=0;\\r\\nfor (k=i-1; k >=0; k--)\\r\\na->data[j++]=buf[k];\\r\\na->length=j;\\r\\nreturn(1);\\r\\n}\\r\\nlong ASN1_ENUMERATED_get(ASN1_ENUMERATED *a)\\r\\n{\\r\\nint neg=0,i;\\r\\nlong r=0;\\r\\nif (a == NULL) return(0L);\\r\\ni=a->type;\\r\\nif (i == V_ASN1_NEG_ENUMERATED)\\r\\nneg=1;\\r\\nelse if (i != V_ASN1_ENUMERATED)\\r\\nreturn(0);\\r\\nif (a->length > sizeof(long))\\r\\n{\\r\\nreturn(0xffffffffL);\\r\\n}\\r\\nif (a->data == NULL)\\r\\nreturn(0);\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nr<<=8;\\r\\nr|=(unsigned char)a->data[i];\\r\\n}\\r\\nif (neg) r= -r;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)\\r\\n{\\r\\nASN1_ENUMERATED *ret;\\r\\nint len,j;\\r\\nif (ai == NULL)\\r\\nret=ASN1_ENUMERATED_new();\\r\\nelse\\r\\nret=ai;\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_ENUMERATED,ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif(bn->neg) ret->type = V_ASN1_NEG_ENUMERATED;\\r\\nelse ret->type=V_ASN1_ENUMERATED;\\r\\nj=BN_num_bits(bn);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nret->data=(unsigned char *)Malloc(len+4);\\r\\nret->length=BN_bn2bin(bn,ret->data);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != ai) ASN1_ENUMERATED_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=BN_bin2bn(ai->data,ai->length,bn)) == NULL)\\r\\nASN1err(ASN1_F_ASN1_ENUMERATED_TO_BN,ASN1_R_BN_LIB);\\r\\nif(ai->type == V_ASN1_NEG_ENUMERATED) bn->neg = 1;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_speed_c", "target": 1, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic des_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nstatic des_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};\\r\\nstatic des_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};\\r\\ndes_key_schedule sch,sch2,sch3;\\r\\ndouble a,b,c,d,e;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\ndes_set_key(&key2,sch2);\\r\\ndes_set_key(&key3,sch3);\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\ndes_set_key(&key,sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nDES_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\ndes_encrypt(data,&(sch[0]),DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\nprintf(\"Doing set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count++)\\r\\ndes_set_key(&key,sch);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing des_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing des_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count++)\\r\\n{\\r\\nDES_LONG data[2];\\r\\ndes_encrypt(data,&(sch[0]),DES_ENCRYPT);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld des_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing des_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing des_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\ndes_ncbc_encrypt(buf,buf,BUFSIZE,&(sch[0]),\\r\\n&key,DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld des_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing des_ede_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing des_ede_cbc_encrypt %ld times on %ld byte blocks\\n\",cd,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cd); count++)\\r\\ndes_ede3_cbc_encrypt(buf,buf,BUFSIZE,\\r\\n&(sch[0]),\\r\\n&(sch2[0]),\\r\\n&(sch3[0]),\\r\\n&key,\\r\\nDES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld des_ede_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nd=((double)COUNT(cd)*BUFSIZE)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing crypt for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing crypt %ld times\\n\",ce);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ce); count++)\\r\\ncrypt(\"testing1\",\"ef\");\\r\\ne=Time_F(STOP);\\r\\nprintf(\"%ld crypts in %.2f second\\n\",count,e);\\r\\ne=((double)COUNT(ce))/e;\\r\\nprintf(\"set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"DES raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"DES cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nprintf(\"DES ede cbc bytes per sec = %12.2f (%9.3fuS)\\n\",d,8.0e6/d);\\r\\nprintf(\"crypt per sec = %12.2f (%9.3fuS)\\n\",e,1.0e6/e);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cfb64ede_c", "target": 0, "func": "void des_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, des_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister long l=length;\\r\\nregister int n= *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=&(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndes_encrypt3(ti,ks1,ks2,ks3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndes_encrypt3(ti,ks1,ks2,ks3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_exp2_c", "target": 0, "func": "int BN_mod_exp2_mont(BIGNUM *rr, BIGNUM *a1, BIGNUM *p1, BIGNUM *a2,\\r\\nBIGNUM *p2, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i,j,k,bits,bits1,bits2,ret=0,wstart,wend,window,xvalue,yvalue;\\r\\nint start=1,ts=0,x,y;\\r\\nBIGNUM *d,*aa1,*aa2,*r;\\r\\nBIGNUM val[EXP2_TABLE_SIZE][EXP2_TABLE_SIZE];\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nbn_check_top(a1);\\r\\nbn_check_top(p1);\\r\\nbn_check_top(a2);\\r\\nbn_check_top(p2);\\r\\nbn_check_top(m);\\r\\nif (!(m->d[0] & 1))\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT,BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn(0);\\r\\n}\\r\\nd= &(ctx->bn[ctx->tos++]);\\r\\nr= &(ctx->bn[ctx->tos++]);\\r\\nbits1=BN_num_bits(p1);\\r\\nbits2=BN_num_bits(p2);\\r\\nif ((bits1 == 0) && (bits2 == 0))\\r\\n{\\r\\nBN_one(r);\\r\\nreturn(1);\\r\\n}\\r\\nbits=(bits1 > bits2)?bits1:bits2;\\r\\nif (in_mont != NULL)\\r\\nmont=in_mont;\\r\\nelse\\r\\n{\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nif (!BN_MONT_CTX_set(mont,m,ctx)) goto err;\\r\\n}\\r\\nBN_init(&(val[0][0]));\\r\\nBN_init(&(val[1][1]));\\r\\nBN_init(&(val[0][1]));\\r\\nBN_init(&(val[1][0]));\\r\\nts=1;\\r\\nif (BN_ucmp(a1,m) >= 0)\\r\\n{\\r\\nBN_mod(&(val[1][0]),a1,m,ctx);\\r\\naa1= &(val[1][0]);\\r\\n}\\r\\nelse\\r\\naa1=a1;\\r\\nif (BN_ucmp(a2,m) >= 0)\\r\\n{\\r\\nBN_mod(&(val[0][1]),a2,m,ctx);\\r\\naa2= &(val[0][1]);\\r\\n}\\r\\nelse\\r\\naa2=a2;\\r\\nif (!BN_to_montgomery(&(val[1][0]),aa1,mont,ctx)) goto err;\\r\\nif (!BN_to_montgomery(&(val[0][1]),aa2,mont,ctx)) goto err;\\r\\nif (!BN_mod_mul_montgomery(&(val[1][1]),\\r\\n&(val[1][0]),&(val[0][1]),mont,ctx))\\r\\ngoto err;\\r\\n#if 0\\r\\nif (bits <= 20)\\r\\nwindow=1;\\r\\nelse if (bits > 250)\\r\\nwindow=5;\\r\\nelse if (bits >= 120)\\r\\nwindow=4;\\r\\nelse\\r\\nwindow=3;\\r\\n#else\\r\\nwindow=EXP2_TABLE_BITS;\\r\\n#endif\\r\\nk=1<<window;\\r\\nfor (x=0; x<k; x++)\\r\\n{\\r\\nif (x >= 2)\\r\\n{\\r\\nBN_init(&(val[x][0]));\\r\\nBN_init(&(val[x][1]));\\r\\nif (!BN_mod_mul_montgomery(&(val[x][0]),\\r\\n&(val[1][0]),&(val[x-1][0]),mont,ctx)) goto err;\\r\\nif (!BN_mod_mul_montgomery(&(val[x][1]),\\r\\n&(val[1][0]),&(val[x-1][1]),mont,ctx)) goto err;\\r\\n}\\r\\nfor (y=2; y<k; y++)\\r\\n{\\r\\nBN_init(&(val[x][y]));\\r\\nif (!BN_mod_mul_montgomery(&(val[x][y]),\\r\\n&(val[x][y-1]),&(val[0][1]),mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nts=k;\\r\\nstart=1;\\r\\nxvalue=0;\\r\\nyvalue=0;\\r\\nwstart=bits-1;\\r\\nwend=0;\\r\\nif (!BN_to_montgomery(r,BN_value_one(),mont,ctx)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nxvalue=BN_is_bit_set(p1,wstart);\\r\\nyvalue=BN_is_bit_set(p2,wstart);\\r\\nif (!(xvalue || yvalue))\\r\\n{\\r\\nif (!start)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nwstart--;\\r\\nif (wstart < 0) break;\\r\\ncontinue;\\r\\n}\\r\\nj=wstart;\\r\\nwend=0;\\r\\nfor (i=1; i<window; i++)\\r\\n{\\r\\nif (wstart-i < 0) break;\\r\\nxvalue+=xvalue;\\r\\nxvalue|=BN_is_bit_set(p1,wstart-i);\\r\\nyvalue+=yvalue;\\r\\nyvalue|=BN_is_bit_set(p2,wstart-i);\\r\\n}\\r\\nif (!start)\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,r,mont,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (xvalue || yvalue)\\r\\n{\\r\\nif (!BN_mod_mul_montgomery(r,r,&(val[xvalue][yvalue]),\\r\\nmont,ctx)) goto err;\\r\\n}\\r\\nwstart-=i;\\r\\nstart=0;\\r\\nif (wstart < 0) break;\\r\\n}\\r\\nBN_from_montgomery(rr,r,mont,ctx);\\r\\nret=1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL)) BN_MONT_CTX_free(mont);\\r\\nctx->tos-=2;\\r\\nfor (i=0; i<ts; i++)\\r\\n{\\r\\nfor (j=0; j<ts; j++)\\r\\n{\\r\\nBN_clear_free(&(val[i][j]));\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_des_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i;\\r\\nstruct stat ins,outs;\\r\\nchar *p;\\r\\nchar *in=NULL,*out=NULL;\\r\\nvflag=cflag=eflag=dflag=kflag=hflag=bflag=fflag=sflag=uflag=flag3=0;\\r\\nerror=0;\\r\\nmemset(key,0,sizeof(key));\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\np=argv[i];\\r\\nif ((p[0] == '-') && (p[1] != '\\0'))\\r\\n{\\r\\np++;\\r\\nwhile (*p)\\r\\n{\\r\\nswitch (*(p++))\\r\\n{\\r\\ncase '3':\\r\\nflag3=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'c':\\r\\ncflag=1;\\r\\nstrncpy(cksumname,p,200);\\r\\np+=strlen(cksumname);\\r\\nbreak;\\r\\ncase 'C':\\r\\ncflag=1;\\r\\nlongk=1;\\r\\nstrncpy(cksumname,p,200);\\r\\np+=strlen(cksumname);\\r\\nbreak;\\r\\ncase 'e':\\r\\neflag=1;\\r\\nbreak;\\r\\ncase 'v':\\r\\nvflag=1;\\r\\nbreak;\\r\\ncase 'E':\\r\\neflag=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'd':\\r\\ndflag=1;\\r\\nbreak;\\r\\ncase 'D':\\r\\ndflag=1;\\r\\nlongk=1;\\r\\nbreak;\\r\\ncase 'b':\\r\\nbflag=1;\\r\\nbreak;\\r\\ncase 'f':\\r\\nfflag=1;\\r\\nbreak;\\r\\ncase 's':\\r\\nsflag=1;\\r\\nbreak;\\r\\ncase 'u':\\r\\nuflag=1;\\r\\nstrncpy(uuname,p,200);\\r\\np+=strlen(uuname);\\r\\nbreak;\\r\\ncase 'h':\\r\\nhflag=1;\\r\\nbreak;\\r\\ncase 'k':\\r\\nkflag=1;\\r\\nif ((i+1) == argc)\\r\\n{\\r\\nfputs(\"must have a key with the -k option\\n\",stderr);\\r\\nerror=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nint j;\\r\\ni++;\\r\\nstrncpy(key,argv[i],KEYSIZB);\\r\\nfor (j=strlen(argv[i])-1; j>=0; j--)\\r\\nargv[i][j]='\\0';\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nfprintf(stderr,\"'%c' unknown flag\\n\",p[-1]);\\r\\nerror=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (in == NULL)\\r\\nin=argv[i];\\r\\nelse if (out == NULL)\\r\\nout=argv[i];\\r\\nelse\\r\\nerror=1;\\r\\n}\\r\\n}\\r\\nif (error) usage();\\r\\nif (((eflag+dflag) == 1) || cflag)\\r\\n{\\r\\nif (eflag) do_encrypt=DES_ENCRYPT;\\r\\nif (dflag) do_encrypt=DES_DECRYPT;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (vflag)\\r\\n{\\r\\n#ifndef _Windows\\r\\nfprintf(stderr,\"des(1) built with %s\\n\",libdes_version);\\r\\n#endif\\r\\nEXIT(1);\\r\\n}\\r\\nelse usage();\\r\\n}\\r\\n#ifndef _Windows\\r\\nif (vflag) fprintf(stderr,\"des(1) built with %s\\n\",libdes_version);\\r\\n#endif\\r\\nif ( (in != NULL) &&\\r\\n(out != NULL) &&\\r\\n#ifndef MSDOS\\r\\n(stat(in,&ins) != -1) &&\\r\\n(stat(out,&outs) != -1) &&\\r\\n(ins.st_dev == outs.st_dev) &&\\r\\n(ins.st_ino == outs.st_ino))\\r\\n#else\\r\\n(strcmp(in,out) == 0))\\r\\n#endif\\r\\n{\\r\\nfputs(\"input and output file are the same\\n\",stderr);\\r\\nEXIT(3);\\r\\n}\\r\\nif (!kflag\\r\\nvoid doencryption(void)\\r\\n{\\r\\n#ifdef _LIBC\\r\\nextern unsigned long time();\\r\\n#endif\\r\\nregister int i;\\r\\ndes_key_schedule ks,ks2;\\r\\ndes_cblock iv,iv2;\\r\\nchar *p;\\r\\nint num=0,j,k,l,rem,ll,len,last,ex=0;\\r\\ndes_cblock kk,k2;\\r\\nFILE *O;\\r\\nint Exit=0;\\r\\n#ifndef MSDOS\\r\\nstatic unsigned char buf[BUFSIZE+8],obuf[BUFSIZE+8];\\r\\n#else\\r\\nstatic unsigned char *buf=NULL,*obuf=NULL;\\r\\nif (buf == NULL)\\r\\n{\\r\\nif ( (( buf=Malloc(BUFSIZE+8)) == NULL) ||\\r\\n((obuf=Malloc(BUFSIZE+8)) == NULL))\\r\\n{\\r\\nfputs(\"Not enough memory\\n\",stderr);\\r\\nExit=10;\\r\\ngoto problems;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (hflag)\\r\\n{\\r\\nj=(flag3?16:8);\\r\\np=key;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nk=0;\\r\\nif ((*p <= '9') && (*p >= '0'))\\r\\nk=(*p-'0')<<4;\\r\\nelse if ((*p <= 'f') && (*p >= 'a'))\\r\\nk=(*p-'a'+10)<<4;\\r\\nelse if ((*p <= 'F') && (*p >= 'A'))\\r\\nk=(*p-'A'+10)<<4;\\r\\nelse\\r\\n{\\r\\nfputs(\"Bad hex key\\n\",stderr);\\r\\nExit=9;\\r\\ngoto problems;\\r\\n}\\r\\np++;\\r\\nif ((*p <= '9') && (*p >= '0'))\\r\\nk|=(*p-'0');\\r\\nelse if ((*p <= 'f') && (*p >= 'a'))\\r\\nk|=(*p-'a'+10);\\r\\nelse if ((*p <= 'F') && (*p >= 'A'))\\r\\nk|=(*p-'A'+10);\\r\\nelse\\r\\n{\\r\\nfputs(\"Bad hex key\\n\",stderr);\\r\\nExit=9;\\r\\ngoto problems;\\r\\n}\\r\\np++;\\r\\nif (i < 8)\\r\\nkk[i]=k;\\r\\nelse\\r\\nk2[i-8]=k;\\r\\n}\\r\\ndes_set_key(&k2,ks2);\\r\\nmemset(k2,0,sizeof(k2));\\r\\n}\\r\\nelse if (longk || flag3)\\r\\n{\\r\\nif (flag3)\\r\\n{\\r\\ndes_string_to_2keys(key,&kk,&k2);\\r\\ndes_set_key(&k2,ks2);\\r\\nmemset(k2,0,sizeof(k2));\\r\\n}\\r\\nelse\\r\\ndes_string_to_key(key,&kk);\\r\\n}\\r\\nelse\\r\\nfor (i=0; i<KEYSIZ; i++)\\r\\n{\\r\\nl=0;\\r\\nk=key[i];\\r\\nfor (j=0; j<8; j++)\\r\\n{\\r\\nif (k&1) l++;\\r\\nk>>=1;\\r\\n}\\r\\nif (l & 1)\\r\\nkk[i]=key[i]&0x7f;\\r\\nelse\\r\\nkk[i]=key[i]|0x80;\\r\\n}\\r\\ndes_set_key(&kk,ks);\\r\\nmemset(key,0,sizeof(key));\\r\\nmemset(kk,0,sizeof(kk));\\r\\nmemset(iv,0,sizeof(iv));\\r\\nmemset(iv2,0,sizeof(iv2));\\r\\nl=1;\\r\\nrem=0;\\r\\nif (eflag || (!dflag && cflag))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nnum=l=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nl+=rem;\\r\\nnum+=rem;\\r\\nif (l < 0)\\r\\n{\\r\\nperror(\"read error\");\\r\\nExit=6;\\r\\ngoto problems;\\r\\n}\\r\\nrem=l%8;\\r\\nlen=l-rem;\\r\\nif (feof(DES_IN))\\r\\n{\\r\\nfor (i=7-rem; i>0; i--)\\r\\nRAND_bytes(buf + l++, 1);\\r\\nbuf[l++]=rem;\\r\\nex=1;\\r\\nlen+=rem;\\r\\n}\\r\\nelse\\r\\nl-=rem;\\r\\nif (cflag)\\r\\n{\\r\\ndes_cbc_cksum(buf,&cksum,\\r\\n(long)len,ks,&cksum);\\r\\nif (!eflag)\\r\\n{\\r\\nif (feof(DES_IN)) break;\\r\\nelse continue;\\r\\n}\\r\\n}\\r\\nif (bflag && !flag3)\\r\\nfor (i=0; i<l; i+=8)\\r\\ndes_ecb_encrypt(\\r\\n(des_cblock *)&(buf[i]),\\r\\n(des_cblock *)&(obuf[i]),\\r\\nks,do_encrypt);\\r\\nelse if (flag3 && bflag)\\r\\nfor (i=0; i<l; i+=8)\\r\\ndes_ecb2_encrypt(\\r\\n(des_cblock *)&(buf[i]),\\r\\n(des_cblock *)&(obuf[i]),\\r\\nks,ks2,do_encrypt);\\r\\nelse if (flag3 && !bflag)\\r\\n{\\r\\nchar tmpbuf[8];\\r\\nif (rem) memcpy(tmpbuf,&(buf[l]),\\r\\n(unsigned int)rem);\\r\\ndes_3cbc_encrypt(\\r\\n(des_cblock *)buf,(des_cblock *)obuf,\\r\\n(long)l,ks,ks2,&iv,\\r\\n&iv2,do_encrypt);\\r\\nif (rem) memcpy(&(buf[l]),tmpbuf,\\r\\n(unsigned int)rem);\\r\\n}\\r\\nelse\\r\\n{\\r\\ndes_cbc_encrypt(\\r\\nbuf,obuf,\\r\\n(long)l,ks,&iv,do_encrypt);\\r\\nif (l >= 8) memcpy(iv,&(obuf[l-8]),8);\\r\\n}\\r\\nif (rem) memcpy(buf,&(buf[l]),(unsigned int)rem);\\r\\ni=0;\\r\\nwhile (i < l)\\r\\n{\\r\\nif (uflag)\\r\\nj=uufwrite(obuf,1,(unsigned int)l-i,\\r\\nDES_OUT);\\r\\nelse\\r\\nj=fwrite(obuf,1,(unsigned int)l-i,\\r\\nDES_OUT);\\r\\nif (j == -1)\\r\\n{\\r\\nperror(\"Write error\");\\r\\nExit=7;\\r\\ngoto problems;\\r\\n}\\r\\ni+=j;\\r\\n}\\r\\nif (feof(DES_IN))\\r\\n{\\r\\nif (uflag) uufwriteEnd(DES_OUT);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nex=1;\\r\\nfor (;;)\\r\\n{\\r\\nif (ex) {\\r\\nif (uflag)\\r\\nl=uufread(buf,1,BUFSIZE,DES_IN);\\r\\nelse\\r\\nl=fread(buf,1,BUFSIZE,DES_IN);\\r\\nex=0;\\r\\nrem=l%8;\\r\\nl-=rem;\\r\\n}\\r\\nif (l < 0)\\r\\n{\\r\\nperror(\"read error\");\\r\\nExit=6;\\r\\ngoto problems;\\r\\n}\\r\\nif (bflag && !flag3)\\r\\nfor (i=0; i<l; i+=8)\\r\\ndes_ecb_encrypt(\\r\\n(des_cblock *)&(buf[i]),\\r\\n(des_cblock *)&(obuf[i]),\\r\\nks,do_encrypt);\\r\\nelse if (flag3 && bflag)\\r\\nfor (i=0; i<l; i+=8)\\r\\ndes_ecb2_encrypt(\\r\\n(des_cblock *)&(buf[i]),\\r\\n(des_cblock *)&(obuf[i]),\\r\\nks,ks2,do_encrypt);\\r\\nelse if (flag3 && !bflag)\\r\\n{\\r\\ndes_3cbc_encrypt(\\r\\n(des_cblock *)buf,(des_cblock *)obuf,\\r\\n(long)l,ks,ks2,&iv,\\r\\n&iv2,do_encrypt);\\r\\n}\\r\\nelse\\r\\n{\\r\\ndes_cbc_encrypt(\\r\\nbuf,obuf,\\r\\n(long)l,ks,&iv,do_encrypt);\\r\\nif (l >= 8) memcpy(iv,&(buf[l-8]),8);\\r\\n}\\r\\nif (uflag)\\r\\nll=uufread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nelse\\r\\nll=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\\r\\nll+=rem;\\r\\nrem=ll%8;\\r\\nll-=rem;\\r\\nif (feof(DES_IN) && (ll == 0))\\r\\n{\\r\\nlast=obuf[l-1];\\r\\nif ((last > 7) || (last < 0))\\r\\n{\\r\\nfputs(\"The file was not decrypted correctly.\\n\",\\r\\nstderr);\\r\\nExit=8;\\r\\nlast=0;\\r\\n}\\r\\nl=l-8+last;\\r\\n}\\r\\ni=0;\\r\\nif (cflag) des_cbc_cksum(obuf,\\r\\n(des_cblock *)cksum,(long)l/8*8,ks,\\r\\n(des_cblock *)cksum);\\r\\nwhile (i != l)\\r\\n{\\r\\nj=fwrite(obuf,1,(unsigned int)l-i,DES_OUT);\\r\\nif (j == -1)\\r\\n{\\r\\nperror(\"Write error\");\\r\\nExit=7;\\r\\ngoto problems;\\r\\n}\\r\\ni+=j;\\r\\n}\\r\\nl=ll;\\r\\nif ((l == 0) && feof(DES_IN)) break;\\r\\n}\\r\\n}\\r\\nif (cflag)\\r\\n{\\r\\nl=0;\\r\\nif (cksumname[0] != '\\0')\\r\\n{\\r\\nif ((O=fopen(cksumname,\"w\")) != NULL)\\r\\n{\\r\\nCKSUM_OUT=O;\\r\\nl=1;\\r\\n}\\r\\n}\\r\\nfor (i=0; i<8; i++)\\r\\nfprintf(CKSUM_OUT,\"%02X\",cksum[i]);\\r\\nfprintf(CKSUM_OUT,\"\\n\");\\r\\nif (l) fclose(CKSUM_OUT);\\r\\n}\\r\\nproblems:\\r\\nmemset(buf,0,sizeof(buf));\\r\\nmemset(obuf,0,sizeof(obuf));\\r\\nmemset(ks,0,sizeof(ks));\\r\\nmemset(ks2,0,sizeof(ks2));\\r\\nmemset(iv,0,sizeof(iv));\\r\\nmemset(iv2,0,sizeof(iv2));\\r\\nmemset(kk,0,sizeof(kk));\\r\\nmemset(k2,0,sizeof(k2));\\r\\nmemset(uubuf,0,sizeof(uubuf));\\r\\nmemset(b,0,sizeof(b));\\r\\nmemset(bb,0,sizeof(bb));\\r\\nmemset(cksum,0,sizeof(cksum));\\r\\nif (Exit) EXIT(Exit);\\r\\n}\\r\\nint uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp)\\r\\n{\\r\\nint i,j,left,rem,ret=num;\\r\\nstatic int start=1;\\r\\nif (start)\\r\\n{\\r\\nfprintf(fp,\"begin 600 %s\\n\",\\r\\n(uuname[0] == '\\0')?\"text.d\":uuname);\\r\\nstart=0;\\r\\n}\\r\\nif (uubufnum)\\r\\n{\\r\\nif (uubufnum+num < 45)\\r\\n{\\r\\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)num);\\r\\nuubufnum+=num;\\r\\nreturn(num);\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=45-uubufnum;\\r\\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)i);\\r\\nj=uuencode((unsigned char *)uubuf,45,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\nuubufnum=0;\\r\\ndata+=i;\\r\\nnum-=i;\\r\\n}\\r\\n}\\r\\nfor (i=0; i<(((int)num)-INUUBUFN); i+=INUUBUFN)\\r\\n{\\r\\nj=uuencode(&(data[i]),INUUBUFN,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\n}\\r\\nrem=(num-i)%45;\\r\\nleft=(num-i-rem);\\r\\nif (left)\\r\\n{\\r\\nj=uuencode(&(data[i]),left,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\ni+=left;\\r\\n}\\r\\nif (i != num)\\r\\n{\\r\\nmemcpy(uubuf,&(data[i]),(unsigned int)rem);\\r\\nuubufnum=rem;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid uufwriteEnd(FILE *fp)\\r\\n{\\r\\nint j;\\r\\nstatic const char *end=\" \\nend\\n\";\\r\\nif (uubufnum != 0)\\r\\n{\\r\\nuubuf[uubufnum]='\\0';\\r\\nuubuf[uubufnum+1]='\\0';\\r\\nuubuf[uubufnum+2]='\\0';\\r\\nj=uuencode(uubuf,uubufnum,b);\\r\\nfwrite(b,1,(unsigned int)j,fp);\\r\\n}\\r\\nfwrite(end,1,strlen(end),fp);\\r\\n}\\r\\nint uufread(unsigned char *out, int size, unsigned int num, FILE *fp)\\r\\n{\\r\\nint i,j,tot;\\r\\nstatic int done=0;\\r\\nstatic int valid=0;\\r\\nstatic int start=1;\\r\\nif (start)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nb[0]='\\0';\\r\\nfgets((char *)b,300,fp);\\r\\nif (b[0] == '\\0')\\r\\n{\\r\\nfprintf(stderr,\"no 'begin' found in uuencoded input\\n\");\\r\\nreturn(-1);\\r\\n}\\r\\nif (strncmp((char *)b,\"begin \",6) == 0) break;\\r\\n}\\r\\nstart=0;\\r\\n}\\r\\nif (done) return(0);\\r\\ntot=0;\\r\\nif (valid)\\r\\n{\\r\\nmemcpy(out,bb,(unsigned int)valid);\\r\\ntot=valid;\\r\\nvalid=0;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nb[0]='\\0';\\r\\nfgets((char *)b,300,fp);\\r\\nif (b[0] == '\\0') break;\\r\\ni=strlen((char *)b);\\r\\nif ((b[0] == 'e') && (b[1] == 'n') && (b[2] == 'd'))\\r\\n{\\r\\ndone=1;\\r\\nwhile (!feof(fp))\\r\\n{\\r\\nfgets((char *)b,300,fp);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\ni=uudecode(b,i,bb);\\r\\nif (i < 0) break;\\r\\nif ((i+tot+8) > num)\\r\\n{\\r\\nj=(num/8*8)-tot-8;\\r\\nmemcpy(&(out[tot]),bb,(unsigned int)j);\\r\\ntot+=j;\\r\\nmemcpy(bb,&(bb[j]),(unsigned int)i-j);\\r\\nvalid=i-j;\\r\\nbreak;\\r\\n}\\r\\nmemcpy(&(out[tot]),bb,(unsigned int)i);\\r\\ntot+=i;\\r\\n}\\r\\nreturn(tot);\\r\\n}\\r\\nint uuencode(unsigned char *in, int num, unsigned char *out)\\r\\n{\\r\\nint j,i,n,tot=0;\\r\\nDES_LONG l;\\r\\nregister unsigned char *p;\\r\\np=out;\\r\\nfor (j=0; j<num; j+=45)\\r\\n{\\r\\nif (j+45 > num)\\r\\ni=(num-j);\\r\\nelse i=45;\\r\\n*(p++)=i+' ';\\r\\nfor (n=0; n<i; n+=3)\\r\\n{\\r\\nccc2l(in,l);\\r\\n*(p++)=((l>>18)&0x3f)+' ';\\r\\n*(p++)=((l>>12)&0x3f)+' ';\\r\\n*(p++)=((l>> 6)&0x3f)+' ';\\r\\n*(p++)=((l )&0x3f)+' ';\\r\\ntot+=4;\\r\\n}\\r\\n*(p++)='\\n';\\r\\ntot+=2;\\r\\n}\\r\\n*p='\\0';\\r\\nl=0;\\r\\nreturn(tot);\\r\\n}\\r\\nint uudecode(unsigned char *in, int num, unsigned char *out)\\r\\n{\\r\\nint j,i,k;\\r\\nunsigned int n=0,space=0;\\r\\nDES_LONG l;\\r\\nDES_LONG w,x,y,z;\\r\\nunsigned int blank=(unsigned int)'\\n'-' ';\\r\\nfor (j=0; j<num; )\\r\\n{\\r\\nn= *(in++)-' ';\\r\\nif (n == blank)\\r\\n{\\r\\nn=0;\\r\\nin--;\\r\\n}\\r\\nif (n > 60)\\r\\n{\\r\\nfprintf(stderr,\"uuencoded line length too long\\n\");\\r\\nreturn(-1);\\r\\n}\\r\\nj++;\\r\\nfor (i=0; i<n; j+=4,i+=3)\\r\\n{\\r\\nif (space)\\r\\n{\\r\\nw=x=y=z=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nw= *(in++)-' ';\\r\\nx= *(in++)-' ';\\r\\ny= *(in++)-' ';\\r\\nz= *(in++)-' ';\\r\\n}\\r\\nif ((w > 63) || (x > 63) || (y > 63) || (z > 63))\\r\\n{\\r\\nk=0;\\r\\nif (w == blank) k=1;\\r\\nif (x == blank) k=2;\\r\\nif (y == blank) k=3;\\r\\nif (z == blank) k=4;\\r\\nspace=1;\\r\\nswitch (k) {\\r\\ncase 1: w=0; in--;\\r\\ncase 2: x=0; in--;\\r\\ncase 3: y=0; in--;\\r\\ncase 4: z=0; in--;\\r\\nbreak;\\r\\ncase 0:\\r\\nspace=0;\\r\\nfprintf(stderr,\"bad uuencoded data values\\n\");\\r\\nw=x=y=z=0;\\r\\nreturn(-1);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nl=(w<<18)|(x<<12)|(y<< 6)|(z );\\r\\nl2ccc(l,out);\\r\\n}\\r\\nif (*(in++) != '\\n')\\r\\n{\\r\\nfprintf(stderr,\"missing nl in uuencoded line\\n\");\\r\\nw=x=y=z=0;\\r\\nreturn(-1);\\r\\n}\\r\\nj++;\\r\\n}\\r\\n*out='\\0';\\r\\nw=x=y=z=0;\\r\\nreturn(n);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_sign_c", "target": 1, "func": "int RSA_sign(int type, unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, RSA *rsa)\\r\\n{\\r\\nX509_SIG sig;\\r\\nASN1_TYPE parameter;\\r\\nint i,j,ret=1;\\r\\nunsigned char *p,*s;\\r\\nX509_ALGOR algor;\\r\\nASN1_OCTET_STRING digest;\\r\\nsig.algor= &algor;\\r\\nsig.algor->algorithm=OBJ_nid2obj(type);\\r\\nif (sig.algor->algorithm == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_UNKNOWN_ALGORITHM_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (sig.algor->algorithm->length == 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\nreturn(0);\\r\\n}\\r\\nparameter.type=V_ASN1_NULL;\\r\\nparameter.value.ptr=NULL;\\r\\nsig.algor->parameter= &parameter;\\r\\nsig.digest= &digest;\\r\\nsig.digest->data=m;\\r\\nsig.digest->length=m_len;\\r\\ni=i2d_X509_SIG(&sig,NULL);\\r\\nj=RSA_size(rsa);\\r\\nif ((i-RSA_PKCS1_PADDING) > j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)Malloc((unsigned int)j+1);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=s;\\r\\ni2d_X509_SIG(&sig,&p);\\r\\ni=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret=0;\\r\\nelse\\r\\n*siglen=i;\\r\\nmemset(s,0,(unsigned int)j+1);\\r\\nFree(s);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_verify(int dtype, unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigbuf, unsigned int siglen, RSA *rsa)\\r\\n{\\r\\nint i,ret=0,sigtype;\\r\\nunsigned char *p,*s;\\r\\nX509_SIG *sig=NULL;\\r\\nif (siglen != (unsigned int)RSA_size(rsa))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)Malloc((unsigned int)siglen);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0) goto err;\\r\\np=s;\\r\\nsig=d2i_X509_SIG(NULL,&p,(long)i);\\r\\nif (sig == NULL) goto err;\\r\\nsigtype=OBJ_obj2nid(sig->algor->algorithm);\\r\\n#ifdef RSA_DEBUG\\r\\nfprintf(stderr,\"in(%s) expect(%s)\\n\",OBJ_nid2ln(sigtype),\\r\\nOBJ_nid2ln(dtype));\\r\\n#endif\\r\\nif (sigtype != dtype)\\r\\n{\\r\\nif (((dtype == NID_md5) &&\\r\\n(sigtype == NID_md5WithRSAEncryption)) ||\\r\\n((dtype == NID_md2) &&\\r\\n(sigtype == NID_md2WithRSAEncryption)))\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"signature has problems, re-make with post SSLeay045\\n\");\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_ALGORITHM_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ( ((unsigned int)sig->digest->length != m_len) ||\\r\\n(memcmp(m,sig->digest->data,m_len) != 0))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY,RSA_R_BAD_SIGNATURE);\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\nerr:\\r\\nif (sig != NULL) X509_SIG_free(sig);\\r\\nmemset(s,0,(unsigned int)siglen);\\r\\nFree(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_clnt_c", "target": 1, "func": "static SSL_METHOD *ssl3_get_client_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_client_data;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\nmemcpy((char *)&SSLv3_client_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_client_data.ssl_connect=ssl3_connect;\\r\\nSSLv3_client_data.get_ssl_method=ssl3_get_client_method;\\r\\n}\\r\\nreturn(&SSLv3_client_data);\\r\\n}\\r\\nint ssl3_connect(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long Time=time(NULL),l;\\r\\nlong num1;\\r\\nvoid (*cb)()=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;;\\r\\nRAND_seed(&Time,sizeof(Time));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ns->state=SSL_ST_CONNECT;\\r\\ns->ctx->stats.sess_connect_renegotiate++;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version & 0xff00 ) != 0x0300)\\r\\nabort();\\r\\ns->type=SSL_ST_CONNECT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\\r\\nif (!ssl_init_wbio_buffer(s,0)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A:\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl3_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nif (s->bbio != s->wbio)\\r\\ns->wbio=BIO_push(s->bbio,s->wbio);\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A:\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B:\\r\\nret=ssl3_get_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CR_FINISHED_A;\\r\\nelse\\r\\ns->state=SSL3_ST_CR_CERT_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_A:\\r\\ncase SSL3_ST_CR_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=ssl3_get_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_CR_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A:\\r\\ncase SSL3_ST_CR_KEY_EXCH_B:\\r\\nret=ssl3_get_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nif (!ssl3_check_cert_and_algorithm(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_A:\\r\\ncase SSL3_ST_CR_CERT_REQ_B:\\r\\nret=ssl3_get_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CR_SRVR_DONE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A:\\r\\ncase SSL3_ST_CR_SRVR_DONE_B:\\r\\nret=ssl3_get_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->s3->tmp.cert_req)\\r\\ns->state=SSL3_ST_CW_CERT_A;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_A:\\r\\ncase SSL3_ST_CW_CERT_B:\\r\\ncase SSL3_ST_CW_CERT_C:\\r\\ncase SSL3_ST_CW_CERT_D:\\r\\nret=ssl3_send_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A:\\r\\ncase SSL3_ST_CW_KEY_EXCH_B:\\r\\nret=ssl3_send_client_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (s->s3->tmp.cert_req == 1)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_VRFY_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->s3->change_cipher_spec=0;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A:\\r\\ncase SSL3_ST_CW_CERT_VRFY_B:\\r\\nret=ssl3_send_client_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\ns->init_num=0;\\r\\ns->s3->change_cipher_spec=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\nret=ssl3_send_change_cipher_spec(s,\\r\\nSSL3_ST_CW_CHANGE_A,SSL3_ST_CW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FINISHED_A;\\r\\ns->init_num=0;\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ns->session->compress_meth=0;\\r\\nelse\\r\\ns->session->compress_meth=\\r\\ns->s3->tmp.new_compression->id;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_CLIENT_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\nret=ssl3_send_finished(s,\\r\\nSSL3_ST_CW_FINISHED_A,SSL3_ST_CW_FINISHED_B,\\r\\ns->method->ssl3_enc->client_finished,\\r\\ns->method->ssl3_enc->client_finished_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_CW_FLUSH;\\r\\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\\r\\nif (s->hit)\\r\\n{\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\nif (s->s3->flags & SSL3_FLAGS_DELAY_CLIENT_FINISHED)\\r\\n{\\r\\ns->state=SSL_ST_OK;\\r\\ns->s3->flags|=SSL3_FLAGS_POP_BUFFER;\\r\\ns->s3->delay_buf_pop_ret=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.next_state=SSL3_ST_CR_FINISHED_A;\\r\\n}\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_CR_FINISHED_A,\\r\\nSSL3_ST_CR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_CW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\nif (!(s->s3->flags & SSL3_FLAGS_POP_BUFFER))\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_num=0;\\r\\ns->new_session=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\\r\\nif (s->hit) s->ctx->stats.sess_hit++;\\r\\nret=1;\\r\\ns->handshake_func=ssl3_connect;\\r\\ns->ctx->stats.sess_connect_good++;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL3_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\ns->in_handshake--;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,j;\\r\\nunsigned long Time,l;\\r\\nSSL_COMP *comp;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL3_ST_CW_CLNT_HELLO_A)\\r\\n{\\r\\nif ((s->session == NULL) ||\\r\\n(s->session->ssl_version != s->version) ||\\r\\n(s->session->not_resumable))\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\ngoto err;\\r\\n}\\r\\np=s->s3->client_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nRAND_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));\\r\\nd=p= &(buf[4]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\ns->client_version=s->version;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (s->new_session)\\r\\ni=0;\\r\\nelse\\r\\ni=s->session->session_id_length;\\r\\n*(p++)=i;\\r\\nif (i != 0)\\r\\n{\\r\\nmemcpy(p,s->session->session_id,i);\\r\\np+=i;\\r\\n}\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),&(p[2]));\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\np+=i;\\r\\nif (s->ctx->comp_methods == NULL)\\r\\nj=0;\\r\\nelse\\r\\nj=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\n*(p++)=1+j;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,i);\\r\\n*(p++)=comp->id;\\r\\n}\\r\\n*(p++)=0;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\n*(d++)=SSL3_MT_CLIENT_HELLO;\\r\\nl2n3(l,d);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_get_server_hello(SSL *s)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nunsigned char *p,*d;\\r\\nint i,al,ok;\\r\\nunsigned int j;\\r\\nlong n;\\r\\nSSL_COMP *comp;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_CR_SRVR_HELLO_A,\\r\\nSSL3_ST_CR_SRVR_HELLO_B,\\r\\nSSL3_MT_SERVER_HELLO,\\r\\n300,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nd=p=(unsigned char *)s->init_buf->data;\\r\\nif ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);\\r\\ns->version=(s->version&0xff00)|p[1];\\r\\nal=SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\np+=2;\\r\\nmemcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nj= *(p++);\\r\\nif ((j != 0) && (j != SSL3_SESSION_ID_SIZE))\\r\\n{\\r\\nif (j < SSL2_SSL_SESSION_ID_LENGTH)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_SHORT);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (j != 0 && j == s->session->session_id_length\\r\\n&& memcmp(p,s->session->session_id,j) == 0)\\r\\n{\\r\\nif(s->sid_ctx_length != s->session->sid_ctx_length\\r\\n|| memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\\r\\ngoto f_err;\\r\\n}\\r\\ns->hit=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->hit=0;\\r\\nif (s->session->session_id_length > 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nal=SSL_AD_INTERNAL_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\ns->session->session_id_length=j;\\r\\nmemcpy(s->session->session_id,p,j);\\r\\n}\\r\\np+=j;\\r\\nc=ssl_get_cipher_by_char(s,p);\\r\\nif (c == NULL)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\np+=ssl_put_cipher_by_char(s,NULL,NULL);\\r\\nsk=ssl_get_ciphers_by_id(s);\\r\\ni=sk_SSL_CIPHER_find(sk,c);\\r\\nif (i < 0)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->hit && (s->session->cipher != c))\\r\\n{\\r\\nif (!(s->options &\\r\\nSSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\ns->s3->tmp.new_cipher=c;\\r\\nj= *(p++);\\r\\nif (j == 0)\\r\\ncomp=NULL;\\r\\nelse\\r\\ncomp=ssl3_comp_find(s->ctx->comp_methods,j);\\r\\nif ((j != 0) && (comp == NULL))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.new_compression=comp;\\r\\n}\\r\\nif (p != (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_get_server_certificate(SSL *s)\\r\\n{\\r\\nint al,i,ok,ret= -1;\\r\\nunsigned long n,nc,llen,l;\\r\\nX509 *x=NULL;\\r\\nunsigned char *p,*d,*q;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nSESS_CERT *sc;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_CR_CERT_A,\\r\\nSSL3_ST_CR_CERT_B,\\r\\n-1,\\r\\n#if defined(MSDOS) && !defined(WIN32)\\r\\n1024*30,\\r\\n#else\\r\\n1024*100,\\r\\n#endif\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type == SSL3_MT_SERVER_KEY_EXCHANGE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_BAD_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nd=p=(unsigned char *)s->init_buf->data;\\r\\nif ((sk=sk_X509_new_null()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2l3(p,llen);\\r\\nif (llen+3 != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2l3(p,l);\\r\\nif ((l+nc+3) > llen)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nq=p;\\r\\nx=d2i_X509(NULL,&q,l);\\r\\nif (x == NULL)\\r\\n{\\r\\nal=SSL_AD_BAD_CERTIFICATE;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_ASN1_LIB);\\r\\ngoto f_err;\\r\\n}\\r\\nif (q != (p+l))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!sk_X509_push(sk,x))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nx=NULL;\\r\\nnc+=l+3;\\r\\np=q;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif ((s->verify_mode != SSL_VERIFY_NONE) && (!i))\\r\\n{\\r\\nal=ssl_verify_alarm_type(s->verify_result);\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);\\r\\ngoto f_err;\\r\\n}\\r\\nsc=ssl_sess_cert_new();\\r\\nif (sc == NULL) goto err;\\r\\nif (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=sc;\\r\\nsc->cert_chain=sk;\\r\\nx=sk_X509_value(sk,0);\\r\\nsk=NULL;\\r\\npkey=X509_get_pubkey(x);\\r\\nif ((pkey == NULL) || EVP_PKEY_missing_parameters(pkey))\\r\\n{\\r\\nx=NULL;\\r\\nal=SSL3_AL_FATAL;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\\r\\ngoto f_err;\\r\\n}\\r\\ni=ssl_cert_type(x,pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nx=NULL;\\r\\nal=SSL3_AL_FATAL;\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nsc->peer_cert_type=i;\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\nif (sc->peer_pkeys[i].x509 != NULL)\\r\\nX509_free(sc->peer_pkeys[i].x509);\\r\\nsc->peer_pkeys[i].x509=x;\\r\\nsc->peer_key= &(sc->peer_pkeys[i]);\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\ns->session->peer=x;\\r\\nx=NULL;\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nEVP_PKEY_free(pkey);\\r\\nX509_free(x);\\r\\nsk_X509_pop_free(sk,X509_free);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_get_key_exchange(SSL *s)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nunsigned char *q,md_buf[EVP_MAX_MD_SIZE*2];\\r\\n#endif\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned char *param,*p;\\r\\nint al,i,j,param_len,ok;\\r\\nlong n,alg;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#ifndef NO_RSA\\r\\nRSA *rsa=NULL;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nDH *dh=NULL;\\r\\n#endif\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_CR_KEY_EXCH_A,\\r\\nSSL3_ST_CR_KEY_EXCH_B,\\r\\n-1,\\r\\n1024*8,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type != SSL3_MT_SERVER_KEY_EXCHANGE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nparam=p=(unsigned char *)s->init_buf->data;\\r\\nif (s->session->sess_cert != NULL)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nif (s->session->sess_cert->peer_rsa_tmp != NULL)\\r\\n{\\r\\nRSA_free(s->session->sess_cert->peer_rsa_tmp);\\r\\ns->session->sess_cert->peer_rsa_tmp=NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (s->session->sess_cert->peer_dh_tmp)\\r\\n{\\r\\nDH_free(s->session->sess_cert->peer_dh_tmp);\\r\\ns->session->sess_cert->peer_dh_tmp=NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->session->sess_cert=ssl_sess_cert_new();\\r\\n}\\r\\nparam_len=0;\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef NO_RSA\\r\\nif (alg & SSL_kRSA)\\r\\n{\\r\\nif ((rsa=RSA_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2s(p,i);\\r\\nparam_len=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(rsa->n=BN_bin2bn(p,i,rsa->n)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(rsa->e=BN_bin2bn(p,i,rsa->e)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn-=param_len;\\r\\nif (alg & SSL_aRSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ns->session->sess_cert->peer_rsa_tmp=rsa;\\r\\nrsa=NULL;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (alg & SSL_kEDH)\\r\\n{\\r\\nif ((dh=DH_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nn2s(p,i);\\r\\nparam_len=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_P_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->p=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_G_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->g=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn2s(p,i);\\r\\nparam_len+=i+2;\\r\\nif (param_len > n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_DH_PUB_KEY_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(dh->pub_key=BN_bin2bn(p,i,NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nn-=param_len;\\r\\n#ifndef NO_RSA\\r\\nif (alg & SSL_aRSA)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (alg & SSL_aDSS)\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_DSA_SIGN].x509);\\r\\n#endif\\r\\ns->session->sess_cert->peer_dh_tmp=dh;\\r\\ndh=NULL;\\r\\n}\\r\\nelse if ((alg & SSL_kDHr) || (alg & SSL_kDHd))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\nif (alg & SSL_aFZA)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\nif (pkey != NULL)\\r\\n{\\r\\nn2s(p,i);\\r\\nn-=2;\\r\\nj=EVP_PKEY_size(pkey);\\r\\nif ((i != n) || (n > j) || (n <= 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_WRONG_SIGNATURE_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nint num;\\r\\nj=0;\\r\\nq=md_buf;\\r\\nfor (num=2; num > 0; num--)\\r\\n{\\r\\nEVP_DigestInit(&md_ctx,(num == 2)\\r\\n?s->ctx->md5:s->ctx->sha1);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,param,param_len);\\r\\nEVP_DigestFinal(&md_ctx,q,(unsigned int *)&i);\\r\\nq+=i;\\r\\nj+=i;\\r\\n}\\r\\ni=RSA_public_decrypt((int)n,p,p,pkey->pkey.rsa,\\r\\nRSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((j != i) || (memcmp(p,md_buf,i) != 0))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nEVP_VerifyInit(&md_ctx,EVP_dss1());\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_VerifyUpdate(&md_ctx,param,param_len);\\r\\nif (!EVP_VerifyFinal(&md_ctx,p,(int)n,pkey))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(alg & SSL_aNULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (n != 0)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_EXTRA_DATA_IN_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nEVP_PKEY_free(pkey);\\r\\n#ifndef NO_RSA\\r\\nif (rsa != NULL)\\r\\nRSA_free(rsa);\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (dh != NULL)\\r\\nDH_free(dh);\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_get_certificate_request(SSL *s)\\r\\n{\\r\\nint ok,ret=0;\\r\\nunsigned long n,nc,l;\\r\\nunsigned int llen,ctype_num,i;\\r\\nX509_NAME *xn=NULL;\\r\\nunsigned char *p,*d,*q;\\r\\nSTACK_OF(X509_NAME) *ca_sk=NULL;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_CR_CERT_REQ_A,\\r\\nSSL3_ST_CR_CERT_REQ_B,\\r\\n-1,\\r\\n#if defined(MSDOS) && !defined(WIN32)\\r\\n1024*30,\\r\\n#else\\r\\n1024*100,\\r\\n#endif\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\ns->s3->tmp.cert_req=0;\\r\\nif (s->s3->tmp.message_type == SSL3_MT_SERVER_DONE)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_REQUEST)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_WRONG_MESSAGE_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (l & SSL_aNULL)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_UNEXPECTED_MESSAGE);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_TLS_CLIENT_CERT_REQ_WITH_ANON_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nd=p=(unsigned char *)s->init_buf->data;\\r\\nif ((ca_sk=sk_X509_NAME_new(ca_dn_cmp)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nctype_num= *(p++);\\r\\nif (ctype_num > SSL3_CT_NUMBER)\\r\\nctype_num=SSL3_CT_NUMBER;\\r\\nfor (i=0; i<ctype_num; i++)\\r\\ns->s3->tmp.ctype[i]= p[i];\\r\\np+=ctype_num;\\r\\nn2s(p,llen);\\r\\n#if 0\\r\\n{\\r\\nFILE *out;\\r\\nout=fopen(\"/tmp/vsign.der\",\"w\");\\r\\nfwrite(p,1,llen,out);\\r\\nfclose(out);\\r\\n}\\r\\n#endif\\r\\nif ((llen+ctype_num+2+1) != n)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2s(p,l);\\r\\nif ((l+nc+2) > llen)\\r\\n{\\r\\nif ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\\r\\ngoto cont;\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nq=p;\\r\\nif ((xn=d2i_X509_NAME(NULL,&q,l)) == NULL)\\r\\n{\\r\\nif (s->options & SSL_OP_NETSCAPE_CA_DN_BUG)\\r\\ngoto cont;\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (q != (p+l))\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,SSL_R_CA_DN_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_X509_NAME_push(ca_sk,xn))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np+=l;\\r\\nnc+=l+2;\\r\\n}\\r\\nif (0)\\r\\n{\\r\\ncont:\\r\\nERR_clear_error();\\r\\n}\\r\\ns->s3->tmp.cert_req=1;\\r\\ns->s3->tmp.ctype_num=ctype_num;\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\\r\\ns->s3->tmp.ca_names=ca_sk;\\r\\nca_sk=NULL;\\r\\nret=1;\\r\\nerr:\\r\\nif (ca_sk != NULL) sk_X509_NAME_pop_free(ca_sk,X509_NAME_free);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ca_dn_cmp(X509_NAME **a, X509_NAME **b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(*a,*b));\\r\\n}\\r\\nstatic int ssl3_get_server_done(SSL *s)\\r\\n{\\r\\nint ok,ret=0;\\r\\nlong n;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_CR_SRVR_DONE_A,\\r\\nSSL3_ST_CR_SRVR_DONE_B,\\r\\nSSL3_MT_SERVER_DONE,\\r\\n30,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (n > 0)\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECODE_ERROR);\\r\\nSSLerr(SSL_F_SSL3_GET_SERVER_DONE,SSL_R_LENGTH_MISMATCH);\\r\\n}\\r\\nret=1;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_send_client_key_exchange(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint n;\\r\\nunsigned long l;\\r\\n#ifndef NO_RSA\\r\\nunsigned char *q;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_KEY_EXCH_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef NO_RSA\\r\\nif (l & SSL_kRSA)\\r\\n{\\r\\nRSA *rsa;\\r\\nunsigned char tmp_buf[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nif (s->session->sess_cert->peer_rsa_tmp != NULL)\\r\\nrsa=s->session->sess_cert->peer_rsa_tmp;\\r\\nelse\\r\\n{\\r\\npkey=X509_get_pubkey(s->session->sess_cert->peer_pkeys[SSL_PKEY_RSA_ENC].x509);\\r\\nif ((pkey == NULL) ||\\r\\n(pkey->type != EVP_PKEY_RSA) ||\\r\\n(pkey->pkey.rsa == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nrsa=pkey->pkey.rsa;\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\ntmp_buf[0]=s->client_version>>8;\\r\\ntmp_buf[1]=s->client_version&0xff;\\r\\nRAND_bytes(&(tmp_buf[2]),SSL_MAX_MASTER_KEY_LENGTH-2);\\r\\ns->session->master_key_length=SSL_MAX_MASTER_KEY_LENGTH;\\r\\nq=p;\\r\\nif (s->version > SSL3_VERSION)\\r\\np+=2;\\r\\nn=RSA_public_encrypt(SSL_MAX_MASTER_KEY_LENGTH,\\r\\ntmp_buf,p,rsa,RSA_PKCS1_PADDING);\\r\\n#ifdef PKCS1_CHECK\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++;\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0]=0x70;\\r\\n#endif\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_ENCRYPT);\\r\\ngoto err;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\ns2n(n,q);\\r\\nn+=2;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\ntmp_buf,SSL_MAX_MASTER_KEY_LENGTH);\\r\\nmemset(tmp_buf,0,SSL_MAX_MASTER_KEY_LENGTH);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nDH *dh_srvr,*dh_clnt;\\r\\nif (s->session->sess_cert->peer_dh_tmp != NULL)\\r\\ndh_srvr=s->session->sess_cert->peer_dh_tmp;\\r\\nelse\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_FIND_DH_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh_clnt=DHparams_dup(dh_srvr)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!DH_generate_key(dh_clnt))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nn=DH_compute_key(p,dh_srvr->pub_key,dh_clnt);\\r\\nif (n <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,p,n);\\r\\nmemset(p,0,n);\\r\\nn=BN_num_bytes(dh_clnt->pub_key);\\r\\ns2n(n,p);\\r\\nBN_bn2bin(dh_clnt->pub_key,p);\\r\\nn+=2;\\r\\nDH_free(dh_clnt);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*(d++)=SSL3_MT_CLIENT_KEY_EXCHANGE;\\r\\nl2n3(n,d);\\r\\ns->state=SSL3_ST_CW_KEY_EXCH_B;\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_send_client_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nEVP_PKEY *pkey;\\r\\n#ifndef NO_RSA\\r\\nint i=0;\\r\\n#endif\\r\\nunsigned long n;\\r\\n#ifndef NO_DSA\\r\\nint j;\\r\\n#endif\\r\\nif (s->state == SSL3_ST_CW_CERT_VRFY_A)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\npkey=s->cert->key->privatekey;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,&(s->s3->finish_dgst2),\\r\\n&(data[MD5_DIGEST_LENGTH]));\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),&(data[0]));\\r\\ni=RSA_private_encrypt(\\r\\nMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\\r\\ndata,&(p[2]),pkey->pkey.rsa,\\r\\nRSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nif (!DSA_sign(pkey->save_type,\\r\\n&(data[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,&(p[2]),\\r\\n(unsigned int *)&j,pkey->pkey.dsa))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns2n(j,p);\\r\\nn=j+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*(d++)=SSL3_MT_CERTIFICATE_VERIFY;\\r\\nl2n3(n,d);\\r\\ns->init_num=(int)n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_send_client_certificate(SSL *s)\\r\\n{\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == SSL3_ST_CW_CERT_A)\\r\\n{\\r\\nif ((s->cert == NULL) ||\\r\\n(s->cert->key->x509 == NULL) ||\\r\\n(s->cert->key->privatekey == NULL))\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nelse\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_B)\\r\\n{\\r\\ni=0;\\r\\nif (s->ctx->client_cert_cb != NULL)\\r\\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\\r\\nif (i < 0)\\r\\n{\\r\\ns->rwstate=SSL_X509_LOOKUP;\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_B;\\r\\nif ( !SSL_use_certificate(s,x509) ||\\r\\n!SSL_use_PrivateKey(s,pkey))\\r\\ni=0;\\r\\n}\\r\\nelse if (i == 1)\\r\\n{\\r\\ni=0;\\r\\nSSLerr(SSL_F_SSL3_SEND_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\\r\\n}\\r\\nif (x509 != NULL) X509_free(x509);\\r\\nif (pkey != NULL) EVP_PKEY_free(pkey);\\r\\nif (i == 0)\\r\\n{\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\ns->s3->tmp.cert_req=0;\\r\\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_NO_CERTIFICATE);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_req=2;\\r\\n}\\r\\n}\\r\\ns->state=SSL3_ST_CW_CERT_C;\\r\\n}\\r\\nif (s->state == SSL3_ST_CW_CERT_C)\\r\\n{\\r\\ns->state=SSL3_ST_CW_CERT_D;\\r\\nl=ssl3_output_cert_chain(s,\\r\\n(s->s3->tmp.cert_req == 2)?NULL:s->cert->key->x509);\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nstatic int ssl3_check_cert_and_algorithm(SSL *s)\\r\\n{\\r\\nint i,idx;\\r\\nlong algs;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nSESS_CERT *sc;\\r\\n#ifndef NO_RSA\\r\\nRSA *rsa;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nDH *dh;\\r\\n#endif\\r\\nsc=s->session->sess_cert;\\r\\nif (sc == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nalgs=s->s3->tmp.new_cipher->algorithms;\\r\\nif (algs & (SSL_aDH|SSL_aNULL))\\r\\nreturn(1);\\r\\n#ifndef NO_RSA\\r\\nrsa=s->session->sess_cert->peer_rsa_tmp;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ndh=s->session->sess_cert->peer_dh_tmp;\\r\\n#endif\\r\\nidx=sc->peer_cert_type;\\r\\npkey=X509_get_pubkey(sc->peer_pkeys[idx].x509);\\r\\ni=X509_certificate_type(sc->peer_pkeys[idx].x509,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif ((algs & SSL_aRSA) && !has_bits(i,EVP_PK_RSA|EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_SIGNING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef NO_DSA\\r\\nelse if ((algs & SSL_aDSS) && !has_bits(i,EVP_PK_DSA|EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DSA_SIGNING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_RSA\\r\\nif ((algs & SSL_kRSA) &&\\r\\n!(has_bits(i,EVP_PK_RSA|EVP_PKT_ENC) || (rsa != NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_RSA_ENCRYPTING_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif ((algs & SSL_kEDH) &&\\r\\n!(has_bits(i,EVP_PK_DH|EVP_PKT_EXCH) || (dh != NULL)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nelse if ((algs & SSL_kDHr) && !has_bits(i,EVP_PK_DH|EVP_PKS_RSA))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_RSA_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef NO_DSA\\r\\nelse if ((algs & SSL_kDHd) && !has_bits(i,EVP_PK_DH|EVP_PKS_DSA))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_DH_DSA_CERT);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\nif (SSL_IS_EXPORT(algs) && !has_bits(i,EVP_PKT_EXP))\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nif (algs & SSL_kRSA)\\r\\n{\\r\\nif (rsa == NULL\\r\\n|| RSA_size(rsa) > SSL_EXPORT_PKEYLENGTH(algs))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (algs & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nif (dh == NULL\\r\\n|| DH_size(dh) > SSL_EXPORT_PKEYLENGTH(algs))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_MISSING_EXPORT_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_des_enc_c", "target": 0, "func": "void des_encrypt(DES_LONG *data, des_key_schedule ks, int enc)\\r\\n{\\r\\nregister DES_LONG l,r,t,u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP=(const unsigned char *)des_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr=data[0];\\r\\nl=data[1];\\r\\nIP(r,l);\\r\\nr=ROTATE(r,29)&0xffffffffL;\\r\\nl=ROTATE(l,29)&0xffffffffL;\\r\\ns=ks->ks.deslong;\\r\\nif (enc)\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r, 0);\\r\\nD_ENCRYPT(r,l, 2);\\r\\nD_ENCRYPT(l,r, 4);\\r\\nD_ENCRYPT(r,l, 6);\\r\\nD_ENCRYPT(l,r, 8);\\r\\nD_ENCRYPT(r,l,10);\\r\\nD_ENCRYPT(l,r,12);\\r\\nD_ENCRYPT(r,l,14);\\r\\nD_ENCRYPT(l,r,16);\\r\\nD_ENCRYPT(r,l,18);\\r\\nD_ENCRYPT(l,r,20);\\r\\nD_ENCRYPT(r,l,22);\\r\\nD_ENCRYPT(l,r,24);\\r\\nD_ENCRYPT(r,l,26);\\r\\nD_ENCRYPT(l,r,28);\\r\\nD_ENCRYPT(r,l,30);\\r\\n#else\\r\\nfor (i=0; i<32; i+=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i+0);\\r\\nD_ENCRYPT(r,l,i+2);\\r\\nD_ENCRYPT(l,r,i+4);\\r\\nD_ENCRYPT(r,l,i+6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r,30);\\r\\nD_ENCRYPT(r,l,28);\\r\\nD_ENCRYPT(l,r,26);\\r\\nD_ENCRYPT(r,l,24);\\r\\nD_ENCRYPT(l,r,22);\\r\\nD_ENCRYPT(r,l,20);\\r\\nD_ENCRYPT(l,r,18);\\r\\nD_ENCRYPT(r,l,16);\\r\\nD_ENCRYPT(l,r,14);\\r\\nD_ENCRYPT(r,l,12);\\r\\nD_ENCRYPT(l,r,10);\\r\\nD_ENCRYPT(r,l, 8);\\r\\nD_ENCRYPT(l,r, 6);\\r\\nD_ENCRYPT(r,l, 4);\\r\\nD_ENCRYPT(l,r, 2);\\r\\nD_ENCRYPT(r,l, 0);\\r\\n#else\\r\\nfor (i=30; i>0; i-=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i-0);\\r\\nD_ENCRYPT(r,l,i-2);\\r\\nD_ENCRYPT(l,r,i-4);\\r\\nD_ENCRYPT(r,l,i-6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nl=ROTATE(l,3)&0xffffffffL;\\r\\nr=ROTATE(r,3)&0xffffffffL;\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\nl=r=t=u=0;\\r\\n}\\r\\nvoid des_encrypt2(DES_LONG *data, des_key_schedule ks, int enc)\\r\\n{\\r\\nregister DES_LONG l,r,t,u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP=(const unsigned char *)des_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr=data[0];\\r\\nl=data[1];\\r\\nr=ROTATE(r,29)&0xffffffffL;\\r\\nl=ROTATE(l,29)&0xffffffffL;\\r\\ns=ks->ks.deslong;\\r\\nif (enc)\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r, 0);\\r\\nD_ENCRYPT(r,l, 2);\\r\\nD_ENCRYPT(l,r, 4);\\r\\nD_ENCRYPT(r,l, 6);\\r\\nD_ENCRYPT(l,r, 8);\\r\\nD_ENCRYPT(r,l,10);\\r\\nD_ENCRYPT(l,r,12);\\r\\nD_ENCRYPT(r,l,14);\\r\\nD_ENCRYPT(l,r,16);\\r\\nD_ENCRYPT(r,l,18);\\r\\nD_ENCRYPT(l,r,20);\\r\\nD_ENCRYPT(r,l,22);\\r\\nD_ENCRYPT(l,r,24);\\r\\nD_ENCRYPT(r,l,26);\\r\\nD_ENCRYPT(l,r,28);\\r\\nD_ENCRYPT(r,l,30);\\r\\n#else\\r\\nfor (i=0; i<32; i+=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i+0);\\r\\nD_ENCRYPT(r,l,i+2);\\r\\nD_ENCRYPT(l,r,i+4);\\r\\nD_ENCRYPT(r,l,i+6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l,r,30);\\r\\nD_ENCRYPT(r,l,28);\\r\\nD_ENCRYPT(l,r,26);\\r\\nD_ENCRYPT(r,l,24);\\r\\nD_ENCRYPT(l,r,22);\\r\\nD_ENCRYPT(r,l,20);\\r\\nD_ENCRYPT(l,r,18);\\r\\nD_ENCRYPT(r,l,16);\\r\\nD_ENCRYPT(l,r,14);\\r\\nD_ENCRYPT(r,l,12);\\r\\nD_ENCRYPT(l,r,10);\\r\\nD_ENCRYPT(r,l, 8);\\r\\nD_ENCRYPT(l,r, 6);\\r\\nD_ENCRYPT(r,l, 4);\\r\\nD_ENCRYPT(l,r, 2);\\r\\nD_ENCRYPT(r,l, 0);\\r\\n#else\\r\\nfor (i=30; i>0; i-=8)\\r\\n{\\r\\nD_ENCRYPT(l,r,i-0);\\r\\nD_ENCRYPT(r,l,i-2);\\r\\nD_ENCRYPT(l,r,i-4);\\r\\nD_ENCRYPT(r,l,i-6);\\r\\n}\\r\\n#endif\\r\\n}\\r\\ndata[0]=ROTATE(l,3)&0xffffffffL;\\r\\ndata[1]=ROTATE(r,3)&0xffffffffL;\\r\\nl=r=t=u=0;\\r\\n}\\r\\nvoid des_encrypt3(DES_LONG *data, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3)\\r\\n{\\r\\nregister DES_LONG l,r;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nIP(l,r);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\ndes_encrypt2((DES_LONG *)data,ks1,DES_ENCRYPT);\\r\\ndes_encrypt2((DES_LONG *)data,ks2,DES_DECRYPT);\\r\\ndes_encrypt2((DES_LONG *)data,ks3,DES_ENCRYPT);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\n}\\r\\nvoid des_decrypt3(DES_LONG *data, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3)\\r\\n{\\r\\nregister DES_LONG l,r;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nIP(l,r);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\ndes_encrypt2((DES_LONG *)data,ks3,DES_DECRYPT);\\r\\ndes_encrypt2((DES_LONG *)data,ks2,DES_ENCRYPT);\\r\\ndes_encrypt2((DES_LONG *)data,ks1,DES_DECRYPT);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nFP(r,l);\\r\\ndata[0]=l;\\r\\ndata[1]=r;\\r\\n}\\r\\nvoid des_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, des_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1;\\r\\nregister const unsigned char *in;\\r\\nunsigned char *out;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin=input;\\r\\nout=output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_encrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nregister DES_LONG t0,t1;\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_decrypt3((DES_LONG *)tin,ks1,ks2,ks3);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_print_c", "target": 0, "func": "int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a, unsigned char **pp)\\r\\n{ return(M_i2d_ASN1_IA5STRING(a,pp)); }\\r\\nASN1_IA5STRING *d2i_ASN1_IA5STRING(ASN1_IA5STRING **a, unsigned char **pp,\\r\\nlong l)\\r\\n{ return(M_d2i_ASN1_IA5STRING(a,pp,l)); }\\r\\nASN1_T61STRING *d2i_ASN1_T61STRING(ASN1_T61STRING **a, unsigned char **pp,\\r\\nlong l)\\r\\n{ return(M_d2i_ASN1_T61STRING(a,pp,l)); }\\r\\nASN1_PRINTABLESTRING *d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING **a,\\r\\nunsigned char **pp, long l)\\r\\n{ return(M_d2i_ASN1_PRINTABLESTRING(a,pp,\\r\\nl)); }\\r\\nint i2d_ASN1_PRINTABLE(ASN1_STRING *a, unsigned char **pp)\\r\\n{ return(M_i2d_ASN1_PRINTABLE(a,pp)); }\\r\\nASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING **a, unsigned char **pp,\\r\\nlong l)\\r\\n{ return(M_d2i_ASN1_PRINTABLE(a,pp,l)); }\\r\\nint ASN1_PRINTABLE_type(unsigned char *s, int len)\\r\\n{\\r\\nint c;\\r\\nint ia5=0;\\r\\nint t61=0;\\r\\nif (len <= 0) len= -1;\\r\\nif (s == NULL) return(V_ASN1_PRINTABLESTRING);\\r\\nwhile ((*s) && (len-- != 0))\\r\\n{\\r\\nc= *(s++);\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((c >= 'a') && (c <= 'z')) ||\\r\\n((c >= 'A') && (c <= 'Z')) ||\\r\\n(c == ' ') ||\\r\\n((c >= '0') && (c <= '9')) ||\\r\\n(c == ' ') || (c == '\\'') ||\\r\\n(c == '(') || (c == ')') ||\\r\\n(c == '+') || (c == ',') ||\\r\\n(c == '-') || (c == '.') ||\\r\\n(c == '/') || (c == ':') ||\\r\\n(c == '=') || (c == '?')))\\r\\nia5=1;\\r\\nif (c&0x80)\\r\\nt61=1;\\r\\n#else\\r\\nif (!isalnum(c) && (c != ' ') &&\\r\\nstrchr(\"'()+,-./:=?\", c) == NULL)\\r\\nia5=1;\\r\\nif (os_toascii[c] & 0x80)\\r\\nt61=1;\\r\\n#endif\\r\\n}\\r\\nif (t61) return(V_ASN1_T61STRING);\\r\\nif (ia5) return(V_ASN1_IA5STRING);\\r\\nreturn(V_ASN1_PRINTABLESTRING);\\r\\n}\\r\\nint ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s)\\r\\n{\\r\\nint i;\\r\\nunsigned char *p;\\r\\nif (s->type != V_ASN1_UNIVERSALSTRING) return(0);\\r\\nif ((s->length%4) != 0) return(0);\\r\\np=s->data;\\r\\nfor (i=0; i<s->length; i+=4)\\r\\n{\\r\\nif ((p[0] != '\\0') || (p[1] != '\\0') || (p[2] != '\\0'))\\r\\nbreak;\\r\\nelse\\r\\np+=4;\\r\\n}\\r\\nif (i < s->length) return(0);\\r\\np=s->data;\\r\\nfor (i=3; i<s->length; i+=4)\\r\\n{\\r\\n*(p++)=s->data[i];\\r\\n}\\r\\n*(p)='\\0';\\r\\ns->length/=4;\\r\\ns->type=ASN1_PRINTABLE_type(s->data,s->length);\\r\\nreturn(1);\\r\\n}\\r\\nint i2d_DIRECTORYSTRING(ASN1_STRING *a, unsigned char **pp)\\r\\n{ return(M_i2d_DIRECTORYSTRING(a,pp)); }\\r\\nASN1_STRING *d2i_DIRECTORYSTRING(ASN1_STRING **a, unsigned char **pp,\\r\\nlong l)\\r\\n{ return(M_d2i_DIRECTORYSTRING(a,pp,l)); }\\r\\nint i2d_DISPLAYTEXT(ASN1_STRING *a, unsigned char **pp)\\r\\n{ return(M_i2d_DISPLAYTEXT(a,pp)); }\\r\\nASN1_STRING *d2i_DISPLAYTEXT(ASN1_STRING **a, unsigned char **pp,\\r\\nlong l)\\r\\n{ return(M_d2i_DISPLAYTEXT(a,pp,l)); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_by_file_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_file(void)\\r\\n{\\r\\nreturn(&x509_file_lookup);\\r\\n}\\r\\nstatic int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\\r\\nchar **ret)\\r\\n{\\r\\nint ok=0,ok2=0;\\r\\nchar *file;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase X509_L_FILE_LOAD:\\r\\nif (argl == X509_FILETYPE_DEFAULT)\\r\\n{\\r\\nok=X509_load_cert_file(ctx,X509_get_default_cert_file(),\\r\\nX509_FILETYPE_PEM);\\r\\nok2=X509_load_crl_file(ctx,X509_get_default_cert_file(),\\r\\nX509_FILETYPE_PEM);\\r\\nif (!ok || !ok2)\\r\\n{\\r\\nX509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfile=(char *)Getenv(X509_get_default_cert_file_env());\\r\\nok=X509_load_cert_file(ctx,file,\\r\\nX509_FILETYPE_PEM);\\r\\nok2=X509_load_crl_file(ctx,file,\\r\\nX509_FILETYPE_PEM);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nok=X509_load_cert_file(ctx,argp,(int)argl);\\r\\nok2=X509_load_crl_file(ctx,argp,(int)argl);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn((ok && ok2)?ok:0);\\r\\n}\\r\\nint X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *in=NULL;\\r\\nint i,count=0;\\r\\nX509 *x=NULL;\\r\\nif (file == NULL) return(1);\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in,file) <= 0))\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nx=PEM_read_bio_X509(in,NULL,NULL,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0))\\r\\n{\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,\\r\\nERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni=X509_STORE_add_cert(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\ncount++;\\r\\nX509_free(x);\\r\\nx=NULL;\\r\\n}\\r\\nret=count;\\r\\n}\\r\\nelse if (type == X509_FILETYPE_ASN1)\\r\\n{\\r\\nx=d2i_X509_bio(in,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=X509_STORE_add_cert(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\nret=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE,X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *in=NULL;\\r\\nint i,count=0;\\r\\nX509_CRL *x=NULL;\\r\\nif (file == NULL) return(1);\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in,file) <= 0))\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nx=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0))\\r\\n{\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,\\r\\nERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni=X509_STORE_add_crl(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\ncount++;\\r\\nX509_CRL_free(x);\\r\\nx=NULL;\\r\\n}\\r\\nret=count;\\r\\n}\\r\\nelse if (type == X509_FILETYPE_ASN1)\\r\\n{\\r\\nx=d2i_X509_CRL_bio(in,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=X509_STORE_add_crl(ctx->store_ctx,x);\\r\\nif (!i) goto err;\\r\\nret=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE,X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_CRL_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_evp_c", "target": 0, "func": "int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len_SET_type(PKCS7_RECIP_INFO,a->recipientinfo,\\r\\ni2d_PKCS7_RECIP_INFO);\\r\\nM_ASN1_I2D_len(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put_SET_type(PKCS7_RECIP_INFO,a->recipientinfo,\\r\\ni2d_PKCS7_RECIP_INFO);\\r\\nM_ASN1_I2D_put(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_ENVELOPE *d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_ENVELOPE *,PKCS7_ENVELOPE_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_set_type(PKCS7_RECIP_INFO,ret->recipientinfo,\\r\\nd2i_PKCS7_RECIP_INFO,PKCS7_RECIP_INFO_free);\\r\\nM_ASN1_D2I_get(ret->enc_data,d2i_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_ENVELOPE_free,ASN1_F_D2I_PKCS7_ENVELOPE);\\r\\n}\\r\\nPKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void)\\r\\n{\\r\\nPKCS7_ENVELOPE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_ENVELOPE);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->recipientinfo,sk_PKCS7_RECIP_INFO_new_null);\\r\\nM_ASN1_New(ret->enc_data,PKCS7_ENC_CONTENT_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_ENVELOPE_NEW);\\r\\n}\\r\\nvoid PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nsk_PKCS7_RECIP_INFO_pop_free(a->recipientinfo,PKCS7_RECIP_INFO_free);\\r\\nPKCS7_ENC_CONTENT_free(a->enc_data);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rmd160_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"RIPEMD160(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nRIPEMD160_CTX c;\\r\\nunsigned char md[RIPEMD160_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nRIPEMD160_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nRIPEMD160_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nRIPEMD160_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<RIPEMD160_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC2_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC2_set_key(&sch,16,key,128);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC2_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC2_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC2_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\nRC2_set_key(&sch,16,key,128);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC2_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC2_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\nRC2_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC2_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC2_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC2_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),RC2_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC2_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC2 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC2 raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"RC2 cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_utl_c", "target": 0, "func": "void X509V3_conf_free(CONF_VALUE *conf)\\r\\n{\\r\\nif(!conf) return;\\r\\nif(conf->name) Free(conf->name);\\r\\nif(conf->value) Free(conf->value);\\r\\nif(conf->section) Free(conf->section);\\r\\nFree((char *)conf);\\r\\n}\\r\\nchar *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif(!a) return NULL;\\r\\nif(!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)) )\\r\\nX509V3err(X509V3_F_I2S_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nchar *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif(!a) return NULL;\\r\\nif(!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)) )\\r\\nX509V3err(X509V3_F_I2S_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)\\r\\n{\\r\\nBIGNUM *bn = NULL;\\r\\nASN1_INTEGER *aint;\\r\\nbn = BN_new();\\r\\nif(!value) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_INVALID_NULL_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nif(!BN_dec2bn(&bn, value)) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_DEC2BN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(aint = BN_to_ASN1_INTEGER(bn, NULL))) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_TO_ASN1_INTEGER_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nBN_free(bn);\\r\\nreturn aint;\\r\\n}\\r\\nint X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)\\r\\n{\\r\\nchar *btmp;\\r\\nif(!(btmp = value->value)) goto err;\\r\\nif(!strcmp(btmp, \"TRUE\") || !strcmp(btmp, \"true\")\\r\\n|| !strcmp(btmp, \"Y\") || !strcmp(btmp, \"y\")\\r\\n|| !strcmp(btmp, \"YES\") || !strcmp(btmp, \"yes\")) {\\r\\n*asn1_bool = 0xff;\\r\\nreturn 1;\\r\\n} else if(!strcmp(btmp, \"FALSE\") || !strcmp(btmp, \"false\")\\r\\n|| !strcmp(btmp, \"N\") || !strcmp(btmp, \"n\")\\r\\n|| !strcmp(btmp, \"NO\") || !strcmp(btmp, \"no\")) {\\r\\n*asn1_bool = 0;\\r\\nreturn 1;\\r\\n}\\r\\nerr:\\r\\nX509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,X509V3_R_INVALID_BOOLEAN_STRING);\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\nint X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)\\r\\n{\\r\\nASN1_INTEGER *itmp;\\r\\nif(!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\n*aint = itmp;\\r\\nreturn 1;\\r\\n}\\r\\nchar *strip_spaces(char *name)\\r\\n{\\r\\nchar *p, *q;\\r\\np = name;\\r\\nwhile(*p && isspace((unsigned char)*p)) p++;\\r\\nif(!*p) return NULL;\\r\\nq = p + strlen(p) - 1;\\r\\nwhile((q != p) && isspace((unsigned char)*q)) q--;\\r\\nif(p != q) q[1] = 0;\\r\\nif(!*p) return NULL;\\r\\nreturn p;\\r\\n}\\r\\nchar *hex_to_string(unsigned char *buffer, long len)\\r\\n{\\r\\nchar *tmp, *q;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nstatic char hexdig[] = \"0123456789ABCDEF\";\\r\\nif(!buffer || !len) return NULL;\\r\\nif(!(tmp = Malloc(len * 3 + 1))) {\\r\\nX509V3err(X509V3_F_HEX_TO_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nq = tmp;\\r\\nfor(i = 0, p = buffer; i < len; i++,p++) {\\r\\n*q++ = hexdig[(*p >> 4) & 0xf];\\r\\n*q++ = hexdig[*p & 0xf];\\r\\n*q++ = ':';\\r\\n}\\r\\nq[-1] = 0;\\r\\nreturn tmp;\\r\\n}\\r\\nunsigned char *string_to_hex(char *str, long *len)\\r\\n{\\r\\nunsigned char *hexbuf, *q;\\r\\nunsigned char ch, cl, *p;\\r\\nif(!str) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(hexbuf = Malloc(strlen(str) >> 1))) goto err;\\r\\nfor(p = (unsigned char *)str, q = hexbuf; *p;) {\\r\\nch = *p++;\\r\\nif(ch == ':') continue;\\r\\ncl = *p++;\\r\\nif(!cl) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ODD_NUMBER_OF_DIGITS);\\r\\nFree(hexbuf);\\r\\nreturn NULL;\\r\\n}\\r\\nif(isupper(ch)) ch = tolower(ch);\\r\\nif(isupper(cl)) cl = tolower(cl);\\r\\nif((ch >= '0') && (ch <= '9')) ch -= '0';\\r\\nelse if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;\\r\\nelse goto badhex;\\r\\nif((cl >= '0') && (cl <= '9')) cl -= '0';\\r\\nelse if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;\\r\\nelse goto badhex;\\r\\n*q++ = (ch << 4) | cl;\\r\\n}\\r\\nif(len) *len = q - hexbuf;\\r\\nreturn hexbuf;\\r\\nerr:\\r\\nif(hexbuf) Free(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\nbadhex:\\r\\nFree(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ILLEGAL_HEX_DIGIT);\\r\\nreturn NULL;\\r\\n}\\r\\nint name_cmp(const char *name, const char *cmp)\\r\\n{\\r\\nint len, ret;\\r\\nchar c;\\r\\nlen = strlen(cmp);\\r\\nif((ret = strncmp(name, cmp, len))) return ret;\\r\\nc = name[len];\\r\\nif(!c || (c=='.')) return 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p5_pbe_c", "target": 0, "func": "int i2d_PBEPARAM(PBEPARAM *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->salt, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->salt, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPBEPARAM *PBEPARAM_new(void)\\r\\n{\\r\\nPBEPARAM *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PBEPARAM);\\r\\nM_ASN1_New(ret->iter,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->salt,ASN1_OCTET_STRING_new);\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PBEPARAM_NEW);\\r\\n}\\r\\nPBEPARAM *d2i_PBEPARAM(PBEPARAM **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PBEPARAM *,PBEPARAM_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->salt, d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_get (ret->iter, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_Finish(a, PBEPARAM_free, ASN1_F_D2I_PBEPARAM);\\r\\n}\\r\\nvoid PBEPARAM_free (PBEPARAM *a)\\r\\n{\\r\\nif(a==NULL) return;\\r\\nASN1_OCTET_STRING_free(a->salt);\\r\\nASN1_INTEGER_free (a->iter);\\r\\nFree ((char *)a);\\r\\n}\\r\\nX509_ALGOR *PKCS5_pbe_set(int alg, int iter, unsigned char *salt,\\r\\nint saltlen)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nASN1_OBJECT *al;\\r\\nX509_ALGOR *algor;\\r\\nASN1_TYPE *astype;\\r\\nif (!(pbe = PBEPARAM_new ())) {\\r\\nASN1err(ASN1_F_ASN1_PBE_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(iter <= 0) iter = PKCS5_DEFAULT_ITER;\\r\\nASN1_INTEGER_set (pbe->iter, iter);\\r\\nif (!saltlen) saltlen = PKCS5_SALT_LEN;\\r\\nif (!(pbe->salt->data = Malloc (saltlen))) {\\r\\nASN1err(ASN1_F_ASN1_PBE_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\npbe->salt->length = saltlen;\\r\\nif (salt) memcpy (pbe->salt->data, salt, saltlen);\\r\\nelse RAND_bytes (pbe->salt->data, saltlen);\\r\\nif (!(astype = ASN1_TYPE_new())) {\\r\\nASN1err(ASN1_F_ASN1_PBE_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nastype->type = V_ASN1_SEQUENCE;\\r\\nif(!ASN1_pack_string(pbe, i2d_PBEPARAM, &astype->value.sequence)) {\\r\\nASN1err(ASN1_F_ASN1_PBE_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nPBEPARAM_free (pbe);\\r\\nal = OBJ_nid2obj(alg);\\r\\nif (!(algor = X509_ALGOR_new())) {\\r\\nASN1err(ASN1_F_ASN1_PBE_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_OBJECT_free(algor->algorithm);\\r\\nalgor->algorithm = al;\\r\\nalgor->parameter = astype;\\r\\nreturn (algor);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_bf_c", "target": 0, "func": "EVP_CIPHER *EVP_bf_ecb(void)\\r\\n{\\r\\nreturn(&bfish_ecb_cipher);\\r\\n}\\r\\nstatic void bf_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\nBF_set_key(&(ctx->c.bf_ks),EVP_BLOWFISH_KEY_SIZE,key);\\r\\n}\\r\\nstatic void bf_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\nBF_ecb_encrypt(\\r\\n&(in[i]),&(out[i]),\\r\\n&(ctx->c.bf_ks),ctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_i_s_c", "target": 0, "func": "int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a,\\r\\nunsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->issuer,i2d_X509_NAME);\\r\\nM_ASN1_I2D_len(a->serial,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->issuer,i2d_X509_NAME);\\r\\nM_ASN1_I2D_put(a->serial,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_ISSUER_AND_SERIAL *d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_ISSUER_AND_SERIAL *,PKCS7_ISSUER_AND_SERIAL_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->issuer,d2i_X509_NAME);\\r\\nM_ASN1_D2I_get(ret->serial,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_ISSUER_AND_SERIAL_free,\\r\\nASN1_F_D2I_PKCS7_ISSUER_AND_SERIAL);\\r\\n}\\r\\nPKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void)\\r\\n{\\r\\nPKCS7_ISSUER_AND_SERIAL *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_New(ret->issuer,X509_NAME_new);\\r\\nM_ASN1_New(ret->serial,ASN1_INTEGER_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_ISSUER_AND_SERIAL_NEW);\\r\\n}\\r\\nvoid PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_NAME_free(a->issuer);\\r\\nASN1_INTEGER_free(a->serial);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_th-lock_c", "target": 0, "func": "int CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\nlock_cs[i]=CreateMutex(NULL,FALSE,NULL);\\r\\n}\\r\\nCRYPTO_set_locking_callback((void (*)(int,int,char *,int))win32_locking_callback);\\r\\nreturn(1);\\r\\n}\\r\\nstatic void CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\nCloseHandle(lock_cs[i]);\\r\\n}\\r\\nvoid win32_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\nWaitForSingleObject(lock_cs[type],INFINITE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nReleaseMutex(lock_cs[type]);\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\nlock_count[i]=0;\\r\\n#ifdef USE_MUTEX\\r\\nmutex_init(&(lock_cs[i]),USYNC_THREAD,NULL);\\r\\n#else\\r\\nrwlock_init(&(lock_cs[i]),USYNC_THREAD,NULL);\\r\\n#endif\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())solaris_locking_callback);\\r\\n}\\r\\nvoid CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_destroy(&(lock_cs[i]));\\r\\n#else\\r\\nrwlock_destroy(&(lock_cs[i]));\\r\\n#endif\\r\\n}\\r\\n}\\r\\nvoid solaris_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\n#if 0\\r\\nfprintf(stderr,\"thread=%4d mode=%s lock=%s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n(mode&CRYPTO_LOCK)?\"l\":\"u\",\\r\\n(type&CRYPTO_READ)?\"r\":\"w\",file,line);\\r\\n#endif\\r\\n#if 0\\r\\nif (CRYPTO_LOCK_SSL_CERT == type)\\r\\nfprintf(stderr,\"(t,m,f,l) %ld %d %s %d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nmode,file,line);\\r\\n#endif\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_lock(&(lock_cs[type]));\\r\\n#else\\r\\nif (mode & CRYPTO_READ)\\r\\nrw_rdlock(&(lock_cs[type]));\\r\\nelse\\r\\nrw_wrlock(&(lock_cs[type]));\\r\\n#endif\\r\\nlock_count[type]++;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef USE_MUTEX\\r\\nmutex_unlock(&(lock_cs[type]));\\r\\n#else\\r\\nrw_unlock(&(lock_cs[type]));\\r\\n#endif\\r\\n}\\r\\n}\\r\\nunsigned long solaris_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)thr_self();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nchar filename[20];\\r\\nstrcpy(filename,\"/tmp/mttest.XXXXXX\");\\r\\nmktemp(filename);\\r\\nusconfig(CONF_STHREADIOOFF);\\r\\nusconfig(CONF_STHREADMALLOCOFF);\\r\\nusconfig(CONF_INITUSERS,100);\\r\\nusconfig(CONF_LOCKTYPE,US_DEBUGPLUS);\\r\\narena=usinit(filename);\\r\\nunlink(filename);\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\nlock_cs[i]=usnewsema(arena,1);\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())irix_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())irix_locking_callback);\\r\\n}\\r\\nvoid CRYPTO_thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\nchar buf[10];\\r\\nsprintf(buf,\"%2d:\",i);\\r\\nusdumpsema(lock_cs[i],stdout,buf);\\r\\nusfreesema(lock_cs[i],arena);\\r\\n}\\r\\n}\\r\\nvoid irix_locking_callback(int mode, int type, char *file, int line)\\r\\n{\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\nuspsema(lock_cs[type]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nusvsema(lock_cs[type]);\\r\\n}\\r\\n}\\r\\nunsigned long irix_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)getpid();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_thread_setup(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\nlock_count[i]=0;\\r\\npthread_mutex_init(&(lock_cs[i]),NULL);\\r\\n}\\r\\nCRYPTO_set_id_callback((unsigned long (*)())pthreads_thread_id);\\r\\nCRYPTO_set_locking_callback((void (*)())pthreads_locking_callback);\\r\\n}\\r\\nvoid thread_cleanup(void)\\r\\n{\\r\\nint i;\\r\\nCRYPTO_set_locking_callback(NULL);\\r\\nfor (i=0; i<CRYPTO_NUM_LOCKS; i++)\\r\\n{\\r\\npthread_mutex_destroy(&(lock_cs[i]));\\r\\n}\\r\\n}\\r\\nvoid pthreads_locking_callback(int mode, int type, char *file,\\r\\nint line)\\r\\n{\\r\\n#if 0\\r\\nfprintf(stderr,\"thread=%4d mode=%s lock=%s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n(mode&CRYPTO_LOCK)?\"l\":\"u\",\\r\\n(type&CRYPTO_READ)?\"r\":\"w\",file,line);\\r\\n#endif\\r\\n#if 0\\r\\nif (CRYPTO_LOCK_SSL_CERT == type)\\r\\nfprintf(stderr,\"(t,m,f,l) %ld %d %s %d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nmode,file,line);\\r\\n#endif\\r\\nif (mode & CRYPTO_LOCK)\\r\\n{\\r\\npthread_mutex_lock(&(lock_cs[type]));\\r\\nlock_count[type]++;\\r\\n}\\r\\nelse\\r\\n{\\r\\npthread_mutex_unlock(&(lock_cs[type]));\\r\\n}\\r\\n}\\r\\nunsigned long pthreads_thread_id(void)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)pthread_self();\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5ofb64_c", "target": 0, "func": "void RC5_32_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC5_32_KEY *schedule, unsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nRC5_32_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_key_c", "target": 0, "func": "int PKCS12_key_gen_asc (const char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n, unsigned char *out,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *unipass;\\r\\nint uniplen;\\r\\nif (!asc2uni (pass, &unipass, &uniplen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_ASC,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nret = PKCS12_key_gen_uni (unipass, uniplen, salt, saltlen,\\r\\nid, iter, n, out, md_type);\\r\\nmemset(unipass, 0, uniplen);\\r\\nFree(unipass);\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS12_key_gen_uni (unsigned char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n, unsigned char *out,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nunsigned char *B, *D, *I, *p, *Ai;\\r\\nint Slen, Plen, Ilen;\\r\\nint i, j, u, v;\\r\\nBIGNUM *Ij, *Bpl1;\\r\\nEVP_MD_CTX ctx;\\r\\n#ifdef DEBUG_KEYGEN\\r\\nunsigned char *tmpout = out;\\r\\nint tmpn = n;\\r\\nBIO_printf (bio_err, \"KEYGEN DEBUG\\n\");\\r\\nBIO_printf (bio_err, \"ID %d, ITER %d\\n\", id, iter);\\r\\nBIO_printf (bio_err, \"Password (length %d):\\n\", passlen);\\r\\nh__dump (pass, passlen);\\r\\nBIO_printf (bio_err, \"Salt (length %d):\\n\", saltlen);\\r\\nh__dump (salt, saltlen);\\r\\nBIO_printf (bio_err, \"ID %d, ITER %d\\n\\n\", id, iter);\\r\\n#endif\\r\\nv = EVP_MD_block_size (md_type);\\r\\nu = EVP_MD_size (md_type);\\r\\nD = Malloc (v);\\r\\nAi = Malloc (u);\\r\\nB = Malloc (v + 1);\\r\\nSlen = v * ((saltlen+v-1)/v);\\r\\nPlen = v * ((passlen+v-1)/v);\\r\\nIlen = Slen + Plen;\\r\\nI = Malloc (Ilen);\\r\\nIj = BN_new();\\r\\nBpl1 = BN_new();\\r\\nif (!D || !Ai || !B || !I || !Ij || !Bpl1) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < v; i++) D[i] = id;\\r\\np = I;\\r\\nfor (i = 0; i < Slen; i++) *p++ = salt[i % saltlen];\\r\\nfor (i = 0; i < Plen; i++) *p++ = pass[i % passlen];\\r\\nfor (;;) {\\r\\nEVP_DigestInit (&ctx, md_type);\\r\\nEVP_DigestUpdate (&ctx, D, v);\\r\\nEVP_DigestUpdate (&ctx, I, Ilen);\\r\\nEVP_DigestFinal (&ctx, Ai, NULL);\\r\\nfor (j = 1; j < iter; j++) {\\r\\nEVP_DigestInit (&ctx, md_type);\\r\\nEVP_DigestUpdate (&ctx, Ai, u);\\r\\nEVP_DigestFinal (&ctx, Ai, NULL);\\r\\n}\\r\\nmemcpy (out, Ai, min (n, u));\\r\\nif (u >= n) {\\r\\nFree (Ai);\\r\\nFree (B);\\r\\nFree (D);\\r\\nFree (I);\\r\\nBN_free (Ij);\\r\\nBN_free (Bpl1);\\r\\n#ifdef DEBUG_KEYGEN\\r\\nBIO_printf (bio_err, \"Output KEY (length %d)\\n\", tmpn);\\r\\nh__dump (tmpout, tmpn);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nn -= u;\\r\\nout += u;\\r\\nfor (j = 0; j < v; j++) B[j] = Ai[j % u];\\r\\nBN_bin2bn (B, v, Bpl1);\\r\\nBN_add_word (Bpl1, 1);\\r\\nfor (j = 0; j < Ilen ; j+=v) {\\r\\nBN_bin2bn (I + j, v, Ij);\\r\\nBN_add (Ij, Ij, Bpl1);\\r\\nBN_bn2bin (Ij, B);\\r\\nif (BN_num_bytes (Ij) > v) {\\r\\nBN_bn2bin (Ij, B);\\r\\nmemcpy (I + j, B + 1, v);\\r\\n} else BN_bn2bin (Ij, I + j);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid h__dump (unsigned char *p, int len)\\r\\n{\\r\\nfor (; len --; p++) BIO_printf (bio_err, \"%02X\", *p);\\r\\nBIO_printf (bio_err, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_rle_c", "target": 0, "func": "COMP_METHOD *COMP_rle(void)\\r\\n{\\r\\nreturn(&rle_method);\\r\\n}\\r\\nstatic int rle_compress_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nif (olen < (ilen+1))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\n*(out++)=0;\\r\\nmemcpy(out,in,ilen);\\r\\nreturn(ilen+1);\\r\\n}\\r\\nstatic int rle_expand_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nint i;\\r\\nif (olen < (ilen-1))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\ni= *(in++);\\r\\nif (i == 0)\\r\\n{\\r\\nmemcpy(out,in,ilen-1);\\r\\n}\\r\\nreturn(ilen-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pkcs8_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint topk8 = 0;\\r\\nint pbe_nid = -1;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint informat, outformat;\\r\\nint p8_broken = PKCS8_OK;\\r\\nint nocrypt = 0;\\r\\nX509_SIG *p8;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nEVP_PKEY *pkey;\\r\\nchar pass[50];\\r\\nint badarg = 0;\\r\\nif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nERR_load_crypto_strings();\\r\\nSSLeay_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args,\"-v2\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncipher=EVP_get_cipherbyname(*args);\\r\\nif(!cipher) {\\r\\nBIO_printf(bio_err,\\r\\n\"Unknown cipher %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-inform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninformat=str2fmt(*args);\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp(*args,\"-outform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutformat=str2fmt(*args);\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-topk8\")) topk8 = 1;\\r\\nelse if (!strcmp (*args, \"-noiter\")) iter = 1;\\r\\nelse if (!strcmp (*args, \"-nocrypt\")) nocrypt = 1;\\r\\nelse if (!strcmp (*args, \"-nooct\")) p8_broken = PKCS8_NO_OCTET;\\r\\nelse if (!strcmp (*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf (bio_err, \"Usage pkcs8 [options]\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-in file input file\\n\");\\r\\nBIO_printf (bio_err, \"-inform X input format (DER or PEM)\\n\");\\r\\nBIO_printf (bio_err, \"-outform X output format (DER or PEM)\\n\");\\r\\nBIO_printf (bio_err, \"-out file output file\\n\");\\r\\nBIO_printf (bio_err, \"-topk8 output PKCS8 file\\n\");\\r\\nBIO_printf (bio_err, \"-nooct use (broken) no octet form\\n\");\\r\\nBIO_printf (bio_err, \"-noiter use 1 as iteration count\\n\");\\r\\nBIO_printf (bio_err, \"-nocrypt use or expect unencrypted private key\\n\");\\r\\nBIO_printf (bio_err, \"-v2 alg use PKCS#5 v2.0 and cipher \\\"alg\\\"\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nif ((pbe_nid == -1) && !cipher) pbe_nid = NID_pbeWithMD5AndDES_CBC;\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file (infile, \"rb\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open input file %s\\n\", infile);\\r\\nreturn (1);\\r\\n}\\r\\n} else in = BIO_new_fp (stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file (outfile, \"wb\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open output file %s\\n\", outfile);\\r\\nreturn (1);\\r\\n}\\r\\n} else out = BIO_new_fp (stdout, BIO_NOCLOSE);\\r\\nif (topk8) {\\r\\nif (!(pkey = PEM_read_bio_PrivateKey(in, NULL, NULL, NULL))) {\\r\\nBIO_printf (bio_err, \"Error reading key\\n\", outfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nBIO_free(in);\\r\\nif (!(p8inf = EVP_PKEY2PKCS8(pkey))) {\\r\\nBIO_printf (bio_err, \"Error converting key\\n\", outfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nPKCS8_set_broken(p8inf, p8_broken);\\r\\nif(nocrypt) {\\r\\nif(outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8_PRIV_KEY_INFO(out, p8inf);\\r\\nelse if(outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_PRIV_KEY_INFO_bio(out, p8inf);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\n} else {\\r\\nEVP_read_pw_string(pass, 50, \"Enter Encryption Password:\", 1);\\r\\nif (!(p8 = PKCS8_encrypt(pbe_nid, cipher,\\r\\npass, strlen(pass),\\r\\nNULL, 0, iter, p8inf))) {\\r\\nBIO_printf (bio_err, \"Error encrypting key\\n\",\\r\\noutfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif(outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8 (out, p8);\\r\\nelse if(outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_bio(out, p8);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nX509_SIG_free(p8);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free (p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free(out);\\r\\nreturn (0);\\r\\n}\\r\\nif(nocrypt) {\\r\\nif(informat == FORMAT_PEM)\\r\\np8inf = PEM_read_bio_PKCS8_PRIV_KEY_INFO(in,NULL,NULL, NULL);\\r\\nelse if(informat == FORMAT_ASN1)\\r\\np8inf = d2i_PKCS8_PRIV_KEY_INFO_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\n} else {\\r\\nif(informat == FORMAT_PEM)\\r\\np8 = PEM_read_bio_PKCS8(in, NULL, NULL, NULL);\\r\\nelse if(informat == FORMAT_ASN1)\\r\\np8 = d2i_PKCS8_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nif (!p8) {\\r\\nBIO_printf (bio_err, \"Error reading key\\n\", outfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nEVP_read_pw_string(pass, 50, \"Enter Password:\", 0);\\r\\np8inf = M_PKCS8_decrypt(p8, pass, strlen(pass));\\r\\nX509_SIG_free(p8);\\r\\n}\\r\\nif (!p8inf) {\\r\\nBIO_printf(bio_err, \"Error decrypting key\\n\", outfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif (!(pkey = EVP_PKCS82PKEY(p8inf))) {\\r\\nBIO_printf(bio_err, \"Error converting key\\n\", outfile);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (1);\\r\\n}\\r\\nif (p8inf->broken) {\\r\\nBIO_printf(bio_err, \"Warning: broken key encoding: \");\\r\\nswitch (p8inf->broken) {\\r\\ncase PKCS8_NO_OCTET:\\r\\nBIO_printf(bio_err, \"No Octet String\\n\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(bio_err, \"Unknown broken type\\n\");\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nPEM_write_bio_PrivateKey(out, pkey, NULL, NULL, 0, NULL, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free(out);\\r\\nBIO_free(in);\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ecb3_enc_c", "target": 0, "func": "void des_ecb3_encrypt(const_des_cblock *input, des_cblock *output,\\r\\ndes_key_schedule ks1, des_key_schedule ks2, des_key_schedule ks3,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG l0,l1;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in,l0);\\r\\nc2l(in,l1);\\r\\nll[0]=l0;\\r\\nll[1]=l1;\\r\\nif (enc)\\r\\ndes_encrypt3(ll,ks1,ks2,ks3);\\r\\nelse\\r\\ndes_decrypt3(ll,ks1,ks2,ks3);\\r\\nl0=ll[0];\\r\\nl1=ll[1];\\r\\nl2c(l0,out);\\r\\nl2c(l1,out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_crld_c", "target": 0, "func": "int i2d_DIST_POINT(DIST_POINT *a, unsigned char **pp)\\r\\n{\\r\\nint v = 0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len_EXP_opt (a->distpoint, i2d_DIST_POINT_NAME, 0, v);\\r\\nM_ASN1_I2D_len_IMP_opt (a->reasons, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_len_IMP_opt (a->CRLissuer, i2d_GENERAL_NAMES);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put_EXP_opt (a->distpoint, i2d_DIST_POINT_NAME, 0, v);\\r\\nM_ASN1_I2D_put_IMP_opt (a->reasons, i2d_ASN1_BIT_STRING, 1);\\r\\nM_ASN1_I2D_put_IMP_opt (a->CRLissuer, i2d_GENERAL_NAMES, 2);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nDIST_POINT *DIST_POINT_new(void)\\r\\n{\\r\\nDIST_POINT *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, DIST_POINT);\\r\\nret->distpoint = NULL;\\r\\nret->reasons = NULL;\\r\\nret->CRLissuer = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_DIST_POINT_NEW);\\r\\n}\\r\\nDIST_POINT *d2i_DIST_POINT(DIST_POINT **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,DIST_POINT *,DIST_POINT_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_EXP_opt (ret->distpoint, d2i_DIST_POINT_NAME, 0);\\r\\nM_ASN1_D2I_get_IMP_opt (ret->reasons, d2i_ASN1_BIT_STRING, 1,\\r\\nV_ASN1_BIT_STRING);\\r\\nM_ASN1_D2I_get_IMP_opt (ret->CRLissuer, d2i_GENERAL_NAMES, 2,\\r\\nV_ASN1_SEQUENCE);\\r\\nM_ASN1_D2I_Finish(a, DIST_POINT_free, ASN1_F_D2I_DIST_POINT);\\r\\n}\\r\\nvoid DIST_POINT_free(DIST_POINT *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nDIST_POINT_NAME_free(a->distpoint);\\r\\nASN1_BIT_STRING_free(a->reasons);\\r\\nsk_GENERAL_NAME_pop_free(a->CRLissuer, GENERAL_NAME_free);\\r\\nFree ((char *)a);\\r\\n}\\r\\nint i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned char **pp)\\r\\n{\\r\\nint v = 0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nif(a->fullname) {\\r\\nM_ASN1_I2D_len_IMP_opt (a->fullname, i2d_GENERAL_NAMES);\\r\\n} else {\\r\\nM_ASN1_I2D_len_EXP_opt (a->relativename, i2d_X509_NAME, 1, v);\\r\\n}\\r\\nif(pp == NULL) return ret;\\r\\np = *pp;\\r\\nif(a->fullname) {\\r\\nM_ASN1_I2D_put_IMP_opt (a->fullname, i2d_GENERAL_NAMES, 0);\\r\\n} else {\\r\\nM_ASN1_I2D_put_EXP_opt (a->relativename, i2d_X509_NAME, 1, v);\\r\\n}\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nDIST_POINT_NAME *DIST_POINT_NAME_new(void)\\r\\n{\\r\\nDIST_POINT_NAME *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, DIST_POINT_NAME);\\r\\nret->fullname = NULL;\\r\\nret->relativename = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_DIST_POINT_NAME_NEW);\\r\\n}\\r\\nvoid DIST_POINT_NAME_free(DIST_POINT_NAME *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_NAME_free(a->relativename);\\r\\nsk_GENERAL_NAME_pop_free(a->fullname, GENERAL_NAME_free);\\r\\nFree ((char *)a);\\r\\n}\\r\\nDIST_POINT_NAME *d2i_DIST_POINT_NAME(DIST_POINT_NAME **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nunsigned char _tmp, tag;\\r\\nM_ASN1_D2I_vars(a,DIST_POINT_NAME *,DIST_POINT_NAME_new);\\r\\nM_ASN1_D2I_Init();\\r\\nc.slen = length;\\r\\n_tmp = M_ASN1_next;\\r\\ntag = _tmp & ~V_ASN1_CONSTRUCTED;\\r\\nif(tag == (0|V_ASN1_CONTEXT_SPECIFIC)) {\\r\\nM_ASN1_D2I_get_imp(ret->fullname, d2i_GENERAL_NAMES,\\r\\nV_ASN1_SEQUENCE);\\r\\n} else if (tag == (1|V_ASN1_CONTEXT_SPECIFIC)) {\\r\\nM_ASN1_D2I_get_EXP_opt (ret->relativename, d2i_X509_NAME, 1);\\r\\n} else {\\r\\nc.error = ASN1_R_BAD_TAG;\\r\\ngoto err;\\r\\n}\\r\\nM_ASN1_D2I_Finish(a, DIST_POINT_NAME_free, ASN1_F_D2I_DIST_POINT_NAME);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_expspeed_c", "target": 0, "func": "static double Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret < 1e-3)?1e-3:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret < 0.001)?0.001:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *a,*b,*c,*r;\\r\\nctx=BN_CTX_new();\\r\\na=BN_new();\\r\\nb=BN_new();\\r\\nc=BN_new();\\r\\nr=BN_new();\\r\\ndo_mul_exp(r,a,b,c,ctx);\\r\\n}\\r\\nvoid do_mul_exp(BIGNUM *r, BIGNUM *a, BIGNUM *b, BIGNUM *c, BN_CTX *ctx)\\r\\n{\\r\\nint i,k;\\r\\ndouble tm;\\r\\nlong num;\\r\\nBN_MONT_CTX m;\\r\\nmemset(&m,0,sizeof(m));\\r\\nnum=BASENUM;\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nBN_rand(a,sizes[i],1,0);\\r\\nBN_rand(b,sizes[i],1,0);\\r\\nBN_rand(c,sizes[i],1,1);\\r\\nBN_mod(a,a,c,ctx);\\r\\nBN_mod(b,b,c,ctx);\\r\\nBN_MONT_CTX_set(&m,c,ctx);\\r\\nTime_F(START);\\r\\nfor (k=0; k<num; k++)\\r\\nBN_mod_exp_mont(r,a,b,c,ctx,&m);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"mul %4d ^ %4d %% %d -> %8.3fms %5.1f\\n\",sizes[i],sizes[i],sizes[i],tm*1000.0/num,tm*mul_c[i]/num);\\r\\nnum/=7;\\r\\nif (num <= 0) num=1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_task_c", "target": 0, "func": "static int get ( io_channel chan, char *buffer, int maxlen, int *length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = SYS$QIOW ( 0, chan, IO$_READVBLK, &iosb, 0, 0,\\r\\nbuffer, maxlen, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nif ( (status&1) == 1 ) *length = iosb.count;\\r\\nreturn status;\\r\\n}\\r\\nstatic int put ( io_channel chan, char *buffer, int length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = SYS$QIOW ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,\\r\\nbuffer, length, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nreturn status;\\r\\n}\\r\\nstatic int general_request ( io_channel chan, struct rpc_msg *msg, int length )\\r\\n{\\r\\nreturn 48;\\r\\n}\\r\\nint main ( int argc, char **argv )\\r\\n{\\r\\nint status, length;\\r\\nio_channel chan;\\r\\nstruct rpc_msg msg;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nint badop=0;\\r\\nint ret=1;\\r\\nint client_auth=0;\\r\\nint server_auth=0;\\r\\nSSL_CTX *s_ctx=NULL;\\r\\nLIB$INIT_TIMER();\\r\\nstatus = SYS$ASSIGN ( &sysnet, &chan, 0, 0, 0 );\\r\\nprintf(\"status of assign to SYS$NET: %d\\n\", status );\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE);\\r\\nif (bio_stdout == NULL)\\r\\nif ((bio_stdout=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_stdout,stdout,BIO_NOCLOSE);\\r\\nif (cipher == NULL) cipher=getenv(\"SSL_CIPHER\");\\r\\nprintf(\"cipher list: %s\\n\", cipher ? cipher : \"{undefined}\" );\\r\\nSSL_load_error_strings();\\r\\nSSLeay_add_all_algorithms();\\r\\ns_ctx=SSL_CTX_new(SSLv2_server_method());\\r\\nif (s_ctx == NULL) goto end;\\r\\nSSL_CTX_use_certificate_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);\\r\\nSSL_CTX_use_RSAPrivateKey_file(s_ctx,TEST_SERVER_CERT,SSL_FILETYPE_PEM);\\r\\nprintf(\"Loaded server certificate: '%s'\\n\", TEST_SERVER_CERT );\\r\\nLIB$SHOW_TIMER();\\r\\nstatus = doit ( chan, s_ctx );\\r\\nLIB$SHOW_TIMER();\\r\\nend:\\r\\nif (s_ctx != NULL) SSL_CTX_free(s_ctx);\\r\\nLIB$SHOW_TIMER();\\r\\nreturn 1;\\r\\n}\\r\\nint doit(io_channel chan, SSL_CTX *s_ctx )\\r\\n{\\r\\nint status, length, link_state;\\r\\nstruct rpc_msg msg;\\r\\nstatic char cbuf[200],sbuf[200];\\r\\nSSL *s_ssl=NULL;\\r\\nBIO *c_to_s=NULL;\\r\\nBIO *s_to_c=NULL;\\r\\nBIO *c_bio=NULL;\\r\\nBIO *s_bio=NULL;\\r\\nint i;\\r\\nint done=0;\\r\\ns_ssl=SSL_new(s_ctx);\\r\\nif (s_ssl == NULL) goto err;\\r\\nc_to_s=BIO_new(BIO_s_rtcp());\\r\\ns_to_c=BIO_new(BIO_s_rtcp());\\r\\nif ((s_to_c == NULL) || (c_to_s == NULL)) goto err;\\r\\nBIO_set_fd ( c_to_s, 0, chan );\\r\\nBIO_set_fd ( s_to_c, 0, chan );\\r\\nc_bio=BIO_new(BIO_f_ssl());\\r\\ns_bio=BIO_new(BIO_f_ssl());\\r\\nif ((c_bio == NULL) || (s_bio == NULL)) goto err;\\r\\nSSL_set_accept_state(s_ssl);\\r\\nSSL_set_bio(s_ssl,c_to_s,s_to_c);\\r\\nBIO_set_ssl(s_bio,s_ssl,BIO_CLOSE);\\r\\nprintf(\"Begin doit main loop\\n\");\\r\\nfor (link_state = 0; link_state < 3; ) {\\r\\nwhile ( link_state == 0 ) {\\r\\nstatus = get ( chan, (char *) &msg, sizeof(msg), &length );\\r\\nif ( (status&1) == 0 ) {\\r\\nprintf(\"Error in main loop get: %d\\n\", status );\\r\\nlink_state = 3;\\r\\nbreak;\\r\\n}\\r\\nif ( length < RPC_HDR_SIZE ) {\\r\\nprintf(\"Error in main loop get size: %d\\n\", length );\\r\\nbreak;\\r\\nlink_state = 3;\\r\\n}\\r\\nif ( msg.channel != 'A' ) {\\r\\nprintf(\"Error in main loop, unexpected channel: %c\\n\",\\r\\nmsg.channel );\\r\\nbreak;\\r\\nlink_state = 3;\\r\\n}\\r\\nif ( msg.function == 'G' ) {\\r\\nlink_state = 1;\\r\\n} else if ( msg.function == 'P' ) {\\r\\nlink_state = 2;\\r\\n} else if ( msg.function == 'X' ) {\\r\\nlink_state = 3;\\r\\n} else {\\r\\nlink_state = 3;\\r\\n}\\r\\n}\\r\\nif ( link_state == 1 ) {\\r\\ni = BIO_read ( s_bio, msg.data, msg.length );\\r\\nif ( i < 0 ) link_state = 3;\\r\\nelse {\\r\\nmsg.channel = 'A';\\r\\nmsg.function = 'C';\\r\\nmsg.length = i;\\r\\nstatus = put ( chan, (char *) &msg, i+RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) break;\\r\\nlink_state = 0;\\r\\n}\\r\\n} else if ( link_state == 2 ) {\\r\\ni = BIO_write ( s_bio, msg.data, msg.length );\\r\\nif ( i < 0 ) link_state = 3;\\r\\nelse {\\r\\nmsg.channel = 'A';\\r\\nmsg.function = 'C';\\r\\nmsg.length = 0;\\r\\nstatus = put ( chan, (char *) &msg, RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) break;\\r\\nlink_state = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nfprintf(stdout,\"DONE\\n\");\\r\\nerr:\\r\\ns_ssl->rbio=NULL;\\r\\ns_ssl->wbio=NULL;\\r\\nif (c_to_s != NULL) BIO_free(c_to_s);\\r\\nif (s_to_c != NULL) BIO_free(s_to_c);\\r\\nif (c_bio != NULL) BIO_free(c_bio);\\r\\nif (s_bio != NULL) BIO_free(s_bio);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_c_c", "target": 0, "func": "EVP_CIPHER *EVP_cast5_ecb(void)\\r\\n{\\r\\nreturn(&cast5_ecb_cipher);\\r\\n}\\r\\nstatic void cast_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\nCAST_set_key(&(ctx->c.cast_ks),EVP_CAST5_KEY_SIZE,key);\\r\\n}\\r\\nstatic void cast_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\nCAST_ecb_encrypt(\\r\\n&(in[i]),&(out[i]),\\r\\n&(ctx->c.cast_ks),ctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_lib_c", "target": 0, "func": "RSA *RSA_new(void)\\r\\n{\\r\\nreturn(RSA_new_method(NULL));\\r\\n}\\r\\nvoid RSA_set_default_method(RSA_METHOD *meth)\\r\\n{\\r\\ndefault_RSA_meth=meth;\\r\\n}\\r\\nRSA_METHOD *RSA_get_default_method(void)\\r\\n{\\r\\nreturn default_RSA_meth;\\r\\n}\\r\\nRSA_METHOD *RSA_get_method(RSA *rsa)\\r\\n{\\r\\nreturn rsa->meth;\\r\\n}\\r\\nRSA_METHOD *RSA_set_method(RSA *rsa, RSA_METHOD *meth)\\r\\n{\\r\\nRSA_METHOD *mtmp;\\r\\nmtmp = rsa->meth;\\r\\nif (mtmp->finish) mtmp->finish(rsa);\\r\\nrsa->meth = meth;\\r\\nif (meth->init) meth->init(rsa);\\r\\nreturn mtmp;\\r\\n}\\r\\nRSA *RSA_new_method(RSA_METHOD *meth)\\r\\n{\\r\\nRSA *ret;\\r\\nif (default_RSA_meth == NULL)\\r\\n{\\r\\n#ifdef RSAref\\r\\ndefault_RSA_meth=RSA_PKCS1_RSAref();\\r\\n#else\\r\\ndefault_RSA_meth=RSA_PKCS1_SSLeay();\\r\\n#endif\\r\\n}\\r\\nret=(RSA *)Malloc(sizeof(RSA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (meth == NULL)\\r\\nret->meth=default_RSA_meth;\\r\\nelse\\r\\nret->meth=meth;\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->n=NULL;\\r\\nret->e=NULL;\\r\\nret->d=NULL;\\r\\nret->p=NULL;\\r\\nret->q=NULL;\\r\\nret->dmp1=NULL;\\r\\nret->dmq1=NULL;\\r\\nret->iqmp=NULL;\\r\\nret->references=1;\\r\\nret->_method_mod_n=NULL;\\r\\nret->_method_mod_p=NULL;\\r\\nret->_method_mod_q=NULL;\\r\\nret->blinding=NULL;\\r\\nret->bignum_data=NULL;\\r\\nret->flags=ret->meth->flags;\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nFree(ret);\\r\\nret=NULL;\\r\\n}\\r\\nelse\\r\\nCRYPTO_new_ex_data(rsa_meth,(char *)ret,&ret->ex_data);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid RSA_free(RSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL) return;\\r\\ni=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"RSA\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"RSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(rsa_meth,(char *)r,&r->ex_data);\\r\\nif (r->meth->finish != NULL)\\r\\nr->meth->finish(r);\\r\\nif (r->n != NULL) BN_clear_free(r->n);\\r\\nif (r->e != NULL) BN_clear_free(r->e);\\r\\nif (r->d != NULL) BN_clear_free(r->d);\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->q != NULL) BN_clear_free(r->q);\\r\\nif (r->dmp1 != NULL) BN_clear_free(r->dmp1);\\r\\nif (r->dmq1 != NULL) BN_clear_free(r->dmq1);\\r\\nif (r->iqmp != NULL) BN_clear_free(r->iqmp);\\r\\nif (r->blinding != NULL) BN_BLINDING_free(r->blinding);\\r\\nif (r->bignum_data != NULL) Free_locked(r->bignum_data);\\r\\nFree(r);\\r\\n}\\r\\nint RSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),\\r\\nint (*dup_func)(), void (*free_func)())\\r\\n{\\r\\nrsa_meth_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(rsa_meth_num-1,\\r\\n&rsa_meth,argl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint RSA_set_ex_data(RSA *r, int idx, char *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\\r\\n}\\r\\nchar *RSA_get_ex_data(RSA *r, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\\r\\n}\\r\\nint RSA_size(RSA *r)\\r\\n{\\r\\nreturn(BN_num_bytes(r->n));\\r\\n}\\r\\nint RSA_public_encrypt(int flen, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_encrypt(int flen, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_decrypt(int flen, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_public_decrypt(int flen, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nreturn(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_flags(RSA *r)\\r\\n{\\r\\nreturn((r == NULL)?0:r->meth->flags);\\r\\n}\\r\\nvoid RSA_blinding_off(RSA *rsa)\\r\\n{\\r\\nif (rsa->blinding != NULL)\\r\\n{\\r\\nBN_BLINDING_free(rsa->blinding);\\r\\nrsa->blinding=NULL;\\r\\n}\\r\\nrsa->flags&= ~RSA_FLAG_BLINDING;\\r\\n}\\r\\nint RSA_blinding_on(RSA *rsa, BN_CTX *p_ctx)\\r\\n{\\r\\nBIGNUM *A,*Ai;\\r\\nBN_CTX *ctx;\\r\\nint ret=0;\\r\\nif (p_ctx == NULL)\\r\\n{\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nctx=p_ctx;\\r\\nif (rsa->blinding != NULL)\\r\\nBN_BLINDING_free(rsa->blinding);\\r\\nA= &(ctx->bn[0]);\\r\\nctx->tos++;\\r\\nif (!BN_rand(A,BN_num_bits(rsa->n)-1,1,0)) goto err;\\r\\nif ((Ai=BN_mod_inverse(NULL,A,rsa->n,ctx)) == NULL) goto err;\\r\\nif (!rsa->meth->bn_mod_exp(A,A,rsa->e,rsa->n,ctx,rsa->_method_mod_n))\\r\\ngoto err;\\r\\nrsa->blinding=BN_BLINDING_new(A,Ai,rsa->n);\\r\\nctx->tos--;\\r\\nrsa->flags|=RSA_FLAG_BLINDING;\\r\\nBN_free(Ai);\\r\\nret=1;\\r\\nerr:\\r\\nif (ctx != p_ctx) BN_CTX_free(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_memory_lock(RSA *r)\\r\\n{\\r\\nint i,j,k,off;\\r\\nchar *p;\\r\\nBIGNUM *bn,**t[6],*b;\\r\\nBN_ULONG *ul;\\r\\nif (r->d == NULL) return(1);\\r\\nt[0]= &r->d;\\r\\nt[1]= &r->p;\\r\\nt[2]= &r->q;\\r\\nt[3]= &r->dmp1;\\r\\nt[4]= &r->dmq1;\\r\\nt[5]= &r->iqmp;\\r\\nk=sizeof(BIGNUM)*6;\\r\\noff=k/sizeof(BN_ULONG)+1;\\r\\nj=1;\\r\\nfor (i=0; i<6; i++)\\r\\nj+= (*t[i])->top;\\r\\nif ((p=Malloc_locked((off+j)*sizeof(BN_ULONG))) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_MEMORY_LOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nbn=(BIGNUM *)p;\\r\\nul=(BN_ULONG *)&(p[off]);\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nb= *(t[i]);\\r\\n*(t[i])= &(bn[i]);\\r\\nmemcpy((char *)&(bn[i]),(char *)b,sizeof(BIGNUM));\\r\\nbn[i].flags=BN_FLG_STATIC_DATA;\\r\\nbn[i].d=ul;\\r\\nmemcpy((char *)ul,b->d,sizeof(BN_ULONG)*b->top);\\r\\nul+=b->top;\\r\\nBN_clear_free(b);\\r\\n}\\r\\nr->flags&= ~(RSA_FLAG_CACHE_PRIVATE|RSA_FLAG_CACHE_PUBLIC);\\r\\nr->bignum_data=p;\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha_one_c", "target": 0, "func": "unsigned char *SHA(const unsigned char *d, unsigned long n, unsigned char *md)\\r\\n{\\r\\nSHA_CTX c;\\r\\nstatic unsigned char m[SHA_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA_Init(&c);\\r\\nSHA_Update(&c,d,n);\\r\\nSHA_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_gen_c", "target": 0, "func": "DSA *DSA_generate_parameters(int bits, unsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret, void (*callback)(),\\r\\nchar *cb_arg)\\r\\n{\\r\\nint ok=0;\\r\\nunsigned char seed[SHA_DIGEST_LENGTH];\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nunsigned char buf[SHA_DIGEST_LENGTH],buf2[SHA_DIGEST_LENGTH];\\r\\nBIGNUM *r0,*W,*X,*c,*test;\\r\\nBIGNUM *g=NULL,*q=NULL,*p=NULL;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nint k,n=0,i,b,m=0;\\r\\nint counter=0;\\r\\nBN_CTX *ctx=NULL,*ctx2=NULL;\\r\\nunsigned int h=2;\\r\\nDSA *ret=NULL;\\r\\nif (bits < 512) bits=512;\\r\\nbits=(bits+63)/64*64;\\r\\nif ((seed_in != NULL) && (seed_len == 20))\\r\\nmemcpy(seed,seed_in,seed_len);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif ((ctx2=BN_CTX_new()) == NULL) goto err;\\r\\nif ((ret=DSA_new()) == NULL) goto err;\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nr0= &(ctx2->bn[0]);\\r\\ng= &(ctx2->bn[1]);\\r\\nW= &(ctx2->bn[2]);\\r\\nq= &(ctx2->bn[3]);\\r\\nX= &(ctx2->bn[4]);\\r\\nc= &(ctx2->bn[5]);\\r\\np= &(ctx2->bn[6]);\\r\\ntest= &(ctx2->bn[7]);\\r\\nBN_lshift(test,BN_value_one(),bits-1);\\r\\nfor (;;)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (callback != NULL) callback(0,m++,cb_arg);\\r\\nif (!seed_len)\\r\\nRAND_bytes(seed,SHA_DIGEST_LENGTH);\\r\\nelse\\r\\nseed_len=0;\\r\\nmemcpy(buf,seed,SHA_DIGEST_LENGTH);\\r\\nmemcpy(buf2,seed,SHA_DIGEST_LENGTH);\\r\\nfor (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)\\r\\n{\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0) break;\\r\\n}\\r\\nHASH(seed,SHA_DIGEST_LENGTH,md);\\r\\nHASH(buf,SHA_DIGEST_LENGTH,buf2);\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nmd[i]^=buf2[i];\\r\\nmd[0]|=0x80;\\r\\nmd[SHA_DIGEST_LENGTH-1]|=0x01;\\r\\nif (!BN_bin2bn(md,SHA_DIGEST_LENGTH,q)) abort();\\r\\nif (DSA_is_prime(q,callback,cb_arg) > 0) break;\\r\\n}\\r\\nif (callback != NULL) callback(2,0,cb_arg);\\r\\nif (callback != NULL) callback(3,0,cb_arg);\\r\\ncounter=0;\\r\\nn=(bits-1)/160;\\r\\nb=(bits-1)-n*160;\\r\\nfor (;;)\\r\\n{\\r\\nBN_zero(W);\\r\\nfor (k=0; k<=n; k++)\\r\\n{\\r\\nfor (i=SHA_DIGEST_LENGTH-1; i >= 0; i--)\\r\\n{\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0) break;\\r\\n}\\r\\nHASH(buf,SHA_DIGEST_LENGTH,md);\\r\\nif (!BN_bin2bn(md,SHA_DIGEST_LENGTH,r0)) abort();\\r\\nBN_lshift(r0,r0,160*k);\\r\\nBN_add(W,W,r0);\\r\\n}\\r\\nBN_mask_bits(W,bits-1);\\r\\nBN_copy(X,W);\\r\\nBN_add(X,X,test);\\r\\nBN_lshift1(r0,q);\\r\\nBN_mod(c,X,r0,ctx);\\r\\nBN_sub(r0,c,BN_value_one());\\r\\nBN_sub(p,X,r0);\\r\\nif (BN_cmp(p,test) >= 0)\\r\\n{\\r\\nif (DSA_is_prime(p,callback,cb_arg) > 0)\\r\\ngoto end;\\r\\n}\\r\\ncounter++;\\r\\nif (counter >= 4096) break;\\r\\nif (callback != NULL) callback(0,counter,cb_arg);\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (callback != NULL) callback(2,1,cb_arg);\\r\\nBN_sub(test,p,BN_value_one());\\r\\nBN_div(r0,NULL,test,q,ctx);\\r\\nBN_set_word(test,h);\\r\\nBN_MONT_CTX_set(mont,p,ctx);\\r\\nfor (;;)\\r\\n{\\r\\nBN_mod_exp_mont(g,test,r0,p,ctx,mont);\\r\\nif (!BN_is_one(g)) break;\\r\\nBN_add(test,test,BN_value_one());\\r\\nh++;\\r\\n}\\r\\nif (callback != NULL) callback(3,1,cb_arg);\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nif (ret != NULL) DSA_free(ret);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->p=BN_dup(p);\\r\\nret->q=BN_dup(q);\\r\\nret->g=BN_dup(g);\\r\\nif ((m > 1) && (seed_in != NULL)) memcpy(seed_in,seed,20);\\r\\nif (counter_ret != NULL) *counter_ret=counter;\\r\\nif (h_ret != NULL) *h_ret=h;\\r\\n}\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nif (ctx != NULL) BN_CTX_free(ctx2);\\r\\nif (mont != NULL) BN_MONT_CTX_free(mont);\\r\\nreturn(ok?ret:NULL);\\r\\n}\\r\\nint DSA_is_prime(BIGNUM *w, void (*callback)(), char *cb_arg)\\r\\n{\\r\\nint ok= -1,j,i,n;\\r\\nBN_CTX *ctx=NULL,*ctx2=NULL;\\r\\nBIGNUM *w_1,*b,*m,*z,*tmp,*mont_1;\\r\\nint a;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nif (!BN_is_bit_set(w,0)) return(0);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif ((ctx2=BN_CTX_new()) == NULL) goto err;\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\nm= &(ctx2->bn[2]);\\r\\nb= &(ctx2->bn[3]);\\r\\nz= &(ctx2->bn[4]);\\r\\nw_1= &(ctx2->bn[5]);\\r\\ntmp= &(ctx2->bn[6]);\\r\\nmont_1= &(ctx2->bn[7]);\\r\\nn=50;\\r\\nif (!BN_sub(w_1,w,BN_value_one())) goto err;\\r\\nfor (a=1; !BN_is_bit_set(w_1,a); a++)\\r\\n;\\r\\nif (!BN_rshift(m,w_1,a)) goto err;\\r\\nBN_MONT_CTX_set(mont,w,ctx);\\r\\nBN_to_montgomery(mont_1,BN_value_one(),mont,ctx);\\r\\nBN_to_montgomery(w_1,w_1,mont,ctx);\\r\\nfor (i=1; i < n; i++)\\r\\n{\\r\\nBN_rand(b,BN_num_bits(w)-2,0,0);\\r\\nj=0;\\r\\nif (!BN_mod_exp_mont(z,b,m,w,ctx,mont)) goto err;\\r\\nif (!BN_to_montgomery(z,z,mont,ctx)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (((j == 0) && (BN_cmp(z,mont_1) == 0)) ||\\r\\n(BN_cmp(z,w_1) == 0))\\r\\nbreak;\\r\\nif ((j > 0) && (BN_cmp(z,mont_1) == 0))\\r\\n{\\r\\nok=0;\\r\\ngoto err;\\r\\n}\\r\\nj++;\\r\\nif (j >= a)\\r\\n{\\r\\nok=0;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_montgomery(z,z,z,mont,ctx)) goto err;\\r\\nif (callback != NULL) callback(1,j,cb_arg);\\r\\n}\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (ok == -1) DSAerr(DSA_F_DSA_IS_PRIME,ERR_R_BN_LIB);\\r\\nBN_CTX_free(ctx);\\r\\nBN_CTX_free(ctx2);\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_dec_c", "target": 0, "func": "int EVP_PKEY_decrypt(unsigned char *key, unsigned char *ek, int ekl,\\r\\nEVP_PKEY *priv)\\r\\n{\\r\\nint ret= -1;\\r\\n#ifndef NO_RSA\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret=RSA_private_decrypt(ekl,ek,key,priv->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_xcbc_d_c", "target": 0, "func": "EVP_CIPHER *EVP_desx_cbc(void)\\r\\n{\\r\\nreturn(&d_xcbc_cipher);\\r\\n}\\r\\nstatic void desx_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(deskey,ctx->c.desx_cbc.ks);\\r\\nmemcpy(&(ctx->c.desx_cbc.inw[0]),&(key[8]),8);\\r\\nmemcpy(&(ctx->c.desx_cbc.outw[0]),&(key[16]),8);\\r\\n}\\r\\n}\\r\\nstatic void desx_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_xcbc_encrypt(in,out,inl,ctx->c.desx_cbc.ks,\\r\\n(des_cblock *)&(ctx->iv[0]),\\r\\n&ctx->c.desx_cbc.inw,\\r\\n&ctx->c.desx_cbc.outw,\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pkcs7err_c", "target": 0, "func": "void ERR_load_PKCS7_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_PKCS7,PKCS7_str_functs);\\r\\nERR_load_strings(ERR_LIB_PKCS7,PKCS7_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_mul_c", "target": 0, "func": "void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint n=n2/2,c1,c2;\\r\\nunsigned int neg,zero;\\r\\nBN_ULONG ln,lo,*p;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_recursive %d * %d\\n\",n2,n2);\\r\\n#endif\\r\\n#ifdef BN_MUL_COMBA\\r\\nif (n2 == 8)\\r\\n{\\r\\nbn_mul_comba8(r,a,b);\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nif (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_normal(r,a,n2,b,n2);\\r\\nreturn;\\r\\n}\\r\\nc1=bn_cmp_words(a,&(a[n]),n);\\r\\nc2=bn_cmp_words(&(b[n]),b,n);\\r\\nzero=neg=0;\\r\\nswitch (c1*3+c2)\\r\\n{\\r\\ncase -4:\\r\\nbn_sub_words(t, &(a[n]),a, n);\\r\\nbn_sub_words(&(t[n]),b, &(b[n]),n);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_words(t, &(a[n]),a, n);\\r\\nbn_sub_words(&(t[n]),&(b[n]),b, n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_words(t, a, &(a[n]),n);\\r\\nbn_sub_words(&(t[n]),b, &(b[n]),n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_words(t, a, &(a[n]),n);\\r\\nbn_sub_words(&(t[n]),&(b[n]),b, n);\\r\\nbreak;\\r\\n}\\r\\n#ifdef BN_MUL_COMBA\\r\\nif (n == 4)\\r\\n{\\r\\nif (!zero)\\r\\nbn_mul_comba4(&(t[n2]),t,&(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]),0,8*sizeof(BN_ULONG));\\r\\nbn_mul_comba4(r,a,b);\\r\\nbn_mul_comba4(&(r[n2]),&(a[n]),&(b[n]));\\r\\n}\\r\\nelse if (n == 8)\\r\\n{\\r\\nif (!zero)\\r\\nbn_mul_comba8(&(t[n2]),t,&(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]),0,16*sizeof(BN_ULONG));\\r\\nbn_mul_comba8(r,a,b);\\r\\nbn_mul_comba8(&(r[n2]),&(a[n]),&(b[n]));\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\np= &(t[n2*2]);\\r\\nif (!zero)\\r\\nbn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);\\r\\nelse\\r\\nmemset(&(t[n2]),0,n2*sizeof(BN_ULONG));\\r\\nbn_mul_recursive(r,a,b,n,p);\\r\\nbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),n,p);\\r\\n}\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nif (neg)\\r\\n{\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\n}\\r\\nelse\\r\\n{\\r\\nc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\\r\\n}\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < (BN_ULONG)c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,\\r\\nint n, BN_ULONG *t)\\r\\n{\\r\\nint i,j,n2=n*2;\\r\\nunsigned int c1;\\r\\nBN_ULONG ln,lo,*p;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_part_recursive %d * %d\\n\",tn+n,tn+n);\\r\\n#endif\\r\\nif (n < 8)\\r\\n{\\r\\ni=tn+n;\\r\\nbn_mul_normal(r,a,i,b,i);\\r\\nreturn;\\r\\n}\\r\\nbn_sub_words(t, a, &(a[n]),n);\\r\\nbn_sub_words(&(t[n]),b, &(b[n]),n);\\r\\nif (n == 8)\\r\\n{\\r\\nbn_mul_comba8(&(t[n2]),t,&(t[n]));\\r\\nbn_mul_comba8(r,a,b);\\r\\nbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\\r\\nmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\\r\\n}\\r\\nelse\\r\\n{\\r\\np= &(t[n2*2]);\\r\\nbn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);\\r\\nbn_mul_recursive(r,a,b,n,p);\\r\\ni=n/2;\\r\\nj=tn-i;\\r\\nif (j == 0)\\r\\n{\\r\\nbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);\\r\\nmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\\r\\n}\\r\\nelse if (j > 0)\\r\\n{\\r\\nbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\\r\\nj,i,p);\\r\\nmemset(&(r[n2+tn*2]),0,\\r\\nsizeof(BN_ULONG)*(n2-tn*2));\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\\r\\nif (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni/=2;\\r\\nif (i < tn)\\r\\n{\\r\\nbn_mul_part_recursive(&(r[n2]),\\r\\n&(a[n]),&(b[n]),\\r\\ntn-i,i,p);\\r\\nbreak;\\r\\n}\\r\\nelse if (i == tn)\\r\\n{\\r\\nbn_mul_recursive(&(r[n2]),\\r\\n&(a[n]),&(b[n]),\\r\\ni,p);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint n=n2/2;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_low_recursive %d * %d\\n\",n2,n2);\\r\\n#endif\\r\\nbn_mul_recursive(r,a,b,n,&(t[0]));\\r\\nif (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_mul_low_recursive(&(t[0]),&(a[0]),&(b[n]),n,&(t[n2]));\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\nbn_mul_low_recursive(&(t[0]),&(a[n]),&(b[0]),n,&(t[n2]));\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbn_mul_low_normal(&(t[0]),&(a[0]),&(b[n]),n);\\r\\nbn_mul_low_normal(&(t[n]),&(a[n]),&(b[0]),n);\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[0]),n);\\r\\nbn_add_words(&(r[n]),&(r[n]),&(t[n]),n);\\r\\n}\\r\\n}\\r\\nvoid bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint i,n;\\r\\nint c1,c2;\\r\\nint neg,oneg,zero;\\r\\nBN_ULONG ll,lc,*lp,*mp;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_high %d * %d\\n\",n2,n2);\\r\\n#endif\\r\\nn=n2/2;\\r\\nneg=zero=0;\\r\\nc1=bn_cmp_words(&(a[0]),&(a[n]),n);\\r\\nc2=bn_cmp_words(&(b[n]),&(b[0]),n);\\r\\nswitch (c1*3+c2)\\r\\n{\\r\\ncase -4:\\r\\nbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\\r\\nbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_words(&(r[0]),&(a[n]),&(a[0]),n);\\r\\nbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\\r\\nbn_sub_words(&(r[n]),&(b[0]),&(b[n]),n);\\r\\nneg=1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero=1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_words(&(r[0]),&(a[0]),&(a[n]),n);\\r\\nbn_sub_words(&(r[n]),&(b[n]),&(b[0]),n);\\r\\nbreak;\\r\\n}\\r\\noneg=neg;\\r\\n#ifdef BN_MUL_COMBA\\r\\nif (n == 8)\\r\\n{\\r\\nbn_mul_comba8(&(t[0]),&(r[0]),&(r[n]));\\r\\nbn_mul_comba8(r,&(a[n]),&(b[n]));\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nbn_mul_recursive(&(t[0]),&(r[0]),&(r[n]),n,&(t[n2]));\\r\\nbn_mul_recursive(r,&(a[n]),&(b[n]),n,&(t[n2]));\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nc1=(int)(bn_add_words(lp,&(r[0]),&(l[0]),n));\\r\\n}\\r\\nelse\\r\\n{\\r\\nc1=0;\\r\\nlp= &(r[0]);\\r\\n}\\r\\nif (neg)\\r\\nneg=(int)(bn_sub_words(&(t[n2]),lp,&(t[0]),n));\\r\\nelse\\r\\n{\\r\\nbn_add_words(&(t[n2]),lp,&(t[0]),n);\\r\\nneg=0;\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nbn_sub_words(&(t[n2+n]),&(l[n]),&(t[n2]),n);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nmp= &(t[n2]);\\r\\nfor (i=0; i<n; i++)\\r\\nlp[i]=((~mp[i])+1)&BN_MASK2;\\r\\n}\\r\\nif (l != NULL)\\r\\n{\\r\\nlp= &(t[n2]);\\r\\nc1= (int)(bn_add_words(lp,&(t[n2+n]),&(l[0]),n));\\r\\n}\\r\\nelse\\r\\n{\\r\\nlp= &(t[n2+n]);\\r\\nc1=0;\\r\\n}\\r\\nc1+=(int)(bn_add_words(&(t[n2]),lp, &(r[0]),n));\\r\\nif (oneg)\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),&(t[n2]),&(t[0]),n));\\r\\nelse\\r\\nc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),&(t[0]),n));\\r\\nc2 =(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n2+n]),n));\\r\\nc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(r[n]),n));\\r\\nif (oneg)\\r\\nc2-=(int)(bn_sub_words(&(r[0]),&(r[0]),&(t[n]),n));\\r\\nelse\\r\\nc2+=(int)(bn_add_words(&(r[0]),&(r[0]),&(t[n]),n));\\r\\nif (c1 != 0)\\r\\n{\\r\\ni=0;\\r\\nif (c1 > 0)\\r\\n{\\r\\nlc=c1;\\r\\ndo {\\r\\nll=(r[i]+lc)&BN_MASK2;\\r\\nr[i++]=ll;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlc= -c1;\\r\\ndo {\\r\\nll=r[i];\\r\\nr[i++]=(ll-lc)&BN_MASK2;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\nif (c2 != 0)\\r\\n{\\r\\ni=n;\\r\\nif (c2 > 0)\\r\\n{\\r\\nlc=c2;\\r\\ndo {\\r\\nll=(r[i]+lc)&BN_MASK2;\\r\\nr[i++]=ll;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlc= -c2;\\r\\ndo {\\r\\nll=r[i];\\r\\nr[i++]=(ll-lc)&BN_MASK2;\\r\\nlc=(lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint top,al,bl;\\r\\nBIGNUM *rr;\\r\\n#ifdef BN_RECURSION\\r\\nBIGNUM *t;\\r\\nint i,j,k;\\r\\n#endif\\r\\n#ifdef BN_COUNT\\r\\nprintf(\"BN_mul %d * %d\\n\",a->top,b->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(r);\\r\\nal=a->top;\\r\\nbl=b->top;\\r\\nr->neg=a->neg^b->neg;\\r\\nif ((al == 0) || (bl == 0))\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\ntop=al+bl;\\r\\nif ((r == a) || (r == b))\\r\\nrr= &(ctx->bn[ctx->tos+1]);\\r\\nelse\\r\\nrr=r;\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nif (al == bl)\\r\\n{\\r\\n# ifdef BN_MUL_COMBA\\r\\nif (al == 8)\\r\\n{\\r\\nif (bn_wexpand(rr,16) == NULL) return(0);\\r\\nrr->top=16;\\r\\nbn_mul_comba8(rr->d,a->d,b->d);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n# endif\\r\\n#ifdef BN_RECURSION\\r\\nif (al < BN_MULL_SIZE_NORMAL)\\r\\n#endif\\r\\n{\\r\\nif (bn_wexpand(rr,top) == NULL) return(0);\\r\\nrr->top=top;\\r\\nbn_mul_normal(rr->d,a->d,al,b->d,bl);\\r\\ngoto end;\\r\\n}\\r\\n# ifdef BN_RECURSION\\r\\ngoto symetric;\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifdef BN_RECURSION\\r\\nelse if ((al < BN_MULL_SIZE_NORMAL) || (bl < BN_MULL_SIZE_NORMAL))\\r\\n{\\r\\nif (bn_wexpand(rr,top) == NULL) return(0);\\r\\nrr->top=top;\\r\\nbn_mul_normal(rr->d,a->d,al,b->d,bl);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=(al-bl);\\r\\nif ((i == 1) && !BN_get_flags(b,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nbn_wexpand(b,al);\\r\\nb->d[bl]=0;\\r\\nbl++;\\r\\ngoto symetric;\\r\\n}\\r\\nelse if ((i == -1) && !BN_get_flags(a,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nbn_wexpand(a,bl);\\r\\na->d[al]=0;\\r\\nal++;\\r\\ngoto symetric;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (bn_wexpand(rr,top) == NULL) return(0);\\r\\nrr->top=top;\\r\\nbn_mul_normal(rr->d,a->d,al,b->d,bl);\\r\\n#ifdef BN_RECURSION\\r\\nif (0)\\r\\n{\\r\\nsymetric:\\r\\nj=BN_num_bits_word((BN_ULONG)al);\\r\\nj=1<<(j-1);\\r\\nk=j+j;\\r\\nt= &(ctx->bn[ctx->tos]);\\r\\nif (al == j)\\r\\n{\\r\\nbn_wexpand(t,k*2);\\r\\nbn_wexpand(rr,k*2);\\r\\nbn_mul_recursive(rr->d,a->d,b->d,al,t->d);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbn_wexpand(a,k);\\r\\nbn_wexpand(b,k);\\r\\nbn_wexpand(t,k*4);\\r\\nbn_wexpand(rr,k*4);\\r\\nfor (i=a->top; i<k; i++)\\r\\na->d[i]=0;\\r\\nfor (i=b->top; i<k; i++)\\r\\nb->d[i]=0;\\r\\nbn_mul_part_recursive(rr->d,a->d,b->d,al-j,j,t->d);\\r\\n}\\r\\nrr->top=top;\\r\\n}\\r\\n#endif\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nend:\\r\\n#endif\\r\\nbn_fix_top(rr);\\r\\nif (r != rr) BN_copy(r,rr);\\r\\nreturn(1);\\r\\n}\\r\\nvoid bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)\\r\\n{\\r\\nBN_ULONG *rr;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_normal %d * %d\\n\",na,nb);\\r\\n#endif\\r\\nif (na < nb)\\r\\n{\\r\\nint itmp;\\r\\nBN_ULONG *ltmp;\\r\\nitmp=na; na=nb; nb=itmp;\\r\\nltmp=a; a=b; b=ltmp;\\r\\n}\\r\\nrr= &(r[na]);\\r\\nrr[0]=bn_mul_words(r,a,na,b[0]);\\r\\nfor (;;)\\r\\n{\\r\\nif (--nb <= 0) return;\\r\\nrr[1]=bn_mul_add_words(&(r[1]),a,na,b[1]);\\r\\nif (--nb <= 0) return;\\r\\nrr[2]=bn_mul_add_words(&(r[2]),a,na,b[2]);\\r\\nif (--nb <= 0) return;\\r\\nrr[3]=bn_mul_add_words(&(r[3]),a,na,b[3]);\\r\\nif (--nb <= 0) return;\\r\\nrr[4]=bn_mul_add_words(&(r[4]),a,na,b[4]);\\r\\nrr+=4;\\r\\nr+=4;\\r\\nb+=4;\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_mul_low_normal %d * %d\\n\",n,n);\\r\\n#endif\\r\\nbn_mul_words(r,a,n,b[0]);\\r\\nfor (;;)\\r\\n{\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[1]),a,n,b[1]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[2]),a,n,b[2]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[3]),a,n,b[3]);\\r\\nif (--n <= 0) return;\\r\\nbn_mul_add_words(&(r[4]),a,n,b[4]);\\r\\nr+=4;\\r\\nb+=4;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rand_key_c", "target": 0, "func": "void des_random_seed(des_cblock *key)\\r\\n{\\r\\nmemcpy(&init,key,sizeof(des_cblock));\\r\\nseed=1;\\r\\n}\\r\\nvoid des_random_key(des_cblock *ret)\\r\\n{\\r\\ndes_key_schedule ks;\\r\\nstatic DES_LONG c=0;\\r\\nstatic unsigned short pid=0;\\r\\nstatic des_cblock data={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};\\r\\ndes_cblock key;\\r\\nunsigned char *p;\\r\\nDES_LONG t;\\r\\nint i;\\r\\n#ifdef MSDOS\\r\\npid=1;\\r\\n#else\\r\\nif (!pid) pid=getpid();\\r\\n#endif\\r\\np=key;\\r\\nif (seed)\\r\\n{\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\ndata[i] ^= init[i];\\r\\ninit[i]=0;\\r\\n}\\r\\nseed=0;\\r\\n}\\r\\nt=(DES_LONG)time(NULL);\\r\\nl2c(t,p);\\r\\nt=(DES_LONG)((pid)|((c++)<<16));\\r\\nl2c(t,p);\\r\\ndes_set_odd_parity(&data);\\r\\ndes_set_key(&data,ks);\\r\\ndes_cbc_cksum(key,&key,sizeof(key),ks,&data);\\r\\ndes_set_odd_parity(&key);\\r\\ndes_set_key(&key,ks);\\r\\ndes_cbc_cksum(key,&data,sizeof(key),ks,&key);\\r\\nmemcpy(ret,data,sizeof(key));\\r\\nmemset(key,0,sizeof(key));\\r\\nmemset(ks,0,sizeof(ks));\\r\\nt=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2_cbc_c", "target": 0, "func": "void RC2_cbc_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC2_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC2_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC2_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC2_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC2_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid RC2_encrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i,n;\\r\\nregister RC2_INT *p0,*p1;\\r\\nregister RC2_INT x0,x1,x2,x3,t;\\r\\nunsigned long l;\\r\\nl=d[0];\\r\\nx0=(RC2_INT)l&0xffff;\\r\\nx1=(RC2_INT)(l>>16L);\\r\\nl=d[1];\\r\\nx2=(RC2_INT)l&0xffff;\\r\\nx3=(RC2_INT)(l>>16L);\\r\\nn=3;\\r\\ni=5;\\r\\np0=p1= &(key->data[0]);\\r\\nfor (;;)\\r\\n{\\r\\nt=(x0+(x1& ~x3)+(x2&x3)+ *(p0++))&0xffff;\\r\\nx0=(t<<1)|(t>>15);\\r\\nt=(x1+(x2& ~x0)+(x3&x0)+ *(p0++))&0xffff;\\r\\nx1=(t<<2)|(t>>14);\\r\\nt=(x2+(x3& ~x1)+(x0&x1)+ *(p0++))&0xffff;\\r\\nx2=(t<<3)|(t>>13);\\r\\nt=(x3+(x0& ~x2)+(x1&x2)+ *(p0++))&0xffff;\\r\\nx3=(t<<5)|(t>>11);\\r\\nif (--i == 0)\\r\\n{\\r\\nif (--n == 0) break;\\r\\ni=(n == 2)?6:5;\\r\\nx0+=p1[x3&0x3f];\\r\\nx1+=p1[x0&0x3f];\\r\\nx2+=p1[x1&0x3f];\\r\\nx3+=p1[x2&0x3f];\\r\\n}\\r\\n}\\r\\nd[0]=(unsigned long)(x0&0xffff)|((unsigned long)(x1&0xffff)<<16L);\\r\\nd[1]=(unsigned long)(x2&0xffff)|((unsigned long)(x3&0xffff)<<16L);\\r\\n}\\r\\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i,n;\\r\\nregister RC2_INT *p0,*p1;\\r\\nregister RC2_INT x0,x1,x2,x3,t;\\r\\nunsigned long l;\\r\\nl=d[0];\\r\\nx0=(RC2_INT)l&0xffff;\\r\\nx1=(RC2_INT)(l>>16L);\\r\\nl=d[1];\\r\\nx2=(RC2_INT)l&0xffff;\\r\\nx3=(RC2_INT)(l>>16L);\\r\\nn=3;\\r\\ni=5;\\r\\np0= &(key->data[63]);\\r\\np1= &(key->data[0]);\\r\\nfor (;;)\\r\\n{\\r\\nt=((x3<<11)|(x3>>5))&0xffff;\\r\\nx3=(t-(x0& ~x2)-(x1&x2)- *(p0--))&0xffff;\\r\\nt=((x2<<13)|(x2>>3))&0xffff;\\r\\nx2=(t-(x3& ~x1)-(x0&x1)- *(p0--))&0xffff;\\r\\nt=((x1<<14)|(x1>>2))&0xffff;\\r\\nx1=(t-(x2& ~x0)-(x3&x0)- *(p0--))&0xffff;\\r\\nt=((x0<<15)|(x0>>1))&0xffff;\\r\\nx0=(t-(x1& ~x3)-(x2&x3)- *(p0--))&0xffff;\\r\\nif (--i == 0)\\r\\n{\\r\\nif (--n == 0) break;\\r\\ni=(n == 2)?6:5;\\r\\nx3=(x3-p1[x2&0x3f])&0xffff;\\r\\nx2=(x2-p1[x1&0x3f])&0xffff;\\r\\nx1=(x1-p1[x0&0x3f])&0xffff;\\r\\nx0=(x0-p1[x3&0x3f])&0xffff;\\r\\n}\\r\\n}\\r\\nd[0]=(unsigned long)(x0&0xffff)|((unsigned long)(x1&0xffff)<<16L);\\r\\nd[1]=(unsigned long)(x2&0xffff)|((unsigned long)(x3&0xffff)<<16L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_read_pwd_c", "target": 0, "func": "int des_read_pw_string(char *buf, int length, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nchar buff[BUFSIZ];\\r\\nint ret;\\r\\nret=des_read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);\\r\\nmemset(buff,0,BUFSIZ);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void read_till_nl(FILE *in)\\r\\n{\\r\\n#define SIZE 4\\r\\nchar buf[SIZE+1];\\r\\ndo {\\r\\nfgets(buf,SIZE,in);\\r\\n} while (strchr(buf,'\\n') == NULL);\\r\\n}\\r\\nint des_read_pw(char *buf, char *buff, int size, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\n#ifdef VMS\\r\\nstruct IOSB iosb;\\r\\n$DESCRIPTOR(terminal,\"TT\");\\r\\nlong tty_orig[3], tty_new[3];\\r\\nlong status;\\r\\nunsigned short channel = 0;\\r\\n#else\\r\\n#ifndef MSDOS\\r\\nTTY_STRUCT tty_orig,tty_new;\\r\\n#endif\\r\\n#endif\\r\\nint number;\\r\\nint ok;\\r\\nstatic int ps;\\r\\nint is_a_tty;\\r\\nstatic FILE *tty;\\r\\nchar *p;\\r\\nif (setjmp(save))\\r\\n{\\r\\nok=0;\\r\\ngoto error;\\r\\n}\\r\\nnumber=5;\\r\\nok=0;\\r\\nps=0;\\r\\nis_a_tty=1;\\r\\ntty=NULL;\\r\\n#ifndef MSDOS\\r\\nif ((tty=fopen(\"/dev/tty\",\"r\")) == NULL)\\r\\ntty=stdin;\\r\\n#else\\r\\nif ((tty=fopen(\"con\",\"r\")) == NULL)\\r\\ntty=stdin;\\r\\n#endif\\r\\n#if defined(TTY_get) && !defined(VMS)\\r\\nif (TTY_get(fileno(tty),&tty_orig) == -1)\\r\\n{\\r\\n#ifdef ENOTTY\\r\\nif (errno == ENOTTY)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\n#ifdef EINVAL\\r\\nif (errno == EINVAL)\\r\\nis_a_tty=0;\\r\\nelse\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nmemcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));\\r\\n#endif\\r\\n#ifdef VMS\\r\\nstatus = sys$assign(&terminal,&channel,0,0);\\r\\nif (status != SS$_NORMAL)\\r\\nreturn(-1);\\r\\nstatus=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn(-1);\\r\\n#endif\\r\\npushsig();\\r\\nps=1;\\r\\n#ifdef TTY_FLAGS\\r\\ntty_new.TTY_FLAGS &= ~ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty),&tty_new) == -1))\\r\\nreturn(-1);\\r\\n#endif\\r\\n#ifdef VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] | TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn(-1);\\r\\n#endif\\r\\nps=2;\\r\\nwhile ((!ok) && (number--))\\r\\n{\\r\\nfputs(prompt,stderr);\\r\\nfflush(stderr);\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,size,tty);\\r\\nif (feof(tty)) goto error;\\r\\nif (ferror(tty)) goto error;\\r\\nif ((p=(char *)strchr(buf,'\\n')) != NULL)\\r\\n*p='\\0';\\r\\nelse read_till_nl(tty);\\r\\nif (verify)\\r\\n{\\r\\nfprintf(stderr,\"\\nVerifying password - %s\",prompt);\\r\\nfflush(stderr);\\r\\nbuff[0]='\\0';\\r\\nfgets(buff,size,tty);\\r\\nif (feof(tty)) goto error;\\r\\nif ((p=(char *)strchr(buff,'\\n')) != NULL)\\r\\n*p='\\0';\\r\\nelse read_till_nl(tty);\\r\\nif (strcmp(buf,buff) != 0)\\r\\n{\\r\\nfprintf(stderr,\"\\nVerify failure\");\\r\\nfflush(stderr);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nok=1;\\r\\n}\\r\\nerror:\\r\\nfprintf(stderr,\"\\n\");\\r\\n#ifdef DEBUG\\r\\nperror(\"fgets(tty)\");\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(VMS)\\r\\nif (ps >= 2) TTY_set(fileno(tty),&tty_orig);\\r\\n#endif\\r\\n#ifdef VMS\\r\\nif (ps >= 2)\\r\\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0\\r\\n,tty_orig,12,0,0,0,0);\\r\\n#endif\\r\\nif (ps >= 1) popsig();\\r\\nif (stdin != tty) fclose(tty);\\r\\n#ifdef VMS\\r\\nstatus = sys$dassgn(channel);\\r\\n#endif\\r\\nreturn(!ok);\\r\\n}\\r\\nint des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)\\r\\n{\\r\\nmemset(buf,0,size);\\r\\nmemset(buff,0,size);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void pushsig(void)\\r\\n{\\r\\nint i;\\r\\n#ifdef SIGACTION\\r\\nstruct sigaction sa;\\r\\nmemset(&sa,0,sizeof sa);\\r\\nsa.sa_handler=recsig;\\r\\n#endif\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&sa,&savsig[i]);\\r\\n#else\\r\\nsavsig[i]=signal(i,recsig);\\r\\n#endif\\r\\n}\\r\\n#ifdef SIGWINCH\\r\\nsignal(SIGWINCH,SIG_DFL);\\r\\n#endif\\r\\n}\\r\\nstatic void popsig(void)\\r\\n{\\r\\nint i;\\r\\nfor (i=1; i<NX509_SIG; i++)\\r\\n{\\r\\n#ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n#endif\\r\\n#ifdef SIGACTION\\r\\nsigaction(i,&savsig[i],NULL);\\r\\n#else\\r\\nsignal(i,savsig[i]);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void recsig(int i)\\r\\n{\\r\\nlongjmp(save,1);\\r\\n#ifdef LINT\\r\\ni=i;\\r\\n#endif\\r\\n}\\r\\nstatic int noecho_fgets(char *buf, int size, FILE *tty)\\r\\n{\\r\\nint i;\\r\\nchar *p;\\r\\np=buf;\\r\\nfor (;;)\\r\\n{\\r\\nif (size == 0)\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\nsize--;\\r\\n#ifdef WIN16TTY\\r\\ni=_inchar();\\r\\n#else\\r\\ni=getch();\\r\\n#endif\\r\\nif (i == '\\r') i='\\n';\\r\\n*(p++)=i;\\r\\nif (i == '\\n')\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#ifdef WIN_CONSOLE_BUG\\r\\n{\\r\\nHANDLE inh;\\r\\ninh = GetStdHandle(STD_INPUT_HANDLE);\\r\\nFlushConsoleInputBuffer(inh);\\r\\n}\\r\\n#endif\\r\\nreturn(strlen(buf));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_3d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ede_cfb(void)\\r\\n{\\r\\nreturn(&d_ede_cfb_cipher2);\\r\\n}\\r\\nEVP_CIPHER *EVP_des_ede3_cfb(void)\\r\\n{\\r\\nreturn(&d_ede3_cfb_cipher3);\\r\\n}\\r\\nstatic void des_ede_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\nmemcpy( (char *)ctx->c.des_ede.ks3,\\r\\n(char *)ctx->c.des_ede.ks1,\\r\\nsizeof(ctx->c.des_ede.ks1));\\r\\n}\\r\\n}\\r\\nstatic void des_ede3_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\ndes_set_key(&deskey[2],ctx->c.des_ede.ks3);\\r\\n}\\r\\n}\\r\\nstatic void des_ede_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_ede3_cfb64_encrypt(in,out,(long)inl,\\r\\nctx->c.des_ede.ks1,\\r\\nctx->c.des_ede.ks2,\\r\\nctx->c.des_ede.ks3,\\r\\n(des_cblock*)&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_3d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ede_ofb(void)\\r\\n{\\r\\nreturn(&d_ede_ofb_cipher2);\\r\\n}\\r\\nEVP_CIPHER *EVP_des_ede3_ofb(void)\\r\\n{\\r\\nreturn(&d_ede3_ofb_cipher3);\\r\\n}\\r\\nstatic void des_ede_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\nmemcpy( (char *)ctx->c.des_ede.ks3,\\r\\n(char *)ctx->c.des_ede.ks1,\\r\\nsizeof(ctx->c.des_ede.ks1));\\r\\n}\\r\\n}\\r\\nstatic void des_ede3_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\ndes_set_key(&deskey[2],ctx->c.des_ede.ks3);\\r\\n}\\r\\n}\\r\\nstatic void des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_ede3_ofb64_encrypt(in,out,inl,ctx->c.des_ede.ks1,\\r\\nctx->c.des_ede.ks2, ctx->c.des_ede.ks3,\\r\\n(des_cblock *)&(ctx->iv[0]),&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_obj_lib_c", "target": 0, "func": "ASN1_OBJECT *OBJ_dup(ASN1_OBJECT *o)\\r\\n{\\r\\nASN1_OBJECT *r;\\r\\nint i;\\r\\nchar *ln=NULL;\\r\\nif (o == NULL) return(NULL);\\r\\nif (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC))\\r\\nreturn(o);\\r\\nr=ASN1_OBJECT_new();\\r\\nif (r == NULL)\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_DUP,ERR_R_ASN1_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nr->data=Malloc(o->length);\\r\\nif (r->data == NULL)\\r\\ngoto err;\\r\\nmemcpy(r->data,o->data,o->length);\\r\\nr->length=o->length;\\r\\nr->nid=o->nid;\\r\\nr->ln=r->sn=NULL;\\r\\nif (o->ln != NULL)\\r\\n{\\r\\ni=strlen(o->ln)+1;\\r\\nr->ln=ln=Malloc(i);\\r\\nif (r->ln == NULL) goto err;\\r\\nmemcpy(ln,o->ln,i);\\r\\n}\\r\\nif (o->sn != NULL)\\r\\n{\\r\\nchar *s;\\r\\ni=strlen(o->sn)+1;\\r\\nr->sn=s=Malloc(i);\\r\\nif (r->sn == NULL) goto err;\\r\\nmemcpy(s,o->sn,i);\\r\\n}\\r\\nr->flags=o->flags|(ASN1_OBJECT_FLAG_DYNAMIC|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS|ASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn(r);\\r\\nerr:\\r\\nOBJerr(OBJ_F_OBJ_DUP,ERR_R_MALLOC_FAILURE);\\r\\nif (r != NULL)\\r\\n{\\r\\nif (ln != NULL) Free(ln);\\r\\nif (r->data != NULL) Free(r->data);\\r\\nFree(r);\\r\\n}\\r\\nreturn(NULL);\\r\\n}\\r\\nint OBJ_cmp(ASN1_OBJECT *a, ASN1_OBJECT *b)\\r\\n{\\r\\nint ret;\\r\\nret=(a->length-b->length);\\r\\nif (ret) return(ret);\\r\\nreturn(memcmp(a->data,b->data,a->length));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_mont_c", "target": 0, "func": "int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\\r\\nBN_MONT_CTX *mont, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *tmp,*tmp2;\\r\\ntmp= &(ctx->bn[ctx->tos]);\\r\\ntmp2= &(ctx->bn[ctx->tos]);\\r\\nctx->tos+=2;\\r\\nbn_check_top(tmp);\\r\\nbn_check_top(tmp2);\\r\\nif (a == b)\\r\\n{\\r\\n#if 0\\r\\nbn_wexpand(tmp,a->top*2);\\r\\nbn_wexpand(tmp2,a->top*4);\\r\\nbn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d);\\r\\ntmp->top=a->top*2;\\r\\nif (tmp->d[tmp->top-1] == 0)\\r\\ntmp->top--;\\r\\n#else\\r\\nif (!BN_sqr(tmp,a,ctx)) goto err;\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_mul(tmp,a,b,ctx)) goto err;\\r\\n}\\r\\nif (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;\\r\\nctx->tos-=2;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint BN_from_montgomery(BIGNUM *ret, BIGNUM *a, BN_MONT_CTX *mont,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\n#ifdef BN_RECURSION_MONT\\r\\nif (mont->use_word)\\r\\n#endif\\r\\n{\\r\\nBIGNUM *n,*r;\\r\\nBN_ULONG *ap,*np,*rp,n0,v,*nrp;\\r\\nint al,nl,max,i,x,ri;\\r\\nint retn=0;\\r\\nr= &(ctx->bn[ctx->tos]);\\r\\nif (!BN_copy(r,a)) goto err1;\\r\\nn= &(mont->N);\\r\\nap=a->d;\\r\\nal=ri=mont->ri/BN_BITS2;\\r\\nnl=n->top;\\r\\nif ((al == 0) || (nl == 0)) { r->top=0; return(1); }\\r\\nmax=(nl+al+1);\\r\\nif (bn_wexpand(r,max) == NULL) goto err1;\\r\\nif (bn_wexpand(ret,max) == NULL) goto err1;\\r\\nr->neg=a->neg^n->neg;\\r\\nnp=n->d;\\r\\nrp=r->d;\\r\\nnrp= &(r->d[nl]);\\r\\n#if 1\\r\\nfor (i=r->top; i<max; i++)\\r\\nr->d[i]=0;\\r\\n#else\\r\\nmemset(&(r->d[r->top]),0,(max-r->top)*sizeof(BN_ULONG));\\r\\n#endif\\r\\nr->top=max;\\r\\nn0=mont->n0;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\"word BN_from_montgomery %d * %d\\n\",nl,nl);\\r\\n#endif\\r\\nfor (i=0; i<nl; i++)\\r\\n{\\r\\nv=bn_mul_add_words(rp,np,nl,(rp[0]*n0)&BN_MASK2);\\r\\nnrp++;\\r\\nrp++;\\r\\nif (((nrp[-1]+=v)&BN_MASK2) >= v)\\r\\ncontinue;\\r\\nelse\\r\\n{\\r\\nif (((++nrp[0])&BN_MASK2) != 0) continue;\\r\\nif (((++nrp[1])&BN_MASK2) != 0) continue;\\r\\nfor (x=2; (((++nrp[x])&BN_MASK2) == 0); x++) ;\\r\\n}\\r\\n}\\r\\nbn_fix_top(r);\\r\\n#if 0\\r\\nBN_rshift(ret,r,mont->ri);\\r\\n#else\\r\\nx=ri;\\r\\nrp=ret->d;\\r\\nap= &(r->d[x]);\\r\\nif (r->top < x)\\r\\nal=0;\\r\\nelse\\r\\nal=r->top-x;\\r\\nret->top=al;\\r\\nal-=4;\\r\\nfor (i=0; i<al; i+=4)\\r\\n{\\r\\nBN_ULONG t1,t2,t3,t4;\\r\\nt1=ap[i+0];\\r\\nt2=ap[i+1];\\r\\nt3=ap[i+2];\\r\\nt4=ap[i+3];\\r\\nrp[i+0]=t1;\\r\\nrp[i+1]=t2;\\r\\nrp[i+2]=t3;\\r\\nrp[i+3]=t4;\\r\\n}\\r\\nal+=4;\\r\\nfor (; i<al; i++)\\r\\nrp[i]=ap[i];\\r\\n#endif\\r\\nif (BN_ucmp(ret, &(mont->N)) >= 0)\\r\\n{\\r\\nBN_usub(ret,ret,&(mont->N));\\r\\n}\\r\\nretn=1;\\r\\nerr1:\\r\\nreturn(retn);\\r\\n}\\r\\n#ifdef BN_RECURSION_MONT\\r\\nelse\\r\\n{\\r\\nBIGNUM *t1,*t2,*t3;\\r\\nint j,i;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\"number BN_from_montgomery\\n\");\\r\\n#endif\\r\\nt1= &(ctx->bn[ctx->tos]);\\r\\nt2= &(ctx->bn[ctx->tos+1]);\\r\\nt3= &(ctx->bn[ctx->tos+2]);\\r\\ni=mont->Ni.top;\\r\\nbn_wexpand(ret,i);\\r\\nbn_wexpand(t1,i*4);\\r\\nbn_wexpand(t2,i*2);\\r\\nbn_mul_low_recursive(t2->d,a->d,mont->Ni.d,i,t1->d);\\r\\nBN_zero(t3);\\r\\nBN_set_bit(t3,mont->N.top*BN_BITS2);\\r\\nbn_sub_words(t3->d,t3->d,a->d,i);\\r\\nbn_mul_high(ret->d,t2->d,mont->N.d,t3->d,i,t1->d);\\r\\nif (a->top > i)\\r\\n{\\r\\nj=(int)(bn_add_words(ret->d,ret->d,&(a->d[i]),i));\\r\\nif (j)\\r\\nbn_sub_words(ret->d,ret->d,mont->N.d,i);\\r\\n}\\r\\nret->top=i;\\r\\nbn_fix_top(ret);\\r\\nif (a->d[0])\\r\\nBN_add_word(ret,1);\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<mont->N.top-1; i++)\\r\\n{\\r\\nif (a->d[i])\\r\\n{\\r\\nBN_add_word(ret,1);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (BN_ucmp(ret,&(mont->N)) >= 0)\\r\\nBN_usub(ret,ret,&(mont->N));\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_new(void)\\r\\n{\\r\\nBN_MONT_CTX *ret;\\r\\nif ((ret=(BN_MONT_CTX *)Malloc(sizeof(BN_MONT_CTX))) == NULL)\\r\\nreturn(NULL);\\r\\nBN_MONT_CTX_init(ret);\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BN_MONT_CTX_init(BN_MONT_CTX *ctx)\\r\\n{\\r\\nctx->use_word=0;\\r\\nctx->ri=0;\\r\\nBN_init(&(ctx->RR));\\r\\nBN_init(&(ctx->N));\\r\\nBN_init(&(ctx->Ni));\\r\\nctx->flags=0;\\r\\n}\\r\\nvoid BN_MONT_CTX_free(BN_MONT_CTX *mont)\\r\\n{\\r\\nif(mont == NULL)\\r\\nreturn;\\r\\nBN_free(&(mont->RR));\\r\\nBN_free(&(mont->N));\\r\\nBN_free(&(mont->Ni));\\r\\nif (mont->flags & BN_FLG_MALLOCED)\\r\\nFree(mont);\\r\\n}\\r\\nint BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM Ri,*R;\\r\\nBN_init(&Ri);\\r\\nR= &(mont->RR);\\r\\nBN_copy(&(mont->N),mod);\\r\\n#ifdef BN_RECURSION_MONT\\r\\nif (mont->N.top < BN_MONT_CTX_SET_SIZE_WORD)\\r\\n#endif\\r\\n{\\r\\nBIGNUM tmod;\\r\\nBN_ULONG buf[2];\\r\\nmont->use_word=1;\\r\\nmont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;\\r\\nBN_zero(R);\\r\\nBN_set_bit(R,BN_BITS2);\\r\\nbuf[0]=mod->d[0];\\r\\nbuf[1]=0;\\r\\ntmod.d=buf;\\r\\ntmod.top=1;\\r\\ntmod.max=mod->max;\\r\\ntmod.neg=mod->neg;\\r\\nif ((BN_mod_inverse(&Ri,R,&tmod,ctx)) == NULL)\\r\\ngoto err;\\r\\nBN_lshift(&Ri,&Ri,BN_BITS2);\\r\\nif (!BN_is_zero(&Ri))\\r\\n{\\r\\n#if 1\\r\\nBN_sub_word(&Ri,1);\\r\\n#else\\r\\nBN_usub(&Ri,&Ri,BN_value_one());\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nBN_set_word(&Ri,BN_MASK2);\\r\\n}\\r\\nBN_div(&Ri,NULL,&Ri,&tmod,ctx);\\r\\nmont->n0=Ri.d[0];\\r\\nBN_free(&Ri);\\r\\n}\\r\\n#ifdef BN_RECURSION_MONT\\r\\nelse\\r\\n{\\r\\nmont->use_word=0;\\r\\nmont->ri=(BN_num_bits(mod)+(BN_BITS2-1))/BN_BITS2*BN_BITS2;\\r\\n#if 1\\r\\nBN_zero(R);\\r\\nBN_set_bit(R,mont->ri);\\r\\n#else\\r\\nBN_lshift(R,BN_value_one(),mont->ri);\\r\\n#endif\\r\\nif ((BN_mod_inverse(&Ri,R,mod,ctx)) == NULL)\\r\\ngoto err;\\r\\nBN_lshift(&Ri,&Ri,mont->ri);\\r\\n#if 1\\r\\nBN_sub_word(&Ri,1);\\r\\n#else\\r\\nBN_usub(&Ri,&Ri,BN_value_one());\\r\\n#endif\\r\\nBN_div(&(mont->Ni),NULL,&Ri,mod,ctx);\\r\\nBN_free(&Ri);\\r\\n}\\r\\n#endif\\r\\n#if 1\\r\\nBN_zero(&(mont->RR));\\r\\nBN_set_bit(&(mont->RR),mont->ri*2);\\r\\n#else\\r\\nBN_lshift(mont->RR,BN_value_one(),mont->ri*2);\\r\\n#endif\\r\\nBN_mod(&(mont->RR),&(mont->RR),&(mont->N),ctx);\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)\\r\\n{\\r\\nif (to == from) return(to);\\r\\nBN_copy(&(to->RR),&(from->RR));\\r\\nBN_copy(&(to->N),&(from->N));\\r\\nBN_copy(&(to->Ni),&(from->Ni));\\r\\nto->use_word=from->use_word;\\r\\nto->ri=from->ri;\\r\\nto->n0=from->n0;\\r\\nreturn(to);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_skey_c", "target": 0, "func": "void CAST_set_key(CAST_KEY *key, int len, unsigned char *data)\\r\\n{\\r\\nCAST_LONG x[16];\\r\\nCAST_LONG z[16];\\r\\nCAST_LONG k[32];\\r\\nCAST_LONG X[4],Z[4];\\r\\nCAST_LONG l,*K;\\r\\nint i;\\r\\nfor (i=0; i<16; i++) x[i]=0;\\r\\nif (len > 16) len=16;\\r\\nfor (i=0; i<len; i++)\\r\\nx[i]=data[i];\\r\\nif(len <= 10)\\r\\nkey->short_key=1;\\r\\nelse\\r\\nkey->short_key=0;\\r\\nK= &k[0];\\r\\nX[0]=((x[ 0]<<24)|(x[ 1]<<16)|(x[ 2]<<8)|x[ 3])&0xffffffffL;\\r\\nX[1]=((x[ 4]<<24)|(x[ 5]<<16)|(x[ 6]<<8)|x[ 7])&0xffffffffL;\\r\\nX[2]=((x[ 8]<<24)|(x[ 9]<<16)|(x[10]<<8)|x[11])&0xffffffffL;\\r\\nX[3]=((x[12]<<24)|(x[13]<<16)|(x[14]<<8)|x[15])&0xffffffffL;\\r\\nfor (;;)\\r\\n{\\r\\nl=X[0]^S4[x[13]]^S5[x[15]]^S6[x[12]]^S7[x[14]]^S6[x[ 8]];\\r\\nCAST_exp(l,Z,z, 0);\\r\\nl=X[2]^S4[z[ 0]]^S5[z[ 2]]^S6[z[ 1]]^S7[z[ 3]]^S7[x[10]];\\r\\nCAST_exp(l,Z,z, 4);\\r\\nl=X[3]^S4[z[ 7]]^S5[z[ 6]]^S6[z[ 5]]^S7[z[ 4]]^S4[x[ 9]];\\r\\nCAST_exp(l,Z,z, 8);\\r\\nl=X[1]^S4[z[10]]^S5[z[ 9]]^S6[z[11]]^S7[z[ 8]]^S5[x[11]];\\r\\nCAST_exp(l,Z,z,12);\\r\\nK[ 0]= S4[z[ 8]]^S5[z[ 9]]^S6[z[ 7]]^S7[z[ 6]]^S4[z[ 2]];\\r\\nK[ 1]= S4[z[10]]^S5[z[11]]^S6[z[ 5]]^S7[z[ 4]]^S5[z[ 6]];\\r\\nK[ 2]= S4[z[12]]^S5[z[13]]^S6[z[ 3]]^S7[z[ 2]]^S6[z[ 9]];\\r\\nK[ 3]= S4[z[14]]^S5[z[15]]^S6[z[ 1]]^S7[z[ 0]]^S7[z[12]];\\r\\nl=Z[2]^S4[z[ 5]]^S5[z[ 7]]^S6[z[ 4]]^S7[z[ 6]]^S6[z[ 0]];\\r\\nCAST_exp(l,X,x, 0);\\r\\nl=Z[0]^S4[x[ 0]]^S5[x[ 2]]^S6[x[ 1]]^S7[x[ 3]]^S7[z[ 2]];\\r\\nCAST_exp(l,X,x, 4);\\r\\nl=Z[1]^S4[x[ 7]]^S5[x[ 6]]^S6[x[ 5]]^S7[x[ 4]]^S4[z[ 1]];\\r\\nCAST_exp(l,X,x, 8);\\r\\nl=Z[3]^S4[x[10]]^S5[x[ 9]]^S6[x[11]]^S7[x[ 8]]^S5[z[ 3]];\\r\\nCAST_exp(l,X,x,12);\\r\\nK[ 4]= S4[x[ 3]]^S5[x[ 2]]^S6[x[12]]^S7[x[13]]^S4[x[ 8]];\\r\\nK[ 5]= S4[x[ 1]]^S5[x[ 0]]^S6[x[14]]^S7[x[15]]^S5[x[13]];\\r\\nK[ 6]= S4[x[ 7]]^S5[x[ 6]]^S6[x[ 8]]^S7[x[ 9]]^S6[x[ 3]];\\r\\nK[ 7]= S4[x[ 5]]^S5[x[ 4]]^S6[x[10]]^S7[x[11]]^S7[x[ 7]];\\r\\nl=X[0]^S4[x[13]]^S5[x[15]]^S6[x[12]]^S7[x[14]]^S6[x[ 8]];\\r\\nCAST_exp(l,Z,z, 0);\\r\\nl=X[2]^S4[z[ 0]]^S5[z[ 2]]^S6[z[ 1]]^S7[z[ 3]]^S7[x[10]];\\r\\nCAST_exp(l,Z,z, 4);\\r\\nl=X[3]^S4[z[ 7]]^S5[z[ 6]]^S6[z[ 5]]^S7[z[ 4]]^S4[x[ 9]];\\r\\nCAST_exp(l,Z,z, 8);\\r\\nl=X[1]^S4[z[10]]^S5[z[ 9]]^S6[z[11]]^S7[z[ 8]]^S5[x[11]];\\r\\nCAST_exp(l,Z,z,12);\\r\\nK[ 8]= S4[z[ 3]]^S5[z[ 2]]^S6[z[12]]^S7[z[13]]^S4[z[ 9]];\\r\\nK[ 9]= S4[z[ 1]]^S5[z[ 0]]^S6[z[14]]^S7[z[15]]^S5[z[12]];\\r\\nK[10]= S4[z[ 7]]^S5[z[ 6]]^S6[z[ 8]]^S7[z[ 9]]^S6[z[ 2]];\\r\\nK[11]= S4[z[ 5]]^S5[z[ 4]]^S6[z[10]]^S7[z[11]]^S7[z[ 6]];\\r\\nl=Z[2]^S4[z[ 5]]^S5[z[ 7]]^S6[z[ 4]]^S7[z[ 6]]^S6[z[ 0]];\\r\\nCAST_exp(l,X,x, 0);\\r\\nl=Z[0]^S4[x[ 0]]^S5[x[ 2]]^S6[x[ 1]]^S7[x[ 3]]^S7[z[ 2]];\\r\\nCAST_exp(l,X,x, 4);\\r\\nl=Z[1]^S4[x[ 7]]^S5[x[ 6]]^S6[x[ 5]]^S7[x[ 4]]^S4[z[ 1]];\\r\\nCAST_exp(l,X,x, 8);\\r\\nl=Z[3]^S4[x[10]]^S5[x[ 9]]^S6[x[11]]^S7[x[ 8]]^S5[z[ 3]];\\r\\nCAST_exp(l,X,x,12);\\r\\nK[12]= S4[x[ 8]]^S5[x[ 9]]^S6[x[ 7]]^S7[x[ 6]]^S4[x[ 3]];\\r\\nK[13]= S4[x[10]]^S5[x[11]]^S6[x[ 5]]^S7[x[ 4]]^S5[x[ 7]];\\r\\nK[14]= S4[x[12]]^S5[x[13]]^S6[x[ 3]]^S7[x[ 2]]^S6[x[ 8]];\\r\\nK[15]= S4[x[14]]^S5[x[15]]^S6[x[ 1]]^S7[x[ 0]]^S7[x[13]];\\r\\nif (K != k) break;\\r\\nK+=16;\\r\\n}\\r\\nfor (i=0; i<16; i++)\\r\\n{\\r\\nkey->data[i*2]=k[i];\\r\\nkey->data[i*2+1]=((k[i+16])+16)&0x1f;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_enc_c", "target": 1, "func": "void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(ctx,0,sizeof(EVP_CIPHER_CTX));\\r\\n}\\r\\nvoid EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *data,\\r\\nunsigned char *key, unsigned char *iv, int enc)\\r\\n{\\r\\nif (enc)\\r\\nEVP_EncryptInit(ctx,data,key,iv);\\r\\nelse\\r\\nEVP_DecryptInit(ctx,data,key,iv);\\r\\n}\\r\\nvoid EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nEVP_EncryptUpdate(ctx,out,outl,in,inl);\\r\\nelse EVP_DecryptUpdate(ctx,out,outl,in,inl);\\r\\n}\\r\\nint EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\n{\\r\\nEVP_EncryptFinal(ctx,out,outl);\\r\\nreturn(1);\\r\\n}\\r\\nelse return(EVP_DecryptFinal(ctx,out,outl));\\r\\n}\\r\\nvoid EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nunsigned char *key, unsigned char *iv)\\r\\n{\\r\\nif (cipher != NULL)\\r\\nctx->cipher=cipher;\\r\\nctx->cipher->init(ctx,key,iv,1);\\r\\nctx->encrypt=1;\\r\\nctx->buf_len=0;\\r\\n}\\r\\nvoid EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nunsigned char *key, unsigned char *iv)\\r\\n{\\r\\nif (cipher != NULL)\\r\\nctx->cipher=cipher;\\r\\nctx->cipher->init(ctx,key,iv,0);\\r\\nctx->encrypt=0;\\r\\nctx->buf_len=0;\\r\\n}\\r\\nvoid EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nint i,j,bl;\\r\\ni=ctx->buf_len;\\r\\nbl=ctx->cipher->block_size;\\r\\n*outl=0;\\r\\nif ((inl == 0) && (i != bl)) return;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i+inl < bl)\\r\\n{\\r\\nmemcpy(&(ctx->buf[i]),in,inl);\\r\\nctx->buf_len+=inl;\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=bl-i;\\r\\nif (j != 0) memcpy(&(ctx->buf[i]),in,j);\\r\\nctx->cipher->do_cipher(ctx,out,ctx->buf,bl);\\r\\ninl-=j;\\r\\nin+=j;\\r\\nout+=bl;\\r\\n*outl+=bl;\\r\\n}\\r\\n}\\r\\ni=inl%bl;\\r\\ninl-=i;\\r\\nif (inl > 0)\\r\\n{\\r\\nctx->cipher->do_cipher(ctx,out,in,inl);\\r\\n*outl+=inl;\\r\\n}\\r\\nif (i != 0)\\r\\nmemcpy(ctx->buf,&(in[inl]),i);\\r\\nctx->buf_len=i;\\r\\n}\\r\\nvoid EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i,n,b,bl;\\r\\nb=ctx->cipher->block_size;\\r\\nif (b == 1)\\r\\n{\\r\\n*outl=0;\\r\\nreturn;\\r\\n}\\r\\nbl=ctx->buf_len;\\r\\nn=b-bl;\\r\\nfor (i=bl; i<b; i++)\\r\\nctx->buf[i]=n;\\r\\nctx->cipher->do_cipher(ctx,out,ctx->buf,b);\\r\\n*outl=b;\\r\\n}\\r\\nvoid EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nint b,bl,n;\\r\\nint keep_last=0;\\r\\n*outl=0;\\r\\nif (inl == 0) return;\\r\\nb=ctx->cipher->block_size;\\r\\nif (b > 1)\\r\\n{\\r\\nbl=ctx->buf_len;\\r\\nn=inl+bl;\\r\\nif (n%b == 0)\\r\\n{\\r\\nif (inl < b)\\r\\n{\\r\\nmemcpy(&(ctx->buf[bl]),in,inl);\\r\\nctx->buf_len=b;\\r\\n*outl=0;\\r\\nreturn;\\r\\n}\\r\\nkeep_last=1;\\r\\ninl-=b;\\r\\n}\\r\\n}\\r\\nEVP_EncryptUpdate(ctx,out,outl,in,inl);\\r\\nif (keep_last)\\r\\n{\\r\\nmemcpy(&(ctx->buf[0]),&(in[inl]),b);\\r\\n#ifdef DEBUG\\r\\nif (ctx->buf_len != 0)\\r\\n{\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nctx->buf_len=b;\\r\\n}\\r\\n}\\r\\nint EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i,b;\\r\\nint n;\\r\\n*outl=0;\\r\\nb=ctx->cipher->block_size;\\r\\nif (b > 1)\\r\\n{\\r\\nif (ctx->buf_len != b)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_WRONG_FINAL_BLOCK_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\nEVP_EncryptUpdate(ctx,ctx->buf,&n,ctx->buf,0);\\r\\nif (n != b)\\r\\nreturn(0);\\r\\nn=ctx->buf[b-1];\\r\\nif (n > b)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif (ctx->buf[--b] != n)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL,EVP_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nn=ctx->cipher->block_size-n;\\r\\nfor (i=0; i<n; i++)\\r\\nout[i]=ctx->buf[i];\\r\\n*outl=n;\\r\\n}\\r\\nelse\\r\\n*outl=0;\\r\\nreturn(1);\\r\\n}\\r\\nvoid EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)\\r\\n{\\r\\nif ((c->cipher != NULL) && (c->cipher->cleanup != NULL))\\r\\nc->cipher->cleanup(c);\\r\\nmemset(c,0,sizeof(EVP_CIPHER_CTX));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s23_pkt_c", "target": 0, "func": "int ssl23_write_bytes(SSL *s)\\r\\n{\\r\\nint i,num,tot;\\r\\nchar *buf;\\r\\nbuf=s->init_buf->data;\\r\\ntot=s->init_off;\\r\\nnum=s->init_num;\\r\\nfor (;;)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,&(buf[tot]),num);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->init_off=tot;\\r\\ns->init_num=num;\\r\\nreturn(i);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (i == num) return(tot+i);\\r\\nnum-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nint ssl23_read_bytes(SSL *s, int n)\\r\\n{\\r\\nunsigned char *p;\\r\\nint j;\\r\\nif (s->packet_length < (unsigned int)n)\\r\\n{\\r\\np=s->packet;\\r\\nfor (;;)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\nj=BIO_read(s->rbio,(char *)&(p[s->packet_length]),\\r\\nn-s->packet_length);\\r\\nif (j <= 0)\\r\\nreturn(j);\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->packet_length+=j;\\r\\nif (s->packet_length >= (unsigned int)n)\\r\\nreturn(s->packet_length);\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_err_all_c", "target": 0, "func": "void ERR_load_crypto_strings(void)\\r\\n{\\r\\nstatic int done=0;\\r\\nif (done) return;\\r\\ndone=1;\\r\\n#ifndef NO_ERR\\r\\nERR_load_ASN1_strings();\\r\\nERR_load_BN_strings();\\r\\nERR_load_BUF_strings();\\r\\nERR_load_BIO_strings();\\r\\nERR_load_CONF_strings();\\r\\n#ifndef NO_RSA\\r\\n#ifdef RSAref\\r\\nERR_load_RSAREF_strings();\\r\\n#else\\r\\nERR_load_RSA_strings();\\r\\n#endif\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nERR_load_DH_strings();\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nERR_load_DSA_strings();\\r\\n#endif\\r\\nERR_load_ERR_strings();\\r\\nERR_load_EVP_strings();\\r\\nERR_load_OBJ_strings();\\r\\nERR_load_PEM_strings();\\r\\nERR_load_X509_strings();\\r\\nERR_load_X509V3_strings();\\r\\nERR_load_CRYPTO_strings();\\r\\nERR_load_PKCS7_strings();\\r\\nERR_load_PKCS12_strings();\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rpc_enc_c", "target": 0, "func": "int _des_crypt(char *buf, int len, struct desparams *desp)\\r\\n{\\r\\ndes_key_schedule ks;\\r\\nint enc;\\r\\ndes_set_key(&desp->des_key,ks);\\r\\nenc=(desp->des_dir == ENCRYPT)?DES_ENCRYPT:DES_DECRYPT;\\r\\nif (desp->des_mode == CBC)\\r\\ndes_ecb_encrypt((const_des_cblock *)desp->UDES.UDES_buf,\\r\\n(des_cblock *)desp->UDES.UDES_buf,ks,\\r\\nenc);\\r\\nelse\\r\\n{\\r\\ndes_ncbc_encrypt(desp->UDES.UDES_buf,desp->UDES.UDES_buf,\\r\\nlen,ks,&desp->des_ivec,enc);\\r\\n#ifdef undef\\r\\na=(char *)&(desp->UDES.UDES_buf[len-8]);\\r\\nb=(char *)&(desp->des_ivec[0]);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n*(a++)= *(b++); *(a++)= *(b++);\\r\\n#endif\\r\\n}\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_prime_c", "target": 0, "func": "BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int strong, BIGNUM *add,\\r\\nBIGNUM *rem, void (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nBIGNUM *rnd=NULL;\\r\\nBIGNUM t;\\r\\nint i,j,c1=0;\\r\\nBN_CTX *ctx;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nif (ret == NULL)\\r\\n{\\r\\nif ((rnd=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nrnd=ret;\\r\\nBN_init(&t);\\r\\nloop:\\r\\nif (add == NULL)\\r\\n{\\r\\nif (!probable_prime(rnd,bits)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (strong)\\r\\n{\\r\\nif (!probable_prime_dh_strong(rnd,bits,add,rem,ctx))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!probable_prime_dh(rnd,bits,add,rem,ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (callback != NULL) callback(0,c1++,cb_arg);\\r\\nif (!strong)\\r\\n{\\r\\ni=BN_is_prime(rnd,BN_prime_checks,callback,ctx,cb_arg);\\r\\nif (i == -1) goto err;\\r\\nif (i == 0) goto loop;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(&t,rnd)) goto err;\\r\\nfor (i=0; i<BN_prime_checks; i++)\\r\\n{\\r\\nj=BN_is_prime(rnd,1,callback,ctx,cb_arg);\\r\\nif (j == -1) goto err;\\r\\nif (j == 0) goto loop;\\r\\nj=BN_is_prime(&t,1,callback,ctx,cb_arg);\\r\\nif (j == -1) goto err;\\r\\nif (j == 0) goto loop;\\r\\nif (callback != NULL) callback(2,c1-1,cb_arg);\\r\\n}\\r\\n}\\r\\nret=rnd;\\r\\nerr:\\r\\nif ((ret == NULL) && (rnd != NULL)) BN_free(rnd);\\r\\nBN_free(&t);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_is_prime(BIGNUM *a, int checks, void (*callback)(int,int,void *),\\r\\nBN_CTX *ctx_passed, void *cb_arg)\\r\\n{\\r\\nint i,j,c2=0,ret= -1;\\r\\nBIGNUM *check;\\r\\nBN_CTX *ctx=NULL,*ctx2=NULL;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nif (!BN_is_odd(a))\\r\\nreturn(0);\\r\\nif (ctx_passed != NULL)\\r\\nctx=ctx_passed;\\r\\nelse\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif ((ctx2=BN_CTX_new()) == NULL) goto err;\\r\\nif ((mont=BN_MONT_CTX_new()) == NULL) goto err;\\r\\ncheck= &(ctx->bn[ctx->tos++]);\\r\\nif (!BN_MONT_CTX_set(mont,a,ctx2)) goto err;\\r\\nfor (i=0; i<checks; i++)\\r\\n{\\r\\nif (!BN_rand(check,BN_num_bits(a)-1,0,0)) goto err;\\r\\nj=witness(check,a,ctx,ctx2,mont);\\r\\nif (j == -1) goto err;\\r\\nif (j)\\r\\n{\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nif (callback != NULL) callback(1,c2++,cb_arg);\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nif ((ctx_passed == NULL) && (ctx != NULL))\\r\\nBN_CTX_free(ctx);\\r\\nif (ctx2 != NULL)\\r\\nBN_CTX_free(ctx2);\\r\\nif (mont != NULL) BN_MONT_CTX_free(mont);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int witness(BIGNUM *a, BIGNUM *n, BN_CTX *ctx, BN_CTX *ctx2,\\r\\nBN_MONT_CTX *mont)\\r\\n{\\r\\nint k,i,ret= -1,good;\\r\\nBIGNUM *d,*dd,*tmp,*d1,*d2,*n1;\\r\\nBIGNUM *mont_one,*mont_n1,*mont_a;\\r\\nd1= &(ctx->bn[ctx->tos]);\\r\\nd2= &(ctx->bn[ctx->tos+1]);\\r\\nn1= &(ctx->bn[ctx->tos+2]);\\r\\nctx->tos+=3;\\r\\nmont_one= &(ctx2->bn[ctx2->tos]);\\r\\nmont_n1= &(ctx2->bn[ctx2->tos+1]);\\r\\nmont_a= &(ctx2->bn[ctx2->tos+2]);\\r\\nctx2->tos+=3;\\r\\nd=d1;\\r\\ndd=d2;\\r\\nif (!BN_one(d)) goto err;\\r\\nif (!BN_sub(n1,n,d)) goto err;\\r\\nk=BN_num_bits(n1);\\r\\nif (!BN_to_montgomery(mont_one,BN_value_one(),mont,ctx2)) goto err;\\r\\nif (!BN_to_montgomery(mont_n1,n1,mont,ctx2)) goto err;\\r\\nif (!BN_to_montgomery(mont_a,a,mont,ctx2)) goto err;\\r\\nBN_copy(d,mont_one);\\r\\nfor (i=k-1; i>=0; i--)\\r\\n{\\r\\nif ( (BN_cmp(d,mont_one) != 0) &&\\r\\n(BN_cmp(d,mont_n1) != 0))\\r\\ngood=1;\\r\\nelse\\r\\ngood=0;\\r\\nBN_mod_mul_montgomery(dd,d,d,mont,ctx2);\\r\\nif (good && (BN_cmp(dd,mont_one) == 0))\\r\\n{\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_bit_set(n1,i))\\r\\n{\\r\\nBN_mod_mul_montgomery(d,dd,mont_a,mont,ctx2);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntmp=d;\\r\\nd=dd;\\r\\ndd=tmp;\\r\\n}\\r\\n}\\r\\nif (BN_cmp(d,mont_one) == 0)\\r\\ni=0;\\r\\nelse i=1;\\r\\nret=i;\\r\\nerr:\\r\\nctx->tos-=3;\\r\\nctx2->tos-=3;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int probable_prime(BIGNUM *rnd, int bits)\\r\\n{\\r\\nint i;\\r\\nMS_STATIC BN_ULONG mods[NUMPRIMES];\\r\\nBN_ULONG delta,d;\\r\\nagain:\\r\\nif (!BN_rand(rnd,bits,1,1)) return(0);\\r\\nfor (i=1; i<NUMPRIMES; i++)\\r\\nmods[i]=BN_mod_word(rnd,(BN_ULONG)primes[i]);\\r\\ndelta=0;\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif (((mods[i]+delta)%primes[i]) <= 1)\\r\\n{\\r\\nd=delta;\\r\\ndelta+=2;\\r\\nif (delta < d) goto again;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nif (!BN_add_word(rnd,delta)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int probable_prime_dh(BIGNUM *rnd, int bits, BIGNUM *add, BIGNUM *rem,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i,ret=0;\\r\\nBIGNUM *t1;\\r\\nt1= &(ctx->bn[ctx->tos++]);\\r\\nif (!BN_rand(rnd,bits,0,1)) goto err;\\r\\nif (!BN_mod(t1,rnd,add,ctx)) goto err;\\r\\nif (!BN_sub(rnd,rnd,t1)) goto err;\\r\\nif (rem == NULL)\\r\\n{ if (!BN_add_word(rnd,1)) goto err; }\\r\\nelse\\r\\n{ if (!BN_add(rnd,rnd,rem)) goto err; }\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif (BN_mod_word(rnd,(BN_ULONG)primes[i]) <= 1)\\r\\n{\\r\\nif (!BN_add(rnd,rnd,add)) goto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int probable_prime_dh_strong(BIGNUM *p, int bits, BIGNUM *padd,\\r\\nBIGNUM *rem, BN_CTX *ctx)\\r\\n{\\r\\nint i,ret=0;\\r\\nBIGNUM *t1,*qadd=NULL,*q=NULL;\\r\\nbits--;\\r\\nt1= &(ctx->bn[ctx->tos++]);\\r\\nq= &(ctx->bn[ctx->tos++]);\\r\\nqadd= &(ctx->bn[ctx->tos++]);\\r\\nif (!BN_rshift1(qadd,padd)) goto err;\\r\\nif (!BN_rand(q,bits,0,1)) goto err;\\r\\nif (!BN_mod(t1,q,qadd,ctx)) goto err;\\r\\nif (!BN_sub(q,q,t1)) goto err;\\r\\nif (rem == NULL)\\r\\n{ if (!BN_add_word(q,1)) goto err; }\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(t1,rem)) goto err;\\r\\nif (!BN_add(q,q,t1)) goto err;\\r\\n}\\r\\nif (!BN_lshift1(p,q)) goto err;\\r\\nif (!BN_add_word(p,1)) goto err;\\r\\nloop: for (i=1; i<NUMPRIMES; i++)\\r\\n{\\r\\nif ( (BN_mod_word(p,(BN_ULONG)primes[i]) == 0) ||\\r\\n(BN_mod_word(q,(BN_ULONG)primes[i]) == 0))\\r\\n{\\r\\nif (!BN_add(p,p,padd)) goto err;\\r\\nif (!BN_add(q,q,qadd)) goto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos-=3;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_stack_c", "target": 0, "func": "char *sk_delete_ptr(STACK *st, char *p)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] == p)\\r\\nreturn(sk_delete(st,i));\\r\\nreturn(NULL);\\r\\n}\\r\\nchar *sk_delete(STACK *st, int loc)\\r\\n{\\r\\nchar *ret;\\r\\nint i,j;\\r\\nif ((st == NULL) || (st->num == 0) || (loc < 0)\\r\\n|| (loc >= st->num)) return(NULL);\\r\\nret=st->data[loc];\\r\\nif (loc != st->num-1)\\r\\n{\\r\\nj=st->num-1;\\r\\nfor (i=loc; i<j; i++)\\r\\nst->data[i]=st->data[i+1];\\r\\n}\\r\\nst->num--;\\r\\nreturn(ret);\\r\\n}\\r\\nint sk_find(STACK *st, char *data)\\r\\n{\\r\\nchar **r;\\r\\nint i;\\r\\nint (*comp_func)();\\r\\nif(st == NULL) return -1;\\r\\nif (st->comp == NULL)\\r\\n{\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] == data)\\r\\nreturn(i);\\r\\nreturn(-1);\\r\\n}\\r\\nsk_sort(st);\\r\\nif (data == NULL) return(-1);\\r\\ncomp_func=(int (*)())st->comp;\\r\\nr=(char **)bsearch(&data,(char *)st->data,\\r\\nst->num,sizeof(char *),FP_ICC comp_func);\\r\\nif (r == NULL) return(-1);\\r\\ni=(int)(r-st->data);\\r\\nfor ( ; i>0; i--)\\r\\nif ((*st->comp)(&(st->data[i-1]),&data) < 0)\\r\\nbreak;\\r\\nreturn(i);\\r\\n}\\r\\nint sk_push(STACK *st, char *data)\\r\\n{\\r\\nreturn(sk_insert(st,data,st->num));\\r\\n}\\r\\nint sk_unshift(STACK *st, char *data)\\r\\n{\\r\\nreturn(sk_insert(st,data,0));\\r\\n}\\r\\nchar *sk_shift(STACK *st)\\r\\n{\\r\\nif (st == NULL) return(NULL);\\r\\nif (st->num <= 0) return(NULL);\\r\\nreturn(sk_delete(st,0));\\r\\n}\\r\\nchar *sk_pop(STACK *st)\\r\\n{\\r\\nif (st == NULL) return(NULL);\\r\\nif (st->num <= 0) return(NULL);\\r\\nreturn(sk_delete(st,st->num-1));\\r\\n}\\r\\nvoid sk_zero(STACK *st)\\r\\n{\\r\\nif (st == NULL) return;\\r\\nif (st->num <= 0) return;\\r\\nmemset((char *)st->data,0,sizeof(st->data)*st->num);\\r\\nst->num=0;\\r\\n}\\r\\nvoid sk_pop_free(STACK *st, void (*func)())\\r\\n{\\r\\nint i;\\r\\nif (st == NULL) return;\\r\\nfor (i=0; i<st->num; i++)\\r\\nif (st->data[i] != NULL)\\r\\nfunc(st->data[i]);\\r\\nsk_free(st);\\r\\n}\\r\\nvoid sk_free(STACK *st)\\r\\n{\\r\\nif (st == NULL) return;\\r\\nif (st->data != NULL) Free((char *)st->data);\\r\\nFree((char *)st);\\r\\n}\\r\\nint sk_num(STACK *st)\\r\\n{\\r\\nif(st == NULL) return -1;\\r\\nreturn st->num;\\r\\n}\\r\\nchar *sk_value(STACK *st, int i)\\r\\n{\\r\\nif(st == NULL) return NULL;\\r\\nreturn st->data[i];\\r\\n}\\r\\nchar *sk_set(STACK *st, int i, char *value)\\r\\n{\\r\\nif(st == NULL) return NULL;\\r\\nreturn (st->data[i] = value);\\r\\n}\\r\\nvoid sk_sort(STACK *st)\\r\\n{\\r\\nif (!st->sorted)\\r\\n{\\r\\nint (*comp_func)();\\r\\ncomp_func=(int (*)())st->comp;\\r\\nqsort(st->data,st->num,sizeof(char *),FP_ICC comp_func);\\r\\nst->sorted=1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_example1_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nERR_load_crypto_strings();\\r\\nif ((argc == 1))\\r\\n{\\r\\nmain_encrypt();\\r\\n}\\r\\nelse if ((argc == 2) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\nmain_decrypt();\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"%s\",usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid main_encrypt(void)\\r\\n{\\r\\nunsigned int ebuflen;\\r\\nEVP_CIPHER_CTX ectx;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *ekey[1];\\r\\nint readlen;\\r\\nint ekeylen, net_ekeylen;\\r\\nEVP_PKEY *pubKey[1];\\r\\nchar buf[512];\\r\\nchar ebuf[512];\\r\\nmemset(iv, '\\0', sizeof(iv));\\r\\npubKey[0] = ReadPublicKey(PUBFILE);\\r\\nif(!pubKey)\\r\\n{\\r\\nfprintf(stderr,\"Error: can't load public key\");\\r\\nexit(1);\\r\\n}\\r\\nekey[0] = malloc(EVP_PKEY_size(pubKey[0]));\\r\\nif (!ekey[0])\\r\\n{\\r\\nEVP_PKEY_free(pubKey[0]);\\r\\nperror(\"malloc\");\\r\\nexit(1);\\r\\n}\\r\\nEVP_SealInit(&ectx,\\r\\nEVP_des_ede3_cbc(),\\r\\nekey,\\r\\n&ekeylen,\\r\\niv,\\r\\npubKey,\\r\\n1);\\r\\nnet_ekeylen = htonl(ekeylen);\\r\\nwrite(STDOUT, (char*)&net_ekeylen, sizeof(net_ekeylen));\\r\\nwrite(STDOUT, ekey[0], ekeylen);\\r\\nwrite(STDOUT, iv, sizeof(iv));\\r\\nwhile(1)\\r\\n{\\r\\nreadlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (readlen < 0)\\r\\nperror(\"read\");\\r\\nbreak;\\r\\n}\\r\\nEVP_SealUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_SealFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\nEVP_PKEY_free(pubKey[0]);\\r\\nfree(ekey[0]);\\r\\n}\\r\\nvoid main_decrypt(void)\\r\\n{\\r\\nchar buf[512];\\r\\nchar ebuf[512];\\r\\nunsigned int buflen;\\r\\nEVP_CIPHER_CTX ectx;\\r\\nunsigned char iv[8];\\r\\nunsigned char *encryptKey;\\r\\nunsigned int ekeylen;\\r\\nEVP_PKEY *privateKey;\\r\\nmemset(iv, '\\0', sizeof(iv));\\r\\nprivateKey = ReadPrivateKey(PRIVFILE);\\r\\nif (!privateKey)\\r\\n{\\r\\nfprintf(stderr, \"Error: can't load private key\");\\r\\nexit(1);\\r\\n}\\r\\nread(STDIN, &ekeylen, sizeof(ekeylen));\\r\\nekeylen = ntohl(ekeylen);\\r\\nif (ekeylen != EVP_PKEY_size(privateKey))\\r\\n{\\r\\nEVP_PKEY_free(privateKey);\\r\\nfprintf(stderr, \"keylength mismatch\");\\r\\nexit(1);\\r\\n}\\r\\nencryptKey = malloc(sizeof(char) * ekeylen);\\r\\nif (!encryptKey)\\r\\n{\\r\\nEVP_PKEY_free(privateKey);\\r\\nperror(\"malloc\");\\r\\nexit(1);\\r\\n}\\r\\nread(STDIN, encryptKey, ekeylen);\\r\\nread(STDIN, iv, sizeof(iv));\\r\\nEVP_OpenInit(&ectx,\\r\\nEVP_des_ede3_cbc(),\\r\\nencryptKey,\\r\\nekeylen,\\r\\niv,\\r\\nprivateKey);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, ebuf, sizeof(ebuf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (readlen < 0)\\r\\nperror(\"read\");\\r\\nbreak;\\r\\n}\\r\\nEVP_OpenUpdate(&ectx, buf, &buflen, ebuf, readlen);\\r\\nwrite(STDOUT, buf, buflen);\\r\\n}\\r\\nEVP_OpenFinal(&ectx, buf, &buflen);\\r\\nwrite(STDOUT, buf, buflen);\\r\\nEVP_PKEY_free(privateKey);\\r\\nfree(encryptKey);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_recip_c", "target": 0, "func": "int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->issuer_and_serial,i2d_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_I2D_len(a->key_enc_algor,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->enc_key,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->issuer_and_serial,i2d_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_I2D_put(a->key_enc_algor,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->enc_key,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_RECIP_INFO *d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_RECIP_INFO *,PKCS7_RECIP_INFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->issuer_and_serial,d2i_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_D2I_get(ret->key_enc_algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->enc_key,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_RECIP_INFO_free,ASN1_F_D2I_PKCS7_RECIP_INFO);\\r\\n}\\r\\nPKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void)\\r\\n{\\r\\nPKCS7_RECIP_INFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_RECIP_INFO);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->issuer_and_serial,PKCS7_ISSUER_AND_SERIAL_new);\\r\\nM_ASN1_New(ret->key_enc_algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->enc_key,ASN1_OCTET_STRING_new);\\r\\nret->cert=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_RECIP_INFO_NEW);\\r\\n}\\r\\nvoid PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nPKCS7_ISSUER_AND_SERIAL_free(a->issuer_and_serial);\\r\\nX509_ALGOR_free(a->key_enc_algor);\\r\\nASN1_OCTET_STRING_free(a->enc_key);\\r\\nif (a->cert != NULL) X509_free(a->cert);\\r\\nFree(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ecb(void)\\r\\n{\\r\\nreturn(&d_ecb_cipher);\\r\\n}\\r\\nstatic void des_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (deskey != NULL)\\r\\ndes_set_key(deskey,ctx->c.des_ks);\\r\\n}\\r\\nstatic void des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\ndes_cblock *output ;\\r\\ndes_cblock *input ;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\noutput = (des_cblock *)(out + i);\\r\\ninput = (des_cblock *)(in + i);\\r\\ndes_ecb_encrypt(input,output,ctx->c.des_ks,ctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_mem_c", "target": 1, "func": "int CRYPTO_mem_ctrl(int mode)\\r\\n{\\r\\nint ret=mh_mode;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nswitch (mode)\\r\\n{\\r\\ncase CRYPTO_MEM_CHECK_ON:\\r\\nmh_mode = CRYPTO_MEM_CHECK_ON|CRYPTO_MEM_CHECK_ENABLE;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_OFF:\\r\\nmh_mode = 0;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_DISABLE:\\r\\nmh_mode&= ~CRYPTO_MEM_CHECK_ENABLE;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_ENABLE:\\r\\nif (mh_mode&CRYPTO_MEM_CHECK_ON)\\r\\nmh_mode|=CRYPTO_MEM_CHECK_ENABLE;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_cmp(MEM *a, MEM *b)\\r\\n{\\r\\nreturn(a->addr - b->addr);\\r\\n}\\r\\nstatic unsigned long mem_hash(MEM *a)\\r\\n{\\r\\nunsigned long ret;\\r\\nret=(unsigned long)a->addr;\\r\\nret=ret*17851+(ret>>14)*7+(ret>>4)*251;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_set_mem_functions(char *(*m)(), char *(*r)(), void (*f)())\\r\\n{\\r\\nif ((m == NULL) || (r == NULL) || (f == NULL)) return;\\r\\nmalloc_func=m;\\r\\nrealloc_func=r;\\r\\nfree_func=f;\\r\\nmalloc_locked_func=m;\\r\\nfree_locked_func=f;\\r\\n}\\r\\nvoid CRYPTO_set_locked_mem_functions(char *(*m)(), void (*f)())\\r\\n{\\r\\nif ((m == NULL) || (f == NULL)) return;\\r\\nmalloc_locked_func=m;\\r\\nfree_locked_func=f;\\r\\n}\\r\\nvoid CRYPTO_get_mem_functions(char *(**m)(), char *(**r)(), void (**f)())\\r\\n{\\r\\nif (m != NULL) *m=malloc_func;\\r\\nif (r != NULL) *r=realloc_func;\\r\\nif (f != NULL) *f=free_func;\\r\\n}\\r\\nvoid CRYPTO_get_locked_mem_functions(char *(**m)(), void (**f)())\\r\\n{\\r\\nif (m != NULL) *m=malloc_locked_func;\\r\\nif (f != NULL) *f=free_locked_func;\\r\\n}\\r\\nvoid *CRYPTO_malloc_locked(int num)\\r\\n{\\r\\nreturn(malloc_locked_func(num));\\r\\n}\\r\\nvoid CRYPTO_free_locked(void *str)\\r\\n{\\r\\nfree_locked_func(str);\\r\\n}\\r\\nvoid *CRYPTO_malloc(int num)\\r\\n{\\r\\nreturn(malloc_func(num));\\r\\n}\\r\\nvoid *CRYPTO_realloc(void *str, int num)\\r\\n{\\r\\nreturn(realloc_func(str,num));\\r\\n}\\r\\nvoid CRYPTO_free(void *str)\\r\\n{\\r\\nfree_func(str);\\r\\n}\\r\\nvoid *CRYPTO_dbg_malloc(int num, const char *file, int line)\\r\\n{\\r\\nchar *ret;\\r\\nMEM *m,*mm;\\r\\nif ((ret=malloc_func(num)) == NULL)\\r\\nreturn(NULL);\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ENABLE)\\r\\n{\\r\\nMemCheck_off();\\r\\nif ((m=(MEM *)Malloc(sizeof(MEM))) == NULL)\\r\\n{\\r\\nFree(ret);\\r\\nMemCheck_on();\\r\\nreturn(NULL);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nif (mh == NULL)\\r\\n{\\r\\nif ((mh=lh_new(mem_hash,mem_cmp)) == NULL)\\r\\n{\\r\\nFree(ret);\\r\\nFree(m);\\r\\nret=NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nm->addr=ret;\\r\\nm->file=file;\\r\\nm->line=line;\\r\\nm->num=num;\\r\\n#ifdef CRYPTO_MDEBUG_THREAD\\r\\nm->thread=CRYPTO_thread_id();\\r\\n#endif\\r\\nif (order == break_order_num)\\r\\n{\\r\\nm->order=order;\\r\\n}\\r\\nm->order=order++;\\r\\n#ifdef CRYPTO_MDEBUG_TIME\\r\\nm->time=time(NULL);\\r\\n#endif\\r\\nif ((mm=(MEM *)lh_insert(mh,(char *)m)) != NULL)\\r\\n{\\r\\nFree(mm);\\r\\n}\\r\\nerr:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_dbg_free(void *addr)\\r\\n{\\r\\nMEM m,*mp;\\r\\nif ((mh_mode & CRYPTO_MEM_CHECK_ENABLE) && (mh != NULL))\\r\\n{\\r\\nMemCheck_off();\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nm.addr=addr;\\r\\nmp=(MEM *)lh_delete(mh,(char *)&m);\\r\\nif (mp != NULL)\\r\\nFree(mp);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nMemCheck_on();\\r\\n}\\r\\nfree_func(addr);\\r\\n}\\r\\nvoid *CRYPTO_dbg_realloc(void *addr, int num, const char *file, int line)\\r\\n{\\r\\nchar *ret;\\r\\nMEM m,*mp;\\r\\nret=realloc_func(addr,num);\\r\\nif (ret == addr) return(ret);\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ENABLE)\\r\\n{\\r\\nMemCheck_off();\\r\\nif (ret == NULL) return(NULL);\\r\\nm.addr=addr;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nmp=(MEM *)lh_delete(mh,(char *)&m);\\r\\nif (mp != NULL)\\r\\n{\\r\\nmp->addr=ret;\\r\\nlh_insert(mh,(char *)mp);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid *CRYPTO_remalloc(void *a, int n)\\r\\n{\\r\\nif (a != NULL) Free(a);\\r\\na=(char *)Malloc(n);\\r\\nreturn(a);\\r\\n}\\r\\nvoid *CRYPTO_dbg_remalloc(void *a, int n, const char *file, int line)\\r\\n{\\r\\nif (a != NULL) CRYPTO_dbg_free(a);\\r\\na=(char *)CRYPTO_dbg_malloc(n,file,line);\\r\\nreturn(a);\\r\\n}\\r\\nstatic void print_leak(MEM *m, MEM_LEAK *l)\\r\\n{\\r\\nchar buf[128];\\r\\n#ifdef CRYPTO_MDEBUG_TIME\\r\\nstruct tm *lcl;\\r\\n#endif\\r\\nif(m->addr == (char *)l->bio)\\r\\nreturn;\\r\\n#ifdef CRYPTO_MDEBUG_TIME\\r\\nlcl = localtime(&m->time);\\r\\n#endif\\r\\nsprintf(buf,\\r\\n#ifdef CRYPTO_MDEBUG_TIME\\r\\n\"[%02d:%02d:%02d] \"\\r\\n#endif\\r\\n\"%5lu file=%s, line=%d, \"\\r\\n#ifdef CRYPTO_MDEBUG_THREAD\\r\\n\"thread=%lu, \"\\r\\n#endif\\r\\n\"number=%d, address=%08lX\\n\",\\r\\n#ifdef CRYPTO_MDEBUG_TIME\\r\\nlcl->tm_hour,lcl->tm_min,lcl->tm_sec,\\r\\n#endif\\r\\nm->order,m->file,m->line,\\r\\n#ifdef CRYPTO_MDEBUG_THREAD\\r\\nm->thread,\\r\\n#endif\\r\\nm->num,(unsigned long)m->addr);\\r\\nBIO_puts(l->bio,buf);\\r\\nl->chunks++;\\r\\nl->bytes+=m->num;\\r\\n}\\r\\nvoid CRYPTO_mem_leaks(BIO *b)\\r\\n{\\r\\nMEM_LEAK ml;\\r\\nchar buf[80];\\r\\nif (mh == NULL) return;\\r\\nml.bio=b;\\r\\nml.bytes=0;\\r\\nml.chunks=0;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nlh_doall_arg(mh,(void (*)())print_leak,(char *)&ml);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nif (ml.chunks != 0)\\r\\n{\\r\\nsprintf(buf,\"%ld bytes leaked in %d chunks\\n\",\\r\\nml.bytes,ml.chunks);\\r\\nBIO_puts(b,buf);\\r\\n}\\r\\n#if 0\\r\\nlh_stats_bio(mh,b);\\r\\nlh_node_stats_bio(mh,b);\\r\\nlh_node_usage_stats_bio(mh,b);\\r\\n#endif\\r\\n}\\r\\nstatic void cb_leak(MEM *m, char *cb)\\r\\n{\\r\\nvoid (*mem_callback)()=(void (*)())cb;\\r\\nmem_callback(m->order,m->file,m->line,m->num,m->addr);\\r\\n}\\r\\nvoid CRYPTO_mem_leaks_cb(void (*cb)())\\r\\n{\\r\\nif (mh == NULL) return;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nmem_cb=cb;\\r\\nlh_doall_arg(mh,(void (*)())cb_leak,(char *)mem_cb);\\r\\nmem_cb=NULL;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\n}\\r\\nvoid CRYPTO_mem_leaks_fp(FILE *fp)\\r\\n{\\r\\nBIO *b;\\r\\nif (mh == NULL) return;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\nreturn;\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nCRYPTO_mem_leaks(b);\\r\\nBIO_free(b);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_utctm_c", "target": 0, "func": "int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a, unsigned char **pp)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_UTCTIME,V_ASN1_UNIVERSAL));\\r\\n#else\\r\\nint len;\\r\\nchar tmp[24];\\r\\nASN1_STRING x = *(ASN1_STRING *)a;\\r\\nlen = x.length;\\r\\nebcdic2ascii(tmp, x.data, (len >= sizeof tmp) ? sizeof tmp : len);\\r\\nx.data = tmp;\\r\\nreturn i2d_ASN1_bytes(&x, pp, V_ASN1_UTCTIME,V_ASN1_UNIVERSAL);\\r\\n#endif\\r\\n}\\r\\nASN1_UTCTIME *d2i_ASN1_UTCTIME(ASN1_UTCTIME **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_UTCTIME *ret=NULL;\\r\\nret=(ASN1_UTCTIME *)d2i_ASN1_bytes((ASN1_STRING **)a,pp,length,\\r\\nV_ASN1_UTCTIME,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_UTCTIME,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(ret->data, ret->data, ret->length);\\r\\n#endif\\r\\nif (!ASN1_UTCTIME_check(ret))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_UTCTIME,ASN1_R_INVALID_TIME_FORMAT);\\r\\ngoto err;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_UTCTIME_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_UTCTIME_check(ASN1_UTCTIME *d)\\r\\n{\\r\\nstatic int min[8]={ 0, 1, 1, 0, 0, 0, 0, 0};\\r\\nstatic int max[8]={99,12,31,23,59,59,12,59};\\r\\nchar *a;\\r\\nint n,i,l,o;\\r\\nif (d->type != V_ASN1_UTCTIME) return(0);\\r\\nl=d->length;\\r\\na=(char *)d->data;\\r\\no=0;\\r\\nif (l < 11) goto err;\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nif ((i == 5) && ((a[o] == 'Z') ||\\r\\n(a[o] == '+') || (a[o] == '-')))\\r\\n{ i++; break; }\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-'))\\r\\n{\\r\\no++;\\r\\nif (o+4 > l) goto err;\\r\\nfor (i=6; i<8; i++)\\r\\n{\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\no++;\\r\\n}\\r\\n}\\r\\nreturn(o == l);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, char *str)\\r\\n{\\r\\nASN1_UTCTIME t;\\r\\nt.type=V_ASN1_UTCTIME;\\r\\nt.length=strlen(str);\\r\\nt.data=(unsigned char *)str;\\r\\nif (ASN1_UTCTIME_check(&t))\\r\\n{\\r\\nif (s != NULL)\\r\\n{\\r\\nASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str,t.length);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\nstruct tm data;\\r\\n#endif\\r\\nif (s == NULL)\\r\\ns=ASN1_UTCTIME_new();\\r\\nif (s == NULL)\\r\\nreturn(NULL);\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\ngmtime_r(&t,&data);\\r\\nts=&data;\\r\\n#else\\r\\nts=gmtime(&t);\\r\\n#endif\\r\\n#ifdef VMS\\r\\nif (ts == NULL)\\r\\n{\\r\\nstatic $DESCRIPTOR(tabnam,\"LNM$DCL_LOGICAL\");\\r\\nstatic $DESCRIPTOR(lognam,\"SYS$TIMEZONE_DIFFERENTIAL\");\\r\\nchar result[256];\\r\\nunsigned int reslen = 0;\\r\\nstruct {\\r\\nshort buflen;\\r\\nshort code;\\r\\nvoid *bufaddr;\\r\\nunsigned int *reslen;\\r\\n} itemlist[] = {\\r\\n{ 0, LNM$_STRING, 0, 0 },\\r\\n{ 0, 0, 0, 0 },\\r\\n};\\r\\nint status;\\r\\nitemlist[0].buflen = sizeof(result);\\r\\nitemlist[0].bufaddr = result;\\r\\nitemlist[0].reslen = &reslen;\\r\\nstatus = sys$trnlnm(0, &tabnam, &lognam, 0, itemlist);\\r\\nif (!(status & 1))\\r\\nreturn NULL;\\r\\nresult[reslen] = '\\0';\\r\\nstatus = atoi(result);\\r\\nt -= status;\\r\\nts=(struct tm *)localtime(&t);\\r\\n}\\r\\n#endif\\r\\np=(char *)s->data;\\r\\nif ((p == NULL) || (s->length < 14))\\r\\n{\\r\\np=Malloc(20);\\r\\nif (p == NULL) return(NULL);\\r\\nif (s->data != NULL)\\r\\nFree(s->data);\\r\\ns->data=(unsigned char *)p;\\r\\n}\\r\\nsprintf(p,\"%02d%02d%02d%02d%02d%02dZ\",ts->tm_year%100,\\r\\nts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);\\r\\ns->length=strlen(p);\\r\\ns->type=V_ASN1_UTCTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn(s);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_crl2p7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,badops=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile,*outfile,*prog,*certfile;\\r\\nPKCS7 *p7 = NULL;\\r\\nPKCS7_SIGNED *p7s = NULL;\\r\\nX509_CRL *crl=NULL;\\r\\nSTACK *certflst=NULL;\\r\\nSTACK_OF(X509_CRL) *crl_stack=NULL;\\r\\nSTACK_OF(X509) *cert_stack=NULL;\\r\\nint ret=1,nocrl=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-nocrl\") == 0)\\r\\n{\\r\\nnocrl=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-certfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif(!certflst) certflst = sk_new(NULL);\\r\\nsk_push(certflst,*(++argv));\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -certfile arg certificates file of chain to a trusted CA\\n\");\\r\\nBIO_printf(bio_err,\" (can be used more than once)\\n\");\\r\\nBIO_printf(bio_err,\" -nocrl no crl to load, just certs from '-certfile'\\n\");\\r\\nEXIT(1);\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!nocrl)\\r\\n{\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\ncrl=d2i_X509_CRL_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ncrl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (crl == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((p7=PKCS7_new()) == NULL) goto end;\\r\\nif ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;\\r\\np7->type=OBJ_nid2obj(NID_pkcs7_signed);\\r\\np7->d.sign=p7s;\\r\\np7s->contents->type=OBJ_nid2obj(NID_pkcs7_data);\\r\\nif (!ASN1_INTEGER_set(p7s->version,1)) goto end;\\r\\nif ((crl_stack=sk_X509_CRL_new(NULL)) == NULL) goto end;\\r\\np7s->crl=crl_stack;\\r\\nif (crl != NULL)\\r\\n{\\r\\nsk_X509_CRL_push(crl_stack,crl);\\r\\ncrl=NULL;\\r\\n}\\r\\nif ((cert_stack=sk_X509_new(NULL)) == NULL) goto end;\\r\\np7s->cert=cert_stack;\\r\\nif(certflst) for(i = 0; i < sk_num(certflst); i++) {\\r\\ncertfile = sk_value(certflst, i);\\r\\nif (add_certs_from_file(cert_stack,certfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err, \"error loading certificates\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nsk_free(certflst);\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_PKCS7_bio(out,p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_PKCS7(out,p7);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (p7 != NULL) PKCS7_free(p7);\\r\\nif (crl != NULL) X509_CRL_free(crl);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cpt_err_c", "target": 0, "func": "void ERR_load_CRYPTO_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_CRYPTO,CRYPTO_str_functs);\\r\\nERR_load_strings(ERR_LIB_CRYPTO,CRYPTO_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_info_c", "target": 0, "func": "X509_INFO *X509_INFO_new(void)\\r\\n{\\r\\nX509_INFO *ret=NULL;\\r\\nret=(X509_INFO *)Malloc(sizeof(X509_INFO));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_X509_INFO_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->enc_cipher.cipher=NULL;\\r\\nret->enc_len=0;\\r\\nret->enc_data=NULL;\\r\\nret->references=1;\\r\\nret->x509=NULL;\\r\\nret->crl=NULL;\\r\\nret->x_pkey=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid X509_INFO_free(X509_INFO *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_INFO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_INFO\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_INFO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->x509 != NULL) X509_free(x->x509);\\r\\nif (x->crl != NULL) X509_CRL_free(x->crl);\\r\\nif (x->x_pkey != NULL) X509_PKEY_free(x->x_pkey);\\r\\nFree((char *)x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_bool_c", "target": 0, "func": "int i2d_ASN1_BOOLEAN(int a, unsigned char **pp)\\r\\n{\\r\\nint r;\\r\\nunsigned char *p;\\r\\nr=ASN1_object_size(0,1,V_ASN1_BOOLEAN);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,1,V_ASN1_BOOLEAN,V_ASN1_UNIVERSAL);\\r\\n*(p++)= (unsigned char)a;\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\nint d2i_ASN1_BOOLEAN(int *a, unsigned char **pp, long length)\\r\\n{\\r\\nint ret= -1;\\r\\nunsigned char *p;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_BOOLEAN)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_A_BOOLEAN;\\r\\ngoto err;\\r\\n}\\r\\nif (len != 1)\\r\\n{\\r\\ni=ASN1_R_BOOLEAN_IS_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nret= (int)*(p++);\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_BOOLEAN,i);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_key_c", "target": 1, "func": "int DH_generate_key(DH *dh)\\r\\n{\\r\\nint ok=0;\\r\\nunsigned int i;\\r\\nBN_CTX ctx;\\r\\nBN_MONT_CTX *mont;\\r\\nBIGNUM *pub_key=NULL,*priv_key=NULL;\\r\\nBN_CTX_init(&ctx);\\r\\nif (dh->priv_key == NULL)\\r\\n{\\r\\ni=dh->length;\\r\\nif (i == 0)\\r\\n{\\r\\ni=BN_num_bits(dh->p)-1;\\r\\n}\\r\\npriv_key=BN_new();\\r\\nif (priv_key == NULL) goto err;\\r\\nif (!BN_rand(priv_key,i,0,0)) goto err;\\r\\n}\\r\\nelse\\r\\npriv_key=dh->priv_key;\\r\\nif (dh->pub_key == NULL)\\r\\n{\\r\\npub_key=BN_new();\\r\\nif (pub_key == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npub_key=dh->pub_key;\\r\\nif ((dh->method_mont_p == NULL) && (dh->flags & DH_FLAG_CACHE_MONT_P))\\r\\n{\\r\\nif ((dh->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set((BN_MONT_CTX *)dh->method_mont_p,\\r\\ndh->p,&ctx)) goto err;\\r\\n}\\r\\nmont=(BN_MONT_CTX *)dh->method_mont_p;\\r\\nif (!BN_mod_exp_mont(pub_key,dh->g,priv_key,dh->p,&ctx,mont)) goto err;\\r\\ndh->pub_key=pub_key;\\r\\ndh->priv_key=priv_key;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok != 1)\\r\\nDHerr(DH_F_DH_GENERATE_KEY,ERR_R_BN_LIB);\\r\\nif ((pub_key != NULL) && (dh->pub_key == NULL)) BN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dh->priv_key == NULL)) BN_free(priv_key);\\r\\nBN_CTX_free(&ctx);\\r\\nreturn(ok);\\r\\n}\\r\\nint DH_compute_key(unsigned char *key, BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nBN_CTX ctx;\\r\\nBN_MONT_CTX *mont;\\r\\nBIGNUM *tmp;\\r\\nint ret= -1;\\r\\nBN_CTX_init(&ctx);\\r\\ntmp= &(ctx.bn[ctx.tos++]);\\r\\nif (dh->priv_key == NULL)\\r\\n{\\r\\nDHerr(DH_F_DH_COMPUTE_KEY,DH_R_NO_PRIVATE_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nif ((dh->method_mont_p == NULL) && (dh->flags & DH_FLAG_CACHE_MONT_P))\\r\\n{\\r\\nif ((dh->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set((BN_MONT_CTX *)dh->method_mont_p,\\r\\ndh->p,&ctx)) goto err;\\r\\n}\\r\\nmont=(BN_MONT_CTX *)dh->method_mont_p;\\r\\nif (!BN_mod_exp_mont(tmp,pub_key,dh->priv_key,dh->p,&ctx,mont))\\r\\n{\\r\\nDHerr(DH_F_DH_COMPUTE_KEY,ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret=BN_bn2bin(tmp,key);\\r\\nerr:\\r\\nBN_CTX_free(&ctx);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cbc3_enc_c", "target": 0, "func": "void des_3cbc_encrypt(des_cblock *input, des_cblock *output, long length,\\r\\ndes_key_schedule ks1, des_key_schedule ks2, des_cblock *iv1,\\r\\ndes_cblock *iv2, int enc)\\r\\n{\\r\\nint off=((int)length-1)/8;\\r\\nlong l8=((length+7)/8)*8;\\r\\ndes_cblock niv1,niv2;\\r\\nif (enc == DES_ENCRYPT)\\r\\n{\\r\\ndes_cbc_encrypt(input,output,length,ks1,iv1,enc);\\r\\nif (length >= sizeof(des_cblock))\\r\\nmemcpy(niv1,output[off],sizeof(des_cblock));\\r\\ndes_cbc_encrypt(output,output,l8,ks2,iv1,!enc);\\r\\ndes_cbc_encrypt(output,output,l8,ks1,iv2, enc);\\r\\nif (length >= sizeof(des_cblock))\\r\\nmemcpy(niv2,output[off],sizeof(des_cblock));\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (length >= sizeof(des_cblock))\\r\\nmemcpy(niv2,input[off],sizeof(des_cblock));\\r\\ndes_cbc_encrypt(input,output,l8,ks1,iv2,enc);\\r\\ndes_cbc_encrypt(output,output,l8,ks2,iv1,!enc);\\r\\nif (length >= sizeof(des_cblock))\\r\\nmemcpy(niv1,output[off],sizeof(des_cblock));\\r\\ndes_cbc_encrypt(output,output,length,ks1,iv1, enc);\\r\\n}\\r\\nmemcpy(*iv1,niv1,sizeof(des_cblock));\\r\\nmemcpy(*iv2,niv2,sizeof(des_cblock));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_qud_cksm_c", "target": 0, "func": "DES_LONG des_quad_cksum(const unsigned char *input, des_cblock output[],\\r\\nlong length, int out_count, des_cblock *seed)\\r\\n{\\r\\nDES_LONG z0,z1,t0,t1;\\r\\nint i;\\r\\nlong l;\\r\\nconst unsigned char *cp;\\r\\nunsigned char *lp;\\r\\nif (out_count < 1) out_count=1;\\r\\nlp = &(output[0])[0];\\r\\nz0=Q_B0((*seed)[0])|Q_B1((*seed)[1])|Q_B2((*seed)[2])|Q_B3((*seed)[3]);\\r\\nz1=Q_B0((*seed)[4])|Q_B1((*seed)[5])|Q_B2((*seed)[6])|Q_B3((*seed)[7]);\\r\\nfor (i=0; ((i<4)&&(i<out_count)); i++)\\r\\n{\\r\\ncp=input;\\r\\nl=length;\\r\\nwhile (l > 0)\\r\\n{\\r\\nif (l > 1)\\r\\n{\\r\\nt0= (DES_LONG)(*(cp++));\\r\\nt0|=(DES_LONG)Q_B1(*(cp++));\\r\\nl--;\\r\\n}\\r\\nelse\\r\\nt0= (DES_LONG)(*(cp++));\\r\\nl--;\\r\\nt0+=z0;\\r\\nt0&=0xffffffffL;\\r\\nt1=z1;\\r\\nz0=((((t0*t0)&0xffffffffL)+((t1*t1)&0xffffffffL))\\r\\n&0xffffffffL)%0x7fffffffL;\\r\\nz1=((t0*((t1+NOISE)&0xffffffffL))&0xffffffffL)%0x7fffffffL;\\r\\n}\\r\\nif (lp != NULL)\\r\\n{\\r\\nstatic DES_LONG ltmp=1;\\r\\nstatic unsigned char *c=(unsigned char *)&ltmp;\\r\\nif (c[0])\\r\\n{\\r\\nl2c(z0,lp);\\r\\nl2c(z1,lp);\\r\\n}\\r\\nelse\\r\\n{\\r\\nlp = &(output[out_count-i-1])[0];\\r\\nl2n(z1,lp);\\r\\nl2n(z0,lp);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(z0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_r2_c", "target": 0, "func": "EVP_CIPHER *EVP_rc2_cfb(void)\\r\\n{\\r\\nreturn(&r2_cfb_cipher);\\r\\n}\\r\\nstatic void rc2_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC2_set_key(&(ctx->c.rc2_ks),EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,EVP_CIPHER_CTX_key_length(ctx)*8);\\r\\n}\\r\\nstatic void rc2_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC2_cfb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.rc2_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_saccept_c", "target": 0, "func": "void close_up()\\r\\n{\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\n}\\r\\nint main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *port=NULL;\\r\\nBIO *ssl_bio,*tmp;\\r\\nSSL_CTX *ctx;\\r\\nSSL *ssl;\\r\\nchar buf[512];\\r\\nint ret=1,i;\\r\\nif (argc <= 1)\\r\\nport=\"*:4433\";\\r\\nelse\\r\\nport=argv[1];\\r\\nsignal(SIGINT,close_up);\\r\\nSSL_load_error_strings();\\r\\nSSLeay_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(SSLv23_server_method());\\r\\nif (!SSL_CTX_use_certificate_file(ctx,CERT_FILE,SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_use_PrivateKey_file(ctx,CERT_FILE,SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\ngoto err;\\r\\nssl=SSL_new(ctx);\\r\\nssl_bio=BIO_new_ssl(ctx,0);\\r\\nif ((in=BIO_new_accept(port)) == NULL) goto err;\\r\\nBIO_set_accept_bios(in,ssl_bio);\\r\\nagain:\\r\\nif (BIO_do_accept(in) <= 0) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(in,buf,512);\\r\\nif (i == 0)\\r\\n{\\r\\nprintf(\"Done\\n\");\\r\\ntmp=BIO_pop(in);\\r\\nBIO_free_all(tmp);\\r\\ngoto again;\\r\\n}\\r\\nif (i < 0) goto err;\\r\\nfwrite(buf,1,i,stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\nret=0;\\r\\nerr:\\r\\nif (ret)\\r\\n{\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (in != NULL) BIO_free(in);\\r\\nexit(ret);\\r\\nreturn(!ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p5_pbev2_c", "target": 0, "func": "int i2d_PBE2PARAM(PBE2PARAM *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->keyfunc, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len (a->encryption, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->keyfunc, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put (a->encryption, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPBE2PARAM *PBE2PARAM_new(void)\\r\\n{\\r\\nPBE2PARAM *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PBE2PARAM);\\r\\nM_ASN1_New(ret->keyfunc,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->encryption,X509_ALGOR_new);\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PBE2PARAM_NEW);\\r\\n}\\r\\nPBE2PARAM *d2i_PBE2PARAM(PBE2PARAM **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PBE2PARAM *,PBE2PARAM_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->keyfunc, d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get (ret->encryption, d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_Finish(a, PBE2PARAM_free, ASN1_F_D2I_PBE2PARAM);\\r\\n}\\r\\nvoid PBE2PARAM_free (PBE2PARAM *a)\\r\\n{\\r\\nif(a==NULL) return;\\r\\nX509_ALGOR_free(a->keyfunc);\\r\\nX509_ALGOR_free(a->encryption);\\r\\nFree ((char *)a);\\r\\n}\\r\\nint i2d_PBKDF2PARAM(PBKDF2PARAM *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->salt, i2d_ASN1_TYPE);\\r\\nM_ASN1_I2D_len (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len (a->keylength, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len (a->prf, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->salt, i2d_ASN1_TYPE);\\r\\nM_ASN1_I2D_put (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put (a->keylength, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put (a->prf, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPBKDF2PARAM *PBKDF2PARAM_new(void)\\r\\n{\\r\\nPBKDF2PARAM *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PBKDF2PARAM);\\r\\nM_ASN1_New(ret->salt, ASN1_TYPE_new);\\r\\nM_ASN1_New(ret->iter, ASN1_INTEGER_new);\\r\\nret->keylength = NULL;\\r\\nret->prf = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PBKDF2PARAM_NEW);\\r\\n}\\r\\nPBKDF2PARAM *d2i_PBKDF2PARAM(PBKDF2PARAM **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PBKDF2PARAM *,PBKDF2PARAM_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->salt, d2i_ASN1_TYPE);\\r\\nM_ASN1_D2I_get (ret->iter, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_opt (ret->keylength, d2i_ASN1_INTEGER, V_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_opt (ret->prf, d2i_X509_ALGOR, V_ASN1_SEQUENCE);\\r\\nM_ASN1_D2I_Finish(a, PBKDF2PARAM_free, ASN1_F_D2I_PBKDF2PARAM);\\r\\n}\\r\\nvoid PBKDF2PARAM_free (PBKDF2PARAM *a)\\r\\n{\\r\\nif(a==NULL) return;\\r\\nASN1_TYPE_free(a->salt);\\r\\nASN1_INTEGER_free(a->iter);\\r\\nASN1_INTEGER_free(a->keylength);\\r\\nX509_ALGOR_free(a->prf);\\r\\nFree ((char *)a);\\r\\n}\\r\\nX509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter,\\r\\nunsigned char *salt, int saltlen)\\r\\n{\\r\\nX509_ALGOR *scheme = NULL, *kalg = NULL, *ret = NULL;\\r\\nint alg_nid;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nPBKDF2PARAM *kdf = NULL;\\r\\nPBE2PARAM *pbe2 = NULL;\\r\\nASN1_OCTET_STRING *osalt = NULL;\\r\\nif(!(pbe2 = PBE2PARAM_new())) goto merr;\\r\\nscheme = pbe2->encryption;\\r\\nalg_nid = EVP_CIPHER_type(cipher);\\r\\nscheme->algorithm = OBJ_nid2obj(alg_nid);\\r\\nif(!(scheme->parameter = ASN1_TYPE_new())) goto merr;\\r\\nRAND_bytes(iv, EVP_CIPHER_iv_length(cipher));\\r\\nEVP_CipherInit(&ctx, cipher, NULL, iv, 0);\\r\\nif(EVP_CIPHER_param_to_asn1(&ctx, scheme->parameter) < 0) {\\r\\nASN1err(ASN1_F_PKCS5_PBE2_SET,\\r\\nASN1_R_ERROR_SETTING_CIPHER_PARAMS);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nif(!(kdf = PBKDF2PARAM_new())) goto merr;\\r\\nif(!(osalt = ASN1_OCTET_STRING_new())) goto merr;\\r\\nif (!saltlen) saltlen = PKCS5_SALT_LEN;\\r\\nif (!(osalt->data = Malloc (saltlen))) goto merr;\\r\\nosalt->length = saltlen;\\r\\nif (salt) memcpy (osalt->data, salt, saltlen);\\r\\nelse RAND_bytes (osalt->data, saltlen);\\r\\nif(iter <= 0) iter = PKCS5_DEFAULT_ITER;\\r\\nif(!ASN1_INTEGER_set(kdf->iter, iter)) goto merr;\\r\\nkdf->salt->value.octet_string = osalt;\\r\\nkdf->salt->type = V_ASN1_OCTET_STRING;\\r\\nosalt = NULL;\\r\\nif(alg_nid == NID_rc2_cbc) {\\r\\nif(!(kdf->keylength = ASN1_INTEGER_new())) goto merr;\\r\\nif(!ASN1_INTEGER_set (kdf->keylength,\\r\\nEVP_CIPHER_key_length(cipher))) goto merr;\\r\\n}\\r\\npbe2->keyfunc->algorithm = OBJ_nid2obj(NID_id_pbkdf2);\\r\\nif(!(pbe2->keyfunc->parameter = ASN1_TYPE_new())) goto merr;\\r\\nif(!ASN1_pack_string(kdf, i2d_PBKDF2PARAM,\\r\\n&pbe2->keyfunc->parameter->value.sequence)) goto merr;\\r\\npbe2->keyfunc->parameter->type = V_ASN1_SEQUENCE;\\r\\nPBKDF2PARAM_free(kdf);\\r\\nkdf = NULL;\\r\\nif(!(ret = X509_ALGOR_new())) goto merr;\\r\\nif(!(ret->parameter = ASN1_TYPE_new())) goto merr;\\r\\nret->algorithm = OBJ_nid2obj(NID_pbes2);\\r\\nif(!ASN1_pack_string(pbe2, i2d_PBE2PARAM,\\r\\n&ret->parameter->value.sequence)) goto merr;\\r\\nret->parameter->type = V_ASN1_SEQUENCE;\\r\\nPBE2PARAM_free(pbe2);\\r\\npbe2 = NULL;\\r\\nreturn ret;\\r\\nmerr:\\r\\nASN1err(ASN1_F_PKCS5_PBE2_SET,ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nPBE2PARAM_free(pbe2);\\r\\nASN1_OCTET_STRING_free(osalt);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nX509_ALGOR_free(kalg);\\r\\nX509_ALGOR_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_gen_c", "target": 0, "func": "DH *DH_generate_parameters(int prime_len, int generator,\\r\\nvoid (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nBIGNUM *p=NULL,*t1,*t2;\\r\\nDH *ret=NULL;\\r\\nint g,ok= -1;\\r\\nBN_CTX *ctx=NULL;\\r\\nret=DH_new();\\r\\nif (ret == NULL) goto err;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nt1= &(ctx->bn[0]);\\r\\nt2= &(ctx->bn[1]);\\r\\nctx->tos=2;\\r\\nif (generator == DH_GENERATOR_2)\\r\\n{\\r\\nBN_set_word(t1,24);\\r\\nBN_set_word(t2,11);\\r\\ng=2;\\r\\n}\\r\\n#ifdef undef\\r\\nelse if (generator == DH_GENERATOR_3)\\r\\n{\\r\\nBN_set_word(t1,12);\\r\\nBN_set_word(t2,5);\\r\\ng=3;\\r\\n}\\r\\n#endif\\r\\nelse if (generator == DH_GENERATOR_5)\\r\\n{\\r\\nBN_set_word(t1,10);\\r\\nBN_set_word(t2,3);\\r\\ng=5;\\r\\n}\\r\\nelse\\r\\ng=generator;\\r\\np=BN_generate_prime(NULL,prime_len,1,t1,t2,callback,cb_arg);\\r\\nif (p == NULL) goto err;\\r\\nif (callback != NULL) callback(3,0,cb_arg);\\r\\nret->p=p;\\r\\nret->g=BN_new();\\r\\nif (!BN_set_word(ret->g,g)) goto err;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok == -1)\\r\\n{\\r\\nDHerr(DH_F_DH_GENERATE_PARAMETERS,ERR_R_BN_LIB);\\r\\nok=0;\\r\\n}\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nif (!ok && (ret != NULL))\\r\\n{\\r\\nDH_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_vis_c", "target": 0, "func": "int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a, unsigned char **pp)\\r\\n{\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_VISIBLESTRING,V_ASN1_UNIVERSAL));\\r\\n}\\r\\nASN1_VISIBLESTRING *d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nASN1_VISIBLESTRING *ret=NULL;\\r\\nret=(ASN1_VISIBLESTRING *)d2i_ASN1_bytes((ASN1_STRING **)a,\\r\\npp,length,V_ASN1_VISIBLESTRING,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_VISIBLESTRING,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s23_meth_c", "target": 0, "func": "static SSL_METHOD *ssl23_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv23_method());\\r\\nelse if (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_data,(char *)sslv23_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv23_data.ssl_connect=ssl23_connect;\\r\\nSSLv23_data.ssl_accept=ssl23_accept;\\r\\nSSLv23_data.get_ssl_method=ssl23_get_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv23_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ecb_enc_c", "target": 0, "func": "const char *des_options(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic char buf[32];\\r\\nif (init)\\r\\n{\\r\\nconst char *ptr,*unroll,*risc,*size;\\r\\n#ifdef DES_PTR\\r\\nptr=\"ptr\";\\r\\n#else\\r\\nptr=\"idx\";\\r\\n#endif\\r\\n#if defined(DES_RISC1) || defined(DES_RISC2)\\r\\n#ifdef DES_RISC1\\r\\nrisc=\"risc1\";\\r\\n#endif\\r\\n#ifdef DES_RISC2\\r\\nrisc=\"risc2\";\\r\\n#endif\\r\\n#else\\r\\nrisc=\"cisc\";\\r\\n#endif\\r\\n#ifdef DES_UNROLL\\r\\nunroll=\"16\";\\r\\n#else\\r\\nunroll=\"4\";\\r\\n#endif\\r\\nif (sizeof(DES_LONG) != sizeof(long))\\r\\nsize=\"int\";\\r\\nelse\\r\\nsize=\"long\";\\r\\nsprintf(buf,\"des(%s,%s,%s,%s)\",ptr,risc,unroll,size);\\r\\ninit=0;\\r\\n}\\r\\nreturn(buf);\\r\\n}\\r\\nvoid des_ecb_encrypt(const_des_cblock *input, des_cblock *output,\\r\\ndes_key_schedule ks,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG l;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in,l); ll[0]=l;\\r\\nc2l(in,l); ll[1]=l;\\r\\ndes_encrypt(ll,ks,enc);\\r\\nl=ll[0]; l2c(l,out);\\r\\nl=ll[1]; l2c(l,out);\\r\\nl=ll[0]=ll[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_spki_c", "target": 0, "func": "int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->pubkey, i2d_X509_PUBKEY);\\r\\nM_ASN1_I2D_len(a->challenge, i2d_ASN1_IA5STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->pubkey, i2d_X509_PUBKEY);\\r\\nM_ASN1_I2D_put(a->challenge, i2d_ASN1_IA5STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nNETSCAPE_SPKAC *d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,NETSCAPE_SPKAC *,NETSCAPE_SPKAC_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->pubkey,d2i_X509_PUBKEY);\\r\\nM_ASN1_D2I_get(ret->challenge,d2i_ASN1_IA5STRING);\\r\\nM_ASN1_D2I_Finish(a,NETSCAPE_SPKAC_free,ASN1_F_D2I_NETSCAPE_SPKAC);\\r\\n}\\r\\nNETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void)\\r\\n{\\r\\nNETSCAPE_SPKAC *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,NETSCAPE_SPKAC);\\r\\nM_ASN1_New(ret->pubkey,X509_PUBKEY_new);\\r\\nM_ASN1_New(ret->challenge,ASN1_IA5STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_NETSCAPE_SPKAC_NEW);\\r\\n}\\r\\nvoid NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_PUBKEY_free(a->pubkey);\\r\\nASN1_IA5STRING_free(a->challenge);\\r\\nFree((char *)a);\\r\\n}\\r\\nint i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->spkac, i2d_NETSCAPE_SPKAC);\\r\\nM_ASN1_I2D_len(a->sig_algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->spkac, i2d_NETSCAPE_SPKAC);\\r\\nM_ASN1_I2D_put(a->sig_algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nNETSCAPE_SPKI *d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,NETSCAPE_SPKI *,NETSCAPE_SPKI_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->spkac,d2i_NETSCAPE_SPKAC);\\r\\nM_ASN1_D2I_get(ret->sig_algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->signature,d2i_ASN1_BIT_STRING);\\r\\nM_ASN1_D2I_Finish(a,NETSCAPE_SPKI_free,ASN1_F_D2I_NETSCAPE_SPKI);\\r\\n}\\r\\nNETSCAPE_SPKI *NETSCAPE_SPKI_new(void)\\r\\n{\\r\\nNETSCAPE_SPKI *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,NETSCAPE_SPKI);\\r\\nM_ASN1_New(ret->spkac,NETSCAPE_SPKAC_new);\\r\\nM_ASN1_New(ret->sig_algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->signature,ASN1_BIT_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_NETSCAPE_SPKI_NEW);\\r\\n}\\r\\nvoid NETSCAPE_SPKI_free(NETSCAPE_SPKI *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nNETSCAPE_SPKAC_free(a->spkac);\\r\\nX509_ALGOR_free(a->sig_algor);\\r\\nASN1_BIT_STRING_free(a->signature);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dec_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *keyfile=NULL;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *x509;\\r\\nPKCS7 *p7;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nX509_STORE_CTX cert_ctx;\\r\\nX509_STORE *cert_store=NULL;\\r\\nBIO *data,*detached=NULL,*p7bio=NULL;\\r\\nchar buf[1024*4];\\r\\nunsigned char *pp;\\r\\nint i,printit=0;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *sk;\\r\\nSSLeay_add_all_algorithms();\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\ndata=BIO_new(BIO_s_file());\\r\\npp=NULL;\\r\\nwhile (argc > 1)\\r\\n{\\r\\nargc--;\\r\\nargv++;\\r\\nif (strcmp(argv[0],\"-p\") == 0)\\r\\n{\\r\\nprintit=1;\\r\\n}\\r\\nelse if ((strcmp(argv[0],\"-k\") == 0) && (argc >= 2)) {\\r\\nkeyfile = argv[1];\\r\\nargc-=1;\\r\\nargv+=1;\\r\\n} else if ((strcmp(argv[0],\"-d\") == 0) && (argc >= 2))\\r\\n{\\r\\ndetached=BIO_new(BIO_s_file());\\r\\nif (!BIO_read_filename(detached,argv[1]))\\r\\ngoto err;\\r\\nargc-=1;\\r\\nargv+=1;\\r\\n}\\r\\nelse break;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[0])) goto err;\\r\\nif(!keyfile) {\\r\\nfprintf(stderr, \"No private key file specified\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((in=BIO_new_file(keyfile,\"r\")) == NULL) goto err;\\r\\nif ((x509=PEM_read_bio_X509(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_free(in);\\r\\nif (pp == NULL)\\r\\nBIO_set_fp(data,stdin,BIO_NOCLOSE);\\r\\nif ((p7=PEM_read_bio_PKCS7(data,NULL,NULL)) == NULL) goto err;\\r\\ncert_store=X509_STORE_new();\\r\\nX509_STORE_set_default_paths(cert_store);\\r\\nX509_STORE_load_locations(cert_store,NULL,\"../../certs\");\\r\\nX509_STORE_set_verify_cb_func(cert_store,verify_callback);\\r\\nERR_clear_error();\\r\\np7bio=PKCS7_dataDecode(p7,pkey,detached,x509);\\r\\nif (p7bio == NULL)\\r\\n{\\r\\nprintf(\"problems decoding\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(p7bio,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nfwrite(buf,1, i, stdout);\\r\\n}\\r\\nsk=PKCS7_get_signer_info(p7);\\r\\nif (sk == NULL)\\r\\n{\\r\\nfprintf(stderr, \"there are no signatures on this data\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nERR_clear_error();\\r\\nfor (i=0; i<sk_PKCS7_SIGNER_INFO_num(sk); i++)\\r\\n{\\r\\nsi=sk_PKCS7_SIGNER_INFO_value(sk,i);\\r\\ni=PKCS7_dataVerify(cert_store,&cert_ctx,p7bio,p7,si);\\r\\nif (i <= 0)\\r\\ngoto err;\\r\\nelse\\r\\nfprintf(stderr,\"Signature verified\\n\");\\r\\n}\\r\\n}\\r\\nX509_STORE_free(cert_store);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nint verify_callback(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nX509 *err_cert;\\r\\nint err,depth;\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr= X509_STORE_CTX_get_error(ctx);\\r\\ndepth= X509_STORE_CTX_get_error_depth(ctx);\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);\\r\\nBIO_printf(bio_err,\"depth=%d %s\\n\",depth,buf);\\r\\nif (!ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:num=%d:%s\\n\",err,\\r\\nX509_verify_cert_error_string(err));\\r\\nif (depth < 6)\\r\\n{\\r\\nok=1;\\r\\nX509_STORE_CTX_set_error(ctx,X509_V_OK);\\r\\n}\\r\\nelse\\r\\n{\\r\\nok=0;\\r\\nX509_STORE_CTX_set_error(ctx,X509_V_ERR_CERT_CHAIN_TOO_LONG);\\r\\n}\\r\\n}\\r\\nswitch (ctx->error)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256);\\r\\nBIO_printf(bio_err,\"issuer= %s\\n\",buf);\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nBIO_printf(bio_err,\"notBefore=\");\\r\\nASN1_UTCTIME_print(bio_err,X509_get_notBefore(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nBIO_printf(bio_err,\"notAfter=\");\\r\\nASN1_UTCTIME_print(bio_err,X509_get_notAfter(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\n}\\r\\nBIO_printf(bio_err,\"verify return:%d\\n\",ok);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_dss1_c", "target": 0, "func": "EVP_MD *EVP_dss1(void)\\r\\n{\\r\\nreturn(&dss1_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_mutl_c", "target": 0, "func": "int PKCS12_gen_mac (PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *mac, unsigned int *maclen)\\r\\n{\\r\\nconst EVP_MD *md_type;\\r\\nHMAC_CTX hmac;\\r\\nunsigned char key[PKCS12_MAC_KEY_LENGTH], *salt;\\r\\nint saltlen, iter;\\r\\nsalt = p12->mac->salt->data;\\r\\nsaltlen = p12->mac->salt->length;\\r\\nif (!p12->mac->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (p12->mac->iter);\\r\\nif(!(md_type =\\r\\nEVP_get_digestbyobj (p12->mac->dinfo->algor->algorithm))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nif(!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_MAC_ID, iter,\\r\\nPKCS12_MAC_KEY_LENGTH, key, md_type)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC,PKCS12_R_KEY_GEN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_Init (&hmac, key, PKCS12_MAC_KEY_LENGTH, md_type);\\r\\nHMAC_Update (&hmac, p12->authsafes->d.data->data,\\r\\np12->authsafes->d.data->length);\\r\\nHMAC_Final (&hmac, mac, maclen);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_verify_mac (PKCS12 *p12, const char *pass, int passlen)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif(p12->mac == NULL) {\\r\\nPKCS12err(PKCS12_F_VERIFY_MAC,PKCS12_R_MAC_ABSENT);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_VERIFY_MAC,PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif ((maclen != (unsigned int)p12->mac->dinfo->digest->length)\\r\\n|| memcmp (mac, p12->mac->dinfo->digest->data, maclen)) {\\r\\nPKCS12err(PKCS12_F_VERIFY_MAC,PKCS12_R_MAC_VERIFY_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_set_mac (PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter, EVP_MD *md_type)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (!md_type) md_type = EVP_sha1();\\r\\nif (PKCS12_setup_mac (p12, iter, salt, saltlen, md_type) ==\\r\\nPKCS12_ERROR) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_SETUP_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac (p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(ASN1_OCTET_STRING_set (p12->mac->dinfo->digest, mac, maclen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC,PKCS12_R_MAC_STRING_SET_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_setup_mac (PKCS12 *p12, int iter, unsigned char *salt, int saltlen,\\r\\nEVP_MD *md_type)\\r\\n{\\r\\nif (!(p12->mac = PKCS12_MAC_DATA_new ())) return PKCS12_ERROR;\\r\\nif (iter > 1) {\\r\\nif(!(p12->mac->iter = ASN1_INTEGER_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_INTEGER_set (p12->mac->iter, iter);\\r\\n}\\r\\nif (!saltlen) saltlen = PKCS12_SALT_LEN;\\r\\np12->mac->salt->length = saltlen;\\r\\nif (!(p12->mac->salt->data = Malloc (saltlen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!salt) RAND_bytes (p12->mac->salt->data, saltlen);\\r\\nelse memcpy (p12->mac->salt->data, salt, saltlen);\\r\\np12->mac->dinfo->algor->algorithm = OBJ_nid2obj(EVP_MD_type(md_type));\\r\\nif (!(p12->mac->dinfo->algor->parameter = ASN1_TYPE_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np12->mac->dinfo->algor->parameter->type = V_ASN1_NULL;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_asn1_c", "target": 0, "func": "int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)\\r\\n{\\r\\nASN1_STRING *os;\\r\\nif ((os=ASN1_OCTET_STRING_new()) == NULL) return(0);\\r\\nif (!ASN1_OCTET_STRING_set(os,data,len)) return(0);\\r\\nASN1_TYPE_set(a,V_ASN1_OCTET_STRING,os);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned char *data,\\r\\nint max_len)\\r\\n{\\r\\nint ret,num;\\r\\nunsigned char *p;\\r\\nif ((a->type != V_ASN1_OCTET_STRING) || (a->value.octet_string == NULL))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING,ASN1_R_DATA_IS_WRONG);\\r\\nreturn(-1);\\r\\n}\\r\\np=ASN1_STRING_data(a->value.octet_string);\\r\\nret=ASN1_STRING_length(a->value.octet_string);\\r\\nif (ret < max_len)\\r\\nnum=ret;\\r\\nelse\\r\\nnum=max_len;\\r\\nmemcpy(data,p,num);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,\\r\\nint len)\\r\\n{\\r\\nint n,size;\\r\\nASN1_OCTET_STRING os,*osp;\\r\\nASN1_INTEGER in;\\r\\nunsigned char *p;\\r\\nunsigned char buf[32];\\r\\nin.data=buf;\\r\\nin.length=32;\\r\\nos.data=data;\\r\\nos.type=V_ASN1_OCTET_STRING;\\r\\nos.length=len;\\r\\nASN1_INTEGER_set(&in,num);\\r\\nn = i2d_ASN1_INTEGER(&in,NULL);\\r\\nn+=M_i2d_ASN1_OCTET_STRING(&os,NULL);\\r\\nsize=ASN1_object_size(1,n,V_ASN1_SEQUENCE);\\r\\nif ((osp=ASN1_STRING_new()) == NULL) return(0);\\r\\nASN1_STRING_set(osp,NULL,size);\\r\\nASN1_STRING_length(osp)=size;\\r\\np=ASN1_STRING_data(osp);\\r\\nASN1_put_object(&p,1,n,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&in,&p);\\r\\nM_i2d_ASN1_OCTET_STRING(&os,&p);\\r\\nASN1_TYPE_set(a,V_ASN1_SEQUENCE,osp);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num, unsigned char *data,\\r\\nint max_len)\\r\\n{\\r\\nint ret= -1,n;\\r\\nASN1_INTEGER *ai=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nunsigned char *p;\\r\\nlong length;\\r\\nASN1_CTX c;\\r\\nif ((a->type != V_ASN1_SEQUENCE) || (a->value.sequence == NULL))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\np=ASN1_STRING_data(a->value.sequence);\\r\\nlength=ASN1_STRING_length(a->value.sequence);\\r\\nc.pp= &p;\\r\\nc.p=p;\\r\\nc.max=p+length;\\r\\nc.error=ASN1_R_DATA_IS_WRONG;\\r\\nM_ASN1_D2I_start_sequence();\\r\\nc.q=c.p;\\r\\nif ((ai=d2i_ASN1_INTEGER(NULL,&c.p,c.slen)) == NULL) goto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nc.q=c.p;\\r\\nif ((os=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL) goto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nif (!M_ASN1_D2I_end_sequence()) goto err;\\r\\nif (num != NULL)\\r\\n*num=ASN1_INTEGER_get(ai);\\r\\nret=ASN1_STRING_length(os);\\r\\nif (max_len > ret)\\r\\nn=ret;\\r\\nelse\\r\\nn=max_len;\\r\\nif (data != NULL)\\r\\nmemcpy(data,ASN1_STRING_data(os),n);\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING,ASN1_R_DATA_IS_WRONG);\\r\\n}\\r\\nif (os != NULL) ASN1_OCTET_STRING_free(os);\\r\\nif (ai != NULL) ASN1_INTEGER_free(ai);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_loadrsa_c", "target": 0, "func": "void callback(stage,count,arg)\\r\\nint stage,count;\\r\\nchar *arg;\\r\\n{\\r\\nFILE *out;\\r\\nout=(FILE *)arg;\\r\\nfprintf(out,\"%d\",stage);\\r\\nif (stage == 3)\\r\\nfprintf(out,\"\\n\");\\r\\nfflush(out);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nRSA *rsa,*pub_rsa,*priv_rsa;\\r\\nint len;\\r\\nunsigned char buf[1024],*p;\\r\\nrsa=RSA_generate_key(512,RSA_F4,callback,(char *)stdout);\\r\\np=buf;\\r\\nlen=i2d_RSAPublicKey(rsa,&p);\\r\\nlen+=i2d_RSAPrivateKey(rsa,&p);\\r\\nprintf(\"The public and private key are now both in a char array\\n\");\\r\\nprintf(\"and are taking up %d bytes\\n\",len);\\r\\nRSA_free(rsa);\\r\\np=buf;\\r\\npub_rsa=d2i_RSAPublicKey(NULL,&p,(long)len);\\r\\nlen-=(p-buf);\\r\\npriv_rsa=d2i_RSAPrivateKey(NULL,&p,(long)len);\\r\\nif ((pub_rsa == NULL) || (priv_rsa == NULL))\\r\\nERR_print_errors_fp(stderr);\\r\\nRSA_free(pub_rsa);\\r\\nRSA_free(priv_rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_enc_c", "target": 0, "func": "int ssl2_enc_init(SSL *s, int client)\\r\\n{\\r\\nEVP_CIPHER_CTX *rs,*ws;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\nint num;\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_SSL2_ENC_INIT,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(0);\\r\\n}\\r\\ns->read_hash=md;\\r\\ns->write_hash=md;\\r\\nif ((s->enc_read_ctx == NULL) &&\\r\\n((s->enc_read_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\nif ((s->enc_write_ctx == NULL) &&\\r\\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\nrs= s->enc_read_ctx;\\r\\nws= s->enc_write_ctx;\\r\\nEVP_CIPHER_CTX_init(rs);\\r\\nEVP_CIPHER_CTX_init(ws);\\r\\nnum=c->key_len;\\r\\ns->s2->key_material_length=num*2;\\r\\nssl2_generate_key_material(s);\\r\\nEVP_EncryptInit(ws,c,&(s->s2->key_material[(client)?num:0]),\\r\\ns->session->key_arg);\\r\\nEVP_DecryptInit(rs,c,&(s->s2->key_material[(client)?0:num]),\\r\\ns->session->key_arg);\\r\\ns->s2->read_key= &(s->s2->key_material[(client)?0:num]);\\r\\ns->s2->write_key= &(s->s2->key_material[(client)?num:0]);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL2_ENC_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl2_enc(SSL *s, int send)\\r\\n{\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs;\\r\\nif (send)\\r\\n{\\r\\nds=s->enc_write_ctx;\\r\\nl=s->s2->wlength;\\r\\n}\\r\\nelse\\r\\n{\\r\\nds=s->enc_read_ctx;\\r\\nl=s->s2->rlength;\\r\\n}\\r\\nif (ds == NULL) return;\\r\\nbs=ds->cipher->block_size;\\r\\nif (bs == 8)\\r\\nl=(l+7)/8*8;\\r\\nEVP_Cipher(ds,s->s2->mac_data,s->s2->mac_data,l);\\r\\n}\\r\\nvoid ssl2_mac(SSL *s, unsigned char *md, int send)\\r\\n{\\r\\nEVP_MD_CTX c;\\r\\nunsigned char sequence[4],*p,*sec,*act;\\r\\nunsigned long seq;\\r\\nunsigned int len;\\r\\nif (send)\\r\\n{\\r\\nseq=s->s2->write_sequence;\\r\\nsec=s->s2->write_key;\\r\\nlen=s->s2->wact_data_length;\\r\\nact=s->s2->wact_data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nseq=s->s2->read_sequence;\\r\\nsec=s->s2->read_key;\\r\\nlen=s->s2->ract_data_length;\\r\\nact=s->s2->ract_data;\\r\\n}\\r\\np= &(sequence[0]);\\r\\nl2n(seq,p);\\r\\nEVP_DigestInit(&c,s->read_hash);\\r\\nEVP_DigestUpdate(&c,sec,\\r\\nEVP_CIPHER_CTX_key_length(s->enc_read_ctx));\\r\\nEVP_DigestUpdate(&c,act,len);\\r\\nEVP_DigestUpdate(&c,sequence,4);\\r\\nEVP_DigestFinal(&c,md,NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_ok_c", "target": 0, "func": "BIO_METHOD *BIO_f_reliable(void)\\r\\n{\\r\\nreturn(&methods_ok);\\r\\n}\\r\\nstatic int ok_new(BIO *bi)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nctx=(BIO_OK_CTX *)Malloc(sizeof(BIO_OK_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->buf_len_save=0;\\r\\nctx->buf_off_save=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->blockout= 0;\\r\\nctx->sigio=1;\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ok_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nmemset(a->ptr,0,sizeof(BIO_OK_CTX));\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ok_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,n;\\r\\nBIO_OK_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\\r\\nwhile(outl > 0)\\r\\n{\\r\\nif (ctx->blockout)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret+=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_off=0;\\r\\nif(ctx->buf_len_save- ctx->buf_off_save > 0)\\r\\n{\\r\\nctx->buf_len= ctx->buf_len_save- ctx->buf_off_save;\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off_save]),\\r\\nctx->buf_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->buf_len=0;\\r\\n}\\r\\nctx->blockout= 0;\\r\\n}\\r\\n}\\r\\nif (outl == 0) break;\\r\\nn=IOBS- ctx->buf_len;\\r\\ni=BIO_read(b->next_bio,&(ctx->buf[ctx->buf_len]),n);\\r\\nif (i <= 0) break;\\r\\nctx->buf_len+= i;\\r\\nif (ctx->sigio == 1) sig_in(b);\\r\\nif (ctx->sigio == 0) block_in(b);\\r\\nif (ctx->cont <= 0) break;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ok_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_OK_CTX *ctx;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nret=inl;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\\r\\nif(ctx->sigio) sig_out(b);\\r\\ndo{\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (ctx->blockout && n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif(!BIO_should_retry(b))\\r\\nctx->cont= 0;\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nctx->blockout= 0;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=OK_BLOCK_BLOCK;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nn= (inl+ ctx->buf_len > OK_BLOCK_SIZE+ OK_BLOCK_BLOCK) ?\\r\\nOK_BLOCK_SIZE+ OK_BLOCK_BLOCK- ctx->buf_len : inl;\\r\\nmemcpy((unsigned char *)(&(ctx->buf[ctx->buf_len])),(unsigned char *)in,n);\\r\\nctx->buf_len+= n;\\r\\ninl-=n;\\r\\nin+=n;\\r\\nif(ctx->buf_len >= OK_BLOCK_SIZE+ OK_BLOCK_BLOCK)\\r\\n{\\r\\nblock_out(b);\\r\\n}\\r\\n}while(inl > 0);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ok_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD *md;\\r\\nconst EVP_MD **ppmd;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->buf_len_save=0;\\r\\nctx->buf_off_save=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->blockout= 0;\\r\\nctx->sigio=1;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->blockout ? ctx->buf_len-ctx->buf_off : 0;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif(ctx->blockout == 0)\\r\\nblock_out(b);\\r\\nwhile (ctx->blockout)\\r\\n{\\r\\ni=ok_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nctx->finished=1;\\r\\nctx->buf_off=ctx->buf_len=0;\\r\\nctx->cont=(int)ret;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)ctx->cont;\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd=(EVP_MD *)ptr;\\r\\nEVP_DigestInit(&(ctx->md),md);\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init)\\r\\n{\\r\\nppmd=(const EVP_MD **)ptr;\\r\\n*ppmd=ctx->md.digest;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void longswap(void *_ptr, int len)\\r\\n{\\r\\n#ifndef L_ENDIAN\\r\\nint i;\\r\\nchar *ptr=_ptr;\\r\\nfor(i= 0;i < len;i+= 4){\\r\\n*((unsigned long *)&(ptr[i]))= swapem(*((unsigned long *)&(ptr[i])));\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void sig_out(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nmd= &(ctx->md);\\r\\nif(ctx->buf_len+ 2* md->digest->md_size > OK_BLOCK_SIZE) return;\\r\\nEVP_DigestInit(md, md->digest);\\r\\nRAND_bytes(&(md->md.base[0]), md->digest->md_size);\\r\\nmemcpy(&(ctx->buf[ctx->buf_len]), &(md->md.base[0]), md->digest->md_size);\\r\\nlongswap(&(ctx->buf[ctx->buf_len]), md->digest->md_size);\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nEVP_DigestUpdate(md, (unsigned char*)WELLKNOWN, strlen(WELLKNOWN));\\r\\nmd->digest->final(&(ctx->buf[ctx->buf_len]), &(md->md.base[0]));\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nctx->blockout= 1;\\r\\nctx->sigio= 0;\\r\\n}\\r\\nstatic void sig_in(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nint ret= 0;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nmd= &(ctx->md);\\r\\nif(ctx->buf_len- ctx->buf_off < 2* md->digest->md_size) return;\\r\\nEVP_DigestInit(md, md->digest);\\r\\nmemcpy(&(md->md.base[0]), &(ctx->buf[ctx->buf_off]), md->digest->md_size);\\r\\nlongswap(&(md->md.base[0]), md->digest->md_size);\\r\\nctx->buf_off+= md->digest->md_size;\\r\\nEVP_DigestUpdate(md, (unsigned char*)WELLKNOWN, strlen(WELLKNOWN));\\r\\nmd->digest->final(tmp, &(md->md.base[0]));\\r\\nret= memcmp(&(ctx->buf[ctx->buf_off]), tmp, md->digest->md_size) == 0;\\r\\nctx->buf_off+= md->digest->md_size;\\r\\nif(ret == 1)\\r\\n{\\r\\nctx->sigio= 0;\\r\\nif(ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off]), ctx->buf_len- ctx->buf_off);\\r\\n}\\r\\nctx->buf_len-= ctx->buf_off;\\r\\nctx->buf_off= 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->cont= 0;\\r\\n}\\r\\n}\\r\\nstatic void block_out(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned long tl;\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nmd= &(ctx->md);\\r\\ntl= ctx->buf_len- OK_BLOCK_BLOCK;\\r\\ntl= swapem(tl);\\r\\nmemcpy(ctx->buf, &tl, OK_BLOCK_BLOCK);\\r\\ntl= swapem(tl);\\r\\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\\r\\nmd->digest->final(&(ctx->buf[ctx->buf_len]), &(md->md.base[0]));\\r\\nctx->buf_len+= md->digest->md_size;\\r\\nctx->blockout= 1;\\r\\n}\\r\\nstatic void block_in(BIO* b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nlong tl= 0;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nctx=(BIO_OK_CTX *)b->ptr;\\r\\nmd= &(ctx->md);\\r\\nmemcpy(&tl, ctx->buf, OK_BLOCK_BLOCK);\\r\\ntl= swapem(tl);\\r\\nif (ctx->buf_len < tl+ OK_BLOCK_BLOCK+ md->digest->md_size) return;\\r\\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\\r\\nmd->digest->final(tmp, &(md->md.base[0]));\\r\\nif(memcmp(&(ctx->buf[tl+ OK_BLOCK_BLOCK]), tmp, md->digest->md_size) == 0)\\r\\n{\\r\\nctx->buf_off_save= tl+ OK_BLOCK_BLOCK+ md->digest->md_size;\\r\\nctx->buf_len_save= ctx->buf_len;\\r\\nctx->buf_off= OK_BLOCK_BLOCK;\\r\\nctx->buf_len= tl+ OK_BLOCK_BLOCK;\\r\\nctx->blockout= 1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->cont= 0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pem_seal_c", "target": 0, "func": "int PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,\\r\\nunsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk,\\r\\nint npubk)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nint ret= -1;\\r\\nint i,j,max=0;\\r\\nchar *s=NULL;\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nif (pubk[i]->type != EVP_PKEY_RSA)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALINIT,PEM_R_PUBLIC_KEY_NO_RSA);\\r\\ngoto err;\\r\\n}\\r\\nj=RSA_size(pubk[i]->pkey.rsa);\\r\\nif (j > max) max=j;\\r\\n}\\r\\ns=(char *)Malloc(max*2);\\r\\nif (s == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_EncodeInit(&(ctx->encode));\\r\\nEVP_SignInit(&(ctx->md),md_type);\\r\\nret=EVP_SealInit(&(ctx->cipher),type,ek,ekl,iv,pubk,npubk);\\r\\nif (!ret) goto err;\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nj=EVP_EncodeBlock((unsigned char *)s,ek[i],\\r\\nRSA_size(pubk[i]->pkey.rsa));\\r\\nekl[i]=j;\\r\\nmemcpy(ek[i],s,j+1);\\r\\n}\\r\\nret=npubk;\\r\\nerr:\\r\\nif (s != NULL) Free(s);\\r\\nmemset(key,0,EVP_MAX_KEY_LENGTH);\\r\\nreturn(ret);\\r\\n}\\r\\nvoid PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nunsigned char buffer[1600];\\r\\nint i,j;\\r\\n*outl=0;\\r\\nEVP_SignUpdate(&(ctx->md),in,inl);\\r\\nfor (;;)\\r\\n{\\r\\nif (inl <= 0) break;\\r\\nif (inl > 1200)\\r\\ni=1200;\\r\\nelse\\r\\ni=inl;\\r\\nEVP_EncryptUpdate(&(ctx->cipher),buffer,&j,in,i);\\r\\nEVP_EncodeUpdate(&(ctx->encode),out,&j,buffer,j);\\r\\n*outl+=j;\\r\\nout+=j;\\r\\nin+=i;\\r\\ninl-=i;\\r\\n}\\r\\n}\\r\\nint PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,\\r\\nunsigned char *out, int *outl, EVP_PKEY *priv)\\r\\n{\\r\\nunsigned char *s=NULL;\\r\\nint ret=0,j;\\r\\nunsigned int i;\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALFINAL,PEM_R_PUBLIC_KEY_NO_RSA);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_size(priv->pkey.rsa);\\r\\nif (i < 100) i=100;\\r\\ns=(unsigned char *)Malloc(i*2);\\r\\nif (s == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_EncryptFinal(&(ctx->cipher),s,(int *)&i);\\r\\nEVP_EncodeUpdate(&(ctx->encode),out,&j,s,i);\\r\\n*outl=j;\\r\\nout+=j;\\r\\nEVP_EncodeFinal(&(ctx->encode),out,&j);\\r\\n*outl+=j;\\r\\nif (!EVP_SignFinal(&(ctx->md),s,&i,priv)) goto err;\\r\\n*sigl=EVP_EncodeBlock(sig,s,i);\\r\\nret=1;\\r\\nerr:\\r\\nmemset((char *)&(ctx->md),0,sizeof(ctx->md));\\r\\nmemset((char *)&(ctx->cipher),0,sizeof(ctx->cipher));\\r\\nif (s != NULL) Free(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_asn1pars_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,badops=0,offset=0,ret=1,j;\\r\\nunsigned int length=0;\\r\\nlong num,tmplen;\\r\\nBIO *in=NULL,*out=NULL,*b64=NULL, *derout = NULL;\\r\\nint informat,indent=0;\\r\\nchar *infile=NULL,*str=NULL,*prog,*oidfile=NULL, *derfile=NULL;\\r\\nunsigned char *tmpbuf;\\r\\nBUF_MEM *buf=NULL;\\r\\nSTACK *osk=NULL;\\r\\nASN1_TYPE *at=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nif ((osk=sk_new_null()) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nderfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-i\") == 0)\\r\\n{\\r\\nindent=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-oid\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noidfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-offset\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noffset= atoi(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-length\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nlength= atoi(*(++argv));\\r\\nif (length == 0) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-strparse\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsk_push(osk,*(++argv));\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -offset arg offset into file\\n\");\\r\\nBIO_printf(bio_err,\" -length arg lenth of section in file\\n\");\\r\\nBIO_printf(bio_err,\" -i indent entries\\n\");\\r\\nBIO_printf(bio_err,\" -oid file file of extra oid definitions\\n\");\\r\\nBIO_printf(bio_err,\" -strparse offset\\n\");\\r\\nBIO_printf(bio_err,\" a series of these can be used to 'dig' into multiple\\n\");\\r\\nBIO_printf(bio_err,\" ASN1 blob wrappings\\n\");\\r\\nBIO_printf(bio_err,\" -out filename output DER encoding to file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (oidfile != NULL)\\r\\n{\\r\\nif (BIO_read_filename(in,oidfile) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"problems opening %s\\n\",oidfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nOBJ_create_objects(in);\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (derfile) {\\r\\nif(!(derout = BIO_new_file(derfile, \"wb\"))) {\\r\\nBIO_printf(bio_err,\"problems opening %s\\n\",derfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((buf=BUF_MEM_new()) == NULL) goto end;\\r\\nif (!BUF_MEM_grow(buf,BUFSIZ*8)) goto end;\\r\\nif (informat == FORMAT_PEM)\\r\\n{\\r\\nBIO *tmp;\\r\\nif ((b64=BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nBIO_push(b64,in);\\r\\ntmp=in;\\r\\nin=b64;\\r\\nb64=tmp;\\r\\n}\\r\\nnum=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BUF_MEM_grow(buf,(int)num+BUFSIZ)) goto end;\\r\\ni=BIO_read(in,&(buf->data[num]),BUFSIZ);\\r\\nif (i <= 0) break;\\r\\nnum+=i;\\r\\n}\\r\\nstr=buf->data;\\r\\nif (sk_num(osk))\\r\\n{\\r\\ntmpbuf=(unsigned char *)str;\\r\\ntmplen=num;\\r\\nfor (i=0; i<sk_num(osk); i++)\\r\\n{\\r\\nASN1_TYPE *atmp;\\r\\nj=atoi(sk_value(osk,i));\\r\\nif (j == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"'%s' is an invalid number\\n\",sk_value(osk,i));\\r\\ncontinue;\\r\\n}\\r\\ntmpbuf+=j;\\r\\ntmplen-=j;\\r\\natmp = at;\\r\\nat = d2i_ASN1_TYPE(NULL,&tmpbuf,tmplen);\\r\\nASN1_TYPE_free(atmp);\\r\\nif(!at)\\r\\n{\\r\\nBIO_printf(bio_err,\"Error parsing structure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ntmpbuf=at->value.asn1_string->data;\\r\\ntmplen=at->value.asn1_string->length;\\r\\n}\\r\\nstr=(char *)tmpbuf;\\r\\nnum=tmplen;\\r\\n}\\r\\nif (length == 0) length=(unsigned int)num;\\r\\nif(derout) {\\r\\nif(BIO_write(derout, str + offset, length) != (int)length) {\\r\\nBIO_printf(bio_err, \"Error writing output\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!ASN1_parse(out,(unsigned char *)&(str[offset]),length,indent))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nBIO_free(derout);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (b64 != NULL) BIO_free(b64);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nif (at != NULL) ASN1_TYPE_free(at);\\r\\nif (osk != NULL) sk_free(osk);\\r\\nOBJ_cleanup();\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_all_c", "target": 0, "func": "void SSLeay_add_all_algorithms(void)\\r\\n{\\r\\nSSLeay_add_all_ciphers();\\r\\nSSLeay_add_all_digests();\\r\\n}\\r\\nvoid SSLeay_add_all_ciphers(void)\\r\\n{\\r\\n#ifndef NO_DES\\r\\nEVP_add_cipher(EVP_des_cfb());\\r\\nEVP_add_cipher(EVP_des_ede_cfb());\\r\\nEVP_add_cipher(EVP_des_ede3_cfb());\\r\\nEVP_add_cipher(EVP_des_ofb());\\r\\nEVP_add_cipher(EVP_des_ede_ofb());\\r\\nEVP_add_cipher(EVP_des_ede3_ofb());\\r\\nEVP_add_cipher(EVP_desx_cbc());\\r\\nEVP_add_cipher_alias(SN_desx_cbc,\"DESX\");\\r\\nEVP_add_cipher_alias(SN_desx_cbc,\"desx\");\\r\\nEVP_add_cipher(EVP_des_cbc());\\r\\nEVP_add_cipher_alias(SN_des_cbc,\"DES\");\\r\\nEVP_add_cipher_alias(SN_des_cbc,\"des\");\\r\\nEVP_add_cipher(EVP_des_ede_cbc());\\r\\nEVP_add_cipher(EVP_des_ede3_cbc());\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc,\"DES3\");\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc,\"des3\");\\r\\nEVP_add_cipher(EVP_des_ecb());\\r\\nEVP_add_cipher(EVP_des_ede());\\r\\nEVP_add_cipher(EVP_des_ede3());\\r\\n#endif\\r\\n#ifndef NO_RC4\\r\\nEVP_add_cipher(EVP_rc4());\\r\\nEVP_add_cipher(EVP_rc4_40());\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nEVP_add_cipher(EVP_idea_ecb());\\r\\nEVP_add_cipher(EVP_idea_cfb());\\r\\nEVP_add_cipher(EVP_idea_ofb());\\r\\nEVP_add_cipher(EVP_idea_cbc());\\r\\nEVP_add_cipher_alias(SN_idea_cbc,\"IDEA\");\\r\\nEVP_add_cipher_alias(SN_idea_cbc,\"idea\");\\r\\n#endif\\r\\n#ifndef NO_RC2\\r\\nEVP_add_cipher(EVP_rc2_ecb());\\r\\nEVP_add_cipher(EVP_rc2_cfb());\\r\\nEVP_add_cipher(EVP_rc2_ofb());\\r\\nEVP_add_cipher(EVP_rc2_cbc());\\r\\nEVP_add_cipher(EVP_rc2_40_cbc());\\r\\nEVP_add_cipher(EVP_rc2_64_cbc());\\r\\nEVP_add_cipher_alias(SN_rc2_cbc,\"RC2\");\\r\\nEVP_add_cipher_alias(SN_rc2_cbc,\"rc2\");\\r\\n#endif\\r\\n#ifndef NO_BF\\r\\nEVP_add_cipher(EVP_bf_ecb());\\r\\nEVP_add_cipher(EVP_bf_cfb());\\r\\nEVP_add_cipher(EVP_bf_ofb());\\r\\nEVP_add_cipher(EVP_bf_cbc());\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"BF\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"bf\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc,\"blowfish\");\\r\\n#endif\\r\\n#ifndef NO_CAST\\r\\nEVP_add_cipher(EVP_cast5_ecb());\\r\\nEVP_add_cipher(EVP_cast5_cfb());\\r\\nEVP_add_cipher(EVP_cast5_ofb());\\r\\nEVP_add_cipher(EVP_cast5_cbc());\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"CAST\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"cast\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"CAST-cbc\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc,\"cast-cbc\");\\r\\n#endif\\r\\n#ifndef NO_RC5\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ecb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cfb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ofb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cbc());\\r\\nEVP_add_cipher_alias(SN_rc5_cbc,\"rc5\");\\r\\nEVP_add_cipher_alias(SN_rc5_cbc,\"RC5\");\\r\\n#endif\\r\\n}\\r\\nvoid SSLeay_add_all_digests(void)\\r\\n{\\r\\n#ifndef NO_MD2\\r\\nEVP_add_digest(EVP_md2());\\r\\n#endif\\r\\n#ifndef NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest_alias(SN_md5,\"ssl2-md5\");\\r\\nEVP_add_digest_alias(SN_md5,\"ssl3-md5\");\\r\\n#endif\\r\\n#ifndef NO_SHA\\r\\nEVP_add_digest(EVP_sha());\\r\\n#ifndef NO_DSA\\r\\nEVP_add_digest(EVP_dss());\\r\\n#endif\\r\\n#endif\\r\\n#ifndef NO_SHA\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");\\r\\nEVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);\\r\\n#ifndef NO_DSA\\r\\nEVP_add_digest(EVP_dss1());\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"DSS1\");\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1,\"dss1\");\\r\\n#endif\\r\\n#endif\\r\\n#if !defined(NO_MDC2) && !defined(NO_DES)\\r\\nEVP_add_digest(EVP_mdc2());\\r\\n#endif\\r\\n#ifndef NO_RIPEMD\\r\\nEVP_add_digest(EVP_ripemd160());\\r\\nEVP_add_digest_alias(SN_ripemd160,\"ripemd\");\\r\\nEVP_add_digest_alias(SN_ripemd160,\"rmd160\");\\r\\n#endif\\r\\nPKCS12_PBE_add();\\r\\nPKCS5_PBE_add();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_buff_c", "target": 0, "func": "BIO_METHOD *BIO_f_buffer(void)\\r\\n{\\r\\nreturn(&methods_buffer);\\r\\n}\\r\\nstatic int buffer_new(BIO *bi)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nctx=(BIO_F_BUFFER_CTX *)Malloc(sizeof(BIO_F_BUFFER_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->ibuf=(char *)Malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->ibuf == NULL) { Free(ctx); return(0); }\\r\\nctx->obuf=(char *)Malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->obuf == NULL) { Free(ctx->ibuf); Free(ctx); return(0); }\\r\\nctx->ibuf_size=DEFAULT_BUFFER_SIZE;\\r\\nctx->obuf_size=DEFAULT_BUFFER_SIZE;\\r\\nctx->ibuf_len=0;\\r\\nctx->ibuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nbi->init=1;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int buffer_free(BIO *a)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_F_BUFFER_CTX *)a->ptr;\\r\\nif (b->ibuf != NULL) Free(b->ibuf);\\r\\nif (b->obuf != NULL) Free(b->obuf);\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int buffer_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint i,num=0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nnum=0;\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni=ctx->ibuf_len;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->ibuf[ctx->ibuf_off]),i);\\r\\nctx->ibuf_off+=i;\\r\\nctx->ibuf_len-=i;\\r\\nnum+=i;\\r\\nif (outl == i) return(num);\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nif (outl > ctx->ibuf_size)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(b->next_bio,out,outl);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nnum+=i;\\r\\nif (outl == i) return(num);\\r\\nout+=i;\\r\\noutl-=i;\\r\\n}\\r\\n}\\r\\ni=BIO_read(b->next_bio,ctx->ibuf,ctx->ibuf_size);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=i;\\r\\ngoto start;\\r\\n}\\r\\nstatic int buffer_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint i,num=0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni=ctx->obuf_size-(ctx->obuf_len+ctx->obuf_off);\\r\\nif (i >= inl)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),in,inl);\\r\\nctx->obuf_len+=inl;\\r\\nreturn(num+inl);\\r\\n}\\r\\nif (ctx->obuf_len != 0)\\r\\n{\\r\\nif (i > 0)\\r\\n{\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]),in,i);\\r\\nin+=i;\\r\\ninl-=i;\\r\\nnum+=i;\\r\\nctx->obuf_len+=i;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->obuf[ctx->obuf_off]),\\r\\nctx->obuf_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->obuf_off+=i;\\r\\nctx->obuf_len-=i;\\r\\nif (ctx->obuf_len == 0) break;\\r\\n}\\r\\n}\\r\\nctx->obuf_off=0;\\r\\nwhile (inl >= ctx->obuf_size)\\r\\n{\\r\\ni=BIO_write(b->next_bio,in,inl);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nnum+=i;\\r\\nin+=i;\\r\\ninl-=i;\\r\\nif (inl == 0) return(num);\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nstatic long buffer_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nlong ret=1;\\r\\nchar *p1,*p2;\\r\\nint r,i,*ip;\\r\\nint ibs,obs;\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)ctx->obuf_len;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUFF_NUM_LINES:\\r\\nret=0;\\r\\np1=ctx->ibuf;\\r\\nfor (i=ctx->ibuf_off; i<ctx->ibuf_len; i++)\\r\\n{\\r\\nif (p1[i] == '\\n') ret++;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=(long)ctx->obuf_len;\\r\\nif (ret == 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=(long)ctx->ibuf_len;\\r\\nif (ret == 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_READ_DATA:\\r\\nif (num > ctx->ibuf_size)\\r\\n{\\r\\np1=Malloc((int)num);\\r\\nif (p1 == NULL) goto malloc_error;\\r\\nif (ctx->ibuf != NULL) Free(ctx->ibuf);\\r\\nctx->ibuf=p1;\\r\\n}\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=(int)num;\\r\\nmemcpy(ctx->ibuf,ptr,(int)num);\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (*ip == 0)\\r\\n{\\r\\nibs=(int)num;\\r\\nobs=ctx->obuf_size;\\r\\n}\\r\\nelse\\r\\n{\\r\\nibs=ctx->ibuf_size;\\r\\nobs=(int)num;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nibs=(int)num;\\r\\nobs=(int)num;\\r\\n}\\r\\np1=ctx->ibuf;\\r\\np2=ctx->obuf;\\r\\nif ((ibs > DEFAULT_BUFFER_SIZE) && (ibs != ctx->ibuf_size))\\r\\n{\\r\\np1=(char *)Malloc((int)num);\\r\\nif (p1 == NULL) goto malloc_error;\\r\\n}\\r\\nif ((obs > DEFAULT_BUFFER_SIZE) && (obs != ctx->obuf_size))\\r\\n{\\r\\np2=(char *)Malloc((int)num);\\r\\nif (p2 == NULL)\\r\\n{\\r\\nif (p1 != ctx->ibuf) Free(p1);\\r\\ngoto malloc_error;\\r\\n}\\r\\n}\\r\\nif (ctx->ibuf != p1)\\r\\n{\\r\\nFree(ctx->ibuf);\\r\\nctx->ibuf=p1;\\r\\nctx->ibuf_off=0;\\r\\nctx->ibuf_len=0;\\r\\nctx->ibuf_size=ibs;\\r\\n}\\r\\nif (ctx->obuf != p2)\\r\\n{\\r\\nFree(ctx->obuf);\\r\\nctx->obuf=p2;\\r\\nctx->obuf_off=0;\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_size=obs;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (ctx->obuf_len <= 0)\\r\\n{\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->obuf_len > ctx->obuf_off)\\r\\n{\\r\\nr=BIO_write(b->next_bio,\\r\\n&(ctx->obuf[ctx->obuf_off]),\\r\\nctx->obuf_len-ctx->obuf_off);\\r\\n#if 0\\r\\nfprintf(stderr,\"FLUSH [%3d] %3d -> %3d\\n\",ctx->obuf_off,ctx->obuf_len-ctx->obuf_off,r);\\r\\n#endif\\r\\nBIO_copy_next_retry(b);\\r\\nif (r <= 0) return((long)r);\\r\\nctx->obuf_off+=r;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->obuf_len=0;\\r\\nctx->obuf_off=0;\\r\\nret=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif ( !BIO_set_read_buffer_size(dbio,ctx->ibuf_size) ||\\r\\n!BIO_set_write_buffer_size(dbio,ctx->obuf_size))\\r\\nret=0;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\nmalloc_error:\\r\\nBIOerr(BIO_F_BUFFER_CTRL,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int buffer_gets(BIO *b, char *buf, int size)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nint num=0,i,flag;\\r\\nchar *p;\\r\\nctx=(BIO_F_BUFFER_CTX *)b->ptr;\\r\\nsize--;\\r\\nBIO_clear_retry_flags(b);\\r\\nfor (;;)\\r\\n{\\r\\nif (ctx->ibuf_len > 0)\\r\\n{\\r\\np= &(ctx->ibuf[ctx->ibuf_off]);\\r\\nflag=0;\\r\\nfor (i=0; (i<ctx->ibuf_len) && (i<size); i++)\\r\\n{\\r\\n*(buf++)=p[i];\\r\\nif (p[i] == '\\n')\\r\\n{\\r\\nflag=1;\\r\\ni++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nsize-=i;\\r\\nctx->ibuf_len-=i;\\r\\nctx->ibuf_off+=i;\\r\\nif ((flag) || (i == size))\\r\\n{\\r\\n*buf='\\0';\\r\\nreturn(num);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=BIO_read(b->next_bio,ctx->ibuf,ctx->ibuf_size);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0) return((num > 0)?num:i);\\r\\nif (i == 0) return(num);\\r\\n}\\r\\nctx->ibuf_len=i;\\r\\nctx->ibuf_off=0;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int buffer_puts(BIO *b, char *str)\\r\\n{\\r\\nreturn(BIO_write(b,str,strlen(str)));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_tmdiff_c", "target": 0, "func": "char *ms_time_new(void)\\r\\n{\\r\\nMS_TM *ret;\\r\\nret=(MS_TM *)Malloc(sizeof(MS_TM));\\r\\nif (ret == NULL)\\r\\nreturn(NULL);\\r\\nmemset(ret,0,sizeof(MS_TM));\\r\\n#ifdef WIN32\\r\\nret->thread_id=GetCurrentThread();\\r\\n#endif\\r\\nreturn((char *)ret);\\r\\n}\\r\\nvoid ms_time_free(char *a)\\r\\n{\\r\\nif (a != NULL)\\r\\nFree(a);\\r\\n}\\r\\nvoid ms_time_get(char *a)\\r\\n{\\r\\nMS_TM *tm=(MS_TM *)a;\\r\\n#ifdef WIN32\\r\\nFILETIME tmpa,tmpb,tmpc;\\r\\n#endif\\r\\n#ifdef TIMES\\r\\ntimes(&tm->ms_tms);\\r\\n#else\\r\\n# ifdef WIN32\\r\\nGetThreadTimes(tm->thread_id,&tmpa,&tmpb,&tmpc,&(tm->ms_win32));\\r\\n# else\\r\\nftime(&tm->ms_timeb);\\r\\n# endif\\r\\n#endif\\r\\n}\\r\\ndouble ms_time_diff(char *ap, char *bp)\\r\\n{\\r\\nMS_TM *a=(MS_TM *)ap;\\r\\nMS_TM *b=(MS_TM *)bp;\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nret=(b->ms_tms.tms_utime-a->ms_tms.tms_utime)/HZ;\\r\\n#else\\r\\n# ifdef WIN32\\r\\n{\\r\\n#ifdef __GNUC__\\r\\nsigned long long la,lb;\\r\\n#else\\r\\nsigned _int64 la,lb;\\r\\n#endif\\r\\nla=a->ms_win32.dwHighDateTime;\\r\\nlb=b->ms_win32.dwHighDateTime;\\r\\nla<<=32;\\r\\nlb<<=32;\\r\\nla+=a->ms_win32.dwLowDateTime;\\r\\nlb+=b->ms_win32.dwLowDateTime;\\r\\nret=((double)(lb-la))/1e7;\\r\\n}\\r\\n# else\\r\\nret= (double)(b->ms_timeb.time-a->ms_timeb.time)+\\r\\n(((double)b->ms_timeb.millitm)-\\r\\n((double)a->ms_timeb.millitm))/1000.0;\\r\\n# endif\\r\\n#endif\\r\\nreturn((ret < 0.0000001)?0.0000001:ret);\\r\\n}\\r\\nint ms_time_cmp(char *ap, char *bp)\\r\\n{\\r\\nMS_TM *a=(MS_TM *)ap,*b=(MS_TM *)bp;\\r\\ndouble d;\\r\\nint ret;\\r\\n#ifdef TIMES\\r\\nd=(b->ms_tms.tms_utime-a->ms_tms.tms_utime)/HZ;\\r\\n#else\\r\\n# ifdef WIN32\\r\\nd =(b->ms_win32.dwHighDateTime&0x000fffff)*10+b->ms_win32.dwLowDateTime/1e7;\\r\\nd-=(a->ms_win32.dwHighDateTime&0x000fffff)*10+a->ms_win32.dwLowDateTime/1e7;\\r\\n# else\\r\\nd= (double)(b->ms_timeb.time-a->ms_timeb.time)+\\r\\n(((double)b->ms_timeb.millitm)-(double)a->ms_timeb.millitm)/1000.0;\\r\\n# endif\\r\\n#endif\\r\\nif (d == 0.0)\\r\\nret=0;\\r\\nelse if (d < 0)\\r\\nret= -1;\\r\\nelse\\r\\nret=1;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_r_pr_c", "target": 0, "func": "ASN1_METHOD *RSAPrivateKey_asn1_meth(void)\\r\\n{\\r\\nreturn(&method);\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey(RSA **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ASN1_R_PARSING;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,RSA *,RSA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif (bs->length == 0)\\r\\nret->version=0;\\r\\nelse ret->version=bs->data[0];\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->n=BN_bin2bn(bs->data,bs->length,ret->n)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->e=BN_bin2bn(bs->data,bs->length,ret->e)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->d=BN_bin2bn(bs->data,bs->length,ret->d)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->p=BN_bin2bn(bs->data,bs->length,ret->p)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->q=BN_bin2bn(bs->data,bs->length,ret->q)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->dmp1=BN_bin2bn(bs->data,bs->length,ret->dmp1)) == NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->dmq1=BN_bin2bn(bs->data,bs->length,ret->dmq1)) == NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->iqmp=BN_bin2bn(bs->data,bs->length,ret->iqmp)) == NULL)\\r\\ngoto err_bn;\\r\\nASN1_INTEGER_free(bs);\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_RSAPRIVATEKEY,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) RSA_free(ret);\\r\\nif (bs != NULL) ASN1_INTEGER_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_f_string_c", "target": 0, "func": "int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"0\",1) != 1) goto err;\\r\\nn=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1)\\r\\n{\\r\\nif (first)\\r\\nbreak;\\r\\nelse\\r\\ngoto err_sl;\\r\\n}\\r\\nfirst=0;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=i-1; j>0; j--)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)Malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=(unsigned char *)Realloc(s,\\r\\n(unsigned int)num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) Free((char *)s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_f_c", "target": 0, "func": "main()\\r\\n{\\r\\nASN1_TYPE *at;\\r\\nchar buf[512];\\r\\nint n;\\r\\nlong l;\\r\\nat=ASN1_TYPE_new();\\r\\nn=ASN1_TYPE_set_int_octetstring(at,98736,\"01234567\",8);\\r\\nprintf(\"%d\\n\",n);\\r\\nn=ASN1_TYPE_get_int_octetstring(at,&l,buf,8);\\r\\nbuf[8]='\\0';\\r\\nprintf(\"%ld %d %d\\n\",l,n,buf[8]);\\r\\nbuf[8]='\\0';\\r\\nprintf(\"%s\\n\",buf);\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_nseq_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint toseq = 0;\\r\\nX509 *x509 = NULL;\\r\\nNETSCAPE_CERT_SEQUENCE *seq = NULL;\\r\\nint i, ret = 1;\\r\\nint badarg = 0;\\r\\nif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\\r\\nERR_load_crypto_strings();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp (*args, \"-toseq\")) toseq = 1;\\r\\nelse if (!strcmp (*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else badarg = 1;\\r\\n} else if (!strcmp (*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else badarg = 1;\\r\\n} else badarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf (bio_err, \"Netscape certificate sequence utility\\n\");\\r\\nBIO_printf (bio_err, \"Usage nseq [options]\\n\");\\r\\nBIO_printf (bio_err, \"where options are\\n\");\\r\\nBIO_printf (bio_err, \"-in file input file\\n\");\\r\\nBIO_printf (bio_err, \"-out file output file\\n\");\\r\\nBIO_printf (bio_err, \"-toseq output NS Sequence file\\n\");\\r\\nEXIT(1);\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file (infile, \"r\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else in = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file (outfile, \"w\"))) {\\r\\nBIO_printf (bio_err,\\r\\n\"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else out = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nif (toseq) {\\r\\nseq = NETSCAPE_CERT_SEQUENCE_new();\\r\\nseq->certs = sk_X509_new(NULL);\\r\\nwhile((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)))\\r\\nsk_X509_push(seq->certs,x509);\\r\\nif(!sk_X509_num(seq->certs))\\r\\n{\\r\\nBIO_printf (bio_err, \"Error reading certs file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) {\\r\\nBIO_printf (bio_err, \"Error reading sequence file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nfor(i = 0; i < sk_X509_num(seq->certs); i++) {\\r\\nx509 = sk_X509_value(seq->certs, i);\\r\\ndump_cert_text(out, x509);\\r\\nPEM_write_bio_X509(out, x509);\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBIO_free(in);\\r\\nBIO_free(out);\\r\\nNETSCAPE_CERT_SEQUENCE_free(seq);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic int dump_cert_text(BIO *out, X509 *x)\\r\\n{\\r\\nchar buf[256];\\r\\nX509_NAME_oneline(X509_get_subject_name(x),buf,256);\\r\\nBIO_puts(out,\"subject=\");\\r\\nBIO_puts(out,buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(x),buf,256);\\r\\nBIO_puts(out,\"\\nissuer= \");\\r\\nBIO_puts(out,buf);\\r\\nBIO_puts(out,\"\\n\");\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pem_sign_c", "target": 0, "func": "void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit(ctx,type);\\r\\n}\\r\\nvoid PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,\\r\\nunsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,data,count);\\r\\n}\\r\\nint PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\\r\\nEVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char *m;\\r\\nint i,ret=0;\\r\\nunsigned int m_len;\\r\\nm=(unsigned char *)Malloc(EVP_PKEY_size(pkey)+2);\\r\\nif (m == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_SignFinal(ctx,m,&m_len,pkey) <= 0) goto err;\\r\\ni=EVP_EncodeBlock(sigret,m,m_len);\\r\\n*siglen=i;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) Free(m);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t1_lib_c", "target": 1, "func": "static long tls1_default_timeout(void)\\r\\n{\\r\\nreturn(60*60*2);\\r\\n}\\r\\nSSL_METHOD *tlsv1_base_method(void)\\r\\n{\\r\\nreturn(&TLSv1_data);\\r\\n}\\r\\nint tls1_new(SSL *s)\\r\\n{\\r\\nif (!ssl3_new(s)) return(0);\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\n}\\r\\nvoid tls1_free(SSL *s)\\r\\n{\\r\\nssl3_free(s);\\r\\n}\\r\\nvoid tls1_clear(SSL *s)\\r\\n{\\r\\nssl3_clear(s);\\r\\ns->version=TLS1_VERSION;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_lib_c", "target": 0, "func": "BIO *BIO_new(BIO_METHOD *method)\\r\\n{\\r\\nBIO *ret=NULL;\\r\\nret=(BIO *)Malloc(sizeof(BIO));\\r\\nif (ret == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (!BIO_set(ret,method))\\r\\n{\\r\\nFree(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_set(BIO *bio, BIO_METHOD *method)\\r\\n{\\r\\nbio->method=method;\\r\\nbio->callback=NULL;\\r\\nbio->cb_arg=NULL;\\r\\nbio->init=0;\\r\\nbio->shutdown=1;\\r\\nbio->flags=0;\\r\\nbio->retry_reason=0;\\r\\nbio->num=0;\\r\\nbio->ptr=NULL;\\r\\nbio->prev_bio=NULL;\\r\\nbio->next_bio=NULL;\\r\\nbio->references=1;\\r\\nbio->num_read=0L;\\r\\nbio->num_write=0L;\\r\\nCRYPTO_new_ex_data(bio_meth,(char *)bio,&bio->ex_data);\\r\\nif (method->create != NULL)\\r\\nif (!method->create(bio))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_free(BIO *a)\\r\\n{\\r\\nint ret=0,i;\\r\\nif (a == NULL) return(0);\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_BIO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"BIO\",a);\\r\\n#endif\\r\\nif (i > 0) return(1);\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"BIO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif ((a->callback != NULL) &&\\r\\n((i=(int)a->callback(a,BIO_CB_FREE,NULL,0,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nCRYPTO_free_ex_data(bio_meth,(char *)a,&a->ex_data);\\r\\nif ((a->method == NULL) || (a->method->destroy == NULL)) return(1);\\r\\nret=a->method->destroy(a);\\r\\nFree(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_read(BIO *b, void *out, int outl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)();\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bread == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_READ,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_READ,out,outl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_READ,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bread(b,out,outl);\\r\\nif (i > 0) b->num_read+=(unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_READ|BIO_CB_RETURN,out,outl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)();\\r\\nif (b == NULL)\\r\\nreturn(0);\\r\\ncb=b->callback;\\r\\nif ((b->method == NULL) || (b->method->bwrite == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_WRITE,in,inl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bwrite(b,in,inl);\\r\\nif (i > 0) b->num_write+=(unsigned long)i;\\r\\nif (b->references <= 0) abort();\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_WRITE|BIO_CB_RETURN,in,inl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_puts(BIO *b, const char *in)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)();\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bputs == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_PUTS,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_PUTS,in,0,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_PUTS,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bputs(b,in);\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_PUTS|BIO_CB_RETURN,in,0,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nint BIO_gets(BIO *b, char *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb)();\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bgets == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETS,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i=(int)cb(b,BIO_CB_GETS,in,inl,0L,1L)) <= 0))\\r\\nreturn(i);\\r\\nif (!b->init)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETS,BIO_R_UNINITIALIZED);\\r\\nreturn(-2);\\r\\n}\\r\\ni=b->method->bgets(b,in,inl);\\r\\nif (cb != NULL)\\r\\ni=(int)cb(b,BIO_CB_GETS|BIO_CB_RETURN,in,inl,\\r\\n0L,(long)i);\\r\\nreturn(i);\\r\\n}\\r\\nlong BIO_int_ctrl(BIO *b, int cmd, long larg, int iarg)\\r\\n{\\r\\nint i;\\r\\ni=iarg;\\r\\nreturn(BIO_ctrl(b,cmd,larg,(char *)&i));\\r\\n}\\r\\nchar *BIO_ptr_ctrl(BIO *b, int cmd, long larg)\\r\\n{\\r\\nchar *p=NULL;\\r\\nif (BIO_ctrl(b,cmd,larg,(char *)&p) <= 0)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(p);\\r\\n}\\r\\nlong BIO_ctrl(BIO *b, int cmd, long larg, void *parg)\\r\\n{\\r\\nlong ret;\\r\\nlong (*cb)();\\r\\nif (b == NULL) return(0);\\r\\nif ((b->method == NULL) || (b->method->ctrl == NULL))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL,BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn(-2);\\r\\n}\\r\\ncb=b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((ret=cb(b,BIO_CB_CTRL,parg,cmd,larg,1L)) <= 0))\\r\\nreturn(ret);\\r\\nret=b->method->ctrl(b,cmd,larg,parg);\\r\\nif (cb != NULL)\\r\\nret=cb(b,BIO_CB_CTRL|BIO_CB_RETURN,parg,cmd,\\r\\nlarg,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nsize_t BIO_ctrl_pending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_PENDING, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_wpending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_WPENDING, 0, NULL);\\r\\n}\\r\\nBIO *BIO_push(BIO *b, BIO *bio)\\r\\n{\\r\\nBIO *lb;\\r\\nif (b == NULL) return(bio);\\r\\nlb=b;\\r\\nwhile (lb->next_bio != NULL)\\r\\nlb=lb->next_bio;\\r\\nlb->next_bio=bio;\\r\\nif (bio != NULL)\\r\\nbio->prev_bio=lb;\\r\\nBIO_ctrl(b,BIO_CTRL_PUSH,0,NULL);\\r\\nreturn(b);\\r\\n}\\r\\nBIO *BIO_pop(BIO *b)\\r\\n{\\r\\nBIO *ret;\\r\\nif (b == NULL) return(NULL);\\r\\nret=b->next_bio;\\r\\nif (b->prev_bio != NULL)\\r\\nb->prev_bio->next_bio=b->next_bio;\\r\\nif (b->next_bio != NULL)\\r\\nb->next_bio->prev_bio=b->prev_bio;\\r\\nb->next_bio=NULL;\\r\\nb->prev_bio=NULL;\\r\\nBIO_ctrl(b,BIO_CTRL_POP,0,NULL);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_get_retry_BIO(BIO *bio, int *reason)\\r\\n{\\r\\nBIO *b,*last;\\r\\nb=last=bio;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BIO_should_retry(b)) break;\\r\\nlast=b;\\r\\nb=b->next_bio;\\r\\nif (b == NULL) break;\\r\\n}\\r\\nif (reason != NULL) *reason=last->retry_reason;\\r\\nreturn(last);\\r\\n}\\r\\nint BIO_get_retry_reason(BIO *bio)\\r\\n{\\r\\nreturn(bio->retry_reason);\\r\\n}\\r\\nBIO *BIO_find_type(BIO *bio, int type)\\r\\n{\\r\\nint mt,mask;\\r\\nmask=type&0xff;\\r\\ndo {\\r\\nif (bio->method != NULL)\\r\\n{\\r\\nmt=bio->method->type;\\r\\nif (!mask)\\r\\n{\\r\\nif (mt & type) return(bio);\\r\\n}\\r\\nelse if (mt == type)\\r\\nreturn(bio);\\r\\n}\\r\\nbio=bio->next_bio;\\r\\n} while (bio != NULL);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid BIO_free_all(BIO *bio)\\r\\n{\\r\\nBIO *b;\\r\\nint ref;\\r\\nwhile (bio != NULL)\\r\\n{\\r\\nb=bio;\\r\\nref=b->references;\\r\\nbio=bio->next_bio;\\r\\nBIO_free(b);\\r\\nif (ref > 1) break;\\r\\n}\\r\\n}\\r\\nBIO *BIO_dup_chain(BIO *in)\\r\\n{\\r\\nBIO *ret=NULL,*eoc=NULL,*bio,*new;\\r\\nfor (bio=in; bio != NULL; bio=bio->next_bio)\\r\\n{\\r\\nif ((new=BIO_new(bio->method)) == NULL) goto err;\\r\\nnew->callback=bio->callback;\\r\\nnew->cb_arg=bio->cb_arg;\\r\\nnew->init=bio->init;\\r\\nnew->shutdown=bio->shutdown;\\r\\nnew->flags=bio->flags;\\r\\nnew->num=bio->num;\\r\\nif (!BIO_dup_state(bio,(char *)new))\\r\\n{\\r\\nBIO_free(new);\\r\\ngoto err;\\r\\n}\\r\\nif (!CRYPTO_dup_ex_data(bio_meth,&new->ex_data,&bio->ex_data))\\r\\ngoto err;\\r\\nif (ret == NULL)\\r\\n{\\r\\neoc=new;\\r\\nret=eoc;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_push(eoc,new);\\r\\neoc=new;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid BIO_copy_next_retry(BIO *b)\\r\\n{\\r\\nBIO_set_flags(b,BIO_get_retry_flags(b->next_bio));\\r\\nb->retry_reason=b->next_bio->retry_reason;\\r\\n}\\r\\nint BIO_get_ex_new_index(long argl, char *argp, int (*new_func)(),\\r\\nint (*dup_func)(), void (*free_func)())\\r\\n{\\r\\nbio_meth_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(bio_meth_num-1,&bio_meth,\\r\\nargl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint BIO_set_ex_data(BIO *bio, int idx, char *data)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&(bio->ex_data),idx,data));\\r\\n}\\r\\nchar *BIO_get_ex_data(BIO *bio, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&(bio->ex_data),idx));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t_pkey_c", "target": 0, "func": "int RSA_print_fp(FILE *fp, RSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=RSA_print(b,x,off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_print(BIO *bp, RSA *x, int off)\\r\\n{\\r\\nchar str[128];\\r\\nconst char *s;\\r\\nunsigned char *m=NULL;\\r\\nint i,ret=0;\\r\\ni=RSA_size(x);\\r\\nm=(unsigned char *)Malloc((unsigned int)i+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (off)\\r\\n{\\r\\nif (off > 128) off=128;\\r\\nmemset(str,' ',off);\\r\\n}\\r\\nif (x->d != NULL)\\r\\n{\\r\\nif (off && (BIO_write(bp,str,off) <= 0)) goto err;\\r\\nif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->n))\\r\\n<= 0) goto err;\\r\\n}\\r\\nif (x->d == NULL)\\r\\nsprintf(str,\"Modulus (%d bit):\",BN_num_bits(x->n));\\r\\nelse\\r\\nstrcpy(str,\"modulus:\");\\r\\nif (!print(bp,str,x->n,m,off)) goto err;\\r\\ns=(x->d == NULL)?\"Exponent:\":\"publicExponent:\";\\r\\nif (!print(bp,s,x->e,m,off)) goto err;\\r\\nif (!print(bp,\"privateExponent:\",x->d,m,off)) goto err;\\r\\nif (!print(bp,\"prime1:\",x->p,m,off)) goto err;\\r\\nif (!print(bp,\"prime2:\",x->q,m,off)) goto err;\\r\\nif (!print(bp,\"exponent1:\",x->dmp1,m,off)) goto err;\\r\\nif (!print(bp,\"exponent2:\",x->dmq1,m,off)) goto err;\\r\\nif (!print(bp,\"coefficient:\",x->iqmp,m,off)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) Free((char *)m);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_print_fp(FILE *fp, DSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DSA_print(b,x,off);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_print(BIO *bp, DSA *x, int off)\\r\\n{\\r\\nchar str[128];\\r\\nunsigned char *m=NULL;\\r\\nint i,ret=0;\\r\\nBIGNUM *bn=NULL;\\r\\nif (x->p != NULL)\\r\\nbn=x->p;\\r\\nelse if (x->priv_key != NULL)\\r\\nbn=x->priv_key;\\r\\nelse if (x->pub_key != NULL)\\r\\nbn=x->pub_key;\\r\\nif (bn != NULL)\\r\\ni=BN_num_bytes(bn)*2;\\r\\nelse\\r\\ni=256;\\r\\nm=(unsigned char *)Malloc((unsigned int)i+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_PRINT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (off)\\r\\n{\\r\\nif (off > 128) off=128;\\r\\nmemset(str,' ',off);\\r\\n}\\r\\nif (x->priv_key != NULL)\\r\\n{\\r\\nif (off && (BIO_write(bp,str,off) <= 0)) goto err;\\r\\nif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->p))\\r\\n<= 0) goto err;\\r\\n}\\r\\nif ((x->priv_key != NULL) && !print(bp,\"priv:\",x->priv_key,m,off))\\r\\ngoto err;\\r\\nif ((x->pub_key != NULL) && !print(bp,\"pub: \",x->pub_key,m,off))\\r\\ngoto err;\\r\\nif ((x->p != NULL) && !print(bp,\"P: \",x->p,m,off)) goto err;\\r\\nif ((x->q != NULL) && !print(bp,\"Q: \",x->q,m,off)) goto err;\\r\\nif ((x->g != NULL) && !print(bp,\"G: \",x->g,m,off)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) Free((char *)m);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int print(BIO *bp, const char *number, BIGNUM *num, unsigned char *buf,\\r\\nint off)\\r\\n{\\r\\nint n,i;\\r\\nchar str[128];\\r\\nconst char *neg;\\r\\nif (num == NULL) return(1);\\r\\nneg=(num->neg)?\"-\":\"\";\\r\\nif (off)\\r\\n{\\r\\nif (off > 128) off=128;\\r\\nmemset(str,' ',off);\\r\\nif (BIO_write(bp,str,off) <= 0) return(0);\\r\\n}\\r\\nif (BN_num_bytes(num) <= BN_BYTES)\\r\\n{\\r\\nif (BIO_printf(bp,\"%s %s%lu (%s0x%lx)\\n\",number,neg,\\r\\n(unsigned long)num->d[0],neg,(unsigned long)num->d[0])\\r\\n<= 0) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]=0;\\r\\nif (BIO_printf(bp,\"%s%s\",number,\\r\\n(neg[0] == '-')?\" (Negative)\":\"\") <= 0)\\r\\nreturn(0);\\r\\nn=BN_bn2bin(num,&buf[1]);\\r\\nif (buf[1] & 0x80)\\r\\nn++;\\r\\nelse buf++;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%15) == 0)\\r\\n{\\r\\nstr[0]='\\n';\\r\\nmemset(&(str[1]),' ',off+4);\\r\\nif (BIO_write(bp,str,off+1+4) <= 0) return(0);\\r\\n}\\r\\nif (BIO_printf(bp,\"%02x%s\",buf[i],((i+1) == n)?\"\":\":\")\\r\\n<= 0) return(0);\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) return(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint DHparams_print_fp(FILE *fp, DH *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDHerr(DH_F_DHPARAMS_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DHparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DHparams_print(BIO *bp, DH *x)\\r\\n{\\r\\nunsigned char *m=NULL;\\r\\nint reason=ERR_R_BUF_LIB,i,ret=0;\\r\\ni=BN_num_bytes(x->p);\\r\\nm=(unsigned char *)Malloc((unsigned int)i+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp,\"Diffie-Hellman-Parameters: (%d bit)\\n\",\\r\\nBN_num_bits(x->p)) <= 0)\\r\\ngoto err;\\r\\nif (!print(bp,\"prime:\",x->p,m,4)) goto err;\\r\\nif (!print(bp,\"generator:\",x->g,m,4)) goto err;\\r\\nif (x->length != 0)\\r\\n{\\r\\nif (BIO_printf(bp,\" recomented-private-length: %d bits\\n\",\\r\\n(int)x->length) <= 0) goto err;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nDHerr(DH_F_DHPARAMS_PRINT,reason);\\r\\n}\\r\\nif (m != NULL) Free((char *)m);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSAparams_print_fp(FILE *fp, DSA *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSAPARAMS_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=DSAparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSAparams_print(BIO *bp, DSA *x)\\r\\n{\\r\\nunsigned char *m=NULL;\\r\\nint reason=ERR_R_BUF_LIB,i,ret=0;\\r\\ni=BN_num_bytes(x->p);\\r\\nm=(unsigned char *)Malloc((unsigned int)i+10);\\r\\nif (m == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp,\"DSA-Parameters: (%d bit)\\n\",\\r\\nBN_num_bits(x->p)) <= 0)\\r\\ngoto err;\\r\\nif (!print(bp,\"p:\",x->p,m,4)) goto err;\\r\\nif (!print(bp,\"q:\",x->q,m,4)) goto err;\\r\\nif (!print(bp,\"g:\",x->g,m,4)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (m != NULL) Free((char *)m);\\r\\nDSAerr(DSA_F_DSAPARAMS_PRINT,reason);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_err_c", "target": 1, "func": "void ERR_load_RSA_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_RSA,RSA_str_functs);\\r\\nERR_load_strings(ERR_LIB_RSA,RSA_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_eay_c", "target": 1, "func": "RSA_METHOD *RSA_PKCS1_SSLeay(void)\\r\\n{\\r\\nreturn(&rsa_pkcs1_eay_meth);\\r\\n}\\r\\nstatic int RSA_eay_public_encrypt(int flen, unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM f,ret;\\r\\nint i,j,k,num=0,r= -1;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_init(&f);\\r\\nBN_init(&ret);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nif ((buf=(unsigned char *)Malloc(num)) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\ni=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);\\r\\nbreak;\\r\\n#ifndef NO_SHA\\r\\ncase RSA_PKCS1_OAEP_PADDING:\\r\\ni=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);\\r\\nbreak;\\r\\n#endif\\r\\ncase RSA_SSLV23_PADDING:\\r\\ni=RSA_padding_add_SSLv23(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\ni=RSA_padding_add_none(buf,num,from,flen);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (i <= 0) goto err;\\r\\nif (BN_bin2bn(buf,num,&f) == NULL) goto err;\\r\\nif ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))\\r\\n{\\r\\nif ((rsa->_method_mod_n=BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set(rsa->_method_mod_n,rsa->n,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\nj=BN_num_bytes(&ret);\\r\\ni=BN_bn2bin(&ret,&(to[num-j]));\\r\\nfor (k=0; k<(num-i); k++)\\r\\nto[k]=0;\\r\\nr=num;\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&f);\\r\\nBN_clear_free(&ret);\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,num);\\r\\nFree(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_private_encrypt(int flen, unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM f,ret;\\r\\nint i,j,k,num=0,r= -1;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_init(&f);\\r\\nBN_init(&ret);\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nif ((buf=(unsigned char *)Malloc(num)) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\ni=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\ni=RSA_padding_add_none(buf,num,from,flen);\\r\\nbreak;\\r\\ncase RSA_SSLV23_PADDING:\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (i <= 0) goto err;\\r\\nif (BN_bin2bn(buf,num,&f) == NULL) goto err;\\r\\nif ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))\\r\\nRSA_blinding_on(rsa,ctx);\\r\\nif (rsa->flags & RSA_FLAG_BLINDING)\\r\\nif (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;\\r\\nif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\\r\\n((rsa->p != NULL) &&\\r\\n(rsa->q != NULL) &&\\r\\n(rsa->dmp1 != NULL) &&\\r\\n(rsa->dmq1 != NULL) &&\\r\\n(rsa->iqmp != NULL)) )\\r\\n{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }\\r\\nelse\\r\\n{\\r\\nif (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL)) goto err;\\r\\n}\\r\\nif (rsa->flags & RSA_FLAG_BLINDING)\\r\\nif (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;\\r\\nj=BN_num_bytes(&ret);\\r\\ni=BN_bn2bin(&ret,&(to[num-j]));\\r\\nfor (k=0; k<(num-i); k++)\\r\\nto[k]=0;\\r\\nr=num;\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&ret);\\r\\nBN_clear_free(&f);\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,num);\\r\\nFree(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_private_decrypt(int flen, unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM f,ret;\\r\\nint j,num=0,r= -1;\\r\\nunsigned char *p;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_init(&f);\\r\\nBN_init(&ret);\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nif ((buf=(unsigned char *)Malloc(num)) == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (flen > num)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_bin2bn(from,(int)flen,&f) == NULL) goto err;\\r\\nif ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))\\r\\nRSA_blinding_on(rsa,ctx);\\r\\nif (rsa->flags & RSA_FLAG_BLINDING)\\r\\nif (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;\\r\\nif ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||\\r\\n((rsa->p != NULL) &&\\r\\n(rsa->q != NULL) &&\\r\\n(rsa->dmp1 != NULL) &&\\r\\n(rsa->dmq1 != NULL) &&\\r\\n(rsa->iqmp != NULL)) )\\r\\n{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }\\r\\nelse\\r\\n{\\r\\nif (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))\\r\\ngoto err;\\r\\n}\\r\\nif (rsa->flags & RSA_FLAG_BLINDING)\\r\\nif (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;\\r\\np=buf;\\r\\nj=BN_bn2bin(&ret,p);\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\nr=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);\\r\\nbreak;\\r\\n#ifndef NO_SHA\\r\\ncase RSA_PKCS1_OAEP_PADDING:\\r\\nr=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);\\r\\nbreak;\\r\\n#endif\\r\\ncase RSA_SSLV23_PADDING:\\r\\nr=RSA_padding_check_SSLv23(to,num,buf,j,num);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\nr=RSA_padding_check_none(to,num,buf,j,num);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (r < 0)\\r\\nRSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&f);\\r\\nBN_clear_free(&ret);\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,num);\\r\\nFree(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_public_decrypt(int flen, unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nBIGNUM f,ret;\\r\\nint i,num=0,r= -1;\\r\\nunsigned char *p;\\r\\nunsigned char *buf=NULL;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_init(&f);\\r\\nBN_init(&ret);\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nnum=BN_num_bytes(rsa->n);\\r\\nbuf=(unsigned char *)Malloc(num);\\r\\nif (buf == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (flen > num)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_bin2bn(from,flen,&f) == NULL) goto err;\\r\\nif ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))\\r\\n{\\r\\nif ((rsa->_method_mod_n=BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set(rsa->_method_mod_n,rsa->n,ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,\\r\\nrsa->_method_mod_n)) goto err;\\r\\np=buf;\\r\\ni=BN_bn2bin(&ret,p);\\r\\nswitch (padding)\\r\\n{\\r\\ncase RSA_PKCS1_PADDING:\\r\\nr=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);\\r\\nbreak;\\r\\ncase RSA_NO_PADDING:\\r\\nr=RSA_padding_check_none(to,num,buf,i,num);\\r\\nbreak;\\r\\ndefault:\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (r < 0)\\r\\nRSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&f);\\r\\nBN_clear_free(&ret);\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,num);\\r\\nFree(buf);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nstatic int RSA_eay_mod_exp(BIGNUM *r0, BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nBIGNUM r1,m1;\\r\\nint ret=0;\\r\\nBN_CTX *ctx;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nBN_init(&m1);\\r\\nBN_init(&r1);\\r\\nif (rsa->flags & RSA_FLAG_CACHE_PRIVATE)\\r\\n{\\r\\nif (rsa->_method_mod_p == NULL)\\r\\n{\\r\\nif ((rsa->_method_mod_p=BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set(rsa->_method_mod_p,rsa->p,\\r\\nctx))\\r\\ngoto err;\\r\\n}\\r\\nif (rsa->_method_mod_q == NULL)\\r\\n{\\r\\nif ((rsa->_method_mod_q=BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set(rsa->_method_mod_q,rsa->q,\\r\\nctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_mod(&r1,I,rsa->q,ctx)) goto err;\\r\\nif (!rsa->meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx,\\r\\nrsa->_method_mod_q)) goto err;\\r\\nif (!BN_mod(&r1,I,rsa->p,ctx)) goto err;\\r\\nif (!rsa->meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx,\\r\\nrsa->_method_mod_p)) goto err;\\r\\nif (!BN_sub(r0,r0,&m1)) goto err;\\r\\nif (r0->neg)\\r\\nif (!BN_add(r0,r0,rsa->p)) goto err;\\r\\nif (!BN_mul(&r1,r0,rsa->iqmp,ctx)) goto err;\\r\\nif (!BN_mod(r0,&r1,rsa->p,ctx)) goto err;\\r\\nif (r0->neg)\\r\\nif (!BN_add(r0,r0,rsa->p)) goto err;\\r\\nif (!BN_mul(&r1,r0,rsa->q,ctx)) goto err;\\r\\nif (!BN_add(r0,&r1,&m1)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nBN_clear_free(&m1);\\r\\nBN_clear_free(&r1);\\r\\nBN_CTX_free(ctx);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int RSA_eay_init(RSA *rsa)\\r\\n{\\r\\nrsa->flags|=RSA_FLAG_CACHE_PUBLIC|RSA_FLAG_CACHE_PRIVATE;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSA_eay_finish(RSA *rsa)\\r\\n{\\r\\nif (rsa->_method_mod_n != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_n);\\r\\nif (rsa->_method_mod_p != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_p);\\r\\nif (rsa->_method_mod_q != NULL)\\r\\nBN_MONT_CTX_free(rsa->_method_mod_q);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_version_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,ret=0;\\r\\nint cflags=0,version=0,date=0,options=0,platform=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (argc == 1) version=1;\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nif (strcmp(argv[i],\"-v\") == 0)\\r\\nversion=1;\\r\\nelse if (strcmp(argv[i],\"-b\") == 0)\\r\\ndate=1;\\r\\nelse if (strcmp(argv[i],\"-f\") == 0)\\r\\ncflags=1;\\r\\nelse if (strcmp(argv[i],\"-o\") == 0)\\r\\noptions=1;\\r\\nelse if (strcmp(argv[i],\"-p\") == 0)\\r\\nplatform=1;\\r\\nelse if (strcmp(argv[i],\"-a\") == 0)\\r\\ndate=version=cflags=options=platform=1;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"usage:version -[avbofp]\\n\");\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (version) printf(\"%s\\n\",SSLeay_version(SSLEAY_VERSION));\\r\\nif (date) printf(\"%s\\n\",SSLeay_version(SSLEAY_BUILT_ON));\\r\\nif (platform) printf(\"%s\\n\",SSLeay_version(SSLEAY_PLATFORM));\\r\\nif (options)\\r\\n{\\r\\nprintf(\"options: \");\\r\\nprintf(\"%s \",BN_options());\\r\\n#ifndef NO_MD2\\r\\nprintf(\"%s \",MD2_options());\\r\\n#endif\\r\\n#ifndef NO_RC4\\r\\nprintf(\"%s \",RC4_options());\\r\\n#endif\\r\\n#ifndef NO_DES\\r\\nprintf(\"%s \",des_options());\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nprintf(\"%s \",idea_options());\\r\\n#endif\\r\\n#ifndef NO_BF\\r\\nprintf(\"%s \",BF_options());\\r\\n#endif\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (cflags) printf(\"%s\\n\",SSLeay_version(SSLEAY_CFLAGS));\\r\\nend:\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_utl_c", "target": 0, "func": "unsigned char *asc2uni (const char *asc, unsigned char **uni, int *unilen)\\r\\n{\\r\\nint ulen, i;\\r\\nunsigned char *unitmp;\\r\\nulen = strlen(asc)*2 + 2;\\r\\nif (!(unitmp = Malloc (ulen))) return NULL;\\r\\nfor (i = 0; i < ulen; i+=2) {\\r\\nunitmp[i] = 0;\\r\\nunitmp[i + 1] = asc[i>>1];\\r\\n}\\r\\nif (unilen) *unilen = ulen;\\r\\nif (uni) *uni = unitmp;\\r\\nreturn unitmp;\\r\\n}\\r\\nchar *uni2asc (unsigned char *uni, int unilen)\\r\\n{\\r\\nint asclen, i;\\r\\nchar *asctmp;\\r\\nasclen = unilen / 2;\\r\\nif (uni[unilen - 1]) asclen++;\\r\\nuni++;\\r\\nif (!(asctmp = Malloc (asclen))) return NULL;\\r\\nfor (i = 0; i < unilen; i+=2) asctmp[i>>1] = uni[i];\\r\\nasctmp[asclen - 1] = 0;\\r\\nreturn asctmp;\\r\\n}\\r\\nint i2d_PKCS12_bio(BIO *bp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_i2d_bio((int(*)())i2d_PKCS12, bp, (unsigned char *)p12);\\r\\n}\\r\\nint i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_i2d_fp((int(*)())i2d_PKCS12, fp, (unsigned char *)p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_bio(BIO *bp, PKCS12 **p12)\\r\\n{\\r\\nreturn (PKCS12 *)ASN1_d2i_bio((char *(*)())PKCS12_new,\\r\\n(char *(*)())d2i_PKCS12, bp, (unsigned char **)p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)\\r\\n{\\r\\nreturn (PKCS12 *)ASN1_d2i_fp((char *(*)())PKCS12_new,\\r\\n(char *(*)())d2i_PKCS12, fp, (unsigned char **)(p12));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_req_c", "target": 0, "func": "int i2d_X509_REQ_INFO(X509_REQ_INFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->subject, i2d_X509_NAME);\\r\\nM_ASN1_I2D_len(a->pubkey, i2d_X509_PUBKEY);\\r\\nif (a->req_kludge)\\r\\n{\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type(X509_ATTRIBUTE,a->attributes,i2d_X509_ATTRIBUTE,0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nM_ASN1_I2D_len_IMP_SET_type(X509_ATTRIBUTE,a->attributes,\\r\\ni2d_X509_ATTRIBUTE,0);\\r\\n}\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->subject, i2d_X509_NAME);\\r\\nM_ASN1_I2D_put(a->pubkey, i2d_X509_PUBKEY);\\r\\nif (a->req_kludge)\\r\\n{\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type(X509_ATTRIBUTE,a->attributes,\\r\\ni2d_X509_ATTRIBUTE,0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nM_ASN1_I2D_put_IMP_SET_type(X509_ATTRIBUTE,a->attributes,\\r\\ni2d_X509_ATTRIBUTE,0);\\r\\n}\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_REQ_INFO *d2i_X509_REQ_INFO(X509_REQ_INFO **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_REQ_INFO *,X509_REQ_INFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->subject,d2i_X509_NAME);\\r\\nM_ASN1_D2I_get(ret->pubkey,d2i_X509_PUBKEY);\\r\\nif (asn1_Finish(&c))\\r\\nret->req_kludge=1;\\r\\nelse\\r\\n{\\r\\nM_ASN1_D2I_get_IMP_set_type(X509_ATTRIBUTE,ret->attributes,\\r\\nd2i_X509_ATTRIBUTE,\\r\\nX509_ATTRIBUTE_free,0);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_REQ_INFO_free,ASN1_F_D2I_X509_REQ_INFO);\\r\\n}\\r\\nX509_REQ_INFO *X509_REQ_INFO_new(void)\\r\\n{\\r\\nX509_REQ_INFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_REQ_INFO);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->subject,X509_NAME_new);\\r\\nM_ASN1_New(ret->pubkey,X509_PUBKEY_new);\\r\\nM_ASN1_New(ret->attributes,sk_X509_ATTRIBUTE_new_null);\\r\\nret->req_kludge=0;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_REQ_INFO_NEW);\\r\\n}\\r\\nvoid X509_REQ_INFO_free(X509_REQ_INFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nX509_NAME_free(a->subject);\\r\\nX509_PUBKEY_free(a->pubkey);\\r\\nsk_X509_ATTRIBUTE_pop_free(a->attributes,X509_ATTRIBUTE_free);\\r\\nFree((char *)a);\\r\\n}\\r\\nint i2d_X509_REQ(X509_REQ *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->req_info, i2d_X509_REQ_INFO);\\r\\nM_ASN1_I2D_len(a->sig_alg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->req_info, i2d_X509_REQ_INFO);\\r\\nM_ASN1_I2D_put(a->sig_alg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ(X509_REQ **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_REQ *,X509_REQ_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->req_info,d2i_X509_REQ_INFO);\\r\\nM_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->signature,d2i_ASN1_BIT_STRING);\\r\\nM_ASN1_D2I_Finish(a,X509_REQ_free,ASN1_F_D2I_X509_REQ);\\r\\n}\\r\\nX509_REQ *X509_REQ_new(void)\\r\\n{\\r\\nX509_REQ *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_REQ);\\r\\nret->references=1;\\r\\nM_ASN1_New(ret->req_info,X509_REQ_INFO_new);\\r\\nM_ASN1_New(ret->sig_alg,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->signature,ASN1_BIT_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_REQ_NEW);\\r\\n}\\r\\nvoid X509_REQ_free(X509_REQ *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_REQ);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_REQ\",a);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_REQ_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nX509_REQ_INFO_free(a->req_info);\\r\\nX509_ALGOR_free(a->sig_alg);\\r\\nASN1_BIT_STRING_free(a->signature);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5_skey_c", "target": 0, "func": "void RC5_32_set_key(RC5_32_KEY *key, int len, unsigned char *data,\\r\\nint rounds)\\r\\n{\\r\\nRC5_32_INT L[64],l,ll,A,B,*S,k;\\r\\nint i,j,m,c,t,ii,jj;\\r\\nif ( (rounds != RC5_16_ROUNDS) &&\\r\\n(rounds != RC5_12_ROUNDS) &&\\r\\n(rounds != RC5_8_ROUNDS))\\r\\nrounds=RC5_16_ROUNDS;\\r\\nkey->rounds=rounds;\\r\\nS= &(key->data[0]);\\r\\nj=0;\\r\\nfor (i=0; i<=(len-8); i+=8)\\r\\n{\\r\\nc2l(data,l);\\r\\nL[j++]=l;\\r\\nc2l(data,l);\\r\\nL[j++]=l;\\r\\n}\\r\\nii=len-i;\\r\\nif (ii)\\r\\n{\\r\\nk=len&0x07;\\r\\nc2ln(data,l,ll,k);\\r\\nL[j+0]=l;\\r\\nL[j+1]=ll;\\r\\n}\\r\\nc=(len+3)/4;\\r\\nt=(rounds+1)*2;\\r\\nS[0]=RC5_32_P;\\r\\nfor (i=1; i<t; i++)\\r\\nS[i]=(S[i-1]+RC5_32_Q)&RC5_32_MASK;\\r\\nj=(t>c)?t:c;\\r\\nj*=3;\\r\\nii=jj=0;\\r\\nA=B=0;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nk=(S[ii]+A+B)&RC5_32_MASK;\\r\\nA=S[ii]=ROTATE_l32(k,3);\\r\\nm=(int)(A+B);\\r\\nk=(L[jj]+A+B)&RC5_32_MASK;\\r\\nB=L[jj]=ROTATE_l32(k,m);\\r\\nif (++ii >= t) ii=0;\\r\\nif (++jj >= c) jj=0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_example_c", "target": 0, "func": "int add_signed_time(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nASN1_UTCTIME *sign_time;\\r\\nsign_time=X509_gmtime_adj(NULL,0);\\r\\nPKCS7_add_signed_attribute(si,NID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,(char *)sign_time);\\r\\nreturn(1);\\r\\n}\\r\\nASN1_UTCTIME *get_signed_time(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nso=PKCS7_get_signed_attribute(si,NID_pkcs9_signingTime);\\r\\nif (so->type == V_ASN1_UTCTIME)\\r\\nreturn so->value.utctime;\\r\\nreturn NULL;\\r\\n}\\r\\nvoid add_signed_string(PKCS7_SIGNER_INFO *si, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nos=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os,str,strlen(str));\\r\\nPKCS7_add_signed_attribute(si,signed_string_nid,\\r\\nV_ASN1_OCTET_STRING,(char *)os);\\r\\n}\\r\\nint get_signed_string(PKCS7_SIGNER_INFO *si, char *buf, int len)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nASN1_OCTET_STRING *os;\\r\\nint i;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nso=PKCS7_get_signed_attribute(si,signed_string_nid);\\r\\nif (so != NULL)\\r\\n{\\r\\nif (so->type == V_ASN1_OCTET_STRING)\\r\\n{\\r\\nos=so->value.octet_string;\\r\\ni=os->length;\\r\\nif ((i+1) > len)\\r\\ni=len-1;\\r\\nmemcpy(buf,os->data,i);\\r\\nreturn(i);\\r\\n}\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint add_signed_seq2string(PKCS7_SIGNER_INFO *si, char *str1, char *str2)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\nASN1_STRING *seq;\\r\\nunsigned char *data;\\r\\nint i,total;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nos1=ASN1_OCTET_STRING_new();\\r\\nos2=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os1,str1,strlen(str1));\\r\\nASN1_OCTET_STRING_set(os2,str1,strlen(str1));\\r\\ni =i2d_ASN1_OCTET_STRING(os1,NULL);\\r\\ni+=i2d_ASN1_OCTET_STRING(os2,NULL);\\r\\ntotal=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\ndata=malloc(total);\\r\\np=data;\\r\\nASN1_put_object(&p,1,i,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_OCTET_STRING(os1,&p);\\r\\ni2d_ASN1_OCTET_STRING(os2,&p);\\r\\nseq=ASN1_STRING_new();\\r\\nASN1_STRING_set(seq,data,total);\\r\\nfree(data);\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nPKCS7_add_signed_attribute(si,signed_seq2string_nid,\\r\\nV_ASN1_SEQUENCE,(char *)seq);\\r\\nreturn(1);\\r\\n}\\r\\nint get_signed_seq2string(PKCS7_SIGNER_INFO *si, char **str1, char **str2)\\r\\n{\\r\\nASN1_TYPE *so;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nso=PKCS7_get_signed_attribute(si,signed_seq2string_nid);\\r\\nif (so && (so->type == V_ASN1_SEQUENCE))\\r\\n{\\r\\nASN1_CTX c;\\r\\nASN1_STRING *s;\\r\\nlong length;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\ns=so->value.sequence;\\r\\nc.p=ASN1_STRING_data(s);\\r\\nc.max=c.p+ASN1_STRING_length(s);\\r\\nif (!asn1_GetSequence(&c,&length)) goto err;\\r\\nc.q=c.p;\\r\\nif ((os1=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nc.q=c.p;\\r\\nif ((os2=d2i_ASN1_OCTET_STRING(NULL,&c.p,c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nif (!asn1_Finish(&c)) goto err;\\r\\n*str1=malloc(os1->length+1);\\r\\n*str2=malloc(os2->length+1);\\r\\nmemcpy(*str1,os1->data,os1->length);\\r\\nmemcpy(*str2,os2->data,os2->length);\\r\\n(*str1)[os1->length]='\\0';\\r\\n(*str2)[os2->length]='\\0';\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nreturn(1);\\r\\n}\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nX509_ATTRIBUTE *create_time(void)\\r\\n{\\r\\nASN1_UTCTIME *sign_time;\\r\\nX509_ATTRIBUTE *ret;\\r\\nsign_time=X509_gmtime_adj(NULL,0);\\r\\nret=X509_ATTRIBUTE_create(NID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,(char *)sign_time);\\r\\nreturn(ret);\\r\\n}\\r\\nX509_ATTRIBUTE *create_string(char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nX509_ATTRIBUTE *ret;\\r\\nif (signed_string_nid == -1)\\r\\nsigned_string_nid=\\r\\nOBJ_create(\"1.2.3.4.5\",\"OID_example\",\"Our example OID\");\\r\\nos=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os,str,strlen(str));\\r\\nret=X509_ATTRIBUTE_create(signed_string_nid,\\r\\nV_ASN1_OCTET_STRING,(char *)os);\\r\\nreturn(ret);\\r\\n}\\r\\nX509_ATTRIBUTE *add_seq2string(PKCS7_SIGNER_INFO *si, char *str1, char *str2)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_OCTET_STRING *os1,*os2;\\r\\nASN1_STRING *seq;\\r\\nX509_ATTRIBUTE *ret;\\r\\nunsigned char *data;\\r\\nint i,total;\\r\\nif (signed_seq2string_nid == -1)\\r\\nsigned_seq2string_nid=\\r\\nOBJ_create(\"1.9.9999\",\"OID_example\",\"Our example OID\");\\r\\nos1=ASN1_OCTET_STRING_new();\\r\\nos2=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(os1,str1,strlen(str1));\\r\\nASN1_OCTET_STRING_set(os2,str1,strlen(str1));\\r\\ni =i2d_ASN1_OCTET_STRING(os1,NULL);\\r\\ni+=i2d_ASN1_OCTET_STRING(os2,NULL);\\r\\ntotal=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\ndata=malloc(total);\\r\\np=data;\\r\\nASN1_put_object(&p,1,i,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_OCTET_STRING(os1,&p);\\r\\ni2d_ASN1_OCTET_STRING(os2,&p);\\r\\nseq=ASN1_STRING_new();\\r\\nASN1_STRING_set(seq,data,total);\\r\\nfree(data);\\r\\nASN1_OCTET_STRING_free(os1);\\r\\nASN1_OCTET_STRING_free(os2);\\r\\nret=X509_ATTRIBUTE_create(signed_seq2string_nid,\\r\\nV_ASN1_SEQUENCE,(char *)seq);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_pkt_c", "target": 0, "func": "int ssl2_peek(SSL *s, char *buf, int len)\\r\\n{\\r\\nint ret;\\r\\nret=ssl2_read(s,buf,len);\\r\\nif (ret > 0)\\r\\n{\\r\\ns->s2->ract_data_length+=ret;\\r\\ns->s2->ract_data-=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl2_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nint n;\\r\\nunsigned char mac[MAX_MAC_SIZE];\\r\\nunsigned char *p;\\r\\nint i;\\r\\nunsigned int mac_size=0;\\r\\nssl2_read_again:\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nclear_sys_error();\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (len <= 0) return(len);\\r\\nif (s->s2->ract_data_length != 0)\\r\\n{\\r\\nif (len > s->s2->ract_data_length)\\r\\nn=s->s2->ract_data_length;\\r\\nelse\\r\\nn=len;\\r\\nmemcpy(buf,s->s2->ract_data,(unsigned int)n);\\r\\ns->s2->ract_data_length-=n;\\r\\ns->s2->ract_data+=n;\\r\\nif (s->s2->ract_data_length == 0)\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nreturn(n);\\r\\n}\\r\\nif (s->rstate == SSL_ST_READ_HEADER)\\r\\n{\\r\\nif (s->first_packet)\\r\\n{\\r\\nn=read_n(s,5,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\\r\\nif (n <= 0) return(n);\\r\\ns->first_packet=0;\\r\\np=s->packet;\\r\\nif (!((p[0] & 0x80) && (\\r\\n(p[2] == SSL2_MT_CLIENT_HELLO) ||\\r\\n(p[2] == SSL2_MT_SERVER_HELLO))))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ,SSL_R_NON_SSLV2_INITIAL_PACKET);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=read_n(s,2,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\\r\\nif (n <= 0) return(n);\\r\\n}\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\np=s->packet;\\r\\ns->s2->escape=0;\\r\\ns->s2->rlength=(((unsigned int)p[0])<<8)|((unsigned int)p[1]);\\r\\nif ((p[0] & TWO_BYTE_BIT))\\r\\n{\\r\\ns->s2->three_byte_header=0;\\r\\ns->s2->rlength&=TWO_BYTE_MASK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s2->three_byte_header=1;\\r\\ns->s2->rlength&=THREE_BYTE_MASK;\\r\\ns->s2->escape=((p[0] & SEC_ESC_BIT))?1:0;\\r\\n}\\r\\n}\\r\\nif (s->rstate == SSL_ST_READ_BODY)\\r\\n{\\r\\nn=s->s2->rlength+2+s->s2->three_byte_header;\\r\\nif (n > (int)s->packet_length)\\r\\n{\\r\\nn-=s->packet_length;\\r\\ni=read_n(s,(unsigned int)n,(unsigned int)n,1);\\r\\nif (i <= 0) return(i);\\r\\n}\\r\\np= &(s->packet[2]);\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nif (s->s2->three_byte_header)\\r\\ns->s2->padding= *(p++);\\r\\nelse s->s2->padding=0;\\r\\nif (s->s2->clear_text)\\r\\n{\\r\\ns->s2->mac_data=p;\\r\\ns->s2->ract_data=p;\\r\\ns->s2->pad_data=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmac_size=EVP_MD_size(s->read_hash);\\r\\ns->s2->mac_data=p;\\r\\ns->s2->ract_data= &p[mac_size];\\r\\ns->s2->pad_data= &p[mac_size+\\r\\ns->s2->rlength-s->s2->padding];\\r\\n}\\r\\ns->s2->ract_data_length=s->s2->rlength;\\r\\nif ((!s->s2->clear_text) &&\\r\\n(s->s2->rlength >= mac_size))\\r\\n{\\r\\nssl2_enc(s,0);\\r\\ns->s2->ract_data_length-=mac_size;\\r\\nssl2_mac(s,mac,0);\\r\\ns->s2->ract_data_length-=s->s2->padding;\\r\\nif ( (memcmp(mac,s->s2->mac_data,\\r\\n(unsigned int)mac_size) != 0) ||\\r\\n(s->s2->rlength%EVP_CIPHER_CTX_block_size(s->enc_read_ctx) != 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ,SSL_R_BAD_MAC_DECODE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nINC32(s->s2->read_sequence);\\r\\n#if 1\\r\\ngoto ssl2_read_again;\\r\\n#else\\r\\nif (s->s2->ract_data_length == 0)\\r\\nreturn(0);\\r\\nreturn(ssl2_read(s,buf,len));\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_READ,SSL_R_BAD_STATE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstatic int read_n(SSL *s, unsigned int n, unsigned int max,\\r\\nunsigned int extend)\\r\\n{\\r\\nint i,off,newb;\\r\\nif (s->s2->rbuf_left >= (int)n)\\r\\n{\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\n{\\r\\ns->packet= &(s->s2->rbuf[s->s2->rbuf_offs]);\\r\\ns->packet_length=n;\\r\\n}\\r\\ns->s2->rbuf_left-=n;\\r\\ns->s2->rbuf_offs+=n;\\r\\nreturn(n);\\r\\n}\\r\\nif (!s->read_ahead) max=n;\\r\\nif (max > (unsigned int)(SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2))\\r\\nmax=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2;\\r\\noff=0;\\r\\nif ((s->s2->rbuf_left != 0) || ((s->packet_length != 0) && extend))\\r\\n{\\r\\nnewb=s->s2->rbuf_left;\\r\\nif (extend)\\r\\n{\\r\\noff=s->packet_length;\\r\\nif (s->packet != s->s2->rbuf)\\r\\nmemcpy(s->s2->rbuf,s->packet,\\r\\n(unsigned int)newb+off);\\r\\n}\\r\\nelse if (s->s2->rbuf_offs != 0)\\r\\n{\\r\\nmemcpy(s->s2->rbuf,&(s->s2->rbuf[s->s2->rbuf_offs]),\\r\\n(unsigned int)newb);\\r\\ns->s2->rbuf_offs=0;\\r\\n}\\r\\ns->s2->rbuf_left=0;\\r\\n}\\r\\nelse\\r\\nnewb=0;\\r\\ns->packet=s->s2->rbuf;\\r\\nwhile (newb < (int)n)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\ni=BIO_read(s->rbio,(char *)&(s->s2->rbuf[off+newb]),\\r\\nmax-newb);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_READ_N,SSL_R_READ_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\n#ifdef PKT_DEBUG\\r\\nif (s->debug & 0x01) sleep(1);\\r\\n#endif\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s2->rbuf_left+=newb;\\r\\nreturn(i);\\r\\n}\\r\\nnewb+=i;\\r\\n}\\r\\nif (newb > (int)n)\\r\\n{\\r\\ns->s2->rbuf_offs=n+off;\\r\\ns->s2->rbuf_left=newb-n;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s2->rbuf_offs=0;\\r\\ns->s2->rbuf_left=0;\\r\\n}\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\ns->packet_length=n;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(n);\\r\\n}\\r\\nint ssl2_write(SSL *s, const void *_buf, int len)\\r\\n{\\r\\nconst unsigned char *buf=_buf;\\r\\nunsigned int n,tot;\\r\\nint i;\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_WRITE,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (s->error)\\r\\n{\\r\\nssl2_write_error(s);\\r\\nif (s->error)\\r\\nreturn(-1);\\r\\n}\\r\\nclear_sys_error();\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif (len <= 0) return(len);\\r\\ntot=s->s2->wnum;\\r\\ns->s2->wnum=0;\\r\\nn=(len-tot);\\r\\nfor (;;)\\r\\n{\\r\\ni=do_ssl_write(s,&(buf[tot]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s2->wnum=tot;\\r\\nreturn(i);\\r\\n}\\r\\nif ((i == (int)n) ||\\r\\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))\\r\\n{\\r\\nreturn(tot+i);\\r\\n}\\r\\nn-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nstatic int write_pending(SSL *s, const unsigned char *buf, unsigned int len)\\r\\n{\\r\\nint i;\\r\\nif ((s->s2->wpend_tot > (int)len) ||\\r\\n((s->s2->wpend_buf != buf) &&\\r\\n!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)))\\r\\n{\\r\\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,\\r\\n(char *)&(s->s2->write_ptr[s->s2->wpend_off]),\\r\\n(unsigned int)s->s2->wpend_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_WRITE_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\n#ifdef PKT_DEBUG\\r\\nif (s->debug & 0x01) sleep(1);\\r\\n#endif\\r\\nif (i == s->s2->wpend_len)\\r\\n{\\r\\ns->s2->wpend_len=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(s->s2->wpend_ret);\\r\\n}\\r\\nelse if (i <= 0)\\r\\nreturn(i);\\r\\ns->s2->wpend_off+=i;\\r\\ns->s2->wpend_len-=i;\\r\\n}\\r\\n}\\r\\nstatic int do_ssl_write(SSL *s, const unsigned char *buf, unsigned int len)\\r\\n{\\r\\nunsigned int j,k,olen,p,mac_size,bs;\\r\\nregister unsigned char *pp;\\r\\nolen=len;\\r\\nif (s->s2->wpend_len != 0) return(write_pending(s,buf,len));\\r\\nif (s->s2->clear_text)\\r\\nmac_size=0;\\r\\nelse\\r\\nmac_size=EVP_MD_size(s->write_hash);\\r\\nif (s->s2->clear_text)\\r\\n{\\r\\nif (len > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\\r\\nlen=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\\r\\np=0;\\r\\ns->s2->three_byte_header=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbs=EVP_CIPHER_CTX_block_size(s->enc_read_ctx);\\r\\nj=len+mac_size;\\r\\nif ((j > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) &&\\r\\n(!s->s2->escape))\\r\\n{\\r\\nif (j > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\\r\\nj=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\\r\\nk=j-(j%bs);\\r\\nlen=k-mac_size;\\r\\ns->s2->three_byte_header=0;\\r\\np=0;\\r\\n}\\r\\nelse if ((bs <= 1) && (!s->s2->escape))\\r\\n{\\r\\ns->s2->three_byte_header=0;\\r\\np=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\np=(j%bs);\\r\\np=(p == 0)?0:(bs-p);\\r\\nif (s->s2->escape)\\r\\ns->s2->three_byte_header=1;\\r\\nelse\\r\\ns->s2->three_byte_header=(p == 0)?0:1;\\r\\n}\\r\\n}\\r\\ns->s2->wlength=len;\\r\\ns->s2->padding=p;\\r\\ns->s2->mac_data= &(s->s2->wbuf[3]);\\r\\ns->s2->wact_data= &(s->s2->wbuf[3+mac_size]);\\r\\nmemcpy(s->s2->wact_data,buf,len);\\r\\n#ifdef PURIFY\\r\\nif (p)\\r\\nmemset(&(s->s2->wact_data[len]),0,p);\\r\\n#endif\\r\\nif (!s->s2->clear_text)\\r\\n{\\r\\ns->s2->wact_data_length=len+p;\\r\\nssl2_mac(s,s->s2->mac_data,1);\\r\\ns->s2->wlength+=p+mac_size;\\r\\nssl2_enc(s,1);\\r\\n}\\r\\ns->s2->wpend_len=s->s2->wlength;\\r\\nif (s->s2->three_byte_header)\\r\\n{\\r\\npp=s->s2->mac_data;\\r\\npp-=3;\\r\\npp[0]=(s->s2->wlength>>8)&(THREE_BYTE_MASK>>8);\\r\\nif (s->s2->escape) pp[0]|=SEC_ESC_BIT;\\r\\npp[1]=s->s2->wlength&0xff;\\r\\npp[2]=s->s2->padding;\\r\\ns->s2->wpend_len+=3;\\r\\n}\\r\\nelse\\r\\n{\\r\\npp=s->s2->mac_data;\\r\\npp-=2;\\r\\npp[0]=((s->s2->wlength>>8)&(TWO_BYTE_MASK>>8))|TWO_BYTE_BIT;\\r\\npp[1]=s->s2->wlength&0xff;\\r\\ns->s2->wpend_len+=2;\\r\\n}\\r\\ns->s2->write_ptr=pp;\\r\\nINC32(s->s2->write_sequence);\\r\\ns->s2->wpend_tot=olen;\\r\\ns->s2->wpend_buf=buf;\\r\\ns->s2->wpend_ret=len;\\r\\ns->s2->wpend_off=0;\\r\\nreturn(write_pending(s,buf,olen));\\r\\n}\\r\\nint ssl2_part_read(SSL *s, unsigned long f, int i)\\r\\n{\\r\\nunsigned char *p;\\r\\nint j;\\r\\nif ((s->init_num == 0) && (i >= 3))\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (p[0] == SSL2_MT_ERROR)\\r\\n{\\r\\nj=(p[1]<<8)|p[2];\\r\\nSSLerr((int)f,ssl_mt_error(j));\\r\\n}\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->init_num+=i;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nint ssl2_do_write(SSL *s)\\r\\n{\\r\\nint ret;\\r\\nret=ssl2_write(s,&s->init_buf->data[s->init_off],s->init_num);\\r\\nif (ret == s->init_num)\\r\\nreturn(1);\\r\\nif (ret < 0)\\r\\nreturn(-1);\\r\\ns->init_off+=ret;\\r\\ns->init_num-=ret;\\r\\nreturn(0);\\r\\n}\\r\\nstatic int ssl_mt_error(int n)\\r\\n{\\r\\nint ret;\\r\\nswitch (n)\\r\\n{\\r\\ncase SSL2_PE_NO_CIPHER:\\r\\nret=SSL_R_PEER_ERROR_NO_CIPHER;\\r\\nbreak;\\r\\ncase SSL2_PE_NO_CERTIFICATE:\\r\\nret=SSL_R_PEER_ERROR_NO_CERTIFICATE;\\r\\nbreak;\\r\\ncase SSL2_PE_BAD_CERTIFICATE:\\r\\nret=SSL_R_PEER_ERROR_CERTIFICATE;\\r\\nbreak;\\r\\ncase SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE:\\r\\nret=SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE;\\r\\nbreak;\\r\\ndefault:\\r\\nret=SSL_R_UNKNOWN_REMOTE_ERROR_TYPE;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_sign_c", "target": 0, "func": "DSA_SIG * DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nBIGNUM *kinv=NULL,*r=NULL,*s=NULL;\\r\\nBIGNUM m;\\r\\nBIGNUM xr;\\r\\nBN_CTX *ctx=NULL;\\r\\nint i,reason=ERR_R_BN_LIB;\\r\\nDSA_SIG *ret=NULL;\\r\\nBN_init(&m);\\r\\nBN_init(&xr);\\r\\ns=BN_new();\\r\\nif (s == NULL) goto err;\\r\\ni=BN_num_bytes(dsa->q);\\r\\nif ((dlen > i) || (dlen > 50))\\r\\n{\\r\\nreason=DSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE;\\r\\ngoto err;\\r\\n}\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nif ((dsa->kinv == NULL) || (dsa->r == NULL))\\r\\n{\\r\\nif (!DSA_sign_setup(dsa,ctx,&kinv,&r)) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nkinv=dsa->kinv;\\r\\ndsa->kinv=NULL;\\r\\nr=dsa->r;\\r\\ndsa->r=NULL;\\r\\n}\\r\\nif (BN_bin2bn(dgst,dlen,&m) == NULL) goto err;\\r\\nif (!BN_mod_mul(&xr,dsa->priv_key,r,dsa->q,ctx)) goto err;\\r\\nif (!BN_add(s, &xr, &m)) goto err;\\r\\nif (BN_cmp(s,dsa->q) > 0)\\r\\nBN_sub(s,s,dsa->q);\\r\\nif (!BN_mod_mul(s,s,kinv,dsa->q,ctx)) goto err;\\r\\nret=DSA_SIG_new();\\r\\nif (ret == NULL) goto err;\\r\\nret->r = r;\\r\\nret->s = s;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_DO_SIGN,reason);\\r\\nBN_free(r);\\r\\nBN_free(s);\\r\\n}\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_clear_free(&m);\\r\\nBN_clear_free(&xr);\\r\\nif (kinv != NULL)\\r\\nBN_clear_free(kinv);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_sign(int type, const unsigned char *dgst, int dlen, unsigned char *sig,\\r\\nunsigned int *siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\ns=DSA_do_sign(dgst,dlen,dsa);\\r\\nif (s == NULL)\\r\\n{\\r\\n*siglen=0;\\r\\nreturn(0);\\r\\n}\\r\\n*siglen=i2d_DSA_SIG(s,&sig);\\r\\nDSA_SIG_free(s);\\r\\nreturn(1);\\r\\n}\\r\\nint DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM k,*kinv=NULL,*r=NULL;\\r\\nint ret=0;\\r\\nif (ctx_in == NULL)\\r\\n{\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nctx=ctx_in;\\r\\nBN_init(&k);\\r\\nif ((r=BN_new()) == NULL) goto err;\\r\\nkinv=NULL;\\r\\nfor (;;)\\r\\n{\\r\\nif (!BN_rand(&k, BN_num_bits(dsa->q), 1, 0)) goto err;\\r\\nif (BN_cmp(&k,dsa->q) >= 0)\\r\\nBN_sub(&k,&k,dsa->q);\\r\\nif (!BN_is_zero(&k)) break;\\r\\n}\\r\\nif ((dsa->method_mont_p == NULL) && (dsa->flags & DSA_FLAG_CACHE_MONT_P))\\r\\n{\\r\\nif ((dsa->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set((BN_MONT_CTX *)dsa->method_mont_p,\\r\\ndsa->p,ctx)) goto err;\\r\\n}\\r\\nif (!BN_mod_exp_mont(r,dsa->g,&k,dsa->p,ctx,\\r\\n(BN_MONT_CTX *)dsa->method_mont_p)) goto err;\\r\\nif (!BN_mod(r,r,dsa->q,ctx)) goto err;\\r\\nif ((kinv=BN_mod_inverse(NULL,&k,dsa->q,ctx)) == NULL) goto err;\\r\\nif (*kinvp != NULL) BN_clear_free(*kinvp);\\r\\n*kinvp=kinv;\\r\\nkinv=NULL;\\r\\nif (*rp != NULL) BN_clear_free(*rp);\\r\\n*rp=r;\\r\\nret=1;\\r\\nerr:\\r\\nif (!ret)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP,ERR_R_BN_LIB);\\r\\nif (kinv != NULL) BN_clear_free(kinv);\\r\\nif (r != NULL) BN_clear_free(r);\\r\\n}\\r\\nif (ctx_in == NULL) BN_CTX_free(ctx);\\r\\nif (kinv != NULL) BN_clear_free(kinv);\\r\\nBN_clear_free(&k);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_r2x_c", "target": 0, "func": "X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey)\\r\\n{\\r\\nX509 *ret=NULL;\\r\\nX509_CINF *xi=NULL;\\r\\nX509_NAME *xn;\\r\\nif ((ret=X509_new()) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_TO_X509,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nxi=ret->cert_info;\\r\\nif (sk_X509_ATTRIBUTE_num(r->req_info->attributes) != 0)\\r\\n{\\r\\nif ((xi->version=ASN1_INTEGER_new()) == NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(xi->version,2)) goto err;\\r\\n}\\r\\nxn=X509_REQ_get_subject_name(r);\\r\\nX509_set_subject_name(ret,X509_NAME_dup(xn));\\r\\nX509_set_issuer_name(ret,X509_NAME_dup(xn));\\r\\nX509_gmtime_adj(xi->validity->notBefore,0);\\r\\nX509_gmtime_adj(xi->validity->notAfter,(long)60*60*24*days);\\r\\nX509_set_pubkey(ret,X509_REQ_get_pubkey(r));\\r\\nif (!X509_sign(ret,pkey,EVP_md5()))\\r\\ngoto err;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nX509_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_d2i_fp_c", "target": 1, "func": "char *ASN1_d2i_fp(char *(*xnew)(), char *(*d2i)(), FILE *in,\\r\\nunsigned char **x)\\r\\n{\\r\\nBIO *b;\\r\\nchar *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_FP,ERR_R_BUF_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO_set_fp(b,in,BIO_NOCLOSE);\\r\\nret=ASN1_d2i_bio(xnew,d2i,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nchar *ASN1_d2i_bio(char *(*xnew)(), char *(*d2i)(), BIO *in,\\r\\nunsigned char **x)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nchar *ret=NULL;\\r\\nASN1_CTX c;\\r\\nint want=HEADER_SIZE;\\r\\nint eos=0;\\r\\nint off=0;\\r\\nint len=0;\\r\\nb=BUF_MEM_new();\\r\\nif (b == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nERR_clear_error();\\r\\nfor (;;)\\r\\n{\\r\\nif (want >= (len-off))\\r\\n{\\r\\nwant-=(len-off);\\r\\nif (!BUF_MEM_grow(b,len+want))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=BIO_read(in,&(b->data[len]),want);\\r\\nif ((i < 0) && ((len-off) == 0))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_BIO,ASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nif (i > 0)\\r\\nlen+=i;\\r\\n}\\r\\np=(unsigned char *)&(b->data[off]);\\r\\nc.p=p;\\r\\nc.inf=ASN1_get_object(&(c.p),&(c.slen),&(c.tag),&(c.xclass),\\r\\nlen-off);\\r\\nif (c.inf & 0x80)\\r\\n{\\r\\nunsigned long e;\\r\\ne=ERR_GET_REASON(ERR_peek_error());\\r\\nif (e != ASN1_R_TOO_LONG)\\r\\ngoto err;\\r\\nelse\\r\\nERR_get_error();\\r\\n}\\r\\ni=c.p-p;\\r\\noff+=i;\\r\\nif (c.inf & 1)\\r\\n{\\r\\neos++;\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\nelse if (eos && (c.slen == 0) && (c.tag == V_ASN1_EOC))\\r\\n{\\r\\neos--;\\r\\nif (eos <= 0)\\r\\nbreak;\\r\\nelse\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\nelse\\r\\n{\\r\\nwant=(int)c.slen;\\r\\nif (want > (len-off))\\r\\n{\\r\\nwant-=(len-off);\\r\\nif (!BUF_MEM_grow(b,len+want))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=BIO_read(in,&(b->data[len]),want);\\r\\nif (i <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_D2I_BIO,ASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nlen+=i;\\r\\n}\\r\\noff+=(int)c.slen;\\r\\nif (eos <= 0)\\r\\n{\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\nwant=HEADER_SIZE;\\r\\n}\\r\\n}\\r\\np=(unsigned char *)b->data;\\r\\nret=d2i(x,&p,off);\\r\\nerr:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_pr_c", "target": 0, "func": "int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nif (a->type == EVP_PKEY_RSA)\\r\\n{\\r\\nreturn(i2d_RSAPrivateKey(a->pkey.rsa,pp));\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (a->type == EVP_PKEY_DSA)\\r\\n{\\r\\nreturn(i2d_DSAPrivateKey(a->pkey.dsa,pp));\\r\\n}\\r\\n#endif\\r\\nASN1err(ASN1_F_I2D_PRIVATEKEY,ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_lib_c", "target": 1, "func": "int SSL_clear(SSL *s)\\r\\n{\\r\\nint state;\\r\\nif (s->method == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CLEAR,SSL_R_NO_METHOD_SPECIFIED);\\r\\nreturn(0);\\r\\n}\\r\\ns->error=0;\\r\\ns->hit=0;\\r\\ns->shutdown=0;\\r\\n#if 0\\r\\nif (s->new_session) return(1);\\r\\n#endif\\r\\nstate=s->state;\\r\\ns->type=0;\\r\\ns->state=SSL_ST_BEFORE|((s->server)?SSL_ST_ACCEPT:SSL_ST_CONNECT);\\r\\ns->version=s->method->version;\\r\\ns->client_version=s->version;\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->read_ahead=s->ctx->read_ahead;\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\nif (ssl_clear_bad_session(s))\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\ns->first_packet=0;\\r\\n#if 1\\r\\nif ((s->session == NULL) && (s->method != s->ctx->method))\\r\\n{\\r\\ns->method->ssl_free(s);\\r\\ns->method=s->ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ns->method->ssl_clear(s);\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_CTX_set_ssl_version(SSL_CTX *ctx,SSL_METHOD *meth)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nctx->method=meth;\\r\\nsk=ssl_create_cipher_list(ctx->method,&(ctx->cipher_list),\\r\\n&(ctx->cipher_list_by_id),SSL_DEFAULT_CIPHER_LIST);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSSL *SSL_new(SSL_CTX *ctx)\\r\\n{\\r\\nSSL *s;\\r\\nif (ctx == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_NEW,SSL_R_NULL_SSL_CTX);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (ctx->method == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_NEW,SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);\\r\\nreturn(NULL);\\r\\n}\\r\\ns=(SSL *)Malloc(sizeof(SSL));\\r\\nif (s == NULL) goto err;\\r\\nmemset(s,0,sizeof(SSL));\\r\\nif (ctx->cert != NULL)\\r\\n{\\r\\ns->cert = ssl_cert_dup(ctx->cert);\\r\\nif (s->cert == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\ns->cert=NULL;\\r\\ns->sid_ctx_length=ctx->sid_ctx_length;\\r\\nmemcpy(&s->sid_ctx,&ctx->sid_ctx,sizeof(s->sid_ctx));\\r\\ns->verify_mode=ctx->verify_mode;\\r\\ns->verify_depth=ctx->verify_depth;\\r\\ns->verify_callback=ctx->default_verify_callback;\\r\\nCRYPTO_add(&ctx->references,1,CRYPTO_LOCK_SSL_CTX);\\r\\ns->ctx=ctx;\\r\\ns->verify_result=X509_V_OK;\\r\\ns->method=ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\ngoto err;\\r\\ns->quiet_shutdown=ctx->quiet_shutdown;\\r\\ns->references=1;\\r\\ns->server=(ctx->method->ssl_accept == ssl_undefined_function)?0:1;\\r\\ns->options=ctx->options;\\r\\ns->mode=ctx->mode;\\r\\nSSL_clear(s);\\r\\nCRYPTO_new_ex_data(ssl_meth,(char *)s,&s->ex_data);\\r\\nreturn(s);\\r\\nerr:\\r\\nif (s != NULL)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nssl_cert_free(s->cert);\\r\\nif (s->ctx != NULL)\\r\\nSSL_CTX_free(s->ctx);\\r\\nFree(s);\\r\\n}\\r\\nSSLerr(SSL_F_SSL_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nint SSL_CTX_set_session_id_context(SSL_CTX *ctx,const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nctx->sid_ctx_length=sid_ctx_len;\\r\\nmemcpy(ctx->sid_ctx,sid_ctx,sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_session_id_context(SSL *ssl,const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif(sid_ctx_len > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nssl->sid_ctx_length=sid_ctx_len;\\r\\nmemcpy(ssl->sid_ctx,sid_ctx,sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nvoid SSL_free(SSL *s)\\r\\n{\\r\\nint i;\\r\\nif(s == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&s->references,-1,CRYPTO_LOCK_SSL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL\",s);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"SSL_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(ssl_meth,(char *)s,&s->ex_data);\\r\\nif (s->bbio != NULL)\\r\\n{\\r\\nif (s->bbio == s->wbio)\\r\\n{\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio=NULL;\\r\\n}\\r\\nif (s->rbio != NULL)\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != s->rbio))\\r\\nBIO_free_all(s->wbio);\\r\\nif (s->init_buf != NULL) BUF_MEM_free(s->init_buf);\\r\\nif (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);\\r\\nif (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);\\r\\nif (s->session != NULL)\\r\\n{\\r\\nssl_clear_bad_session(s);\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\nif (s->cert != NULL) ssl_cert_free(s->cert);\\r\\nif (s->ctx) SSL_CTX_free(s->ctx);\\r\\nif (s->client_CA != NULL)\\r\\nsk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);\\r\\nif (s->method != NULL) s->method->ssl_free(s);\\r\\nFree((char *)s);\\r\\n}\\r\\nvoid SSL_set_bio(SSL *s,BIO *rbio,BIO *wbio)\\r\\n{\\r\\nif (s->bbio != NULL)\\r\\n{\\r\\nif (s->wbio == s->bbio)\\r\\n{\\r\\ns->wbio=s->wbio->next_bio;\\r\\ns->bbio->next_bio=NULL;\\r\\n}\\r\\n}\\r\\nif ((s->rbio != NULL) && (s->rbio != rbio))\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))\\r\\nBIO_free_all(s->wbio);\\r\\ns->rbio=rbio;\\r\\ns->wbio=wbio;\\r\\n}\\r\\nBIO *SSL_get_rbio(SSL *s)\\r\\n{ return(s->rbio); }\\r\\nBIO *SSL_get_wbio(SSL *s)\\r\\n{ return(s->wbio); }\\r\\nint SSL_get_fd(SSL *s)\\r\\n{\\r\\nint ret= -1;\\r\\nBIO *b,*r;\\r\\nb=SSL_get_rbio(s);\\r\\nr=BIO_find_type(b,BIO_TYPE_DESCRIPTOR);\\r\\nif (r != NULL)\\r\\nBIO_get_fd(r,&ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_fd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_FD,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,bio,bio);\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_wfd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nif ((s->rbio == NULL) || (BIO_method_type(s->rbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->rbio,NULL) != fd))\\r\\n{\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{ SSLerr(SSL_F_SSL_SET_WFD,ERR_R_BUF_LIB); goto err; }\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,SSL_get_rbio(s),bio);\\r\\n}\\r\\nelse\\r\\nSSL_set_bio(s,SSL_get_rbio(s),SSL_get_rbio(s));\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_set_rfd(SSL *s,int fd)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *bio=NULL;\\r\\nif ((s->wbio == NULL) || (BIO_method_type(s->wbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->wbio,NULL) != fd))\\r\\n{\\r\\nbio=BIO_new(BIO_s_socket());\\r\\nif (bio == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_RFD,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio,fd,BIO_NOCLOSE);\\r\\nSSL_set_bio(s,bio,SSL_get_wbio(s));\\r\\n}\\r\\nelse\\r\\nSSL_set_bio(s,SSL_get_wbio(s),SSL_get_wbio(s));\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_get_verify_mode(SSL *s)\\r\\n{\\r\\nreturn(s->verify_mode);\\r\\n}\\r\\nint SSL_get_verify_depth(SSL *s)\\r\\n{\\r\\nreturn(s->verify_depth);\\r\\n}\\r\\nint SSL_CTX_get_verify_mode(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->verify_mode);\\r\\n}\\r\\nint SSL_CTX_get_verify_depth(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->verify_depth);\\r\\n}\\r\\nvoid SSL_set_verify(SSL *s,int mode,\\r\\nint (*callback)(int ok,X509_STORE_CTX *ctx))\\r\\n{\\r\\ns->verify_mode=mode;\\r\\nif (callback != NULL)\\r\\ns->verify_callback=callback;\\r\\n}\\r\\nvoid SSL_set_verify_depth(SSL *s,int depth)\\r\\n{\\r\\ns->verify_depth=depth;\\r\\n}\\r\\nvoid SSL_set_read_ahead(SSL *s,int yes)\\r\\n{\\r\\ns->read_ahead=yes;\\r\\n}\\r\\nint SSL_get_read_ahead(SSL *s)\\r\\n{\\r\\nreturn(s->read_ahead);\\r\\n}\\r\\nint SSL_pending(SSL *s)\\r\\n{\\r\\nreturn(s->method->ssl_pending(s));\\r\\n}\\r\\nX509 *SSL_get_peer_certificate(SSL *s)\\r\\n{\\r\\nX509 *r;\\r\\nif ((s == NULL) || (s->session == NULL))\\r\\nr=NULL;\\r\\nelse\\r\\nr=s->session->peer;\\r\\nif (r == NULL) return(r);\\r\\nCRYPTO_add(&r->references,1,CRYPTO_LOCK_X509);\\r\\nreturn(r);\\r\\n}\\r\\nint SSL_CTX_check_private_key(SSL_CTX *ctx)\\r\\n{\\r\\nif ( (ctx == NULL) ||\\r\\n(ctx->cert == NULL) ||\\r\\n(ctx->cert->key->x509 == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nif (ctx->cert->key->privatekey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(X509_check_private_key(ctx->cert->key->x509, ctx->cert->key->privatekey));\\r\\n}\\r\\nint SSL_check_private_key(SSL *ssl)\\r\\n{\\r\\nif (ssl == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (ssl->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn 0;\\r\\n}\\r\\nif (ssl->cert->key->x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nif (ssl->cert->key->privatekey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY,SSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(X509_check_private_key(ssl->cert->key->x509,\\r\\nssl->cert->key->privatekey));\\r\\n}\\r\\nint SSL_accept(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_accept_state(s);\\r\\nreturn(s->method->ssl_accept(s));\\r\\n}\\r\\nint SSL_connect(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_connect_state(s);\\r\\nreturn(s->method->ssl_connect(s));\\r\\n}\\r\\nlong SSL_get_default_timeout(SSL *s)\\r\\n{\\r\\nreturn(s->method->get_timeout());\\r\\n}\\r\\nint SSL_read(SSL *s,char *buf,int num)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\nreturn(s->method->ssl_read(s,buf,num));\\r\\n}\\r\\nint SSL_peek(SSL *s,char *buf,int num)\\r\\n{\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nreturn(s->method->ssl_peek(s,buf,num));\\r\\n}\\r\\nint SSL_write(SSL *s,const char *buf,int num)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nSSLerr(SSL_F_SSL_WRITE,SSL_R_PROTOCOL_IS_SHUTDOWN);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(s->method->ssl_write(s,buf,num));\\r\\n}\\r\\nint SSL_shutdown(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif ((s != NULL) && !SSL_in_init(s))\\r\\nreturn(s->method->ssl_shutdown(s));\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_renegotiate(SSL *s)\\r\\n{\\r\\ns->new_session=1;\\r\\nreturn(s->method->ssl_renegotiate(s));\\r\\n}\\r\\nlong SSL_ctrl(SSL *s,int cmd,long larg,char *parg)\\r\\n{\\r\\nlong l;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn(s->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl=s->read_ahead;\\r\\ns->read_ahead=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn(s->options|=larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn(s->mode|=larg);\\r\\ndefault:\\r\\nreturn(s->method->ssl_ctrl(s,cmd,larg,parg));\\r\\n}\\r\\n}\\r\\nlong SSL_CTX_ctrl(SSL_CTX *ctx,int cmd,long larg,char *parg)\\r\\n{\\r\\nlong l;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn(ctx->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl=ctx->read_ahead;\\r\\nctx->read_ahead=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_SIZE:\\r\\nl=ctx->session_cache_size;\\r\\nctx->session_cache_size=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_SIZE:\\r\\nreturn(ctx->session_cache_size);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_MODE:\\r\\nl=ctx->session_cache_mode;\\r\\nctx->session_cache_mode=larg;\\r\\nreturn(l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_MODE:\\r\\nreturn(ctx->session_cache_mode);\\r\\ncase SSL_CTRL_SESS_NUMBER:\\r\\nreturn(ctx->sessions->num_items);\\r\\ncase SSL_CTRL_SESS_CONNECT:\\r\\nreturn(ctx->stats.sess_connect);\\r\\ncase SSL_CTRL_SESS_CONNECT_GOOD:\\r\\nreturn(ctx->stats.sess_connect_good);\\r\\ncase SSL_CTRL_SESS_CONNECT_RENEGOTIATE:\\r\\nreturn(ctx->stats.sess_connect_renegotiate);\\r\\ncase SSL_CTRL_SESS_ACCEPT:\\r\\nreturn(ctx->stats.sess_accept);\\r\\ncase SSL_CTRL_SESS_ACCEPT_GOOD:\\r\\nreturn(ctx->stats.sess_accept_good);\\r\\ncase SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:\\r\\nreturn(ctx->stats.sess_accept_renegotiate);\\r\\ncase SSL_CTRL_SESS_HIT:\\r\\nreturn(ctx->stats.sess_hit);\\r\\ncase SSL_CTRL_SESS_CB_HIT:\\r\\nreturn(ctx->stats.sess_cb_hit);\\r\\ncase SSL_CTRL_SESS_MISSES:\\r\\nreturn(ctx->stats.sess_miss);\\r\\ncase SSL_CTRL_SESS_TIMEOUTS:\\r\\nreturn(ctx->stats.sess_timeout);\\r\\ncase SSL_CTRL_SESS_CACHE_FULL:\\r\\nreturn(ctx->stats.sess_cache_full);\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn(ctx->options|=larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn(ctx->mode|=larg);\\r\\ndefault:\\r\\nreturn(ctx->method->ssl_ctx_ctrl(ctx,cmd,larg,parg));\\r\\n}\\r\\n}\\r\\nint ssl_cipher_id_cmp(SSL_CIPHER *a,SSL_CIPHER *b)\\r\\n{\\r\\nlong l;\\r\\nl=a->id-b->id;\\r\\nif (l == 0L)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((l > 0)?1:-1);\\r\\n}\\r\\nint ssl_cipher_ptr_id_cmp(SSL_CIPHER **ap,SSL_CIPHER **bp)\\r\\n{\\r\\nlong l;\\r\\nl=(*ap)->id-(*bp)->id;\\r\\nif (l == 0L)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((l > 0)?1:-1);\\r\\n}\\r\\nchar *SSL_get_cipher_list(SSL *s,int n)\\r\\n{\\r\\nSSL_CIPHER *c;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nif (s == NULL) return(NULL);\\r\\nsk=SSL_get_ciphers(s);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\\r\\nreturn(NULL);\\r\\nc=sk_SSL_CIPHER_value(sk,n);\\r\\nif (c == NULL) return(NULL);\\r\\nreturn(c->name);\\r\\n}\\r\\nint SSL_CTX_set_cipher_list(SSL_CTX *ctx,char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk=ssl_create_cipher_list(ctx->method,&ctx->cipher_list,\\r\\n&ctx->cipher_list_by_id,str);\\r\\nreturn((sk == NULL)?0:1);\\r\\n}\\r\\nint SSL_set_cipher_list(SSL *s,char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk=ssl_create_cipher_list(s->ctx->method,&s->cipher_list,\\r\\n&s->cipher_list_by_id,str);\\r\\nreturn((sk == NULL)?0:1);\\r\\n}\\r\\nchar *SSL_get_shared_ciphers(SSL *s,char *buf,int len)\\r\\n{\\r\\nchar *p;\\r\\nconst char *cp;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nint i;\\r\\nif ((s->session == NULL) || (s->session->ciphers == NULL) ||\\r\\n(len < 2))\\r\\nreturn(NULL);\\r\\np=buf;\\r\\nsk=s->session->ciphers;\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nlen--;\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nfor (cp=c->name; *cp; )\\r\\n{\\r\\nif (len-- == 0)\\r\\n{\\r\\n*p='\\0';\\r\\nreturn(buf);\\r\\n}\\r\\nelse\\r\\n*(p++)= *(cp++);\\r\\n}\\r\\n*(p++)=':';\\r\\n}\\r\\np[-1]='\\0';\\r\\nreturn(buf);\\r\\n}\\r\\nlong SSL_SESSION_hash(SSL_SESSION *a)\\r\\n{\\r\\nunsigned long l;\\r\\nl=(unsigned long)\\r\\n((unsigned int) a->session_id[0] )|\\r\\n((unsigned int) a->session_id[1]<< 8L)|\\r\\n((unsigned long)a->session_id[2]<<16L)|\\r\\n((unsigned long)a->session_id[3]<<24L);\\r\\nreturn(l);\\r\\n}\\r\\nint SSL_SESSION_cmp(SSL_SESSION *a,SSL_SESSION *b)\\r\\n{\\r\\nif (a->ssl_version != b->ssl_version)\\r\\nreturn(1);\\r\\nif (a->session_id_length != b->session_id_length)\\r\\nreturn(1);\\r\\nreturn(memcmp(a->session_id,b->session_id,a->session_id_length));\\r\\n}\\r\\nSSL_CTX *SSL_CTX_new(SSL_METHOD *meth)\\r\\n{\\r\\nSSL_CTX *ret=NULL;\\r\\nif (meth == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_NULL_SSL_METHOD_PASSED);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (SSL_get_ex_data_X509_STORE_CTX_idx() < 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);\\r\\ngoto err;\\r\\n}\\r\\nret=(SSL_CTX *)Malloc(sizeof(SSL_CTX));\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nmemset(ret,0,sizeof(SSL_CTX));\\r\\nret->method=meth;\\r\\nret->cert_store=NULL;\\r\\nret->session_cache_mode=SSL_SESS_CACHE_SERVER;\\r\\nret->session_cache_size=SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;\\r\\nret->session_cache_head=NULL;\\r\\nret->session_cache_tail=NULL;\\r\\nret->session_timeout=meth->get_timeout();\\r\\nret->new_session_cb=NULL;\\r\\nret->remove_session_cb=NULL;\\r\\nret->get_session_cb=NULL;\\r\\nmemset((char *)&ret->stats,0,sizeof(ret->stats));\\r\\nret->references=1;\\r\\nret->quiet_shutdown=0;\\r\\nret->info_callback=NULL;\\r\\nret->app_verify_callback=NULL;\\r\\nret->app_verify_arg=NULL;\\r\\nret->read_ahead=0;\\r\\nret->verify_mode=SSL_VERIFY_NONE;\\r\\nret->verify_depth=-1;\\r\\nret->default_verify_callback=NULL;\\r\\nif ((ret->cert=ssl_cert_new()) == NULL)\\r\\ngoto err;\\r\\nret->default_passwd_callback=NULL;\\r\\nret->default_passwd_callback_userdata=NULL;\\r\\nret->client_cert_cb=NULL;\\r\\nret->sessions=lh_new(SSL_SESSION_hash,SSL_SESSION_cmp);\\r\\nif (ret->sessions == NULL) goto err;\\r\\nret->cert_store=X509_STORE_new();\\r\\nif (ret->cert_store == NULL) goto err;\\r\\nssl_create_cipher_list(ret->method,\\r\\n&ret->cipher_list,&ret->cipher_list_by_id,\\r\\nSSL_DEFAULT_CIPHER_LIST);\\r\\nif (ret->cipher_list == NULL\\r\\n|| sk_SSL_CIPHER_num(ret->cipher_list) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_LIBRARY_HAS_NO_CIPHERS);\\r\\ngoto err2;\\r\\n}\\r\\nif ((ret->rsa_md5=EVP_get_digestbyname(\"ssl2-md5\")) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);\\r\\ngoto err2;\\r\\n}\\r\\nif ((ret->md5=EVP_get_digestbyname(\"ssl3-md5\")) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);\\r\\ngoto err2;\\r\\n}\\r\\nif ((ret->sha1=EVP_get_digestbyname(\"ssl3-sha1\")) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);\\r\\ngoto err2;\\r\\n}\\r\\nif ((ret->client_CA=sk_X509_NAME_new_null()) == NULL)\\r\\ngoto err;\\r\\nCRYPTO_new_ex_data(ssl_ctx_meth,(char *)ret,&ret->ex_data);\\r\\nret->extra_certs=NULL;\\r\\nret->comp_methods=SSL_COMP_get_compression_methods();\\r\\nreturn(ret);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL_CTX_NEW,ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nif (ret != NULL) SSL_CTX_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nstatic void SSL_COMP_free(SSL_COMP *comp)\\r\\n{ Free(comp); }\\r\\nvoid SSL_CTX_free(SSL_CTX *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_SSL_CTX);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL_CTX\",a);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"SSL_CTX_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(ssl_ctx_meth,(char *)a,&a->ex_data);\\r\\nif (a->sessions != NULL)\\r\\n{\\r\\nSSL_CTX_flush_sessions(a,0);\\r\\nlh_free(a->sessions);\\r\\n}\\r\\nif (a->cert_store != NULL)\\r\\nX509_STORE_free(a->cert_store);\\r\\nif (a->cipher_list != NULL)\\r\\nsk_SSL_CIPHER_free(a->cipher_list);\\r\\nif (a->cipher_list_by_id != NULL)\\r\\nsk_SSL_CIPHER_free(a->cipher_list_by_id);\\r\\nif (a->cert != NULL)\\r\\nssl_cert_free(a->cert);\\r\\nif (a->client_CA != NULL)\\r\\nsk_X509_NAME_pop_free(a->client_CA,X509_NAME_free);\\r\\nif (a->extra_certs != NULL)\\r\\nsk_X509_pop_free(a->extra_certs,X509_free);\\r\\nif (a->comp_methods != NULL)\\r\\nsk_SSL_COMP_pop_free(a->comp_methods,SSL_COMP_free);\\r\\nFree((char *)a);\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)\\r\\n{\\r\\nctx->default_passwd_callback=cb;\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx,void *u)\\r\\n{\\r\\nctx->default_passwd_callback_userdata=u;\\r\\n}\\r\\nvoid SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,int (*cb)(),char *arg)\\r\\n{\\r\\nctx->app_verify_callback=cb;\\r\\nctx->app_verify_arg=arg;\\r\\n}\\r\\nvoid SSL_CTX_set_verify(SSL_CTX *ctx,int mode,int (*cb)(int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_mode=mode;\\r\\nctx->default_verify_callback=cb;\\r\\nX509_STORE_set_verify_cb_func(ctx->cert_store,cb);\\r\\n}\\r\\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx,int depth)\\r\\n{\\r\\nctx->verify_depth=depth;\\r\\n}\\r\\nvoid ssl_set_cert_masks(CERT *c, SSL_CIPHER *cipher)\\r\\n{\\r\\nCERT_PKEY *cpk;\\r\\nint rsa_enc,rsa_tmp,rsa_sign,dh_tmp,dh_rsa,dh_dsa,dsa_sign;\\r\\nint rsa_enc_export,dh_rsa_export,dh_dsa_export;\\r\\nint rsa_tmp_export,dh_tmp_export,kl;\\r\\nunsigned long mask,emask;\\r\\nif (c == NULL) return;\\r\\nkl=SSL_C_EXPORT_PKEYLENGTH(cipher);\\r\\n#ifndef NO_RSA\\r\\nrsa_tmp=(c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);\\r\\nrsa_tmp_export=(c->rsa_tmp_cb != NULL ||\\r\\n(rsa_tmp && RSA_size(c->rsa_tmp)*8 <= kl));\\r\\n#else\\r\\nrsa_tmp=rsa_tmp_export=0;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ndh_tmp=(c->dh_tmp != NULL || c->dh_tmp_cb != NULL);\\r\\ndh_tmp_export=(c->dh_tmp_cb != NULL ||\\r\\n(dh_tmp && DH_size(c->dh_tmp)*8 <= kl));\\r\\n#else\\r\\ndh_tmp=dh_tmp_export=0;\\r\\n#endif\\r\\ncpk= &(c->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nrsa_enc= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\nrsa_enc_export=(rsa_enc && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\ncpk= &(c->pkeys[SSL_PKEY_RSA_SIGN]);\\r\\nrsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DSA_SIGN]);\\r\\ndsa_sign=(cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DH_RSA]);\\r\\ndh_rsa= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ndh_rsa_export=(dh_rsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\ncpk= &(c->pkeys[SSL_PKEY_DH_DSA]);\\r\\ndh_dsa= (cpk->x509 != NULL && cpk->privatekey != NULL);\\r\\ndh_dsa_export=(dh_dsa && EVP_PKEY_size(cpk->privatekey)*8 <= kl);\\r\\nmask=0;\\r\\nemask=0;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"rt=%d rte=%d dht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\\n\",\\r\\nrsa_tmp,rsa_tmp_export,dh_tmp,\\r\\nrsa_enc,rsa_enc_export,rsa_sign,dsa_sign,dh_rsa,dh_dsa);\\r\\n#endif\\r\\nif (rsa_enc || (rsa_tmp && rsa_sign))\\r\\nmask|=SSL_kRSA;\\r\\nif (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))\\r\\nemask|=SSL_kRSA;\\r\\n#if 0\\r\\nif ( (dh_tmp || dh_rsa || dh_dsa) &&\\r\\n(rsa_enc || rsa_sign || dsa_sign))\\r\\nmask|=SSL_kEDH;\\r\\nif ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&\\r\\n(rsa_enc || rsa_sign || dsa_sign))\\r\\nemask|=SSL_kEDH;\\r\\n#endif\\r\\nif (dh_tmp_export)\\r\\nemask|=SSL_kEDH;\\r\\nif (dh_tmp)\\r\\nmask|=SSL_kEDH;\\r\\nif (dh_rsa) mask|=SSL_kDHr;\\r\\nif (dh_rsa_export) emask|=SSL_kDHr;\\r\\nif (dh_dsa) mask|=SSL_kDHd;\\r\\nif (dh_dsa_export) emask|=SSL_kDHd;\\r\\nif (rsa_enc || rsa_sign)\\r\\n{\\r\\nmask|=SSL_aRSA;\\r\\nemask|=SSL_aRSA;\\r\\n}\\r\\nif (dsa_sign)\\r\\n{\\r\\nmask|=SSL_aDSS;\\r\\nemask|=SSL_aDSS;\\r\\n}\\r\\n#ifdef SSL_ALLOW_ADH\\r\\nmask|=SSL_aNULL;\\r\\nemask|=SSL_aNULL;\\r\\n#endif\\r\\nc->mask=mask;\\r\\nc->export_mask=emask;\\r\\nc->valid=1;\\r\\n}\\r\\nX509 *ssl_get_server_send_cert(SSL *s)\\r\\n{\\r\\nunsigned long alg,mask,kalg;\\r\\nCERT *c;\\r\\nint i,is_export;\\r\\nc=s->cert;\\r\\nssl_set_cert_masks(c, s->s3->tmp.new_cipher);\\r\\nalg=s->s3->tmp.new_cipher->algorithms;\\r\\nis_export=SSL_IS_EXPORT(alg);\\r\\nmask=is_export?c->export_mask:c->mask;\\r\\nkalg=alg&(SSL_MKEY_MASK|SSL_AUTH_MASK);\\r\\nif (kalg & SSL_kDHr)\\r\\ni=SSL_PKEY_DH_RSA;\\r\\nelse if (kalg & SSL_kDHd)\\r\\ni=SSL_PKEY_DH_DSA;\\r\\nelse if (kalg & SSL_aDSS)\\r\\ni=SSL_PKEY_DSA_SIGN;\\r\\nelse if (kalg & SSL_aRSA)\\r\\n{\\r\\nif (c->pkeys[SSL_PKEY_RSA_ENC].x509 == NULL)\\r\\ni=SSL_PKEY_RSA_SIGN;\\r\\nelse\\r\\ni=SSL_PKEY_RSA_ENC;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_SERVER_SEND_CERT,SSL_R_INTERNAL_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (c->pkeys[i].x509 == NULL) return(NULL);\\r\\nreturn(c->pkeys[i].x509);\\r\\n}\\r\\nEVP_PKEY *ssl_get_sign_pkey(SSL *s,SSL_CIPHER *cipher)\\r\\n{\\r\\nunsigned long alg;\\r\\nCERT *c;\\r\\nalg=cipher->algorithms;\\r\\nc=s->cert;\\r\\nif ((alg & SSL_aDSS) &&\\r\\n(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))\\r\\nreturn(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey);\\r\\nelse if (alg & SSL_aRSA)\\r\\n{\\r\\nif (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)\\r\\nreturn(c->pkeys[SSL_PKEY_RSA_SIGN].privatekey);\\r\\nelse if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)\\r\\nreturn(c->pkeys[SSL_PKEY_RSA_ENC].privatekey);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_SIGN_PKEY,SSL_R_INTERNAL_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nvoid ssl_update_cache(SSL *s,int mode)\\r\\n{\\r\\nint i;\\r\\nif (s->session->session_id_length == 0) return;\\r\\nif ((s->ctx->session_cache_mode & mode)\\r\\n&& (!s->hit)\\r\\n&& SSL_CTX_add_session(s->ctx,s->session)\\r\\n&& (s->ctx->new_session_cb != NULL))\\r\\n{\\r\\nCRYPTO_add(&s->session->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nif (!s->ctx->new_session_cb(s,s->session))\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\ni=s->ctx->session_cache_mode;\\r\\nif ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) &&\\r\\n((i & mode) == mode))\\r\\n{\\r\\nif ( (((mode & SSL_SESS_CACHE_CLIENT)\\r\\n?s->ctx->stats.sess_connect_good\\r\\n:s->ctx->stats.sess_accept_good) & 0xff) == 0xff)\\r\\n{\\r\\nSSL_CTX_flush_sessions(s->ctx,time(NULL));\\r\\n}\\r\\n}\\r\\n}\\r\\nSSL_METHOD *SSL_get_ssl_method(SSL *s)\\r\\n{\\r\\nreturn(s->method);\\r\\n}\\r\\nint SSL_set_ssl_method(SSL *s,SSL_METHOD *meth)\\r\\n{\\r\\nint conn= -1;\\r\\nint ret=1;\\r\\nif (s->method != meth)\\r\\n{\\r\\nif (s->handshake_func != NULL)\\r\\nconn=(s->handshake_func == s->method->ssl_connect);\\r\\nif (s->method->version == meth->version)\\r\\ns->method=meth;\\r\\nelse\\r\\n{\\r\\ns->method->ssl_free(s);\\r\\ns->method=meth;\\r\\nret=s->method->ssl_new(s);\\r\\n}\\r\\nif (conn == 1)\\r\\ns->handshake_func=meth->ssl_connect;\\r\\nelse if (conn == 0)\\r\\ns->handshake_func=meth->ssl_accept;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_get_error(SSL *s,int i)\\r\\n{\\r\\nint reason;\\r\\nunsigned long l;\\r\\nBIO *bio;\\r\\nif (i > 0) return(SSL_ERROR_NONE);\\r\\nif ((l=ERR_peek_error()) != 0)\\r\\n{\\r\\nif (ERR_GET_LIB(l) == ERR_LIB_SYS)\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\nelse\\r\\nreturn(SSL_ERROR_SSL);\\r\\n}\\r\\nif ((i < 0) && SSL_want_read(s))\\r\\n{\\r\\nbio=SSL_get_rbio(s);\\r\\nif (BIO_should_read(bio))\\r\\nreturn(SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_write(bio))\\r\\nreturn(SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_io_special(bio))\\r\\n{\\r\\nreason=BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn(SSL_ERROR_WANT_CONNECT);\\r\\nelse\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_write(s))\\r\\n{\\r\\nbio=SSL_get_wbio(s);\\r\\nif (BIO_should_write(bio))\\r\\nreturn(SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_read(bio))\\r\\nreturn(SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_io_special(bio))\\r\\n{\\r\\nreason=BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn(SSL_ERROR_WANT_CONNECT);\\r\\nelse\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_x509_lookup(s))\\r\\n{\\r\\nreturn(SSL_ERROR_WANT_X509_LOOKUP);\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nif (s->version == SSL2_VERSION)\\r\\n{\\r\\nreturn(SSL_ERROR_ZERO_RETURN);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&\\r\\n(s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))\\r\\nreturn(SSL_ERROR_ZERO_RETURN);\\r\\n}\\r\\n}\\r\\nreturn(SSL_ERROR_SYSCALL);\\r\\n}\\r\\nint SSL_do_handshake(SSL *s)\\r\\n{\\r\\nint ret=1;\\r\\nif (s->handshake_func == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_DO_HANDSHAKE,SSL_R_CONNECTION_TYPE_NOT_SET);\\r\\nreturn(-1);\\r\\n}\\r\\ns->method->ssl_renegotiate_check(s);\\r\\nif (SSL_in_init(s) || SSL_in_before(s))\\r\\n{\\r\\nret=s->handshake_func(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid SSL_set_accept_state(SSL *s)\\r\\n{\\r\\ns->server=1;\\r\\ns->shutdown=0;\\r\\ns->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\nssl_clear_cipher_ctx(s);\\r\\n}\\r\\nvoid SSL_set_connect_state(SSL *s)\\r\\n{\\r\\ns->server=0;\\r\\ns->shutdown=0;\\r\\ns->state=SSL_ST_CONNECT|SSL_ST_BEFORE;\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\nssl_clear_cipher_ctx(s);\\r\\n}\\r\\nint ssl_undefined_function(SSL *s)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_FUNCTION,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nSSL_METHOD *ssl_bad_method(int ver)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_BAD_METHOD,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(NULL);\\r\\n}\\r\\nchar *SSL_get_version(SSL *s)\\r\\n{\\r\\nif (s->version == TLS1_VERSION)\\r\\nreturn(\"TLSv1\");\\r\\nelse if (s->version == SSL3_VERSION)\\r\\nreturn(\"SSLv3\");\\r\\nelse if (s->version == SSL2_VERSION)\\r\\nreturn(\"SSLv2\");\\r\\nelse\\r\\nreturn(\"unknown\");\\r\\n}\\r\\nSSL *SSL_dup(SSL *s)\\r\\n{\\r\\nSTACK_OF(X509_NAME) *sk;\\r\\nX509_NAME *xn;\\r\\nSSL *ret;\\r\\nint i;\\r\\nif ((ret=SSL_new(SSL_get_SSL_CTX(s))) == NULL)\\r\\nreturn(NULL);\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_copy_session_id(ret,s);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->method = s->method;\\r\\nret->method->ssl_new(ret);\\r\\nif (s->cert != NULL)\\r\\n{\\r\\nret->cert = ssl_cert_dup(s->cert);\\r\\nif (ret->cert == NULL)\\r\\ngoto err;\\r\\n}\\r\\nSSL_set_session_id_context(ret,\\r\\ns->sid_ctx, s->sid_ctx_length);\\r\\n}\\r\\nSSL_set_read_ahead(ret,SSL_get_read_ahead(s));\\r\\nSSL_set_verify(ret,SSL_get_verify_mode(s),\\r\\nSSL_get_verify_callback(s));\\r\\nSSL_set_verify_depth(ret,SSL_get_verify_depth(s));\\r\\nSSL_set_info_callback(ret,SSL_get_info_callback(s));\\r\\nret->debug=s->debug;\\r\\nret->options=s->options;\\r\\nif (!CRYPTO_dup_ex_data(ssl_meth,&ret->ex_data,&s->ex_data))\\r\\ngoto err;\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\nif (!BIO_dup_state(s->rbio,(char *)&ret->rbio))\\r\\ngoto err;\\r\\n}\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\nif (s->wbio != s->rbio)\\r\\n{\\r\\nif (!BIO_dup_state(s->wbio,(char *)&ret->wbio))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nret->wbio=ret->rbio;\\r\\n}\\r\\nif (s->cipher_list != NULL)\\r\\n{\\r\\nif ((ret->cipher_list=sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (s->cipher_list_by_id != NULL)\\r\\nif ((ret->cipher_list_by_id=sk_SSL_CIPHER_dup(s->cipher_list_by_id))\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (s->client_CA != NULL)\\r\\n{\\r\\nif ((sk=sk_X509_NAME_dup(s->client_CA)) == NULL) goto err;\\r\\nret->client_CA=sk;\\r\\nfor (i=0; i<sk_X509_NAME_num(sk); i++)\\r\\n{\\r\\nxn=sk_X509_NAME_value(sk,i);\\r\\nif (sk_X509_NAME_set(sk,i,X509_NAME_dup(xn)) == NULL)\\r\\n{\\r\\nX509_NAME_free(xn);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nret->shutdown=s->shutdown;\\r\\nret->state=s->state;\\r\\nret->handshake_func=s->handshake_func;\\r\\nret->server=s->server;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ret != NULL) SSL_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ssl_clear_cipher_ctx(SSL *s)\\r\\n{\\r\\nif (s->enc_read_ctx != NULL)\\r\\n{\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_read_ctx);\\r\\nFree(s->enc_read_ctx);\\r\\ns->enc_read_ctx=NULL;\\r\\n}\\r\\nif (s->enc_write_ctx != NULL)\\r\\n{\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_write_ctx);\\r\\nFree(s->enc_write_ctx);\\r\\ns->enc_write_ctx=NULL;\\r\\n}\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\n}\\r\\nX509 *SSL_get_certificate(SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn(s->cert->key->x509);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nEVP_PKEY *SSL_get_privatekey(SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn(s->cert->key->privatekey);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_CIPHER *SSL_get_current_cipher(SSL *s)\\r\\n{\\r\\nif ((s->session != NULL) && (s->session->cipher != NULL))\\r\\nreturn(s->session->cipher);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl_init_wbio_buffer(SSL *s,int push)\\r\\n{\\r\\nBIO *bbio;\\r\\nif (s->bbio == NULL)\\r\\n{\\r\\nbbio=BIO_new(BIO_f_buffer());\\r\\nif (bbio == NULL) return(0);\\r\\ns->bbio=bbio;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbbio=s->bbio;\\r\\nif (s->bbio == s->wbio)\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\n}\\r\\n(void)BIO_reset(bbio);\\r\\nif (!BIO_set_read_buffer_size(bbio,1))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_INIT_WBIO_BUFFER,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nif (push)\\r\\n{\\r\\nif (s->wbio != bbio)\\r\\ns->wbio=BIO_push(bbio,s->wbio);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->wbio == bbio)\\r\\ns->wbio=BIO_pop(bbio);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nvoid ssl_free_wbio_buffer(SSL *s)\\r\\n{\\r\\nBIO *under;\\r\\nif (s->bbio == NULL) return;\\r\\nif (s->bbio == s->wbio)\\r\\n{\\r\\nunder=BIO_pop(s->wbio);\\r\\nif (under != NULL)\\r\\ns->wbio=under;\\r\\nelse\\r\\nabort();\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio=NULL;\\r\\n}\\r\\nvoid SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx,int mode)\\r\\n{\\r\\nctx->quiet_shutdown=mode;\\r\\n}\\r\\nint SSL_CTX_get_quiet_shutdown(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_quiet_shutdown(SSL *s,int mode)\\r\\n{\\r\\ns->quiet_shutdown=mode;\\r\\n}\\r\\nint SSL_get_quiet_shutdown(SSL *s)\\r\\n{\\r\\nreturn(s->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_shutdown(SSL *s,int mode)\\r\\n{\\r\\ns->shutdown=mode;\\r\\n}\\r\\nint SSL_get_shutdown(SSL *s)\\r\\n{\\r\\nreturn(s->shutdown);\\r\\n}\\r\\nint SSL_version(SSL *s)\\r\\n{\\r\\nreturn(s->version);\\r\\n}\\r\\nSSL_CTX *SSL_get_SSL_CTX(SSL *ssl)\\r\\n{\\r\\nreturn(ssl->ctx);\\r\\n}\\r\\nint SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(X509_STORE_set_default_paths(ctx->cert_store));\\r\\n}\\r\\nint SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\\r\\nconst char *CApath)\\r\\n{\\r\\nreturn(X509_STORE_load_locations(ctx->cert_store,CAfile,CApath));\\r\\n}\\r\\nvoid SSL_set_info_callback(SSL *ssl,void (*cb)())\\r\\n{\\r\\nssl->info_callback=cb;\\r\\n}\\r\\nint SSL_state(SSL *ssl)\\r\\n{\\r\\nreturn(ssl->state);\\r\\n}\\r\\nvoid SSL_set_verify_result(SSL *ssl,long arg)\\r\\n{\\r\\nssl->verify_result=arg;\\r\\n}\\r\\nlong SSL_get_verify_result(SSL *ssl)\\r\\n{\\r\\nreturn(ssl->verify_result);\\r\\n}\\r\\nint SSL_get_ex_new_index(long argl,char *argp,int (*new_func)(),\\r\\nint (*dup_func)(),void (*free_func)())\\r\\n{\\r\\nssl_meth_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(ssl_meth_num-1,\\r\\n&ssl_meth,argl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint SSL_set_ex_data(SSL *s,int idx,void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_get_ex_data(SSL *s,int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nint SSL_CTX_get_ex_new_index(long argl,char *argp,int (*new_func)(),\\r\\nint (*dup_func)(),void (*free_func)())\\r\\n{\\r\\nssl_ctx_meth_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(ssl_ctx_meth_num-1,\\r\\n&ssl_ctx_meth,argl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint SSL_CTX_set_ex_data(SSL_CTX *s,int idx,void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_CTX_get_ex_data(SSL_CTX *s,int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nint ssl_ok(SSL *s)\\r\\n{\\r\\nreturn(1);\\r\\n}\\r\\nX509_STORE *SSL_CTX_get_cert_store(SSL_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->cert_store);\\r\\n}\\r\\nvoid SSL_CTX_set_cert_store(SSL_CTX *ctx,X509_STORE *store)\\r\\n{\\r\\nif (ctx->cert_store != NULL)\\r\\nX509_STORE_free(ctx->cert_store);\\r\\nctx->cert_store=store;\\r\\n}\\r\\nint SSL_want(SSL *s)\\r\\n{\\r\\nreturn(s->rwstate);\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx,RSA *(*cb)(SSL *ssl,\\r\\nint is_export,\\r\\nint keylength))\\r\\n{ SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_RSA_CB,0,(char *)cb); }\\r\\nvoid SSL_set_tmp_rsa_callback(SSL *ssl,RSA *(*cb)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{ SSL_ctrl(ssl,SSL_CTRL_SET_TMP_RSA_CB,0,(char *)cb); }\\r\\nRSA *cb(SSL *ssl,int is_export,int keylength)\\r\\n{}\\r\\nvoid SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,DH *(*dh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{ SSL_CTX_ctrl(ctx,SSL_CTRL_SET_TMP_DH_CB,0,(char *)dh); }\\r\\nvoid SSL_set_tmp_dh_callback(SSL *ssl,DH *(*dh)(SSL *ssl,int is_export,\\r\\nint keylength))\\r\\n{ SSL_ctrl(ssl,SSL_CTRL_SET_TMP_DH_CB,0,(char *)dh); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_ssl_c", "target": 0, "func": "BIO_METHOD *BIO_f_ssl(void)\\r\\n{\\r\\nreturn(&methods_sslp);\\r\\n}\\r\\nstatic int ssl_new(BIO *bi)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nbs=(BIO_SSL *)Malloc(sizeof(BIO_SSL));\\r\\nif (bs == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_SSL_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(bs,0,sizeof(BIO_SSL));\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)bs;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ssl_free(BIO *a)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nif (a == NULL) return(0);\\r\\nbs=(BIO_SSL *)a->ptr;\\r\\nif (bs->ssl != NULL) SSL_shutdown(bs->ssl);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif (a->init && (bs->ssl != NULL))\\r\\nSSL_free(bs->ssl);\\r\\na->init=0;\\r\\na->flags=0;\\r\\n}\\r\\nif (a->ptr != NULL)\\r\\nFree(a->ptr);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ssl_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=1;\\r\\nBIO_SSL *sb;\\r\\nSSL *ssl;\\r\\nint retry_reason=0;\\r\\nint r=0;\\r\\nif (out == NULL) return(0);\\r\\nsb=(BIO_SSL *)b->ptr;\\r\\nssl=sb->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 0\\r\\nif (!SSL_is_init_finished(ssl))\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\noutflags=(BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret=SSL_read(ssl,out,outl);\\r\\nswitch (SSL_get_error(ssl,ret))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0) break;\\r\\nif (sb->renegotiate_count > 0)\\r\\n{\\r\\nsb->byte_count+=ret;\\r\\nif (sb->byte_count > sb->renegotiate_count)\\r\\n{\\r\\nsb->byte_count=0;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr=1;\\r\\n}\\r\\n}\\r\\nif ((sb->renegotiate_timeout > 0) && (!r))\\r\\n{\\r\\nunsigned long tm;\\r\\ntm=(unsigned long)time(NULL);\\r\\nif (tm > sb->last_time+sb->renegotiate_timeout)\\r\\n{\\r\\nsb->last_time=tm;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_CONNECT;\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason=retry_reason;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_write(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret,r=0;\\r\\nint retry_reason=0;\\r\\nSSL *ssl;\\r\\nBIO_SSL *bs;\\r\\nif (out == NULL) return(0);\\r\\nbs=(BIO_SSL *)b->ptr;\\r\\nssl=bs->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\nret=SSL_write(ssl,out,outl);\\r\\nswitch (SSL_get_error(ssl,ret))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0) break;\\r\\nif (bs->renegotiate_count > 0)\\r\\n{\\r\\nbs->byte_count+=ret;\\r\\nif (bs->byte_count > bs->renegotiate_count)\\r\\n{\\r\\nbs->byte_count=0;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr=1;\\r\\n}\\r\\n}\\r\\nif ((bs->renegotiate_timeout > 0) && (!r))\\r\\n{\\r\\nunsigned long tm;\\r\\ntm=(unsigned long)time(NULL);\\r\\nif (tm > bs->last_time+bs->renegotiate_timeout)\\r\\n{\\r\\nbs->last_time=tm;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason=BIO_RR_CONNECT;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason=retry_reason;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ssl_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nSSL **sslp,*ssl;\\r\\nBIO_SSL *bs;\\r\\nBIO *dbio,*bio;\\r\\nlong ret=1;\\r\\nbs=(BIO_SSL *)b->ptr;\\r\\nssl=bs->ssl;\\r\\nif ((ssl == NULL) && (cmd != BIO_C_SET_SSL))\\r\\nreturn(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nSSL_shutdown(ssl);\\r\\nif (ssl->handshake_func == ssl->method->ssl_connect)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse if (ssl->handshake_func == ssl->method->ssl_accept)\\r\\nSSL_set_accept_state(ssl);\\r\\nSSL_clear(ssl);\\r\\nif (b->next_bio != NULL)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nelse if (ssl->rbio != NULL)\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nelse\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_SSL_MODE:\\r\\nif (num)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT:\\r\\nret=bs->renegotiate_timeout;\\r\\nif (num < 60) num=5;\\r\\nbs->renegotiate_timeout=(unsigned long)num;\\r\\nbs->last_time=(unsigned long)time(NULL);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_BYTES:\\r\\nret=bs->renegotiate_count;\\r\\nif ((long)num >=512)\\r\\nbs->renegotiate_count=(unsigned long)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL_NUM_RENEGOTIATES:\\r\\nret=bs->num_renegotiates;\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL:\\r\\nif (ssl != NULL)\\r\\nssl_free(b);\\r\\nb->shutdown=(int)num;\\r\\nssl=(SSL *)ptr;\\r\\n((BIO_SSL *)b->ptr)->ssl=ssl;\\r\\nbio=SSL_get_rbio(ssl);\\r\\nif (bio != NULL)\\r\\n{\\r\\nif (b->next_bio != NULL)\\r\\nBIO_push(bio,b->next_bio);\\r\\nb->next_bio=bio;\\r\\nCRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO);\\r\\n}\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nsslp=(SSL **)ptr;\\r\\n*sslp=ssl;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=SSL_pending(ssl);\\r\\nif (ret == 0)\\r\\nret=BIO_pending(ssl->rbio);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\nif ((b->next_bio != NULL) && (b->next_bio != ssl->rbio))\\r\\n{\\r\\nSSL_set_bio(ssl,b->next_bio,b->next_bio);\\r\\nCRYPTO_add(&b->next_bio->references,1,CRYPTO_LOCK_BIO);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_POP:\\r\\nif (ssl->rbio != ssl->wbio)\\r\\n{\\r\\nBIO_free_all(ssl->wbio);\\r\\n}\\r\\nssl->wbio=NULL;\\r\\nssl->rbio=NULL;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nb->retry_reason=0;\\r\\nret=(int)SSL_do_handshake(ssl);\\r\\nswitch (SSL_get_error(ssl,(int)ret))\\r\\n{\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_WRITE|BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_flags(b,\\r\\nBIO_FLAGS_IO_SPECIAL|BIO_FLAGS_SHOULD_RETRY);\\r\\nb->retry_reason=b->next_bio->retry_reason;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif (((BIO_SSL *)dbio->ptr)->ssl != NULL)\\r\\nSSL_free(((BIO_SSL *)dbio->ptr)->ssl);\\r\\n((BIO_SSL *)dbio->ptr)->ssl=SSL_dup(ssl);\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_count=\\r\\n((BIO_SSL *)b->ptr)->renegotiate_count;\\r\\n((BIO_SSL *)dbio->ptr)->byte_count=\\r\\n((BIO_SSL *)b->ptr)->byte_count;\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_timeout=\\r\\n((BIO_SSL *)b->ptr)->renegotiate_timeout;\\r\\n((BIO_SSL *)dbio->ptr)->last_time=\\r\\n((BIO_SSL *)b->ptr)->last_time;\\r\\nret=(((BIO_SSL *)dbio->ptr)->ssl != NULL);\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\nSSL_set_info_callback(ssl,(void (*)())ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nvoid (**fptr)();\\r\\nfptr=(void (**)())ptr;\\r\\n*fptr=SSL_get_info_callback(ssl);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=BIO_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\nBIO *ret=NULL,*buf=NULL,*ssl=NULL;\\r\\nif ((buf=BIO_new(BIO_f_buffer())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=BIO_new_ssl_connect(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((ret=BIO_push(buf,ssl)) == NULL)\\r\\ngoto err;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (buf != NULL) BIO_free(buf);\\r\\nif (ssl != NULL) BIO_free(ssl);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\nBIO *ret=NULL,*con=NULL,*ssl=NULL;\\r\\nif ((con=BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=BIO_new_ssl(ctx,1)) == NULL)\\r\\ngoto err;\\r\\nif ((ret=BIO_push(ssl,con)) == NULL)\\r\\ngoto err;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (con != NULL) BIO_free(con);\\r\\nif (ret != NULL) BIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl(SSL_CTX *ctx, int client)\\r\\n{\\r\\nBIO *ret;\\r\\nSSL *ssl;\\r\\nif ((ret=BIO_new(BIO_f_ssl())) == NULL)\\r\\nreturn(NULL);\\r\\nif ((ssl=SSL_new(ctx)) == NULL)\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (client)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nBIO_set_ssl(ret,ssl,BIO_CLOSE);\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_ssl_copy_session_id(BIO *t, BIO *f)\\r\\n{\\r\\nt=BIO_find_type(t,BIO_TYPE_SSL);\\r\\nf=BIO_find_type(f,BIO_TYPE_SSL);\\r\\nif ((t == NULL) || (f == NULL))\\r\\nreturn(0);\\r\\nif ( (((BIO_SSL *)t->ptr)->ssl == NULL) ||\\r\\n(((BIO_SSL *)f->ptr)->ssl == NULL))\\r\\nreturn(0);\\r\\nSSL_copy_session_id(((BIO_SSL *)t->ptr)->ssl,((BIO_SSL *)f->ptr)->ssl);\\r\\nreturn(1);\\r\\n}\\r\\nvoid BIO_ssl_shutdown(BIO *b)\\r\\n{\\r\\nSSL *s;\\r\\nwhile (b != NULL)\\r\\n{\\r\\nif (b->method->type == BIO_TYPE_SSL)\\r\\n{\\r\\ns=((BIO_SSL *)b->ptr)->ssl;\\r\\nSSL_shutdown(s);\\r\\nbreak;\\r\\n}\\r\\nb=b->next_bio;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_sign_c", "target": 0, "func": "void EVP_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit(ctx,type);\\r\\n}\\r\\nvoid EVP_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,\\r\\nunsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,data,count);\\r\\n}\\r\\nint EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,\\r\\nEVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i,ok=0,v;\\r\\nMS_STATIC EVP_MD_CTX tmp_ctx;\\r\\n*siglen=0;\\r\\nEVP_MD_CTX_copy(&tmp_ctx,ctx);\\r\\nEVP_DigestFinal(&tmp_ctx,&(m[0]),&m_len);\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nv=ctx->digest->required_pkey_type[i];\\r\\nif (v == 0) break;\\r\\nif (pkey->type == v)\\r\\n{\\r\\nok=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (ctx->digest->sign == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL,EVP_R_NO_SIGN_FUNCTION_CONFIGURED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ctx->digest->sign(ctx->digest->type,m,m_len,sigret,siglen,\\r\\npkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_check_c", "target": 1, "func": "int DH_check(DH *dh, int *ret)\\r\\n{\\r\\nint ok=0;\\r\\nBN_CTX *ctx=NULL;\\r\\nBN_ULONG l;\\r\\nBIGNUM *q=NULL;\\r\\n*ret=0;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nq=BN_new();\\r\\nif (q == NULL) goto err;\\r\\nif (BN_is_word(dh->g,DH_GENERATOR_2))\\r\\n{\\r\\nl=BN_mod_word(dh->p,24);\\r\\nif (l != 11) *ret|=DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\nelse if (BN_is_word(dh->g,DH_GENERATOR_5))\\r\\n{\\r\\nl=BN_mod_word(dh->p,10);\\r\\nif ((l != 3) && (l != 7))\\r\\n*ret|=DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\nelse\\r\\n*ret|=DH_UNABLE_TO_CHECK_GENERATOR;\\r\\nif (!BN_is_prime(dh->p,BN_prime_checks,NULL,ctx,NULL))\\r\\n*ret|=DH_CHECK_P_NOT_PRIME;\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(q,dh->p)) goto err;\\r\\nif (!BN_is_prime(q,BN_prime_checks,NULL,ctx,NULL))\\r\\n*ret|=DH_CHECK_P_NOT_STRONG_PRIME;\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nif (q != NULL) BN_free(q);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i_cfb64_c", "target": 0, "func": "void idea_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nIDEA_KEY_SCHEDULE *schedule, unsigned char *ivec, int *num,\\r\\nint encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_mdc2dgst_c", "target": 1, "func": "void MDC2_Init(MDC2_CTX *c)\\r\\n{\\r\\nc->num=0;\\r\\nc->pad_type=1;\\r\\nmemset(&(c->h[0]),0x52,MDC2_BLOCK);\\r\\nmemset(&(c->hh[0]),0x25,MDC2_BLOCK);\\r\\n}\\r\\nvoid MDC2_Update(MDC2_CTX *c, register unsigned char *in, unsigned long len)\\r\\n{\\r\\nint i,j;\\r\\ni=c->num;\\r\\nif (i != 0)\\r\\n{\\r\\nif (i+len < MDC2_BLOCK)\\r\\n{\\r\\nmemcpy(&(c->data[i]),in,(int)len);\\r\\nc->num+=(int)len;\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=MDC2_BLOCK-i;\\r\\nmemcpy(&(c->data[i]),in,j);\\r\\nlen-=j;\\r\\nin+=j;\\r\\nc->num=0;\\r\\nmdc2_body(c,&(c->data[0]),MDC2_BLOCK);\\r\\n}\\r\\n}\\r\\ni=(int)(len&(unsigned long)~(MDC2_BLOCK-1));\\r\\nif (i > 0) mdc2_body(c,in,i);\\r\\nj=(int)len-i;\\r\\nif (j > 0)\\r\\n{\\r\\nmemcpy(&(c->data[0]),&(in[i]),j);\\r\\nc->num=j;\\r\\n}\\r\\n}\\r\\nstatic void mdc2_body(MDC2_CTX *c, unsigned char *in, unsigned int len)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG ttin0,ttin1;\\r\\nDES_LONG d[2],dd[2];\\r\\ndes_key_schedule k;\\r\\nunsigned char *p;\\r\\nunsigned int i;\\r\\nfor (i=0; i<len; i+=8)\\r\\n{\\r\\nc2l(in,tin0); d[0]=dd[0]=tin0;\\r\\nc2l(in,tin1); d[1]=dd[1]=tin1;\\r\\nc->h[0]=(c->h[0]&0x9f)|0x40;\\r\\nc->hh[0]=(c->hh[0]&0x9f)|0x20;\\r\\ndes_set_odd_parity(&c->h);\\r\\ndes_set_key(&c->h,k);\\r\\ndes_encrypt(d,k,1);\\r\\ndes_set_odd_parity(&c->hh);\\r\\ndes_set_key(&c->hh,k);\\r\\ndes_encrypt(dd,k,1);\\r\\nttin0=tin0^dd[0];\\r\\nttin1=tin1^dd[1];\\r\\ntin0^=d[0];\\r\\ntin1^=d[1];\\r\\np=c->h;\\r\\nl2c(tin0,p);\\r\\nl2c(ttin1,p);\\r\\np=c->hh;\\r\\nl2c(ttin0,p);\\r\\nl2c(tin1,p);\\r\\n}\\r\\n}\\r\\nvoid MDC2_Final(unsigned char *md, MDC2_CTX *c)\\r\\n{\\r\\nint i,j;\\r\\ni=c->num;\\r\\nj=c->pad_type;\\r\\nif ((i > 0) || (j == 2))\\r\\n{\\r\\nif (j == 2)\\r\\nc->data[i++]=0x80;\\r\\nmemset(&(c->data[i]),0,MDC2_BLOCK-i);\\r\\nmdc2_body(c,c->data,MDC2_BLOCK);\\r\\n}\\r\\nmemcpy(md,(char *)c->h,MDC2_BLOCK);\\r\\nmemcpy(&(md[MDC2_BLOCK]),(char *)c->hh,MDC2_BLOCK);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char md[MDC2_DIGEST_LENGTH];\\r\\nint i;\\r\\nMDC2_CTX c;\\r\\nstatic char *text=\"Now is the time for all \";\\r\\nMDC2_Init(&c);\\r\\nMDC2_Update(&c,text,strlen(text));\\r\\nMDC2_Final(&(md[0]),&c);\\r\\nfor (i=0; i<MDC2_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02X\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_verify_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,ret=1;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nX509_STORE *cert_ctx=NULL;\\r\\nX509_LOOKUP *lookup=NULL;\\r\\ncert_ctx=X509_STORE_new();\\r\\nif (cert_ctx == NULL) goto end;\\r\\nX509_STORE_set_verify_cb_func(cert_ctx,cb);\\r\\nERR_load_crypto_strings();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nargc--;\\r\\nargv++;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (argc-- < 1) goto end;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-help\") == 0)\\r\\ngoto end;\\r\\nelse if (strcmp(*argv,\"-verbose\") == 0)\\r\\nv_verbose=1;\\r\\nelse if (argv[0][0] == '-')\\r\\ngoto end;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) abort();\\r\\nif (!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) abort();\\r\\nif (!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nif (argc < 1) check(cert_ctx,NULL);\\r\\nelse\\r\\nfor (i=0; i<argc; i++)\\r\\ncheck(cert_ctx,argv[i]);\\r\\nret=0;\\r\\nend:\\r\\nif (ret == 1)\\r\\nBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] cert1 cert2 ...\\n\");\\r\\nif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic int check(X509_STORE *ctx, char *file)\\r\\n{\\r\\nX509 *x=NULL;\\r\\nBIO *in=NULL;\\r\\nint i=0,ret=0;\\r\\nX509_STORE_CTX csc;\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nperror(file);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nx=PEM_read_bio_X509(in,NULL,NULL,NULL);\\r\\nif (x == NULL)\\r\\n{\\r\\nfprintf(stdout,\"%s: unable to load certificate file\\n\",\\r\\n(file == NULL)?\"stdin\":file);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nfprintf(stdout,\"%s: \",(file == NULL)?\"stdin\":file);\\r\\nX509_STORE_CTX_init(&csc,ctx,x,NULL);\\r\\ni=X509_verify_cert(&csc);\\r\\nX509_STORE_CTX_cleanup(&csc);\\r\\nret=0;\\r\\nend:\\r\\nif (i)\\r\\n{\\r\\nfprintf(stdout,\"OK\\n\");\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nif (!ok)\\r\\n{\\r\\nif (ctx->error == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\\r\\nok=1;\\r\\nelse\\r\\n{\\r\\nX509_NAME_oneline(\\r\\nX509_get_subject_name(ctx->current_cert),buf,256);\\r\\nprintf(\"%s\\n\",buf);\\r\\nprintf(\"error %d at %d depth lookup:%s\\n\",ctx->error,\\r\\nctx->error_depth,\\r\\nX509_verify_cert_error_string(ctx->error));\\r\\nif (ctx->error == X509_V_ERR_CERT_HAS_EXPIRED)\\r\\nok=1;\\r\\n}\\r\\n}\\r\\nif (!v_verbose)\\r\\nERR_clear_error();\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_object_c", "target": 1, "func": "int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp)\\r\\n{\\r\\nunsigned char *p;\\r\\nif ((a == NULL) || (a->data == NULL)) return(0);\\r\\nif (pp == NULL)\\r\\nreturn(ASN1_object_size(0,a->length,V_ASN1_OBJECT));\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,a->length,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\\r\\nmemcpy(p,a->data,a->length);\\r\\np+=a->length;\\r\\n*pp=p;\\r\\nreturn(a->length);\\r\\n}\\r\\nint a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)\\r\\n{\\r\\nint i,first,len=0,c;\\r\\nchar tmp[24];\\r\\nconst char *p;\\r\\nunsigned long l;\\r\\nif (num == 0)\\r\\nreturn(0);\\r\\nelse if (num == -1)\\r\\nnum=strlen(buf);\\r\\np=buf;\\r\\nc= *(p++);\\r\\nnum--;\\r\\nif ((c >= '0') && (c <= '2'))\\r\\n{\\r\\nfirst=(c-'0')*40;\\r\\n}\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_FIRST_NUM_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (num <= 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_MISSING_SECOND_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nc= *(p++);\\r\\nnum--;\\r\\nfor (;;)\\r\\n{\\r\\nif (num <= 0) break;\\r\\nif ((c != '.') && (c != ' '))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_INVALID_SEPARATOR);\\r\\ngoto err;\\r\\n}\\r\\nl=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (num <= 0) break;\\r\\nnum--;\\r\\nc= *(p++);\\r\\nif ((c == ' ') || (c == '.'))\\r\\nbreak;\\r\\nif ((c < '0') || (c > '9'))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_INVALID_DIGIT);\\r\\ngoto err;\\r\\n}\\r\\nl=l*10L+(long)(c-'0');\\r\\n}\\r\\nif (len == 0)\\r\\n{\\r\\nif ((first < 2) && (l >= 40))\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_SECOND_NUMBER_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nl+=(long)first;\\r\\n}\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\ntmp[i++]=(unsigned char)l&0x7f;\\r\\nl>>=7L;\\r\\nif (l == 0L) break;\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nif (len+i > olen)\\r\\n{\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,ASN1_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nwhile (--i > 0)\\r\\nout[len++]=tmp[i]|0x80;\\r\\nout[len++]=tmp[0];\\r\\n}\\r\\nelse\\r\\nlen+=i;\\r\\n}\\r\\nreturn(len);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a)\\r\\n{\\r\\nreturn OBJ_obj2txt(buf, buf_len, a, 0);\\r\\n}\\r\\nint i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a)\\r\\n{\\r\\nchar buf[80];\\r\\nint i;\\r\\nif ((a == NULL) || (a->data == NULL))\\r\\nreturn(BIO_write(bp,\"NULL\",4));\\r\\ni=i2t_ASN1_OBJECT(buf,80,a);\\r\\nif (i > 80) i=80;\\r\\nBIO_write(bp,buf,i);\\r\\nreturn(i);\\r\\n}\\r\\nASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_OBJECT *ret=NULL;\\r\\nunsigned char *p;\\r\\nlong len;\\r\\nint tag,xclass;\\r\\nint inf,i;\\r\\nif ((a == NULL) || ((*a) == NULL) ||\\r\\n!((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC))\\r\\n{\\r\\nif ((ret=ASN1_OBJECT_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse ret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_OBJECT)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_OBJECT;\\r\\ngoto err;\\r\\n}\\r\\nif ((ret->data == NULL) || (ret->length < len))\\r\\n{\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->data=(unsigned char *)Malloc((int)len);\\r\\nret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\nif (ret->data == NULL)\\r\\n{ i=ERR_R_MALLOC_FAILURE; goto err; }\\r\\n}\\r\\nmemcpy(ret->data,p,(int)len);\\r\\nret->length=(int)len;\\r\\nret->sn=NULL;\\r\\nret->ln=NULL;\\r\\np+=len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_OBJECT,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_OBJECT_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_new(void)\\r\\n{\\r\\nASN1_OBJECT *ret;\\r\\nret=(ASN1_OBJECT *)Malloc(sizeof(ASN1_OBJECT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_OBJECT_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->data=NULL;\\r\\nret->nid=0;\\r\\nret->sn=NULL;\\r\\nret->ln=NULL;\\r\\nret->flags=ASN1_OBJECT_FLAG_DYNAMIC;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ASN1_OBJECT_free(ASN1_OBJECT *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS)\\r\\n{\\r\\n#ifndef CONST_STRICT\\r\\nif (a->sn != NULL) Free((void *)a->sn);\\r\\nif (a->ln != NULL) Free((void *)a->ln);\\r\\n#endif\\r\\na->sn=a->ln=NULL;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA)\\r\\n{\\r\\nif (a->data != NULL) Free(a->data);\\r\\na->data=NULL;\\r\\na->length=0;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC)\\r\\nFree(a);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,\\r\\nchar *sn, char *ln)\\r\\n{\\r\\nASN1_OBJECT o;\\r\\no.sn=sn;\\r\\no.ln=ln;\\r\\no.data=data;\\r\\no.nid=nid;\\r\\no.length=len;\\r\\no.flags=ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\nreturn(OBJ_dup(&o));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_dhp_c", "target": 0, "func": "DH *d2i_DHparams(DH **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ERR_R_NESTED_ASN1_ERROR;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nlong v=0;\\r\\nM_ASN1_D2I_vars(a,DH *,DH_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->p=BN_bin2bn(bs->data,bs->length,ret->p)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->g=BN_bin2bn(bs->data,bs->length,ret->g)) == NULL) goto err_bn;\\r\\nif (!M_ASN1_D2I_end_sequence())\\r\\n{\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nfor (i=0; i<bs->length; i++)\\r\\nv=(v<<8)|(bs->data[i]);\\r\\nret->length=(int)v;\\r\\n}\\r\\nASN1_BIT_STRING_free(bs);\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_DHPARAMS,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) DH_free(ret);\\r\\nif (bs != NULL) ASN1_BIT_STRING_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_nbio_c", "target": 0, "func": "BIO_METHOD *BIO_f_nbio_test(void)\\r\\n{\\r\\nreturn(&methods_nbiof);\\r\\n}\\r\\nstatic int nbiof_new(BIO *bi)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nnt=(NBIO_TEST *)Malloc(sizeof(NBIO_TEST));\\r\\nnt->lrn= -1;\\r\\nnt->lwn= -1;\\r\\nbi->ptr=(char *)nt;\\r\\nbi->init=1;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nbiof_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->ptr != NULL)\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nbiof_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nint ret=0;\\r\\n#if 0\\r\\nint num;\\r\\nunsigned char n;\\r\\n#endif\\r\\nif (out == NULL) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nnt=(NBIO_TEST *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 0\\r\\nRAND_bytes(&n,1);\\r\\nnum=(n&0x07);\\r\\nif (outl > num) outl=num;\\r\\nif (num == 0)\\r\\n{\\r\\nret= -1;\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (ret < 0)\\r\\nBIO_copy_next_retry(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nbiof_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nint ret=0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nnt=(NBIO_TEST *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 1\\r\\nif (nt->lwn > 0)\\r\\n{\\r\\nnum=nt->lwn;\\r\\nnt->lwn=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nRAND_bytes(&n,1);\\r\\nnum=(n&7);\\r\\n}\\r\\nif (inl > num) inl=num;\\r\\nif (num == 0)\\r\\n{\\r\\nret= -1;\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nif (ret < 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nnt->lwn=inl;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nbiof_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nbiof_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_gets(bp->next_bio,buf,size));\\r\\n}\\r\\nstatic int nbiof_puts(BIO *bp, char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_puts(bp->next_bio,str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t_crl_c", "target": 0, "func": "int X509_CRL_print_fp(FILE *fp, X509_CRL *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_CRL_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_CRL_print(BIO *out, X509_CRL *x)\\r\\n{\\r\\nchar buf[256];\\r\\nunsigned char *s;\\r\\nSTACK_OF(X509_REVOKED) *rev;\\r\\nX509_REVOKED *r;\\r\\nlong l;\\r\\nint i, j, n;\\r\\nBIO_printf(out, \"Certificate Revocation List (CRL):\\n\");\\r\\nl = X509_CRL_get_version(x);\\r\\nBIO_printf(out, \"%8sVersion %lu (0x%lx)\\n\", \"\", l+1, l);\\r\\ni = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nBIO_printf(out, \"%8sSignature Algorithm: %s\\n\", \"\",\\r\\n(i == NID_undef) ? \"NONE\" : OBJ_nid2ln(i));\\r\\nX509_NAME_oneline(X509_CRL_get_issuer(x),buf,256);\\r\\nBIO_printf(out,\"%8sIssuer: %s\\n\",\"\",buf);\\r\\nBIO_printf(out,\"%8sLast Update: \",\"\");\\r\\nASN1_TIME_print(out,X509_CRL_get_lastUpdate(x));\\r\\nBIO_printf(out,\"\\n%8sNext Update: \",\"\");\\r\\nif (X509_CRL_get_nextUpdate(x))\\r\\nASN1_TIME_print(out,X509_CRL_get_nextUpdate(x));\\r\\nelse BIO_printf(out,\"NONE\");\\r\\nBIO_printf(out,\"\\n\");\\r\\nn=X509_CRL_get_ext_count(x);\\r\\nif (n > 0) {\\r\\nBIO_printf(out,\"%8sCRL extensions:\\n\",\"\");\\r\\nfor (i=0; i<n; i++) ext_print(out, X509_CRL_get_ext(x, i));\\r\\n}\\r\\nrev = X509_CRL_get_REVOKED(x);\\r\\nif(sk_X509_REVOKED_num(rev))\\r\\nBIO_printf(out, \"Revoked Certificates:\\n\");\\r\\nelse BIO_printf(out, \"No Revoked Certificates.\\n\");\\r\\nfor(i = 0; i < sk_X509_REVOKED_num(rev); i++) {\\r\\nr = sk_X509_REVOKED_value(rev, i);\\r\\nBIO_printf(out,\" Serial Number: \");\\r\\ni2a_ASN1_INTEGER(out,r->serialNumber);\\r\\nBIO_printf(out,\"\\n Revocation Date: \",\"\");\\r\\nASN1_TIME_print(out,r->revocationDate);\\r\\nBIO_printf(out,\"\\n\");\\r\\nfor(j = 0; j < X509_REVOKED_get_ext_count(r); j++)\\r\\next_print(out, X509_REVOKED_get_ext(r, j));\\r\\n}\\r\\ni=OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nBIO_printf(out,\" Signature Algorithm: %s\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i));\\r\\ns = x->signature->data;\\r\\nn = x->signature->length;\\r\\nfor (i=0; i<n; i++, s++)\\r\\n{\\r\\nif ((i%18) == 0) BIO_write(out,\"\\n \",9);\\r\\nBIO_printf(out,\"%02x%s\",*s, ((i+1) == n)?\"\":\":\");\\r\\n}\\r\\nBIO_write(out,\"\\n\",1);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void ext_print(BIO *out, X509_EXTENSION *ex)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint j;\\r\\nBIO_printf(out,\"%12s\",\"\");\\r\\nobj=X509_EXTENSION_get_object(ex);\\r\\ni2a_ASN1_OBJECT(out,obj);\\r\\nj=X509_EXTENSION_get_critical(ex);\\r\\nBIO_printf(out, \": %s\\n\", j ? \"critical\":\"\",\"\");\\r\\nif(!X509V3_EXT_print(out, ex, 0, 16)) {\\r\\nBIO_printf(out, \"%16s\", \"\");\\r\\nASN1_OCTET_STRING_print(out,ex->value);\\r\\n}\\r\\nBIO_write(out,\"\\n\",1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_signi_c", "target": 0, "func": "int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->issuer_and_serial,i2d_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_I2D_len(a->digest_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type(X509_ATTRIBUTE,a->auth_attr,\\r\\ni2d_X509_ATTRIBUTE,0);\\r\\nM_ASN1_I2D_len(a->digest_enc_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->enc_digest,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type(X509_ATTRIBUTE,a->unauth_attr,\\r\\ni2d_X509_ATTRIBUTE,1);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->issuer_and_serial,i2d_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_I2D_put(a->digest_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type(X509_ATTRIBUTE,a->auth_attr,\\r\\ni2d_X509_ATTRIBUTE,0);\\r\\nM_ASN1_I2D_put(a->digest_enc_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->enc_digest,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type(X509_ATTRIBUTE,a->unauth_attr,\\r\\ni2d_X509_ATTRIBUTE,1);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_SIGNER_INFO *d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_SIGNER_INFO *,PKCS7_SIGNER_INFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->issuer_and_serial,d2i_PKCS7_ISSUER_AND_SERIAL);\\r\\nM_ASN1_D2I_get(ret->digest_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509_ATTRIBUTE,ret->auth_attr,\\r\\nd2i_X509_ATTRIBUTE,X509_ATTRIBUTE_free,\\r\\n0);\\r\\nM_ASN1_D2I_get(ret->digest_enc_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->enc_digest,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509_ATTRIBUTE,ret->unauth_attr,\\r\\nd2i_X509_ATTRIBUTE,\\r\\nX509_ATTRIBUTE_free,1);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_SIGNER_INFO_free,\\r\\nASN1_F_D2I_PKCS7_SIGNER_INFO);\\r\\n}\\r\\nPKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void)\\r\\n{\\r\\nPKCS7_SIGNER_INFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_SIGNER_INFO);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->issuer_and_serial,PKCS7_ISSUER_AND_SERIAL_new);\\r\\nM_ASN1_New(ret->digest_alg,X509_ALGOR_new);\\r\\nret->auth_attr=NULL;\\r\\nM_ASN1_New(ret->digest_enc_alg,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->enc_digest,ASN1_OCTET_STRING_new);\\r\\nret->unauth_attr=NULL;\\r\\nret->pkey=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_SIGNER_INFO_NEW);\\r\\n}\\r\\nvoid PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nPKCS7_ISSUER_AND_SERIAL_free(a->issuer_and_serial);\\r\\nX509_ALGOR_free(a->digest_alg);\\r\\nsk_X509_ATTRIBUTE_pop_free(a->auth_attr,X509_ATTRIBUTE_free);\\r\\nX509_ALGOR_free(a->digest_enc_alg);\\r\\nASN1_OCTET_STRING_free(a->enc_digest);\\r\\nsk_X509_ATTRIBUTE_pop_free(a->unauth_attr,X509_ATTRIBUTE_free);\\r\\nif (a->pkey != NULL)\\r\\nEVP_PKEY_free(a->pkey);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_exp_c", "target": 0, "func": "main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nBN_CTX ctx;\\r\\nBIGNUM a,b,c,r,rr,t,l;\\r\\nint j,i,size=SIZE,num=NUM,mod=MOD;\\r\\nchar *start,*end;\\r\\nBN_MONT_CTX mont;\\r\\ndouble d,md;\\r\\nBN_MONT_CTX_init(&mont);\\r\\nBN_CTX_init(&ctx);\\r\\nBN_init(&a);\\r\\nBN_init(&b);\\r\\nBN_init(&c);\\r\\nBN_init(&r);\\r\\nstart=ms_time_new();\\r\\nend=ms_time_new();\\r\\nwhile (size <= 1024*8)\\r\\n{\\r\\nBN_rand(&a,size,0,0);\\r\\nBN_rand(&b,size,1,0);\\r\\nBN_rand(&c,size,0,1);\\r\\nBN_mod(&a,&a,&c,&ctx);\\r\\nms_time_get(start);\\r\\nfor (i=0; i<10; i++)\\r\\nBN_MONT_CTX_set(&mont,&c,&ctx);\\r\\nms_time_get(end);\\r\\nmd=ms_time_diff(start,end);\\r\\nms_time_get(start);\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nBN_mod_exp_mont(&r,&a,&b,&c,&ctx,&mont);\\r\\n}\\r\\nms_time_get(end);\\r\\nd=ms_time_diff(start,end);\\r\\nprintf(\"%5d bit:%6.2f %6d %6.4f %4d m_set(%5.4f)\\n\",size,\\r\\nd,num,d/num,(int)((d/num)*mod),md/10.0);\\r\\nnum/=8;\\r\\nmod/=8;\\r\\nif (num <= 0) num=1;\\r\\nsize*=2;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_sess_c", "target": 1, "func": "SSL_SESSION *SSL_get_session(SSL *ssl)\\r\\n{\\r\\nreturn(ssl->session);\\r\\n}\\r\\nint SSL_SESSION_get_ex_new_index(long argl, char *argp, int (*new_func)(),\\r\\nint (*dup_func)(), void (*free_func)())\\r\\n{\\r\\nssl_session_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(ssl_session_num-1,\\r\\n&ssl_session_meth,\\r\\nargl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&s->ex_data,idx,arg));\\r\\n}\\r\\nvoid *SSL_SESSION_get_ex_data(SSL_SESSION *s, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&s->ex_data,idx));\\r\\n}\\r\\nSSL_SESSION *SSL_SESSION_new(void)\\r\\n{\\r\\nSSL_SESSION *ss;\\r\\nss=(SSL_SESSION *)Malloc(sizeof(SSL_SESSION));\\r\\nif (ss == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESSION_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(ss,0,sizeof(SSL_SESSION));\\r\\nss->references=1;\\r\\nss->timeout=60*5+4;\\r\\nss->time=time(NULL);\\r\\nss->prev=NULL;\\r\\nss->next=NULL;\\r\\nss->compress_meth=0;\\r\\nCRYPTO_new_ex_data(ssl_session_meth,(char *)ss,&ss->ex_data);\\r\\nreturn(ss);\\r\\n}\\r\\nint ssl_get_new_session(SSL *s, int session)\\r\\n{\\r\\nSSL_SESSION *ss=NULL;\\r\\nif ((ss=SSL_SESSION_new()) == NULL) return(0);\\r\\nif (s->ctx->session_timeout == 0)\\r\\nss->timeout=SSL_get_default_timeout(s);\\r\\nelse\\r\\nss->timeout=s->ctx->session_timeout;\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\nif (session)\\r\\n{\\r\\nif (s->version == SSL2_VERSION)\\r\\n{\\r\\nss->ssl_version=SSL2_VERSION;\\r\\nss->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse if (s->version == SSL3_VERSION)\\r\\n{\\r\\nss->ssl_version=SSL3_VERSION;\\r\\nss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse if (s->version == TLS1_VERSION)\\r\\n{\\r\\nss->ssl_version=TLS1_VERSION;\\r\\nss->session_id_length=SSL3_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,SSL_R_UNSUPPORTED_SSL_VERSION);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn(0);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nSSL_SESSION *r;\\r\\nRAND_bytes(ss->session_id,ss->session_id_length);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nr=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,\\r\\n(char *)ss);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (r == NULL) break;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nss->session_id_length=0;\\r\\n}\\r\\nmemcpy(ss->sid_ctx,s->sid_ctx,s->sid_ctx_length);\\r\\nss->sid_ctx_length=s->sid_ctx_length;\\r\\ns->session=ss;\\r\\nss->ssl_version=s->version;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl_get_prev_session(SSL *s, unsigned char *session_id, int len)\\r\\n{\\r\\nSSL_SESSION *ret=NULL,data;\\r\\nint fatal = 0;\\r\\ndata.ssl_version=s->version;\\r\\ndata.session_id_length=len;\\r\\nif (len > SSL_MAX_SSL_SESSION_ID_LENGTH)\\r\\ngoto err;\\r\\nmemcpy(data.session_id,session_id,len);\\r\\nif (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP))\\r\\n{\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nret=(SSL_SESSION *)lh_retrieve(s->ctx->sessions,(char *)&data);\\r\\nif (ret != NULL)\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\n}\\r\\nif (ret == NULL)\\r\\n{\\r\\nint copy=1;\\r\\ns->ctx->stats.sess_miss++;\\r\\nret=NULL;\\r\\nif (s->ctx->get_session_cb != NULL\\r\\n&& (ret=s->ctx->get_session_cb(s,session_id,len,&copy))\\r\\n!= NULL)\\r\\n{\\r\\ns->ctx->stats.sess_cb_hit++;\\r\\nif (copy)\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nSSL_CTX_add_session(s->ctx,ret);\\r\\n}\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif((s->verify_mode&SSL_VERIFY_PEER)\\r\\n&& (!s->sid_ctx_length || ret->sid_ctx_length != s->sid_ctx_length\\r\\n|| memcmp(ret->sid_ctx,s->sid_ctx,ret->sid_ctx_length)))\\r\\n{\\r\\nif (s->sid_ctx_length == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\\r\\nfatal = 1;\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if 0\\r\\nSSLerr(SSL_F_SSL_GET_PREV_SESSION,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\\r\\n#endif\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ret->cipher == NULL)\\r\\n{\\r\\nunsigned char buf[5],*p;\\r\\nunsigned long l;\\r\\np=buf;\\r\\nl=ret->cipher_id;\\r\\nl2n(l,p);\\r\\nif ((ret->ssl_version>>8) == SSL3_VERSION_MAJOR)\\r\\nret->cipher=ssl_get_cipher_by_char(s,&(buf[2]));\\r\\nelse\\r\\nret->cipher=ssl_get_cipher_by_char(s,&(buf[1]));\\r\\nif (ret->cipher == NULL)\\r\\ngoto err;\\r\\n}\\r\\n#if 0\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\n#endif\\r\\nif ((long)(ret->time+ret->timeout) < (long)time(NULL))\\r\\n{\\r\\ns->ctx->stats.sess_timeout++;\\r\\nSSL_CTX_remove_session(s->ctx,ret);\\r\\ngoto err;\\r\\n}\\r\\ns->ctx->stats.sess_hit++;\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=ret;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nSSL_SESSION_free(ret);\\r\\nif (fatal)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nint ret=0;\\r\\nSSL_SESSION *s;\\r\\nCRYPTO_add(&c->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\ns=(SSL_SESSION *)lh_insert(ctx->sessions,(char *)c);\\r\\nif (s == NULL)\\r\\nSSL_SESSION_list_add(ctx,c);\\r\\nif (s != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s);\\r\\nret=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=1;\\r\\nif (SSL_CTX_sess_get_cache_size(ctx) > 0)\\r\\n{\\r\\nwhile (SSL_CTX_sess_number(ctx) >\\r\\nSSL_CTX_sess_get_cache_size(ctx))\\r\\n{\\r\\nif (!remove_session_lock(ctx,\\r\\nctx->session_cache_tail, 0))\\r\\nbreak;\\r\\nelse\\r\\nctx->stats.sess_cache_full++;\\r\\n}\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nreturn remove_session_lock(ctx, c, 1);\\r\\n}\\r\\nstatic int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)\\r\\n{\\r\\nSSL_SESSION *r;\\r\\nint ret=0;\\r\\nif ((c != NULL) && (c->session_id_length != 0))\\r\\n{\\r\\nif(lck) CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nr=(SSL_SESSION *)lh_delete(ctx->sessions,(char *)c);\\r\\nif (r != NULL)\\r\\n{\\r\\nret=1;\\r\\nSSL_SESSION_list_remove(ctx,c);\\r\\n}\\r\\nif(lck) CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ret)\\r\\n{\\r\\nr->not_resumable=1;\\r\\nif (ctx->remove_session_cb != NULL)\\r\\nctx->remove_session_cb(ctx,r);\\r\\nSSL_SESSION_free(r);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid SSL_SESSION_free(SSL_SESSION *ss)\\r\\n{\\r\\nint i;\\r\\nif(ss == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL_SESSION\",ss);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"SSL_SESSION_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(ssl_session_meth,(char *)ss,&ss->ex_data);\\r\\nmemset(ss->key_arg,0,SSL_MAX_KEY_ARG_LENGTH);\\r\\nmemset(ss->master_key,0,SSL_MAX_MASTER_KEY_LENGTH);\\r\\nmemset(ss->session_id,0,SSL_MAX_SSL_SESSION_ID_LENGTH);\\r\\nif (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);\\r\\nif (ss->peer != NULL) X509_free(ss->peer);\\r\\nif (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);\\r\\nmemset(ss,0,sizeof(*ss));\\r\\nFree(ss);\\r\\n}\\r\\nint SSL_set_session(SSL *s, SSL_SESSION *session)\\r\\n{\\r\\nint ret=0;\\r\\nSSL_METHOD *meth;\\r\\nif (session != NULL)\\r\\n{\\r\\nmeth=s->ctx->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL)\\r\\nmeth=s->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_SESSION,SSL_R_UNABLE_TO_FIND_SSL_METHOD);\\r\\nreturn(0);\\r\\n}\\r\\nif (meth != s->method)\\r\\n{\\r\\nif (!SSL_set_ssl_method(s,meth))\\r\\nreturn(0);\\r\\nif (s->ctx->session_timeout == 0)\\r\\nsession->timeout=SSL_get_default_timeout(s);\\r\\nelse\\r\\nsession->timeout=s->ctx->session_timeout;\\r\\n}\\r\\nCRYPTO_add(&session->references,1,CRYPTO_LOCK_SSL_SESSION);\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=session;\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session=NULL;\\r\\n}\\r\\nmeth=s->ctx->method;\\r\\nif (meth != s->method)\\r\\n{\\r\\nif (!SSL_set_ssl_method(s,meth))\\r\\nreturn(0);\\r\\n}\\r\\nret=1;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong SSL_SESSION_set_timeout(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\ns->timeout=t;\\r\\nreturn(1);\\r\\n}\\r\\nlong SSL_SESSION_get_timeout(SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->timeout);\\r\\n}\\r\\nlong SSL_SESSION_get_time(SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->time);\\r\\n}\\r\\nlong SSL_SESSION_set_time(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\ns->time=t;\\r\\nreturn(t);\\r\\n}\\r\\nlong SSL_CTX_set_timeout(SSL_CTX *s, long t)\\r\\n{\\r\\nlong l;\\r\\nif (s == NULL) return(0);\\r\\nl=s->session_timeout;\\r\\ns->session_timeout=t;\\r\\nreturn(l);\\r\\n}\\r\\nlong SSL_CTX_get_timeout(SSL_CTX *s)\\r\\n{\\r\\nif (s == NULL) return(0);\\r\\nreturn(s->session_timeout);\\r\\n}\\r\\nstatic void timeout(SSL_SESSION *s, TIMEOUT_PARAM *p)\\r\\n{\\r\\nif ((p->time == 0) || (p->time > (s->time+s->timeout)))\\r\\n{\\r\\nlh_delete(p->cache,(char *)s);\\r\\nSSL_SESSION_list_remove(p->ctx,s);\\r\\ns->not_resumable=1;\\r\\nif (p->ctx->remove_session_cb != NULL)\\r\\np->ctx->remove_session_cb(p->ctx,s);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n}\\r\\nvoid SSL_CTX_flush_sessions(SSL_CTX *s, long t)\\r\\n{\\r\\nunsigned long i;\\r\\nTIMEOUT_PARAM tp;\\r\\ntp.ctx=s;\\r\\ntp.cache=s->sessions;\\r\\nif (tp.cache == NULL) return;\\r\\ntp.time=t;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\ni=tp.cache->down_load;\\r\\ntp.cache->down_load=0;\\r\\nlh_doall_arg(tp.cache,(void (*)())timeout,(char *)&tp);\\r\\ntp.cache->down_load=i;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\n}\\r\\nint ssl_clear_bad_session(SSL *s)\\r\\n{\\r\\nif ( (s->session != NULL) &&\\r\\n!(s->shutdown & SSL_SENT_SHUTDOWN) &&\\r\\n!(SSL_in_init(s) || SSL_in_before(s)))\\r\\n{\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nstatic void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next == NULL) || (s->prev == NULL)) return;\\r\\nif (s->next == (SSL_SESSION *)&(ctx->session_cache_tail))\\r\\n{\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))\\r\\n{\\r\\nctx->session_cache_head=NULL;\\r\\nctx->session_cache_tail=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctx->session_cache_tail=s->prev;\\r\\ns->prev->next=(SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head))\\r\\n{\\r\\nctx->session_cache_head=s->next;\\r\\ns->next->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->next->prev=s->prev;\\r\\ns->prev->next=s->next;\\r\\n}\\r\\n}\\r\\ns->prev=s->next=NULL;\\r\\n}\\r\\nstatic void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next != NULL) && (s->prev != NULL))\\r\\nSSL_SESSION_list_remove(ctx,s);\\r\\nif (ctx->session_cache_head == NULL)\\r\\n{\\r\\nctx->session_cache_head=s;\\r\\nctx->session_cache_tail=s;\\r\\ns->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\ns->next=(SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->next=ctx->session_cache_head;\\r\\ns->next->prev=s;\\r\\ns->prev=(SSL_SESSION *)&(ctx->session_cache_head);\\r\\nctx->session_cache_head=s;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_kiss_c", "target": 0, "func": "int PKCS12_parse (PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,\\r\\nSTACK **ca)\\r\\n{\\r\\nif(!p12) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_INVALID_NULL_PKCS12_POINTER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((ca != NULL) && (*ca == NULL)) {\\r\\nif (!(*ca = sk_new(NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PARSE,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif(pkey) *pkey = NULL;\\r\\nif(cert) *cert = NULL;\\r\\nif (!PKCS12_verify_mac (p12, pass, -1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_MAC_VERIFY_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!parse_pk12 (p12, pass, -1, pkey, cert, ca)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_PARSE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (pkey && *pkey) EVP_PKEY_free (*pkey);\\r\\nif (cert && *cert) X509_free (*cert);\\r\\nif (ca) sk_pop_free (*ca, X509_free);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int parse_pk12 (PKCS12 *p12, const char *pass, int passlen,\\r\\nEVP_PKEY **pkey, X509 **cert, STACK **ca)\\r\\n{\\r\\nSTACK *asafes, *bags;\\r\\nint i, bagnid;\\r\\nPKCS7 *p7;\\r\\nASN1_OCTET_STRING *keyid = NULL;\\r\\nchar keymatch = 0;\\r\\nif (!( asafes = M_PKCS12_unpack_authsafes (p12))) return 0;\\r\\nfor (i = 0; i < sk_num (asafes); i++) {\\r\\np7 = (PKCS7 *) sk_value (asafes, i);\\r\\nbagnid = OBJ_obj2nid (p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = M_PKCS12_unpack_p7data (p7);\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nbags = M_PKCS12_unpack_p7encdata (p7, pass, passlen);\\r\\n} else continue;\\r\\nif (!bags) {\\r\\nsk_pop_free (asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (!parse_bags (bags, pass, passlen, pkey, cert, ca,\\r\\n&keyid, &keymatch)) {\\r\\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\nsk_pop_free (asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\\r\\n}\\r\\nsk_pop_free (asafes, PKCS7_free);\\r\\nif (keyid) ASN1_OCTET_STRING_free (keyid);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_bags (STACK *bags, const char *pass, int passlen,\\r\\nEVP_PKEY **pkey, X509 **cert, STACK **ca,\\r\\nASN1_OCTET_STRING **keyid, char *keymatch)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < sk_num (bags); i++) {\\r\\nif (!parse_bag ((PKCS12_SAFEBAG *)sk_value (bags, i),\\r\\npass, passlen, pkey, cert, ca, keyid,\\r\\nkeymatch)) return 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_bag (PKCS12_SAFEBAG *bag, const char *pass, int passlen,\\r\\nEVP_PKEY **pkey, X509 **cert, STACK **ca,\\r\\nASN1_OCTET_STRING **keyid,\\r\\nchar *keymatch)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509 *x509;\\r\\nASN1_OCTET_STRING *lkey = NULL;\\r\\nASN1_TYPE *attrib;\\r\\nif ((attrib = PKCS12_get_attr (bag, NID_localKeyID)))\\r\\nlkey = attrib->value.octet_string;\\r\\nif (lkey && ((*keymatch & MATCH_ALL) != MATCH_ALL)) {\\r\\nif (*keyid) {\\r\\nif (ASN1_OCTET_STRING_cmp (*keyid, lkey)) lkey = NULL;\\r\\n} else {\\r\\nif (!(*keyid = ASN1_OCTET_STRING_dup (lkey))) {\\r\\nPKCS12err(PKCS12_F_PARSE_BAGS,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nswitch (M_PKCS12_bag_type(bag))\\r\\n{\\r\\ncase NID_keyBag:\\r\\nif (!lkey || !pkey) return 1;\\r\\nif (!(*pkey = EVP_PKCS82PKEY (bag->value.keybag))) return 0;\\r\\n*keymatch |= MATCH_KEY;\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nif (!lkey || !pkey) return 1;\\r\\nif (!(p8 = M_PKCS12_decrypt_skey (bag, pass, passlen)))\\r\\nreturn 0;\\r\\n*pkey = EVP_PKCS82PKEY (p8);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nif (!(*pkey)) return 0;\\r\\n*keymatch |= MATCH_KEY;\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate )\\r\\nreturn 1;\\r\\nif (!(x509 = M_PKCS12_certbag2x509(bag))) return 0;\\r\\nif (lkey) {\\r\\n*keymatch |= MATCH_CERT;\\r\\nif (cert) *cert = x509;\\r\\n} else if (ca) sk_push (*ca, (char *)x509);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nreturn parse_bags(bag->value.safes, pass, passlen,\\r\\npkey, cert, ca, keyid, keymatch);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 1;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_lib_c", "target": 0, "func": "int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->set_asn1_parameters != NULL)\\r\\nret=c->cipher->set_asn1_parameters(c,type);\\r\\nelse\\r\\nret=1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->get_asn1_parameters != NULL)\\r\\nret=c->cipher->get_asn1_parameters(c,type);\\r\\nelse\\r\\nret=1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i=0,l;\\r\\nif (type != NULL)\\r\\n{\\r\\nl=EVP_CIPHER_CTX_iv_length(c);\\r\\ni=ASN1_TYPE_get_octetstring(type,c->oiv,l);\\r\\nif (i != l)\\r\\nreturn(-1);\\r\\nelse if (i > 0)\\r\\nmemcpy(c->iv,c->oiv,l);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nint EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i=0,j;\\r\\nif (type != NULL)\\r\\n{\\r\\nj=EVP_CIPHER_CTX_iv_length(c);\\r\\ni=ASN1_TYPE_set_octetstring(type,c->oiv,j);\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nint EVP_CIPHER_type(const EVP_CIPHER *ctx)\\r\\n{\\r\\nint nid;\\r\\nnid = EVP_CIPHER_nid(ctx);\\r\\nswitch(nid) {\\r\\ncase NID_rc2_cbc:\\r\\ncase NID_rc2_64_cbc:\\r\\ncase NID_rc2_40_cbc:\\r\\nreturn NID_rc2_cbc;\\r\\ncase NID_rc4:\\r\\ncase NID_rc4_40:\\r\\nreturn NID_rc4;\\r\\ndefault:\\r\\nreturn nid;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_decr_c", "target": 0, "func": "unsigned char * PKCS12_pbe_crypt (X509_ALGOR *algor, const char *pass,\\r\\nint passlen, unsigned char *in, int inlen, unsigned char **data,\\r\\nint *datalen, int en_de)\\r\\n{\\r\\nunsigned char *out;\\r\\nint outlen, i;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nif (!EVP_PBE_CipherInit (algor->algorithm, pass, passlen,\\r\\nalgor->parameter, &ctx, en_de)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_ALGOR_CIPHERINIT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(out = Malloc (inlen + EVP_CIPHER_CTX_block_size(&ctx)))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_CipherUpdate (&ctx, out, &i, in, inlen);\\r\\noutlen = i;\\r\\nif(!EVP_CipherFinal (&ctx, out + i, &i)) {\\r\\nFree (out);\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,PKCS12_R_PKCS12_CIPHERFINAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\noutlen += i;\\r\\nif (datalen) *datalen = outlen;\\r\\nif (data) *data = out;\\r\\nreturn out;\\r\\n}\\r\\nchar * PKCS12_decrypt_d2i (X509_ALGOR *algor, char * (*d2i)(),\\r\\nvoid (*free_func)(), const char *pass, int passlen,\\r\\nASN1_OCTET_STRING *oct, int seq)\\r\\n{\\r\\nunsigned char *out, *p;\\r\\nchar *ret;\\r\\nint outlen;\\r\\nif (!PKCS12_pbe_crypt (algor, pass, passlen, oct->data, oct->length,\\r\\n&out, &outlen, 0)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_DECRYPT_D2I,PKCS12_R_PKCS12_PBE_CRYPT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\np = out;\\r\\n#ifdef DEBUG_DECRYPT\\r\\n{\\r\\nFILE *op;\\r\\nchar fname[30];\\r\\nstatic int fnm = 1;\\r\\nsprintf(fname, \"DER%d\", fnm++);\\r\\nop = fopen(fname, \"wb\");\\r\\nfwrite (p, 1, outlen, op);\\r\\nfclose(op);\\r\\n}\\r\\n#endif\\r\\nif (seq & 1) ret = (char *) d2i_ASN1_SET(NULL, &p, outlen, d2i,\\r\\nfree_func, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\\r\\nelse ret = d2i(NULL, &p, outlen);\\r\\nif (seq & 2) memset(out, 0, outlen);\\r\\nif(!ret) PKCS12err(PKCS12_F_PKCS12_DECRYPT_D2I,PKCS12_R_DECODE_ERROR);\\r\\nFree (out);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_OCTET_STRING *PKCS12_i2d_encrypt (X509_ALGOR *algor, int (*i2d)(),\\r\\nconst char *pass, int passlen,\\r\\nchar *obj, int seq)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nunsigned char *in, *p;\\r\\nint inlen;\\r\\nif (!(oct = ASN1_OCTET_STRING_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (seq) inlen = i2d_ASN1_SET((STACK *)obj, NULL, i2d, V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL, IS_SEQUENCE);\\r\\nelse inlen = i2d (obj, NULL);\\r\\nif (!inlen) {\\r\\nPKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,PKCS12_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(in = Malloc (inlen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np = in;\\r\\nif (seq) i2d_ASN1_SET((STACK *)obj, &p, i2d, V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL, IS_SEQUENCE);\\r\\nelse i2d (obj, &p);\\r\\nif (!PKCS12_pbe_crypt (algor, pass, passlen, in, inlen, &oct->data,\\r\\n&oct->length, 1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_I2D_ENCRYPT,PKCS12_R_ENCRYPT_ERROR);\\r\\nFree(in);\\r\\nreturn NULL;\\r\\n}\\r\\nFree (in);\\r\\nreturn oct;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_mac_c", "target": 0, "func": "int i2d_PKCS12_MAC_DATA(PKCS12_MAC_DATA *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->dinfo, i2d_X509_SIG);\\r\\nM_ASN1_I2D_len (a->salt, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->dinfo, i2d_X509_SIG);\\r\\nM_ASN1_I2D_put (a->salt, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put (a->iter, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS12_MAC_DATA *PKCS12_MAC_DATA_new(void)\\r\\n{\\r\\nPKCS12_MAC_DATA *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKCS12_MAC_DATA);\\r\\nret->dinfo = X509_SIG_new();\\r\\nret->salt = ASN1_OCTET_STRING_new();\\r\\nret->iter = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS12_MAC_DATA_NEW);\\r\\n}\\r\\nPKCS12_MAC_DATA *d2i_PKCS12_MAC_DATA(PKCS12_MAC_DATA **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS12_MAC_DATA *,PKCS12_MAC_DATA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->dinfo, d2i_X509_SIG);\\r\\nM_ASN1_D2I_get (ret->salt, d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_get_opt (ret->iter, d2i_ASN1_INTEGER, V_ASN1_INTEGER);\\r\\nM_ASN1_D2I_Finish(a, PKCS12_MAC_DATA_free, ASN1_F_D2I_PKCS12_MAC_DATA);\\r\\n}\\r\\nvoid PKCS12_MAC_DATA_free (PKCS12_MAC_DATA *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_SIG_free (a->dinfo);\\r\\nASN1_OCTET_STRING_free (a->salt);\\r\\nASN1_INTEGER_free (a->iter);\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha_dgst_c", "target": 0, "func": "void SHA_Init(SHA_CTX *c)\\r\\n{\\r\\nc->h0=INIT_DATA_h0;\\r\\nc->h1=INIT_DATA_h1;\\r\\nc->h2=INIT_DATA_h2;\\r\\nc->h3=INIT_DATA_h3;\\r\\nc->h4=INIT_DATA_h4;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\n}\\r\\nvoid SHA_Update(SHA_CTX *c, register const unsigned char *data,\\r\\nunsigned long len)\\r\\n{\\r\\nregister SHA_LONG *p;\\r\\nint ew,ec,sw,sc;\\r\\nSHA_LONG l;\\r\\nif (len == 0) return;\\r\\nl=(c->Nl+(len<<3))&0xffffffffL;\\r\\nif (l < c->Nl)\\r\\nc->Nh++;\\r\\nc->Nh+=(len>>29);\\r\\nc->Nl=l;\\r\\nif (c->num != 0)\\r\\n{\\r\\np=c->data;\\r\\nsw=c->num>>2;\\r\\nsc=c->num&0x03;\\r\\nif ((c->num+len) >= SHA_CBLOCK)\\r\\n{\\r\\nl= p[sw];\\r\\nM_p_c2nl(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw<SHA_LBLOCK; sw++)\\r\\n{\\r\\nM_c2nl(data,l);\\r\\np[sw]=l;\\r\\n}\\r\\nlen-=(SHA_CBLOCK-c->num);\\r\\nsha_block(c,p,1);\\r\\nc->num=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nc->num+=(int)len;\\r\\nif ((sc+len) < 4)\\r\\n{\\r\\nl= p[sw];\\r\\nM_p_c2nl_p(data,l,sc,len);\\r\\np[sw]=l;\\r\\n}\\r\\nelse\\r\\n{\\r\\new=(c->num>>2);\\r\\nec=(c->num&0x03);\\r\\nl= p[sw];\\r\\nM_p_c2nl(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw < ew; sw++)\\r\\n{ M_c2nl(data,l); p[sw]=l; }\\r\\nif (ec)\\r\\n{\\r\\nM_c2nl_p(data,l,ec);\\r\\np[sw]=l;\\r\\n}\\r\\n}\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA_ASM)\\r\\nif ((((unsigned long)data)%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nsw=len/SHA_CBLOCK;\\r\\nif (sw)\\r\\n{\\r\\nsha_block(c,(SHA_LONG *)data,sw);\\r\\nsw*=SHA_CBLOCK;\\r\\ndata+=sw;\\r\\nlen-=sw;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\np=c->data;\\r\\nwhile (len >= SHA_CBLOCK)\\r\\n{\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA_ASM)\\r\\n#define SHA_NO_TAIL_CODE\\r\\nif (p != (SHA_LONG *)data)\\r\\nmemcpy(p,data,SHA_CBLOCK);\\r\\ndata+=SHA_CBLOCK;\\r\\nsha_block(c,p=c->data,1);\\r\\nlen-=SHA_CBLOCK;\\r\\n#elif defined(L_ENDIAN)\\r\\n#define BE_COPY(dst,src,i) { \\\\r\\nl = ((SHA_LONG *)src)[i]; \\\\r\\nEndian_Reverse32(l); \\\\r\\ndst[i] = l; \\\\r\\n}\\r\\nif ((((unsigned long)data)%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nfor (sw=(SHA_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nBE_COPY(p,data,0);\\r\\nBE_COPY(p,data,1);\\r\\nBE_COPY(p,data,2);\\r\\nBE_COPY(p,data,3);\\r\\np+=4;\\r\\ndata += 4*sizeof(SHA_LONG);\\r\\n}\\r\\nsha_block(c,p=c->data,1);\\r\\nlen-=SHA_CBLOCK;\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\n#ifndef SHA_NO_TAIL_CODE\\r\\np=c->data;\\r\\nfor (sw=(SHA_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nM_c2nl(data,l); p[0]=l;\\r\\nM_c2nl(data,l); p[1]=l;\\r\\nM_c2nl(data,l); p[2]=l;\\r\\nM_c2nl(data,l); p[3]=l;\\r\\np+=4;\\r\\n}\\r\\np=c->data;\\r\\nsha_block(c,p,1);\\r\\nlen-=SHA_CBLOCK;\\r\\n#endif\\r\\n}\\r\\nec=(int)len;\\r\\nc->num=ec;\\r\\new=(ec>>2);\\r\\nec&=0x03;\\r\\nfor (sw=0; sw < ew; sw++)\\r\\n{ M_c2nl(data,l); p[sw]=l; }\\r\\nM_c2nl_p(data,l,ec);\\r\\np[sw]=l;\\r\\n}\\r\\nvoid SHA_Transform(SHA_CTX *c, unsigned char *b)\\r\\n{\\r\\nSHA_LONG p[SHA_LBLOCK];\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA_ASM)\\r\\nmemcpy(p,b,SHA_CBLOCK);\\r\\nsha_block(c,p,1);\\r\\nreturn;\\r\\n#elif defined(L_ENDIAN)\\r\\nif (((unsigned long)b%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nSHA_LONG *q;\\r\\nint i;\\r\\nq=p;\\r\\nfor (i=(SHA_LBLOCK/4); i; i--)\\r\\n{\\r\\nunsigned long l;\\r\\nBE_COPY(q,b,0);\\r\\nBE_COPY(q,b,1);\\r\\nBE_COPY(q,b,2);\\r\\nBE_COPY(q,b,3);\\r\\nq+=4;\\r\\nb+=4*sizeof(SHA_LONG);\\r\\n}\\r\\nsha_block(c,p,1);\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\n#ifndef SHA_NO_TAIL_CODE\\r\\n{\\r\\nSHA_LONG *q;\\r\\nint i;\\r\\nq=p;\\r\\nfor (i=(SHA_LBLOCK/4); i; i--)\\r\\n{\\r\\nSHA_LONG l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\n}\\r\\nsha_block(c,p,1);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void sha_block(SHA_CTX *c, register SHA_LONG *W, int num)\\r\\n{\\r\\nregister SHA_LONG A,B,C,D,E,T;\\r\\nSHA_LONG X[SHA_LBLOCK];\\r\\nA=c->h0;\\r\\nB=c->h1;\\r\\nC=c->h2;\\r\\nD=c->h3;\\r\\nE=c->h4;\\r\\nfor (;;)\\r\\n{\\r\\nBODY_00_15( 0,A,B,C,D,E,T,W);\\r\\nBODY_00_15( 1,T,A,B,C,D,E,W);\\r\\nBODY_00_15( 2,E,T,A,B,C,D,W);\\r\\nBODY_00_15( 3,D,E,T,A,B,C,W);\\r\\nBODY_00_15( 4,C,D,E,T,A,B,W);\\r\\nBODY_00_15( 5,B,C,D,E,T,A,W);\\r\\nBODY_00_15( 6,A,B,C,D,E,T,W);\\r\\nBODY_00_15( 7,T,A,B,C,D,E,W);\\r\\nBODY_00_15( 8,E,T,A,B,C,D,W);\\r\\nBODY_00_15( 9,D,E,T,A,B,C,W);\\r\\nBODY_00_15(10,C,D,E,T,A,B,W);\\r\\nBODY_00_15(11,B,C,D,E,T,A,W);\\r\\nBODY_00_15(12,A,B,C,D,E,T,W);\\r\\nBODY_00_15(13,T,A,B,C,D,E,W);\\r\\nBODY_00_15(14,E,T,A,B,C,D,W);\\r\\nBODY_00_15(15,D,E,T,A,B,C,W);\\r\\nBODY_16_19(16,C,D,E,T,A,B,W,W,W,W);\\r\\nBODY_16_19(17,B,C,D,E,T,A,W,W,W,W);\\r\\nBODY_16_19(18,A,B,C,D,E,T,W,W,W,W);\\r\\nBODY_16_19(19,T,A,B,C,D,E,W,W,W,X);\\r\\nBODY_20_31(20,E,T,A,B,C,D,W,W,W,X);\\r\\nBODY_20_31(21,D,E,T,A,B,C,W,W,W,X);\\r\\nBODY_20_31(22,C,D,E,T,A,B,W,W,W,X);\\r\\nBODY_20_31(23,B,C,D,E,T,A,W,W,W,X);\\r\\nBODY_20_31(24,A,B,C,D,E,T,W,W,X,X);\\r\\nBODY_20_31(25,T,A,B,C,D,E,W,W,X,X);\\r\\nBODY_20_31(26,E,T,A,B,C,D,W,W,X,X);\\r\\nBODY_20_31(27,D,E,T,A,B,C,W,W,X,X);\\r\\nBODY_20_31(28,C,D,E,T,A,B,W,W,X,X);\\r\\nBODY_20_31(29,B,C,D,E,T,A,W,W,X,X);\\r\\nBODY_20_31(30,A,B,C,D,E,T,W,X,X,X);\\r\\nBODY_20_31(31,T,A,B,C,D,E,W,X,X,X);\\r\\nBODY_32_39(32,E,T,A,B,C,D,X);\\r\\nBODY_32_39(33,D,E,T,A,B,C,X);\\r\\nBODY_32_39(34,C,D,E,T,A,B,X);\\r\\nBODY_32_39(35,B,C,D,E,T,A,X);\\r\\nBODY_32_39(36,A,B,C,D,E,T,X);\\r\\nBODY_32_39(37,T,A,B,C,D,E,X);\\r\\nBODY_32_39(38,E,T,A,B,C,D,X);\\r\\nBODY_32_39(39,D,E,T,A,B,C,X);\\r\\nBODY_40_59(40,C,D,E,T,A,B,X);\\r\\nBODY_40_59(41,B,C,D,E,T,A,X);\\r\\nBODY_40_59(42,A,B,C,D,E,T,X);\\r\\nBODY_40_59(43,T,A,B,C,D,E,X);\\r\\nBODY_40_59(44,E,T,A,B,C,D,X);\\r\\nBODY_40_59(45,D,E,T,A,B,C,X);\\r\\nBODY_40_59(46,C,D,E,T,A,B,X);\\r\\nBODY_40_59(47,B,C,D,E,T,A,X);\\r\\nBODY_40_59(48,A,B,C,D,E,T,X);\\r\\nBODY_40_59(49,T,A,B,C,D,E,X);\\r\\nBODY_40_59(50,E,T,A,B,C,D,X);\\r\\nBODY_40_59(51,D,E,T,A,B,C,X);\\r\\nBODY_40_59(52,C,D,E,T,A,B,X);\\r\\nBODY_40_59(53,B,C,D,E,T,A,X);\\r\\nBODY_40_59(54,A,B,C,D,E,T,X);\\r\\nBODY_40_59(55,T,A,B,C,D,E,X);\\r\\nBODY_40_59(56,E,T,A,B,C,D,X);\\r\\nBODY_40_59(57,D,E,T,A,B,C,X);\\r\\nBODY_40_59(58,C,D,E,T,A,B,X);\\r\\nBODY_40_59(59,B,C,D,E,T,A,X);\\r\\nBODY_60_79(60,A,B,C,D,E,T,X);\\r\\nBODY_60_79(61,T,A,B,C,D,E,X);\\r\\nBODY_60_79(62,E,T,A,B,C,D,X);\\r\\nBODY_60_79(63,D,E,T,A,B,C,X);\\r\\nBODY_60_79(64,C,D,E,T,A,B,X);\\r\\nBODY_60_79(65,B,C,D,E,T,A,X);\\r\\nBODY_60_79(66,A,B,C,D,E,T,X);\\r\\nBODY_60_79(67,T,A,B,C,D,E,X);\\r\\nBODY_60_79(68,E,T,A,B,C,D,X);\\r\\nBODY_60_79(69,D,E,T,A,B,C,X);\\r\\nBODY_60_79(70,C,D,E,T,A,B,X);\\r\\nBODY_60_79(71,B,C,D,E,T,A,X);\\r\\nBODY_60_79(72,A,B,C,D,E,T,X);\\r\\nBODY_60_79(73,T,A,B,C,D,E,X);\\r\\nBODY_60_79(74,E,T,A,B,C,D,X);\\r\\nBODY_60_79(75,D,E,T,A,B,C,X);\\r\\nBODY_60_79(76,C,D,E,T,A,B,X);\\r\\nBODY_60_79(77,B,C,D,E,T,A,X);\\r\\nBODY_60_79(78,A,B,C,D,E,T,X);\\r\\nBODY_60_79(79,T,A,B,C,D,E,X);\\r\\nc->h0=(c->h0+E)&0xffffffffL;\\r\\nc->h1=(c->h1+T)&0xffffffffL;\\r\\nc->h2=(c->h2+A)&0xffffffffL;\\r\\nc->h3=(c->h3+B)&0xffffffffL;\\r\\nc->h4=(c->h4+C)&0xffffffffL;\\r\\nif (--num <= 0) break;\\r\\nA=c->h0;\\r\\nB=c->h1;\\r\\nC=c->h2;\\r\\nD=c->h3;\\r\\nE=c->h4;\\r\\nW+=SHA_LBLOCK;\\r\\n}\\r\\n}\\r\\nvoid SHA_Final(unsigned char *md, SHA_CTX *c)\\r\\n{\\r\\nregister int i,j;\\r\\nregister SHA_LONG l;\\r\\nregister SHA_LONG *p;\\r\\nstatic unsigned char end[4]={0x80,0x00,0x00,0x00};\\r\\nunsigned char *cp=end;\\r\\np=c->data;\\r\\nj=c->num;\\r\\ni=j>>2;\\r\\n#ifdef PURIFY\\r\\nif ((j&0x03) == 0) p[i]=0;\\r\\n#endif\\r\\nl=p[i];\\r\\nM_p_c2nl(cp,l,j&0x03);\\r\\np[i]=l;\\r\\ni++;\\r\\nif (c->num >= SHA_LAST_BLOCK)\\r\\n{\\r\\nfor (; i<SHA_LBLOCK; i++)\\r\\np[i]=0;\\r\\nsha_block(c,p,1);\\r\\ni=0;\\r\\n}\\r\\nfor (; i<(SHA_LBLOCK-2); i++)\\r\\np[i]=0;\\r\\np[SHA_LBLOCK-2]=c->Nh;\\r\\np[SHA_LBLOCK-1]=c->Nl;\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if !defined(B_ENDIAN) && defined(SHA_ASM)\\r\\nEndian_Reverse32(p[SHA_LBLOCK-2]);\\r\\nEndian_Reverse32(p[SHA_LBLOCK-1]);\\r\\n#endif\\r\\n#endif\\r\\nsha_block(c,p,1);\\r\\ncp=md;\\r\\nl=c->h0; nl2c(l,cp);\\r\\nl=c->h1; nl2c(l,cp);\\r\\nl=c->h2; nl2c(l,cp);\\r\\nl=c->h3; nl2c(l,cp);\\r\\nl=c->h4; nl2c(l,cp);\\r\\nc->num=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_conn_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nPROXY *pxy;\\r\\nchar *host;\\r\\nchar buf[1024*10],*p;\\r\\nBIO *bio;\\r\\nint i,len,off,ret=1;\\r\\nif (argc <= 1)\\r\\nhost=\"localhost:4433\";\\r\\nelse\\r\\nhost=argv[1];\\r\\nERR_load_crypto_strings();\\r\\npxy=PROXY_new();\\r\\nPROXY_add_server(pxy,PROXY_PROTOCOL_SOCKS,\"gromit:1080\");\\r\\nbio=BIO_new(BIO_s_socks4a_connect());\\r\\nBIO_set_conn_hostname(bio,host);\\r\\nBIO_set_proxies(bio,pxy);\\r\\nBIO_set_socks_userid(bio,\"eay\");\\r\\nBIO_set_nbio(bio,1);\\r\\np=\"GET / HTTP/1.0\\r\\n\\r\\n\";\\r\\nlen=strlen(p);\\r\\noff=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(bio,&(p[off]),len);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (BIO_should_retry(bio))\\r\\n{\\r\\nfprintf(stderr,\"write DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\noff+=i;\\r\\nlen-=i;\\r\\nif (len <= 0) break;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(bio,buf,sizeof(buf));\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nif (BIO_should_retry(bio))\\r\\n{\\r\\nfprintf(stderr,\"read DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf,1,i,stdout);\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ERR_peek_error() == 0)\\r\\n{\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"error\");\\r\\n}\\r\\nelse\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nBIO_free_all(bio);\\r\\nif (pxy != NULL) PROXY_free(pxy);\\r\\nexit(!ret);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ofb_enc_c", "target": 0, "func": "void des_ofb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, des_key_schedule schedule, des_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG d0,d1,vv0,vv1,v0,v1,n=(numbits+7)/8;\\r\\nregister DES_LONG mask0,mask1;\\r\\nregister long l=length;\\r\\nregister int num=numbits;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nif (num > 64) return;\\r\\nif (num > 32)\\r\\n{\\r\\nmask0=0xffffffffL;\\r\\nif (num >= 64)\\r\\nmask1=mask0;\\r\\nelse\\r\\nmask1=(1L<<(num-32))-1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (num == 32)\\r\\nmask0=0xffffffffL;\\r\\nelse\\r\\nmask0=(1L<<num)-1;\\r\\nmask1=0x00000000L;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\nwhile (l-- > 0)\\r\\n{\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndes_encrypt((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nvv0=ti[0];\\r\\nvv1=ti[1];\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nd0=(d0^vv0)&mask0;\\r\\nd1=(d1^vv1)&mask1;\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=vv0; }\\r\\nelse if (num == 64)\\r\\n{ v0=vv0; v1=vv1; }\\r\\nelse if (num > 32)\\r\\n{\\r\\nv0=((v1>>(num-32))|(vv0<<(64-num)))&0xffffffffL;\\r\\nv1=((vv0>>(num-32))|(vv1<<(64-num)))&0xffffffffL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nv0=((v0>>num)|(v1<<(32-num)))&0xffffffffL;\\r\\nv1=((v1>>num)|(vv0<<(32-num)))&0xffffffffL;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nv0=v1=d0=d1=ti[0]=ti[1]=vv0=vv1=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_lib_c", "target": 0, "func": "int X509V3_EXT_add(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif(!ext_list && !(ext_list = sk_new(ext_cmp))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif(!sk_push(ext_list, (char *)ext)) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ext_cmp(X509V3_EXT_METHOD **a, X509V3_EXT_METHOD **b)\\r\\n{\\r\\nreturn ((*a)->ext_nid - (*b)->ext_nid);\\r\\n}\\r\\nX509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)\\r\\n{\\r\\nX509V3_EXT_METHOD tmp;\\r\\nint idx;\\r\\ntmp.ext_nid = nid;\\r\\nif(!ext_list || (tmp.ext_nid < 0) ) return NULL;\\r\\nidx = sk_find(ext_list, (char *)&tmp);\\r\\nif(idx == -1) return NULL;\\r\\nreturn (X509V3_EXT_METHOD *)sk_value(ext_list, idx);\\r\\n}\\r\\nX509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)\\r\\n{\\r\\nint nid;\\r\\nif((nid = OBJ_obj2nid(ext->object)) == NID_undef) return NULL;\\r\\nreturn X509V3_EXT_get_nid(nid);\\r\\n}\\r\\nint X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)\\r\\n{\\r\\nfor(;extlist->ext_nid!=-1;extlist++)\\r\\nif(!X509V3_EXT_add(extlist)) return 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509V3_EXT_add_alias(int nid_to, int nid_from)\\r\\n{\\r\\nX509V3_EXT_METHOD *ext, *tmpext;\\r\\nif(!(ext = X509V3_EXT_get_nid(nid_from))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,X509V3_R_EXTENSION_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(tmpext = (X509V3_EXT_METHOD *)Malloc(sizeof(X509V3_EXT_METHOD)))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n*tmpext = *ext;\\r\\ntmpext->ext_nid = nid_to;\\r\\ntmpext->ext_flags |= X509V3_EXT_DYNAMIC;\\r\\nreturn 1;\\r\\n}\\r\\nvoid X509V3_EXT_cleanup(void)\\r\\n{\\r\\nsk_pop_free(ext_list, ext_list_free);\\r\\next_list = NULL;\\r\\n}\\r\\nstatic void ext_list_free(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif(ext->ext_flags & X509V3_EXT_DYNAMIC) Free(ext);\\r\\n}\\r\\nint X509V3_add_standard_extensions(void)\\r\\n{\\r\\nX509V3_EXT_add_list(v3_ns_ia5_list);\\r\\nX509V3_EXT_add_list(v3_alt);\\r\\nX509V3_EXT_add(&v3_bcons);\\r\\nX509V3_EXT_add(&v3_nscert);\\r\\nX509V3_EXT_add(&v3_key_usage);\\r\\nX509V3_EXT_add(&v3_ext_ku);\\r\\nX509V3_EXT_add(&v3_skey_id);\\r\\nX509V3_EXT_add(&v3_akey_id);\\r\\nX509V3_EXT_add(&v3_pkey_usage_period);\\r\\nX509V3_EXT_add(&v3_crl_num);\\r\\nX509V3_EXT_add(&v3_sxnet);\\r\\nX509V3_EXT_add(&v3_crl_reason);\\r\\nX509V3_EXT_add(&v3_cpols);\\r\\nX509V3_EXT_add(&v3_crld);\\r\\nreturn 1;\\r\\n}\\r\\nvoid *X509V3_EXT_d2i(X509_EXTENSION *ext)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nunsigned char *p;\\r\\nif(!(method = X509V3_EXT_get(ext)) || !method->d2i) return NULL;\\r\\np = ext->value->data;\\r\\nreturn method->d2i(NULL, &p, ext->value->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_def_c", "target": 0, "func": "const char *X509_get_default_private_dir(void)\\r\\n{ return(X509_PRIVATE_DIR); }\\r\\nconst char *X509_get_default_cert_area(void)\\r\\n{ return(X509_CERT_AREA); }\\r\\nconst char *X509_get_default_cert_dir(void)\\r\\n{ return(X509_CERT_DIR); }\\r\\nconst char *X509_get_default_cert_file(void)\\r\\n{ return(X509_CERT_FILE); }\\r\\nconst char *X509_get_default_cert_dir_env(void)\\r\\n{ return(X509_CERT_DIR_EVP); }\\r\\nconst char *X509_get_default_cert_file_env(void)\\r\\n{ return(X509_CERT_FILE_EVP); }"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dggccbug_c", "target": 0, "func": "void inc(a)\\r\\nint *a;\\r\\n{\\r\\n(*a)++;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nint p=0;\\r\\n#ifdef FIXBUG\\r\\nint dummy;\\r\\n#endif\\r\\nwhile (p<3)\\r\\n{\\r\\nfprintf(stderr,\"%08X\\n\",p);\\r\\ninc(&p);\\r\\n#ifdef FIXBUG\\r\\ndummy+=p;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_skey_c", "target": 0, "func": "static ASN1_OCTET_STRING *octet_string_new(void)\\r\\n{\\r\\nreturn ASN1_OCTET_STRING_new();\\r\\n}\\r\\nchar *i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,\\r\\nASN1_OCTET_STRING *oct)\\r\\n{\\r\\nreturn hex_to_string(oct->data, oct->length);\\r\\n}\\r\\nASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nlong length;\\r\\nif(!(oct = ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(oct->data = string_to_hex(str, &length))) {\\r\\nASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}\\r\\noct->length = length;\\r\\nreturn oct;\\r\\n}\\r\\nstatic ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nASN1_BIT_STRING *pk;\\r\\nunsigned char pkey_dig[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX md;\\r\\nunsigned int diglen;\\r\\nif(strcmp(str, \"hash\")) return s2i_ASN1_OCTET_STRING(method, ctx, str);\\r\\nif(!(oct = ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_S2I_SKEY_ID,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(ctx && (ctx->flags == CTX_TEST)) return oct;\\r\\nif(!ctx || (!ctx->subject_req && !ctx->subject_cert)) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_SKEY_ID,X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif(ctx->subject_req)\\r\\npk = ctx->subject_req->req_info->pubkey->public_key;\\r\\nelse pk = ctx->subject_cert->cert_info->key->public_key;\\r\\nif(!pk) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_SKEY_ID,X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nEVP_DigestInit(&md, EVP_sha1());\\r\\nEVP_DigestUpdate(&md, pk->data, pk->length);\\r\\nEVP_DigestFinal(&md, pkey_dig, &diglen);\\r\\nif(!ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {\\r\\nX509V3err(X509V3_F_S2I_S2I_SKEY_ID,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nreturn oct;\\r\\nerr:\\r\\nASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsaparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nDSA *dsa=NULL;\\r\\nint i,badops=0,text=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,noout=0,C=0,ret=1;\\r\\nchar *infile,*outfile,*prog,*inrand=NULL;\\r\\nint numbits= -1,num,genkey=0;\\r\\nchar buffer[200],*randfile=NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC=1;\\r\\nelse if (strcmp(*argv,\"-genkey\") == 0)\\r\\ngenkey=1;\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (sscanf(*argv,\"%d\",&num) == 1)\\r\\n{\\r\\nnumbits=num;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] [bits] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -text check the DSA parameters\\n\");\\r\\nBIO_printf(bio_err,\" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\" -noout no output\\n\");\\r\\nBIO_printf(bio_err,\" -rand files to use for random number input\\n\");\\r\\nBIO_printf(bio_err,\" number number of bits to use for generating private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (numbits > 0)\\r\\n{\\r\\nrandfile=RAND_file_name(buffer,200);\\r\\nRAND_load_file(randfile,1024L*1024L);\\r\\nBIO_printf(bio_err,\"Generating DSA parameters, %d bit long prime\\n\",num);\\r\\nBIO_printf(bio_err,\"This could take some time\\n\");\\r\\ndsa=DSA_generate_parameters(num,NULL,0,NULL,NULL,\\r\\ndsa_cb,(char *)bio_err);\\r\\n}\\r\\nelse if (informat == FORMAT_ASN1)\\r\\ndsa=d2i_DSAparams_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndsa=PEM_read_bio_DSAparams(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nDSAparams_print(out,dsa);\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nunsigned char *data;\\r\\nint l,len,bits_p,bits_q,bits_g;\\r\\nlen=BN_num_bytes(dsa->p);\\r\\nbits_p=BN_num_bits(dsa->p);\\r\\nbits_q=BN_num_bits(dsa->q);\\r\\nbits_g=BN_num_bits(dsa->g);\\r\\ndata=(unsigned char *)Malloc(len+20);\\r\\nif (data == NULL)\\r\\n{\\r\\nperror(\"Malloc\");\\r\\ngoto end;\\r\\n}\\r\\nl=BN_bn2bin(dsa->p,data);\\r\\nprintf(\"static unsigned char dsa%d_p[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dsa->q,data);\\r\\nprintf(\"static unsigned char dsa%d_q[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dsa->g,data);\\r\\nprintf(\"static unsigned char dsa%d_g[]={\",bits_p);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\\n\");\\r\\nprintf(\"DSA *get_dsa%d()\\n\\t{\\n\",bits_p);\\r\\nprintf(\"\\tDSA *dsa;\\n\\n\");\\r\\nprintf(\"\\tif ((dsa=DSA_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdsa->p=BN_bin2bn(dsa%d_p,sizeof(dsa%d_p),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tdsa->q=BN_bin2bn(dsa%d_q,sizeof(dsa%d_q),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tdsa->g=BN_bin2bn(dsa%d_g,sizeof(dsa%d_g),NULL);\\n\",\\r\\nbits_p,bits_p);\\r\\nprintf(\"\\tif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\n\");\\r\\nprintf(\"\\t\\treturn(NULL);\\n\");\\r\\nprintf(\"\\treturn(dsa);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DSAparams_bio(out,dsa);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DSAparams(out,dsa);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write DSA paramaters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (genkey)\\r\\n{\\r\\nDSA *dsakey;\\r\\nif ((dsakey=DSAparams_dup(dsa)) == NULL) goto end;\\r\\nif (!DSA_generate_key(dsakey)) goto end;\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DSAPrivateKey_bio(out,dsakey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DSAPrivateKey(out,dsakey,NULL,NULL,0,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nDSA_free(dsakey);\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (dsa != NULL) DSA_free(dsa);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void MS_CALLBACK dsa_cb(int p, int n, char *arg)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write((BIO *)arg,&c,1);\\r\\n(void)BIO_flush((BIO *)arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"SHA(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nSHA_CTX c;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nunsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nSHA_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nSHA_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nSHA_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_pku_c", "target": 0, "func": "int i2d_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len_IMP_opt (a->notBefore, i2d_ASN1_GENERALIZEDTIME);\\r\\nM_ASN1_I2D_len_IMP_opt (a->notAfter, i2d_ASN1_GENERALIZEDTIME);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put_IMP_opt (a->notBefore, i2d_ASN1_GENERALIZEDTIME, 0);\\r\\nM_ASN1_I2D_put_IMP_opt (a->notAfter, i2d_ASN1_GENERALIZEDTIME, 1);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKEY_USAGE_PERIOD *PKEY_USAGE_PERIOD_new(void)\\r\\n{\\r\\nPKEY_USAGE_PERIOD *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKEY_USAGE_PERIOD);\\r\\nret->notBefore = NULL;\\r\\nret->notAfter = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKEY_USAGE_PERIOD_NEW);\\r\\n}\\r\\nPKEY_USAGE_PERIOD *d2i_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKEY_USAGE_PERIOD *,PKEY_USAGE_PERIOD_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_IMP_opt (ret->notBefore, d2i_ASN1_GENERALIZEDTIME, 0,\\r\\nV_ASN1_GENERALIZEDTIME);\\r\\nM_ASN1_D2I_get_IMP_opt (ret->notAfter, d2i_ASN1_GENERALIZEDTIME, 1,\\r\\nV_ASN1_GENERALIZEDTIME);\\r\\nM_ASN1_D2I_Finish(a, PKEY_USAGE_PERIOD_free, ASN1_F_D2I_PKEY_USAGE_PERIOD);\\r\\n}\\r\\nvoid PKEY_USAGE_PERIOD_free(PKEY_USAGE_PERIOD *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_GENERALIZEDTIME_free(a->notBefore);\\r\\nASN1_GENERALIZEDTIME_free(a->notAfter);\\r\\nFree ((char *)a);\\r\\n}\\r\\nstatic int i2r_PKEY_USAGE_PERIOD(X509V3_EXT_METHOD *method,\\r\\nPKEY_USAGE_PERIOD *usage, BIO *out, int indent)\\r\\n{\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nif(usage->notBefore) {\\r\\nBIO_write(out, \"Not Before: \", 12);\\r\\nASN1_GENERALIZEDTIME_print(out, usage->notBefore);\\r\\nif(usage->notAfter) BIO_write(out, \", \", 2);\\r\\n}\\r\\nif(usage->notAfter) {\\r\\nBIO_write(out, \"Not After: \", 11);\\r\\nASN1_GENERALIZEDTIME_print(out, usage->notAfter);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_pkey_c", "target": 0, "func": "EVP_PKEY *EVP_PKCS82PKEY (PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\n#ifndef NO_RSA\\r\\nRSA *rsa;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nDSA *dsa;\\r\\nASN1_INTEGER *dsapriv;\\r\\nSTACK *ndsa;\\r\\nBN_CTX *ctx;\\r\\nint plen;\\r\\n#endif\\r\\nX509_ALGOR *a;\\r\\nunsigned char *p;\\r\\nint pkeylen;\\r\\nchar obj_tmp[80];\\r\\nswitch (p8->broken) {\\r\\ncase PKCS8_OK:\\r\\np = p8->pkey->value.octet_string->data;\\r\\npkeylen = p8->pkey->value.octet_string->length;\\r\\nbreak;\\r\\ncase PKCS8_NO_OCTET:\\r\\np = p8->pkey->value.sequence->data;\\r\\npkeylen = p8->pkey->value.sequence->length;\\r\\nbreak;\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);\\r\\nreturn NULL;\\r\\nbreak;\\r\\n}\\r\\nif (!(pkey = EVP_PKEY_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\na = p8->pkeyalg;\\r\\nswitch (OBJ_obj2nid(a->algorithm))\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase NID_rsaEncryption:\\r\\nif (!(rsa = d2i_RSAPrivateKey (NULL, &p, pkeylen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY_assign_RSA (pkey, rsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase NID_dsa:\\r\\nif(*p == (V_ASN1_SEQUENCE|V_ASN1_CONSTRUCTED)) {\\r\\nif(!(ndsa = ASN1_seq_unpack(p, pkeylen,\\r\\n(char *(*)())d2i_ASN1_INTEGER,\\r\\nASN1_STRING_free))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif(sk_num(ndsa) != 2 ) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nsk_pop_free(ndsa, ASN1_STRING_free);\\r\\nreturn NULL;\\r\\n}\\r\\ndsapriv = (ASN1_INTEGER *) sk_pop(ndsa);\\r\\nsk_pop_free(ndsa, ASN1_STRING_free);\\r\\n} else if (!(dsapriv=d2i_ASN1_INTEGER (NULL, &p, pkeylen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a->parameter->type != V_ASN1_SEQUENCE) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_NO_DSA_PARAMETERS);\\r\\nreturn NULL;\\r\\n}\\r\\np = a->parameter->value.sequence->data;\\r\\nplen = a->parameter->value.sequence->length;\\r\\nif (!(dsa = d2i_DSAparams (NULL, &p, plen))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_DECODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(dsa->priv_key = ASN1_INTEGER_to_BN(dsapriv, NULL))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_DECODE_ERROR);\\r\\nDSA_free (dsa);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(dsa->pub_key = BN_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\nDSA_free (dsa);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(ctx = BN_CTX_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,ERR_R_MALLOC_FAILURE);\\r\\nDSA_free (dsa);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!BN_mod_exp(dsa->pub_key, dsa->g,\\r\\ndsa->priv_key, dsa->p, ctx)) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY,EVP_R_BN_PUBKEY_ERROR);\\r\\nBN_CTX_free (ctx);\\r\\nDSA_free (dsa);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY_assign_DSA (pkey, dsa);\\r\\nBN_CTX_free (ctx);\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\nif (!a->algorithm) strcpy (obj_tmp, \"NULL\");\\r\\nelse i2t_ASN1_OBJECT(obj_tmp, 80, a->algorithm);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\nEVP_PKEY_free (pkey);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn pkey;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\n#ifndef NO_DSA\\r\\nASN1_INTEGER *dpkey;\\r\\nunsigned char *p, *q;\\r\\nint len;\\r\\n#endif\\r\\nif (!(p8 = PKCS8_PRIV_KEY_INFO_new())) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_set (p8->version, 0);\\r\\nif (!(p8->pkeyalg->parameter = ASN1_TYPE_new ())) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nswitch (EVP_PKEY_type(pkey->type)) {\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\np8->pkeyalg->algorithm = OBJ_nid2obj(NID_rsaEncryption);\\r\\np8->pkeyalg->parameter->type = V_ASN1_NULL;\\r\\nif (!ASN1_pack_string ((char *)pkey, i2d_PrivateKey,\\r\\n&p8->pkey->value.octet_string)) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\np8->pkeyalg->algorithm = OBJ_nid2obj(NID_dsa);\\r\\nlen = i2d_DSAparams (pkey->pkey.dsa, NULL);\\r\\nif (!(p = Malloc(len))) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nq = p;\\r\\ni2d_DSAparams (pkey->pkey.dsa, &q);\\r\\np8->pkeyalg->parameter->type = V_ASN1_SEQUENCE;\\r\\np8->pkeyalg->parameter->value.sequence = ASN1_STRING_new();\\r\\nASN1_STRING_set(p8->pkeyalg->parameter->value.sequence, p, len);\\r\\nFree(p);\\r\\nif (!(dpkey = BN_to_ASN1_INTEGER (pkey->pkey.dsa->priv_key, NULL))) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,EVP_R_ENCODE_ERROR);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!ASN1_pack_string((char *)dpkey, i2d_ASN1_INTEGER,\\r\\n&p8->pkey->value.octet_string)) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8,ERR_R_MALLOC_FAILURE);\\r\\nASN1_INTEGER_free (dpkey);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_free (dpkey);\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\nPKCS8_PRIV_KEY_INFO_free (p8);\\r\\nreturn NULL;\\r\\n}\\r\\np8->pkey->type = V_ASN1_OCTET_STRING;\\r\\nRAND_seed (p8->pkey->value.octet_string->data,\\r\\np8->pkey->value.octet_string->length);\\r\\nreturn p8;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken)\\r\\n{\\r\\nswitch (broken) {\\r\\ncase PKCS8_OK:\\r\\np8->broken = PKCS8_OK;\\r\\nreturn p8;\\r\\nbreak;\\r\\ncase PKCS8_NO_OCTET:\\r\\np8->broken = PKCS8_NO_OCTET;\\r\\np8->pkey->type = V_ASN1_SEQUENCE;\\r\\nreturn p8;\\r\\nbreak;\\r\\ndefault:\\r\\nEVPerr(EVP_F_EVP_PKCS8_SET_BROKEN,EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);\\r\\nreturn NULL;\\r\\nbreak;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rand_lib_c", "target": 1, "func": "void RAND_set_rand_method(RAND_METHOD *meth)\\r\\n{\\r\\nrand_meth=meth;\\r\\n}\\r\\nRAND_METHOD *RAND_get_rand_method(void)\\r\\n{\\r\\nreturn(rand_meth);\\r\\n}\\r\\nvoid RAND_cleanup(void)\\r\\n{\\r\\nif (rand_meth != NULL)\\r\\nrand_meth->cleanup();\\r\\n}\\r\\nvoid RAND_seed(const void *buf, int num)\\r\\n{\\r\\nif (rand_meth != NULL)\\r\\nrand_meth->seed(buf,num);\\r\\n}\\r\\nvoid RAND_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nif (rand_meth != NULL)\\r\\nrand_meth->bytes(buf,num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_asm_c", "target": 1, "func": "BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nbn_check_num(num);\\r\\nif (num <= 0) return(c1);\\r\\nfor (;;)\\r\\n{\\r\\nmul_add(rp[0],ap[0],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[1],ap[1],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[2],ap[2],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[3],ap[3],w,c1);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1=0;\\r\\nbn_check_num(num);\\r\\nif (num <= 0) return(c1);\\r\\nwhile (1)\\r\\n{\\r\\nmul(rp[0],ap[0],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul(rp[1],ap[1],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul(rp[2],ap[2],w,c1);\\r\\nif (--num == 0) break;\\r\\nmul(rp[3],ap[3],w,c1);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(c1);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)\\r\\n{\\r\\nbn_check_num(n);\\r\\nif (n <= 0) return;\\r\\nfor (;;)\\r\\n{\\r\\nBN_ULLONG t;\\r\\nt=(BN_ULLONG)(a[0])*(a[0]);\\r\\nr[0]=Lw(t); r[1]=Hw(t);\\r\\nif (--n == 0) break;\\r\\nt=(BN_ULLONG)(a[1])*(a[1]);\\r\\nr[2]=Lw(t); r[3]=Hw(t);\\r\\nif (--n == 0) break;\\r\\nt=(BN_ULLONG)(a[2])*(a[2]);\\r\\nr[4]=Lw(t); r[5]=Hw(t);\\r\\nif (--n == 0) break;\\r\\nt=(BN_ULLONG)(a[3])*(a[3]);\\r\\nr[6]=Lw(t); r[7]=Hw(t);\\r\\nif (--n == 0) break;\\r\\na+=4;\\r\\nr+=8;\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c=0;\\r\\nBN_ULONG bl,bh;\\r\\nbn_check_num(num);\\r\\nif (num <= 0) return((BN_ULONG)0);\\r\\nbl=LBITS(w);\\r\\nbh=HBITS(w);\\r\\nfor (;;)\\r\\n{\\r\\nmul_add(rp[0],ap[0],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[1],ap[1],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[2],ap[2],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nmul_add(rp[3],ap[3],bl,bh,c);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(c);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG carry=0;\\r\\nBN_ULONG bl,bh;\\r\\nbn_check_num(num);\\r\\nif (num <= 0) return((BN_ULONG)0);\\r\\nbl=LBITS(w);\\r\\nbh=HBITS(w);\\r\\nfor (;;)\\r\\n{\\r\\nmul(rp[0],ap[0],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[1],ap[1],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[2],ap[2],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nmul(rp[3],ap[3],bl,bh,carry);\\r\\nif (--num == 0) break;\\r\\nap+=4;\\r\\nrp+=4;\\r\\n}\\r\\nreturn(carry);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, BN_ULONG *a, int n)\\r\\n{\\r\\nbn_check_num(n);\\r\\nif (n <= 0) return;\\r\\nfor (;;)\\r\\n{\\r\\nsqr64(r[0],r[1],a[0]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[2],r[3],a[1]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[4],r[5],a[2]);\\r\\nif (--n == 0) break;\\r\\nsqr64(r[6],r[7],a[3]);\\r\\nif (--n == 0) break;\\r\\na+=4;\\r\\nr+=8;\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nreturn((BN_ULONG)(((((BN_ULLONG)h)<<BN_BITS2)|l)/(BN_ULLONG)d));\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nBN_ULONG dh,dl,q,ret=0,th,tl,t;\\r\\nint i,count=2;\\r\\nif (d == 0) return(BN_MASK2);\\r\\ni=BN_num_bits_word(d);\\r\\nif ((i != BN_BITS2) && (h > (BN_ULONG)1<<i))\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"Division would overflow (%d)\\n\",i);\\r\\n#endif\\r\\nabort();\\r\\n}\\r\\ni=BN_BITS2-i;\\r\\nif (h >= d) h-=d;\\r\\nif (i)\\r\\n{\\r\\nd<<=i;\\r\\nh=(h<<i)|(l>>(BN_BITS2-i));\\r\\nl<<=i;\\r\\n}\\r\\ndh=(d&BN_MASK2h)>>BN_BITS4;\\r\\ndl=(d&BN_MASK2l);\\r\\nfor (;;)\\r\\n{\\r\\nif ((h>>BN_BITS4) == dh)\\r\\nq=BN_MASK2l;\\r\\nelse\\r\\nq=h/dh;\\r\\nth=q*dh;\\r\\ntl=dl*q;\\r\\nfor (;;)\\r\\n{\\r\\nt=h-th;\\r\\nif ((t&BN_MASK2h) ||\\r\\n((tl) <= (\\r\\n(t<<BN_BITS4)|\\r\\n((l&BN_MASK2h)>>BN_BITS4))))\\r\\nbreak;\\r\\nq--;\\r\\nth-=dh;\\r\\ntl-=dl;\\r\\n}\\r\\nt=(tl>>BN_BITS4);\\r\\ntl=(tl<<BN_BITS4)&BN_MASK2h;\\r\\nth+=t;\\r\\nif (l < tl) th++;\\r\\nl-=tl;\\r\\nif (h < th)\\r\\n{\\r\\nh+=d;\\r\\nq--;\\r\\n}\\r\\nh-=th;\\r\\nif (--count == 0) break;\\r\\nret=q<<BN_BITS4;\\r\\nh=((h<<BN_BITS4)|(l>>BN_BITS4))&BN_MASK2;\\r\\nl=(l&BN_MASK2l)<<BN_BITS4;\\r\\n}\\r\\nret|=q;\\r\\nreturn(ret);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULLONG ll=0;\\r\\nbn_check_num(n);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nfor (;;)\\r\\n{\\r\\nll+=(BN_ULLONG)a[0]+b[0];\\r\\nr[0]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[1]+b[1];\\r\\nr[1]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[2]+b[2];\\r\\nr[2]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\nll+=(BN_ULLONG)a[3]+b[3];\\r\\nr[3]=(BN_ULONG)ll&BN_MASK2;\\r\\nll>>=BN_BITS2;\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn((BN_ULONG)ll);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG c,l,t;\\r\\nbn_check_num(n);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nc=0;\\r\\nfor (;;)\\r\\n{\\r\\nt=a[0];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[0])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[0]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[1];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[1])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[1]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[2];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[2])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[2]=l;\\r\\nif (--n <= 0) break;\\r\\nt=a[3];\\r\\nt=(t+c)&BN_MASK2;\\r\\nc=(t < c);\\r\\nl=(t+b[3])&BN_MASK2;\\r\\nc+=(l < t);\\r\\nr[3]=l;\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn((BN_ULONG)c);\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG t1,t2;\\r\\nint c=0;\\r\\nbn_check_num(n);\\r\\nif (n <= 0) return((BN_ULONG)0);\\r\\nfor (;;)\\r\\n{\\r\\nt1=a[0]; t2=b[0];\\r\\nr[0]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[1]; t2=b[1];\\r\\nr[1]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[2]; t2=b[2];\\r\\nr[2]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\nt1=a[3]; t2=b[3];\\r\\nr[3]=(t1-t2-c)&BN_MASK2;\\r\\nif (t1 != t2) c=(t1 < t2);\\r\\nif (--n <= 0) break;\\r\\na+=4;\\r\\nb+=4;\\r\\nr+=4;\\r\\n}\\r\\nreturn(c);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[4],b[0],c2,c3,c1);\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nmul_add_c(a[0],b[4],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[0],b[5],c3,c1,c2);\\r\\nmul_add_c(a[1],b[4],c3,c1,c2);\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nmul_add_c(a[4],b[1],c3,c1,c2);\\r\\nmul_add_c(a[5],b[0],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[6],b[0],c1,c2,c3);\\r\\nmul_add_c(a[5],b[1],c1,c2,c3);\\r\\nmul_add_c(a[4],b[2],c1,c2,c3);\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nmul_add_c(a[2],b[4],c1,c2,c3);\\r\\nmul_add_c(a[1],b[5],c1,c2,c3);\\r\\nmul_add_c(a[0],b[6],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[7],c2,c3,c1);\\r\\nmul_add_c(a[1],b[6],c2,c3,c1);\\r\\nmul_add_c(a[2],b[5],c2,c3,c1);\\r\\nmul_add_c(a[3],b[4],c2,c3,c1);\\r\\nmul_add_c(a[4],b[3],c2,c3,c1);\\r\\nmul_add_c(a[5],b[2],c2,c3,c1);\\r\\nmul_add_c(a[6],b[1],c2,c3,c1);\\r\\nmul_add_c(a[7],b[0],c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[1],c3,c1,c2);\\r\\nmul_add_c(a[6],b[2],c3,c1,c2);\\r\\nmul_add_c(a[5],b[3],c3,c1,c2);\\r\\nmul_add_c(a[4],b[4],c3,c1,c2);\\r\\nmul_add_c(a[3],b[5],c3,c1,c2);\\r\\nmul_add_c(a[2],b[6],c3,c1,c2);\\r\\nmul_add_c(a[1],b[7],c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[2],b[7],c1,c2,c3);\\r\\nmul_add_c(a[3],b[6],c1,c2,c3);\\r\\nmul_add_c(a[4],b[5],c1,c2,c3);\\r\\nmul_add_c(a[5],b[4],c1,c2,c3);\\r\\nmul_add_c(a[6],b[3],c1,c2,c3);\\r\\nmul_add_c(a[7],b[2],c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[7],b[3],c2,c3,c1);\\r\\nmul_add_c(a[6],b[4],c2,c3,c1);\\r\\nmul_add_c(a[5],b[5],c2,c3,c1);\\r\\nmul_add_c(a[4],b[6],c2,c3,c1);\\r\\nmul_add_c(a[3],b[7],c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[4],b[7],c3,c1,c2);\\r\\nmul_add_c(a[5],b[6],c3,c1,c2);\\r\\nmul_add_c(a[6],b[5],c3,c1,c2);\\r\\nmul_add_c(a[7],b[4],c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[7],b[5],c1,c2,c3);\\r\\nmul_add_c(a[6],b[6],c1,c2,c3);\\r\\nmul_add_c(a[5],b[7],c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[6],b[7],c2,c3,c1);\\r\\nmul_add_c(a[7],b[6],c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[7],b[7],c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[0],c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[0],b[1],c2,c3,c1);\\r\\nmul_add_c(a[1],b[0],c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[0],c3,c1,c2);\\r\\nmul_add_c(a[1],b[1],c3,c1,c2);\\r\\nmul_add_c(a[0],b[2],c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[0],b[3],c1,c2,c3);\\r\\nmul_add_c(a[1],b[2],c1,c2,c3);\\r\\nmul_add_c(a[2],b[1],c1,c2,c3);\\r\\nmul_add_c(a[3],b[0],c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nmul_add_c(a[3],b[1],c2,c3,c1);\\r\\nmul_add_c(a[2],b[2],c2,c3,c1);\\r\\nmul_add_c(a[1],b[3],c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nmul_add_c(a[2],b[3],c3,c1,c2);\\r\\nmul_add_c(a[3],b[2],c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nmul_add_c(a[3],b[3],c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t,tt;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nsqr_add_c2(a,4,0,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,5,0,c3,c1,c2);\\r\\nsqr_add_c2(a,4,1,c3,c1,c2);\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nsqr_add_c2(a,4,2,c1,c2,c3);\\r\\nsqr_add_c2(a,5,1,c1,c2,c3);\\r\\nsqr_add_c2(a,6,0,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,0,c2,c3,c1);\\r\\nsqr_add_c2(a,6,1,c2,c3,c1);\\r\\nsqr_add_c2(a,5,2,c2,c3,c1);\\r\\nsqr_add_c2(a,4,3,c2,c3,c1);\\r\\nr[7]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,4,c3,c1,c2);\\r\\nsqr_add_c2(a,5,3,c3,c1,c2);\\r\\nsqr_add_c2(a,6,2,c3,c1,c2);\\r\\nsqr_add_c2(a,7,1,c3,c1,c2);\\r\\nr[8]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,7,2,c1,c2,c3);\\r\\nsqr_add_c2(a,6,3,c1,c2,c3);\\r\\nsqr_add_c2(a,5,4,c1,c2,c3);\\r\\nr[9]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,5,c2,c3,c1);\\r\\nsqr_add_c2(a,6,4,c2,c3,c1);\\r\\nsqr_add_c2(a,7,3,c2,c3,c1);\\r\\nr[10]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,7,4,c3,c1,c2);\\r\\nsqr_add_c2(a,6,5,c3,c1,c2);\\r\\nr[11]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,6,c1,c2,c3);\\r\\nsqr_add_c2(a,7,5,c1,c2,c3);\\r\\nr[12]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,7,6,c2,c3,c1);\\r\\nr[13]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,7,c3,c1,c2);\\r\\nr[14]=c3;\\r\\nr[15]=c1;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t,tt;\\r\\n#else\\r\\nBN_ULONG bl,bh;\\r\\n#endif\\r\\nBN_ULONG t1,t2;\\r\\nBN_ULONG c1,c2,c3;\\r\\nc1=0;\\r\\nc2=0;\\r\\nc3=0;\\r\\nsqr_add_c(a,0,c1,c2,c3);\\r\\nr[0]=c1;\\r\\nc1=0;\\r\\nsqr_add_c2(a,1,0,c2,c3,c1);\\r\\nr[1]=c2;\\r\\nc2=0;\\r\\nsqr_add_c(a,1,c3,c1,c2);\\r\\nsqr_add_c2(a,2,0,c3,c1,c2);\\r\\nr[2]=c3;\\r\\nc3=0;\\r\\nsqr_add_c2(a,3,0,c1,c2,c3);\\r\\nsqr_add_c2(a,2,1,c1,c2,c3);\\r\\nr[3]=c1;\\r\\nc1=0;\\r\\nsqr_add_c(a,2,c2,c3,c1);\\r\\nsqr_add_c2(a,3,1,c2,c3,c1);\\r\\nr[4]=c2;\\r\\nc2=0;\\r\\nsqr_add_c2(a,3,2,c3,c1,c2);\\r\\nr[5]=c3;\\r\\nc3=0;\\r\\nsqr_add_c(a,3,c1,c2,c3);\\r\\nr[6]=c1;\\r\\nr[7]=c2;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(r,a,4,t);\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(r,a,8,t);\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[4]=bn_mul_words( &(r[0]),a,4,b[0]);\\r\\nr[5]=bn_mul_add_words(&(r[1]),a,4,b[1]);\\r\\nr[6]=bn_mul_add_words(&(r[2]),a,4,b[2]);\\r\\nr[7]=bn_mul_add_words(&(r[3]),a,4,b[3]);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[ 8]=bn_mul_words( &(r[0]),a,8,b[0]);\\r\\nr[ 9]=bn_mul_add_words(&(r[1]),a,8,b[1]);\\r\\nr[10]=bn_mul_add_words(&(r[2]),a,8,b[2]);\\r\\nr[11]=bn_mul_add_words(&(r[3]),a,8,b[3]);\\r\\nr[12]=bn_mul_add_words(&(r[4]),a,8,b[4]);\\r\\nr[13]=bn_mul_add_words(&(r[5]),a,8,b[5]);\\r\\nr[14]=bn_mul_add_words(&(r[6]),a,8,b[6]);\\r\\nr[15]=bn_mul_add_words(&(r[7]),a,8,b[7]);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_none_c", "target": 0, "func": "int RSA_padding_add_none(unsigned char *to, int tlen, unsigned char *from,\\r\\nint flen)\\r\\n{\\r\\nif (flen > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\nif (flen < tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE,RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\nmemcpy(to,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_none(unsigned char *to, int tlen, unsigned char *from,\\r\\nint flen, int num)\\r\\n{\\r\\nif (flen > tlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_NONE,RSA_R_DATA_TOO_LARGE);\\r\\nreturn(-1);\\r\\n}\\r\\nmemset(to,0,tlen-flen);\\r\\nmemcpy(to+tlen-flen,from,flen);\\r\\nreturn(tlen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2_skey_c", "target": 0, "func": "void RC2_set_key(RC2_KEY *key, int len, unsigned char *data, int bits)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *k;\\r\\nRC2_INT *ki;\\r\\nunsigned int c,d;\\r\\nk= (unsigned char *)&(key->data[0]);\\r\\n*k=0;\\r\\nif (len > 128) len=128;\\r\\nif (bits <= 0) bits=1024;\\r\\nif (bits > 1024) bits=1024;\\r\\nfor (i=0; i<len; i++)\\r\\nk[i]=data[i];\\r\\nd=k[len-1];\\r\\nj=0;\\r\\nfor (i=len; i < 128; i++,j++)\\r\\n{\\r\\nd=key_table[(k[j]+d)&0xff];\\r\\nk[i]=d;\\r\\n}\\r\\nj=(bits+7)>>3;\\r\\ni=128-j;\\r\\nc= (0xff>>(-bits & 0x07));\\r\\nd=key_table[k[i]&c];\\r\\nk[i]=d;\\r\\nwhile (i--)\\r\\n{\\r\\nd=key_table[k[i+j]^d];\\r\\nk[i]=d;\\r\\n}\\r\\nki= &(key->data[63]);\\r\\nfor (i=127; i>=0; i-=2)\\r\\n*(ki--)=((k[i]<<8)|k[i-1])&0xffff;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_enc_read_c", "target": 0, "func": "int des_enc_read(int fd, void *buf, int len, des_key_schedule sched,\\r\\ndes_cblock *iv)\\r\\n{\\r\\nint net_num=0;\\r\\nstatic unsigned char *net=NULL;\\r\\nstatic unsigned char *unnet=NULL;\\r\\nstatic int unnet_start=0;\\r\\nstatic int unnet_left=0;\\r\\nstatic unsigned char *tmpbuf=NULL;\\r\\nint i;\\r\\nlong num=0,rnum;\\r\\nunsigned char *p;\\r\\nif (tmpbuf == NULL)\\r\\n{\\r\\ntmpbuf=Malloc(BSIZE);\\r\\nif (tmpbuf == NULL) return(-1);\\r\\n}\\r\\nif (net == NULL)\\r\\n{\\r\\nnet=Malloc(BSIZE);\\r\\nif (net == NULL) return(-1);\\r\\n}\\r\\nif (unnet == NULL)\\r\\n{\\r\\nunnet=Malloc(BSIZE);\\r\\nif (unnet == NULL) return(-1);\\r\\n}\\r\\nif (unnet_left != 0)\\r\\n{\\r\\nif (unnet_left < len)\\r\\n{\\r\\nmemcpy(buf,&(unnet[unnet_start]),\\r\\nunnet_left);\\r\\ni=unnet_left;\\r\\nunnet_start=unnet_left=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(buf,&(unnet[unnet_start]),len);\\r\\nunnet_start+=len;\\r\\nunnet_left-=len;\\r\\ni=len;\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nif (len > MAXWRITE) len=MAXWRITE;\\r\\nwhile (net_num < HDRSIZE)\\r\\n{\\r\\ni=read(fd,&(net[net_num]),HDRSIZE-net_num);\\r\\n#ifdef EINTR\\r\\nif ((i == -1) && (errno == EINTR)) continue;\\r\\n#endif\\r\\nif (i <= 0) return(0);\\r\\nnet_num+=i;\\r\\n}\\r\\np=net;\\r\\nn2l(p,num);\\r\\nif ((num > MAXWRITE) || (num < 0))\\r\\nreturn(-1);\\r\\nrnum=(num < 8)?8:((num+7)/8*8);\\r\\nnet_num=0;\\r\\nwhile (net_num < rnum)\\r\\n{\\r\\ni=read(fd,&(net[net_num]),rnum-net_num);\\r\\n#ifdef EINTR\\r\\nif ((i == -1) && (errno == EINTR)) continue;\\r\\n#endif\\r\\nif (i <= 0) return(0);\\r\\nnet_num+=i;\\r\\n}\\r\\nif (len < num)\\r\\n{\\r\\nif (des_rw_mode & DES_PCBC_MODE)\\r\\ndes_pcbc_encrypt(net,unnet,num,sched,iv,DES_DECRYPT);\\r\\nelse\\r\\ndes_cbc_encrypt(net,unnet,num,sched,iv,DES_DECRYPT);\\r\\nmemcpy(buf,unnet,len);\\r\\nunnet_start=len;\\r\\nunnet_left=num-len;\\r\\nnum=len;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len < rnum)\\r\\n{\\r\\nif (des_rw_mode & DES_PCBC_MODE)\\r\\ndes_pcbc_encrypt(net,tmpbuf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nelse\\r\\ndes_cbc_encrypt(net,tmpbuf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nmemcpy(buf,tmpbuf,num);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (des_rw_mode & DES_PCBC_MODE)\\r\\ndes_pcbc_encrypt(net,buf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\nelse\\r\\ndes_cbc_encrypt(net,buf,num,sched,iv,\\r\\nDES_DECRYPT);\\r\\n}\\r\\n}\\r\\nreturn num;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_crl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nX509_CRL *x=NULL;\\r\\nint ret=1,i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile=NULL,*outfile=NULL;\\r\\nint hash=0,issuer=0,lastupdate=0,nextupdate=0,noout=0,text=0;\\r\\nchar **pp,buf[256];\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif (bio_out == NULL)\\r\\nif ((bio_out=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_out,stdout,BIO_NOCLOSE);\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\n#ifdef undef\\r\\nif (strcmp(*argv,\"-p\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!args_from_file(++argv,Nargc,Nargv)) { goto end; }*/\\r\\n}\\r\\n#endif\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv,\"-hash\") == 0)\\r\\nhash= ++num;\\r\\nelse if (strcmp(*argv,\"-issuer\") == 0)\\r\\nissuer= ++num;\\r\\nelse if (strcmp(*argv,\"-lastupdate\") == 0)\\r\\nlastupdate= ++num;\\r\\nelse if (strcmp(*argv,\"-nextupdate\") == 0)\\r\\nnextupdate= ++num;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=crl_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,*pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nX509V3_add_standard_extensions();\\r\\nx=load_crl(infile,informat);\\r\\nif (x == NULL) { goto end; }\\r\\nif (num)\\r\\n{\\r\\nfor (i=1; i<=num; i++)\\r\\n{\\r\\nif (issuer == i)\\r\\n{\\r\\nX509_NAME_oneline(x->crl->issuer,buf,256);\\r\\nBIO_printf(bio_out,\"issuer= %s\\n\",buf);\\r\\n}\\r\\nif (hash == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"%08lx\\n\",\\r\\nX509_NAME_hash(x->crl->issuer));\\r\\n}\\r\\nif (lastupdate == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"lastUpdate=\");\\r\\nASN1_TIME_print(bio_out,x->crl->lastUpdate);\\r\\nBIO_printf(bio_out,\"\\n\");\\r\\n}\\r\\nif (nextupdate == i)\\r\\n{\\r\\nBIO_printf(bio_out,\"nextUpdate=\");\\r\\nif (x->crl->nextUpdate != NULL)\\r\\nASN1_TIME_print(bio_out,x->crl->nextUpdate);\\r\\nelse\\r\\nBIO_printf(bio_out,\"NONE\");\\r\\nBIO_printf(bio_out,\"\\n\");\\r\\n}\\r\\n}\\r\\n}\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text) X509_CRL_print(out, x);\\r\\nif (noout) goto end;\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=(int)i2d_X509_CRL_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509_CRL(out,x);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) { BIO_printf(bio_err,\"unable to write CRL\\n\"); goto end; }\\r\\nret=0;\\r\\nend:\\r\\nBIO_free(out);\\r\\nBIO_free(bio_out);\\r\\nX509_CRL_free(x);\\r\\nX509V3_EXT_cleanup();\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic X509_CRL *load_crl(char *infile, int format)\\r\\n{\\r\\nX509_CRL *x=NULL;\\r\\nBIO *in=NULL;\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_X509_CRL_bio(in,NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nBIO_free(in);\\r\\nreturn(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p512_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,2);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_utf8_c", "target": 0, "func": "int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a, unsigned char **pp)\\r\\n{\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_UTF8STRING,V_ASN1_UNIVERSAL));\\r\\n}\\r\\nASN1_UTF8STRING *d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_UTF8STRING *ret=NULL;\\r\\nret=(ASN1_UTF8STRING *)d2i_ASN1_bytes((ASN1_STRING **)a,\\r\\npp,length,V_ASN1_UTF8STRING,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_UTF8STRING,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_bitstr_c", "target": 0, "func": "int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp)\\r\\n{\\r\\nint ret,j,r,bits,len;\\r\\nunsigned char *p,*d;\\r\\nif (a == NULL) return(0);\\r\\nlen=a->length;\\r\\nif (len > 0)\\r\\n{\\r\\nif (a->flags & ASN1_STRING_FLAG_BITS_LEFT)\\r\\n{\\r\\nbits=(int)a->flags&0x07;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor ( ; len > 0; len--)\\r\\n{\\r\\nif (a->data[len-1]) break;\\r\\n}\\r\\nj=a->data[len-1];\\r\\nif (j & 0x01) bits=0;\\r\\nelse if (j & 0x02) bits=1;\\r\\nelse if (j & 0x04) bits=2;\\r\\nelse if (j & 0x08) bits=3;\\r\\nelse if (j & 0x10) bits=4;\\r\\nelse if (j & 0x20) bits=5;\\r\\nelse if (j & 0x40) bits=6;\\r\\nelse if (j & 0x80) bits=7;\\r\\nelse bits=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbits=0;\\r\\nret=1+len;\\r\\nr=ASN1_object_size(0,ret,V_ASN1_BIT_STRING);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,ret,V_ASN1_BIT_STRING,V_ASN1_UNIVERSAL);\\r\\n*(p++)=(unsigned char)bits;\\r\\nd=a->data;\\r\\nmemcpy(p,d,len);\\r\\np+=len;\\r\\nif (len > 0) p[-1]&=(0xff<<bits);\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_BIT_STRING *d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_BIT_STRING *ret=NULL;\\r\\nunsigned char *p,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_BIT_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_BIT_STRING)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_A_BIT_STRING;\\r\\ngoto err;\\r\\n}\\r\\nif (len < 1) { i=ASN1_R_STRING_TOO_SHORT; goto err; }\\r\\ni= *(p++);\\r\\nret->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nret->flags|=(ASN1_STRING_FLAG_BITS_LEFT|(i&0x07));\\r\\nif (len-- > 1)\\r\\n{\\r\\ns=(unsigned char *)Malloc((int)len);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\ns[len-1]&=(0xff<<i);\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nret->length=(int)len;\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->data=s;\\r\\nret->type=V_ASN1_BIT_STRING;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_BIT_STRING,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_BIT_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)\\r\\n{\\r\\nint w,v,iv;\\r\\nunsigned char *c;\\r\\nw=n/8;\\r\\nv=1<<(7-(n&0x07));\\r\\niv= ~v;\\r\\na->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nif (a == NULL) return(0);\\r\\nif ((a->length < (w+1)) || (a->data == NULL))\\r\\n{\\r\\nif (!value) return(1);\\r\\nif (a->data == NULL)\\r\\nc=(unsigned char *)Malloc(w+1);\\r\\nelse\\r\\nc=(unsigned char *)Realloc(a->data,w+1);\\r\\nif (c == NULL) return(0);\\r\\na->data=c;\\r\\na->length=w+1;\\r\\nc[w]=0;\\r\\n}\\r\\na->data[w]=((a->data[w])&iv)|v;\\r\\nwhile ((a->length > 0) && (a->data[a->length-1] == 0))\\r\\na->length--;\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)\\r\\n{\\r\\nint w,v;\\r\\nw=n/8;\\r\\nv=1<<(7-(n&0x07));\\r\\nif ((a == NULL) || (a->length < (w+1)) || (a->data == NULL))\\r\\nreturn(0);\\r\\nreturn((a->data[w]&v) != 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_r5_c", "target": 0, "func": "EVP_CIPHER *EVP_rc5_32_12_16_ofb(void)\\r\\n{\\r\\nreturn(&rc5_ofb_cipher);\\r\\n}\\r\\nstatic void rc5_32_12_16_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC5_32_set_key(&(ctx->c.rc5_ks),EVP_RC5_32_12_16_KEY_SIZE,key,\\r\\nRC5_12_ROUNDS);\\r\\n}\\r\\nstatic void rc5_32_12_16_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC5_32_ofb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.rc5_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_crpt_c", "target": 0, "func": "void PKCS12_PBE_add(void)\\r\\n{\\r\\n#ifndef NO_RC4\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And128BitRC4, EVP_rc4(), EVP_sha1(),\\r\\nPKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And40BitRC4, EVP_rc4_40(), EVP_sha1(),\\r\\nPKCS12_PBE_keyivgen);\\r\\n#endif\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And3_Key_TripleDES_CBC,\\r\\nEVP_des_ede3_cbc(), EVP_sha1(), PKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And2_Key_TripleDES_CBC,\\r\\nEVP_des_ede_cbc(), EVP_sha1(), PKCS12_PBE_keyivgen);\\r\\n#ifndef NO_RC2\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And128BitRC2_CBC, EVP_rc2_cbc(),\\r\\nEVP_sha1(), PKCS12_PBE_keyivgen);\\r\\nEVP_PBE_alg_add(NID_pbe_WithSHA1And40BitRC2_CBC, EVP_rc2_40_cbc(),\\r\\nEVP_sha1(), PKCS12_PBE_keyivgen);\\r\\n#endif\\r\\n}\\r\\nint PKCS12_PBE_keyivgen (EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER *cipher, EVP_MD *md, int en_de)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter;\\r\\nunsigned char *salt, *pbuf;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\npbuf = param->value.sequence->data;\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe = d2i_PBEPARAM (NULL, &pbuf, param->value.sequence->length))) {\\r\\nEVPerr(PKCS12_F_PKCS12_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_KEY_ID,\\r\\niter, EVP_CIPHER_key_length(cipher), key, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_KEY_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_IV_ID,\\r\\niter, EVP_CIPHER_iv_length(cipher), iv, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_IV_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nPBEPARAM_free(pbe);\\r\\nEVP_CipherInit(ctx, cipher, key, iv, en_de);\\r\\nmemset(key, 0, EVP_MAX_KEY_LENGTH);\\r\\nmemset(iv, 0, EVP_MAX_IV_LENGTH);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_null_c", "target": 0, "func": "EVP_CIPHER *EVP_enc_null(void)\\r\\n{\\r\\nreturn(&n_cipher);\\r\\n}\\r\\nstatic void null_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nmemset(&(ctx->c),0,sizeof(ctx->c));\\r\\n}\\r\\nstatic void null_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nif (in != out)\\r\\nmemcpy((char *)out,(char *)in,(int)inl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_err2_c", "target": 0, "func": "void SSL_load_error_strings(void)\\r\\n{\\r\\n#ifndef NO_ERR\\r\\nERR_load_crypto_strings();\\r\\nERR_load_SSL_strings();\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_hdr_c", "target": 0, "func": "int i2d_ASN1_HEADER(ASN1_HEADER *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->header, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(a->data, a->meth->i2d);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->header, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(a->data, a->meth->i2d);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nASN1_HEADER *d2i_ASN1_HEADER(ASN1_HEADER **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,ASN1_HEADER *,ASN1_HEADER_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->header,d2i_ASN1_OCTET_STRING);\\r\\nif (ret->meth != NULL)\\r\\n{\\r\\nM_ASN1_D2I_get(ret->data,ret->meth->d2i);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (a != NULL) (*a)=ret;\\r\\nreturn(ret);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,ASN1_HEADER_free,ASN1_F_D2I_ASN1_HEADER);\\r\\n}\\r\\nASN1_HEADER *ASN1_HEADER_new(void)\\r\\n{\\r\\nASN1_HEADER *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,ASN1_HEADER);\\r\\nM_ASN1_New(ret->header,ASN1_OCTET_STRING_new);\\r\\nret->meth=NULL;\\r\\nret->data=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_ASN1_HEADER_NEW);\\r\\n}\\r\\nvoid ASN1_HEADER_free(ASN1_HEADER *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OCTET_STRING_free(a->header);\\r\\nif (a->meth != NULL)\\r\\na->meth->destroy(a->data);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rmd_dgst_c", "target": 0, "func": "void RIPEMD160_Init(RIPEMD160_CTX *c)\\r\\n{\\r\\nc->A=RIPEMD160_A;\\r\\nc->B=RIPEMD160_B;\\r\\nc->C=RIPEMD160_C;\\r\\nc->D=RIPEMD160_D;\\r\\nc->E=RIPEMD160_E;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\n}\\r\\nvoid RIPEMD160_Update(RIPEMD160_CTX *c, register unsigned char *data,\\r\\nunsigned long len)\\r\\n{\\r\\nregister ULONG *p;\\r\\nint sw,sc;\\r\\nULONG l;\\r\\nif (len == 0) return;\\r\\nl=(c->Nl+(len<<3))&0xffffffffL;\\r\\nif (l < c->Nl)\\r\\nc->Nh++;\\r\\nc->Nh+=(len>>29);\\r\\nc->Nl=l;\\r\\nif (c->num != 0)\\r\\n{\\r\\np=c->data;\\r\\nsw=c->num>>2;\\r\\nsc=c->num&0x03;\\r\\nif ((c->num+len) >= RIPEMD160_CBLOCK)\\r\\n{\\r\\nl= p[sw];\\r\\np_c2l(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw<RIPEMD160_LBLOCK; sw++)\\r\\n{\\r\\nc2l(data,l);\\r\\np[sw]=l;\\r\\n}\\r\\nlen-=(RIPEMD160_CBLOCK-c->num);\\r\\nripemd160_block(c,p,64);\\r\\nc->num=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nint ew,ec;\\r\\nc->num+=(int)len;\\r\\nif ((sc+len) < 4)\\r\\n{\\r\\nl= p[sw];\\r\\np_c2l_p(data,l,sc,len);\\r\\np[sw]=l;\\r\\n}\\r\\nelse\\r\\n{\\r\\new=(c->num>>2);\\r\\nec=(c->num&0x03);\\r\\nl= p[sw];\\r\\np_c2l(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw < ew; sw++)\\r\\n{ c2l(data,l); p[sw]=l; }\\r\\nif (ec)\\r\\n{\\r\\nc2l_p(data,l,ec);\\r\\np[sw]=l;\\r\\n}\\r\\n}\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n#ifdef L_ENDIAN\\r\\nif ((((unsigned long)data)%sizeof(ULONG)) == 0)\\r\\n{\\r\\nsw=(int)len/RIPEMD160_CBLOCK;\\r\\nif (sw > 0)\\r\\n{\\r\\nsw*=RIPEMD160_CBLOCK;\\r\\nripemd160_block(c,(ULONG *)data,sw);\\r\\ndata+=sw;\\r\\nlen-=sw;\\r\\n}\\r\\n}\\r\\n#endif\\r\\np=c->data;\\r\\nwhile (len >= RIPEMD160_CBLOCK)\\r\\n{\\r\\n#if defined(L_ENDIAN) || defined(B_ENDIAN)\\r\\nif (p != (unsigned long *)data)\\r\\nmemcpy(p,data,RIPEMD160_CBLOCK);\\r\\ndata+=RIPEMD160_CBLOCK;\\r\\n#ifdef B_ENDIAN\\r\\nfor (sw=(RIPEMD160_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nEndian_Reverse32(p[0]);\\r\\nEndian_Reverse32(p[1]);\\r\\nEndian_Reverse32(p[2]);\\r\\nEndian_Reverse32(p[3]);\\r\\np+=4;\\r\\n}\\r\\n#endif\\r\\n#else\\r\\nfor (sw=(RIPEMD160_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nc2l(data,l); *(p++)=l;\\r\\nc2l(data,l); *(p++)=l;\\r\\nc2l(data,l); *(p++)=l;\\r\\nc2l(data,l); *(p++)=l;\\r\\n}\\r\\n#endif\\r\\np=c->data;\\r\\nripemd160_block(c,p,64);\\r\\nlen-=RIPEMD160_CBLOCK;\\r\\n}\\r\\nsc=(int)len;\\r\\nc->num=sc;\\r\\nif (sc)\\r\\n{\\r\\nsw=sc>>2;\\r\\n#ifdef L_ENDIAN\\r\\np[sw]=0;\\r\\nmemcpy(p,data,sc);\\r\\n#else\\r\\nsc&=0x03;\\r\\nfor ( ; sw; sw--)\\r\\n{ c2l(data,l); *(p++)=l; }\\r\\nc2l_p(data,l,sc);\\r\\n*p=l;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nvoid RIPEMD160_Transform(RIPEMD160_CTX *c, unsigned char *b)\\r\\n{\\r\\nULONG p[16];\\r\\n#if !defined(L_ENDIAN)\\r\\nULONG *q;\\r\\nint i;\\r\\n#endif\\r\\n#if defined(B_ENDIAN) || defined(L_ENDIAN)\\r\\nmemcpy(p,b,64);\\r\\n#ifdef B_ENDIAN\\r\\nq=p;\\r\\nfor (i=(RIPEMD160_LBLOCK/4); i; i--)\\r\\n{\\r\\nEndian_Reverse32(q[0]);\\r\\nEndian_Reverse32(q[1]);\\r\\nEndian_Reverse32(q[2]);\\r\\nEndian_Reverse32(q[3]);\\r\\nq+=4;\\r\\n}\\r\\n#endif\\r\\n#else\\r\\nq=p;\\r\\nfor (i=(RIPEMD160_LBLOCK/4); i; i--)\\r\\n{\\r\\nULONG l;\\r\\nc2l(b,l); *(q++)=l;\\r\\nc2l(b,l); *(q++)=l;\\r\\nc2l(b,l); *(q++)=l;\\r\\nc2l(b,l); *(q++)=l;\\r\\n}\\r\\n#endif\\r\\nripemd160_block(c,p,64);\\r\\n}\\r\\nvoid ripemd160_block(RIPEMD160_CTX *ctx, register ULONG *X, int num)\\r\\n{\\r\\nregister ULONG A,B,C,D,E;\\r\\nULONG a,b,c,d,e;\\r\\nfor (;;)\\r\\n{\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nRIP1(A,B,C,D,E,WL00,SL00);\\r\\nRIP1(E,A,B,C,D,WL01,SL01);\\r\\nRIP1(D,E,A,B,C,WL02,SL02);\\r\\nRIP1(C,D,E,A,B,WL03,SL03);\\r\\nRIP1(B,C,D,E,A,WL04,SL04);\\r\\nRIP1(A,B,C,D,E,WL05,SL05);\\r\\nRIP1(E,A,B,C,D,WL06,SL06);\\r\\nRIP1(D,E,A,B,C,WL07,SL07);\\r\\nRIP1(C,D,E,A,B,WL08,SL08);\\r\\nRIP1(B,C,D,E,A,WL09,SL09);\\r\\nRIP1(A,B,C,D,E,WL10,SL10);\\r\\nRIP1(E,A,B,C,D,WL11,SL11);\\r\\nRIP1(D,E,A,B,C,WL12,SL12);\\r\\nRIP1(C,D,E,A,B,WL13,SL13);\\r\\nRIP1(B,C,D,E,A,WL14,SL14);\\r\\nRIP1(A,B,C,D,E,WL15,SL15);\\r\\nRIP2(E,A,B,C,D,WL16,SL16,KL1);\\r\\nRIP2(D,E,A,B,C,WL17,SL17,KL1);\\r\\nRIP2(C,D,E,A,B,WL18,SL18,KL1);\\r\\nRIP2(B,C,D,E,A,WL19,SL19,KL1);\\r\\nRIP2(A,B,C,D,E,WL20,SL20,KL1);\\r\\nRIP2(E,A,B,C,D,WL21,SL21,KL1);\\r\\nRIP2(D,E,A,B,C,WL22,SL22,KL1);\\r\\nRIP2(C,D,E,A,B,WL23,SL23,KL1);\\r\\nRIP2(B,C,D,E,A,WL24,SL24,KL1);\\r\\nRIP2(A,B,C,D,E,WL25,SL25,KL1);\\r\\nRIP2(E,A,B,C,D,WL26,SL26,KL1);\\r\\nRIP2(D,E,A,B,C,WL27,SL27,KL1);\\r\\nRIP2(C,D,E,A,B,WL28,SL28,KL1);\\r\\nRIP2(B,C,D,E,A,WL29,SL29,KL1);\\r\\nRIP2(A,B,C,D,E,WL30,SL30,KL1);\\r\\nRIP2(E,A,B,C,D,WL31,SL31,KL1);\\r\\nRIP3(D,E,A,B,C,WL32,SL32,KL2);\\r\\nRIP3(C,D,E,A,B,WL33,SL33,KL2);\\r\\nRIP3(B,C,D,E,A,WL34,SL34,KL2);\\r\\nRIP3(A,B,C,D,E,WL35,SL35,KL2);\\r\\nRIP3(E,A,B,C,D,WL36,SL36,KL2);\\r\\nRIP3(D,E,A,B,C,WL37,SL37,KL2);\\r\\nRIP3(C,D,E,A,B,WL38,SL38,KL2);\\r\\nRIP3(B,C,D,E,A,WL39,SL39,KL2);\\r\\nRIP3(A,B,C,D,E,WL40,SL40,KL2);\\r\\nRIP3(E,A,B,C,D,WL41,SL41,KL2);\\r\\nRIP3(D,E,A,B,C,WL42,SL42,KL2);\\r\\nRIP3(C,D,E,A,B,WL43,SL43,KL2);\\r\\nRIP3(B,C,D,E,A,WL44,SL44,KL2);\\r\\nRIP3(A,B,C,D,E,WL45,SL45,KL2);\\r\\nRIP3(E,A,B,C,D,WL46,SL46,KL2);\\r\\nRIP3(D,E,A,B,C,WL47,SL47,KL2);\\r\\nRIP4(C,D,E,A,B,WL48,SL48,KL3);\\r\\nRIP4(B,C,D,E,A,WL49,SL49,KL3);\\r\\nRIP4(A,B,C,D,E,WL50,SL50,KL3);\\r\\nRIP4(E,A,B,C,D,WL51,SL51,KL3);\\r\\nRIP4(D,E,A,B,C,WL52,SL52,KL3);\\r\\nRIP4(C,D,E,A,B,WL53,SL53,KL3);\\r\\nRIP4(B,C,D,E,A,WL54,SL54,KL3);\\r\\nRIP4(A,B,C,D,E,WL55,SL55,KL3);\\r\\nRIP4(E,A,B,C,D,WL56,SL56,KL3);\\r\\nRIP4(D,E,A,B,C,WL57,SL57,KL3);\\r\\nRIP4(C,D,E,A,B,WL58,SL58,KL3);\\r\\nRIP4(B,C,D,E,A,WL59,SL59,KL3);\\r\\nRIP4(A,B,C,D,E,WL60,SL60,KL3);\\r\\nRIP4(E,A,B,C,D,WL61,SL61,KL3);\\r\\nRIP4(D,E,A,B,C,WL62,SL62,KL3);\\r\\nRIP4(C,D,E,A,B,WL63,SL63,KL3);\\r\\nRIP5(B,C,D,E,A,WL64,SL64,KL4);\\r\\nRIP5(A,B,C,D,E,WL65,SL65,KL4);\\r\\nRIP5(E,A,B,C,D,WL66,SL66,KL4);\\r\\nRIP5(D,E,A,B,C,WL67,SL67,KL4);\\r\\nRIP5(C,D,E,A,B,WL68,SL68,KL4);\\r\\nRIP5(B,C,D,E,A,WL69,SL69,KL4);\\r\\nRIP5(A,B,C,D,E,WL70,SL70,KL4);\\r\\nRIP5(E,A,B,C,D,WL71,SL71,KL4);\\r\\nRIP5(D,E,A,B,C,WL72,SL72,KL4);\\r\\nRIP5(C,D,E,A,B,WL73,SL73,KL4);\\r\\nRIP5(B,C,D,E,A,WL74,SL74,KL4);\\r\\nRIP5(A,B,C,D,E,WL75,SL75,KL4);\\r\\nRIP5(E,A,B,C,D,WL76,SL76,KL4);\\r\\nRIP5(D,E,A,B,C,WL77,SL77,KL4);\\r\\nRIP5(C,D,E,A,B,WL78,SL78,KL4);\\r\\nRIP5(B,C,D,E,A,WL79,SL79,KL4);\\r\\na=A; b=B; c=C; d=D; e=E;\\r\\nA=ctx->A; B=ctx->B; C=ctx->C; D=ctx->D; E=ctx->E;\\r\\nRIP5(A,B,C,D,E,WR00,SR00,KR0);\\r\\nRIP5(E,A,B,C,D,WR01,SR01,KR0);\\r\\nRIP5(D,E,A,B,C,WR02,SR02,KR0);\\r\\nRIP5(C,D,E,A,B,WR03,SR03,KR0);\\r\\nRIP5(B,C,D,E,A,WR04,SR04,KR0);\\r\\nRIP5(A,B,C,D,E,WR05,SR05,KR0);\\r\\nRIP5(E,A,B,C,D,WR06,SR06,KR0);\\r\\nRIP5(D,E,A,B,C,WR07,SR07,KR0);\\r\\nRIP5(C,D,E,A,B,WR08,SR08,KR0);\\r\\nRIP5(B,C,D,E,A,WR09,SR09,KR0);\\r\\nRIP5(A,B,C,D,E,WR10,SR10,KR0);\\r\\nRIP5(E,A,B,C,D,WR11,SR11,KR0);\\r\\nRIP5(D,E,A,B,C,WR12,SR12,KR0);\\r\\nRIP5(C,D,E,A,B,WR13,SR13,KR0);\\r\\nRIP5(B,C,D,E,A,WR14,SR14,KR0);\\r\\nRIP5(A,B,C,D,E,WR15,SR15,KR0);\\r\\nRIP4(E,A,B,C,D,WR16,SR16,KR1);\\r\\nRIP4(D,E,A,B,C,WR17,SR17,KR1);\\r\\nRIP4(C,D,E,A,B,WR18,SR18,KR1);\\r\\nRIP4(B,C,D,E,A,WR19,SR19,KR1);\\r\\nRIP4(A,B,C,D,E,WR20,SR20,KR1);\\r\\nRIP4(E,A,B,C,D,WR21,SR21,KR1);\\r\\nRIP4(D,E,A,B,C,WR22,SR22,KR1);\\r\\nRIP4(C,D,E,A,B,WR23,SR23,KR1);\\r\\nRIP4(B,C,D,E,A,WR24,SR24,KR1);\\r\\nRIP4(A,B,C,D,E,WR25,SR25,KR1);\\r\\nRIP4(E,A,B,C,D,WR26,SR26,KR1);\\r\\nRIP4(D,E,A,B,C,WR27,SR27,KR1);\\r\\nRIP4(C,D,E,A,B,WR28,SR28,KR1);\\r\\nRIP4(B,C,D,E,A,WR29,SR29,KR1);\\r\\nRIP4(A,B,C,D,E,WR30,SR30,KR1);\\r\\nRIP4(E,A,B,C,D,WR31,SR31,KR1);\\r\\nRIP3(D,E,A,B,C,WR32,SR32,KR2);\\r\\nRIP3(C,D,E,A,B,WR33,SR33,KR2);\\r\\nRIP3(B,C,D,E,A,WR34,SR34,KR2);\\r\\nRIP3(A,B,C,D,E,WR35,SR35,KR2);\\r\\nRIP3(E,A,B,C,D,WR36,SR36,KR2);\\r\\nRIP3(D,E,A,B,C,WR37,SR37,KR2);\\r\\nRIP3(C,D,E,A,B,WR38,SR38,KR2);\\r\\nRIP3(B,C,D,E,A,WR39,SR39,KR2);\\r\\nRIP3(A,B,C,D,E,WR40,SR40,KR2);\\r\\nRIP3(E,A,B,C,D,WR41,SR41,KR2);\\r\\nRIP3(D,E,A,B,C,WR42,SR42,KR2);\\r\\nRIP3(C,D,E,A,B,WR43,SR43,KR2);\\r\\nRIP3(B,C,D,E,A,WR44,SR44,KR2);\\r\\nRIP3(A,B,C,D,E,WR45,SR45,KR2);\\r\\nRIP3(E,A,B,C,D,WR46,SR46,KR2);\\r\\nRIP3(D,E,A,B,C,WR47,SR47,KR2);\\r\\nRIP2(C,D,E,A,B,WR48,SR48,KR3);\\r\\nRIP2(B,C,D,E,A,WR49,SR49,KR3);\\r\\nRIP2(A,B,C,D,E,WR50,SR50,KR3);\\r\\nRIP2(E,A,B,C,D,WR51,SR51,KR3);\\r\\nRIP2(D,E,A,B,C,WR52,SR52,KR3);\\r\\nRIP2(C,D,E,A,B,WR53,SR53,KR3);\\r\\nRIP2(B,C,D,E,A,WR54,SR54,KR3);\\r\\nRIP2(A,B,C,D,E,WR55,SR55,KR3);\\r\\nRIP2(E,A,B,C,D,WR56,SR56,KR3);\\r\\nRIP2(D,E,A,B,C,WR57,SR57,KR3);\\r\\nRIP2(C,D,E,A,B,WR58,SR58,KR3);\\r\\nRIP2(B,C,D,E,A,WR59,SR59,KR3);\\r\\nRIP2(A,B,C,D,E,WR60,SR60,KR3);\\r\\nRIP2(E,A,B,C,D,WR61,SR61,KR3);\\r\\nRIP2(D,E,A,B,C,WR62,SR62,KR3);\\r\\nRIP2(C,D,E,A,B,WR63,SR63,KR3);\\r\\nRIP1(B,C,D,E,A,WR64,SR64);\\r\\nRIP1(A,B,C,D,E,WR65,SR65);\\r\\nRIP1(E,A,B,C,D,WR66,SR66);\\r\\nRIP1(D,E,A,B,C,WR67,SR67);\\r\\nRIP1(C,D,E,A,B,WR68,SR68);\\r\\nRIP1(B,C,D,E,A,WR69,SR69);\\r\\nRIP1(A,B,C,D,E,WR70,SR70);\\r\\nRIP1(E,A,B,C,D,WR71,SR71);\\r\\nRIP1(D,E,A,B,C,WR72,SR72);\\r\\nRIP1(C,D,E,A,B,WR73,SR73);\\r\\nRIP1(B,C,D,E,A,WR74,SR74);\\r\\nRIP1(A,B,C,D,E,WR75,SR75);\\r\\nRIP1(E,A,B,C,D,WR76,SR76);\\r\\nRIP1(D,E,A,B,C,WR77,SR77);\\r\\nRIP1(C,D,E,A,B,WR78,SR78);\\r\\nRIP1(B,C,D,E,A,WR79,SR79);\\r\\nD =ctx->B+c+D;\\r\\nctx->B=ctx->C+d+E;\\r\\nctx->C=ctx->D+e+A;\\r\\nctx->D=ctx->E+a+B;\\r\\nctx->E=ctx->A+b+C;\\r\\nctx->A=D;\\r\\nX+=16;\\r\\nnum-=64;\\r\\nif (num <= 0) break;\\r\\n}\\r\\n}\\r\\nvoid RIPEMD160_Final(unsigned char *md, RIPEMD160_CTX *c)\\r\\n{\\r\\nregister int i,j;\\r\\nregister ULONG l;\\r\\nregister ULONG *p;\\r\\nstatic unsigned char end[4]={0x80,0x00,0x00,0x00};\\r\\nunsigned char *cp=end;\\r\\np=c->data;\\r\\nj=c->num;\\r\\ni=j>>2;\\r\\n#ifdef PURIFY\\r\\nif ((j&0x03) == 0) p[i]=0;\\r\\n#endif\\r\\nl=p[i];\\r\\np_c2l(cp,l,j&0x03);\\r\\np[i]=l;\\r\\ni++;\\r\\nif (c->num >= RIPEMD160_LAST_BLOCK)\\r\\n{\\r\\nfor (; i<RIPEMD160_LBLOCK; i++)\\r\\np[i]=0;\\r\\nripemd160_block(c,p,64);\\r\\ni=0;\\r\\n}\\r\\nfor (; i<(RIPEMD160_LBLOCK-2); i++)\\r\\np[i]=0;\\r\\np[RIPEMD160_LBLOCK-2]=c->Nl;\\r\\np[RIPEMD160_LBLOCK-1]=c->Nh;\\r\\nripemd160_block(c,p,64);\\r\\ncp=md;\\r\\nl=c->A; l2c(l,cp);\\r\\nl=c->B; l2c(l,cp);\\r\\nl=c->C; l2c(l,cp);\\r\\nl=c->D; l2c(l,cp);\\r\\nl=c->E; l2c(l,cp);\\r\\nc->num=0;\\r\\n}\\r\\nint printit(unsigned long *l)\\r\\n{\\r\\nint i,ii;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nfor (ii=0; ii<8; ii++)\\r\\n{\\r\\nfprintf(stderr,\"%08lx \",l[i*8+ii]);\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_lib_c", "target": 0, "func": "int i2d_PKCS12(PKCS12 *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len (a->authsafes, i2d_PKCS7);\\r\\nM_ASN1_I2D_len (a->mac, i2d_PKCS12_MAC_DATA);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put (a->authsafes, i2d_PKCS7);\\r\\nM_ASN1_I2D_put (a->mac, i2d_PKCS12_MAC_DATA);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS12 *d2i_PKCS12(PKCS12 **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS12 *,PKCS12_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->version, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get (ret->authsafes, d2i_PKCS7);\\r\\nM_ASN1_D2I_get_opt (ret->mac, d2i_PKCS12_MAC_DATA, V_ASN1_SEQUENCE);\\r\\nM_ASN1_D2I_Finish(a, PKCS12_free, ASN1_F_D2I_PKCS12);\\r\\n}\\r\\nPKCS12 *PKCS12_new(void)\\r\\n{\\r\\nPKCS12 *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKCS12);\\r\\nret->version=NULL;\\r\\nret->mac=NULL;\\r\\nret->authsafes=NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS12_NEW);\\r\\n}\\r\\nvoid PKCS12_free (PKCS12 *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free (a->version);\\r\\nPKCS12_MAC_DATA_free (a->mac);\\r\\nPKCS7_free (a->authsafes);\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_err_c", "target": 1, "func": "void ERR_load_DSA_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_DSA,DSA_str_functs);\\r\\nERR_load_strings(ERR_LIB_DSA,DSA_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s_time_c", "target": 0, "func": "static void s_time_init(void)\\r\\n{\\r\\nhost=SSL_CONNECT_NAME;\\r\\nt_cert_file=NULL;\\r\\nt_key_file=NULL;\\r\\nCApath=NULL;\\r\\nCAfile=NULL;\\r\\ntm_cipher=NULL;\\r\\ntm_verify = SSL_VERIFY_NONE;\\r\\nmaxTime = SECONDS;\\r\\ntm_ctx=NULL;\\r\\ns_time_meth=NULL;\\r\\ns_www_path=NULL;\\r\\nbytes_read=0;\\r\\nst_bugs=0;\\r\\nperform=0;\\r\\n#ifdef FIONBIO\\r\\nt_nbio=0;\\r\\n#endif\\r\\n#ifdef WIN32\\r\\nexitNow = 0;\\r\\n#endif\\r\\n}\\r\\nstatic void s_time_usage(void)\\r\\n{\\r\\nstatic char umsg[] = \"\\\\r\\n-time arg - max number of seconds to collect data, default %d\\n\\\\r\\n-verify arg - turn on peer certificate verification, arg == depth\\n\\\\r\\n-cert arg - certificate file to use, PEM format assumed\\n\\\\r\\n-key arg - RSA file to use, PEM format assumed, key is in cert file\\n\\\\r\\nfile if not specified by this option\\n\\\\r\\n-CApath arg - PEM format directory of CA's\\n\\\\r\\n-CAfile arg - PEM format file of CA's\\n\\\\r\\n-cipher - prefered cipher to use, play with 'openssl ciphers'\\n\\n\";\\r\\nprintf( \"usage: s_time <args>\\n\\n\" );\\r\\nprintf(\"-connect host:port - host:port to connect to (default is %s)\\n\",SSL_CONNECT_NAME);\\r\\n#ifdef FIONBIO\\r\\nprintf(\"-nbio - Run with non-blocking IO\\n\");\\r\\nprintf(\"-ssl2 - Just use SSLv2\\n\");\\r\\nprintf(\"-ssl3 - Just use SSLv3\\n\");\\r\\nprintf(\"-bugs - Turn on SSL bug compatability\\n\");\\r\\nprintf(\"-new - Just time new connections\\n\");\\r\\nprintf(\"-reuse - Just time connection reuse\\n\");\\r\\nprintf(\"-www page - Retrieve 'page' from the site\\n\");\\r\\n#endif\\r\\nprintf( umsg,SECONDS );\\r\\n}\\r\\nstatic int parseArgs(int argc, char **argv)\\r\\n{\\r\\nint badop = 0;\\r\\nverify_depth=0;\\r\\nverify_error=X509_V_OK;\\r\\n#ifdef FIONBIO\\r\\nt_nbio=0;\\r\\n#endif\\r\\napps_startup();\\r\\ns_time_init();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv,\"-connect\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\n#if 0\\r\\nelse if( strcmp(*argv,\"-host\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\nelse if( strcmp(*argv,\"-port\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nport= *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-reuse\") == 0)\\r\\nperform=2;\\r\\nelse if (strcmp(*argv,\"-new\") == 0)\\r\\nperform=1;\\r\\nelse if( strcmp(*argv,\"-verify\") == 0) {\\r\\ntm_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n} else if( strcmp(*argv,\"-cert\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nt_cert_file= *(++argv);\\r\\n} else if( strcmp(*argv,\"-key\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nt_key_file= *(++argv);\\r\\n} else if( strcmp(*argv,\"-CApath\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n} else if( strcmp(*argv,\"-CAfile\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n} else if( strcmp(*argv,\"-cipher\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\ntm_cipher= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if(strcmp(*argv,\"-nbio\") == 0) {\\r\\nt_nbio=1;\\r\\n}\\r\\n#endif\\r\\nelse if(strcmp(*argv,\"-www\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_www_path= *(++argv);\\r\\n}\\r\\nelse if(strcmp(*argv,\"-bugs\") == 0)\\r\\nst_bugs=1;\\r\\n#ifndef NO_SSL2\\r\\nelse if(strcmp(*argv,\"-ssl2\") == 0)\\r\\ns_time_meth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\nelse if(strcmp(*argv,\"-ssl3\") == 0)\\r\\ns_time_meth=SSLv3_client_method();\\r\\n#endif\\r\\nelse if( strcmp(*argv,\"-time\") == 0) {\\r\\nif (--argc < 1) goto bad;\\r\\nmaxTime= atoi(*(++argv));\\r\\n}\\r\\nelse {\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (perform == 0) perform=3;\\r\\nif(badop) {\\r\\nbad:\\r\\ns_time_usage();\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic double tm_Time_F(int s)\\r\\n{\\r\\nstatic double ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif(s == START) {\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n} else {\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif(s == START) {\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n} else {\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\ndouble totalTime = 0.0;\\r\\nint nConn = 0;\\r\\nSSL *scon=NULL;\\r\\nlong finishtime=0;\\r\\nint ret=1,i;\\r\\nMS_STATIC char buf[1024*8];\\r\\nint ver;\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\ns_time_meth=SSLv23_client_method();\\r\\n#elif !defined(NO_SSL3)\\r\\ns_time_meth=SSLv3_client_method();\\r\\n#elif !defined(NO_SSL2)\\r\\ns_time_meth=SSLv2_client_method();\\r\\n#endif\\r\\nif( parseArgs( argc, argv ) < 0 )\\r\\ngoto end;\\r\\nSSLeay_add_ssl_algorithms();\\r\\nif ((tm_ctx=SSL_CTX_new(s_time_meth)) == NULL) return(1);\\r\\nSSL_CTX_set_quiet_shutdown(tm_ctx,1);\\r\\nif (st_bugs) SSL_CTX_set_options(tm_ctx,SSL_OP_ALL);\\r\\nSSL_CTX_set_cipher_list(tm_ctx,tm_cipher);\\r\\nif(!set_cert_stuff(tm_ctx,t_cert_file,t_key_file))\\r\\ngoto end;\\r\\nSSL_load_error_strings();\\r\\nif ((!SSL_CTX_load_verify_locations(tm_ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(tm_ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (tm_cipher == NULL)\\r\\ntm_cipher = getenv(\"SSL_CIPHER\");\\r\\nif (tm_cipher == NULL ) {\\r\\nfprintf( stderr, \"No CIPHER specified\\n\" );\\r\\n}\\r\\nif (!(perform & 1)) goto next;\\r\\nprintf( \"Collecting connection statistics for %d seconds\\n\", maxTime );\\r\\nbytes_read=0;\\r\\nfinishtime=(long)time(NULL)+maxTime;\\r\\ntm_Time_F(START);\\r\\nfor (;;)\\r\\n{\\r\\nif (finishtime < time(NULL)) break;\\r\\n#ifdef WIN32_STUFF\\r\\nif( flushWinMsgs(0) == -1 )\\r\\ngoto end;\\r\\nif( waitingToDie || exitNow )\\r\\ngoto end;\\r\\n#endif\\r\\nif( (scon = doConnection( NULL )) == NULL )\\r\\ngoto end;\\r\\nif (s_www_path != NULL)\\r\\n{\\r\\nsprintf(buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile ((i=SSL_read(scon,buf,sizeof(buf))) > 0)\\r\\nbytes_read+=i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver='r';\\r\\nelse\\r\\n{\\r\\nver=SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver='t';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver='3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver='2';\\r\\nelse\\r\\nver='*';\\r\\n}\\r\\nfputc(ver,stdout);\\r\\nfflush(stdout);\\r\\nSSL_free( scon );\\r\\nscon=NULL;\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\ni=(int)(time(NULL)-finishtime+maxTime);\\r\\nprintf( \"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\", nConn, totalTime, ((double)nConn/totalTime),bytes_read);\\r\\nprintf( \"%d connections in %ld real seconds, %ld bytes read per connection\\n\",nConn,time(NULL)-finishtime+maxTime,bytes_read/nConn);\\r\\nnext:\\r\\nif (!(perform & 2)) goto end;\\r\\nprintf( \"\\n\\nNow timing with session id reuse.\\n\" );\\r\\nif( (scon = doConnection( NULL )) == NULL )\\r\\n{\\r\\nfprintf( stderr, \"Unable to get connection\\n\" );\\r\\ngoto end;\\r\\n}\\r\\nif (s_www_path != NULL)\\r\\n{\\r\\nsprintf(buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile (SSL_read(scon,buf,sizeof(buf)) > 0)\\r\\n;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn = 0;\\r\\ntotalTime = 0.0;\\r\\nfinishtime=time(NULL)+maxTime;\\r\\nprintf( \"starting\\n\" );\\r\\nbytes_read=0;\\r\\ntm_Time_F(START);\\r\\nfor (;;)\\r\\n{\\r\\nif (finishtime < time(NULL)) break;\\r\\n#ifdef WIN32_STUFF\\r\\nif( flushWinMsgs(0) == -1 )\\r\\ngoto end;\\r\\nif( waitingToDie || exitNow )\\r\\ngoto end;\\r\\n#endif\\r\\nif( (doConnection( scon )) == NULL )\\r\\ngoto end;\\r\\nif (s_www_path)\\r\\n{\\r\\nsprintf(buf,\"GET %s HTTP/1.0\\r\\n\\r\\n\",s_www_path);\\r\\nSSL_write(scon,buf,strlen(buf));\\r\\nwhile ((i=SSL_read(scon,buf,sizeof(buf))) > 0)\\r\\nbytes_read+=i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver='r';\\r\\nelse\\r\\n{\\r\\nver=SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver='t';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver='3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver='2';\\r\\nelse\\r\\nver='*';\\r\\n}\\r\\nfputc(ver,stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\nprintf( \"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\", nConn, totalTime, ((double)nConn/totalTime),bytes_read);\\r\\nprintf( \"%d connections in %ld real seconds, %ld bytes read per connection\\n\",nConn,time(NULL)-finishtime+maxTime,bytes_read/nConn);\\r\\nret=0;\\r\\nend:\\r\\nif (scon != NULL) SSL_free(scon);\\r\\nif (tm_ctx != NULL)\\r\\n{\\r\\nSSL_CTX_free(tm_ctx);\\r\\ntm_ctx=NULL;\\r\\n}\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic SSL *doConnection(SSL *scon)\\r\\n{\\r\\nBIO *conn;\\r\\nSSL *serverCon;\\r\\nint width, i;\\r\\nfd_set readfds;\\r\\nif ((conn=BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_set_conn_hostname(conn,host);\\r\\nif (scon == NULL)\\r\\nserverCon=(SSL *)SSL_new(tm_ctx);\\r\\nelse\\r\\n{\\r\\nserverCon=scon;\\r\\nSSL_set_connect_state(serverCon);\\r\\n}\\r\\nSSL_set_bio(serverCon,conn,conn);\\r\\n#if 0\\r\\nif( scon != NULL )\\r\\nSSL_set_session(serverCon,SSL_get_session(scon));\\r\\n#endif\\r\\nfor(;;) {\\r\\ni=SSL_connect(serverCon);\\r\\nif (BIO_sock_should_retry(i))\\r\\n{\\r\\nBIO_printf(bio_err,\"DELAY\\n\");\\r\\ni=SSL_get_fd(serverCon);\\r\\nwidth=i+1;\\r\\nFD_ZERO(&readfds);\\r\\nFD_SET(i,&readfds);\\r\\nselect(width,(void *)&readfds,NULL,NULL,NULL);\\r\\ncontinue;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif(i <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR\\n\");\\r\\nif (verify_error != X509_V_OK)\\r\\nBIO_printf(bio_err,\"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nif (scon == NULL)\\r\\nSSL_free(serverCon);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn serverCon;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_conf_err_c", "target": 0, "func": "void ERR_load_CONF_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_CONF,CONF_str_functs);\\r\\nERR_load_strings(ERR_LIB_CONF,CONF_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_gen_c", "target": 1, "func": "RSA *RSA_generate_key(int bits, unsigned long e_value,\\r\\nvoid (*callback)(int,int,void *), void *cb_arg)\\r\\n{\\r\\nRSA *rsa=NULL;\\r\\nBIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;\\r\\nint bitsp,bitsq,ok= -1,n=0,i;\\r\\nBN_CTX *ctx=NULL,*ctx2=NULL;\\r\\nctx=BN_CTX_new();\\r\\nif (ctx == NULL) goto err;\\r\\nctx2=BN_CTX_new();\\r\\nif (ctx2 == NULL) goto err;\\r\\nr0= &(ctx->bn[0]);\\r\\nr1= &(ctx->bn[1]);\\r\\nr2= &(ctx->bn[2]);\\r\\nr3= &(ctx->bn[3]);\\r\\nctx->tos+=4;\\r\\nbitsp=(bits+1)/2;\\r\\nbitsq=bits-bitsp;\\r\\nrsa=RSA_new();\\r\\nif (rsa == NULL) goto err;\\r\\nrsa->e=BN_new();\\r\\nif (rsa->e == NULL) goto err;\\r\\n#if 1\\r\\nfor (i=0; i<sizeof(unsigned long)*8; i++)\\r\\n{\\r\\nif (e_value & (1<<i))\\r\\nBN_set_bit(rsa->e,i);\\r\\n}\\r\\n#else\\r\\nif (!BN_set_word(rsa->e,e_value)) goto err;\\r\\n#endif\\r\\nfor (;;)\\r\\n{\\r\\nrsa->p=BN_generate_prime(NULL,bitsp,0,NULL,NULL,callback,cb_arg);\\r\\nif (rsa->p == NULL) goto err;\\r\\nif (!BN_sub(r2,rsa->p,BN_value_one())) goto err;\\r\\nif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\\r\\nif (BN_is_one(r1)) break;\\r\\nif (callback != NULL) callback(2,n++,cb_arg);\\r\\nBN_free(rsa->p);\\r\\n}\\r\\nif (callback != NULL) callback(3,0,cb_arg);\\r\\nfor (;;)\\r\\n{\\r\\nrsa->q=BN_generate_prime(NULL,bitsq,0,NULL,NULL,callback,cb_arg);\\r\\nif (rsa->q == NULL) goto err;\\r\\nif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\\r\\nif (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;\\r\\nif (BN_is_one(r1) && (BN_cmp(rsa->p,rsa->q) != 0))\\r\\nbreak;\\r\\nif (callback != NULL) callback(2,n++,cb_arg);\\r\\nBN_free(rsa->q);\\r\\n}\\r\\nif (callback != NULL) callback(3,1,cb_arg);\\r\\nif (BN_cmp(rsa->p,rsa->q) < 0)\\r\\n{\\r\\ntmp=rsa->p;\\r\\nrsa->p=rsa->q;\\r\\nrsa->q=tmp;\\r\\n}\\r\\nrsa->n=BN_new();\\r\\nif (rsa->n == NULL) goto err;\\r\\nif (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;\\r\\nif (!BN_sub(r1,rsa->p,BN_value_one())) goto err;\\r\\nif (!BN_sub(r2,rsa->q,BN_value_one())) goto err;\\r\\nif (!BN_mul(r0,r1,r2,ctx)) goto err;\\r\\nrsa->d=BN_mod_inverse(NULL,rsa->e,r0,ctx2);\\r\\nif (rsa->d == NULL) goto err;\\r\\nrsa->dmp1=BN_new();\\r\\nif (rsa->dmp1 == NULL) goto err;\\r\\nif (!BN_mod(rsa->dmp1,rsa->d,r1,ctx)) goto err;\\r\\nrsa->dmq1=BN_new();\\r\\nif (rsa->dmq1 == NULL) goto err;\\r\\nif (!BN_mod(rsa->dmq1,rsa->d,r2,ctx)) goto err;\\r\\nrsa->iqmp=BN_mod_inverse(NULL,rsa->q,rsa->p,ctx2);\\r\\nif (rsa->iqmp == NULL) goto err;\\r\\nok=1;\\r\\nerr:\\r\\nif (ok == -1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_GENERATE_KEY,ERR_LIB_BN);\\r\\nok=0;\\r\\n}\\r\\nBN_CTX_free(ctx);\\r\\nBN_CTX_free(ctx2);\\r\\nif (!ok)\\r\\n{\\r\\nif (rsa != NULL) RSA_free(rsa);\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nreturn(rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_lh_stats_c", "target": 0, "func": "void lh_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nfprintf(out,\"num_items = %lu\\n\",lh->num_items);\\r\\nfprintf(out,\"num_nodes = %u\\n\",lh->num_nodes);\\r\\nfprintf(out,\"num_alloc_nodes = %u\\n\",lh->num_alloc_nodes);\\r\\nfprintf(out,\"num_expands = %lu\\n\",lh->num_expands);\\r\\nfprintf(out,\"num_expand_reallocs = %lu\\n\",lh->num_expand_reallocs);\\r\\nfprintf(out,\"num_contracts = %lu\\n\",lh->num_contracts);\\r\\nfprintf(out,\"num_contract_reallocs = %lu\\n\",lh->num_contract_reallocs);\\r\\nfprintf(out,\"num_hash_calls = %lu\\n\",lh->num_hash_calls);\\r\\nfprintf(out,\"num_comp_calls = %lu\\n\",lh->num_comp_calls);\\r\\nfprintf(out,\"num_insert = %lu\\n\",lh->num_insert);\\r\\nfprintf(out,\"num_replace = %lu\\n\",lh->num_replace);\\r\\nfprintf(out,\"num_delete = %lu\\n\",lh->num_delete);\\r\\nfprintf(out,\"num_no_delete = %lu\\n\",lh->num_no_delete);\\r\\nfprintf(out,\"num_retrieve = %lu\\n\",lh->num_retrieve);\\r\\nfprintf(out,\"num_retrieve_miss = %lu\\n\",lh->num_retrieve_miss);\\r\\nfprintf(out,\"num_hash_comps = %lu\\n\",lh->num_hash_comps);\\r\\n#ifdef DEBUG\\r\\nfprintf(out,\"p = %u\\n\",lh->p);\\r\\nfprintf(out,\"pmax = %u\\n\",lh->pmax);\\r\\nfprintf(out,\"up_load = %lu\\n\",lh->up_load);\\r\\nfprintf(out,\"down_load = %lu\\n\",lh->down_load);\\r\\n#endif\\r\\n}\\r\\nvoid lh_node_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i,num;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nfprintf(out,\"node %6u -> %3u\\n\",i,num);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total=0,n_used=0;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nif (num != 0)\\r\\n{\\r\\nn_used++;\\r\\ntotal+=num;\\r\\n}\\r\\n}\\r\\nfprintf(out,\"%lu nodes used out of %u\\n\",n_used,lh->num_nodes);\\r\\nfprintf(out,\"%lu items\\n\",total);\\r\\nif (n_used == 0) return;\\r\\nfprintf(out,\"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total/lh->num_nodes),\\r\\n(int)((total%lh->num_nodes)*100/lh->num_nodes),\\r\\n(int)(total/n_used),\\r\\n(int)((total%n_used)*100/n_used));\\r\\n}\\r\\nvoid lh_stats(LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_stats(LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_node_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_usage_stats(LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp=BIO_new(BIO_s_file());\\r\\nif (bp == NULL) goto end;\\r\\nBIO_set_fp(bp,fp,BIO_NOCLOSE);\\r\\nlh_node_usage_stats_bio(lh,bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_stats_bio(LHASH *lh, BIO *out)\\r\\n{\\r\\nchar buf[128];\\r\\nsprintf(buf,\"num_items = %lu\\n\",lh->num_items);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_nodes = %u\\n\",lh->num_nodes);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_alloc_nodes = %u\\n\",lh->num_alloc_nodes);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_expands = %lu\\n\",lh->num_expands);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_expand_reallocs = %lu\\n\",lh->num_expand_reallocs);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_contracts = %lu\\n\",lh->num_contracts);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_contract_reallocs = %lu\\n\",lh->num_contract_reallocs);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_hash_calls = %lu\\n\",lh->num_hash_calls);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_comp_calls = %lu\\n\",lh->num_comp_calls);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_insert = %lu\\n\",lh->num_insert);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_replace = %lu\\n\",lh->num_replace);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_delete = %lu\\n\",lh->num_delete);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_no_delete = %lu\\n\",lh->num_no_delete);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_retrieve = %lu\\n\",lh->num_retrieve);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_retrieve_miss = %lu\\n\",lh->num_retrieve_miss);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"num_hash_comps = %lu\\n\",lh->num_hash_comps);\\r\\nBIO_puts(out,buf);\\r\\n#ifdef DEBUG\\r\\nsprintf(buf,\"p = %u\\n\",lh->p);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"pmax = %u\\n\",lh->pmax);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"up_load = %lu\\n\",lh->up_load);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"down_load = %lu\\n\",lh->down_load);\\r\\nBIO_puts(out,buf);\\r\\n#endif\\r\\n}\\r\\nvoid lh_node_stats_bio(LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i,num;\\r\\nchar buf[128];\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nsprintf(buf,\"node %6u -> %3u\\n\",i,num);\\r\\nBIO_puts(out,buf);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats_bio(LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total=0,n_used=0;\\r\\nchar buf[128];\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nfor (n=lh->b[i],num=0; n != NULL; n=n->next)\\r\\nnum++;\\r\\nif (num != 0)\\r\\n{\\r\\nn_used++;\\r\\ntotal+=num;\\r\\n}\\r\\n}\\r\\nsprintf(buf,\"%lu nodes used out of %u\\n\",n_used,lh->num_nodes);\\r\\nBIO_puts(out,buf);\\r\\nsprintf(buf,\"%lu items\\n\",total);\\r\\nBIO_puts(out,buf);\\r\\nif (n_used == 0) return;\\r\\nsprintf(buf,\"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total/lh->num_nodes),\\r\\n(int)((total%lh->num_nodes)*100/lh->num_nodes),\\r\\n(int)(total/n_used),\\r\\n(int)((total%n_used)*100/n_used));\\r\\nBIO_puts(out,buf);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_opts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic char key[16]={ 0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nBF_KEY sch;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most acurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nBF_set_key(&sch,16,key);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nBF_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\ntime_it(BF_encrypt_normal, \"BF_encrypt_normal \", 0);\\r\\ntime_it(BF_encrypt_ptr, \"BF_encrypt_ptr \", 1);\\r\\ntime_it(BF_encrypt_ptr2, \"BF_encrypt_ptr2 \", 2);\\r\\nnum+=3;\\r\\nstr[0]=\"<nothing>\";\\r\\nprint_it(\"BF_encrypt_normal \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"ptr \";\\r\\nprint_it(\"BF_encrypt_ptr \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\"ptr2 \";\\r\\nprint_it(\"BF_encrypt_ptr2 \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\nprintf(\"options BF ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DBF_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DBF_PTR\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DBF_PTR2\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_digest_c", "target": 0, "func": "void EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)\\r\\n{\\r\\nctx->digest=type;\\r\\ntype->init(&(ctx->md));\\r\\n}\\r\\nvoid EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data,\\r\\nunsigned int count)\\r\\n{\\r\\nctx->digest->update(&(ctx->md.base[0]),data,(unsigned long)count);\\r\\n}\\r\\nvoid EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\\r\\n{\\r\\nctx->digest->final(md,&(ctx->md.base[0]));\\r\\nif (size != NULL)\\r\\n*size=ctx->digest->md_size;\\r\\nmemset(&(ctx->md),0,sizeof(ctx->md));\\r\\n}\\r\\nint EVP_MD_CTX_copy(EVP_MD_CTX *out, EVP_MD_CTX *in)\\r\\n{\\r\\nif ((in == NULL) || (in->digest == NULL)) {\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY,EVP_R_INPUT_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy((char *)out,(char *)in,in->digest->ctx_size);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509type_c", "target": 0, "func": "int X509_certificate_type(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret=0,i;\\r\\nif (x == NULL) return(0);\\r\\nif (pkey == NULL)\\r\\npk=X509_get_pubkey(x);\\r\\nelse\\r\\npk=pkey;\\r\\nif (pk == NULL) return(0);\\r\\nswitch (pk->type)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\nret=EVP_PK_RSA|EVP_PKT_SIGN;\\r\\nret|=EVP_PKT_ENC;\\r\\nbreak;\\r\\ncase EVP_PKEY_DSA:\\r\\nret=EVP_PK_DSA|EVP_PKT_SIGN;\\r\\nbreak;\\r\\ncase EVP_PKEY_DH:\\r\\nret=EVP_PK_DH|EVP_PKT_EXCH;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\ni=X509_get_signature_type(x);\\r\\nswitch (i)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\nret|=EVP_PKS_RSA;\\r\\nbreak;\\r\\ncase EVP_PKS_DSA:\\r\\nret|=EVP_PKS_DSA;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (EVP_PKEY_size(pk) <= 512)\\r\\nret|=EVP_PKT_EXP;\\r\\nif(pkey==NULL) EVP_PKEY_free(pk);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nDH *dh=NULL;\\r\\nint i,badops=0,text=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,check=0,noout=0,C=0,ret=1;\\r\\nchar *infile,*outfile,*prog;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -check check the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -text print a text form of the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\" -noout no output\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\ndh=d2i_DHparams_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndh=PEM_read_bio_DHparams(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dh == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nDHparams_print(out,dh);\\r\\n#ifdef undef\\r\\nprintf(\"p=\");\\r\\nBN_print(stdout,dh->p);\\r\\nprintf(\"\\ng=\");\\r\\nBN_print(stdout,dh->g);\\r\\nprintf(\"\\n\");\\r\\nif (dh->length != 0)\\r\\nprintf(\"recomented private length=%ld\\n\",dh->length);\\r\\n#endif\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nif (!DH_check(dh,&i))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i & DH_CHECK_P_NOT_PRIME)\\r\\nprintf(\"p value is not prime\\n\");\\r\\nif (i & DH_CHECK_P_NOT_STRONG_PRIME)\\r\\nprintf(\"p value is not a strong prime\\n\");\\r\\nif (i & DH_UNABLE_TO_CHECK_GENERATOR)\\r\\nprintf(\"unable to check the generator value\\n\");\\r\\nif (i & DH_NOT_SUITABLE_GENERATOR)\\r\\nprintf(\"the g value is not a generator\\n\");\\r\\nif (i == 0)\\r\\nprintf(\"DH parameters appear to be ok.\\n\");\\r\\n}\\r\\nif (C)\\r\\n{\\r\\nunsigned char *data;\\r\\nint len,l,bits;\\r\\nlen=BN_num_bytes(dh->p);\\r\\nbits=BN_num_bits(dh->p);\\r\\ndata=(unsigned char *)Malloc(len);\\r\\nif (data == NULL)\\r\\n{\\r\\nperror(\"Malloc\");\\r\\ngoto end;\\r\\n}\\r\\nl=BN_bn2bin(dh->p,data);\\r\\nprintf(\"static unsigned char dh%d_p[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl=BN_bn2bin(dh->g,data);\\r\\nprintf(\"static unsigned char dh%d_g[]={\",bits);\\r\\nfor (i=0; i<l; i++)\\r\\n{\\r\\nif ((i%12) == 0) printf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\",data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\\n\");\\r\\nprintf(\"DH *get_dh%d()\\n\\t{\\n\",bits);\\r\\nprintf(\"\\tDH *dh;\\n\\n\");\\r\\nprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\\r\\nbits,bits);\\r\\nprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\\r\\nprintf(\"\\t\\treturn(NULL);\\n\");\\r\\nprintf(\"\\treturn(dh);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DHparams_bio(out,dh);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DHparams(out,dh);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write DH paramaters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (dh != NULL) DH_free(dh);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p5_crpt2_c", "target": 0, "func": "int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter,\\r\\nint keylen, unsigned char *out)\\r\\n{\\r\\nunsigned char digtmp[SHA_DIGEST_LENGTH], *p, itmp[4];\\r\\nint cplen, j, k, tkeylen;\\r\\nunsigned long i = 1;\\r\\nHMAC_CTX hctx;\\r\\np = out;\\r\\ntkeylen = keylen;\\r\\nif(passlen == -1) passlen = strlen(pass);\\r\\nwhile(tkeylen) {\\r\\nif(tkeylen > SHA_DIGEST_LENGTH) cplen = SHA_DIGEST_LENGTH;\\r\\nelse cplen = tkeylen;\\r\\nitmp[0] = (unsigned char)((i >> 24) & 0xff);\\r\\nitmp[1] = (unsigned char)((i >> 16) & 0xff);\\r\\nitmp[2] = (unsigned char)((i >> 8) & 0xff);\\r\\nitmp[3] = (unsigned char)(i & 0xff);\\r\\nHMAC_Init(&hctx, pass, passlen, EVP_sha1());\\r\\nHMAC_Update(&hctx, salt, saltlen);\\r\\nHMAC_Update(&hctx, itmp, 4);\\r\\nHMAC_Final(&hctx, digtmp, NULL);\\r\\nmemcpy(p, digtmp, cplen);\\r\\nfor(j = 1; j < iter; j++) {\\r\\nHMAC(EVP_sha1(), pass, passlen,\\r\\ndigtmp, SHA_DIGEST_LENGTH, digtmp, NULL);\\r\\nfor(k = 0; k < cplen; k++) p[k] ^= digtmp[k];\\r\\n}\\r\\ntkeylen-= cplen;\\r\\ni++;\\r\\np+= cplen;\\r\\n}\\r\\nHMAC_cleanup(&hctx);\\r\\n#ifdef DEBUG_PKCS5V2\\r\\nfprintf(stderr, \"Password:\\n\");\\r\\nh__dump (pass, passlen);\\r\\nfprintf(stderr, \"Salt:\\n\");\\r\\nh__dump (salt, saltlen);\\r\\nfprintf(stderr, \"Iteration count %d\\n\", iter);\\r\\nfprintf(stderr, \"Key:\\n\");\\r\\nh__dump (out, keylen);\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char out[4];\\r\\nunsigned char salt[] = {0x12, 0x34, 0x56, 0x78};\\r\\nPKCS5_PBKDF2_HMAC_SHA1(\"password\", -1, salt, 4, 5, 4, out);\\r\\nfprintf(stderr, \"Out %02X %02X %02X %02X\\n\",\\r\\nout[0], out[1], out[2], out[3]);\\r\\n}\\r\\nint PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER *c, EVP_MD *md,\\r\\nint en_de)\\r\\n{\\r\\nunsigned char *pbuf, *salt, key[EVP_MAX_KEY_LENGTH];\\r\\nint saltlen, keylen, iter, plen;\\r\\nPBE2PARAM *pbe2 = NULL;\\r\\nconst EVP_CIPHER *cipher;\\r\\nPBKDF2PARAM *kdf = NULL;\\r\\npbuf = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif(!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif(OBJ_obj2nid(pbe2->keyfunc->algorithm) != NID_id_pbkdf2) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);\\r\\ngoto err;\\r\\n}\\r\\ncipher = EVP_get_cipherbyname(\\r\\nOBJ_nid2sn(OBJ_obj2nid(pbe2->encryption->algorithm)));\\r\\nif(!cipher) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CipherInit(ctx, cipher, NULL, NULL, en_de);\\r\\nif(EVP_CIPHER_asn1_to_param(ctx, pbe2->encryption->parameter) < 0) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_CIPHER_PARAMETER_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\npbuf = pbe2->keyfunc->parameter->value.sequence->data;\\r\\nplen = pbe2->keyfunc->parameter->value.sequence->length;\\r\\nif(!pbe2->keyfunc->parameter ||\\r\\n(pbe2->keyfunc->parameter->type != V_ASN1_SEQUENCE) ||\\r\\n!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen)) ) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nPBE2PARAM_free(pbe2);\\r\\npbe2 = NULL;\\r\\nif(kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != keylen)){\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_KEYLENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif(kdf->prf && (OBJ_obj2nid(kdf->prf->algorithm) != NID_hmacWithSHA1)) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);\\r\\ngoto err;\\r\\n}\\r\\nif(kdf->salt->type != V_ASN1_OCTET_STRING) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_SALT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nsalt = kdf->salt->value.octet_string->data;\\r\\nsaltlen = kdf->salt->value.octet_string->length;\\r\\niter = ASN1_INTEGER_get(kdf->iter);\\r\\nPKCS5_PBKDF2_HMAC_SHA1(pass, passlen, salt, saltlen, iter, keylen, key);\\r\\nEVP_CipherInit(ctx, NULL, key, NULL, en_de);\\r\\nmemset(key, 0, keylen);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn 1;\\r\\nerr:\\r\\nPBE2PARAM_free(pbe2);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void h__dump (const unsigned char *p, int len)\\r\\n{\\r\\nfor (; len --; p++) fprintf(stderr, \"%02X \", *p);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s23_srvr_c", "target": 1, "func": "static SSL_METHOD *ssl23_get_server_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_server_method());\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_server_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_server_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_server_data,\\r\\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\\r\\nSSLv23_server_data.ssl_accept=ssl23_accept;\\r\\nSSLv23_server_data.get_ssl_method=ssl23_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv23_server_data);\\r\\n}\\r\\nint ssl23_accept(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long Time=time(NULL);\\r\\nvoid (*cb)()=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state;\\r\\nRAND_seed(&Time,sizeof(Time));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_accept++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A:\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl23_get_client_hello(s);\\r\\nif (ret >= 0) cb=NULL;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL23_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\ns->in_handshake--;\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl23_get_client_hello(SSL *s)\\r\\n{\\r\\nchar buf_space[8];\\r\\nchar *buf= &(buf_space[0]);\\r\\nunsigned char *p,*d,*dd;\\r\\nunsigned int i;\\r\\nunsigned int csl,sil,cl;\\r\\nint n=0,j,tls1=0;\\r\\nint type=0,use_sslv2_strong=0;\\r\\nint v[2];\\r\\nv[0]=v[1]=0;\\r\\nif (s->state == SSL23_ST_SR_CLNT_HELLO_A)\\r\\n{\\r\\nif (!ssl3_setup_buffers(s)) goto err;\\r\\nn=ssl23_read_bytes(s,7);\\r\\nif (n != 7) return(n);\\r\\np=s->packet;\\r\\nmemcpy(buf,p,n);\\r\\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\\r\\n{\\r\\nif ((p[3] == 0x00) && (p[4] == 0x02))\\r\\n{\\r\\nv[0]=p[3]; v[1]=p[4];\\r\\nif (!(s->options & SSL_OP_NO_SSLv2))\\r\\ntype=1;\\r\\n}\\r\\nelse if (p[3] == SSL3_VERSION_MAJOR)\\r\\n{\\r\\nv[0]=p[3]; v[1]=p[4];\\r\\nif (p[4] >= TLS1_VERSION_MINOR)\\r\\n{\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ntls1=1;\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\n{\\r\\ntype=1;\\r\\n}\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\ntype=1;\\r\\nif (s->options & SSL_OP_NON_EXPORT_FIRST)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nint ne2,ne3;\\r\\nj=((p[0]&0x7f)<<8)|p[1];\\r\\nif (j > (1024*4))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nn=ssl23_read_bytes(s,j+2);\\r\\nif (n <= 0) return(n);\\r\\np=s->packet;\\r\\nif ((buf=Malloc(n)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(buf,p,n);\\r\\np+=5;\\r\\nn2s(p,csl);\\r\\np+=4;\\r\\nsk=ssl_bytes_to_cipher_list(\\r\\ns,p,csl,NULL);\\r\\nif (sk != NULL)\\r\\n{\\r\\nne2=ne3=0;\\r\\nfor (j=0; j<sk_SSL_CIPHER_num(sk); j++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(sk,j);\\r\\nif (!SSL_C_IS_EXPORT(c))\\r\\n{\\r\\nif ((c->id>>24L) == 2L)\\r\\nne2=1;\\r\\nelse\\r\\nne3=1;\\r\\n}\\r\\n}\\r\\nif (ne2 && !ne3)\\r\\n{\\r\\ntype=1;\\r\\nuse_sslv2_strong=1;\\r\\ngoto next_bit;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n(p[5] == SSL3_MT_CLIENT_HELLO))\\r\\n{\\r\\nv[0]=p[1]; v[1]=p[2];\\r\\nif (p[2] >= TLS1_VERSION_MINOR)\\r\\n{\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ntype=3;\\r\\ntls1=1;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\ntype=3;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\ntype=3;\\r\\n}\\r\\nelse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\\r\\n(strncmp(\"POST \",(char *)p,5) == 0) ||\\r\\n(strncmp(\"HEAD \",(char *)p,5) == 0) ||\\r\\n(strncmp(\"PUT \", (char *)p,4) == 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nelse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nnext_bit:\\r\\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\\r\\n{\\r\\ntype=2;\\r\\np=s->packet;\\r\\nn=((p[0]&0x7f)<<8)|p[1];\\r\\nif (n > (1024*4))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nj=ssl23_read_bytes(s,n+2);\\r\\nif (j <= 0) return(j);\\r\\nssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2);\\r\\np=s->packet;\\r\\np+=5;\\r\\nn2s(p,csl);\\r\\nn2s(p,sil);\\r\\nn2s(p,cl);\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\nif ((csl+sil+cl+11) != s->packet_length)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n*(d++)=SSL3_VERSION_MAJOR;\\r\\nif (tls1)\\r\\n*(d++)=TLS1_VERSION_MINOR;\\r\\nelse\\r\\n*(d++)=SSL3_VERSION_MINOR;\\r\\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\\r\\nmemset(d,0,SSL3_RANDOM_SIZE);\\r\\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\\r\\nd+=SSL3_RANDOM_SIZE;\\r\\n*(d++)=0;\\r\\nj=0;\\r\\ndd=d;\\r\\nd+=2;\\r\\nfor (i=0; i<csl; i+=3)\\r\\n{\\r\\nif (p[i] != 0) continue;\\r\\n*(d++)=p[i+1];\\r\\n*(d++)=p[i+2];\\r\\nj+=2;\\r\\n}\\r\\ns2n(j,dd);\\r\\n*(d++)=1;\\r\\n*(d++)=0;\\r\\ni=(d-(unsigned char *)s->init_buf->data);\\r\\ns->s3->tmp.reuse_message=1;\\r\\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\\r\\ns->s3->tmp.message_size=i;\\r\\n}\\r\\nif (type == 1)\\r\\n{\\r\\nif (s->s2 == NULL)\\r\\n{\\r\\nif (!ssl2_new(s))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nssl2_clear(s);\\r\\nif (s->s3 != NULL) ssl3_free(s);\\r\\nif (!BUF_MEM_grow(s->init_buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\\r\\nif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\\r\\nuse_sslv2_strong)\\r\\ns->s2->ssl2_rollback=0;\\r\\nelse\\r\\ns->s2->ssl2_rollback=1;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s2->rbuf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s2->rbuf_left=n;\\r\\ns->s2->rbuf_offs=0;\\r\\ns->method=SSLv2_server_method();\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\n}\\r\\nif ((type == 2) || (type == 3))\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) goto err;\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\nif (type == 3)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s3->rbuf.left=n;\\r\\ns->s3->rbuf.offset=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->packet_length=0;\\r\\ns->s3->rbuf.left=0;\\r\\ns->s3->rbuf.offset=0;\\r\\n}\\r\\nif (tls1)\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ns->method=TLSv1_server_method();\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ns->method=SSLv3_server_method();\\r\\n}\\r\\ns->client_version=(v[0]<<8)|v[1];\\r\\ns->handshake_func=s->method->ssl_accept;\\r\\n}\\r\\nif ((type < 1) || (type > 3))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (buf != buf_space) Free(buf);\\r\\ns->first_packet=1;\\r\\nreturn(SSL_accept(s));\\r\\nerr:\\r\\nif (buf != buf_space) Free(buf);\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_vfy_c", "target": 1, "func": "static int null_callback(int ok, X509_STORE_CTX *e)\\r\\n{\\r\\nreturn(ok);\\r\\n}\\r\\nint X509_verify_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509 *x,*xtmp,*chain_ss=NULL;\\r\\nX509_NAME *xn;\\r\\nX509_OBJECT obj;\\r\\nint depth,i,ok=0;\\r\\nint num;\\r\\nint (*cb)();\\r\\nSTACK_OF(X509) *sktmp=NULL;\\r\\nif (ctx->cert == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\\r\\nreturn(-1);\\r\\n}\\r\\ncb=ctx->ctx->verify_cb;\\r\\nif (cb == NULL) cb=null_callback;\\r\\nif (ctx->chain == NULL)\\r\\n{\\r\\nif ( ((ctx->chain=sk_X509_new_null()) == NULL) ||\\r\\n(!sk_X509_push(ctx->chain,ctx->cert)))\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&ctx->cert->references,1,CRYPTO_LOCK_X509);\\r\\nctx->last_untrusted=1;\\r\\n}\\r\\nif (ctx->untrusted != NULL\\r\\n&& (sktmp=sk_X509_dup(ctx->untrusted)) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nnum=sk_X509_num(ctx->chain);\\r\\nx=sk_X509_value(ctx->chain,num-1);\\r\\ndepth=ctx->depth;\\r\\nfor (;;)\\r\\n{\\r\\nif (depth < num) break;\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),xn) == 0)\\r\\nbreak;\\r\\nif (ctx->untrusted != NULL)\\r\\n{\\r\\nxtmp=X509_find_by_subject(sktmp,xn);\\r\\nif (xtmp != NULL)\\r\\n{\\r\\nif (!sk_X509_push(ctx->chain,xtmp))\\r\\n{\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&xtmp->references,1,CRYPTO_LOCK_X509);\\r\\nsk_X509_delete_ptr(sktmp,xtmp);\\r\\nctx->last_untrusted++;\\r\\nx=xtmp;\\r\\nnum++;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\ni=sk_X509_num(ctx->chain);\\r\\nx=sk_X509_value(ctx->chain,i-1);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),X509_get_issuer_name(x))\\r\\n== 0)\\r\\n{\\r\\nif (sk_X509_num(ctx->chain) == 1)\\r\\n{\\r\\nctx->error=X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\\r\\nctx->current_cert=x;\\r\\nctx->error_depth=i-1;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nchain_ss=sk_X509_pop(ctx->chain);\\r\\nctx->last_untrusted--;\\r\\nnum--;\\r\\nx=sk_X509_value(ctx->chain,num-1);\\r\\n}\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nif (depth < num) break;\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),xn) == 0)\\r\\nbreak;\\r\\nok=X509_STORE_get_by_subject(ctx,X509_LU_X509,xn,&obj);\\r\\nif (ok != X509_LU_X509)\\r\\n{\\r\\nif (ok == X509_LU_RETRY)\\r\\n{\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nX509err(X509_F_X509_VERIFY_CERT,X509_R_SHOULD_RETRY);\\r\\nreturn(ok);\\r\\n}\\r\\nelse if (ok != X509_LU_FAIL)\\r\\n{\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nreturn(ok);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nx=obj.data.x509;\\r\\nif (!sk_X509_push(ctx->chain,obj.data.x509))\\r\\n{\\r\\nX509_OBJECT_free_contents(&obj);\\r\\nX509err(X509_F_X509_VERIFY_CERT,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nnum++;\\r\\n}\\r\\nxn=X509_get_issuer_name(x);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),xn) != 0)\\r\\n{\\r\\nif ((chain_ss == NULL) || (X509_NAME_cmp(X509_get_subject_name(chain_ss),xn) != 0))\\r\\n{\\r\\nif (ctx->last_untrusted >= num)\\r\\nctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\\r\\nelse\\r\\nctx->error=X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\\r\\nctx->current_cert=x;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsk_X509_push(ctx->chain,chain_ss);\\r\\nnum++;\\r\\nctx->last_untrusted=num;\\r\\nctx->current_cert=chain_ss;\\r\\nctx->error=X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\\r\\nchain_ss=NULL;\\r\\n}\\r\\nctx->error_depth=num-1;\\r\\nok=cb(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nX509_get_pubkey_parameters(NULL,ctx->chain);\\r\\nif (ctx->ctx->verify != NULL)\\r\\nok=ctx->ctx->verify(ctx);\\r\\nelse\\r\\nok=internal_verify(ctx);\\r\\nif (0)\\r\\n{\\r\\nend:\\r\\nX509_get_pubkey_parameters(NULL,ctx->chain);\\r\\n}\\r\\nif (sktmp != NULL) sk_X509_free(sktmp);\\r\\nif (chain_ss != NULL) X509_free(chain_ss);\\r\\nreturn(ok);\\r\\n}\\r\\nstatic int internal_verify(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint i,ok=0,n;\\r\\nX509 *xs,*xi;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint (*cb)();\\r\\ncb=ctx->ctx->verify_cb;\\r\\nif (cb == NULL) cb=null_callback;\\r\\nn=sk_X509_num(ctx->chain);\\r\\nctx->error_depth=n-1;\\r\\nn--;\\r\\nxi=sk_X509_value(ctx->chain,n);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(xi),\\r\\nX509_get_issuer_name(xi)) == 0)\\r\\nxs=xi;\\r\\nelse\\r\\n{\\r\\nif (n <= 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\\r\\nctx->current_cert=xi;\\r\\nok=cb(0,ctx);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nn--;\\r\\nctx->error_depth=n;\\r\\nxs=sk_X509_value(ctx->chain,n);\\r\\n}\\r\\n}\\r\\nwhile (n >= 0)\\r\\n{\\r\\nctx->error_depth=n;\\r\\nif (!xs->valid)\\r\\n{\\r\\nif ((pkey=X509_get_pubkey(xi)) == NULL)\\r\\n{\\r\\nctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\\r\\nctx->current_cert=xi;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (X509_verify(xs,pkey) <= 0)\\r\\n{\\r\\nEVP_PKEY_free(pkey);\\r\\nctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\npkey=NULL;\\r\\ni=X509_cmp_current_time(X509_get_notBefore(xs));\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (i > 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CERT_NOT_YET_VALID;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nxs->valid=1;\\r\\n}\\r\\ni=X509_cmp_current_time(X509_get_notAfter(xs));\\r\\nif (i == 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\nctx->error=X509_V_ERR_CERT_HAS_EXPIRED;\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(0,ctx);\\r\\nif (!ok) goto end;\\r\\n}\\r\\nctx->current_cert=xs;\\r\\nok=(*cb)(1,ctx);\\r\\nif (!ok) goto end;\\r\\nn--;\\r\\nif (n >= 0)\\r\\n{\\r\\nxi=xs;\\r\\nxs=sk_X509_value(ctx->chain,n);\\r\\n}\\r\\n}\\r\\nok=1;\\r\\nend:\\r\\nreturn(ok);\\r\\n}\\r\\nint X509_cmp_current_time(ASN1_UTCTIME *ctm)\\r\\n{\\r\\nchar *str;\\r\\nASN1_UTCTIME atm;\\r\\ntime_t offset;\\r\\nchar buff1[24],buff2[24],*p;\\r\\nint i,j;\\r\\np=buff1;\\r\\ni=ctm->length;\\r\\nstr=(char *)ctm->data;\\r\\nif ((i < 11) || (i > 17)) return(0);\\r\\nmemcpy(p,str,10);\\r\\np+=10;\\r\\nstr+=10;\\r\\nif ((*str == 'Z') || (*str == '-') || (*str == '+'))\\r\\n{ *(p++)='0'; *(p++)='0'; }\\r\\nelse { *(p++)= *(str++); *(p++)= *(str++); }\\r\\n*(p++)='Z';\\r\\n*(p++)='\\0';\\r\\nif (*str == 'Z')\\r\\noffset=0;\\r\\nelse\\r\\n{\\r\\nif ((*str != '+') && (str[5] != '-'))\\r\\nreturn(0);\\r\\noffset=((str[1]-'0')*10+(str[2]-'0'))*60;\\r\\noffset+=(str[3]-'0')*10+(str[4]-'0');\\r\\nif (*str == '-')\\r\\noffset= -offset;\\r\\n}\\r\\natm.type=V_ASN1_UTCTIME;\\r\\natm.length=sizeof(buff2);\\r\\natm.data=(unsigned char *)buff2;\\r\\nX509_gmtime_adj(&atm,-offset);\\r\\ni=(buff1[0]-'0')*10+(buff1[1]-'0');\\r\\nif (i < 50) i+=100;\\r\\nj=(buff2[0]-'0')*10+(buff2[1]-'0');\\r\\nif (j < 50) j+=100;\\r\\nif (i < j) return (-1);\\r\\nif (i > j) return (1);\\r\\ni=strcmp(buff1,buff2);\\r\\nif (i == 0)\\r\\nreturn(-1);\\r\\nelse\\r\\nreturn(i);\\r\\n}\\r\\nASN1_UTCTIME *X509_gmtime_adj(ASN1_UTCTIME *s, long adj)\\r\\n{\\r\\ntime_t t;\\r\\ntime(&t);\\r\\nt+=adj;\\r\\nreturn(ASN1_UTCTIME_set(s,t));\\r\\n}\\r\\nint X509_STORE_add_cert(X509_STORE *ctx, X509 *x)\\r\\n{\\r\\nX509_OBJECT *obj,*r;\\r\\nint ret=1;\\r\\nif (x == NULL) return(0);\\r\\nobj=(X509_OBJECT *)Malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nobj->type=X509_LU_X509;\\r\\nobj->data.x509=x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nr=(X509_OBJECT *)lh_insert(ctx->certs,(char *)obj);\\r\\nif (r != NULL)\\r\\n{\\r\\nlh_delete(ctx->certs,(char *)obj);\\r\\nX509_OBJECT_free_contents(obj);\\r\\nFree(obj);\\r\\nlh_insert(ctx->certs,(char *)r);\\r\\nX509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)\\r\\n{\\r\\nX509_OBJECT *obj,*r;\\r\\nint ret=1;\\r\\nif (x == NULL) return(0);\\r\\nobj=(X509_OBJECT *)Malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nobj->type=X509_LU_CRL;\\r\\nobj->data.crl=x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nr=(X509_OBJECT *)lh_insert(ctx->certs,(char *)obj);\\r\\nif (r != NULL)\\r\\n{\\r\\nlh_delete(ctx->certs,(char *)obj);\\r\\nX509_OBJECT_free_contents(obj);\\r\\nFree(obj);\\r\\nlh_insert(ctx->certs,(char *)r);\\r\\nX509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret=0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_STORE_CTX_get_ex_new_index(long argl, char *argp, int (*new_func)(),\\r\\nint (*dup_func)(), void (*free_func)())\\r\\n{\\r\\nx509_store_ctx_num++;\\r\\nreturn(CRYPTO_get_ex_new_index(x509_store_ctx_num-1,\\r\\n&x509_store_ctx_method,\\r\\nargl,argp,new_func,dup_func,free_func));\\r\\n}\\r\\nint X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\\r\\n{\\r\\nreturn(CRYPTO_set_ex_data(&ctx->ex_data,idx,data));\\r\\n}\\r\\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)\\r\\n{\\r\\nreturn(CRYPTO_get_ex_data(&ctx->ex_data,idx));\\r\\n}\\r\\nint X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->error);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)\\r\\n{\\r\\nctx->error=err;\\r\\n}\\r\\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->error_depth);\\r\\n}\\r\\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn(ctx->current_cert);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\nctx->cert=x;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2ofb64_c", "target": 0, "func": "void RC2_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC2_KEY *schedule, unsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_cinf_c", "target": 0, "func": "int i2d_X509_CINF(X509_CINF *a, unsigned char **pp)\\r\\n{\\r\\nint v1=0,v2=0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len_EXP_opt(a->version,i2d_ASN1_INTEGER,0,v1);\\r\\nM_ASN1_I2D_len(a->serialNumber, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->signature, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->issuer, i2d_X509_NAME);\\r\\nM_ASN1_I2D_len(a->validity, i2d_X509_VAL);\\r\\nM_ASN1_I2D_len(a->subject, i2d_X509_NAME);\\r\\nM_ASN1_I2D_len(a->key, i2d_X509_PUBKEY);\\r\\nM_ASN1_I2D_len_IMP_opt(a->issuerUID, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_len_IMP_opt(a->subjectUID, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_len_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION,3,\\r\\nV_ASN1_SEQUENCE,v2);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put_EXP_opt(a->version,i2d_ASN1_INTEGER,0,v1);\\r\\nM_ASN1_I2D_put(a->serialNumber, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->signature, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->issuer, i2d_X509_NAME);\\r\\nM_ASN1_I2D_put(a->validity, i2d_X509_VAL);\\r\\nM_ASN1_I2D_put(a->subject, i2d_X509_NAME);\\r\\nM_ASN1_I2D_put(a->key, i2d_X509_PUBKEY);\\r\\nM_ASN1_I2D_put_IMP_opt(a->issuerUID, i2d_ASN1_BIT_STRING,1);\\r\\nM_ASN1_I2D_put_IMP_opt(a->subjectUID, i2d_ASN1_BIT_STRING,2);\\r\\nM_ASN1_I2D_put_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION,3,\\r\\nV_ASN1_SEQUENCE,v2);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_CINF *d2i_X509_CINF(X509_CINF **a, unsigned char **pp, long length)\\r\\n{\\r\\nint ver=0;\\r\\nM_ASN1_D2I_vars(a,X509_CINF *,X509_CINF_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nif (M_ASN1_next == (V_ASN1_CONTEXT_SPECIFIC | V_ASN1_CONSTRUCTED | 0))\\r\\n{\\r\\nM_ASN1_D2I_get_EXP_opt(ret->version,d2i_ASN1_INTEGER,0);\\r\\nif (ret->version->data != NULL)\\r\\nver=ret->version->data[0];\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (ret->version != NULL)\\r\\n{\\r\\nASN1_INTEGER_free(ret->version);\\r\\nret->version=NULL;\\r\\n}\\r\\n}\\r\\nM_ASN1_D2I_get(ret->serialNumber,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->signature,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->issuer,d2i_X509_NAME);\\r\\nM_ASN1_D2I_get(ret->validity,d2i_X509_VAL);\\r\\nM_ASN1_D2I_get(ret->subject,d2i_X509_NAME);\\r\\nM_ASN1_D2I_get(ret->key,d2i_X509_PUBKEY);\\r\\nif (ver >= 1)\\r\\n{\\r\\nif (ret->issuerUID != NULL)\\r\\n{\\r\\nASN1_BIT_STRING_free(ret->issuerUID);\\r\\nret->issuerUID=NULL;\\r\\n}\\r\\nif (ret->subjectUID != NULL)\\r\\n{\\r\\nASN1_BIT_STRING_free(ret->subjectUID);\\r\\nret->subjectUID=NULL;\\r\\n}\\r\\nM_ASN1_D2I_get_IMP_opt(ret->issuerUID,d2i_ASN1_BIT_STRING, 1,\\r\\nV_ASN1_BIT_STRING);\\r\\nM_ASN1_D2I_get_IMP_opt(ret->subjectUID,d2i_ASN1_BIT_STRING, 2,\\r\\nV_ASN1_BIT_STRING);\\r\\n}\\r\\n#ifdef VERSION_EXT_CHECK\\r\\nif (ver >= 2)\\r\\n#endif\\r\\n{\\r\\nif (ret->extensions != NULL)\\r\\nwhile (sk_X509_EXTENSION_num(ret->extensions))\\r\\nX509_EXTENSION_free(\\r\\nsk_X509_EXTENSION_pop(ret->extensions));\\r\\nM_ASN1_D2I_get_EXP_set_opt_type(X509_EXTENSION,ret->extensions,\\r\\nd2i_X509_EXTENSION,\\r\\nX509_EXTENSION_free,3,\\r\\nV_ASN1_SEQUENCE);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_CINF_free,ASN1_F_D2I_X509_CINF);\\r\\n}\\r\\nX509_CINF *X509_CINF_new(void)\\r\\n{\\r\\nX509_CINF *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_CINF);\\r\\nret->version=NULL;\\r\\nM_ASN1_New(ret->serialNumber,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->signature,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->issuer,X509_NAME_new);\\r\\nM_ASN1_New(ret->validity,X509_VAL_new);\\r\\nM_ASN1_New(ret->subject,X509_NAME_new);\\r\\nM_ASN1_New(ret->key,X509_PUBKEY_new);\\r\\nret->issuerUID=NULL;\\r\\nret->subjectUID=NULL;\\r\\nret->extensions=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_CINF_NEW);\\r\\n}\\r\\nvoid X509_CINF_free(X509_CINF *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nASN1_INTEGER_free(a->serialNumber);\\r\\nX509_ALGOR_free(a->signature);\\r\\nX509_NAME_free(a->issuer);\\r\\nX509_VAL_free(a->validity);\\r\\nX509_NAME_free(a->subject);\\r\\nX509_PUBKEY_free(a->key);\\r\\nASN1_BIT_STRING_free(a->issuerUID);\\r\\nASN1_BIT_STRING_free(a->subjectUID);\\r\\nsk_X509_EXTENSION_pop_free(a->extensions,X509_EXTENSION_free);\\r\\nFree(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pem_lib_c", "target": 0, "func": "static int def_callback(char *buf, int num, int w, void *userdata)\\r\\n{\\r\\n#ifdef NO_FP_API\\r\\nPEMerr(PEM_F_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(-1);\\r\\n#else\\r\\nint i,j;\\r\\nconst char *prompt;\\r\\nprompt=EVP_get_pw_prompt();\\r\\nif (prompt == NULL)\\r\\nprompt=\"Enter PEM pass phrase:\";\\r\\nfor (;;)\\r\\n{\\r\\ni=EVP_read_pw_string(buf,num,prompt,w);\\r\\nif (i != 0)\\r\\n{\\r\\nPEMerr(PEM_F_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);\\r\\nmemset(buf,0,(unsigned int)num);\\r\\nreturn(-1);\\r\\n}\\r\\nj=strlen(buf);\\r\\nif (j < MIN_LENGTH)\\r\\n{\\r\\nfprintf(stderr,\"phrase is too short, needs to be at least %d chars\\n\",MIN_LENGTH);\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nreturn(j);\\r\\n#endif\\r\\n}\\r\\nvoid PEM_proc_type(char *buf, int type)\\r\\n{\\r\\nconst char *str;\\r\\nif (type == PEM_TYPE_ENCRYPTED)\\r\\nstr=\"ENCRYPTED\";\\r\\nelse if (type == PEM_TYPE_MIC_CLEAR)\\r\\nstr=\"MIC-CLEAR\";\\r\\nelse if (type == PEM_TYPE_MIC_ONLY)\\r\\nstr=\"MIC-ONLY\";\\r\\nelse\\r\\nstr=\"BAD-TYPE\";\\r\\nstrcat(buf,\"Proc-Type: 4,\");\\r\\nstrcat(buf,str);\\r\\nstrcat(buf,\"\\n\");\\r\\n}\\r\\nvoid PEM_dek_info(char *buf, const char *type, int len, char *str)\\r\\n{\\r\\nstatic unsigned char map[17]=\"0123456789ABCDEF\";\\r\\nlong i;\\r\\nint j;\\r\\nstrcat(buf,\"DEK-Info: \");\\r\\nstrcat(buf,type);\\r\\nstrcat(buf,\",\");\\r\\nj=strlen(buf);\\r\\nfor (i=0; i<len; i++)\\r\\n{\\r\\nbuf[j+i*2] =map[(str[i]>>4)&0x0f];\\r\\nbuf[j+i*2+1]=map[(str[i] )&0x0f];\\r\\n}\\r\\nbuf[j+i*2]='\\n';\\r\\nbuf[j+i*2+1]='\\0';\\r\\n}\\r\\nchar *PEM_ASN1_read(char *(*d2i)(), const char *name, FILE *fp, char **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nchar *ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nchar *PEM_ASN1_read_bio(char *(*d2i)(), const char *name, BIO *bp, char **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nEVP_CIPHER_INFO cipher;\\r\\nchar *nm=NULL,*header=NULL;\\r\\nunsigned char *p=NULL,*data=NULL;\\r\\nlong len;\\r\\nchar *ret=NULL;\\r\\nfor (;;)\\r\\n{\\r\\nif (!PEM_read_bio(bp,&nm,&header,&data,&len)) return(NULL);\\r\\nif ( (strcmp(nm,name) == 0) ||\\r\\n((strcmp(nm,PEM_STRING_RSA) == 0) &&\\r\\n(strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||\\r\\n((strcmp(nm,PEM_STRING_DSA) == 0) &&\\r\\n(strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||\\r\\n((strcmp(nm,PEM_STRING_PKCS8) == 0) &&\\r\\n(strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||\\r\\n((strcmp(nm,PEM_STRING_PKCS8INF) == 0) &&\\r\\n(strcmp(name,PEM_STRING_EVP_PKEY) == 0)) ||\\r\\n((strcmp(nm,PEM_STRING_X509_OLD) == 0) &&\\r\\n(strcmp(name,PEM_STRING_X509) == 0)) ||\\r\\n((strcmp(nm,PEM_STRING_X509_REQ_OLD) == 0) &&\\r\\n(strcmp(name,PEM_STRING_X509_REQ) == 0))\\r\\n)\\r\\nbreak;\\r\\nFree(nm);\\r\\nFree(header);\\r\\nFree(data);\\r\\n}\\r\\nif (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;\\r\\nif (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;\\r\\np=data;\\r\\nif (strcmp(name,PEM_STRING_EVP_PKEY) == 0) {\\r\\nif (strcmp(nm,PEM_STRING_RSA) == 0)\\r\\nret=d2i(EVP_PKEY_RSA,x,&p,len);\\r\\nelse if (strcmp(nm,PEM_STRING_DSA) == 0)\\r\\nret=d2i(EVP_PKEY_DSA,x,&p,len);\\r\\nelse if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\np8inf=d2i_PKCS8_PRIV_KEY_INFO(\\r\\n(PKCS8_PRIV_KEY_INFO **) x, &p, len);\\r\\nret = (char *)EVP_PKCS82PKEY(p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nX509_SIG *p8;\\r\\nint klen;\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\np8 = d2i_X509_SIG((X509_SIG **)x, &p, len);\\r\\nif(!p8) goto p8err;\\r\\nif (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);\\r\\nelse klen=def_callback(psbuf,PEM_BUFSIZE,0,u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_ASN1_READ_BIO,\\r\\nPEM_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\np8inf = M_PKCS8_decrypt(p8, psbuf, klen);\\r\\nX509_SIG_free(p8);\\r\\nif(!p8inf) goto p8err;\\r\\nret = (char *)EVP_PKCS82PKEY(p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n}\\r\\n} else ret=d2i(x,&p,len);\\r\\np8err:\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);\\r\\nerr:\\r\\nFree(nm);\\r\\nFree(header);\\r\\nFree(data);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_ASN1_write(int (*i2d)(), const char *name, FILE *fp, char *x,\\r\\nconst EVP_CIPHER *enc, unsigned char *kstr, int klen,\\r\\npem_password_cb *callback, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_ASN1_write_bio(int (*i2d)(), const char *name, BIO *bp, char *x,\\r\\nconst EVP_CIPHER *enc, unsigned char *kstr, int klen,\\r\\npem_password_cb *callback, void *u)\\r\\n{\\r\\nEVP_CIPHER_CTX ctx;\\r\\nint dsize=0,i,j,ret=0;\\r\\nunsigned char *p,*data=NULL;\\r\\nconst char *objstr=NULL;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nif (enc != NULL)\\r\\n{\\r\\nobjstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));\\r\\nif (objstr == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((dsize=i2d(x,NULL)) < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);\\r\\ndsize=0;\\r\\ngoto err;\\r\\n}\\r\\ndata=(unsigned char *)Malloc((unsigned int)dsize+20);\\r\\nif (data == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=data;\\r\\ni=i2d(x,&p);\\r\\nif (enc != NULL)\\r\\n{\\r\\nif (kstr == NULL)\\r\\n{\\r\\nif (callback == NULL)\\r\\nklen=def_callback(buf,PEM_BUFSIZE,1,u);\\r\\nelse\\r\\nklen=(*callback)(buf,PEM_BUFSIZE,1,u);\\r\\nif (klen <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nkstr=(unsigned char *)buf;\\r\\n}\\r\\nRAND_seed(data,i);\\r\\nRAND_bytes(iv,8);\\r\\nEVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL);\\r\\nif (kstr == (unsigned char *)buf) memset(buf,0,PEM_BUFSIZE);\\r\\nbuf[0]='\\0';\\r\\nPEM_proc_type(buf,PEM_TYPE_ENCRYPTED);\\r\\nPEM_dek_info(buf,objstr,8,(char *)iv);\\r\\nEVP_EncryptInit(&ctx,enc,key,iv);\\r\\nEVP_EncryptUpdate(&ctx,data,&j,data,i);\\r\\nEVP_EncryptFinal(&ctx,&(data[j]),&i);\\r\\ni+=j;\\r\\nret=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=1;\\r\\nbuf[0]='\\0';\\r\\n}\\r\\ni=PEM_write_bio(bp,name,buf,data,i);\\r\\nif (i <= 0) ret=0;\\r\\nerr:\\r\\nmemset(key,0,sizeof(key));\\r\\nmemset(iv,0,sizeof(iv));\\r\\nmemset((char *)&ctx,0,sizeof(ctx));\\r\\nmemset(buf,0,PEM_BUFSIZE);\\r\\nmemset(data,0,(unsigned int)dsize);\\r\\nFree(data);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,\\r\\npem_password_cb *callback,void *u)\\r\\n{\\r\\nint i,j,o,klen;\\r\\nlong len;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nchar buf[PEM_BUFSIZE];\\r\\nlen= *plen;\\r\\nif (cipher->cipher == NULL) return(1);\\r\\nif (callback == NULL)\\r\\nklen=def_callback(buf,PEM_BUFSIZE,0,u);\\r\\nelse\\r\\nklen=callback(buf,PEM_BUFSIZE,0,u);\\r\\nif (klen <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_PASSWORD_READ);\\r\\nreturn(0);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nEVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),\\r\\n(unsigned char *)buf,klen,1,key,NULL);\\r\\nj=(int)len;\\r\\nEVP_DecryptInit(&ctx,cipher->cipher,key,&(cipher->iv[0]));\\r\\nEVP_DecryptUpdate(&ctx,data,&i,data,j);\\r\\no=EVP_DecryptFinal(&ctx,&(data[i]),&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nmemset((char *)buf,0,sizeof(buf));\\r\\nmemset((char *)key,0,sizeof(key));\\r\\nj+=i;\\r\\nif (!o)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_DECRYPT);\\r\\nreturn(0);\\r\\n}\\r\\n*plen=j;\\r\\nreturn(1);\\r\\n}\\r\\nint PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)\\r\\n{\\r\\nint o;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nchar *p,c;\\r\\ncipher->cipher=NULL;\\r\\nif ((header == NULL) || (*header == '\\0') || (*header == '\\n'))\\r\\nreturn(1);\\r\\nif (strncmp(header,\"Proc-Type: \",11) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_PROC_TYPE); return(0); }\\r\\nheader+=11;\\r\\nif (*header != '4') return(0); header++;\\r\\nif (*header != ',') return(0); header++;\\r\\nif (strncmp(header,\"ENCRYPTED\",9) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_ENCRYPTED); return(0); }\\r\\nfor (; (*header != '\\n') && (*header != '\\0'); header++)\\r\\n;\\r\\nif (*header == '\\0')\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_SHORT_HEADER); return(0); }\\r\\nheader++;\\r\\nif (strncmp(header,\"DEK-Info: \",10) != 0)\\r\\n{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_DEK_INFO); return(0); }\\r\\nheader+=10;\\r\\np=header;\\r\\nfor (;;)\\r\\n{\\r\\nc= *header;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((c >= 'A') && (c <= 'Z')) || (c == '-') ||\\r\\n((c >= '0') && (c <= '9'))))\\r\\nbreak;\\r\\n#else\\r\\nif (!( isupper(c) || (c == '-') ||\\r\\nisdigit(c)))\\r\\nbreak;\\r\\n#endif\\r\\nheader++;\\r\\n}\\r\\n*header='\\0';\\r\\no=OBJ_sn2nid(p);\\r\\ncipher->cipher=enc=EVP_get_cipherbyname(p);\\r\\n*header=c;\\r\\nheader++;\\r\\nif (enc == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_UNSUPPORTED_ENCRYPTION);\\r\\nreturn(0);\\r\\n}\\r\\nif (!load_iv((unsigned char **)&header,&(cipher->iv[0]),8)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int load_iv(unsigned char **fromp, unsigned char *to, int num)\\r\\n{\\r\\nint v,i;\\r\\nunsigned char *from;\\r\\nfrom= *fromp;\\r\\nfor (i=0; i<num; i++) to[i]=0;\\r\\nnum*=2;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nif ((*from >= '0') && (*from <= '9'))\\r\\nv= *from-'0';\\r\\nelse if ((*from >= 'A') && (*from <= 'F'))\\r\\nv= *from-'A'+10;\\r\\nelse if ((*from >= 'a') && (*from <= 'f'))\\r\\nv= *from-'a'+10;\\r\\nelse\\r\\n{\\r\\nPEMerr(PEM_F_LOAD_IV,PEM_R_BAD_IV_CHARS);\\r\\nreturn(0);\\r\\n}\\r\\nfrom++;\\r\\nto[i/2]|=v<<(long)((!(i&1))*4);\\r\\n}\\r\\n*fromp=from;\\r\\nreturn(1);\\r\\n}\\r\\nint PEM_write(FILE *fp, char *name, char *header, unsigned char *data,\\r\\nlong len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_WRITE,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_write_bio(b, name, header, data,len);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,\\r\\nlong len)\\r\\n{\\r\\nint nlen,n,i,j,outl;\\r\\nunsigned char *buf;\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint reason=ERR_R_BUF_LIB;\\r\\nEVP_EncodeInit(&ctx);\\r\\nnlen=strlen(name);\\r\\nif ( (BIO_write(bp,\"-----BEGIN \",11) != 11) ||\\r\\n(BIO_write(bp,name,nlen) != nlen) ||\\r\\n(BIO_write(bp,\"-----\\n\",6) != 6))\\r\\ngoto err;\\r\\ni=strlen(header);\\r\\nif (i > 0)\\r\\n{\\r\\nif ( (BIO_write(bp,header,i) != i) ||\\r\\n(BIO_write(bp,\"\\n\",1) != 1))\\r\\ngoto err;\\r\\n}\\r\\nbuf=(unsigned char *)Malloc(PEM_BUFSIZE*8);\\r\\nif (buf == NULL)\\r\\n{\\r\\nreason=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\ni=j=0;\\r\\nwhile (len > 0)\\r\\n{\\r\\nn=(int)((len>(PEM_BUFSIZE*5))?(PEM_BUFSIZE*5):len);\\r\\nEVP_EncodeUpdate(&ctx,buf,&outl,&(data[j]),n);\\r\\nif ((outl) && (BIO_write(bp,(char *)buf,outl) != outl))\\r\\ngoto err;\\r\\ni+=outl;\\r\\nlen-=n;\\r\\nj+=n;\\r\\n}\\r\\nEVP_EncodeFinal(&ctx,buf,&outl);\\r\\nif ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;\\r\\nFree(buf);\\r\\nif ( (BIO_write(bp,\"-----END \",9) != 9) ||\\r\\n(BIO_write(bp,name,nlen) != nlen) ||\\r\\n(BIO_write(bp,\"-----\\n\",6) != 6))\\r\\ngoto err;\\r\\nreturn(i+outl);\\r\\nerr:\\r\\nPEMerr(PEM_F_PEM_WRITE_BIO,reason);\\r\\nreturn(0);\\r\\n}\\r\\nint PEM_read(FILE *fp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=PEM_read_bio(b, name, header, data,len);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint end=0,i,k,bl=0,hl=0,nohead=0;\\r\\nchar buf[256];\\r\\nBUF_MEM *nameB;\\r\\nBUF_MEM *headerB;\\r\\nBUF_MEM *dataB,*tmpB;\\r\\nnameB=BUF_MEM_new();\\r\\nheaderB=BUF_MEM_new();\\r\\ndataB=BUF_MEM_new();\\r\\nif ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nbuf[254]='\\0';\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);\\r\\ngoto err;\\r\\n}\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (strncmp(buf,\"-----BEGIN \",11) == 0)\\r\\n{\\r\\ni=strlen(&(buf[11]));\\r\\nif (strncmp(&(buf[11+i-6]),\"-----\\n\",6) != 0)\\r\\ncontinue;\\r\\nif (!BUF_MEM_grow(nameB,i+9))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(nameB->data,&(buf[11]),i-6);\\r\\nnameB->data[i-6]='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nhl=0;\\r\\nif (!BUF_MEM_grow(headerB,256))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\nheaderB->data[0]='\\0';\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (buf[0] == '\\n') break;\\r\\nif (!BUF_MEM_grow(headerB,hl+i+9))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\nif (strncmp(buf,\"-----END \",9) == 0)\\r\\n{\\r\\nnohead=1;\\r\\nbreak;\\r\\n}\\r\\nmemcpy(&(headerB->data[hl]),buf,i);\\r\\nheaderB->data[hl+i]='\\0';\\r\\nhl+=i;\\r\\n}\\r\\nbl=0;\\r\\nif (!BUF_MEM_grow(dataB,1024))\\r\\n{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }\\r\\ndataB->data[0]='\\0';\\r\\nif (!nohead)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nif (i != 65) end=1;\\r\\nif (strncmp(buf,\"-----END \",9) == 0)\\r\\nbreak;\\r\\nif (i > 65) break;\\r\\nif (!BUF_MEM_grow(dataB,i+bl+9))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(&(dataB->data[bl]),buf,i);\\r\\ndataB->data[bl+i]='\\0';\\r\\nbl+=i;\\r\\nif (end)\\r\\n{\\r\\nbuf[0]='\\0';\\r\\ni=BIO_gets(bp,buf,254);\\r\\nif (i <= 0) break;\\r\\nwhile ((i >= 0) && (buf[i] <= ' ')) i--;\\r\\nbuf[++i]='\\n'; buf[++i]='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ntmpB=headerB;\\r\\nheaderB=dataB;\\r\\ndataB=tmpB;\\r\\nbl=hl;\\r\\n}\\r\\ni=strlen(nameB->data);\\r\\nif ( (strncmp(buf,\"-----END \",9) != 0) ||\\r\\n(strncmp(nameB->data,&(buf[9]),i) != 0) ||\\r\\n(strncmp(&(buf[9+i]),\"-----\\n\",6) != 0))\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_DecodeInit(&ctx);\\r\\ni=EVP_DecodeUpdate(&ctx,\\r\\n(unsigned char *)dataB->data,&bl,\\r\\n(unsigned char *)dataB->data,bl);\\r\\nif (i < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\ni=EVP_DecodeFinal(&ctx,(unsigned char *)&(dataB->data[bl]),&k);\\r\\nif (i < 0)\\r\\n{\\r\\nPEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\nbl+=k;\\r\\nif (bl == 0) goto err;\\r\\n*name=nameB->data;\\r\\n*header=headerB->data;\\r\\n*data=(unsigned char *)dataB->data;\\r\\n*len=bl;\\r\\nFree(nameB);\\r\\nFree(headerB);\\r\\nFree(dataB);\\r\\nreturn(1);\\r\\nerr:\\r\\nBUF_MEM_free(nameB);\\r\\nBUF_MEM_free(headerB);\\r\\nBUF_MEM_free(dataB);\\r\\nreturn(0);\\r\\n}\\r\\nint PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nX509_SIG *p8;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nint ret;\\r\\nif(!(p8inf = EVP_PKEY2PKCS8(x))) {\\r\\nPEMerr(PEM_F_PEM_WRITE_BIO_PKCS8PRIVATEKEY,\\r\\nPEM_R_ERROR_CONVERTING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif(enc) {\\r\\nif(!kstr) {\\r\\nif(!cb) klen = def_callback(buf, PEM_BUFSIZE, 1, u);\\r\\nelse klen = cb(buf, PEM_BUFSIZE, 1, u);\\r\\nif(klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_WRITE_BIO_PKCS8PRIVATEKEY,\\r\\nPEM_R_READ_KEY);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn 0;\\r\\n}\\r\\nkstr = buf;\\r\\n}\\r\\np8 = PKCS8_encrypt(-1, enc, kstr, klen, NULL, 0, 0, p8inf);\\r\\nif(kstr == buf) memset(buf, 0, klen);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nret = PEM_write_bio_PKCS8(bp, p8);\\r\\nX509_SIG_free(p8);\\r\\nreturn ret;\\r\\n} else {\\r\\nret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nint PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen, pem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *bp;\\r\\nint ret;\\r\\nif(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nPEMerr(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret = PEM_write_bio_PKCS8PrivateKey(bp, x, enc, kstr, klen, cb, u);\\r\\nBIO_free(bp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_set_key_c", "target": 0, "func": "void des_set_odd_parity(des_cblock *key)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<DES_KEY_SZ; i++)\\r\\n(*key)[i]=odd_parity[(*key)[i]];\\r\\n}\\r\\nstatic int check_parity(const_des_cblock *key)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<DES_KEY_SZ; i++)\\r\\n{\\r\\nif ((*key)[i] != odd_parity[(*key)[i]])\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint des_is_weak_key(const_des_cblock *key)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<NUM_WEAK_KEY; i++)\\r\\nif (memcmp(weak_keys[i],key,sizeof(des_cblock)) == 0) return(1);\\r\\nreturn(0);\\r\\n}\\r\\nint des_set_key(const_des_cblock *key, des_key_schedule schedule)\\r\\n{\\r\\nstatic int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};\\r\\nregister DES_LONG c,d,t,s,t2;\\r\\nregister const unsigned char *in;\\r\\nregister DES_LONG *k;\\r\\nregister int i;\\r\\nif (des_check_key)\\r\\n{\\r\\nif (!check_parity(key))\\r\\nreturn(-1);\\r\\nif (des_is_weak_key(key))\\r\\nreturn(-2);\\r\\n}\\r\\nk = &schedule->ks.deslong[0];\\r\\nin = &(*key)[0];\\r\\nc2l(in,c);\\r\\nc2l(in,d);\\r\\nPERM_OP (d,c,t,4,0x0f0f0f0fL);\\r\\nHPERM_OP(c,t,-2,0xcccc0000L);\\r\\nHPERM_OP(d,t,-2,0xcccc0000L);\\r\\nPERM_OP (d,c,t,1,0x55555555L);\\r\\nPERM_OP (c,d,t,8,0x00ff00ffL);\\r\\nPERM_OP (d,c,t,1,0x55555555L);\\r\\nd= (((d&0x000000ffL)<<16L)| (d&0x0000ff00L) |\\r\\n((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));\\r\\nc&=0x0fffffffL;\\r\\nfor (i=0; i<ITERATIONS; i++)\\r\\n{\\r\\nif (shifts2[i])\\r\\n{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }\\r\\nelse\\r\\n{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }\\r\\nc&=0x0fffffffL;\\r\\nd&=0x0fffffffL;\\r\\ns= des_skb[0][ (c )&0x3f ]|\\r\\ndes_skb[1][((c>> 6)&0x03)|((c>> 7L)&0x3c)]|\\r\\ndes_skb[2][((c>>13)&0x0f)|((c>>14L)&0x30)]|\\r\\ndes_skb[3][((c>>20)&0x01)|((c>>21L)&0x06) |\\r\\n((c>>22L)&0x38)];\\r\\nt= des_skb[4][ (d )&0x3f ]|\\r\\ndes_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|\\r\\ndes_skb[6][ (d>>15L)&0x3f ]|\\r\\ndes_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];\\r\\nt2=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;\\r\\n*(k++)=ROTATE(t2,30)&0xffffffffL;\\r\\nt2=((s>>16L)|(t&0xffff0000L));\\r\\n*(k++)=ROTATE(t2,26)&0xffffffffL;\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint des_key_sched(const_des_cblock *key, des_key_schedule schedule)\\r\\n{\\r\\nreturn(des_set_key(key,schedule));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_bf_c", "target": 0, "func": "EVP_CIPHER *EVP_bf_cfb(void)\\r\\n{\\r\\nreturn(&bfish_cfb_cipher);\\r\\n}\\r\\nstatic void bf_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nBF_set_key(&(ctx->c.bf_ks),EVP_BLOWFISH_KEY_SIZE,key);\\r\\n}\\r\\nstatic void bf_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nBF_cfb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.bf_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_err_c", "target": 0, "func": "void ERR_load_BIO_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_BIO,BIO_str_functs);\\r\\nERR_load_strings(ERR_LIB_BIO,BIO_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_comp_err_c", "target": 0, "func": "void ERR_load_COMP_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_COMP,COMP_str_functs);\\r\\nERR_load_strings(ERR_LIB_COMP,COMP_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_req_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nDSA *dsa_params=NULL;\\r\\n#endif\\r\\nint ex=1,x509=0,days=30;\\r\\nX509 *x509ss=NULL;\\r\\nX509_REQ *req=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i,badops=0,newreq=0,newkey= -1,pkey_type=0;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,verify=0,noout=0,text=0,keyform=FORMAT_PEM;\\r\\nint nodes=0,kludge=0;\\r\\nchar *infile,*outfile,*prog,*keyfile=NULL,*template=NULL,*keyout=NULL;\\r\\nchar *extensions = NULL;\\r\\nEVP_CIPHER *cipher=NULL;\\r\\nint modulus=0;\\r\\nchar *p;\\r\\nconst EVP_MD *md_alg=NULL,*digest=EVP_md5();\\r\\n#ifndef MONOLITH\\r\\nMS_STATIC char config_name[256];\\r\\n#endif\\r\\n#ifndef NO_DES\\r\\ncipher=EVP_des_ede3_cbc();\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-new\") == 0)\\r\\n{\\r\\npkey_type=TYPE_RSA;\\r\\nnewreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-config\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ntemplate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyform=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyout\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyout= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-newkey\") == 0)\\r\\n{\\r\\nint is_numeric;\\r\\nif (--argc < 1) goto bad;\\r\\np= *(++argv);\\r\\nis_numeric = p[0] >= '0' && p[0] <= '9';\\r\\nif (strncmp(\"rsa:\",p,4) == 0 || is_numeric)\\r\\n{\\r\\npkey_type=TYPE_RSA;\\r\\nif(!is_numeric)\\r\\np+=4;\\r\\nnewkey= atoi(p);\\r\\n}\\r\\nelse\\r\\n#ifndef NO_DSA\\r\\nif (strncmp(\"dsa:\",p,4) == 0)\\r\\n{\\r\\nX509 *xtmp=NULL;\\r\\nEVP_PKEY *dtmp;\\r\\npkey_type=TYPE_DSA;\\r\\np+=4;\\r\\nif ((in=BIO_new_file(p,\"r\")) == NULL)\\r\\n{\\r\\nperror(p);\\r\\ngoto end;\\r\\n}\\r\\nif ((dsa_params=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\n(void)BIO_reset(in);\\r\\nif ((xtmp=PEM_read_bio_X509(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameters from file\\n\");\\r\\ngoto end;\\r\\n}\\r\\ndtmp=X509_get_pubkey(xtmp);\\r\\nif (dtmp->type == EVP_PKEY_DSA)\\r\\ndsa_params=DSAparams_dup(dtmp->pkey.dsa);\\r\\nEVP_PKEY_free(dtmp);\\r\\nX509_free(xtmp);\\r\\nif (dsa_params == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Certificate does not contain DSA parameters\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_free(in);\\r\\nnewkey=BN_num_bits(dsa_params->p);\\r\\nin=NULL;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (strncmp(\"dh:\",p,4) == 0)\\r\\n{\\r\\npkey_type=TYPE_DH;\\r\\np+=3;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\npkey_type=TYPE_RSA;\\r\\nnewreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\nverify=1;\\r\\nelse if (strcmp(*argv,\"-nodes\") == 0)\\r\\nnodes=1;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-x509\") == 0)\\r\\nx509=1;\\r\\nelse if (strcmp(*argv,\"-asn1-kludge\") == 0)\\r\\nkludge=1;\\r\\nelse if (strcmp(*argv,\"-no-asn1-kludge\") == 0)\\r\\nkludge=0;\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays= atoi(*(++argv));\\r\\nif (days == 0) days=30;\\r\\n}\\r\\nelse if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\n{\\r\\ndigest=md_alg;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER TXT PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -text text form of request\\n\");\\r\\nBIO_printf(bio_err,\" -noout do not output REQ\\n\");\\r\\nBIO_printf(bio_err,\" -verify verify signature on REQ\\n\");\\r\\nBIO_printf(bio_err,\" -modulus RSA modulus\\n\");\\r\\nBIO_printf(bio_err,\" -nodes don't encrypt the output key\\n\");\\r\\nBIO_printf(bio_err,\" -key file use the private key contained in file\\n\");\\r\\nBIO_printf(bio_err,\" -keyform arg key file format\\n\");\\r\\nBIO_printf(bio_err,\" -keyout arg file to send the key to\\n\");\\r\\nBIO_printf(bio_err,\" -newkey rsa:bits generate a new RSA key of 'bits' in size\\n\");\\r\\nBIO_printf(bio_err,\" -newkey dsa:file generate a new DSA key, parameters taken from CA in 'file'\\n\");\\r\\nBIO_printf(bio_err,\" -[digest] Digest to sign with (md5, sha1, md2, mdc2)\\n\");\\r\\nBIO_printf(bio_err,\" -config file request template file.\\n\");\\r\\nBIO_printf(bio_err,\" -new new request.\\n\");\\r\\nBIO_printf(bio_err,\" -x509 output a x509 structure instead of a cert. req.\\n\");\\r\\nBIO_printf(bio_err,\" -days number of days a x509 generated by -x509 is valid for.\\n\");\\r\\nBIO_printf(bio_err,\" -asn1-kludge Output the 'request' in a format that is wrong but some CA's\\n\");\\r\\nBIO_printf(bio_err,\" have been reported as requiring\\n\");\\r\\nBIO_printf(bio_err,\" [ It is now always turned on but can be turned off with -no-asn1-kludge ]\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nX509V3_add_standard_extensions();\\r\\n#ifndef MONOLITH\\r\\np=getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np=getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\n{\\r\\nstrcpy(config_name,X509_get_default_cert_area());\\r\\n#ifndef VMS\\r\\nstrcat(config_name,\"/\");\\r\\n#endif\\r\\nstrcat(config_name,OPENSSL_CONF);\\r\\np=config_name;\\r\\n}\\r\\ndefault_config_file=p;\\r\\nconfig=CONF_load(config,p,NULL);\\r\\n#endif\\r\\nif (template != NULL)\\r\\n{\\r\\nlong errline;\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",template);\\r\\nreq_conf=CONF_load(NULL,template,&errline);\\r\\nif (req_conf == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error on line %ld of %s\\n\",errline,template);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nreq_conf=config;\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",\\r\\ndefault_config_file);\\r\\nif (req_conf == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Unable to load config info\\n\");\\r\\n}\\r\\n}\\r\\nif (req_conf != NULL)\\r\\n{\\r\\np=CONF_get_string(req_conf,NULL,\"oid_file\");\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO *oid_bio;\\r\\noid_bio=BIO_new_file(p,\"r\");\\r\\nif (oid_bio == NULL)\\r\\n{\\r\\n}\\r\\nelse\\r\\n{\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\n}\\r\\nif(!add_oid_section(req_conf)) goto end;\\r\\nif ((md_alg == NULL) &&\\r\\n((p=CONF_get_string(req_conf,SECTION,\"default_md\")) != NULL))\\r\\n{\\r\\nif ((md_alg=EVP_get_digestbyname(p)) != NULL)\\r\\ndigest=md_alg;\\r\\n}\\r\\nextensions = CONF_get_string(req_conf, SECTION, V3_EXTENSIONS);\\r\\nif(extensions) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_conf_lhash(&ctx, req_conf);\\r\\nif(!X509V3_EXT_add_conf(req_conf, &ctx, extensions, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\", extensions);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\ngoto end;\\r\\nif (keyfile != NULL)\\r\\n{\\r\\nif (BIO_read_filename(in,keyfile) <= 0)\\r\\n{\\r\\nperror(keyfile);\\r\\ngoto end;\\r\\n}\\r\\nif (keyform == FORMAT_PEM)\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (newreq && (pkey == NULL))\\r\\n{\\r\\nchar *randfile;\\r\\nchar buffer[200];\\r\\nif ((randfile=CONF_get_string(req_conf,SECTION,\"RANDFILE\")) == NULL)\\r\\nrandfile=RAND_file_name(buffer,200);\\r\\n#ifdef WINDOWS\\r\\nBIO_printf(bio_err,\"Loading 'screen' into random state -\");\\r\\nBIO_flush(bio_err);\\r\\nRAND_screen();\\r\\nBIO_printf(bio_err,\" done\\n\");\\r\\n#endif\\r\\nif ((randfile == NULL) || !RAND_load_file(randfile,1024L*1024L))\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load 'random state'\\n\");\\r\\nBIO_printf(bio_err,\"What this means is that the random number generator has not been seeded\\n\");\\r\\nBIO_printf(bio_err,\"with much random data.\\n\");\\r\\nBIO_printf(bio_err,\"Consider setting the RANDFILE environment variable to point at a file that\\n\");\\r\\nBIO_printf(bio_err,\"'random' data can be kept in.\\n\");\\r\\n}\\r\\nif (newkey <= 0)\\r\\n{\\r\\nnewkey=(int)CONF_get_number(req_conf,SECTION,BITS);\\r\\nif (newkey <= 0)\\r\\nnewkey=DEFAULT_KEY_LENGTH;\\r\\n}\\r\\nif (newkey < MIN_KEY_LENGTH)\\r\\n{\\r\\nBIO_printf(bio_err,\"private key length is too short,\\n\");\\r\\nBIO_printf(bio_err,\"it needs to be at least %d bits, not %d\\n\",MIN_KEY_LENGTH,newkey);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating a %d bit %s private key\\n\",\\r\\nnewkey,(pkey_type == TYPE_RSA)?\"RSA\":\"DSA\");\\r\\nif ((pkey=EVP_PKEY_new()) == NULL) goto end;\\r\\n#ifndef NO_RSA\\r\\nif (pkey_type == TYPE_RSA)\\r\\n{\\r\\nif (!EVP_PKEY_assign_RSA(pkey,\\r\\nRSA_generate_key(newkey,0x10001,\\r\\nreq_cb,bio_err)))\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey_type == TYPE_DSA)\\r\\n{\\r\\nif (!DSA_generate_key(dsa_params)) goto end;\\r\\nif (!EVP_PKEY_assign_DSA(pkey,dsa_params)) goto end;\\r\\ndsa_params=NULL;\\r\\n}\\r\\n#endif\\r\\nif ((randfile == NULL) || (RAND_write_file(randfile) == 0))\\r\\nBIO_printf(bio_err,\"unable to write 'random state'\\n\");\\r\\nif (pkey == NULL) goto end;\\r\\nif (keyout == NULL)\\r\\nkeyout=CONF_get_string(req_conf,SECTION,KEYFILE);\\r\\nif (keyout == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"writing new private key to stdout\\n\");\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"writing new private key to '%s'\\n\",keyout);\\r\\nif (BIO_write_filename(out,keyout) <= 0)\\r\\n{\\r\\nperror(keyout);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np=CONF_get_string(req_conf,SECTION,\"encrypt_rsa_key\");\\r\\nif (p == NULL)\\r\\np=CONF_get_string(req_conf,SECTION,\"encrypt_key\");\\r\\nif ((p != NULL) && (strcmp(p,\"no\") == 0))\\r\\ncipher=NULL;\\r\\nif (nodes) cipher=NULL;\\r\\ni=0;\\r\\nloop:\\r\\nif (!PEM_write_bio_PrivateKey(out,pkey,cipher,\\r\\nNULL,0,NULL,NULL))\\r\\n{\\r\\nif ((ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3))\\r\\n{\\r\\nERR_clear_error();\\r\\ni++;\\r\\ngoto loop;\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"-----\\n\");\\r\\n}\\r\\nif (!newreq)\\r\\n{\\r\\nkludge= -1;\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\nreq=d2i_X509_REQ_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\nreq=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (newreq || x509)\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"you need to specify a private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req == NULL)\\r\\n{\\r\\nreq=X509_REQ_new();\\r\\nif (req == NULL)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\ni=make_REQ(req,pkey,!x509);\\r\\nif (kludge >= 0)\\r\\nreq->req_info->req_kludge=kludge;\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"problems making Certificate Request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (x509)\\r\\n{\\r\\nEVP_PKEY *tmppkey;\\r\\nX509V3_CTX ext_ctx;\\r\\nif ((x509ss=X509_new()) == NULL) goto end;\\r\\nif(!X509_set_version(x509ss, 2)) goto end;\\r\\nASN1_INTEGER_set(X509_get_serialNumber(x509ss),0L);\\r\\nX509_set_issuer_name(x509ss,\\r\\nX509_REQ_get_subject_name(req));\\r\\nX509_gmtime_adj(X509_get_notBefore(x509ss),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x509ss),\\r\\n(long)60*60*24*days);\\r\\nX509_set_subject_name(x509ss,\\r\\nX509_REQ_get_subject_name(req));\\r\\ntmppkey = X509_REQ_get_pubkey(req);\\r\\nX509_set_pubkey(x509ss,tmppkey);\\r\\nEVP_PKEY_free(tmppkey);\\r\\nX509V3_set_ctx(&ext_ctx, x509ss, x509ss, NULL, NULL, 0);\\r\\nX509V3_set_conf_lhash(&ext_ctx, req_conf);\\r\\nif(extensions && !X509V3_EXT_add_conf(req_conf,\\r\\n&ext_ctx, extensions, x509ss))\\r\\n{\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\ngoto end;\\r\\n}\\r\\nif (!(i=X509_sign(x509ss,pkey,digest)))\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(i=X509_REQ_sign(req,pkey,digest)))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (verify && !x509)\\r\\n{\\r\\nint tmp=0;\\r\\nif (pkey == NULL)\\r\\n{\\r\\npkey=X509_REQ_get_pubkey(req);\\r\\ntmp=1;\\r\\nif (pkey == NULL) goto end;\\r\\n}\\r\\ni=X509_REQ_verify(req,pkey);\\r\\nif (tmp) {\\r\\nEVP_PKEY_free(pkey);\\r\\npkey=NULL;\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\ngoto end;\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify failure\\n\");\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio_err,\"verify OK\\n\");\\r\\n}\\r\\nif (noout && !text && !modulus)\\r\\n{\\r\\nex=0;\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif ((keyout != NULL) && (strcmp(outfile,keyout) == 0))\\r\\ni=(int)BIO_append_filename(out,outfile);\\r\\nelse\\r\\ni=(int)BIO_write_filename(out,outfile);\\r\\nif (!i)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nif (x509)\\r\\nX509_print(out,x509ss);\\r\\nelse\\r\\nX509_REQ_print(out,req);\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nEVP_PKEY *pubkey;\\r\\nif (x509)\\r\\npubkey=X509_get_pubkey(x509ss);\\r\\nelse\\r\\npubkey=X509_REQ_get_pubkey(req);\\r\\nif (pubkey == NULL)\\r\\n{\\r\\nfprintf(stdout,\"Modulus=unavailable\\n\");\\r\\ngoto end;\\r\\n}\\r\\nfprintf(stdout,\"Modulus=\");\\r\\n#ifndef NO_RSA\\r\\nif (pubkey->type == EVP_PKEY_RSA)\\r\\nBN_print(out,pubkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\nfprintf(stdout,\"Wrong Algorithm type\");\\r\\nfprintf(stdout,\"\\n\");\\r\\n}\\r\\nif (!noout && !x509)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_REQ_bio(out,req);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509_REQ(out,req);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!noout && x509 && (x509ss != NULL))\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_bio(out,x509ss);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509(out,x509ss);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write X509 certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nex=0;\\r\\nend:\\r\\nif (ex)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif ((req_conf != NULL) && (req_conf != config)) CONF_free(req_conf);\\r\\nBIO_free(in);\\r\\nBIO_free(out);\\r\\nEVP_PKEY_free(pkey);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x509ss);\\r\\nX509V3_EXT_cleanup();\\r\\nOBJ_cleanup();\\r\\n#ifndef NO_DSA\\r\\nif (dsa_params != NULL) DSA_free(dsa_params);\\r\\n#endif\\r\\nEXIT(ex);\\r\\n}\\r\\nstatic int make_REQ(X509_REQ *req, EVP_PKEY *pkey, int attribs)\\r\\n{\\r\\nint ret=0,i;\\r\\nchar *p,*q;\\r\\nX509_REQ_INFO *ri;\\r\\nchar buf[100];\\r\\nint nid,min,max;\\r\\nchar *type,*def,*tmp,*value,*tmp_attr;\\r\\nSTACK_OF(CONF_VALUE) *sk, *attr=NULL;\\r\\nCONF_VALUE *v;\\r\\ntmp=CONF_get_string(req_conf,SECTION,DISTINGUISHED_NAME);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to find '%s' in config\\n\",\\r\\nDISTINGUISHED_NAME);\\r\\ngoto err;\\r\\n}\\r\\nsk=CONF_get_section(req_conf,tmp);\\r\\nif (sk == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get '%s' section\\n\",tmp);\\r\\ngoto err;\\r\\n}\\r\\ntmp_attr=CONF_get_string(req_conf,SECTION,ATTRIBUTES);\\r\\nif (tmp_attr == NULL)\\r\\nattr=NULL;\\r\\nelse\\r\\n{\\r\\nattr=CONF_get_section(req_conf,tmp_attr);\\r\\nif (attr == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get '%s' section\\n\",tmp_attr);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nri=req->req_info;\\r\\nBIO_printf(bio_err,\"You are about to be asked to enter information that will be incorporated\\n\");\\r\\nBIO_printf(bio_err,\"into your certificate request.\\n\");\\r\\nBIO_printf(bio_err,\"What you are about to enter is what is called a Distinguished Name or a DN.\\n\");\\r\\nBIO_printf(bio_err,\"There are quite a few fields but you can leave some blank\\n\");\\r\\nBIO_printf(bio_err,\"For some fields there will be a default value,\\n\");\\r\\nBIO_printf(bio_err,\"If you enter '.', the field will be left blank.\\n\");\\r\\nBIO_printf(bio_err,\"-----\\n\");\\r\\nif (!ASN1_INTEGER_set(ri->version,0L)) goto err;\\r\\nif (sk_CONF_VALUE_num(sk))\\r\\n{\\r\\ni= -1;\\r\\nstart: for (;;)\\r\\n{\\r\\ni++;\\r\\nif (sk_CONF_VALUE_num(sk) <= i) break;\\r\\nv=sk_CONF_VALUE_value(sk,i);\\r\\np=q=NULL;\\r\\ntype=v->name;\\r\\nif(!check_end(type,\"_min\") || !check_end(type,\"_max\") ||\\r\\n!check_end(type,\"_default\") ||\\r\\n!check_end(type,\"_value\")) continue;\\r\\nfor(p = v->name; *p ; p++)\\r\\nif ((*p == ':') || (*p == ',') ||\\r\\n(*p == '.')) {\\r\\np++;\\r\\nif(*p) type = p;\\r\\nbreak;\\r\\n}\\r\\nif ((nid=OBJ_txt2nid(type)) == NID_undef) goto start;\\r\\nsprintf(buf,\"%s_default\",v->name);\\r\\nif ((def=CONF_get_string(req_conf,tmp,buf)) == NULL)\\r\\ndef=\"\";\\r\\nsprintf(buf,\"%s_value\",v->name);\\r\\nif ((value=CONF_get_string(req_conf,tmp,buf)) == NULL)\\r\\nvalue=NULL;\\r\\nsprintf(buf,\"%s_min\",v->name);\\r\\nmin=(int)CONF_get_number(req_conf,tmp,buf);\\r\\nsprintf(buf,\"%s_max\",v->name);\\r\\nmax=(int)CONF_get_number(req_conf,tmp,buf);\\r\\nif (!add_DN_object(ri->subject,v->value,def,value,nid,\\r\\nmin,max))\\r\\ngoto err;\\r\\n}\\r\\nif (sk_X509_NAME_ENTRY_num(ri->subject->entries) == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"error, no objects specified in config file\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (attribs)\\r\\n{\\r\\nif ((attr != NULL) && (sk_CONF_VALUE_num(attr) > 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"\\nPlease enter the following 'extra' attributes\\n\");\\r\\nBIO_printf(bio_err,\"to be sent with your certificate request\\n\");\\r\\n}\\r\\ni= -1;\\r\\nstart2: for (;;)\\r\\n{\\r\\ni++;\\r\\nif ((attr == NULL) ||\\r\\n(sk_CONF_VALUE_num(attr) <= i))\\r\\nbreak;\\r\\nv=sk_CONF_VALUE_value(attr,i);\\r\\ntype=v->name;\\r\\nif ((nid=OBJ_txt2nid(type)) == NID_undef)\\r\\ngoto start2;\\r\\nsprintf(buf,\"%s_default\",type);\\r\\nif ((def=CONF_get_string(req_conf,tmp_attr,buf))\\r\\n== NULL)\\r\\ndef=\"\";\\r\\nsprintf(buf,\"%s_value\",type);\\r\\nif ((value=CONF_get_string(req_conf,tmp_attr,buf))\\r\\n== NULL)\\r\\nvalue=NULL;\\r\\nsprintf(buf,\"%s_min\",type);\\r\\nmin=(int)CONF_get_number(req_conf,tmp_attr,buf);\\r\\nsprintf(buf,\"%s_max\",type);\\r\\nmax=(int)CONF_get_number(req_conf,tmp_attr,buf);\\r\\nif (!add_attribute_object(ri->attributes,\\r\\nv->value,def,value,nid,min,max))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"No template, please set one up.\\n\");\\r\\ngoto err;\\r\\n}\\r\\nX509_REQ_set_pubkey(req,pkey);\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int add_DN_object(X509_NAME *n, char *text, char *def, char *value,\\r\\nint nid, int min, int max)\\r\\n{\\r\\nint i,j,ret=0;\\r\\nX509_NAME_ENTRY *ne=NULL;\\r\\nMS_STATIC char buf[1024];\\r\\nBIO_printf(bio_err,\"%s [%s]:\",text,def);\\r\\n(void)BIO_flush(bio_err);\\r\\nif (value != NULL)\\r\\n{\\r\\nstrcpy(buf,value);\\r\\nstrcat(buf,\"\\n\");\\r\\nBIO_printf(bio_err,\"%s\\n\",value);\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,1024,stdin);\\r\\n}\\r\\nif (buf[0] == '\\0') return(0);\\r\\nelse if (buf[0] == '\\n')\\r\\n{\\r\\nif ((def == NULL) || (def[0] == '\\0'))\\r\\nreturn(1);\\r\\nstrcpy(buf,def);\\r\\nstrcat(buf,\"\\n\");\\r\\n}\\r\\nelse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\\r\\ni=strlen(buf);\\r\\nif (buf[i-1] != '\\n')\\r\\n{\\r\\nBIO_printf(bio_err,\"weird input :-(\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nbuf[--i]='\\0';\\r\\nj=ASN1_PRINTABLE_type((unsigned char *)buf,-1);\\r\\nif (req_fix_data(nid,&j,i,min,max) == 0)\\r\\ngoto err;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nif ((ne=X509_NAME_ENTRY_create_by_NID(NULL,nid,j,(unsigned char *)buf,\\r\\nstrlen(buf)))\\r\\n== NULL) goto err;\\r\\nif (!X509_NAME_add_entry(n,ne,X509_NAME_entry_count(n),0))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (ne != NULL) X509_NAME_ENTRY_free(ne);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void MS_CALLBACK req_cb(int p, int n, void *arg)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write((BIO *)arg,&c,1);\\r\\n(void)BIO_flush((BIO *)arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\n}\\r\\nstatic int req_fix_data(int nid, int *type, int len, int min, int max)\\r\\n{\\r\\nif (nid == NID_pkcs9_emailAddress)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nif ((nid == NID_commonName) && (*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_challengePassword) &&\\r\\n(*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_unstructuredName) &&\\r\\n(*type == V_ASN1_T61STRING))\\r\\n{\\r\\nBIO_printf(bio_err,\"invalid characters in string, please re-enter the string\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nif (nid == NID_pkcs9_unstructuredName)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nif (len < min)\\r\\n{\\r\\nBIO_printf(bio_err,\"string is too short, it needs to be at least %d bytes long\\n\",min);\\r\\nreturn(0);\\r\\n}\\r\\nif ((max != 0) && (len > max))\\r\\n{\\r\\nBIO_printf(bio_err,\"string is too long, it needs to be less than %d bytes long\\n\",max);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int check_end(char *str, char *end)\\r\\n{\\r\\nint elen, slen;\\r\\nchar *tmp;\\r\\nelen = strlen(end);\\r\\nslen = strlen(str);\\r\\nif(elen > slen) return 1;\\r\\ntmp = str + slen - elen;\\r\\nreturn strcmp(tmp, end);\\r\\n}\\r\\nstatic int add_oid_section(LHASH *conf)\\r\\n{\\r\\nchar *p;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *cnf;\\r\\nint i;\\r\\nif(!(p=CONF_get_string(conf,NULL,\"oid_section\"))) return 1;\\r\\nif(!(sktmp = CONF_get_section(conf, p))) {\\r\\nBIO_printf(bio_err, \"problem loading oid section %s\\n\", p);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\ncnf = sk_CONF_VALUE_value(sktmp, i);\\r\\nif(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {\\r\\nBIO_printf(bio_err, \"problem creating object %s=%s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_x509_c", "target": 1, "func": "ASN1_METHOD *X509_asn1_meth(void)\\r\\n{\\r\\nreturn(&meth);\\r\\n}\\r\\nint i2d_X509(X509 *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->cert_info, i2d_X509_CINF);\\r\\nM_ASN1_I2D_len(a->sig_alg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->cert_info, i2d_X509_CINF);\\r\\nM_ASN1_I2D_put(a->sig_alg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->signature, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509 *d2i_X509(X509 **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509 *,X509_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->cert_info,d2i_X509_CINF);\\r\\nM_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->signature,d2i_ASN1_BIT_STRING);\\r\\nif (ret->name != NULL) Free(ret->name);\\r\\nret->name=X509_NAME_oneline(ret->cert_info->subject,NULL,0);\\r\\nM_ASN1_D2I_Finish(a,X509_free,ASN1_F_D2I_X509);\\r\\n}\\r\\nX509 *X509_new(void)\\r\\n{\\r\\nX509 *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509);\\r\\nret->references=1;\\r\\nret->valid=0;\\r\\nret->name=NULL;\\r\\nM_ASN1_New(ret->cert_info,X509_CINF_new);\\r\\nM_ASN1_New(ret->sig_alg,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->signature,ASN1_BIT_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_NEW);\\r\\n}\\r\\nvoid X509_free(X509 *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509\",a);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nX509_CINF_free(a->cert_info);\\r\\nX509_ALGOR_free(a->sig_alg);\\r\\nASN1_BIT_STRING_free(a->signature);\\r\\nif (a->name != NULL) Free(a->name);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_s_pr_c", "target": 0, "func": "int i2d_DSAPrivateKey(DSA *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[6];\\r\\nunsigned char data[1];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot,t,len,max=0;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nnum[1]=a->p;\\r\\nnum[2]=a->q;\\r\\nnum[3]=a->g;\\r\\nnum[4]=a->pub_key;\\r\\nnum[5]=a->priv_key;\\r\\nbs.length=1;\\r\\nbs.data=data;\\r\\nbs.type=V_ASN1_INTEGER;\\r\\ndata[0]=a->version&0x7f;\\r\\ntot=i2d_ASN1_INTEGER(&(bs),NULL);\\r\\nfor (i=1; i<6; i++)\\r\\n{\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(t);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_DSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (i=1; i<6; i++)\\r\\n{\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\n*pp=p;\\r\\nreturn(t);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md2_one_c", "target": 0, "func": "unsigned char *MD2(unsigned char *d, unsigned long n, unsigned char *md)\\r\\n{\\r\\nMD2_CTX c;\\r\\nstatic unsigned char m[MD2_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nMD2_Init(&c);\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD2_Update(&c,d,n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0)\\r\\n{\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD2_Update(&c,temp,chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD2_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md5_dgst_c", "target": 0, "func": "void MD5_Init(MD5_CTX *c)\\r\\n{\\r\\nc->A=INIT_DATA_A;\\r\\nc->B=INIT_DATA_B;\\r\\nc->C=INIT_DATA_C;\\r\\nc->D=INIT_DATA_D;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\n}\\r\\nvoid md5_block_host_order (MD5_CTX *c, const void *data, int num)\\r\\n{\\r\\nconst MD5_LONG *X=data;\\r\\nregister unsigned long A,B,C,D;\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;X+=HASH_LBLOCK)\\r\\n{\\r\\nR0(A,B,C,D,X[ 0], 7,0xd76aa478L);\\r\\nR0(D,A,B,C,X[ 1],12,0xe8c7b756L);\\r\\nR0(C,D,A,B,X[ 2],17,0x242070dbL);\\r\\nR0(B,C,D,A,X[ 3],22,0xc1bdceeeL);\\r\\nR0(A,B,C,D,X[ 4], 7,0xf57c0fafL);\\r\\nR0(D,A,B,C,X[ 5],12,0x4787c62aL);\\r\\nR0(C,D,A,B,X[ 6],17,0xa8304613L);\\r\\nR0(B,C,D,A,X[ 7],22,0xfd469501L);\\r\\nR0(A,B,C,D,X[ 8], 7,0x698098d8L);\\r\\nR0(D,A,B,C,X[ 9],12,0x8b44f7afL);\\r\\nR0(C,D,A,B,X[10],17,0xffff5bb1L);\\r\\nR0(B,C,D,A,X[11],22,0x895cd7beL);\\r\\nR0(A,B,C,D,X[12], 7,0x6b901122L);\\r\\nR0(D,A,B,C,X[13],12,0xfd987193L);\\r\\nR0(C,D,A,B,X[14],17,0xa679438eL);\\r\\nR0(B,C,D,A,X[15],22,0x49b40821L);\\r\\nR1(A,B,C,D,X[ 1], 5,0xf61e2562L);\\r\\nR1(D,A,B,C,X[ 6], 9,0xc040b340L);\\r\\nR1(C,D,A,B,X[11],14,0x265e5a51L);\\r\\nR1(B,C,D,A,X[ 0],20,0xe9b6c7aaL);\\r\\nR1(A,B,C,D,X[ 5], 5,0xd62f105dL);\\r\\nR1(D,A,B,C,X[10], 9,0x02441453L);\\r\\nR1(C,D,A,B,X[15],14,0xd8a1e681L);\\r\\nR1(B,C,D,A,X[ 4],20,0xe7d3fbc8L);\\r\\nR1(A,B,C,D,X[ 9], 5,0x21e1cde6L);\\r\\nR1(D,A,B,C,X[14], 9,0xc33707d6L);\\r\\nR1(C,D,A,B,X[ 3],14,0xf4d50d87L);\\r\\nR1(B,C,D,A,X[ 8],20,0x455a14edL);\\r\\nR1(A,B,C,D,X[13], 5,0xa9e3e905L);\\r\\nR1(D,A,B,C,X[ 2], 9,0xfcefa3f8L);\\r\\nR1(C,D,A,B,X[ 7],14,0x676f02d9L);\\r\\nR1(B,C,D,A,X[12],20,0x8d2a4c8aL);\\r\\nR2(A,B,C,D,X[ 5], 4,0xfffa3942L);\\r\\nR2(D,A,B,C,X[ 8],11,0x8771f681L);\\r\\nR2(C,D,A,B,X[11],16,0x6d9d6122L);\\r\\nR2(B,C,D,A,X[14],23,0xfde5380cL);\\r\\nR2(A,B,C,D,X[ 1], 4,0xa4beea44L);\\r\\nR2(D,A,B,C,X[ 4],11,0x4bdecfa9L);\\r\\nR2(C,D,A,B,X[ 7],16,0xf6bb4b60L);\\r\\nR2(B,C,D,A,X[10],23,0xbebfbc70L);\\r\\nR2(A,B,C,D,X[13], 4,0x289b7ec6L);\\r\\nR2(D,A,B,C,X[ 0],11,0xeaa127faL);\\r\\nR2(C,D,A,B,X[ 3],16,0xd4ef3085L);\\r\\nR2(B,C,D,A,X[ 6],23,0x04881d05L);\\r\\nR2(A,B,C,D,X[ 9], 4,0xd9d4d039L);\\r\\nR2(D,A,B,C,X[12],11,0xe6db99e5L);\\r\\nR2(C,D,A,B,X[15],16,0x1fa27cf8L);\\r\\nR2(B,C,D,A,X[ 2],23,0xc4ac5665L);\\r\\nR3(A,B,C,D,X[ 0], 6,0xf4292244L);\\r\\nR3(D,A,B,C,X[ 7],10,0x432aff97L);\\r\\nR3(C,D,A,B,X[14],15,0xab9423a7L);\\r\\nR3(B,C,D,A,X[ 5],21,0xfc93a039L);\\r\\nR3(A,B,C,D,X[12], 6,0x655b59c3L);\\r\\nR3(D,A,B,C,X[ 3],10,0x8f0ccc92L);\\r\\nR3(C,D,A,B,X[10],15,0xffeff47dL);\\r\\nR3(B,C,D,A,X[ 1],21,0x85845dd1L);\\r\\nR3(A,B,C,D,X[ 8], 6,0x6fa87e4fL);\\r\\nR3(D,A,B,C,X[15],10,0xfe2ce6e0L);\\r\\nR3(C,D,A,B,X[ 6],15,0xa3014314L);\\r\\nR3(B,C,D,A,X[13],21,0x4e0811a1L);\\r\\nR3(A,B,C,D,X[ 4], 6,0xf7537e82L);\\r\\nR3(D,A,B,C,X[11],10,0xbd3af235L);\\r\\nR3(C,D,A,B,X[ 2],15,0x2ad7d2bbL);\\r\\nR3(B,C,D,A,X[ 9],21,0xeb86d391L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nvoid md5_block_data_order (MD5_CTX *c, const void *data_, int num)\\r\\n{\\r\\nconst unsigned char *data=data_;\\r\\nregister unsigned long A,B,C,D,l;\\r\\nMD5_LONG X[MD5_LBLOCK];\\r\\nA=c->A;\\r\\nB=c->B;\\r\\nC=c->C;\\r\\nD=c->D;\\r\\nfor (;num--;)\\r\\n{\\r\\nHOST_c2l(data,l); X[ 0]=l; HOST_c2l(data,l); X[ 1]=l;\\r\\nR0(A,B,C,D,X[ 0], 7,0xd76aa478L); HOST_c2l(data,l); X[ 2]=l;\\r\\nR0(D,A,B,C,X[ 1],12,0xe8c7b756L); HOST_c2l(data,l); X[ 3]=l;\\r\\nR0(C,D,A,B,X[ 2],17,0x242070dbL); HOST_c2l(data,l); X[ 4]=l;\\r\\nR0(B,C,D,A,X[ 3],22,0xc1bdceeeL); HOST_c2l(data,l); X[ 5]=l;\\r\\nR0(A,B,C,D,X[ 4], 7,0xf57c0fafL); HOST_c2l(data,l); X[ 6]=l;\\r\\nR0(D,A,B,C,X[ 5],12,0x4787c62aL); HOST_c2l(data,l); X[ 7]=l;\\r\\nR0(C,D,A,B,X[ 6],17,0xa8304613L); HOST_c2l(data,l); X[ 8]=l;\\r\\nR0(B,C,D,A,X[ 7],22,0xfd469501L); HOST_c2l(data,l); X[ 9]=l;\\r\\nR0(A,B,C,D,X[ 8], 7,0x698098d8L); HOST_c2l(data,l); X[10]=l;\\r\\nR0(D,A,B,C,X[ 9],12,0x8b44f7afL); HOST_c2l(data,l); X[11]=l;\\r\\nR0(C,D,A,B,X[10],17,0xffff5bb1L); HOST_c2l(data,l); X[12]=l;\\r\\nR0(B,C,D,A,X[11],22,0x895cd7beL); HOST_c2l(data,l); X[13]=l;\\r\\nR0(A,B,C,D,X[12], 7,0x6b901122L); HOST_c2l(data,l); X[14]=l;\\r\\nR0(D,A,B,C,X[13],12,0xfd987193L); HOST_c2l(data,l); X[15]=l;\\r\\nR0(C,D,A,B,X[14],17,0xa679438eL);\\r\\nR0(B,C,D,A,X[15],22,0x49b40821L);\\r\\nR1(A,B,C,D,X[ 1], 5,0xf61e2562L);\\r\\nR1(D,A,B,C,X[ 6], 9,0xc040b340L);\\r\\nR1(C,D,A,B,X[11],14,0x265e5a51L);\\r\\nR1(B,C,D,A,X[ 0],20,0xe9b6c7aaL);\\r\\nR1(A,B,C,D,X[ 5], 5,0xd62f105dL);\\r\\nR1(D,A,B,C,X[10], 9,0x02441453L);\\r\\nR1(C,D,A,B,X[15],14,0xd8a1e681L);\\r\\nR1(B,C,D,A,X[ 4],20,0xe7d3fbc8L);\\r\\nR1(A,B,C,D,X[ 9], 5,0x21e1cde6L);\\r\\nR1(D,A,B,C,X[14], 9,0xc33707d6L);\\r\\nR1(C,D,A,B,X[ 3],14,0xf4d50d87L);\\r\\nR1(B,C,D,A,X[ 8],20,0x455a14edL);\\r\\nR1(A,B,C,D,X[13], 5,0xa9e3e905L);\\r\\nR1(D,A,B,C,X[ 2], 9,0xfcefa3f8L);\\r\\nR1(C,D,A,B,X[ 7],14,0x676f02d9L);\\r\\nR1(B,C,D,A,X[12],20,0x8d2a4c8aL);\\r\\nR2(A,B,C,D,X[ 5], 4,0xfffa3942L);\\r\\nR2(D,A,B,C,X[ 8],11,0x8771f681L);\\r\\nR2(C,D,A,B,X[11],16,0x6d9d6122L);\\r\\nR2(B,C,D,A,X[14],23,0xfde5380cL);\\r\\nR2(A,B,C,D,X[ 1], 4,0xa4beea44L);\\r\\nR2(D,A,B,C,X[ 4],11,0x4bdecfa9L);\\r\\nR2(C,D,A,B,X[ 7],16,0xf6bb4b60L);\\r\\nR2(B,C,D,A,X[10],23,0xbebfbc70L);\\r\\nR2(A,B,C,D,X[13], 4,0x289b7ec6L);\\r\\nR2(D,A,B,C,X[ 0],11,0xeaa127faL);\\r\\nR2(C,D,A,B,X[ 3],16,0xd4ef3085L);\\r\\nR2(B,C,D,A,X[ 6],23,0x04881d05L);\\r\\nR2(A,B,C,D,X[ 9], 4,0xd9d4d039L);\\r\\nR2(D,A,B,C,X[12],11,0xe6db99e5L);\\r\\nR2(C,D,A,B,X[15],16,0x1fa27cf8L);\\r\\nR2(B,C,D,A,X[ 2],23,0xc4ac5665L);\\r\\nR3(A,B,C,D,X[ 0], 6,0xf4292244L);\\r\\nR3(D,A,B,C,X[ 7],10,0x432aff97L);\\r\\nR3(C,D,A,B,X[14],15,0xab9423a7L);\\r\\nR3(B,C,D,A,X[ 5],21,0xfc93a039L);\\r\\nR3(A,B,C,D,X[12], 6,0x655b59c3L);\\r\\nR3(D,A,B,C,X[ 3],10,0x8f0ccc92L);\\r\\nR3(C,D,A,B,X[10],15,0xffeff47dL);\\r\\nR3(B,C,D,A,X[ 1],21,0x85845dd1L);\\r\\nR3(A,B,C,D,X[ 8], 6,0x6fa87e4fL);\\r\\nR3(D,A,B,C,X[15],10,0xfe2ce6e0L);\\r\\nR3(C,D,A,B,X[ 6],15,0xa3014314L);\\r\\nR3(B,C,D,A,X[13],21,0x4e0811a1L);\\r\\nR3(A,B,C,D,X[ 4], 6,0xf7537e82L);\\r\\nR3(D,A,B,C,X[11],10,0xbd3af235L);\\r\\nR3(C,D,A,B,X[ 2],15,0x2ad7d2bbL);\\r\\nR3(B,C,D,A,X[ 9],21,0xeb86d391L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}\\r\\nint printit(unsigned long *l)\\r\\n{\\r\\nint i,ii;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nfor (ii=0; ii<8; ii++)\\r\\n{\\r\\nfprintf(stderr,\"%08lx \",l[i*8+ii]);\\r\\n}\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_s_pu_c", "target": 0, "func": "DSA *d2i_DSAPublicKey(DSA **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ASN1_R_PARSING;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,DSA *,DSA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nif ((length != 0) && ((M_ASN1_next & (~V_ASN1_CONSTRUCTED))\\r\\n== (V_ASN1_UNIVERSAL|(V_ASN1_INTEGER))))\\r\\n{\\r\\nc.slen=length;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->pub_key=BN_bin2bn(bs->data,bs->length,ret->pub_key))\\r\\n== NULL)\\r\\ngoto err_bn;\\r\\nret->write_params=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->pub_key=BN_bin2bn(bs->data,bs->length,ret->pub_key))\\r\\n== NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->p=BN_bin2bn(bs->data,bs->length,ret->p)) == NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->q=BN_bin2bn(bs->data,bs->length,ret->q)) == NULL)\\r\\ngoto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->g=BN_bin2bn(bs->data,bs->length,ret->g)) == NULL)\\r\\ngoto err_bn;\\r\\nret->write_params=1;\\r\\n}\\r\\nASN1_INTEGER_free(bs);\\r\\nbs=NULL;\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_DSAPUBLICKEY,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) DSA_free(ret);\\r\\nif (bs != NULL) ASN1_INTEGER_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_dhp_c", "target": 0, "func": "int i2d_DHparams(DH *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[3];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot=0,len,max=0;\\r\\nint t,ret= -1;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nnum[0]=a->p;\\r\\nnum[1]=a->g;\\r\\nif (a->length != 0)\\r\\n{\\r\\nif ((num[2]=BN_new()) == NULL) goto err;\\r\\nif (!BN_set_word(num[2],a->length)) goto err;\\r\\n}\\r\\nelse\\r\\nnum[2]=NULL;\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (num[i] == NULL) continue;\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL)\\r\\n{\\r\\nif (num[2] != NULL)\\r\\nBN_free(num[2]);\\r\\nreturn(t);\\r\\n}\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_DHPARAMS,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (num[i] == NULL) continue;\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\nret=t;\\r\\nerr:\\r\\nif (num[2] != NULL) BN_free(num[2]);\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_3d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ede(void)\\r\\n{\\r\\nreturn(&d_ede_cipher2);\\r\\n}\\r\\nEVP_CIPHER *EVP_des_ede3(void)\\r\\n{\\r\\nreturn(&d_ede3_cipher3);\\r\\n}\\r\\nstatic void des_ede_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\nmemcpy( (char *)ctx->c.des_ede.ks3,\\r\\n(char *)ctx->c.des_ede.ks1,\\r\\nsizeof(ctx->c.des_ede.ks1));\\r\\n}\\r\\n}\\r\\nstatic void des_ede3_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\ndes_set_key(&deskey[2],ctx->c.des_ede.ks3);\\r\\n}\\r\\n}\\r\\nstatic void des_ede_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\ndes_cblock *output ;\\r\\ndes_cblock *input ;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\noutput = (des_cblock *)(out + i);\\r\\ninput = (des_cblock *)(in + i);\\r\\ndes_ecb3_encrypt(input,output,\\r\\nctx->c.des_ede.ks1,\\r\\nctx->c.des_ede.ks2,\\r\\nctx->c.des_ede.ks3,\\r\\nctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_clnt_c", "target": 1, "func": "static SSL_METHOD *ssl2_get_client_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_client_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_client_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_client_data.ssl_connect=ssl2_connect;\\r\\nSSLv2_client_data.get_ssl_method=ssl2_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv2_client_data);\\r\\n}\\r\\nint ssl2_connect(SSL *s)\\r\\n{\\r\\nunsigned long l=time(NULL);\\r\\nBUF_MEM *buf=NULL;\\r\\nint ret= -1;\\r\\nvoid (*cb)()=NULL;\\r\\nint new_state,state;\\r\\nRAND_seed(&l,sizeof(l));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->version=SSL2_VERSION;\\r\\ns->type=SSL_ST_CONNECT;\\r\\nbuf=s->init_buf;\\r\\nif ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_CLIENT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->handshake_func=ssl2_connect;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A:\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A:\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B:\\r\\nret=get_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (!s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_A;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\\r\\nbreak;\\r\\n}\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A:\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B:\\r\\nret=client_master_key(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\\r\\nbreak;\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION:\\r\\nif (!ssl2_enc_init(s,1))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->s2->clear_text=0;\\r\\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A:\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B:\\r\\nret=client_finished(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_VERIFY_A;\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A:\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B:\\r\\nret=get_server_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A:\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B:\\r\\nret=get_server_finished(s);\\r\\nif (ret <= 0) goto end;\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C:\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D:\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE:\\r\\nret=client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nif (s->init_buf != NULL)\\r\\n{\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\n}\\r\\ns->init_num=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\\r\\nif (s->hit) s->ctx->stats.sess_hit++;\\r\\nret=1;\\r\\ns->ctx->stats.sess_connect_good++;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL2_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nreturn(-1);\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int get_server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nint i,j;\\r\\nSTACK_OF(SSL_CIPHER) *sk=NULL,*cl;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=buf;\\r\\nif (s->state == SSL2_ST_GET_SERVER_HELLO_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),11-s->init_num);\\r\\nif (i < (11-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\\r\\nif (*(p++) != SSL2_MT_SERVER_HELLO)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,\\r\\nSSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,\\r\\nSSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ns->hit=(*(p++))?1:0;\\r\\ns->s2->tmp.cert_type= *(p++);\\r\\nn2s(p,i);\\r\\nif (i < s->version) s->version=i;\\r\\nn2s(p,i); s->s2->tmp.cert_length=i;\\r\\nn2s(p,i); s->s2->tmp.csl=i;\\r\\nn2s(p,i); s->s2->tmp.conn_id_length=i;\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_B;\\r\\ns->init_num=0;\\r\\n}\\r\\nj=s->s2->tmp.cert_length+s->s2->tmp.csl+s->s2->tmp.conn_id_length\\r\\n- s->init_num;\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),j);\\r\\nif (i != j) return(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\\r\\np=buf;\\r\\nif (s->hit)\\r\\n{\\r\\nif (s->s2->tmp.cert_length != 0)\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_LENGTH_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\nif (s->s2->tmp.cert_type != 0)\\r\\n{\\r\\nif (!(s->options &\\r\\nSSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_TYPE_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (s->s2->tmp.csl != 0)\\r\\n{\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CIPHER_LIST_NOT_ZERO);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef undef\\r\\nmemset(s->session->session_id,0,\\r\\nSSL_MAX_SSL_SESSION_ID_LENGTH_IN_BYTES);\\r\\ns->session->session_id_length=0;\\r\\n*/\\r\\n#endif\\r\\nif (s->session->session_id_length > 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nif (ssl2_set_certificate(s,s->s2->tmp.cert_type,\\r\\ns->s2->tmp.cert_length,p) <= 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\nreturn(-1);\\r\\n}\\r\\np+=s->s2->tmp.cert_length;\\r\\nif (s->s2->tmp.csl == 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_LIST);\\r\\nreturn(-1);\\r\\n}\\r\\nsk=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.csl,\\r\\n&s->session->ciphers);\\r\\np+=s->s2->tmp.csl;\\r\\nif (sk == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nsk_SSL_CIPHER_set_cmp_func(sk,ssl_cipher_ptr_id_cmp);\\r\\ncl=ssl_get_ciphers_by_id(s);\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(cl); i++)\\r\\n{\\r\\nif (sk_SSL_CIPHER_find(sk,\\r\\nsk_SSL_CIPHER_value(cl,i)) >= 0)\\r\\nbreak;\\r\\n}\\r\\nif (i >= sk_SSL_CIPHER_num(cl))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_MATCH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->session->cipher=sk_SSL_CIPHER_value(cl,i);\\r\\n}\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\n#if 0\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\ns->session->peer=s->session->sess_cert->key->x509;\\r\\ns->session->peer->references++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n#else\\r\\ns->session->peer = s->session->sess_cert->peer_key->x509;\\r\\nCRYPTO_add(&s->session->peer->references, 1, CRYPTO_LOCK_X509);\\r\\n#endif\\r\\ns->s2->conn_id_length=s->s2->tmp.conn_id_length;\\r\\nmemcpy(s->s2->conn_id,p,s->s2->tmp.conn_id_length);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,n,j;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_HELLO_A)\\r\\n{\\r\\nif ((s->session == NULL) ||\\r\\n(s->session->ssl_version != s->version))\\r\\n{\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np=buf;\\r\\nd=p+9;\\r\\n*(p++)=SSL2_MT_CLIENT_HELLO;\\r\\ns2n(SSL2_VERSION,p);\\r\\nn=j=0;\\r\\nn=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),d);\\r\\nd+=n;\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\nreturn(-1);\\r\\n}\\r\\ns2n(n,p);\\r\\nif ((s->session->session_id_length > 0) &&\\r\\n(s->session->session_id_length <=\\r\\nSSL2_MAX_SSL_SESSION_ID_LENGTH))\\r\\n{\\r\\ni=s->session->session_id_length;\\r\\ns2n(i,p);\\r\\nmemcpy(d,s->session->session_id,(unsigned int)i);\\r\\nd+=i;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns2n(0,p);\\r\\n}\\r\\ns->s2->challenge_length=SSL2_CHALLENGE_LENGTH;\\r\\ns2n(SSL2_CHALLENGE_LENGTH,p);\\r\\nRAND_bytes(s->s2->challenge,SSL2_CHALLENGE_LENGTH);\\r\\nmemcpy(d,s->s2->challenge,SSL2_CHALLENGE_LENGTH);\\r\\nd+=SSL2_CHALLENGE_LENGTH;\\r\\ns->state=SSL2_ST_SEND_CLIENT_HELLO_B;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_master_key(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint clear,enc,karg,i;\\r\\nSSL_SESSION *sess;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_MASTER_KEY_A)\\r\\n{\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(-1);\\r\\n}\\r\\nsess=s->session;\\r\\np=buf;\\r\\nd=p+10;\\r\\n*(p++)=SSL2_MT_CLIENT_MASTER_KEY;\\r\\ni=ssl_put_cipher_by_char(s,sess->cipher,p);\\r\\np+=i;\\r\\ni=EVP_CIPHER_iv_length(c);\\r\\nsess->key_arg_length=i;\\r\\nif (i > 0) RAND_bytes(sess->key_arg,i);\\r\\ni=EVP_CIPHER_key_length(c);\\r\\nsess->master_key_length=i;\\r\\nif (i > 0) RAND_bytes(sess->master_key,i);\\r\\nif (sess->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)\\r\\nenc=8;\\r\\nelse if (SSL_C_IS_EXPORT(sess->cipher))\\r\\nenc=5;\\r\\nelse\\r\\nenc=i;\\r\\nif (i < enc)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_CIPHER_TABLE_SRC_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nclear=i-enc;\\r\\ns2n(clear,p);\\r\\nmemcpy(d,sess->master_key,(unsigned int)clear);\\r\\nd+=clear;\\r\\nenc=ssl_rsa_public_encrypt(sess->sess_cert,enc,\\r\\n&(sess->master_key[clear]),d,\\r\\n(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);\\r\\nif (enc <= 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PUBLIC_KEY_ENCRYPT_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n#ifdef PKCS1_CHECK\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_1) d[1]++;\\r\\nif (s->options & SSL_OP_PKCS1_CHECK_2)\\r\\nsess->master_key[clear]++;\\r\\n#endif\\r\\ns2n(enc,p);\\r\\nd+=enc;\\r\\nkarg=sess->key_arg_length;\\r\\ns2n(karg,p);\\r\\nmemcpy(d,sess->key_arg,(unsigned int)karg);\\r\\nd+=karg;\\r\\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_B;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_finished(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_FINISHED_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_CLIENT_FINISHED;\\r\\nmemcpy(p,s->s2->conn_id,(unsigned int)s->s2->conn_id_length);\\r\\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_B;\\r\\ns->init_num=s->s2->conn_id_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int client_certificate(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i;\\r\\nunsigned int n;\\r\\nint cert_ch_len=0;\\r\\nunsigned char *cert_ch;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\ncert_ch= &(buf[2]);\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),\\r\\nSSL2_MAX_CERT_CHALLENGE_LENGTH+1-s->init_num);\\r\\nif (i<(SSL2_MIN_CERT_CHALLENGE_LENGTH+1-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_CLIENT_CERTIFICATE,i));\\r\\nif (buf[1] != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\\r\\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_AUTHENTICATION_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\ncert_ch_len=i-1;\\r\\nif ((s->cert == NULL) ||\\r\\n(s->cert->key->x509 == NULL) ||\\r\\n(s->cert->key->privatekey == NULL))\\r\\n{\\r\\ns->state=SSL2_ST_X509_GET_CLIENT_CERTIFICATE;\\r\\n}\\r\\nelse\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\\r\\n}\\r\\nif (s->state == SSL2_ST_X509_GET_CLIENT_CERTIFICATE)\\r\\n{\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\ni=0;\\r\\nif (s->ctx->client_cert_cb != NULL)\\r\\n{\\r\\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\\r\\n}\\r\\nif (i < 0)\\r\\n{\\r\\ns->rwstate=SSL_X509_LOOKUP;\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\\r\\nif ( !SSL_use_certificate(s,x509) ||\\r\\n!SSL_use_PrivateKey(s,pkey))\\r\\n{\\r\\ni=0;\\r\\n}\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse if (i == 1)\\r\\n{\\r\\nif (x509 != NULL) X509_free(x509);\\r\\nif (pkey != NULL) EVP_PKEY_free(pkey);\\r\\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\\r\\ni=0;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_B;\\r\\np=buf;\\r\\n*(p++)=SSL2_MT_ERROR;\\r\\ns2n(SSL2_PE_NO_CERTIFICATE,p);\\r\\ns->init_off=0;\\r\\ns->init_num=3;\\r\\n}\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_B)\\r\\n{\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_C)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\np=buf;\\r\\nEVP_SignInit(&ctx,s->ctx->rsa_md5);\\r\\nEVP_SignUpdate(&ctx,s->s2->key_material,\\r\\n(unsigned int)s->s2->key_material_length);\\r\\nEVP_SignUpdate(&ctx,cert_ch,(unsigned int)cert_ch_len);\\r\\nn=i2d_X509(s->session->sess_cert->peer_key->x509,&p);\\r\\nEVP_SignUpdate(&ctx,buf,(unsigned int)n);\\r\\np=buf;\\r\\nd=p+6;\\r\\n*(p++)=SSL2_MT_CLIENT_CERTIFICATE;\\r\\n*(p++)=SSL2_CT_X509_CERTIFICATE;\\r\\nn=i2d_X509(s->cert->key->x509,&d);\\r\\ns2n(n,p);\\r\\nif (!EVP_SignFinal(&ctx,d,&n,s->cert->key->privatekey))\\r\\n{\\r\\n}\\r\\nmemset(&ctx,0,sizeof(ctx));\\r\\ns2n(n,p);\\r\\nd+=n;\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_D;\\r\\ns->init_num=d-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int get_server_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nint i;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_SERVER_VERIFY_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);\\r\\nif (i < (1-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\\r\\ns->state= SSL2_ST_GET_SERVER_VERIFY_B;\\r\\ns->init_num=0;\\r\\nif (*p != SSL2_MT_SERVER_VERIFY)\\r\\n{\\r\\nif (p[0] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,\\r\\nSSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,\\r\\nSSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),\\r\\n(unsigned int)s->s2->challenge_length-s->init_num);\\r\\nif (i < ((int)s->s2->challenge_length-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\\r\\nif (memcmp(p,s->s2->challenge,(unsigned int)s->s2->challenge_length) != 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_CHALLENGE_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_server_finished(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=buf;\\r\\nif (s->state == SSL2_ST_GET_SERVER_FINISHED_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),1-s->init_num);\\r\\nif (i < (1-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\\r\\ns->init_num=i;\\r\\nif (*p == SSL2_MT_REQUEST_CERTIFICATE)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_A;\\r\\nreturn(1);\\r\\n}\\r\\nelse if (*p != SSL2_MT_SERVER_FINISHED)\\r\\n{\\r\\nif (p[0] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ns->state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\n}\\r\\ni=ssl2_read(s,(char *)&(buf[s->init_num]),\\r\\nSSL2_SSL_SESSION_ID_LENGTH-s->init_num);\\r\\nif (i < (SSL2_SSL_SESSION_ID_LENGTH-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\\r\\nif (!s->hit)\\r\\n{\\r\\ns->session->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;\\r\\nmemcpy(s->session->session_id,p,SSL2_SSL_SESSION_ID_LENGTH);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!(s->options & SSL_OP_MICROSOFT_SESS_ID_BUG))\\r\\n{\\r\\nif (memcmp(buf,s->session->session_id,\\r\\n(unsigned int)s->session->session_id_length) != 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_SSL_SESSION_ID_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint ssl2_set_certificate(SSL *s, int type, int len, unsigned char *data)\\r\\n{\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nSESS_CERT *sc=NULL;\\r\\nint i;\\r\\nX509 *x509=NULL;\\r\\nint ret=0;\\r\\nx509=d2i_X509(NULL,&data,(long)len);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((sk=sk_X509_new_null()) == NULL || !sk_X509_push(sk,x509))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif ((s->verify_mode != SSL_VERIFY_NONE) && (!i))\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nsc=ssl_sess_cert_new();\\r\\nif (sc == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nif (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=sc;\\r\\nsc->peer_pkeys[SSL_PKEY_RSA_ENC].x509=x509;\\r\\nsc->peer_key= &(sc->peer_pkeys[SSL_PKEY_RSA_ENC]);\\r\\npkey=X509_get_pubkey(x509);\\r\\nx509=NULL;\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (pkey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_PUBLIC_KEY_NOT_RSA);\\r\\ngoto err;\\r\\n}\\r\\nif (!ssl_set_peer_cert_type(sc,SSL2_CT_X509_CERTIFICATE))\\r\\ngoto err;\\r\\nret=1;\\r\\nerr:\\r\\nsk_X509_free(sk);\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_rsa_public_encrypt(SESS_CERT *sc, int len, unsigned char *from,\\r\\nunsigned char *to, int padding)\\r\\n{\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint i= -1;\\r\\nif ((sc == NULL) || (sc->peer_key->x509 == NULL) ||\\r\\n((pkey=X509_get_pubkey(sc->peer_key->x509)) == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_NO_PUBLICKEY);\\r\\nreturn(-1);\\r\\n}\\r\\nif (pkey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);\\r\\ngoto end;\\r\\n}\\r\\ni=RSA_public_encrypt(len,from,to,pkey->pkey.rsa,padding);\\r\\nif (i < 0)\\r\\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,ERR_R_RSA_LIB);\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_b_print_c", "target": 1, "func": "int BIO_printf (BIO *bio, ...)\\r\\n{\\r\\nva_list args;\\r\\nchar *format;\\r\\nint ret;\\r\\nMS_STATIC char hugebuf[1024*2];\\r\\nva_start(args, bio);\\r\\nformat=va_arg(args, char *);\\r\\nhugebuf[0]='\\0';\\r\\nvsprintf(hugebuf,format,args);\\r\\nret=BIO_write(bio,hugebuf,strlen(hugebuf));\\r\\nva_end(args);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_prn_c", "target": 0, "func": "int X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, int flag, int indent)\\r\\n{\\r\\nchar *ext_str = NULL, *value = NULL;\\r\\nunsigned char *p;\\r\\nX509V3_EXT_METHOD *method;\\r\\nSTACK_OF(CONF_VALUE) *nval = NULL;\\r\\nint ok = 1;\\r\\nif(!(method = X509V3_EXT_get(ext))) return 0;\\r\\np = ext->value->data;\\r\\nif(!(ext_str = method->d2i(NULL, &p, ext->value->length))) return 0;\\r\\nif(method->i2s) {\\r\\nif(!(value = method->i2s(method, ext_str))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", value);\\r\\n} else if(method->i2v) {\\r\\nif(!(nval = method->i2v(method, ext_str, NULL))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\nX509V3_EXT_val_prn(out, nval, indent,\\r\\nmethod->ext_flags & X509V3_EXT_MULTILINE);\\r\\n} else if(method->i2r) {\\r\\nif(!method->i2r(method, ext_str, out, indent)) ok = 0;\\r\\n} else ok = 0;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\\r\\nif(value) Free(value);\\r\\nmethod->ext_free(ext_str);\\r\\nreturn ok;\\r\\n}\\r\\nint X509V3_EXT_print_fp(FILE *fp, X509_EXTENSION *ext, int flag, int indent)\\r\\n{\\r\\nBIO *bio_tmp;\\r\\nint ret;\\r\\nif(!(bio_tmp = BIO_new_fp(fp, BIO_NOCLOSE))) return 0;\\r\\nret = X509V3_EXT_print(bio_tmp, ext, flag, indent);\\r\\nBIO_free(bio_tmp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_ecb_c", "target": 0, "func": "void CAST_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nCAST_KEY *ks, int enc)\\r\\n{\\r\\nCAST_LONG l,d[2];\\r\\nn2l(in,l); d[0]=l;\\r\\nn2l(in,l); d[1]=l;\\r\\nif (enc)\\r\\nCAST_encrypt(d,ks);\\r\\nelse\\r\\nCAST_decrypt(d,ks);\\r\\nl=d[0]; l2n(l,out);\\r\\nl=d[1]; l2n(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_recp_c", "target": 0, "func": "void BN_RECP_CTX_init(BN_RECP_CTX *recp)\\r\\n{\\r\\nBN_init(&(recp->N));\\r\\nBN_init(&(recp->Nr));\\r\\nrecp->num_bits=0;\\r\\nrecp->flags=0;\\r\\n}\\r\\nBN_RECP_CTX *BN_RECP_CTX_new(void)\\r\\n{\\r\\nBN_RECP_CTX *ret;\\r\\nif ((ret=(BN_RECP_CTX *)Malloc(sizeof(BN_RECP_CTX))) == NULL)\\r\\nreturn(NULL);\\r\\nBN_RECP_CTX_init(ret);\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BN_RECP_CTX_free(BN_RECP_CTX *recp)\\r\\n{\\r\\nif(recp == NULL)\\r\\nreturn;\\r\\nBN_free(&(recp->N));\\r\\nBN_free(&(recp->Nr));\\r\\nif (recp->flags & BN_FLG_MALLOCED)\\r\\nFree(recp);\\r\\n}\\r\\nint BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\nBN_copy(&(recp->N),d);\\r\\nBN_zero(&(recp->Nr));\\r\\nrecp->num_bits=BN_num_bits(d);\\r\\nrecp->shift=0;\\r\\nreturn(1);\\r\\n}\\r\\nint BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *x, BIGNUM *y, BN_RECP_CTX *recp,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nBIGNUM *a;\\r\\na= &(ctx->bn[ctx->tos++]);\\r\\nif (y != NULL)\\r\\n{\\r\\nif (x == y)\\r\\n{ if (!BN_sqr(a,x,ctx)) goto err; }\\r\\nelse\\r\\n{ if (!BN_mul(a,x,y,ctx)) goto err; }\\r\\n}\\r\\nelse\\r\\na=x;\\r\\nBN_div_recp(NULL,r,a,recp,ctx);\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos--;\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_div_recp(BIGNUM *dv, BIGNUM *rem, BIGNUM *m, BN_RECP_CTX *recp,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i,j,tos,ret=0,ex;\\r\\nBIGNUM *a,*b,*d,*r;\\r\\ntos=ctx->tos;\\r\\na= &(ctx->bn[ctx->tos++]);\\r\\nb= &(ctx->bn[ctx->tos++]);\\r\\nif (dv != NULL)\\r\\nd=dv;\\r\\nelse\\r\\nd= &(ctx->bn[ctx->tos++]);\\r\\nif (rem != NULL)\\r\\nr=rem;\\r\\nelse\\r\\nr= &(ctx->bn[ctx->tos++]);\\r\\nif (BN_ucmp(m,&(recp->N)) < 0)\\r\\n{\\r\\nBN_zero(d);\\r\\nBN_copy(r,m);\\r\\nctx->tos=tos;\\r\\nreturn(1);\\r\\n}\\r\\ni=BN_num_bits(m);\\r\\nj=recp->num_bits*2;\\r\\nif (j > i)\\r\\n{\\r\\ni=j;\\r\\nex=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nex=(i-j)/2;\\r\\n}\\r\\nj=i/2;\\r\\nif (i != recp->shift)\\r\\nrecp->shift=BN_reciprocal(&(recp->Nr),&(recp->N),\\r\\ni,ctx);\\r\\nif (!BN_rshift(a,m,j-ex)) goto err;\\r\\nif (!BN_mul(b,a,&(recp->Nr),ctx)) goto err;\\r\\nif (!BN_rshift(d,b,j+ex)) goto err;\\r\\nd->neg=0;\\r\\nif (!BN_mul(b,&(recp->N),d,ctx)) goto err;\\r\\nif (!BN_usub(r,m,b)) goto err;\\r\\nr->neg=0;\\r\\nj=0;\\r\\n#if 1\\r\\nwhile (BN_ucmp(r,&(recp->N)) >= 0)\\r\\n{\\r\\nif (j++ > 2)\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_MUL_RECIPROCAL,BN_R_BAD_RECIPROCAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_usub(r,r,&(recp->N))) goto err;\\r\\nif (!BN_add_word(d,1)) goto err;\\r\\n}\\r\\n#endif\\r\\nr->neg=BN_is_zero(r)?0:m->neg;\\r\\nd->neg=m->neg^recp->N.neg;\\r\\nret=1;\\r\\nerr:\\r\\nctx->tos=tos;\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_reciprocal(BIGNUM *r, BIGNUM *m, int len, BN_CTX *ctx)\\r\\n{\\r\\nint ret= -1;\\r\\nBIGNUM t;\\r\\nBN_init(&t);\\r\\nBN_zero(&t);\\r\\nif (!BN_set_bit(&t,len)) goto err;\\r\\nif (!BN_div(r,NULL,&t,m,ctx)) goto err;\\r\\nret=len;\\r\\nerr:\\r\\nBN_free(&t);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_r2_c", "target": 0, "func": "EVP_CIPHER *EVP_rc2_ecb(void)\\r\\n{\\r\\nreturn(&r2_ecb_cipher);\\r\\n}\\r\\nstatic void rc2_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\nRC2_set_key(&(ctx->c.rc2_ks),EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,EVP_CIPHER_CTX_key_length(ctx)*8);\\r\\n}\\r\\nstatic void rc2_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\nRC2_ecb_encrypt(\\r\\n&(in[i]),&(out[i]),\\r\\n&(ctx->c.rc2_ks),ctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_r2_c", "target": 0, "func": "EVP_CIPHER *EVP_rc2_ofb(void)\\r\\n{\\r\\nreturn(&r2_ofb_cipher);\\r\\n}\\r\\nstatic void rc2_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC2_set_key(&(ctx->c.rc2_ks),EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,EVP_CIPHER_CTX_key_length(ctx)*8);\\r\\n}\\r\\nstatic void rc2_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC2_ofb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.rc2_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2_ecb_c", "target": 0, "func": "void RC2_ecb_encrypt(unsigned char *in, unsigned char *out, RC2_KEY *ks,\\r\\nint encrypt)\\r\\n{\\r\\nunsigned long l,d[2];\\r\\nc2l(in,l); d[0]=l;\\r\\nc2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nRC2_encrypt(d,ks);\\r\\nelse\\r\\nRC2_decrypt(d,ks);\\r\\nl=d[0]; l2c(l,out);\\r\\nl=d[1]; l2c(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_prime_c", "target": 0, "func": "void callback(type,num)\\r\\nint type,num;\\r\\n{\\r\\nif (type == 0)\\r\\nfprintf(stderr,\".\");\\r\\nelse if (type == 1)\\r\\nfprintf(stderr,\"+\");\\r\\nelse if (type == 2)\\r\\nfprintf(stderr,\"*\");\\r\\nfflush(stderr);\\r\\n}\\r\\nint main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nBIGNUM *rand;\\r\\nint num=256;\\r\\nif (argc >= 2)\\r\\n{\\r\\nnum=atoi(argv[1]);\\r\\nif (num == 0) num=256;\\r\\n}\\r\\nfprintf(stderr,\"generate a strong prime\\n\");\\r\\nrand=BN_generate_prime(NULL,num,1,NULL,NULL,callback,NULL);\\r\\nfprintf(stderr,\"\\n\");\\r\\nBN_print_fp(stdout,rand);\\r\\nfprintf(stdout,\"\\n\");\\r\\nBN_free(rand);\\r\\nexit(0);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_zlib_c", "target": 0, "func": "static int zlib_compress_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nunsigned long l;\\r\\nint i;\\r\\nint clear=1;\\r\\nif (ilen > 128)\\r\\n{\\r\\nout[0]=1;\\r\\nl=olen-1;\\r\\ni=compress(&(out[1]),&l,in,(unsigned long)ilen);\\r\\nif (i != Z_OK)\\r\\nreturn(-1);\\r\\nif (ilen > l)\\r\\n{\\r\\nclear=0;\\r\\nl++;\\r\\n}\\r\\n}\\r\\nif (clear)\\r\\n{\\r\\nout[0]=0;\\r\\nmemcpy(&(out[1]),in,ilen);\\r\\nl=ilen+1;\\r\\n}\\r\\nfprintf(stderr,\"compress(%4d)->%4d %s\\n\",ilen,(int)l,(clear)?\"clear\":\"zlib\");\\r\\nreturn((int)l);\\r\\n}\\r\\nstatic int zlib_expand_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in, unsigned int ilen)\\r\\n{\\r\\nunsigned long l;\\r\\nint i;\\r\\nif (in[0])\\r\\n{\\r\\nl=olen;\\r\\ni=zz_uncompress(out,&l,&(in[1]),(unsigned long)ilen-1);\\r\\nif (i != Z_OK)\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(out,&(in[1]),ilen-1);\\r\\nl=ilen-1;\\r\\n}\\r\\nfprintf(stderr,\"expand (%4d)->%4d %s\\n\",ilen,(int)l,in[0]?\"zlib\":\"clear\");\\r\\nreturn((int)l);\\r\\n}\\r\\nstatic int zz_uncompress (Bytef *dest, uLongf *destLen, const Bytef *source,\\r\\nuLong sourceLen)\\r\\n{\\r\\nz_stream stream;\\r\\nint err;\\r\\nstream.next_in = (Bytef*)source;\\r\\nstream.avail_in = (uInt)sourceLen;\\r\\nif ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;\\r\\nstream.next_out = dest;\\r\\nstream.avail_out = (uInt)*destLen;\\r\\nif ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;\\r\\nstream.zalloc = (alloc_func)0;\\r\\nstream.zfree = (free_func)0;\\r\\nerr = inflateInit(&stream);\\r\\nif (err != Z_OK) return err;\\r\\nerr = inflate(&stream, Z_FINISH);\\r\\nif (err != Z_STREAM_END) {\\r\\ninflateEnd(&stream);\\r\\nreturn err;\\r\\n}\\r\\n*destLen = stream.total_out;\\r\\nerr = inflateEnd(&stream);\\r\\nreturn err;\\r\\n}\\r\\nCOMP_METHOD *COMP_zlib(void)\\r\\n{\\r\\nreturn(&zlib_method);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bfspeed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nBF_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nBF_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nBF_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nBF_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing BF_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing BF_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\nBF_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing BF_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing BF_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nBF_LONG data[2];\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\nBF_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing BF_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing BF_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nBF_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),BF_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld BF_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"Blowfish set_key per sec = %12.3f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"Blowfish raw ecb bytes per sec = %12.3f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"Blowfish cbc bytes per sec = %12.3f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_enc_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nX509 *x509;\\r\\nPKCS7 *p7;\\r\\nBIO *in;\\r\\nBIO *data,*p7bio;\\r\\nchar buf[1024*4];\\r\\nint i;\\r\\nint nodetach=1;\\r\\nchar *keyfile = NULL;\\r\\nconst EVP_CIPHER *cipher=NULL;\\r\\nSTACK_OF(X509) *recips=NULL;\\r\\nSSLeay_add_all_algorithms();\\r\\ndata=BIO_new(BIO_s_file());\\r\\nwhile(argc > 1)\\r\\n{\\r\\nif (strcmp(argv[1],\"-nd\") == 0)\\r\\n{\\r\\nnodetach=1;\\r\\nargv++; argc--;\\r\\n}\\r\\nelse if ((strcmp(argv[1],\"-c\") == 0) && (argc >= 2)) {\\r\\nif(!(cipher = EVP_get_cipherbyname(argv[2]))) {\\r\\nfprintf(stderr, \"Unknown cipher %s\\n\", argv[2]);\\r\\ngoto err;\\r\\n}\\r\\nargc-=2;\\r\\nargv+=2;\\r\\n} else if ((strcmp(argv[1],\"-k\") == 0) && (argc >= 2)) {\\r\\nkeyfile = argv[2];\\r\\nargc-=2;\\r\\nargv+=2;\\r\\nif (!(in=BIO_new_file(keyfile,\"r\"))) goto err;\\r\\nif (!(x509=PEM_read_bio_X509(in,NULL,NULL))) goto err;\\r\\nif(!recips) recips = sk_X509_new_null();\\r\\nsk_X509_push(recips, x509);\\r\\nBIO_free(in);\\r\\n} else break;\\r\\n}\\r\\nif(!recips) {\\r\\nfprintf(stderr, \"No recipients\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[1])) goto err;\\r\\np7=PKCS7_new();\\r\\n#if 0\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_free(in);\\r\\nPKCS7_set_type(p7,NID_pkcs7_signedAndEnveloped);\\r\\nif (PKCS7_add_signature(p7,x509,pkey,EVP_sha1()) == NULL) goto err;\\r\\nPKCS7_add_certificate(p7,x509);\\r\\n#else\\r\\nPKCS7_set_type(p7,NID_pkcs7_enveloped);\\r\\n#endif\\r\\nif(!cipher) cipher = EVP_des_ede3_cbc();\\r\\nif (!PKCS7_set_cipher(p7,cipher)) goto err;\\r\\nfor(i = 0; i < sk_X509_num(recips); i++) {\\r\\nif (!PKCS7_add_recipient(p7,sk_X509_value(recips, i))) goto err;\\r\\n}\\r\\nsk_X509_pop_free(recips, X509_free);\\r\\nif ((p7bio=PKCS7_dataInit(p7,NULL)) == NULL) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(data,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nBIO_write(p7bio,buf,i);\\r\\n}\\r\\nBIO_flush(p7bio);\\r\\nif (!PKCS7_dataFinal(p7,p7bio)) goto err;\\r\\nBIO_free(p7bio);\\r\\nPEM_write_PKCS7(stdout,p7);\\r\\nPKCS7_free(p7);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_by_dir_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void)\\r\\n{\\r\\nreturn(&x509_dir_lookup);\\r\\n}\\r\\nstatic int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\\r\\nchar **retp)\\r\\n{\\r\\nint ret=0;\\r\\nBY_DIR *ld;\\r\\nchar *dir;\\r\\nld=(BY_DIR *)ctx->method_data;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase X509_L_ADD_DIR:\\r\\nif (argl == X509_FILETYPE_DEFAULT)\\r\\n{\\r\\nret=add_cert_dir(ld,X509_get_default_cert_dir(),\\r\\nX509_FILETYPE_PEM);\\r\\nif (!ret)\\r\\n{\\r\\nX509err(X509_F_DIR_CTRL,X509_R_LOADING_CERT_DIR);\\r\\n}\\r\\nelse\\r\\n{\\r\\ndir=(char *)Getenv(X509_get_default_cert_dir_env());\\r\\nret=add_cert_dir(ld,dir,X509_FILETYPE_PEM);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=add_cert_dir(ld,argp,(int)argl);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int new_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\nif ((a=(BY_DIR *)Malloc(sizeof(BY_DIR))) == NULL)\\r\\nreturn(0);\\r\\nif ((a->buffer=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nFree(a);\\r\\nreturn(0);\\r\\n}\\r\\na->num_dirs=0;\\r\\na->dirs=NULL;\\r\\na->dirs_type=NULL;\\r\\na->num_dirs_alloced=0;\\r\\nlu->method_data=(char *)a;\\r\\nreturn(1);\\r\\n}\\r\\nstatic void free_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\nint i;\\r\\na=(BY_DIR *)lu->method_data;\\r\\nfor (i=0; i<a->num_dirs; i++)\\r\\nif (a->dirs[i] != NULL) Free(a->dirs[i]);\\r\\nif (a->dirs != NULL) Free(a->dirs);\\r\\nif (a->dirs_type != NULL) Free(a->dirs_type);\\r\\nif (a->buffer != NULL) BUF_MEM_free(a->buffer);\\r\\nFree(a);\\r\\n}\\r\\nstatic int add_cert_dir(BY_DIR *ctx, const char *dir, int type)\\r\\n{\\r\\nint j,len;\\r\\nint *ip;\\r\\nconst char *s,*ss,*p;\\r\\nchar **pp;\\r\\nif (dir == NULL || !*dir)\\r\\n{\\r\\nX509err(X509_F_ADD_CERT_DIR,X509_R_INVALID_DIRECTORY);\\r\\nreturn 0;\\r\\n}\\r\\ns=dir;\\r\\np=s;\\r\\nfor (;;)\\r\\n{\\r\\nif ((*p == LIST_SEPARATOR_CHAR) || (*p == '\\0'))\\r\\n{\\r\\nss=s;\\r\\ns=p+1;\\r\\nlen=(int)(p-ss);\\r\\nif (len == 0) continue;\\r\\nfor (j=0; j<ctx->num_dirs; j++)\\r\\nif (strncmp(ctx->dirs[j],ss,(unsigned int)len) == 0)\\r\\ncontinue;\\r\\nif (ctx->num_dirs_alloced < (ctx->num_dirs+1))\\r\\n{\\r\\nctx->num_dirs_alloced+=10;\\r\\npp=(char **)Malloc(ctx->num_dirs_alloced*\\r\\nsizeof(char *));\\r\\nip=(int *)Malloc(ctx->num_dirs_alloced*\\r\\nsizeof(int));\\r\\nif ((pp == NULL) || (ip == NULL))\\r\\n{\\r\\nX509err(X509_F_ADD_CERT_DIR,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nmemcpy(pp,ctx->dirs,(ctx->num_dirs_alloced-10)*\\r\\nsizeof(char *));\\r\\nmemcpy(ip,ctx->dirs_type,(ctx->num_dirs_alloced-10)*\\r\\nsizeof(int));\\r\\nif (ctx->dirs != NULL)\\r\\nFree((char *)ctx->dirs);\\r\\nif (ctx->dirs_type != NULL)\\r\\nFree((char *)ctx->dirs_type);\\r\\nctx->dirs=pp;\\r\\nctx->dirs_type=ip;\\r\\n}\\r\\nctx->dirs_type[ctx->num_dirs]=type;\\r\\nctx->dirs[ctx->num_dirs]=(char *)Malloc((unsigned int)len+1);\\r\\nif (ctx->dirs[ctx->num_dirs] == NULL) return(0);\\r\\nstrncpy(ctx->dirs[ctx->num_dirs],ss,(unsigned int)len);\\r\\nctx->dirs[ctx->num_dirs][len]='\\0';\\r\\nctx->num_dirs++;\\r\\n}\\r\\nif (*p == '\\0') break;\\r\\np++;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_cert_by_subject(X509_LOOKUP *xl, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nBY_DIR *ctx;\\r\\nunion {\\r\\nstruct {\\r\\nX509 st_x509;\\r\\nX509_CINF st_x509_cinf;\\r\\n} x509;\\r\\nstruct {\\r\\nX509_CRL st_crl;\\r\\nX509_CRL_INFO st_crl_info;\\r\\n} crl;\\r\\n} data;\\r\\nint ok=0;\\r\\nint i,j,k;\\r\\nunsigned long h;\\r\\nBUF_MEM *b=NULL;\\r\\nstruct stat st;\\r\\nX509_OBJECT stmp,*tmp;\\r\\nconst char *postfix=\"\";\\r\\nif (name == NULL) return(0);\\r\\nstmp.type=type;\\r\\nif (type == X509_LU_X509)\\r\\n{\\r\\ndata.x509.st_x509.cert_info= &data.x509.st_x509_cinf;\\r\\ndata.x509.st_x509_cinf.subject=name;\\r\\nstmp.data.x509= &data.x509.st_x509;\\r\\npostfix=\"\";\\r\\n}\\r\\nelse if (type == X509_LU_CRL)\\r\\n{\\r\\ndata.crl.st_crl.crl= &data.crl.st_crl_info;\\r\\ndata.crl.st_crl_info.issuer=name;\\r\\nstmp.data.crl= &data.crl.st_crl;\\r\\npostfix=\"r\";\\r\\n}\\r\\nelse\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,X509_R_WRONG_LOOKUP_TYPE);\\r\\ngoto finish;\\r\\n}\\r\\nif ((b=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_BUF_LIB);\\r\\ngoto finish;\\r\\n}\\r\\nctx=(BY_DIR *)xl->method_data;\\r\\nh=X509_NAME_hash(name);\\r\\nfor (i=0; i<ctx->num_dirs; i++)\\r\\n{\\r\\nj=strlen(ctx->dirs[i])+1+8+6+1+1;\\r\\nif (!BUF_MEM_grow(b,j))\\r\\n{\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_MALLOC_FAILURE);\\r\\ngoto finish;\\r\\n}\\r\\nk=0;\\r\\nfor (;;)\\r\\n{\\r\\nsprintf(b->data,\"%s/%08lx.%s%d\",ctx->dirs[i],h,\\r\\npostfix,k);\\r\\nk++;\\r\\nif (stat(b->data,&st) < 0)\\r\\nbreak;\\r\\nif (type == X509_LU_X509)\\r\\n{\\r\\nif ((X509_load_cert_file(xl,b->data,\\r\\nctx->dirs_type[i])) == 0)\\r\\nbreak;\\r\\n}\\r\\nelse if (type == X509_LU_CRL)\\r\\n{\\r\\nif ((X509_load_crl_file(xl,b->data,\\r\\nctx->dirs_type[i])) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_X509_STORE);\\r\\ntmp=(X509_OBJECT *)lh_retrieve(xl->store_ctx->certs,\\r\\n(char *)&stmp);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nif (tmp != NULL)\\r\\n{\\r\\nok=1;\\r\\nret->type=tmp->type;\\r\\nmemcpy(&ret->data,&tmp->data,sizeof(ret->data));\\r\\ngoto finish;\\r\\n}\\r\\n}\\r\\nfinish:\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_c_c", "target": 0, "func": "EVP_CIPHER *EVP_cast5_cbc(void)\\r\\n{\\r\\nreturn(&cast5_cbc_cipher);\\r\\n}\\r\\nstatic void cast_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nCAST_set_key(&(ctx->c.cast_ks),EVP_CAST5_KEY_SIZE,key);\\r\\n}\\r\\nstatic void cast_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nCAST_cbc_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.cast_ks),&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_cfb64_c", "target": 0, "func": "void BF_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nBF_KEY *schedule, unsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister BF_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t1_srvr_c", "target": 0, "func": "static SSL_METHOD *tls1_get_server_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_server_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_server_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_server_data.ssl_accept=ssl3_accept;\\r\\nTLSv1_server_data.get_ssl_method=tls1_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&TLSv1_server_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509name_c", "target": 0, "func": "int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL) return(-1);\\r\\nreturn(X509_NAME_get_text_by_OBJ(name,obj,buf,len));\\r\\n}\\r\\nint X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,\\r\\nint len)\\r\\n{\\r\\nint i;\\r\\nASN1_STRING *data;\\r\\ni=X509_NAME_get_index_by_OBJ(name,obj,-1);\\r\\nif (i < 0) return(-1);\\r\\ndata=X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name,i));\\r\\ni=(data->length > (len-1))?(len-1):data->length;\\r\\nif (buf == NULL) return(data->length);\\r\\nmemcpy(buf,data->data,i);\\r\\nbuf[i]='\\0';\\r\\nreturn(i);\\r\\n}\\r\\nint X509_NAME_entry_count(X509_NAME *name)\\r\\n{\\r\\nif (name == NULL) return(0);\\r\\nreturn(sk_X509_NAME_ENTRY_num(name->entries));\\r\\n}\\r\\nint X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL) return(-2);\\r\\nreturn(X509_NAME_get_index_by_OBJ(name,obj,lastpos));\\r\\n}\\r\\nint X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nint n;\\r\\nX509_NAME_ENTRY *ne;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL) return(-1);\\r\\nif (lastpos < 0)\\r\\nlastpos= -1;\\r\\nsk=name->entries;\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (lastpos++; lastpos < n; lastpos++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(sk,lastpos);\\r\\nif (OBJ_cmp(ne->object,obj) == 0)\\r\\nreturn(lastpos);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nif(name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(sk_X509_NAME_ENTRY_value(name->entries,loc));\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nint i,n,set_prev,set_next;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn(NULL);\\r\\nsk=name->entries;\\r\\nret=sk_X509_NAME_ENTRY_delete(sk,loc);\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nname->modified=1;\\r\\nif (loc == n) return(ret);\\r\\nif (loc != 0)\\r\\nset_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;\\r\\nelse\\r\\nset_prev=ret->set-1;\\r\\nset_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;\\r\\nif (set_prev+1 < set_next)\\r\\nfor (i=loc; i<n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk,i)->set--;\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *new_name=NULL;\\r\\nint n,i,inc;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL) return(0);\\r\\nsk=name->entries;\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nif (loc > n) loc=n;\\r\\nelse if (loc < 0) loc=n;\\r\\nname->modified=1;\\r\\nif (set == -1)\\r\\n{\\r\\nif (loc == 0)\\r\\n{\\r\\nset=0;\\r\\ninc=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set;\\r\\ninc=0;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (loc >= n)\\r\\n{\\r\\nif (loc != 0)\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc-1)->set+1;\\r\\nelse\\r\\nset=0;\\r\\n}\\r\\nelse\\r\\nset=sk_X509_NAME_ENTRY_value(sk,loc)->set;\\r\\ninc=(set == 0)?1:0;\\r\\n}\\r\\nif ((new_name=X509_NAME_ENTRY_dup(ne)) == NULL)\\r\\ngoto err;\\r\\nnew_name->set=set;\\r\\nif (!sk_X509_NAME_ENTRY_insert(sk,new_name,loc))\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ADD_ENTRY,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (inc)\\r\\n{\\r\\nn=sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (i=loc+1; i<n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk,i-1)->set+=1;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nif (new_name != NULL)\\r\\nX509_NAME_ENTRY_free(new_name);\\r\\nreturn(0);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,\\r\\nint type, unsigned char *bytes, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj=OBJ_nid2obj(nid);\\r\\nif (obj == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_NID,X509_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(X509_NAME_ENTRY_create_by_OBJ(ne,obj,type,bytes,len));\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,\\r\\nASN1_OBJECT *obj, int type, unsigned char *bytes, int len)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nif ((ne == NULL) || (*ne == NULL))\\r\\n{\\r\\nif ((ret=X509_NAME_ENTRY_new()) == NULL)\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nret= *ne;\\r\\nif (!X509_NAME_ENTRY_set_object(ret,obj))\\r\\ngoto err;\\r\\nif (!X509_NAME_ENTRY_set_data(ret,type,bytes,len))\\r\\ngoto err;\\r\\nif ((ne != NULL) && (*ne == NULL)) *ne=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ne == NULL) || (ret != *ne))\\r\\nX509_NAME_ENTRY_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj)\\r\\n{\\r\\nif ((ne == NULL) || (obj == NULL))\\r\\n{\\r\\nX509err(X509_F_X509_NAME_ENTRY_SET_OBJECT,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nASN1_OBJECT_free(ne->object);\\r\\nne->object=OBJ_dup(obj);\\r\\nreturn((ne->object == NULL)?0:1);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,\\r\\nunsigned char *bytes, int len)\\r\\n{\\r\\nint i;\\r\\nif ((ne == NULL) || ((bytes == NULL) && (len != 0))) return(0);\\r\\nif (len < 0) len=strlen((char *)bytes);\\r\\ni=ASN1_STRING_set(ne->value,bytes,len);\\r\\nif (!i) return(0);\\r\\nif (type != V_ASN1_UNDEF)\\r\\n{\\r\\nif (type == V_ASN1_APP_CHOOSE)\\r\\nne->value->type=ASN1_PRINTABLE_type(bytes,len);\\r\\nelse\\r\\nne->value->type=type;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL) return(NULL);\\r\\nreturn(ne->object);\\r\\n}\\r\\nASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL) return(NULL);\\r\\nreturn(ne->value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s_socket_c", "target": 0, "func": "static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,\\r\\nLPARAM lParam)\\r\\n{\\r\\nif (hwnd == topWnd)\\r\\n{\\r\\nswitch(message)\\r\\n{\\r\\ncase WM_DESTROY:\\r\\ncase WM_CLOSE:\\r\\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopWndProc);\\r\\nsock_cleanup();\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn CallWindowProc(lpTopWndProc,hwnd,message,wParam,lParam);\\r\\n}\\r\\nstatic BOOL CALLBACK enumproc(HWND hwnd,LPARAM lParam)\\r\\n{\\r\\ntopWnd=hwnd;\\r\\nreturn(FALSE);\\r\\n}\\r\\nvoid sock_cleanup(void)\\r\\n{\\r\\n#ifdef WINDOWS\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\nWSACancelBlockingCall();\\r\\nWSACleanup();\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint sock_init(void)\\r\\n{\\r\\n#ifdef WINDOWS\\r\\nif (!wsa_init_done)\\r\\n{\\r\\nint err;\\r\\n#ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))sock_cleanup);\\r\\n#endif\\r\\nwsa_init_done=1;\\r\\nmemset(&wsa_state,0,sizeof(wsa_state));\\r\\nif (WSAStartup(0x0101,&wsa_state)!=0)\\r\\n{\\r\\nerr=WSAGetLastError();\\r\\nBIO_printf(bio_err,\"unable to start WINSOCK, error code=%d\\n\",err);\\r\\nreturn(0);\\r\\n}\\r\\n#ifdef WIN16\\r\\nEnumTaskWindows(GetCurrentTask(),enumproc,0L);\\r\\nlpTopWndProc=(FARPROC)GetWindowLong(topWnd,GWL_WNDPROC);\\r\\nlpTopHookProc=MakeProcInstance((FARPROC)topHookProc,_hInstance);\\r\\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopHookProc);\\r\\n#endif\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nint init_client(int *sock, char *host, int port)\\r\\n{\\r\\nunsigned char ip[4];\\r\\nshort p=0;\\r\\nif (!host_ip(host,&(ip[0])))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nif (p != 0) port=p;\\r\\nreturn(init_client_ip(sock,ip,port));\\r\\n}\\r\\nint init_client_ip(int *sock, unsigned char ip[4], int port)\\r\\n{\\r\\nunsigned long addr;\\r\\nstruct sockaddr_in them;\\r\\nint s,i;\\r\\nif (!sock_init()) return(0);\\r\\nmemset((char *)&them,0,sizeof(them));\\r\\nthem.sin_family=AF_INET;\\r\\nthem.sin_port=htons((unsigned short)port);\\r\\naddr=(unsigned long)\\r\\n((unsigned long)ip[0]<<24L)|\\r\\n((unsigned long)ip[1]<<16L)|\\r\\n((unsigned long)ip[2]<< 8L)|\\r\\n((unsigned long)ip[3]);\\r\\nthem.sin_addr.s_addr=htonl(addr);\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET) { perror(\"socket\"); return(0); }\\r\\ni=0;\\r\\ni=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\\r\\nif (i < 0) { perror(\"keepalive\"); return(0); }\\r\\nif (connect(s,(struct sockaddr *)&them,sizeof(them)) == -1)\\r\\n{ close(s); perror(\"connect\"); return(0); }\\r\\n*sock=s;\\r\\nreturn(1);\\r\\n}\\r\\nint nbio_sock_error(int sock)\\r\\n{\\r\\nint j,i;\\r\\nint size;\\r\\nsize=sizeof(int);\\r\\ni=getsockopt(sock,SOL_SOCKET,SO_ERROR,(char *)&j,(void *)&size);\\r\\nif (i < 0)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(j);\\r\\n}\\r\\nint nbio_init_client_ip(int *sock, unsigned char ip[4], int port)\\r\\n{\\r\\nunsigned long addr;\\r\\nstruct sockaddr_in them;\\r\\nint s,i;\\r\\nif (!sock_init()) return(0);\\r\\nmemset((char *)&them,0,sizeof(them));\\r\\nthem.sin_family=AF_INET;\\r\\nthem.sin_port=htons((unsigned short)port);\\r\\naddr= (unsigned long)\\r\\n((unsigned long)ip[0]<<24L)|\\r\\n((unsigned long)ip[1]<<16L)|\\r\\n((unsigned long)ip[2]<< 8L)|\\r\\n((unsigned long)ip[3]);\\r\\nthem.sin_addr.s_addr=htonl(addr);\\r\\nif (*sock <= 0)\\r\\n{\\r\\n#ifdef FIONBIO\\r\\nunsigned long l=1;\\r\\n#endif\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET) { perror(\"socket\"); return(0); }\\r\\ni=0;\\r\\ni=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\\r\\nif (i < 0) { perror(\"keepalive\"); return(0); }\\r\\n*sock=s;\\r\\n#ifdef FIONBIO\\r\\nBIO_socket_ioctl(s,FIONBIO,&l);\\r\\n#endif\\r\\n}\\r\\nelse\\r\\ns= *sock;\\r\\ni=connect(s,(struct sockaddr *)&them,sizeof(them));\\r\\nif (i == INVALID_SOCKET)\\r\\n{\\r\\nif (BIO_sock_should_retry(i))\\r\\nreturn(-1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint do_server(int port, int *ret, int (*cb)(), char *context)\\r\\n{\\r\\nint sock;\\r\\nchar *name;\\r\\nint accept_socket;\\r\\nint i;\\r\\nif (!init_server(&accept_socket,port)) return(0);\\r\\nif (ret != NULL)\\r\\n{\\r\\n*ret=accept_socket;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nif (do_accept(accept_socket,&sock,&name) == 0)\\r\\n{\\r\\nSHUTDOWN(accept_socket);\\r\\nreturn(0);\\r\\n}\\r\\ni=(*cb)(name,sock, context);\\r\\nif (name != NULL) Free(name);\\r\\nSHUTDOWN2(sock);\\r\\nif (i < 0)\\r\\n{\\r\\nSHUTDOWN2(accept_socket);\\r\\nreturn(i);\\r\\n}\\r\\n}\\r\\n}\\r\\nint init_server_long(int *sock, int port, char *ip)\\r\\n{\\r\\nint ret=0;\\r\\nstruct sockaddr_in server;\\r\\nint s= -1,i;\\r\\nif (!sock_init()) return(0);\\r\\nmemset((char *)&server,0,sizeof(server));\\r\\nserver.sin_family=AF_INET;\\r\\nserver.sin_port=htons((unsigned short)port);\\r\\nif (ip == NULL)\\r\\nserver.sin_addr.s_addr=INADDR_ANY;\\r\\nelse\\r\\n#ifndef BIT_FIELD_LIMITS\\r\\nmemcpy(&server.sin_addr.s_addr,ip,4);\\r\\n#else\\r\\nmemcpy(&server.sin_addr,ip,4);\\r\\n#endif\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET) goto err;\\r\\n#if defined SOL_SOCKET && defined SO_REUSEADDR\\r\\n{\\r\\nint j = 1;\\r\\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR,\\r\\n(void *) &j, sizeof j);\\r\\n}\\r\\n#endif\\r\\nif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\\r\\n{\\r\\n#ifndef WINDOWS\\r\\nperror(\"bind\");\\r\\n#endif\\r\\ngoto err;\\r\\n}\\r\\nif (listen(s,128) == -1) goto err;\\r\\ni=0;\\r\\n*sock=s;\\r\\nret=1;\\r\\nerr:\\r\\nif ((ret == 0) && (s != -1))\\r\\n{\\r\\nSHUTDOWN(s);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint init_server(int *sock, int port)\\r\\n{\\r\\nreturn(init_server_long(sock, port, NULL));\\r\\n}\\r\\nint do_accept(int acc_sock, int *sock, char **host)\\r\\n{\\r\\nint ret,i;\\r\\nstruct hostent *h1,*h2;\\r\\nstatic struct sockaddr_in from;\\r\\nint len;\\r\\nif (!sock_init()) return(0);\\r\\n#ifndef WINDOWS\\r\\nredoit:\\r\\n#endif\\r\\nmemset((char *)&from,0,sizeof(from));\\r\\nlen=sizeof(from);\\r\\nret=accept(acc_sock,(struct sockaddr *)&from,(void *)&len);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\n#ifdef WINDOWS\\r\\ni=WSAGetLastError();\\r\\nBIO_printf(bio_err,\"accept error %d\\n\",i);\\r\\n#else\\r\\nif (errno == EINTR)\\r\\n{\\r\\ngoto redoit;\\r\\n}\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"accept\");\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nif (host == NULL) goto end;\\r\\n#ifndef BIT_FIELD_LIMITS\\r\\nh1=gethostbyaddr((char *)&from.sin_addr.s_addr,\\r\\nsizeof(from.sin_addr.s_addr),AF_INET);\\r\\n#else\\r\\nh1=gethostbyaddr((char *)&from.sin_addr,\\r\\nsizeof(struct in_addr),AF_INET);\\r\\n#endif\\r\\nif (h1 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"bad gethostbyaddr\\n\");\\r\\n*host=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((*host=(char *)Malloc(strlen(h1->h_name)+1)) == NULL)\\r\\n{\\r\\nperror(\"Malloc\");\\r\\nreturn(0);\\r\\n}\\r\\nstrcpy(*host,h1->h_name);\\r\\nh2=GetHostByName(*host);\\r\\nif (h2 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname failure\\n\");\\r\\nreturn(0);\\r\\n}\\r\\ni=0;\\r\\nif (h2->h_addrtype != AF_INET)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname addr is not AF_INET\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nend:\\r\\n*sock=ret;\\r\\nreturn(1);\\r\\n}\\r\\nint extract_host_port(char *str, char **host_ptr, unsigned char *ip,\\r\\nshort *port_ptr)\\r\\n{\\r\\nchar *h,*p;\\r\\nh=str;\\r\\np=strchr(str,':');\\r\\nif (p == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no port defined\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n*(p++)='\\0';\\r\\nif ((ip != NULL) && !host_ip(str,ip))\\r\\ngoto err;\\r\\nif (host_ptr != NULL) *host_ptr=h;\\r\\nif (!extract_port(p,port_ptr))\\r\\ngoto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint host_ip(char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int in[4];\\r\\nint i;\\r\\nif (sscanf(str,\"%u.%u.%u.%u\",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)\\r\\n{\\r\\nfor (i=0; i<4; i++)\\r\\nif (in[i] > 255)\\r\\n{\\r\\nBIO_printf(bio_err,\"invalid IP address\\n\");\\r\\ngoto err;\\r\\n}\\r\\nip[0]=in[0];\\r\\nip[1]=in[1];\\r\\nip[2]=in[2];\\r\\nip[3]=in[3];\\r\\n}\\r\\nelse\\r\\n{\\r\\nstruct hostent *he;\\r\\nif (!sock_init()) return(0);\\r\\nhe=GetHostByName(str);\\r\\nif (he == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET)\\r\\n{\\r\\nBIO_printf(bio_err,\"gethostbyname addr is not AF_INET\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nip[0]=he->h_addr_list[0][0];\\r\\nip[1]=he->h_addr_list[0][1];\\r\\nip[2]=he->h_addr_list[0][2];\\r\\nip[3]=he->h_addr_list[0][3];\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint extract_port(char *str, short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\ni=atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr=(unsigned short)i;\\r\\nelse\\r\\n{\\r\\ns=getservbyname(str,\"tcp\");\\r\\nif (s == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"getservbyname failure for %s\\n\",str);\\r\\nreturn(0);\\r\\n}\\r\\n*port_ptr=ntohs((unsigned short)s->s_port);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic struct hostent *GetHostByName(char *name)\\r\\n{\\r\\nstruct hostent *ret;\\r\\nint i,lowi=0;\\r\\nunsigned long low= (unsigned long)-1;\\r\\nfor (i=0; i<GHBN_NUM; i++)\\r\\n{\\r\\nif (low > ghbn_cache[i].order)\\r\\n{\\r\\nlow=ghbn_cache[i].order;\\r\\nlowi=i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0)\\r\\n{\\r\\nif (strncmp(name,ghbn_cache[i].name,128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i == GHBN_NUM)\\r\\n{\\r\\nghbn_miss++;\\r\\nret=gethostbyname(name);\\r\\nif (ret == NULL) return(NULL);\\r\\nstrncpy(ghbn_cache[lowi].name,name,128);\\r\\nmemcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));\\r\\nghbn_cache[lowi].order=ghbn_miss+ghbn_hits;\\r\\nreturn(ret);\\r\\n}\\r\\nelse\\r\\n{\\r\\nghbn_hits++;\\r\\nret= &(ghbn_cache[i].ent);\\r\\nghbn_cache[i].order=ghbn_miss+ghbn_hits;\\r\\nreturn(ret);\\r\\n}\\r\\n}\\r\\nint spawn(int argc, char **argv, int *in, int *out)\\r\\n{\\r\\nint pid;\\r\\n#define CHILD_READ p1[0]\\r\\n#define CHILD_WRITE p2[1]\\r\\n#define PARENT_READ p2[0]\\r\\n#define PARENT_WRITE p1[1]\\r\\nint p1[2],p2[2];\\r\\nif ((pipe(p1) < 0) || (pipe(p2) < 0)) return(-1);\\r\\n#ifdef VMS\\r\\nif ((pid=vfork()) == 0)\\r\\n#else\\r\\nif ((pid=fork()) == 0)\\r\\n#endif\\r\\n{\\r\\nif (dup2(CHILD_WRITE,fileno(stdout)) < 0)\\r\\nperror(\"dup2\");\\r\\nif (dup2(CHILD_WRITE,fileno(stderr)) < 0)\\r\\nperror(\"dup2\");\\r\\nif (dup2(CHILD_READ,fileno(stdin)) < 0)\\r\\nperror(\"dup2\");\\r\\nclose(CHILD_READ);\\r\\nclose(CHILD_WRITE);\\r\\nclose(PARENT_READ);\\r\\nclose(PARENT_WRITE);\\r\\nexecvp(argv[0],argv);\\r\\nperror(\"child\");\\r\\nexit(1);\\r\\n}\\r\\n*in= PARENT_READ;\\r\\n*out=PARENT_WRITE;\\r\\nclose(CHILD_READ);\\r\\nclose(CHILD_WRITE);\\r\\nreturn(pid);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_enc_c", "target": 0, "func": "void CAST_encrypt(CAST_LONG *data, CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l,r,*k,t;\\r\\nk= &(key->data[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nE_CAST( 0,k,l,r,+,^,-);\\r\\nE_CAST( 1,k,r,l,^,-,+);\\r\\nE_CAST( 2,k,l,r,-,+,^);\\r\\nE_CAST( 3,k,r,l,+,^,-);\\r\\nE_CAST( 4,k,l,r,^,-,+);\\r\\nE_CAST( 5,k,r,l,-,+,^);\\r\\nE_CAST( 6,k,l,r,+,^,-);\\r\\nE_CAST( 7,k,r,l,^,-,+);\\r\\nE_CAST( 8,k,l,r,-,+,^);\\r\\nE_CAST( 9,k,r,l,+,^,-);\\r\\nE_CAST(10,k,l,r,^,-,+);\\r\\nE_CAST(11,k,r,l,-,+,^);\\r\\nif(!key->short_key)\\r\\n{\\r\\nE_CAST(12,k,l,r,+,^,-);\\r\\nE_CAST(13,k,r,l,^,-,+);\\r\\nE_CAST(14,k,l,r,-,+,^);\\r\\nE_CAST(15,k,r,l,+,^,-);\\r\\n}\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n}\\r\\nvoid CAST_decrypt(CAST_LONG *data, CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l,r,*k,t;\\r\\nk= &(key->data[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nif(!key->short_key)\\r\\n{\\r\\nE_CAST(15,k,l,r,+,^,-);\\r\\nE_CAST(14,k,r,l,-,+,^);\\r\\nE_CAST(13,k,l,r,^,-,+);\\r\\nE_CAST(12,k,r,l,+,^,-);\\r\\n}\\r\\nE_CAST(11,k,l,r,-,+,^);\\r\\nE_CAST(10,k,r,l,^,-,+);\\r\\nE_CAST( 9,k,l,r,+,^,-);\\r\\nE_CAST( 8,k,r,l,-,+,^);\\r\\nE_CAST( 7,k,l,r,^,-,+);\\r\\nE_CAST( 6,k,r,l,+,^,-);\\r\\nE_CAST( 5,k,l,r,-,+,^);\\r\\nE_CAST( 4,k,r,l,^,-,+);\\r\\nE_CAST( 3,k,l,r,+,^,-);\\r\\nE_CAST( 2,k,r,l,-,+,^);\\r\\nE_CAST( 1,k,l,r,^,-,+);\\r\\nE_CAST( 0,k,r,l,+,^,-);\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n}\\r\\nvoid CAST_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nCAST_KEY *ks, unsigned char *iv, int enc)\\r\\n{\\r\\nregister CAST_LONG tin0,tin1;\\r\\nregister CAST_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nCAST_LONG tin[2];\\r\\nif (enc)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nCAST_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_dsap_c", "target": 0, "func": "int i2d_DSAparams(DSA *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[3];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot=0,len,max=0;\\r\\nint t,ret= -1;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nnum[0]=a->p;\\r\\nnum[1]=a->q;\\r\\nnum[2]=a->g;\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (num[i] == NULL) continue;\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(t);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_DSAPARAMS,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (num[i] == NULL) continue;\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\nret=t;\\r\\nerr:\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_names_c", "target": 0, "func": "int EVP_add_cipher(EVP_CIPHER *c)\\r\\n{\\r\\nint r;\\r\\nr=OBJ_NAME_add(OBJ_nid2sn(c->nid),OBJ_NAME_TYPE_CIPHER_METH,(char *)c);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(c->nid),OBJ_NAME_TYPE_CIPHER_METH,(char *)c);\\r\\nreturn(r);\\r\\n}\\r\\nint EVP_add_digest(EVP_MD *md)\\r\\n{\\r\\nint r;\\r\\nconst char *name;\\r\\nname=OBJ_nid2sn(md->type);\\r\\nr=OBJ_NAME_add(name,OBJ_NAME_TYPE_MD_METH,(char *)md);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(md->type),OBJ_NAME_TYPE_MD_METH,(char *)md);\\r\\nif (r == 0) return(0);\\r\\nif (md->type != md->pkey_type)\\r\\n{\\r\\nr=OBJ_NAME_add(OBJ_nid2sn(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,name);\\r\\nif (r == 0) return(0);\\r\\nr=OBJ_NAME_add(OBJ_nid2ln(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH|OBJ_NAME_ALIAS,name);\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *name)\\r\\n{\\r\\nconst EVP_CIPHER *cp;\\r\\ncp=(const EVP_CIPHER *)OBJ_NAME_get(name,OBJ_NAME_TYPE_CIPHER_METH);\\r\\nreturn(cp);\\r\\n}\\r\\nconst EVP_MD *EVP_get_digestbyname(const char *name)\\r\\n{\\r\\nconst EVP_MD *cp;\\r\\ncp=(const EVP_MD *)OBJ_NAME_get(name,OBJ_NAME_TYPE_MD_METH);\\r\\nreturn(cp);\\r\\n}\\r\\nvoid EVP_cleanup(void)\\r\\n{\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_CIPHER_METH);\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_MD_METH);\\r\\nEVP_PBE_cleanup();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_s_pu_c", "target": 0, "func": "int i2d_DSAPublicKey(DSA *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[4];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot=0,len,max=0,t=0,all,n=1;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nall=a->write_params;\\r\\nnum[0]=a->pub_key;\\r\\nif (all)\\r\\n{\\r\\nnum[1]=a->p;\\r\\nnum[2]=a->q;\\r\\nnum[3]=a->g;\\r\\nn=4;\\r\\n}\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nif (all)\\r\\n{\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(t);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (pp == NULL) return(tot);\\r\\n}\\r\\np= *pp;\\r\\nif (all)\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_DSAPUBLICKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\n*pp=p;\\r\\nif(all) return(t);\\r\\nelse return(tot);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cast_spd_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nCAST_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nCAST_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nCAST_LONG data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nCAST_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing CAST_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing CAST_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\nCAST_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld cast set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing CAST_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing CAST_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nCAST_LONG data[2];\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\nCAST_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld CAST_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing CAST_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing CAST_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nCAST_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),CAST_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld CAST_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"CAST set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"CAST raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"CAST cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ofb(void)\\r\\n{\\r\\nreturn(&d_ofb_cipher);\\r\\n}\\r\\nstatic void des_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\ndes_set_key(deskey,ctx->c.des_ks);\\r\\n}\\r\\nstatic void des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_ofb64_encrypt(in,out,inl,ctx->c.des_ks,\\r\\n(des_cblock *)&(ctx->iv[0]),&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_cfb64_c", "target": 0, "func": "void CAST_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, CAST_KEY *schedule, unsigned char *ivec,\\r\\nint *num, int enc)\\r\\n{\\r\\nregister CAST_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=ivec;\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\niv=ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nn2l(iv,v0); ti[0]=v0;\\r\\nn2l(iv,v1); ti[1]=v1;\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\niv=ivec;\\r\\nt=ti[0]; l2n(t,iv);\\r\\nt=ti[1]; l2n(t,iv);\\r\\niv=ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_sock_c", "target": 0, "func": "BIO_METHOD *BIO_s_socket(void)\\r\\n{\\r\\nreturn(&methods_sockp);\\r\\n}\\r\\nBIO_METHOD *BIO_s_fd(void)\\r\\n{\\r\\nreturn(&methods_fdp);\\r\\n}\\r\\nstatic int sock_gets(BIO *bp, char *buf,int size)\\r\\n{\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_enc_writ_c", "target": 0, "func": "int des_enc_write(int fd, const void *_buf, int len,\\r\\ndes_key_schedule sched, des_cblock *iv)\\r\\n{\\r\\n#ifdef _LIBC\\r\\nextern unsigned long time();\\r\\nextern int write();\\r\\n#endif\\r\\nconst unsigned char *buf=_buf;\\r\\nlong rnum;\\r\\nint i,j,k,outnum;\\r\\nstatic unsigned char *outbuf=NULL;\\r\\nunsigned char shortbuf[8];\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nstatic int start=1;\\r\\nif (outbuf == NULL)\\r\\n{\\r\\noutbuf=Malloc(BSIZE+HDRSIZE);\\r\\nif (outbuf == NULL) return(-1);\\r\\n}\\r\\nif (start)\\r\\n{\\r\\nstart=0;\\r\\n}\\r\\nif (len > MAXWRITE)\\r\\n{\\r\\nj=0;\\r\\nfor (i=0; i<len; i+=k)\\r\\n{\\r\\nk=des_enc_write(fd,&(buf[i]),\\r\\n((len-i) > MAXWRITE)?MAXWRITE:(len-i),sched,iv);\\r\\nif (k < 0)\\r\\nreturn(k);\\r\\nelse\\r\\nj+=k;\\r\\n}\\r\\nreturn(j);\\r\\n}\\r\\np=outbuf;\\r\\nl2n(len,p);\\r\\nif (len < 8)\\r\\n{\\r\\ncp=shortbuf;\\r\\nmemcpy(shortbuf,buf,len);\\r\\nRAND_bytes(shortbuf+len, 8-len);\\r\\nrnum=8;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncp=(unsigned char*)buf;\\r\\nrnum=((len+7)/8*8);\\r\\n}\\r\\nif (des_rw_mode & DES_PCBC_MODE)\\r\\ndes_pcbc_encrypt(cp,&(outbuf[HDRSIZE]),(len<8)?8:len,sched,iv,\\r\\nDES_ENCRYPT);\\r\\nelse\\r\\ndes_cbc_encrypt(cp,&(outbuf[HDRSIZE]),(len<8)?8:len,sched,iv,\\r\\nDES_ENCRYPT);\\r\\noutnum=rnum+HDRSIZE;\\r\\nfor (j=0; j<outnum; j+=i)\\r\\n{\\r\\ni=write(fd,&(outbuf[j]),outnum-j);\\r\\nif (i == -1)\\r\\n{\\r\\nif (errno == EINTR)\\r\\ni=0;\\r\\nelse\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nreturn(len);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p8_pkey_c", "target": 0, "func": "int i2d_PKCS8_PRIV_KEY_INFO (PKCS8_PRIV_KEY_INFO *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len (a->pkeyalg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len (a->pkey, i2d_ASN1_TYPE);\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type (X509_ATTRIBUTE, a->attributes,\\r\\ni2d_X509_ATTRIBUTE, 0);\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put (a->pkeyalg, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put (a->pkey, i2d_ASN1_TYPE);\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type (X509_ATTRIBUTE, a->attributes,\\r\\ni2d_X509_ATTRIBUTE, 0);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKCS8_PRIV_KEY_INFO);\\r\\nM_ASN1_New (ret->version, ASN1_INTEGER_new);\\r\\nM_ASN1_New (ret->pkeyalg, X509_ALGOR_new);\\r\\nM_ASN1_New (ret->pkey, ASN1_TYPE_new);\\r\\nret->attributes = NULL;\\r\\nret->broken = PKCS8_OK;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS8_PRIV_KEY_INFO_NEW);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS8_PRIV_KEY_INFO *,PKCS8_PRIV_KEY_INFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->version, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get (ret->pkeyalg, d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get (ret->pkey, d2i_ASN1_TYPE);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509_ATTRIBUTE, ret->attributes,\\r\\nd2i_X509_ATTRIBUTE,\\r\\nX509_ATTRIBUTE_free, 0);\\r\\nif (ASN1_TYPE_get(ret->pkey) == V_ASN1_SEQUENCE)\\r\\nret->broken = PKCS8_NO_OCTET;\\r\\nM_ASN1_D2I_Finish(a, PKCS8_PRIV_KEY_INFO_free, ASN1_F_D2I_PKCS8_PRIV_KEY_INFO);\\r\\n}\\r\\nvoid PKCS8_PRIV_KEY_INFO_free (PKCS8_PRIV_KEY_INFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free (a->version);\\r\\nX509_ALGOR_free(a->pkeyalg);\\r\\nif (a->pkey->value.octet_string)\\r\\nmemset (a->pkey->value.octet_string->data,\\r\\n0, a->pkey->value.octet_string->length);\\r\\nASN1_TYPE_free (a->pkey);\\r\\nsk_X509_ATTRIBUTE_pop_free (a->attributes, X509_ATTRIBUTE_free);\\r\\nFree (a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_openssl_c", "target": 0, "func": "static void sig_stop(int i)\\r\\n{\\r\\nchar *a=NULL;\\r\\n*a='\\0';\\r\\n}\\r\\nint main(int Argc, char *Argv[])\\r\\n{\\r\\nARGS arg;\\r\\n#define PROG_NAME_SIZE 16\\r\\nchar pname[PROG_NAME_SIZE];\\r\\nFUNCTION f,*fp;\\r\\nMS_STATIC char *prompt,buf[1024],config_name[256];\\r\\nint n,i,ret=0;\\r\\nint argc;\\r\\nchar **argv,*p;\\r\\nLHASH *prog=NULL;\\r\\nlong errline;\\r\\narg.data=NULL;\\r\\narg.count=0;\\r\\napps_startup();\\r\\n#if defined(DEBUG) && !defined(WINDOWS) && !defined(MSDOS)\\r\\n#ifdef SIGBUS\\r\\nsignal(SIGBUS,sig_stop);\\r\\n#endif\\r\\n#ifdef SIGSEGV\\r\\nsignal(SIGSEGV,sig_stop);\\r\\n#endif\\r\\n#endif\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\nERR_load_crypto_strings();\\r\\np=getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np=getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\n{\\r\\nstrcpy(config_name,X509_get_default_cert_area());\\r\\n#ifndef VMS\\r\\nstrcat(config_name,\"/\");\\r\\n#endif\\r\\nstrcat(config_name,OPENSSL_CONF);\\r\\np=config_name;\\r\\n}\\r\\ndefault_config_file=p;\\r\\nconfig=CONF_load(config,p,&errline);\\r\\nif (config == NULL) ERR_clear_error();\\r\\nprog=prog_init();\\r\\nprogram_name(Argv[0],pname,PROG_NAME_SIZE);\\r\\nf.name=pname;\\r\\nfp=(FUNCTION *)lh_retrieve(prog,(char *)&f);\\r\\nif (fp != NULL)\\r\\n{\\r\\nArgv[0]=pname;\\r\\nret=fp->func(Argc,Argv);\\r\\ngoto end;\\r\\n}\\r\\nif (Argc != 1)\\r\\n{\\r\\nArgc--;\\r\\nArgv++;\\r\\nret=do_cmd(prog,Argc,Argv);\\r\\nif (ret < 0) ret=0;\\r\\ngoto end;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nret=0;\\r\\np=buf;\\r\\nn=1024;\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\np[0]='\\0';\\r\\nif (i++)\\r\\nprompt=\">\";\\r\\nelse prompt=\"OpenSSL> \";\\r\\nfputs(prompt,stdout);\\r\\nfflush(stdout);\\r\\nfgets(p,n,stdin);\\r\\nif (p[0] == '\\0') goto end;\\r\\ni=strlen(p);\\r\\nif (i <= 1) break;\\r\\nif (p[i-2] != '\\\\') break;\\r\\ni-=2;\\r\\np+=i;\\r\\nn-=i;\\r\\n}\\r\\nif (!chopup_args(&arg,buf,&argc,&argv)) break;\\r\\nret=do_cmd(prog,argc,argv);\\r\\nif (ret < 0)\\r\\n{\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif (ret != 0)\\r\\nBIO_printf(bio_err,\"error in %s\\n\",argv[0]);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nBIO_printf(bio_err,\"bad exit\\n\");\\r\\nret=1;\\r\\nend:\\r\\nif (config != NULL)\\r\\n{\\r\\nCONF_free(config);\\r\\nconfig=NULL;\\r\\n}\\r\\nif (prog != NULL) lh_free(prog);\\r\\nif (arg.data != NULL) Free(arg.data);\\r\\nERR_remove_state(0);\\r\\nEVP_cleanup();\\r\\nERR_free_strings();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nif (bio_err != NULL)\\r\\n{\\r\\nBIO_free(bio_err);\\r\\nbio_err=NULL;\\r\\n}\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic int do_cmd(LHASH *prog, int argc, char *argv[])\\r\\n{\\r\\nFUNCTION f,*fp;\\r\\nint i,ret=1,tp,nl;\\r\\nif ((argc <= 0) || (argv[0] == NULL))\\r\\n{ ret=0; goto end; }\\r\\nf.name=argv[0];\\r\\nfp=(FUNCTION *)lh_retrieve(prog,(char *)&f);\\r\\nif (fp != NULL)\\r\\n{\\r\\nret=fp->func(argc,argv);\\r\\n}\\r\\nelse if ((strcmp(argv[0],\"quit\") == 0) ||\\r\\n(strcmp(argv[0],\"q\") == 0) ||\\r\\n(strcmp(argv[0],\"exit\") == 0) ||\\r\\n(strcmp(argv[0],\"bye\") == 0))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nelse if ((strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0) ||\\r\\n(strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0) ||\\r\\n(strcmp(argv[0],LIST_CIPHER_COMMANDS) == 0))\\r\\n{\\r\\nint list_type;\\r\\nBIO *bio_stdout;\\r\\nif (strcmp(argv[0],LIST_STANDARD_COMMANDS) == 0)\\r\\nlist_type = FUNC_TYPE_GENERAL;\\r\\nelse if (strcmp(argv[0],LIST_MESSAGE_DIGEST_COMMANDS) == 0)\\r\\nlist_type = FUNC_TYPE_MD;\\r\\nelse\\r\\nlist_type = FUNC_TYPE_CIPHER;\\r\\nbio_stdout = BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\nfor (fp=functions; fp->name != NULL; fp++)\\r\\nif (fp->type == list_type)\\r\\nBIO_printf(bio_stdout, \"%s\\n\", fp->name);\\r\\nBIO_free(bio_stdout);\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"openssl:Error: '%s' is an invalid command.\\n\",\\r\\nargv[0]);\\r\\nBIO_printf(bio_err, \"\\nStandard commands\");\\r\\ni=0;\\r\\ntp=0;\\r\\nfor (fp=functions; fp->name != NULL; fp++)\\r\\n{\\r\\nnl=0;\\r\\nif (((i++) % 5) == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nnl=1;\\r\\n}\\r\\nif (fp->type != tp)\\r\\n{\\r\\ntp=fp->type;\\r\\nif (!nl) BIO_printf(bio_err,\"\\n\");\\r\\nif (tp == FUNC_TYPE_MD)\\r\\n{\\r\\ni=1;\\r\\nBIO_printf(bio_err,\\r\\n\"\\nMessage Digest commands (see the `dgst' command for more details)\\n\");\\r\\n}\\r\\nelse if (tp == FUNC_TYPE_CIPHER)\\r\\n{\\r\\ni=1;\\r\\nBIO_printf(bio_err,\"\\nCipher commands (see the `enc' command for more details)\\n\");\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"%-15s\",fp->name);\\r\\n}\\r\\nBIO_printf(bio_err,\"\\n\\n\");\\r\\nret=0;\\r\\n}\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int SortFnByName(const void *_f1,const void *_f2)\\r\\n{\\r\\nconst FUNCTION *f1=_f1;\\r\\nconst FUNCTION *f2=_f2;\\r\\nif(f1->type != f2->type)\\r\\nreturn f1->type-f2->type;\\r\\nreturn strcmp(f1->name,f2->name);\\r\\n}\\r\\nstatic LHASH *prog_init(void)\\r\\n{\\r\\nLHASH *ret;\\r\\nFUNCTION *f;\\r\\nint i;\\r\\nfor(i=0,f=functions ; f->name != NULL ; ++f,++i)\\r\\n;\\r\\nqsort(functions,i,sizeof *functions,SortFnByName);\\r\\nif ((ret=lh_new(hash,cmp)) == NULL) return(NULL);\\r\\nfor (f=functions; f->name != NULL; f++)\\r\\nlh_insert(ret,(char *)f);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK cmp(FUNCTION *a, FUNCTION *b)\\r\\n{\\r\\nreturn(strncmp(a->name,b->name,8));\\r\\n}\\r\\nstatic unsigned long MS_CALLBACK hash(FUNCTION *a)\\r\\n{\\r\\nreturn(lh_strhash(a->name));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_enc_c_c", "target": 0, "func": "int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->content_type,i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_len(a->algorithm,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len_IMP_opt(a->enc_data,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->content_type,i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_put(a->algorithm,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put_IMP_opt(a->enc_data,i2d_ASN1_OCTET_STRING,0);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_ENC_CONTENT *d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_ENC_CONTENT *,PKCS7_ENC_CONTENT_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->content_type,d2i_ASN1_OBJECT);\\r\\nM_ASN1_D2I_get(ret->algorithm,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get_IMP_opt(ret->enc_data,d2i_ASN1_OCTET_STRING,0,\\r\\nV_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_ENC_CONTENT_free,\\r\\nASN1_F_D2I_PKCS7_ENC_CONTENT);\\r\\n}\\r\\nPKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void)\\r\\n{\\r\\nPKCS7_ENC_CONTENT *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_ENC_CONTENT);\\r\\nret->content_type=OBJ_nid2obj(NID_pkcs7_encrypted);\\r\\nM_ASN1_New(ret->algorithm,X509_ALGOR_new);\\r\\nret->enc_data=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_ENC_CONTENT_NEW);\\r\\n}\\r\\nvoid PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->content_type);\\r\\nX509_ALGOR_free(a->algorithm);\\r\\nASN1_OCTET_STRING_free(a->enc_data);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_r5_c", "target": 0, "func": "EVP_CIPHER *EVP_rc5_32_12_16_cbc(void)\\r\\n{\\r\\nreturn(&rc5_32_12_16_cbc_cipher);\\r\\n}\\r\\nstatic void r_32_12_16_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC5_32_set_key(&(ctx->c.rc5_ks),EVP_RC5_32_12_16_KEY_SIZE,\\r\\nkey,RC5_12_ROUNDS);\\r\\n}\\r\\nstatic void r_32_12_16_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC5_32_cbc_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.rc5_ks),&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_verify_c", "target": 0, "func": "int EVP_VerifyFinal(EVP_MD_CTX *ctx, unsigned char *sigbuf,\\r\\nunsigned int siglen, EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i,ok=0,v;\\r\\nMS_STATIC EVP_MD_CTX tmp_ctx;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nv=ctx->digest->required_pkey_type[i];\\r\\nif (v == 0) break;\\r\\nif (pkey->type == v)\\r\\n{\\r\\nok=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\nEVP_MD_CTX_copy(&tmp_ctx,ctx);\\r\\nEVP_DigestFinal(&tmp_ctx,&(m[0]),&m_len);\\r\\nif (ctx->digest->verify == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ctx->digest->verify(ctx->digest->type,m,m_len,\\r\\nsigbuf,siglen,pkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_crl_c", "target": 0, "func": "int i2d_X509_REVOKED(X509_REVOKED *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->serialNumber,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->revocationDate,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_len_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->serialNumber,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->revocationDate,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_put_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_REVOKED *d2i_X509_REVOKED(X509_REVOKED **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_REVOKED *,X509_REVOKED_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->serialNumber,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->revocationDate,d2i_ASN1_TIME);\\r\\nM_ASN1_D2I_get_seq_opt_type(X509_EXTENSION,ret->extensions,\\r\\nd2i_X509_EXTENSION,X509_EXTENSION_free);\\r\\nM_ASN1_D2I_Finish(a,X509_REVOKED_free,ASN1_F_D2I_X509_REVOKED);\\r\\n}\\r\\nint i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned char **pp)\\r\\n{\\r\\nint v1=0;\\r\\nlong l=0;\\r\\nint (*old_cmp)(X509_REVOKED **,X509_REVOKED **);\\r\\nM_ASN1_I2D_vars(a);\\r\\nold_cmp=sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_seq_cmp);\\r\\nsk_X509_REVOKED_sort(a->revoked);\\r\\nsk_X509_REVOKED_set_cmp_func(a->revoked,old_cmp);\\r\\nif ((a->version != NULL) && ((l=ASN1_INTEGER_get(a->version)) != 0))\\r\\n{\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\n}\\r\\nM_ASN1_I2D_len(a->sig_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->issuer,i2d_X509_NAME);\\r\\nM_ASN1_I2D_len(a->lastUpdate,i2d_ASN1_TIME);\\r\\nif (a->nextUpdate != NULL)\\r\\n{ M_ASN1_I2D_len(a->nextUpdate,i2d_ASN1_TIME); }\\r\\nM_ASN1_I2D_len_SEQUENCE_opt_type(X509_REVOKED,a->revoked,\\r\\ni2d_X509_REVOKED);\\r\\nM_ASN1_I2D_len_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION,0,\\r\\nV_ASN1_SEQUENCE,v1);\\r\\nM_ASN1_I2D_seq_total();\\r\\nif ((a->version != NULL) && (l != 0))\\r\\n{\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\n}\\r\\nM_ASN1_I2D_put(a->sig_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->issuer,i2d_X509_NAME);\\r\\nM_ASN1_I2D_put(a->lastUpdate,i2d_ASN1_UTCTIME);\\r\\nif (a->nextUpdate != NULL)\\r\\n{ M_ASN1_I2D_put(a->nextUpdate,i2d_ASN1_UTCTIME); }\\r\\nM_ASN1_I2D_put_SEQUENCE_opt_type(X509_REVOKED,a->revoked,\\r\\ni2d_X509_REVOKED);\\r\\nM_ASN1_I2D_put_EXP_SEQUENCE_opt_type(X509_EXTENSION,a->extensions,\\r\\ni2d_X509_EXTENSION,0,\\r\\nV_ASN1_SEQUENCE,v1);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_CRL_INFO *d2i_X509_CRL_INFO(X509_CRL_INFO **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint i,ver=0;\\r\\nM_ASN1_D2I_vars(a,X509_CRL_INFO *,X509_CRL_INFO_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_opt(ret->version,d2i_ASN1_INTEGER,V_ASN1_INTEGER);\\r\\nif (ret->version != NULL)\\r\\nver=ret->version->data[0];\\r\\nif ((ver == 0) && (ret->version != NULL))\\r\\n{\\r\\nASN1_INTEGER_free(ret->version);\\r\\nret->version=NULL;\\r\\n}\\r\\nM_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->issuer,d2i_X509_NAME);\\r\\nM_ASN1_D2I_get(ret->lastUpdate,d2i_ASN1_TIME);\\r\\nif(c.slen != 0\\r\\n&& ( (M_ASN1_next & ~V_ASN1_CONSTRUCTED) ==\\r\\n(V_ASN1_UNIVERSAL|V_ASN1_UTCTIME)\\r\\n|| (M_ASN1_next & ~V_ASN1_CONSTRUCTED) ==\\r\\n(V_ASN1_UNIVERSAL|V_ASN1_GENERALIZEDTIME) ) ) {\\r\\nM_ASN1_D2I_get(ret->nextUpdate,d2i_ASN1_TIME);\\r\\n}\\r\\nif(!ret->nextUpdate)\\r\\nM_ASN1_D2I_get_opt(ret->nextUpdate,d2i_ASN1_GENERALIZEDTIME,\\r\\nV_ASN1_GENERALIZEDTIME);\\r\\nif (ret->revoked != NULL)\\r\\n{\\r\\nwhile (sk_X509_REVOKED_num(ret->revoked))\\r\\nX509_REVOKED_free(sk_X509_REVOKED_pop(ret->revoked));\\r\\n}\\r\\nM_ASN1_D2I_get_seq_opt_type(X509_REVOKED,ret->revoked,d2i_X509_REVOKED,\\r\\nX509_REVOKED_free);\\r\\nif (ret->revoked != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_REVOKED_num(ret->revoked); i++)\\r\\n{\\r\\nsk_X509_REVOKED_value(ret->revoked,i)->sequence=i;\\r\\n}\\r\\n}\\r\\nif (ver >= 1)\\r\\n{\\r\\nif (ret->extensions != NULL)\\r\\n{\\r\\nwhile (sk_X509_EXTENSION_num(ret->extensions))\\r\\nX509_EXTENSION_free(\\r\\nsk_X509_EXTENSION_pop(ret->extensions));\\r\\n}\\r\\nM_ASN1_D2I_get_EXP_set_opt_type(X509_EXTENSION,ret->extensions,\\r\\nd2i_X509_EXTENSION,\\r\\nX509_EXTENSION_free,0,\\r\\nV_ASN1_SEQUENCE);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_CRL_INFO_free,ASN1_F_D2I_X509_CRL_INFO);\\r\\n}\\r\\nint i2d_X509_CRL(X509_CRL *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->crl,i2d_X509_CRL_INFO);\\r\\nM_ASN1_I2D_len(a->sig_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->signature,i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->crl,i2d_X509_CRL_INFO);\\r\\nM_ASN1_I2D_put(a->sig_alg,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->signature,i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL(X509_CRL **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_CRL *,X509_CRL_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->crl,d2i_X509_CRL_INFO);\\r\\nM_ASN1_D2I_get(ret->sig_alg,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->signature,d2i_ASN1_BIT_STRING);\\r\\nM_ASN1_D2I_Finish(a,X509_CRL_free,ASN1_F_D2I_X509_CRL);\\r\\n}\\r\\nX509_REVOKED *X509_REVOKED_new(void)\\r\\n{\\r\\nX509_REVOKED *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_REVOKED);\\r\\nM_ASN1_New(ret->serialNumber,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->revocationDate,ASN1_UTCTIME_new);\\r\\nret->extensions=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_REVOKED_NEW);\\r\\n}\\r\\nX509_CRL_INFO *X509_CRL_INFO_new(void)\\r\\n{\\r\\nX509_CRL_INFO *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_CRL_INFO);\\r\\nret->version=NULL;\\r\\nM_ASN1_New(ret->sig_alg,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->issuer,X509_NAME_new);\\r\\nM_ASN1_New(ret->lastUpdate,ASN1_UTCTIME_new);\\r\\nret->nextUpdate=NULL;\\r\\nM_ASN1_New(ret->revoked,sk_X509_REVOKED_new_null);\\r\\nM_ASN1_New(ret->extensions,sk_X509_EXTENSION_new_null);\\r\\nsk_X509_REVOKED_set_cmp_func(ret->revoked,X509_REVOKED_cmp);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_CRL_INFO_NEW);\\r\\n}\\r\\nX509_CRL *X509_CRL_new(void)\\r\\n{\\r\\nX509_CRL *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_CRL);\\r\\nret->references=1;\\r\\nM_ASN1_New(ret->crl,X509_CRL_INFO_new);\\r\\nM_ASN1_New(ret->sig_alg,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->signature,ASN1_BIT_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_CRL_NEW);\\r\\n}\\r\\nvoid X509_REVOKED_free(X509_REVOKED *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->serialNumber);\\r\\nASN1_UTCTIME_free(a->revocationDate);\\r\\nsk_X509_EXTENSION_pop_free(a->extensions,X509_EXTENSION_free);\\r\\nFree(a);\\r\\n}\\r\\nvoid X509_CRL_INFO_free(X509_CRL_INFO *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nX509_ALGOR_free(a->sig_alg);\\r\\nX509_NAME_free(a->issuer);\\r\\nASN1_UTCTIME_free(a->lastUpdate);\\r\\nif (a->nextUpdate)\\r\\nASN1_UTCTIME_free(a->nextUpdate);\\r\\nsk_X509_REVOKED_pop_free(a->revoked,X509_REVOKED_free);\\r\\nsk_X509_EXTENSION_pop_free(a->extensions,X509_EXTENSION_free);\\r\\nFree(a);\\r\\n}\\r\\nvoid X509_CRL_free(X509_CRL *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\ni=CRYPTO_add(&a->references,-1,CRYPTO_LOCK_X509_CRL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_CRL\",a);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_CRL_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nX509_CRL_INFO_free(a->crl);\\r\\nX509_ALGOR_free(a->sig_alg);\\r\\nASN1_BIT_STRING_free(a->signature);\\r\\nFree(a);\\r\\n}\\r\\nstatic int X509_REVOKED_cmp(X509_REVOKED **a, X509_REVOKED **b)\\r\\n{\\r\\nreturn(ASN1_STRING_cmp(\\r\\n(ASN1_STRING *)(*a)->serialNumber,\\r\\n(ASN1_STRING *)(*b)->serialNumber));\\r\\n}\\r\\nstatic int X509_REVOKED_seq_cmp(X509_REVOKED **a, X509_REVOKED **b)\\r\\n{\\r\\nreturn((*a)->sequence-(*b)->sequence);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_req_c", "target": 1, "func": "X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, EVP_MD *md)\\r\\n{\\r\\nX509_REQ *ret;\\r\\nX509_REQ_INFO *ri;\\r\\nint i;\\r\\nEVP_PKEY *pktmp;\\r\\nret=X509_REQ_new();\\r\\nif (ret == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_TO_X509_REQ,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nri=ret->req_info;\\r\\nri->version->length=1;\\r\\nri->version->data=(unsigned char *)Malloc(1);\\r\\nif (ri->version->data == NULL) goto err;\\r\\nri->version->data[0]=0;\\r\\nif (!X509_REQ_set_subject_name(ret,X509_get_subject_name(x)))\\r\\ngoto err;\\r\\npktmp = X509_get_pubkey(x);\\r\\ni=X509_REQ_set_pubkey(ret,pktmp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!i) goto err;\\r\\nif (pkey != NULL)\\r\\n{\\r\\nif (!X509_REQ_sign(ret,pkey,md))\\r\\ngoto err;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nX509_REQ_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req)\\r\\n{\\r\\nif ((req == NULL) || (req->req_info == NULL))\\r\\nreturn(NULL);\\r\\nreturn(X509_PUBKEY_get(req->req_info->pubkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_dss_c", "target": 0, "func": "EVP_MD *EVP_dss(void)\\r\\n{\\r\\nreturn(&dsa_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_chk_c", "target": 0, "func": "int RSA_check_key(RSA *key)\\r\\n{\\r\\nBIGNUM *i, *j, *k, *l, *m;\\r\\nBN_CTX *ctx;\\r\\nint r;\\r\\nint ret=1;\\r\\ni = BN_new();\\r\\nj = BN_new();\\r\\nk = BN_new();\\r\\nl = BN_new();\\r\\nm = BN_new();\\r\\nctx = BN_CTX_new();\\r\\nif (i == NULL || j == NULL || k == NULL || l == NULL ||\\r\\nm == NULL || ctx == NULL)\\r\\n{\\r\\nret = -1;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nr = BN_is_prime(key->p, BN_prime_checks, NULL, NULL, NULL);\\r\\nif (r != 1)\\r\\n{\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_P_NOT_PRIME);\\r\\n}\\r\\nr = BN_is_prime(key->q, BN_prime_checks, NULL, NULL, NULL);\\r\\nif (r != 1)\\r\\n{\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_Q_NOT_PRIME);\\r\\n}\\r\\nr = BN_mul(i, key->p, key->q, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(i, key->n) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_N_DOES_NOT_EQUAL_P_Q);\\r\\n}\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_sub(j, key->q, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mul(l, i, j, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_gcd(m, i, j, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_div(k, NULL, l, m, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod_mul(i, key->d, key->e, k, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (!BN_is_one(i))\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_D_E_NOT_CONGRUENT_TO_1);\\r\\n}\\r\\nif (key->dmp1 != NULL && key->dmq1 != NULL && key->iqmp != NULL)\\r\\n{\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(j, key->dmp1) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_DMP1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nr = BN_sub(i, key->q, BN_value_one());\\r\\nif (!r) { ret = -1; goto err; }\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) { ret = -1; goto err; }\\r\\nif (BN_cmp(j, key->dmq1) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_DMQ1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nif(!BN_mod_inverse(i, key->q, key->p, ctx))\\r\\n{\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(i, key->iqmp) != 0)\\r\\n{\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY,\\r\\nRSA_R_IQMP_NOT_INVERSE_OF_Q);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (i != NULL) BN_free(i);\\r\\nif (j != NULL) BN_free(j);\\r\\nif (k != NULL) BN_free(k);\\r\\nif (l != NULL) BN_free(l);\\r\\nif (m != NULL) BN_free(m);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s_client_c", "target": 0, "func": "static void sc_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"usage: s_client args\\n\");\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nBIO_printf(bio_err,\" -host host - use -connect instead\\n\");\\r\\nBIO_printf(bio_err,\" -port port - use -connect instead\\n\");\\r\\nBIO_printf(bio_err,\" -connect host:port - who to connect to (default is %s:%s)\\n\",SSL_HOST_NAME,PORT_STR);\\r\\nBIO_printf(bio_err,\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\" -cert arg - certificate file to use, PEM format assumed\\n\");\\r\\nBIO_printf(bio_err,\" -key arg - Private key file to use, PEM format assumed, in cert file if\\n\");\\r\\nBIO_printf(bio_err,\" not specified but cert file is.\\n\");\\r\\nBIO_printf(bio_err,\" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -reconnect - Drop and re-make the connection with the same Session-ID\\n\");\\r\\nBIO_printf(bio_err,\" -pause - sleep(1) after each read(2) and write(2) system call\\n\");\\r\\nBIO_printf(bio_err,\" -showcerts - show all certificates in the chain\\n\");\\r\\nBIO_printf(bio_err,\" -debug - extra output\\n\");\\r\\nBIO_printf(bio_err,\" -nbio_test - more ssl protocol testing\\n\");\\r\\nBIO_printf(bio_err,\" -state - print the 'ssl' states\\n\");\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err,\" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\n#ifdef APPS_CRLF\\r\\nBIO_printf(bio_err,\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -quiet - no s_client output\\n\");\\r\\nBIO_printf(bio_err,\" -ssl2 - just use SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -ssl3 - just use SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -tls1 - just use TLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\\n\");\\r\\nBIO_printf(bio_err,\" -bugs - Switch on all SSL implementation bug workarounds\\n\");\\r\\nBIO_printf(bio_err,\" -cipher - prefered cipher to use, use the 'openssl ciphers'\\n\");\\r\\nBIO_printf(bio_err,\" command to see what is available\\n\");\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint off=0;\\r\\nSSL *con=NULL,*con2=NULL;\\r\\nint s,k,width,state=0;\\r\\nchar *cbuf=NULL,*sbuf=NULL;\\r\\nint cbuf_len,cbuf_off;\\r\\nint sbuf_len,sbuf_off;\\r\\nfd_set readfds,writefds;\\r\\nshort port=PORT;\\r\\nint full_log=1;\\r\\nchar *host=SSL_HOST_NAME;\\r\\nchar *cert_file=NULL,*key_file=NULL;\\r\\nchar *CApath=NULL,*CAfile=NULL,*cipher=NULL;\\r\\nint reconnect=0,badop=0,verify=SSL_VERIFY_NONE,bugs=0;\\r\\n#ifdef APPS_CRLF\\r\\nint crlf=0;\\r\\n#endif\\r\\nint write_tty,read_tty,write_ssl,read_ssl,tty_on,ssl_pending;\\r\\nSSL_CTX *ctx=NULL;\\r\\nint ret=1,in_init=1,i,nbio_test=0;\\r\\nSSL_METHOD *meth=NULL;\\r\\nBIO *sbio;\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\nmeth=SSLv23_client_method();\\r\\n#elif !defined(NO_SSL3)\\r\\nmeth=SSLv3_client_method();\\r\\n#elif !defined(NO_SSL2)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\napps_startup();\\r\\nc_Pause=0;\\r\\nc_quiet=0;\\r\\nc_debug=0;\\r\\nc_showcerts=0;\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nif ( ((cbuf=Malloc(BUFSIZZ)) == NULL) ||\\r\\n((sbuf=Malloc(BUFSIZZ)) == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nverify_depth=0;\\r\\nverify_error=X509_V_OK;\\r\\n#ifdef FIONBIO\\r\\nc_nbio=0;\\r\\n#endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-host\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nhost= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-port\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nport=atoi(*(++argv));\\r\\nif (port == 0) goto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-connect\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!extract_host_port(*(++argv),&host,NULL,&port))\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\n{\\r\\nverify=SSL_VERIFY_PEER;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncert_file= *(++argv);\\r\\n}\\r\\n#ifdef APPS_CRLF\\r\\nelse if (strcmp(*argv,\"-crlf\") == 0)\\r\\ncrlf=1;\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-quiet\") == 0)\\r\\nc_quiet=1;\\r\\nelse if (strcmp(*argv,\"-pause\") == 0)\\r\\nc_Pause=1;\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\nc_debug=1;\\r\\nelse if (strcmp(*argv,\"-showcerts\") == 0)\\r\\nc_showcerts=1;\\r\\nelse if (strcmp(*argv,\"-nbio_test\") == 0)\\r\\nnbio_test=1;\\r\\nelse if (strcmp(*argv,\"-state\") == 0)\\r\\nstate=1;\\r\\n#ifndef NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\nmeth=SSLv3_client_method();\\r\\n#endif\\r\\n#ifndef NO_TLS1\\r\\nelse if (strcmp(*argv,\"-tls1\") == 0)\\r\\nmeth=TLSv1_client_method();\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-bugs\") == 0)\\r\\nbugs=1;\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-reconnect\") == 0)\\r\\n{\\r\\nreconnect=5;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-no_tls1\") == 0)\\r\\noff|=SSL_OP_NO_TLSv1;\\r\\nelse if (strcmp(*argv,\"-no_ssl3\") == 0)\\r\\noff|=SSL_OP_NO_SSLv3;\\r\\nelse if (strcmp(*argv,\"-no_ssl2\") == 0)\\r\\noff|=SSL_OP_NO_SSLv2;\\r\\nelse if (strcmp(*argv,\"-cipher\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncipher= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv,\"-nbio\") == 0)\\r\\n{ c_nbio=1; }\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop)\\r\\n{\\r\\nbad:\\r\\nsc_usage();\\r\\ngoto end;\\r\\n}\\r\\nif (bio_c_out == NULL)\\r\\n{\\r\\nif (c_quiet)\\r\\n{\\r\\nbio_c_out=BIO_new(BIO_s_null());\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bio_c_out == NULL)\\r\\nbio_c_out=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\nSSLeay_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (bugs)\\r\\nSSL_CTX_set_options(ctx,SSL_OP_ALL|off);\\r\\nelse\\r\\nSSL_CTX_set_options(ctx,off);\\r\\nif (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);\\r\\nif (cipher != NULL)\\r\\nSSL_CTX_set_cipher_list(ctx,cipher);\\r\\n#if 0\\r\\nelse\\r\\nSSL_CTX_set_cipher_list(ctx,getenv(\"SSL_CIPHER\"));\\r\\n#endif\\r\\nSSL_CTX_set_verify(ctx,verify,verify_callback);\\r\\nif (!set_cert_stuff(ctx,cert_file,key_file))\\r\\ngoto end;\\r\\nif ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nSSL_load_error_strings();\\r\\ncon=(SSL *)SSL_new(ctx);\\r\\nre_start:\\r\\nif (init_client(&s,host,port) == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"connect:errno=%d\\n\",get_last_socket_error());\\r\\nSHUTDOWN(s);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_c_out,\"CONNECTED(%08X)\\n\",s);\\r\\n#ifdef FIONBIO\\r\\nif (c_nbio)\\r\\n{\\r\\nunsigned long l=1;\\r\\nBIO_printf(bio_c_out,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&l) < 0)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (c_Pause & 0x01) con->debug=1;\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nif (c_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(sbio,bio_dump_cb);\\r\\nBIO_set_callback_arg(sbio,bio_c_out);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_connect_state(con);\\r\\nwidth=SSL_get_fd(con)+1;\\r\\nread_tty=1;\\r\\nwrite_tty=0;\\r\\ntty_on=0;\\r\\nread_ssl=1;\\r\\nwrite_ssl=1;\\r\\ncbuf_len=0;\\r\\ncbuf_off=0;\\r\\nsbuf_len=0;\\r\\nsbuf_off=0;\\r\\nfor (;;)\\r\\n{\\r\\nFD_ZERO(&readfds);\\r\\nFD_ZERO(&writefds);\\r\\nif (SSL_in_init(con) && !SSL_total_renegotiations(con))\\r\\n{\\r\\nin_init=1;\\r\\ntty_on=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntty_on=1;\\r\\nif (in_init)\\r\\n{\\r\\nin_init=0;\\r\\nprint_stuff(bio_c_out,con,full_log);\\r\\nif (full_log > 0) full_log--;\\r\\nif (reconnect)\\r\\n{\\r\\nreconnect--;\\r\\nBIO_printf(bio_c_out,\"drop connection and then reconnect\\n\");\\r\\nSSL_shutdown(con);\\r\\nSSL_set_connect_state(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\ngoto re_start;\\r\\n}\\r\\n}\\r\\n}\\r\\nssl_pending = read_ssl && SSL_pending(con);\\r\\nif (!ssl_pending)\\r\\n{\\r\\n#ifndef WINDOWS\\r\\nif (tty_on)\\r\\n{\\r\\nif (read_tty) FD_SET(fileno(stdin),&readfds);\\r\\nif (write_tty) FD_SET(fileno(stdout),&writefds);\\r\\n}\\r\\n#endif\\r\\nif (read_ssl)\\r\\nFD_SET(SSL_get_fd(con),&readfds);\\r\\nif (write_ssl)\\r\\nFD_SET(SSL_get_fd(con),&writefds);\\r\\ni=select(width,(void *)&readfds,(void *)&writefds,\\r\\nNULL,NULL);\\r\\nif ( i < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"bad select %d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\nif (!ssl_pending && FD_ISSET(SSL_get_fd(con),&writefds))\\r\\n{\\r\\nk=SSL_write(con,&(cbuf[cbuf_off]),\\r\\n(unsigned int)cbuf_len);\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\ncbuf_off+=k;\\r\\ncbuf_len-=k;\\r\\nif (k <= 0) goto end;\\r\\nif (cbuf_len <= 0)\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=0;\\r\\nwrite_ssl=1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out,\"write W BLOCK\\n\");\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out,\"write R BLOCK\\n\");\\r\\nwrite_tty=0;\\r\\nread_ssl=1;\\r\\nwrite_ssl=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out,\"write X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nif (cbuf_len != 0)\\r\\n{\\r\\nBIO_printf(bio_c_out,\"shutdown\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\nbreak;\\r\\n}\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nif ((k != 0) || (cbuf_len != 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"write:errno=%d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n}\\r\\nelse\\r\\n{\\r\\nread_tty=1;\\r\\nwrite_ssl=0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#ifndef WINDOWS\\r\\nelse if (!ssl_pending && FD_ISSET(fileno(stdout),&writefds))\\r\\n{\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(&(sbuf[sbuf_off]),&(sbuf[sbuf_off]),sbuf_len);\\r\\n#endif\\r\\ni=write(fileno(stdout),&(sbuf[sbuf_off]),sbuf_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_printf(bio_c_out,\"DONE\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nsbuf_len-=i;;\\r\\nsbuf_off+=i;\\r\\nif (sbuf_len <= 0)\\r\\n{\\r\\nread_ssl=1;\\r\\nwrite_tty=0;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nelse if (ssl_pending || FD_ISSET(SSL_get_fd(con),&readfds))\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static int iiii; if (++iiii == 52) { SSL_renegotiate(con); iiii=0; } }\\r\\n#endif\\r\\n#if 1\\r\\nk=SSL_read(con,sbuf,1024 );\\r\\n#else\\r\\nk=SSL_read(con,sbuf,16);\\r\\n{ char zbuf[10240];\\r\\nprintf(\"read=%d pending=%d peek=%d\\n\",k,SSL_pending(con),SSL_peek(con,zbuf,10240));\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nif (k <= 0)\\r\\ngoto end;\\r\\nsbuf_off=0;\\r\\nsbuf_len=k;\\r\\nread_ssl=0;\\r\\nwrite_tty=1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out,\"read W BLOCK\\n\");\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out,\"read R BLOCK\\n\");\\r\\nwrite_tty=0;\\r\\nread_ssl=1;\\r\\nif ((read_tty == 0) && (write_ssl == 0))\\r\\nwrite_ssl=1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out,\"read X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nBIO_printf(bio_err,\"read:errno=%d\\n\",get_last_socket_error());\\r\\ngoto shut;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_c_out,\"closed\\n\");\\r\\ngoto shut;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#ifndef WINDOWS\\r\\nelse if (FD_ISSET(fileno(stdin),&readfds))\\r\\n{\\r\\n#ifdef APPS_CRLF\\r\\nif (crlf)\\r\\n{\\r\\nint j, lf_num;\\r\\ni=read(fileno(stdin),cbuf,BUFSIZZ/2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (cbuf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i-1; j >= 0; j--)\\r\\n{\\r\\ncbuf[j+lf_num] = cbuf[j];\\r\\nif (cbuf[j] == '\\n')\\r\\n{\\r\\nlf_num--;\\r\\ni++;\\r\\ncbuf[j+lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ni=read(fileno(stdin),cbuf,BUFSIZZ);\\r\\nif ((!c_quiet) && ((i <= 0) || (cbuf[0] == 'Q')))\\r\\n{\\r\\nBIO_printf(bio_err,\"DONE\\n\");\\r\\ngoto shut;\\r\\n}\\r\\nif ((!c_quiet) && (cbuf[0] == 'R'))\\r\\n{\\r\\nBIO_printf(bio_err,\"RENEGOTIATING\\n\");\\r\\nSSL_renegotiate(con);\\r\\ncbuf_len=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncbuf_len=i;\\r\\ncbuf_off=0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(cbuf, cbuf, i);\\r\\n#endif\\r\\n}\\r\\nwrite_ssl=1;\\r\\nread_tty=0;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nshut:\\r\\nSSL_shutdown(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\nret=0;\\r\\nend:\\r\\nif (con != NULL) SSL_free(con);\\r\\nif (con2 != NULL) SSL_free(con2);\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (cbuf != NULL) { memset(cbuf,0,BUFSIZZ); Free(cbuf); }\\r\\nif (sbuf != NULL) { memset(sbuf,0,BUFSIZZ); Free(sbuf); }\\r\\nif (bio_c_out != NULL)\\r\\n{\\r\\nBIO_free(bio_c_out);\\r\\nbio_c_out=NULL;\\r\\n}\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void print_stuff(BIO *bio, SSL *s, int full)\\r\\n{\\r\\nX509 *peer=NULL;\\r\\nchar *p;\\r\\nstatic char *space=\" \";\\r\\nchar buf[BUFSIZ];\\r\\nSTACK_OF(X509) *sk;\\r\\nSTACK_OF(X509_NAME) *sk2;\\r\\nSSL_CIPHER *c;\\r\\nX509_NAME *xn;\\r\\nint j,i;\\r\\nif (full)\\r\\n{\\r\\nint got_a_chain = 0;\\r\\nsk=SSL_get_peer_cert_chain(s);\\r\\nif (sk != NULL)\\r\\n{\\r\\ngot_a_chain = 1;\\r\\nBIO_printf(bio,\"---\\nCertificate chain\\n\");\\r\\nfor (i=0; i<sk_X509_num(sk); i++)\\r\\n{\\r\\nX509_NAME_oneline(X509_get_subject_name(\\r\\nsk_X509_value(sk,i)),buf,BUFSIZ);\\r\\nBIO_printf(bio,\"%2d s:%s\\n\",i,buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(\\r\\nsk_X509_value(sk,i)),buf,BUFSIZ);\\r\\nBIO_printf(bio,\" i:%s\\n\",buf);\\r\\nif (c_showcerts)\\r\\nPEM_write_bio_X509(bio,sk_X509_value(sk,i));\\r\\n}\\r\\n}\\r\\nBIO_printf(bio,\"---\\n\");\\r\\npeer=SSL_get_peer_certificate(s);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(bio,\"Server certificate\\n\");\\r\\nif (!(c_showcerts && got_a_chain))\\r\\nPEM_write_bio_X509(bio,peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer),\\r\\nbuf,BUFSIZ);\\r\\nBIO_printf(bio,\"subject=%s\\n\",buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer),\\r\\nbuf,BUFSIZ);\\r\\nBIO_printf(bio,\"issuer=%s\\n\",buf);\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio,\"no peer certificate available\\n\");\\r\\nsk2=SSL_get_client_CA_list(s);\\r\\nif ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0))\\r\\n{\\r\\nBIO_printf(bio,\"---\\nAcceptable client certificate CA names\\n\");\\r\\nfor (i=0; i<sk_X509_NAME_num(sk2); i++)\\r\\n{\\r\\nxn=sk_X509_NAME_value(sk2,i);\\r\\nX509_NAME_oneline(xn,buf,sizeof(buf));\\r\\nBIO_write(bio,buf,strlen(buf));\\r\\nBIO_write(bio,\"\\n\",1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio,\"---\\nNo client certificate CA names sent\\n\");\\r\\n}\\r\\np=SSL_get_shared_ciphers(s,buf,BUFSIZ);\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO_printf(bio,\"---\\nCiphers common between both SSL endpoints:\\n\");\\r\\nj=i=0;\\r\\nwhile (*p)\\r\\n{\\r\\nif (*p == ':')\\r\\n{\\r\\nBIO_write(bio,space,15-j%25);\\r\\ni++;\\r\\nj=0;\\r\\nBIO_write(bio,((i%3)?\" \":\"\\n\"),1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_write(bio,p,1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_write(bio,\"\\n\",1);\\r\\n}\\r\\nBIO_printf(bio,\"---\\nSSL handshake has read %ld bytes and written %ld bytes\\n\",\\r\\nBIO_number_read(SSL_get_rbio(s)),\\r\\nBIO_number_written(SSL_get_wbio(s)));\\r\\n}\\r\\nBIO_printf(bio,((s->hit)?\"---\\nReused, \":\"---\\nNew, \"));\\r\\nc=SSL_get_current_cipher(s);\\r\\nBIO_printf(bio,\"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nif (peer != NULL) {\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(peer);\\r\\nBIO_printf(bio,\"Server public key is %d bit\\n\",\\r\\nEVP_PKEY_bits(pktmp));\\r\\nEVP_PKEY_free(pktmp);\\r\\n}\\r\\nSSL_SESSION_print(bio,SSL_get_session(s));\\r\\nBIO_printf(bio,\"---\\n\");\\r\\nif (peer != NULL)\\r\\nX509_free(peer);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_dup_c", "target": 0, "func": "char *ASN1_dup(int (*i2d)(), char *(*d2i)(), char *x)\\r\\n{\\r\\nunsigned char *b,*p;\\r\\nlong i;\\r\\nchar *ret;\\r\\nif (x == NULL) return(NULL);\\r\\ni=(long)i2d(x,NULL);\\r\\nb=(unsigned char *)Malloc((unsigned int)i+10);\\r\\nif (b == NULL)\\r\\n{ ASN1err(ASN1_F_ASN1_DUP,ERR_R_MALLOC_FAILURE); return(NULL); }\\r\\np= b;\\r\\ni=i2d(x,&p);\\r\\np= b;\\r\\nret=d2i(NULL,&p,i);\\r\\nFree((char *)b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_obj_err_c", "target": 0, "func": "void ERR_load_OBJ_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_OBJ,OBJ_str_functs);\\r\\nERR_load_strings(ERR_LIB_OBJ,OBJ_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_genn_c", "target": 0, "func": "int i2d_GENERAL_NAME(GENERAL_NAME *a, unsigned char **pp)\\r\\n{\\r\\nunsigned char *p;\\r\\nint ret;\\r\\nret = 0;\\r\\nif(pp) p = *pp;\\r\\nelse p = NULL;\\r\\nif(a->type == GEN_DIRNAME) {\\r\\nint v = 0;\\r\\nM_ASN1_I2D_len_EXP_opt(a->d.dirn, i2d_X509_NAME, 4, v);\\r\\nif(!p) return ret;\\r\\nM_ASN1_I2D_put_EXP_opt(a->d.dirn, i2d_X509_NAME, 4, v);\\r\\n*pp = p;\\r\\nreturn ret;\\r\\n}\\r\\nswitch(a->type) {\\r\\ncase GEN_OTHERNAME:\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\nret = i2d_ASN1_TYPE(a->d.other, pp);\\r\\nbreak;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\nret = i2d_ASN1_IA5STRING(a->d.ia5, pp);\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\nret = i2d_ASN1_OCTET_STRING(a->d.ip, pp);\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\nret = i2d_ASN1_OBJECT(a->d.rid, pp);\\r\\nbreak;\\r\\n}\\r\\nif(p) *p = (*p & V_ASN1_CONSTRUCTED) | a->type;\\r\\nreturn ret;\\r\\n}\\r\\nGENERAL_NAME *GENERAL_NAME_new()\\r\\n{\\r\\nGENERAL_NAME *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, GENERAL_NAME);\\r\\nret->type = -1;\\r\\nret->d.ptr = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_GENERAL_NAME_NEW);\\r\\n}\\r\\nGENERAL_NAME *d2i_GENERAL_NAME(GENERAL_NAME **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nunsigned char _tmp;\\r\\nM_ASN1_D2I_vars(a,GENERAL_NAME *,GENERAL_NAME_new);\\r\\nM_ASN1_D2I_Init();\\r\\nc.slen = length;\\r\\n_tmp = M_ASN1_next;\\r\\nret->type = _tmp & ~V_ASN1_CONSTRUCTED;\\r\\nswitch(ret->type) {\\r\\ncase GEN_OTHERNAME:\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\nM_ASN1_D2I_get_imp(ret->d.other, d2i_ASN1_TYPE,V_ASN1_SEQUENCE);\\r\\nbreak;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\nM_ASN1_D2I_get_imp(ret->d.ia5, d2i_ASN1_IA5STRING,\\r\\nV_ASN1_IA5STRING);\\r\\nbreak;\\r\\ncase GEN_DIRNAME:\\r\\nM_ASN1_D2I_get_EXP_opt(ret->d.dirn, d2i_X509_NAME, 4);\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\nM_ASN1_D2I_get_imp(ret->d.ip, d2i_ASN1_OCTET_STRING,\\r\\nV_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\nM_ASN1_D2I_get_imp(ret->d.rid, d2i_ASN1_OBJECT,V_ASN1_OBJECT);\\r\\nbreak;\\r\\ndefault:\\r\\nc.error = ASN1_R_BAD_TAG;\\r\\ngoto err;\\r\\n}\\r\\nc.slen = 0;\\r\\nM_ASN1_D2I_Finish(a, GENERAL_NAME_free, ASN1_F_D2I_GENERAL_NAME);\\r\\n}\\r\\nvoid GENERAL_NAME_free(GENERAL_NAME *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nswitch(a->type) {\\r\\ncase GEN_OTHERNAME:\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\nASN1_TYPE_free(a->d.other);\\r\\nbreak;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\nASN1_IA5STRING_free(a->d.ia5);\\r\\nbreak;\\r\\ncase GEN_DIRNAME:\\r\\nX509_NAME_free(a->d.dirn);\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\nASN1_OCTET_STRING_free(a->d.ip);\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\nASN1_OBJECT_free(a->d.rid);\\r\\nbreak;\\r\\n}\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_meth_c", "target": 0, "func": "static SSL_METHOD *ssl3_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv3_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_data.ssl_connect=ssl3_connect;\\r\\nSSLv3_data.ssl_accept=ssl3_accept;\\r\\nSSLv3_data.get_ssl_method=ssl3_get_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv3_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_attr_c", "target": 0, "func": "int PKCS12_add_localkeyid (PKCS12_SAFEBAG *bag, unsigned char *name,\\r\\nint namelen)\\r\\n{\\r\\nX509_ATTRIBUTE *attrib;\\r\\nASN1_BMPSTRING *oct;\\r\\nASN1_TYPE *keyid;\\r\\nif (!(keyid = ASN1_TYPE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nkeyid->type = V_ASN1_OCTET_STRING;\\r\\nif (!(oct = ASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_OCTET_STRING_set(oct, name, namelen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nkeyid->value.octet_string = oct;\\r\\nif (!(attrib = X509_ATTRIBUTE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nattrib->object = OBJ_nid2obj(NID_localKeyID);\\r\\nif (!(attrib->value.set = sk_ASN1_TYPE_new(NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_ASN1_TYPE_push (attrib->value.set,keyid);\\r\\nattrib->set = 1;\\r\\nif (!bag->attrib && !(bag->attrib = sk_X509_ATTRIBUTE_new (NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_LOCALKEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_X509_ATTRIBUTE_push (bag->attrib, attrib);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS8_add_keyusage (PKCS8_PRIV_KEY_INFO *p8, int usage)\\r\\n{\\r\\nX509_ATTRIBUTE *attrib;\\r\\nASN1_BIT_STRING *bstr;\\r\\nASN1_TYPE *keyid;\\r\\nunsigned char us_val;\\r\\nus_val = (unsigned char) usage;\\r\\nif (!(keyid = ASN1_TYPE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nkeyid->type = V_ASN1_BIT_STRING;\\r\\nif (!(bstr = ASN1_BIT_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_BIT_STRING_set(bstr, &us_val, 1)) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nkeyid->value.bit_string = bstr;\\r\\nif (!(attrib = X509_ATTRIBUTE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nattrib->object = OBJ_nid2obj(NID_key_usage);\\r\\nif (!(attrib->value.set = sk_ASN1_TYPE_new(NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_ASN1_TYPE_push (attrib->value.set,keyid);\\r\\nattrib->set = 1;\\r\\nif (!p8->attributes\\r\\n&& !(p8->attributes = sk_X509_ATTRIBUTE_new (NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ADD_KEYUSAGE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_X509_ATTRIBUTE_push (p8->attributes, attrib);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_add_friendlyname_asc (PKCS12_SAFEBAG *bag, const char *name,\\r\\nint namelen)\\r\\n{\\r\\nunsigned char *uniname;\\r\\nint ret, unilen;\\r\\nif (!asc2uni(name, &uniname, &unilen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_ASC,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nret = PKCS12_add_friendlyname_uni (bag, uniname, unilen);\\r\\nFree(uniname);\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS12_add_friendlyname_uni (PKCS12_SAFEBAG *bag,\\r\\nconst unsigned char *name, int namelen)\\r\\n{\\r\\nX509_ATTRIBUTE *attrib;\\r\\nASN1_BMPSTRING *bmp;\\r\\nASN1_TYPE *fname;\\r\\nif(!name[namelen - 1] && !name[namelen - 2]) namelen -= 2;\\r\\nif (!(fname = ASN1_TYPE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfname->type = V_ASN1_BMPSTRING;\\r\\nif (!(bmp = ASN1_BMPSTRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(bmp->data = Malloc (namelen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy (bmp->data, name, namelen);\\r\\nbmp->length = namelen;\\r\\nfname->value.bmpstring = bmp;\\r\\nif (!(attrib = X509_ATTRIBUTE_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nattrib->object = OBJ_nid2obj(NID_friendlyName);\\r\\nif (!(attrib->value.set = sk_ASN1_TYPE_new(NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_ASN1_TYPE_push (attrib->value.set,fname);\\r\\nattrib->set = 1;\\r\\nif (!bag->attrib && !(bag->attrib = sk_X509_ATTRIBUTE_new (NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ADD_FRIENDLYNAME_UNI,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_X509_ATTRIBUTE_push (bag->attrib, attrib);\\r\\nreturn PKCS12_OK;\\r\\n}\\r\\nchar *PKCS12_get_friendlyname(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nASN1_TYPE *atype;\\r\\nif (!(atype = PKCS12_get_attr(bag, NID_friendlyName))) return NULL;\\r\\nif (atype->type != V_ASN1_BMPSTRING) return NULL;\\r\\nreturn uni2asc(atype->value.bmpstring->data,\\r\\natype->value.bmpstring->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p1024_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,2);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cbc_cksm_c", "target": 0, "func": "DES_LONG des_cbc_cksum(const unsigned char *in, des_cblock *output,\\r\\nlong length,\\r\\ndes_key_schedule schedule, const_des_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG tout0,tout1,tin0,tin1;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *out = &(*output)[0];\\r\\nconst unsigned char *iv = &(*ivec)[0];\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (; l>0; l-=8)\\r\\n{\\r\\nif (l >= 8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\n}\\r\\nelse\\r\\nc2ln(in,tin0,tin1,l);\\r\\ntin0^=tout0; tin[0]=tin0;\\r\\ntin1^=tout1; tin[1]=tin1;\\r\\ndes_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\ntout0=tin0=tin1=tin[0]=tin[1]=0;\\r\\nreturn(tout1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_dgst_c", "target": 0, "func": "int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->md,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->contents,i2d_PKCS7);\\r\\nM_ASN1_I2D_len(a->digest,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->md,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->contents,i2d_PKCS7);\\r\\nM_ASN1_I2D_put(a->digest,i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_DIGEST *d2i_PKCS7_DIGEST(PKCS7_DIGEST **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_DIGEST *,PKCS7_DIGEST_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->md,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->contents,d2i_PKCS7);\\r\\nM_ASN1_D2I_get(ret->digest,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_DIGEST_free,ASN1_F_D2I_PKCS7_DIGEST);\\r\\n}\\r\\nPKCS7_DIGEST *PKCS7_DIGEST_new(void)\\r\\n{\\r\\nPKCS7_DIGEST *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_DIGEST);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->md,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->contents,PKCS7_new);\\r\\nM_ASN1_New(ret->digest,ASN1_OCTET_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_DIGEST_NEW);\\r\\n}\\r\\nvoid PKCS7_DIGEST_free(PKCS7_DIGEST *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nX509_ALGOR_free(a->md);\\r\\nPKCS7_free(a->contents);\\r\\nASN1_OCTET_STRING_free(a->digest);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_cbc(void)\\r\\n{\\r\\nreturn(&d_cbc_cipher);\\r\\n}\\r\\nstatic void des_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\ndes_set_key(deskey,ctx->c.des_ks);\\r\\n}\\r\\nstatic void des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_ncbc_encrypt(in,out,inl,ctx->c.des_ks,\\r\\n(des_cblock *)&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md5_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"MD5(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nMD5_CTX c;\\r\\nunsigned char md[MD5_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nMD5_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nMD5_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nMD5_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<MD5_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_ber_c", "target": 0, "func": "BIO_METHOD *BIO_f_ber(void)\\r\\n{\\r\\nreturn(&methods_ber);\\r\\n}\\r\\nstatic int ber_new(BIO *bi)\\r\\n{\\r\\nBIO_BER_CTX *ctx;\\r\\nctx=(BIO_BER_CTX *)Malloc(sizeof(BIO_BER_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nmemset((char *)ctx,0,sizeof(BIO_BER_CTX));\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ber_free(BIO *a)\\r\\n{\\r\\nBIO_BER_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_BER_CTX *)a->ptr;\\r\\nmemset(a->ptr,0,sizeof(BIO_BER_CTX));\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nint bio_ber_get_header(BIO *bio, BIO_BER_CTX *ctx)\\r\\n{\\r\\nchar buf[64];\\r\\nint i,j,n;\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nunsigned long length\\r\\nint tag;\\r\\nint class;\\r\\nlong max;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->buf_off != 0)\\r\\n{\\r\\np=ctx->buf;\\r\\nj=ctx->buf_off;\\r\\nn=ctx->buf_len-j;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\np[0]=p[j];\\r\\np++;\\r\\n}\\r\\nctx->buf_len-j;\\r\\nctx->buf_off=0;\\r\\n}\\r\\ni=BER_BUF_SIZE-ctx->buf_len;\\r\\nif (i)\\r\\n{\\r\\ni=BIO_read(bio->next_bio,&(ctx->buf[ctx->buf_len]),i);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\nctx->buf_len+=i;\\r\\n}\\r\\nmax=ctx->buf_len;\\r\\np=ctx->buf;\\r\\nret=ASN1_get_object(&p,&length,&tag,&class,max);\\r\\nif (ret & 0x80)\\r\\n{\\r\\nif ((ctx->buf_len < BER_BUF_SIZE) &&\\r\\n(ERR_GET_REASON(ERR_peek_error()) == ASN1_R_TOO_LONG))\\r\\n{\\r\\nERR_get_error();\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nreturn(-1);\\r\\n}\\r\\nif ((ctx->tag >= 0) && (ctx->tag != tag))\\r\\n{\\r\\nBIOerr(BIO_F_BIO_BER_GET_HEADER,BIO_R_TAG_MISMATCH);\\r\\nsprintf(buf,\"tag=%d, got %d\",ctx->tag,tag);\\r\\nERR_add_error_data(1,buf);\\r\\nreturn(-1);\\r\\n}\\r\\nif (ret & 0x01)\\r\\nif (ret & V_ASN1_CONSTRUCTED)\\r\\n}\\r\\nstatic int ber_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,n;\\r\\nBIO_BER_CTX *ctx;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_BER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->finished) return(0);\\r\\nagain:\\r\\nif (ctx->num_left > 0)\\r\\n{\\r\\nif (ctx->num_left < outl)\\r\\nn=ctx->num_left;\\r\\nelse\\r\\nn=outl;\\r\\ni=BIO_read(b->next_bio,out,n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->num_left-=i;\\r\\noutl-=i;\\r\\nret+=i;\\r\\nif (ctx->num_left <= 0)\\r\\n{\\r\\nctx->depth--;\\r\\nif (ctx->depth <= 0)\\r\\nctx->finished=1;\\r\\n}\\r\\nif (outl <= 0)\\r\\nreturn(ret);\\r\\nelse\\r\\ngoto again;\\r\\n}\\r\\nelse\\r\\n{\\r\\n}\\r\\n}\\r\\nstatic int ber_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nret=inl;\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx->buf_off=0;\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ber_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_ENC_CTX *ctx,*dctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ok=1;\\r\\nctx->finished=0;\\r\\nEVP_CipherInit(&(ctx->cipher),NULL,NULL,NULL,\\r\\nctx->cipher.berrypt);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=ber_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ctx->finished)\\r\\n{\\r\\nctx->finished=1;\\r\\nctx->buf_off=0;\\r\\nret=EVP_CipherFinal(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=(int)ret;\\r\\nif (ret <= 0) break;\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_STATUS:\\r\\nret=(long)ctx->ok;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\ndctx=(BIO_ENC_CTX *)dbio->ptr;\\r\\nmemcpy(&(dctx->cipher),&(ctx->cipher),sizeof(ctx->cipher));\\r\\ndbio->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_set_cipher(BIO *b, EVP_CIPHER *c, unsigned char *k, unsigned char *i,\\r\\nint e)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (b == NULL) return;\\r\\nif ((b->callback != NULL) &&\\r\\n(b->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,0L) <= 0))\\r\\nreturn;\\r\\nb->init=1;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nEVP_CipherInit(&(ctx->cipher),c,k,i,e);\\r\\nif (b->callback != NULL)\\r\\nb->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,1L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p192_c", "target": 0, "func": "main()\\r\\n{\\r\\nDH *dh;\\r\\ndh=DH_new();\\r\\ndh->p=BN_bin2bn(data,sizeof(data),NULL);\\r\\ndh->g=BN_new();\\r\\nBN_set_word(dh->g,3);\\r\\nPEM_write_DHparams(stdout,dh);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ede_cbcm_enc_c", "target": 0, "func": "void des_ede3_cbcm_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule ks1, des_key_schedule ks2,\\r\\ndes_key_schedule ks3, des_cblock *ivec1, des_cblock *ivec2,\\r\\nint enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1,m0,m1;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv1,*iv2;\\r\\niv1 = &(*ivec1)[0];\\r\\niv2 = &(*ivec2)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv1,m0);\\r\\nc2l(iv1,m1);\\r\\nc2l(iv2,tout0);\\r\\nc2l(iv2,tout1);\\r\\nfor (l-=8; l>=-7; l-=8)\\r\\n{\\r\\ntin[0]=m0;\\r\\ntin[1]=m1;\\r\\ndes_encrypt(tin,ks3,1);\\r\\nm0=tin[0];\\r\\nm1=tin[1];\\r\\nif(l < 0)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\n}\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_encrypt(tin,ks1,1);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\ndes_encrypt(tin,ks2,0);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\ndes_encrypt(tin,ks1,1);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\niv1=&(*ivec1)[0];\\r\\nl2c(m0,iv1);\\r\\nl2c(m1,iv1);\\r\\niv2=&(*ivec2)[0];\\r\\nl2c(tout0,iv2);\\r\\nl2c(tout1,iv2);\\r\\n}\\r\\nelse\\r\\n{\\r\\nregister DES_LONG t0,t1;\\r\\nc2l(iv1,m0);\\r\\nc2l(iv1,m1);\\r\\nc2l(iv2,xor0);\\r\\nc2l(iv2,xor1);\\r\\nfor (l-=8; l>=-7; l-=8)\\r\\n{\\r\\ntin[0]=m0;\\r\\ntin[1]=m1;\\r\\ndes_encrypt(tin,ks3,1);\\r\\nm0=tin[0];\\r\\nm1=tin[1];\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\nt0=tin0;\\r\\nt1=tin1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\ndes_encrypt(tin,ks1,0);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\ndes_encrypt(tin,ks2,1);\\r\\ntin[0]^=m0;\\r\\ntin[1]^=m1;\\r\\ndes_encrypt(tin,ks1,0);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\ntout0^=xor0;\\r\\ntout1^=xor1;\\r\\nif(l < 0)\\r\\n{\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\n}\\r\\nelse\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nxor0=t0;\\r\\nxor1=t1;\\r\\n}\\r\\niv1=&(*ivec1)[0];\\r\\nl2c(m0,iv1);\\r\\nl2c(m1,iv1);\\r\\niv2=&(*ivec2)[0];\\r\\nl2c(xor0,iv2);\\r\\nl2c(xor1,iv2);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_sign_c", "target": 0, "func": "int ASN1_sign(int (*i2d)(), X509_ALGOR *algor1, X509_ALGOR *algor2,\\r\\nASN1_BIT_STRING *signature, char *data, EVP_PKEY *pkey,\\r\\nconst EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *p,*buf_in=NULL,*buf_out=NULL;\\r\\nint i,inl=0,outl=0,outll=0;\\r\\nX509_ALGOR *a;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nif (i == 0)\\r\\na=algor1;\\r\\nelse\\r\\na=algor2;\\r\\nif (a == NULL) continue;\\r\\nif ( (a->parameter == NULL) ||\\r\\n(a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\nif ((a->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=OBJ_nid2obj(type->pkey_type);\\r\\nif (a->algorithm == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_SIGN,ASN1_R_UNKNOWN_OBJECT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a->algorithm->length == 0)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_SIGN,ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ninl=i2d(data,NULL);\\r\\nbuf_in=(unsigned char *)Malloc((unsigned int)inl);\\r\\noutll=outl=EVP_PKEY_size(pkey);\\r\\nbuf_out=(unsigned char *)Malloc((unsigned int)outl);\\r\\nif ((buf_in == NULL) || (buf_out == NULL))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_SIGN,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf_in;\\r\\ni2d(data,&p);\\r\\nEVP_SignInit(&ctx,type);\\r\\nEVP_SignUpdate(&ctx,(unsigned char *)buf_in,inl);\\r\\nif (!EVP_SignFinal(&ctx,(unsigned char *)buf_out,\\r\\n(unsigned int *)&outl,pkey))\\r\\n{\\r\\noutl=0;\\r\\nASN1err(ASN1_F_ASN1_SIGN,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->data != NULL) Free((char *)signature->data);\\r\\nsignature->data=buf_out;\\r\\nbuf_out=NULL;\\r\\nsignature->length=outl;\\r\\nsignature->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\nsignature->flags|=ASN1_STRING_FLAG_BITS_LEFT;\\r\\nerr:\\r\\nmemset(&ctx,0,sizeof(ctx));\\r\\nif (buf_in != NULL)\\r\\n{ memset((char *)buf_in,0,(unsigned int)inl); Free((char *)buf_in); }\\r\\nif (buf_out != NULL)\\r\\n{ memset((char *)buf_out,0,outll); Free((char *)buf_out); }\\r\\nreturn(outl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_c_c", "target": 0, "func": "EVP_CIPHER *EVP_cast5_ofb(void)\\r\\n{\\r\\nreturn(&cast5_ofb_cipher);\\r\\n}\\r\\nstatic void cast_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nCAST_set_key(&(ctx->c.cast_ks),EVP_CAST5_KEY_SIZE,key);\\r\\n}\\r\\nstatic void cast_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nCAST_ofb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.cast_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha1dgst_c", "target": 0, "func": "void SHA1_Init(SHA_CTX *c)\\r\\n{\\r\\nc->h0=INIT_DATA_h0;\\r\\nc->h1=INIT_DATA_h1;\\r\\nc->h2=INIT_DATA_h2;\\r\\nc->h3=INIT_DATA_h3;\\r\\nc->h4=INIT_DATA_h4;\\r\\nc->Nl=0;\\r\\nc->Nh=0;\\r\\nc->num=0;\\r\\n}\\r\\nvoid SHA1_Update(SHA_CTX *c, register const unsigned char *data,\\r\\nunsigned long len)\\r\\n{\\r\\nregister SHA_LONG *p;\\r\\nint ew,ec,sw,sc;\\r\\nSHA_LONG l;\\r\\nif (len == 0) return;\\r\\nl=(c->Nl+(len<<3))&0xffffffffL;\\r\\nif (l < c->Nl)\\r\\nc->Nh++;\\r\\nc->Nh+=(len>>29);\\r\\nc->Nl=l;\\r\\nif (c->num != 0)\\r\\n{\\r\\np=c->data;\\r\\nsw=c->num>>2;\\r\\nsc=c->num&0x03;\\r\\nif ((c->num+len) >= SHA_CBLOCK)\\r\\n{\\r\\nl= p[sw];\\r\\nM_p_c2nl(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw<SHA_LBLOCK; sw++)\\r\\n{\\r\\nM_c2nl(data,l);\\r\\np[sw]=l;\\r\\n}\\r\\nlen-=(SHA_CBLOCK-c->num);\\r\\nsha1_block(c,p,1);\\r\\nc->num=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nc->num+=(int)len;\\r\\nif ((sc+len) < 4)\\r\\n{\\r\\nl= p[sw];\\r\\nM_p_c2nl_p(data,l,sc,len);\\r\\np[sw]=l;\\r\\n}\\r\\nelse\\r\\n{\\r\\new=(c->num>>2);\\r\\nec=(c->num&0x03);\\r\\nl= p[sw];\\r\\nM_p_c2nl(data,l,sc);\\r\\np[sw++]=l;\\r\\nfor (; sw < ew; sw++)\\r\\n{ M_c2nl(data,l); p[sw]=l; }\\r\\nif (ec)\\r\\n{\\r\\nM_c2nl_p(data,l,ec);\\r\\np[sw]=l;\\r\\n}\\r\\n}\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA1_ASM)\\r\\nif ((((unsigned long)data)%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nsw=len/SHA_CBLOCK;\\r\\nif (sw)\\r\\n{\\r\\nsha1_block(c,(SHA_LONG *)data,sw);\\r\\nsw*=SHA_CBLOCK;\\r\\ndata+=sw;\\r\\nlen-=sw;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\np=c->data;\\r\\nwhile (len >= SHA_CBLOCK)\\r\\n{\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA1_ASM)\\r\\n#define SHA_NO_TAIL_CODE\\r\\nif (p != (SHA_LONG *)data)\\r\\nmemcpy(p,data,SHA_CBLOCK);\\r\\ndata+=SHA_CBLOCK;\\r\\nsha1_block(c,p=c->data,1);\\r\\nlen-=SHA_CBLOCK;\\r\\n#elif defined(L_ENDIAN)\\r\\n#define BE_COPY(dst,src,i) { \\\\r\\nl = ((SHA_LONG *)src)[i]; \\\\r\\nEndian_Reverse32(l); \\\\r\\ndst[i] = l; \\\\r\\n}\\r\\nif ((((unsigned long)data)%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nfor (sw=(SHA_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nBE_COPY(p,data,0);\\r\\nBE_COPY(p,data,1);\\r\\nBE_COPY(p,data,2);\\r\\nBE_COPY(p,data,3);\\r\\np+=4;\\r\\ndata += 4*sizeof(SHA_LONG);\\r\\n}\\r\\nsha1_block(c,p=c->data,1);\\r\\nlen-=SHA_CBLOCK;\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\n#ifndef SHA_NO_TAIL_CODE\\r\\np=c->data;\\r\\nfor (sw=(SHA_LBLOCK/4); sw; sw--)\\r\\n{\\r\\nM_c2nl(data,l); p[0]=l;\\r\\nM_c2nl(data,l); p[1]=l;\\r\\nM_c2nl(data,l); p[2]=l;\\r\\nM_c2nl(data,l); p[3]=l;\\r\\np+=4;\\r\\n}\\r\\np=c->data;\\r\\nsha1_block(c,p,1);\\r\\nlen-=SHA_CBLOCK;\\r\\n#endif\\r\\n}\\r\\nec=(int)len;\\r\\nc->num=ec;\\r\\new=(ec>>2);\\r\\nec&=0x03;\\r\\nfor (sw=0; sw < ew; sw++)\\r\\n{ M_c2nl(data,l); p[sw]=l; }\\r\\nM_c2nl_p(data,l,ec);\\r\\np[sw]=l;\\r\\n}\\r\\nvoid SHA1_Transform(SHA_CTX *c, unsigned char *b)\\r\\n{\\r\\nSHA_LONG p[SHA_LBLOCK];\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if defined(B_ENDIAN) || defined(SHA1_ASM)\\r\\nmemcpy(p,b,SHA_CBLOCK);\\r\\nsha1_block(c,p,1);\\r\\nreturn;\\r\\n#elif defined(L_ENDIAN)\\r\\nif (((unsigned long)b%sizeof(SHA_LONG)) == 0)\\r\\n{\\r\\nSHA_LONG *q;\\r\\nint i;\\r\\nq=p;\\r\\nfor (i=(SHA_LBLOCK/4); i; i--)\\r\\n{\\r\\nunsigned long l;\\r\\nBE_COPY(q,b,0);\\r\\nBE_COPY(q,b,1);\\r\\nBE_COPY(q,b,2);\\r\\nBE_COPY(q,b,3);\\r\\nq+=4;\\r\\nb+=4*sizeof(SHA_LONG);\\r\\n}\\r\\nsha1_block(c,p,1);\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\n#ifndef SHA_NO_TAIL_CODE\\r\\n{\\r\\nSHA_LONG *q;\\r\\nint i;\\r\\nq=p;\\r\\nfor (i=(SHA_LBLOCK/4); i; i--)\\r\\n{\\r\\nSHA_LONG l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\nc2nl(b,l); *(q++)=l;\\r\\n}\\r\\nsha1_block(c,p,1);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void sha1_block(SHA_CTX *c, register SHA_LONG *W, int num)\\r\\n{\\r\\nregister SHA_LONG A,B,C,D,E,T;\\r\\nSHA_LONG X[SHA_LBLOCK];\\r\\nA=c->h0;\\r\\nB=c->h1;\\r\\nC=c->h2;\\r\\nD=c->h3;\\r\\nE=c->h4;\\r\\nfor (;;)\\r\\n{\\r\\nBODY_00_15( 0,A,B,C,D,E,T,W);\\r\\nBODY_00_15( 1,T,A,B,C,D,E,W);\\r\\nBODY_00_15( 2,E,T,A,B,C,D,W);\\r\\nBODY_00_15( 3,D,E,T,A,B,C,W);\\r\\nBODY_00_15( 4,C,D,E,T,A,B,W);\\r\\nBODY_00_15( 5,B,C,D,E,T,A,W);\\r\\nBODY_00_15( 6,A,B,C,D,E,T,W);\\r\\nBODY_00_15( 7,T,A,B,C,D,E,W);\\r\\nBODY_00_15( 8,E,T,A,B,C,D,W);\\r\\nBODY_00_15( 9,D,E,T,A,B,C,W);\\r\\nBODY_00_15(10,C,D,E,T,A,B,W);\\r\\nBODY_00_15(11,B,C,D,E,T,A,W);\\r\\nBODY_00_15(12,A,B,C,D,E,T,W);\\r\\nBODY_00_15(13,T,A,B,C,D,E,W);\\r\\nBODY_00_15(14,E,T,A,B,C,D,W);\\r\\nBODY_00_15(15,D,E,T,A,B,C,W);\\r\\nBODY_16_19(16,C,D,E,T,A,B,W,W,W,W);\\r\\nBODY_16_19(17,B,C,D,E,T,A,W,W,W,W);\\r\\nBODY_16_19(18,A,B,C,D,E,T,W,W,W,W);\\r\\nBODY_16_19(19,T,A,B,C,D,E,W,W,W,X);\\r\\nBODY_20_31(20,E,T,A,B,C,D,W,W,W,X);\\r\\nBODY_20_31(21,D,E,T,A,B,C,W,W,W,X);\\r\\nBODY_20_31(22,C,D,E,T,A,B,W,W,W,X);\\r\\nBODY_20_31(23,B,C,D,E,T,A,W,W,W,X);\\r\\nBODY_20_31(24,A,B,C,D,E,T,W,W,X,X);\\r\\nBODY_20_31(25,T,A,B,C,D,E,W,W,X,X);\\r\\nBODY_20_31(26,E,T,A,B,C,D,W,W,X,X);\\r\\nBODY_20_31(27,D,E,T,A,B,C,W,W,X,X);\\r\\nBODY_20_31(28,C,D,E,T,A,B,W,W,X,X);\\r\\nBODY_20_31(29,B,C,D,E,T,A,W,W,X,X);\\r\\nBODY_20_31(30,A,B,C,D,E,T,W,X,X,X);\\r\\nBODY_20_31(31,T,A,B,C,D,E,W,X,X,X);\\r\\nBODY_32_39(32,E,T,A,B,C,D,X);\\r\\nBODY_32_39(33,D,E,T,A,B,C,X);\\r\\nBODY_32_39(34,C,D,E,T,A,B,X);\\r\\nBODY_32_39(35,B,C,D,E,T,A,X);\\r\\nBODY_32_39(36,A,B,C,D,E,T,X);\\r\\nBODY_32_39(37,T,A,B,C,D,E,X);\\r\\nBODY_32_39(38,E,T,A,B,C,D,X);\\r\\nBODY_32_39(39,D,E,T,A,B,C,X);\\r\\nBODY_40_59(40,C,D,E,T,A,B,X);\\r\\nBODY_40_59(41,B,C,D,E,T,A,X);\\r\\nBODY_40_59(42,A,B,C,D,E,T,X);\\r\\nBODY_40_59(43,T,A,B,C,D,E,X);\\r\\nBODY_40_59(44,E,T,A,B,C,D,X);\\r\\nBODY_40_59(45,D,E,T,A,B,C,X);\\r\\nBODY_40_59(46,C,D,E,T,A,B,X);\\r\\nBODY_40_59(47,B,C,D,E,T,A,X);\\r\\nBODY_40_59(48,A,B,C,D,E,T,X);\\r\\nBODY_40_59(49,T,A,B,C,D,E,X);\\r\\nBODY_40_59(50,E,T,A,B,C,D,X);\\r\\nBODY_40_59(51,D,E,T,A,B,C,X);\\r\\nBODY_40_59(52,C,D,E,T,A,B,X);\\r\\nBODY_40_59(53,B,C,D,E,T,A,X);\\r\\nBODY_40_59(54,A,B,C,D,E,T,X);\\r\\nBODY_40_59(55,T,A,B,C,D,E,X);\\r\\nBODY_40_59(56,E,T,A,B,C,D,X);\\r\\nBODY_40_59(57,D,E,T,A,B,C,X);\\r\\nBODY_40_59(58,C,D,E,T,A,B,X);\\r\\nBODY_40_59(59,B,C,D,E,T,A,X);\\r\\nBODY_60_79(60,A,B,C,D,E,T,X);\\r\\nBODY_60_79(61,T,A,B,C,D,E,X);\\r\\nBODY_60_79(62,E,T,A,B,C,D,X);\\r\\nBODY_60_79(63,D,E,T,A,B,C,X);\\r\\nBODY_60_79(64,C,D,E,T,A,B,X);\\r\\nBODY_60_79(65,B,C,D,E,T,A,X);\\r\\nBODY_60_79(66,A,B,C,D,E,T,X);\\r\\nBODY_60_79(67,T,A,B,C,D,E,X);\\r\\nBODY_60_79(68,E,T,A,B,C,D,X);\\r\\nBODY_60_79(69,D,E,T,A,B,C,X);\\r\\nBODY_60_79(70,C,D,E,T,A,B,X);\\r\\nBODY_60_79(71,B,C,D,E,T,A,X);\\r\\nBODY_60_79(72,A,B,C,D,E,T,X);\\r\\nBODY_60_79(73,T,A,B,C,D,E,X);\\r\\nBODY_60_79(74,E,T,A,B,C,D,X);\\r\\nBODY_60_79(75,D,E,T,A,B,C,X);\\r\\nBODY_60_79(76,C,D,E,T,A,B,X);\\r\\nBODY_60_79(77,B,C,D,E,T,A,X);\\r\\nBODY_60_79(78,A,B,C,D,E,T,X);\\r\\nBODY_60_79(79,T,A,B,C,D,E,X);\\r\\nc->h0=(c->h0+E)&0xffffffffL;\\r\\nc->h1=(c->h1+T)&0xffffffffL;\\r\\nc->h2=(c->h2+A)&0xffffffffL;\\r\\nc->h3=(c->h3+B)&0xffffffffL;\\r\\nc->h4=(c->h4+C)&0xffffffffL;\\r\\nif (--num <= 0) break;\\r\\nA=c->h0;\\r\\nB=c->h1;\\r\\nC=c->h2;\\r\\nD=c->h3;\\r\\nE=c->h4;\\r\\nW+=SHA_LBLOCK;\\r\\n}\\r\\n}\\r\\nvoid SHA1_Final(unsigned char *md, SHA_CTX *c)\\r\\n{\\r\\nregister int i,j;\\r\\nregister SHA_LONG l;\\r\\nregister SHA_LONG *p;\\r\\nstatic unsigned char end[4]={0x80,0x00,0x00,0x00};\\r\\nunsigned char *cp=end;\\r\\np=c->data;\\r\\nj=c->num;\\r\\ni=j>>2;\\r\\n#ifdef PURIFY\\r\\nif ((j&0x03) == 0) p[i]=0;\\r\\n#endif\\r\\nl=p[i];\\r\\nM_p_c2nl(cp,l,j&0x03);\\r\\np[i]=l;\\r\\ni++;\\r\\nif (c->num >= SHA_LAST_BLOCK)\\r\\n{\\r\\nfor (; i<SHA_LBLOCK; i++)\\r\\np[i]=0;\\r\\nsha1_block(c,p,1);\\r\\ni=0;\\r\\n}\\r\\nfor (; i<(SHA_LBLOCK-2); i++)\\r\\np[i]=0;\\r\\np[SHA_LBLOCK-2]=c->Nh;\\r\\np[SHA_LBLOCK-1]=c->Nl;\\r\\n#if SHA_LONG_LOG2==2\\r\\n#if !defined(B_ENDIAN) && defined(SHA1_ASM)\\r\\nEndian_Reverse32(p[SHA_LBLOCK-2]);\\r\\nEndian_Reverse32(p[SHA_LBLOCK-1]);\\r\\n#endif\\r\\n#endif\\r\\nsha1_block(c,p,1);\\r\\ncp=md;\\r\\nl=c->h0; nl2c(l,cp);\\r\\nl=c->h1; nl2c(l,cp);\\r\\nl=c->h2; nl2c(l,cp);\\r\\nl=c->h3; nl2c(l,cp);\\r\\nl=c->h4; nl2c(l,cp);\\r\\nc->num=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_b64_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar **argv;\\r\\n{\\r\\nchar *strbuf=NULL;\\r\\nunsigned char *buff=NULL,*bufsize=NULL;\\r\\nint bsize=BSIZE,verbose=0;\\r\\nint ret=1,inl;\\r\\nunsigned char key[24],iv[MD5_DIGEST_LENGTH];\\r\\nchar *str=NULL;\\r\\nchar *hkey=NULL,*hiv=NULL;\\r\\nint enc=1,printkey=0,i,base64=0;\\r\\nint debug=0;\\r\\nEVP_CIPHER *cipher=NULL,*c;\\r\\nchar *inf=NULL,*outf=NULL;\\r\\nBIO *in=NULL,*out=NULL,*b64=NULL,*benc=NULL,*rbio=NULL,*wbio=NULL;\\r\\n#define PROG_NAME_SIZE 16\\r\\nchar pname[PROG_NAME_SIZE];\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE);\\r\\nbase64=1;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-e\") == 0)\\r\\nenc=1;\\r\\nif (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninf= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutf= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-d\") == 0)\\r\\nenc=0;\\r\\nelse if (strcmp(*argv,\"-v\") == 0)\\r\\nverbose=1;\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\ndebug=1;\\r\\nelse if (strcmp(*argv,\"-bufsize\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nbufsize=(unsigned char *)*(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option '%s'\\n\",*argv);\\r\\nbad:\\r\\nBIO_printf(bio_err,\"options are\\n\");\\r\\nBIO_printf(bio_err,\"%-14s input file\\n\",\"-in <file>\");\\r\\nBIO_printf(bio_err,\"%-14s output file\\n\",\"-out <file>\");\\r\\nBIO_printf(bio_err,\"%-14s encode\\n\",\"-e\");\\r\\nBIO_printf(bio_err,\"%-14s decode\\n\",\"-d\");\\r\\nBIO_printf(bio_err,\"%-14s buffer size\\n\",\"-bufsize <n>\");\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (bufsize != NULL)\\r\\n{\\r\\nint i;\\r\\nunsigned long n;\\r\\nfor (n=0; *bufsize; bufsize++)\\r\\n{\\r\\ni= *bufsize;\\r\\nif ((i <= '9') && (i >= '0'))\\r\\nn=n*10+i-'0';\\r\\nelse if (i == 'k')\\r\\n{\\r\\nn*=1024;\\r\\nbufsize++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (*bufsize != '\\0')\\r\\n{\\r\\nBIO_printf(bio_err,\"invalid 'bufsize' specified.\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (n < 80) n=80;\\r\\nbsize=(int)n;\\r\\nif (verbose) BIO_printf(bio_err,\"bufsize=%d\\n\",bsize);\\r\\n}\\r\\nstrbuf=Malloc(SIZE);\\r\\nbuff=(unsigned char *)Malloc(EVP_ENCODE_LENGTH(bsize));\\r\\nif ((buff == NULL) || (strbuf == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(in,BIO_debug_callback);\\r\\nBIO_set_callback(out,BIO_debug_callback);\\r\\nBIO_set_callback_arg(in,bio_err);\\r\\nBIO_set_callback_arg(out,bio_err);\\r\\n}\\r\\nif (inf == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,inf) <= 0)\\r\\n{\\r\\nperror(inf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outf == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outf) <= 0)\\r\\n{\\r\\nperror(outf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrbio=in;\\r\\nwbio=out;\\r\\nif (base64)\\r\\n{\\r\\nif ((b64=BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(b64,BIO_debug_callback);\\r\\nBIO_set_callback_arg(b64,bio_err);\\r\\n}\\r\\nif (enc)\\r\\nwbio=BIO_push(b64,wbio);\\r\\nelse\\r\\nrbio=BIO_push(b64,rbio);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ninl=BIO_read(rbio,(char *)buff,bsize);\\r\\nif (inl <= 0) break;\\r\\nif (BIO_write(wbio,(char *)buff,inl) != inl)\\r\\n{\\r\\nBIO_printf(bio_err,\"error writing output file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_flush(wbio);\\r\\nret=0;\\r\\nif (verbose)\\r\\n{\\r\\nBIO_printf(bio_err,\"bytes read :%8ld\\n\",BIO_number_read(in));\\r\\nBIO_printf(bio_err,\"bytes written:%8ld\\n\",BIO_number_written(out));\\r\\n}\\r\\nend:\\r\\nif (strbuf != NULL) Free(strbuf);\\r\\nif (buff != NULL) Free(buff);\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (benc != NULL) BIO_free(benc);\\r\\nif (b64 != NULL) BIO_free(b64);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_digest_c", "target": 0, "func": "int ASN1_digest(int (*i2d)(), EVP_MD *type, char *data, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nint i;\\r\\nunsigned char *str,*p;\\r\\ni=i2d(data,NULL);\\r\\nif ((str=(unsigned char *)Malloc(i)) == NULL) return(0);\\r\\np=str;\\r\\ni2d(data,&p);\\r\\nEVP_DigestInit(&ctx,type);\\r\\nEVP_DigestUpdate(&ctx,str,i);\\r\\nEVP_DigestFinal(&ctx,md,len);\\r\\nFree(str);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_des_opts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic des_cblock key ={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nstatic des_cblock key2={0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12};\\r\\nstatic des_cblock key3={0x56,0x78,0x9a,0xbc,0xde,0xf0,0x12,0x34};\\r\\ndes_key_schedule sch,sch2,sch3;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most acurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\ndes_set_key(&key,sch);\\r\\ndes_set_key(&key2,sch2);\\r\\ndes_set_key(&key3,sch3);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\ndes_set_key(&key,sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\ndes_encrypt(data,&(sch[0]),DES_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\n#ifdef PART1\\r\\ntime_it(des_encrypt_u4_cisc_idx, \"des_encrypt_u4_cisc_idx \", 0);\\r\\ntime_it(des_encrypt_u16_cisc_idx, \"des_encrypt_u16_cisc_idx \", 1);\\r\\ntime_it(des_encrypt_u4_risc1_idx, \"des_encrypt_u4_risc1_idx \", 2);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART2\\r\\ntime_it(des_encrypt_u16_risc1_idx,\"des_encrypt_u16_risc1_idx\", 3);\\r\\ntime_it(des_encrypt_u4_risc2_idx, \"des_encrypt_u4_risc2_idx \", 4);\\r\\ntime_it(des_encrypt_u16_risc2_idx,\"des_encrypt_u16_risc2_idx\", 5);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART3\\r\\ntime_it(des_encrypt_u4_cisc_ptr, \"des_encrypt_u4_cisc_ptr \", 6);\\r\\ntime_it(des_encrypt_u16_cisc_ptr, \"des_encrypt_u16_cisc_ptr \", 7);\\r\\ntime_it(des_encrypt_u4_risc1_ptr, \"des_encrypt_u4_risc1_ptr \", 8);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART4\\r\\ntime_it(des_encrypt_u16_risc1_ptr,\"des_encrypt_u16_risc1_ptr\", 9);\\r\\ntime_it(des_encrypt_u4_risc2_ptr, \"des_encrypt_u4_risc2_ptr \",10);\\r\\ntime_it(des_encrypt_u16_risc2_ptr,\"des_encrypt_u16_risc2_ptr\",11);\\r\\nnum+=3;\\r\\n#endif\\r\\n#ifdef PART1\\r\\nstr[0]=\" 4 c i\";\\r\\nprint_it(\"des_encrypt_u4_cisc_idx \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"16 c i\";\\r\\nprint_it(\"des_encrypt_u16_cisc_idx \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\" 4 r1 i\";\\r\\nprint_it(\"des_encrypt_u4_risc1_idx \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\n#endif\\r\\n#ifdef PART2\\r\\nstr[3]=\"16 r1 i\";\\r\\nprint_it(\"des_encrypt_u16_risc1_idx\",3);\\r\\nif (max < tm[3]) { max=tm[3]; max_idx=3; }\\r\\nstr[4]=\" 4 r2 i\";\\r\\nprint_it(\"des_encrypt_u4_risc2_idx \",4);\\r\\nif (max < tm[4]) { max=tm[4]; max_idx=4; }\\r\\nstr[5]=\"16 r2 i\";\\r\\nprint_it(\"des_encrypt_u16_risc2_idx\",5);\\r\\nif (max < tm[5]) { max=tm[5]; max_idx=5; }\\r\\n#endif\\r\\n#ifdef PART3\\r\\nstr[6]=\" 4 c p\";\\r\\nprint_it(\"des_encrypt_u4_cisc_ptr \",6);\\r\\nif (max < tm[6]) { max=tm[6]; max_idx=6; }\\r\\nstr[7]=\"16 c p\";\\r\\nprint_it(\"des_encrypt_u16_cisc_ptr \",7);\\r\\nif (max < tm[7]) { max=tm[7]; max_idx=7; }\\r\\nstr[8]=\" 4 r1 p\";\\r\\nprint_it(\"des_encrypt_u4_risc1_ptr \",8);\\r\\nif (max < tm[8]) { max=tm[8]; max_idx=8; }\\r\\n#endif\\r\\n#ifdef PART4\\r\\nstr[9]=\"16 r1 p\";\\r\\nprint_it(\"des_encrypt_u16_risc1_ptr\",9);\\r\\nif (max < tm[9]) { max=tm[9]; max_idx=9; }\\r\\nstr[10]=\" 4 r2 p\";\\r\\nprint_it(\"des_encrypt_u4_risc2_ptr \",10);\\r\\nif (max < tm[10]) { max=tm[10]; max_idx=10; }\\r\\nstr[11]=\"16 r2 p\";\\r\\nprint_it(\"des_encrypt_u16_risc2_ptr\",11);\\r\\nif (max < tm[11]) { max=tm[11]; max_idx=11; }\\r\\n#endif\\r\\nprintf(\"options des ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DDES_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DDES_UNROLL\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DDES_RISC1\\n\");\\r\\nbreak;\\r\\ncase 3:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC1\\n\");\\r\\nbreak;\\r\\ncase 4:\\r\\nprintf(\"-DDES_RISC2\\n\");\\r\\nbreak;\\r\\ncase 5:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC2\\n\");\\r\\nbreak;\\r\\ncase 6:\\r\\nprintf(\"-DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 7:\\r\\nprintf(\"-DDES_UNROLL -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 8:\\r\\nprintf(\"-DDES_RISC1 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 9:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC1 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 10:\\r\\nprintf(\"-DDES_RISC2 -DDES_PTR\\n\");\\r\\nbreak;\\r\\ncase 11:\\r\\nprintf(\"-DDES_UNROLL -DDES_RISC2 -DDES_PTR\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md5_one_c", "target": 0, "func": "unsigned char *MD5(unsigned char *d, unsigned long n, unsigned char *md)\\r\\n{\\r\\nMD5_CTX c;\\r\\nstatic unsigned char m[MD5_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nMD5_Init(&c);\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD5_Update(&c,d,n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0)\\r\\n{\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD5_Update(&c,temp,chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD5_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_shift_c", "target": 0, "func": "int BN_lshift1(BIGNUM *r, BIGNUM *a)\\r\\n{\\r\\nregister BN_ULONG *ap,*rp,t,c;\\r\\nint i;\\r\\nif (r != a)\\r\\n{\\r\\nr->neg=a->neg;\\r\\nif (bn_wexpand(r,a->top+1) == NULL) return(0);\\r\\nr->top=a->top;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bn_wexpand(r,a->top+1) == NULL) return(0);\\r\\n}\\r\\nap=a->d;\\r\\nrp=r->d;\\r\\nc=0;\\r\\nfor (i=0; i<a->top; i++)\\r\\n{\\r\\nt= *(ap++);\\r\\n*(rp++)=((t<<1)|c)&BN_MASK2;\\r\\nc=(t & BN_TBIT)?1:0;\\r\\n}\\r\\nif (c)\\r\\n{\\r\\n*rp=1;\\r\\nr->top++;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint BN_rshift1(BIGNUM *r, BIGNUM *a)\\r\\n{\\r\\nBN_ULONG *ap,*rp,t,c;\\r\\nint i;\\r\\nif (BN_is_zero(a))\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\nif (a != r)\\r\\n{\\r\\nif (bn_wexpand(r,a->top) == NULL) return(0);\\r\\nr->top=a->top;\\r\\nr->neg=a->neg;\\r\\n}\\r\\nap=a->d;\\r\\nrp=r->d;\\r\\nc=0;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt=ap[i];\\r\\nrp[i]=((t>>1)&BN_MASK2)|c;\\r\\nc=(t&1)?BN_TBIT:0;\\r\\n}\\r\\nbn_fix_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_lshift(BIGNUM *r, const BIGNUM *a, int n)\\r\\n{\\r\\nint i,nw,lb,rb;\\r\\nBN_ULONG *t,*f;\\r\\nBN_ULONG l;\\r\\nr->neg=a->neg;\\r\\nif (bn_wexpand(r,a->top+(n/BN_BITS2)+1) == NULL) return(0);\\r\\nnw=n/BN_BITS2;\\r\\nlb=n%BN_BITS2;\\r\\nrb=BN_BITS2-lb;\\r\\nf=a->d;\\r\\nt=r->d;\\r\\nt[a->top+nw]=0;\\r\\nif (lb == 0)\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\nt[nw+i]=f[i];\\r\\nelse\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nl=f[i];\\r\\nt[nw+i+1]|=(l>>rb)&BN_MASK2;\\r\\nt[nw+i]=(l<<lb)&BN_MASK2;\\r\\n}\\r\\nmemset(t,0,nw*sizeof(t[0]));\\r\\nr->top=a->top+nw+1;\\r\\nbn_fix_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_rshift(BIGNUM *r, BIGNUM *a, int n)\\r\\n{\\r\\nint i,j,nw,lb,rb;\\r\\nBN_ULONG *t,*f;\\r\\nBN_ULONG l,tmp;\\r\\nnw=n/BN_BITS2;\\r\\nrb=n%BN_BITS2;\\r\\nlb=BN_BITS2-rb;\\r\\nif (nw > a->top)\\r\\n{\\r\\nBN_zero(r);\\r\\nreturn(1);\\r\\n}\\r\\nif (r != a)\\r\\n{\\r\\nr->neg=a->neg;\\r\\nif (bn_wexpand(r,a->top-nw+1) == NULL) return(0);\\r\\n}\\r\\nf= &(a->d[nw]);\\r\\nt=r->d;\\r\\nj=a->top-nw;\\r\\nr->top=j;\\r\\nif (rb == 0)\\r\\n{\\r\\nfor (i=j+1; i > 0; i--)\\r\\n*(t++)= *(f++);\\r\\n}\\r\\nelse\\r\\n{\\r\\nl= *(f++);\\r\\nfor (i=1; i<j; i++)\\r\\n{\\r\\ntmp =(l>>rb)&BN_MASK2;\\r\\nl= *(f++);\\r\\n*(t++) =(tmp|(l<<lb))&BN_MASK2;\\r\\n}\\r\\n*(t++) =(l>>rb)&BN_MASK2;\\r\\n}\\r\\n*t=0;\\r\\nbn_fix_top(r);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_skey_c", "target": 0, "func": "void BF_set_key(BF_KEY *key, int len, unsigned char *data)\\r\\n{\\r\\nint i;\\r\\nBF_LONG *p,ri,in[2];\\r\\nunsigned char *d,*end;\\r\\nmemcpy((char *)key,(char *)&bf_init,sizeof(BF_KEY));\\r\\np=key->P;\\r\\nif (len > ((BF_ROUNDS+2)*4)) len=(BF_ROUNDS+2)*4;\\r\\nd=data;\\r\\nend= &(data[len]);\\r\\nfor (i=0; i<(BF_ROUNDS+2); i++)\\r\\n{\\r\\nri= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\nri<<=8;\\r\\nri|= *(d++);\\r\\nif (d >= end) d=data;\\r\\np[i]^=ri;\\r\\n}\\r\\nin[0]=0L;\\r\\nin[1]=0L;\\r\\nfor (i=0; i<(BF_ROUNDS+2); i+=2)\\r\\n{\\r\\nBF_encrypt(in,key);\\r\\np[i ]=in[0];\\r\\np[i+1]=in[1];\\r\\n}\\r\\np=key->S;\\r\\nfor (i=0; i<4*256; i+=2)\\r\\n{\\r\\nBF_encrypt(in,key);\\r\\np[i ]=in[0];\\r\\np[i+1]=in[1];\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cfb64enc_c", "target": 0, "func": "void des_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule schedule, des_cblock *ivec,\\r\\nint *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister long l=length;\\r\\nregister int n= *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\ndes_encrypt(ti,schedule,DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0=ti[0]; l2c(v0,iv);\\r\\nv0=ti[1]; l2c(v0,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\ndes_encrypt(ti,schedule,DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0=ti[0]; l2c(v0,iv);\\r\\nv0=ti[1]; l2c(v0,iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_lib_c", "target": 0, "func": "DH *DH_new(void)\\r\\n{\\r\\nDH *ret;\\r\\nret=(DH *)Malloc(sizeof(DH));\\r\\nif (ret == NULL)\\r\\n{\\r\\nDHerr(DH_F_DH_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->p=NULL;\\r\\nret->g=NULL;\\r\\nret->length=0;\\r\\nret->pub_key=NULL;\\r\\nret->priv_key=NULL;\\r\\nret->flags=DH_FLAG_CACHE_MONT_P;\\r\\nret->method_mont_p=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid DH_free(DH *r)\\r\\n{\\r\\nif(r == NULL) return;\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->g != NULL) BN_clear_free(r->g);\\r\\nif (r->pub_key != NULL) BN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL) BN_clear_free(r->priv_key);\\r\\nif (r->method_mont_p != NULL)\\r\\nBN_MONT_CTX_free((BN_MONT_CTX *)r->method_mont_p);\\r\\nFree(r);\\r\\n}\\r\\nint DH_size(DH *dh)\\r\\n{\\r\\nreturn(BN_num_bytes(dh->p));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ex_data_c", "target": 0, "func": "int CRYPTO_get_ex_new_index(int idx, STACK **skp, long argl, char *argp,\\r\\nint (*new_func)(), int (*dup_func)(), void (*free_func)())\\r\\n{\\r\\nint ret= -1;\\r\\nCRYPTO_EX_DATA_FUNCS *a;\\r\\nMemCheck_off();\\r\\nif (*skp == NULL)\\r\\n*skp=sk_new_null();\\r\\nif (*skp == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\na=(CRYPTO_EX_DATA_FUNCS *)Malloc(sizeof(CRYPTO_EX_DATA_FUNCS));\\r\\nif (a == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\na->argl=argl;\\r\\na->argp=argp;\\r\\na->new_func=new_func;\\r\\na->dup_func=dup_func;\\r\\na->free_func=free_func;\\r\\nwhile (sk_num(*skp) <= idx)\\r\\n{\\r\\nif (!sk_push(*skp,NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX,ERR_R_MALLOC_FAILURE);\\r\\nFree(a);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nsk_set(*skp,idx, (char *)a);\\r\\nret=idx;\\r\\nerr:\\r\\nMemCheck_on();\\r\\nreturn(idx);\\r\\n}\\r\\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, char *val)\\r\\n{\\r\\nint i;\\r\\nif (ad->sk == NULL)\\r\\n{\\r\\nif ((ad->sk=sk_new_null()) == NULL)\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\ni=sk_num(ad->sk);\\r\\nwhile (i <= idx)\\r\\n{\\r\\nif (!sk_push(ad->sk,NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\ni++;\\r\\n}\\r\\nsk_set(ad->sk,idx,val);\\r\\nreturn(1);\\r\\n}\\r\\nchar *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad, int idx)\\r\\n{\\r\\nif (ad->sk == NULL)\\r\\nreturn(0);\\r\\nelse if (idx >= sk_num(ad->sk))\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(sk_value(ad->sk,idx));\\r\\n}\\r\\nint CRYPTO_dup_ex_data(STACK *meth, CRYPTO_EX_DATA *to,\\r\\nCRYPTO_EX_DATA *from)\\r\\n{\\r\\nint i,j,m,r;\\r\\nCRYPTO_EX_DATA_FUNCS *mm;\\r\\nchar *from_d;\\r\\nif (meth == NULL) return(1);\\r\\nif (from->sk == NULL) return(1);\\r\\nm=sk_num(meth);\\r\\nj=sk_num(from->sk);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nfrom_d=CRYPTO_get_ex_data(from,i);\\r\\nif (i < m)\\r\\n{\\r\\nmm=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);\\r\\nif (mm->dup_func != NULL)\\r\\nr=mm->dup_func(to,from,(char **)&from_d,i,\\r\\nmm->argl,mm->argp);\\r\\n}\\r\\nCRYPTO_set_ex_data(to,i,from_d);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nvoid CRYPTO_free_ex_data(STACK *meth, char *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nCRYPTO_EX_DATA_FUNCS *m;\\r\\nchar *ptr;\\r\\nint i,max;\\r\\nif (meth != NULL)\\r\\n{\\r\\nmax=sk_num(meth);\\r\\nfor (i=0; i<max; i++)\\r\\n{\\r\\nm=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);\\r\\nif ((m != NULL) && (m->free_func != NULL))\\r\\n{\\r\\nptr=CRYPTO_get_ex_data(ad,i);\\r\\nm->free_func(obj,ptr,ad,i,m->argl,m->argp);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (ad->sk != NULL)\\r\\n{\\r\\nsk_free(ad->sk);\\r\\nad->sk=NULL;\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_new_ex_data(STACK *meth, char *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nCRYPTO_EX_DATA_FUNCS *m;\\r\\nchar *ptr;\\r\\nint i,max;\\r\\nad->sk=NULL;\\r\\nif (meth != NULL)\\r\\n{\\r\\nmax=sk_num(meth);\\r\\nfor (i=0; i<max; i++)\\r\\n{\\r\\nm=(CRYPTO_EX_DATA_FUNCS *)sk_value(meth,i);\\r\\nif ((m != NULL) && (m->new_func != NULL))\\r\\n{\\r\\nptr=CRYPTO_get_ex_data(ad,i);\\r\\nm->new_func(obj,ptr,ad,i,m->argl,m->argp);\\r\\n}\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_idea_spd_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nIDEA_KEY_SCHEDULE sch;\\r\\ndouble a,aa,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nidea_set_encrypt_key(key,&sch);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nIDEA_INT data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nidea_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/4;\\r\\ncca=count/200;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"idea_set_encrypt_key %ld times\\n\",ca);\\r\\n#define COND(d) (count <= (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing idea_set_encrypt_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\nidea_set_encrypt_key(key,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea idea_set_encrypt_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_set_decrypt_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_set_decrypt_key %ld times\\n\",cca);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cca); count+=4)\\r\\n{\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\nidea_set_decrypt_key(&sch,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea idea_set_decrypt_key's in %.2f seconds\\n\",count,d);\\r\\naa=((double)COUNT(cca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\nidea_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing idea_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing idea_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nidea_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),IDEA_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld idea_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"IDEA set_encrypt_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"IDEA set_decrypt_key per sec = %12.2f (%9.3fuS)\\n\",aa,1.0e6/aa);\\r\\nprintf(\"IDEA raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"IDEA cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pk12err_c", "target": 0, "func": "void ERR_load_PKCS12_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_PKCS12,PKCS12_str_functs);\\r\\nERR_load_strings(ERR_LIB_PKCS12,PKCS12_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ofb64ede_c", "target": 0, "func": "void des_ede3_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length, des_key_schedule k1,\\r\\ndes_key_schedule k2, des_key_schedule k3, des_cblock *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister DES_LONG v0,v1;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\ndes_cblock d;\\r\\nregister char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\ndes_encrypt3(ti,k1,k2,k3);\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\ndp=(char *)d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_gendsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar buffer[200];\\r\\nDSA *dsa=NULL;\\r\\nint ret=1;\\r\\nchar *outfile=NULL;\\r\\nchar *inrand=NULL,*randfile,*dsaparams=NULL;\\r\\nBIO *out=NULL,*in=NULL;\\r\\nEVP_CIPHER *enc=NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-\") == 0)\\r\\ngoto bad;\\r\\n#ifndef NO_DES\\r\\nelse if (strcmp(*argv,\"-des\") == 0)\\r\\nenc=EVP_des_cbc();\\r\\nelse if (strcmp(*argv,\"-des3\") == 0)\\r\\nenc=EVP_des_ede3_cbc();\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nelse if (strcmp(*argv,\"-idea\") == 0)\\r\\nenc=EVP_idea_cbc();\\r\\n#endif\\r\\nelse if (**argv != '-' && dsaparams == NULL)\\r\\n{\\r\\ndsaparams = *argv;\\r\\n}\\r\\nelse\\r\\ngoto bad;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif (dsaparams == NULL)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: gendsa [args] dsaparam-file\\n\");\\r\\nBIO_printf(bio_err,\" -out file - output the key to 'file'\\n\");\\r\\n#ifndef NO_DES\\r\\nBIO_printf(bio_err,\" -des - encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\" -des3 - encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea - encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -rand file:file:...\\n\");\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\" dsaparam-file\\n\");\\r\\nBIO_printf(bio_err,\" - a DSA parameter file as generated by the dsaparam command\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (!(BIO_read_filename(in,dsaparams)))\\r\\n{\\r\\nperror(dsaparams);\\r\\ngoto end;\\r\\n}\\r\\nif ((dsa=PEM_read_bio_DSAparams(in,NULL,NULL,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load DSA parameter file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_free(in);\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL) goto end;\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrandfile=RAND_file_name(buffer,200);\\r\\nif ((randfile == NULL)|| !RAND_load_file(randfile,1024L*1024L))\\r\\nBIO_printf(bio_err,\"unable to load 'random state'\\n\");\\r\\nif (inrand == NULL)\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\ndsa_load_rand(inrand));\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating DSA key, %d bits\\n\",\\r\\nBN_num_bits(dsa->p));\\r\\nif (!DSA_generate_key(dsa)) goto end;\\r\\nif (randfile == NULL)\\r\\nBIO_printf(bio_err,\"unable to write 'random state'\\n\");\\r\\nelse\\r\\nRAND_write_file(randfile);\\r\\nif (!PEM_write_bio_DSAPrivateKey(out,dsa,enc,NULL,0,NULL,NULL))\\r\\ngoto end;\\r\\nret=0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (dsa != NULL) DSA_free(dsa);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic long dsa_load_rand(char *name)\\r\\n{\\r\\nchar *p,*n;\\r\\nint last;\\r\\nlong tot=0;\\r\\nfor (;;)\\r\\n{\\r\\nlast=0;\\r\\nfor (p=name; ((*p != '\\0') && (*p != LIST_SEPARATOR_CHAR)); p++);\\r\\nif (*p == '\\0') last=1;\\r\\n*p='\\0';\\r\\nn=name;\\r\\nname=p+1;\\r\\nif (*n == '\\0') break;\\r\\ntot+=RAND_load_file(n,1);\\r\\nif (last) break;\\r\\n}\\r\\nreturn(tot);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_conf_c", "target": 0, "func": "X509_EXTENSION *X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\nX509_EXTENSION *ret;\\r\\ncrit = v3_check_critical(&value);\\r\\nif((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(name, value, crit, ext_type);\\r\\nret = do_ext_conf(conf, ctx, OBJ_sn2nid(name), crit, value);\\r\\nif(!ret) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_ERROR_IN_EXTENSION);\\r\\nERR_add_error_data(4,\"name=\", name, \", value=\", value);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\ncrit = v3_check_critical(&value);\\r\\nif((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(OBJ_nid2sn(ext_nid),\\r\\nvalue, crit, ext_type);\\r\\nreturn do_ext_conf(conf, ctx, ext_nid, crit, value);\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_conf(LHASH *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nint crit, char *value)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nX509_EXTENSION *ext;\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nvoid *ext_struc;\\r\\nif(ext_nid == NID_undef) {\\r\\nX509V3err(X509V3_F_DO_EXT_CONF,X509V3_R_UNKNOWN_EXTENSION_NAME);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(method = X509V3_EXT_get_nid(ext_nid))) {\\r\\nX509V3err(X509V3_F_DO_EXT_CONF,X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nif(method->v2i) {\\r\\nif(*value == '@') nval = CONF_get_section(conf, value + 1);\\r\\nelse nval = X509V3_parse_list(value);\\r\\nif(!nval) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_INVALID_EXTENSION_STRING);\\r\\nERR_add_error_data(4, \"name=\", OBJ_nid2sn(ext_nid), \",section=\", value);\\r\\nreturn NULL;\\r\\n}\\r\\next_struc = method->v2i(method, ctx, nval);\\r\\nif(*value != '@') sk_CONF_VALUE_pop_free(nval,\\r\\nX509V3_conf_free);\\r\\nif(!ext_struc) return NULL;\\r\\n} else if(method->s2i) {\\r\\nif(!(ext_struc = method->s2i(method, ctx, value))) return NULL;\\r\\n} else if(method->r2i) {\\r\\nif(!ctx->db) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_NO_CONFIG_DATABASE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(ext_struc = method->r2i(method, ctx, value))) return NULL;\\r\\n} else {\\r\\nX509V3err(X509V3_F_X509V3_EXT_CONF,X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);\\r\\nERR_add_error_data(2, \"name=\", OBJ_nid2sn(ext_nid));\\r\\nreturn NULL;\\r\\n}\\r\\next = do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\nmethod->ext_free(ext_struc);\\r\\nreturn ext;\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_i2d(X509V3_EXT_METHOD *method, int ext_nid,\\r\\nint crit, void *ext_struc)\\r\\n{\\r\\nunsigned char *ext_der, *p;\\r\\nint ext_len;\\r\\nASN1_OCTET_STRING *ext_oct;\\r\\nX509_EXTENSION *ext;\\r\\next_len = method->i2d(ext_struc, NULL);\\r\\nif(!(ext_der = Malloc(ext_len))) goto merr;\\r\\np = ext_der;\\r\\nmethod->i2d(ext_struc, &p);\\r\\nif(!(ext_oct = ASN1_OCTET_STRING_new())) goto merr;\\r\\next_oct->data = ext_der;\\r\\next_oct->length = ext_len;\\r\\next = X509_EXTENSION_create_by_NID(NULL, ext_nid, crit, ext_oct);\\r\\nif(!ext) goto merr;\\r\\nASN1_OCTET_STRING_free(ext_oct);\\r\\nreturn ext;\\r\\nmerr:\\r\\nX509V3err(X509V3_F_DO_EXT_I2D,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)\\r\\n{\\r\\nX509V3_EXT_METHOD *method;\\r\\nif(!(method = X509V3_EXT_get_nid(ext_nid))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_I2D,X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\n}\\r\\nstatic int v3_check_critical(char **value)\\r\\n{\\r\\nchar *p = *value;\\r\\nif((strlen(p) < 9) || strncmp(p, \"critical,\", 9)) return 0;\\r\\np+=9;\\r\\nwhile(isspace((unsigned char)*p)) p++;\\r\\n*value = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int v3_check_generic(char **value)\\r\\n{\\r\\nchar *p = *value;\\r\\nif((strlen(p) < 4) || strncmp(p, \"DER:,\", 4)) return 0;\\r\\np+=4;\\r\\nwhile(isspace((unsigned char)*p)) p++;\\r\\n*value = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic X509_EXTENSION *v3_generic_extension(const char *ext, char *value,\\r\\nint crit, int type)\\r\\n{\\r\\nunsigned char *ext_der=NULL;\\r\\nlong ext_len;\\r\\nASN1_OBJECT *obj=NULL;\\r\\nASN1_OCTET_STRING *oct=NULL;\\r\\nX509_EXTENSION *extension=NULL;\\r\\nif(!(obj = OBJ_txt2obj(ext, 0))) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_NAME_ERROR);\\r\\nERR_add_error_data(2, \"name=\", ext);\\r\\ngoto err;\\r\\n}\\r\\nif(!(ext_der = string_to_hex(value, &ext_len))) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,X509V3_R_EXTENSION_VALUE_ERROR);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\nif(!(oct = ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\noct->data = ext_der;\\r\\noct->length = ext_len;\\r\\next_der = NULL;\\r\\nextension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);\\r\\nerr:\\r\\nASN1_OBJECT_free(obj);\\r\\nASN1_OCTET_STRING_free(oct);\\r\\nif(ext_der) Free(ext_der);\\r\\nreturn extension;\\r\\n}\\r\\nint X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,\\r\\nX509 *cert)\\r\\n{\\r\\nX509_EXTENSION *ext;\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nCONF_VALUE *val;\\r\\nint i;\\r\\nif(!(nval = CONF_get_section(conf, section))) return 0;\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(nval); i++) {\\r\\nval = sk_CONF_VALUE_value(nval, i);\\r\\nif(!(ext = X509V3_EXT_conf(conf, ctx, val->name, val->value)))\\r\\nreturn 0;\\r\\nif(cert) X509_add_ext(cert, ext, -1);\\r\\nX509_EXTENSION_free(ext);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_CRL *crl)\\r\\n{\\r\\nX509_EXTENSION *ext;\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nCONF_VALUE *val;\\r\\nint i;\\r\\nif(!(nval = CONF_get_section(conf, section))) return 0;\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(nval); i++) {\\r\\nval = sk_CONF_VALUE_value(nval, i);\\r\\nif(!(ext = X509V3_EXT_conf(conf, ctx, val->name, val->value)))\\r\\nreturn 0;\\r\\nif(crl) X509_CRL_add_ext(crl, ext, -1);\\r\\nX509_EXTENSION_free(ext);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar * X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)\\r\\n{\\r\\nif(ctx->db_meth->get_string)\\r\\nreturn ctx->db_meth->get_string(ctx->db, name, section);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic char *conf_lhash_get_string(void *db, char *section, char *value)\\r\\n{\\r\\nreturn CONF_get_string(db, section, value);\\r\\n}\\r\\nvoid X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH *lhash)\\r\\n{\\r\\nctx->db_meth = &conf_lhash_method;\\r\\nctx->db = lhash;\\r\\n}\\r\\nvoid X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,\\r\\nX509_CRL *crl, int flags)\\r\\n{\\r\\nctx->issuer_cert = issuer;\\r\\nctx->subject_cert = subj;\\r\\nctx->crl = crl;\\r\\nctx->subject_req = req;\\r\\nctx->flags = flags;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_err_prn_c", "target": 0, "func": "void ERR_print_errors_fp(FILE *fp)\\r\\n{\\r\\nunsigned long l;\\r\\nchar buf[200];\\r\\nconst char *file,*data;\\r\\nint line,flags;\\r\\nunsigned long es;\\r\\nes=CRYPTO_thread_id();\\r\\nwhile ((l=ERR_get_error_line_data(&file,&line,&data,&flags)) != 0)\\r\\n{\\r\\nfprintf(fp,\"%lu:%s:%s:%d:%s\\n\",es,ERR_error_string(l,buf),\\r\\nfile,line,(flags&ERR_TXT_STRING)?data:\"\");\\r\\n}\\r\\n}\\r\\nvoid ERR_print_errors(BIO *bp)\\r\\n{\\r\\nunsigned long l;\\r\\nchar buf[256];\\r\\nchar buf2[256];\\r\\nconst char *file,*data;\\r\\nint line,flags;\\r\\nunsigned long es;\\r\\nes=CRYPTO_thread_id();\\r\\nwhile ((l=ERR_get_error_line_data(&file,&line,&data,&flags)) != 0)\\r\\n{\\r\\nsprintf(buf2,\"%lu:%s:%s:%d:\",es,ERR_error_string(l,buf),\\r\\nfile,line);\\r\\nBIO_write(bp,buf2,strlen(buf2));\\r\\nif (flags & ERR_TXT_STRING)\\r\\nBIO_write(bp,data,strlen(data));\\r\\nBIO_write(bp,\"\\n\",1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_asn1_lib_c", "target": 0, "func": "int ASN1_check_infinite_end(unsigned char **p, long len)\\r\\n{\\r\\nif (len <= 0)\\r\\nreturn(1);\\r\\nelse if ((len >= 2) && ((*p)[0] == 0) && ((*p)[1] == 0))\\r\\n{\\r\\n(*p)+=2;\\r\\nreturn(1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_get_object(unsigned char **pp, long *plength, int *ptag, int *pclass,\\r\\nlong omax)\\r\\n{\\r\\nint i,ret;\\r\\nlong l;\\r\\nunsigned char *p= *pp;\\r\\nint tag,xclass,inf;\\r\\nlong max=omax;\\r\\nif (!max) goto err;\\r\\nret=(*p&V_ASN1_CONSTRUCTED);\\r\\nxclass=(*p&V_ASN1_PRIVATE);\\r\\ni= *p&V_ASN1_PRIMITIVE_TAG;\\r\\nif (i == V_ASN1_PRIMITIVE_TAG)\\r\\n{\\r\\np++;\\r\\nif (--max == 0) goto err;\\r\\nl=0;\\r\\nwhile (*p&0x80)\\r\\n{\\r\\nl<<=7L;\\r\\nl|= *(p++)&0x7f;\\r\\nif (--max == 0) goto err;\\r\\n}\\r\\nl<<=7L;\\r\\nl|= *(p++)&0x7f;\\r\\ntag=(int)l;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntag=i;\\r\\np++;\\r\\nif (--max == 0) goto err;\\r\\n}\\r\\n*ptag=tag;\\r\\n*pclass=xclass;\\r\\nif (!asn1_get_length(&p,&inf,plength,(int)max)) goto err;\\r\\n#if 0\\r\\nfprintf(stderr,\"p=%d + *plength=%ld > omax=%ld + *pp=%d (%d > %d)\\n\",\\r\\n(int)p,*plength,omax,(int)*pp,(int)(p+ *plength),\\r\\n(int)(omax+ *pp));\\r\\n#endif\\r\\n#if 0\\r\\nif ((p+ *plength) > (omax+ *pp))\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_TOO_LONG);\\r\\nret|=0x80;\\r\\n}\\r\\n#endif\\r\\n*pp=p;\\r\\nreturn(ret|inf);\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT,ASN1_R_HEADER_TOO_LONG);\\r\\nreturn(0x80);\\r\\n}\\r\\nstatic int asn1_get_length(unsigned char **pp, int *inf, long *rl, int max)\\r\\n{\\r\\nunsigned char *p= *pp;\\r\\nlong ret=0;\\r\\nint i;\\r\\nif (max-- < 1) return(0);\\r\\nif (*p == 0x80)\\r\\n{\\r\\n*inf=1;\\r\\nret=0;\\r\\np++;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*inf=0;\\r\\ni= *p&0x7f;\\r\\nif (*(p++) & 0x80)\\r\\n{\\r\\nif (max-- == 0) return(0);\\r\\nwhile (i-- > 0)\\r\\n{\\r\\nret<<=8L;\\r\\nret|= *(p++);\\r\\nif (max-- == 0) return(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=i;\\r\\n}\\r\\n*pp=p;\\r\\n*rl=ret;\\r\\nreturn(1);\\r\\n}\\r\\nvoid ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,\\r\\nint xclass)\\r\\n{\\r\\nunsigned char *p= *pp;\\r\\nint i;\\r\\ni=(constructed)?V_ASN1_CONSTRUCTED:0;\\r\\ni|=(xclass&V_ASN1_PRIVATE);\\r\\nif (tag < 31)\\r\\n*(p++)=i|(tag&V_ASN1_PRIMITIVE_TAG);\\r\\nelse\\r\\n{\\r\\n*(p++)=i|V_ASN1_PRIMITIVE_TAG;\\r\\nwhile (tag > 0x7f)\\r\\n{\\r\\n*(p++)=(tag&0x7f)|0x80;\\r\\ntag>>=7;\\r\\n}\\r\\n*(p++)=(tag&0x7f);\\r\\n}\\r\\nif ((constructed == 2) && (length == 0))\\r\\n*(p++)=0x80;\\r\\nelse\\r\\nasn1_put_length(&p,length);\\r\\n*pp=p;\\r\\n}\\r\\nstatic void asn1_put_length(unsigned char **pp, int length)\\r\\n{\\r\\nunsigned char *p= *pp;\\r\\nint i,l;\\r\\nif (length <= 127)\\r\\n*(p++)=(unsigned char)length;\\r\\nelse\\r\\n{\\r\\nl=length;\\r\\nfor (i=0; l > 0; i++)\\r\\nl>>=8;\\r\\n*(p++)=i|0x80;\\r\\nl=i;\\r\\nwhile (i-- > 0)\\r\\n{\\r\\np[i]=length&0xff;\\r\\nlength>>=8;\\r\\n}\\r\\np+=l;\\r\\n}\\r\\n*pp=p;\\r\\n}\\r\\nint ASN1_object_size(int constructed, int length, int tag)\\r\\n{\\r\\nint ret;\\r\\nret=length;\\r\\nret++;\\r\\nif (tag >= 31)\\r\\n{\\r\\nwhile (tag > 0)\\r\\n{\\r\\ntag>>=7;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nif ((length == 0) && (constructed == 2))\\r\\nret+=2;\\r\\nret++;\\r\\nif (length > 127)\\r\\n{\\r\\nwhile (length > 0)\\r\\n{\\r\\nlength>>=8;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint asn1_Finish(ASN1_CTX *c)\\r\\n{\\r\\nif ((c->inf == (1|V_ASN1_CONSTRUCTED)) && (!c->eos))\\r\\n{\\r\\nif (!ASN1_check_infinite_end(&c->p,c->slen))\\r\\n{\\r\\nc->error=ERR_R_MISSING_ASN1_EOS;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nif ( ((c->slen != 0) && !(c->inf & 1)) ||\\r\\n((c->slen < 0) && (c->inf & 1)))\\r\\n{\\r\\nc->error=ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint asn1_GetSequence(ASN1_CTX *c, long *length)\\r\\n{\\r\\nunsigned char *q;\\r\\nq=c->p;\\r\\nc->inf=ASN1_get_object(&(c->p),&(c->slen),&(c->tag),&(c->xclass),\\r\\n*length);\\r\\nif (c->inf & 0x80)\\r\\n{\\r\\nc->error=ERR_R_BAD_GET_ASN1_OBJECT_CALL;\\r\\nreturn(0);\\r\\n}\\r\\nif (c->tag != V_ASN1_SEQUENCE)\\r\\n{\\r\\nc->error=ERR_R_EXPECTING_AN_ASN1_SEQUENCE;\\r\\nreturn(0);\\r\\n}\\r\\n(*length)-=(c->p-q);\\r\\nif (c->max && (*length < 0))\\r\\n{\\r\\nc->error=ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn(0);\\r\\n}\\r\\nif (c->inf == (1|V_ASN1_CONSTRUCTED))\\r\\nc->slen= *length+ *(c->pp)-c->p;\\r\\nc->eos=0;\\r\\nreturn(1);\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_dup(ASN1_STRING *str)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nif (str == NULL) return(NULL);\\r\\nif ((ret=ASN1_STRING_type_new(str->type)) == NULL)\\r\\nreturn(NULL);\\r\\nif (!ASN1_STRING_set(ret,str->data,str->length))\\r\\n{\\r\\nASN1_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->flags = str->flags;\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len)\\r\\n{\\r\\nunsigned char *c;\\r\\nconst char *data=_data;\\r\\nif (len < 0)\\r\\n{\\r\\nif (data == NULL)\\r\\nreturn(0);\\r\\nelse\\r\\nlen=strlen(data);\\r\\n}\\r\\nif ((str->length < len) || (str->data == NULL))\\r\\n{\\r\\nc=str->data;\\r\\nif (c == NULL)\\r\\nstr->data=Malloc(len+1);\\r\\nelse\\r\\nstr->data=Realloc(c,len+1);\\r\\nif (str->data == NULL)\\r\\n{\\r\\nstr->data=c;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstr->length=len;\\r\\nif (data != NULL)\\r\\n{\\r\\nmemcpy(str->data,data,len);\\r\\nstr->data[len]='\\0';\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_new(void)\\r\\n{\\r\\nreturn(ASN1_STRING_type_new(V_ASN1_OCTET_STRING));\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_type_new(int type)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nret=(ASN1_STRING *)Malloc(sizeof(ASN1_STRING));\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_STRING_TYPE_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->type=type;\\r\\nret->data=NULL;\\r\\nret->flags=0;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid ASN1_STRING_free(ASN1_STRING *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif (a->data != NULL) Free((char *)a->data);\\r\\nFree((char *)a);\\r\\n}\\r\\nint ASN1_STRING_cmp(ASN1_STRING *a, ASN1_STRING *b)\\r\\n{\\r\\nint i;\\r\\ni=(a->length-b->length);\\r\\nif (i == 0)\\r\\n{\\r\\ni=memcmp(a->data,b->data,a->length);\\r\\nif (i == 0)\\r\\nreturn(a->type-b->type);\\r\\nelse\\r\\nreturn(i);\\r\\n}\\r\\nelse\\r\\nreturn(i);\\r\\n}\\r\\nvoid asn1_add_error(unsigned char *address, int offset)\\r\\n{\\r\\nchar buf1[16],buf2[16];\\r\\nsprintf(buf1,\"%lu\",(unsigned long)address);\\r\\nsprintf(buf2,\"%d\",offset);\\r\\nERR_add_error_data(4,\"address=\",buf1,\" offset=\",buf2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_word_c", "target": 0, "func": "BN_ULONG BN_mod_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\n#ifndef BN_LLONG\\r\\nBN_ULONG ret=0;\\r\\n#else\\r\\nBN_ULLONG ret=0;\\r\\n#endif\\r\\nint i;\\r\\nw&=BN_MASK2;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\n#ifndef BN_LLONG\\r\\nret=((ret<<BN_BITS4)|((a->d[i]>>BN_BITS4)&BN_MASK2l))%w;\\r\\nret=((ret<<BN_BITS4)|(a->d[i]&BN_MASK2l))%w;\\r\\n#else\\r\\nret=(BN_ULLONG)(((ret<<(BN_ULLONG)BN_BITS2)|a->d[i])%\\r\\n(BN_ULLONG)w);\\r\\n#endif\\r\\n}\\r\\nreturn((BN_ULONG)ret);\\r\\n}\\r\\nBN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ret;\\r\\nint i;\\r\\nif (a->top == 0) return(0);\\r\\nret=0;\\r\\nw&=BN_MASK2;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nBN_ULONG l,d;\\r\\nl=a->d[i];\\r\\nd=bn_div_words(ret,l,w);\\r\\nret=(l-((d*w)&BN_MASK2))&BN_MASK2;\\r\\na->d[i]=d;\\r\\n}\\r\\nif ((a->top > 0) && (a->d[a->top-1] == 0))\\r\\na->top--;\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_add_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG l;\\r\\nint i;\\r\\nif (a->neg)\\r\\n{\\r\\na->neg=0;\\r\\ni=BN_sub_word(a,w);\\r\\nif (!BN_is_zero(a))\\r\\na->neg=1;\\r\\nreturn(i);\\r\\n}\\r\\nw&=BN_MASK2;\\r\\nif (bn_wexpand(a,a->top+1) == NULL) return(0);\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\nl=(a->d[i]+(BN_ULONG)w)&BN_MASK2;\\r\\na->d[i]=l;\\r\\nif (w > l)\\r\\nw=1;\\r\\nelse\\r\\nbreak;\\r\\ni++;\\r\\n}\\r\\nif (i >= a->top)\\r\\na->top++;\\r\\nreturn(1);\\r\\n}\\r\\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nint i;\\r\\nif (a->neg)\\r\\n{\\r\\na->neg=0;\\r\\ni=BN_add_word(a,w);\\r\\na->neg=1;\\r\\nreturn(i);\\r\\n}\\r\\nw&=BN_MASK2;\\r\\nif ((a->top == 1) && (a->d[0] < w))\\r\\n{\\r\\na->d[0]=w-a->d[0];\\r\\na->neg=1;\\r\\nreturn(1);\\r\\n}\\r\\ni=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (a->d[i] >= w)\\r\\n{\\r\\na->d[i]-=w;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\na->d[i]=(a->d[i]-w)&BN_MASK2;\\r\\ni++;\\r\\nw=1;\\r\\n}\\r\\n}\\r\\nif ((a->d[i] == 0) && (i == (a->top-1)))\\r\\na->top--;\\r\\nreturn(1);\\r\\n}\\r\\nint BN_mul_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ll;\\r\\nw&=BN_MASK2;\\r\\nif (a->top)\\r\\n{\\r\\nll=bn_mul_words(a->d,a->d,a->top,w);\\r\\nif (ll)\\r\\n{\\r\\nif (bn_wexpand(a,a->top+1) == NULL) return(0);\\r\\na->d[a->top++]=ll;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md_rand_c", "target": 0, "func": "RAND_METHOD *RAND_SSLeay(void)\\r\\n{\\r\\nreturn(&rand_ssleay_meth);\\r\\n}\\r\\nstatic void ssleay_rand_cleanup(void)\\r\\n{\\r\\nmemset(state,0,sizeof(state));\\r\\nstate_num=0;\\r\\nstate_index=0;\\r\\nmemset(md,0,MD_DIGEST_LENGTH);\\r\\nmd_count[0]=0;\\r\\nmd_count[1]=0;\\r\\n}\\r\\nstatic void ssleay_rand_seed(const void *buf, int num)\\r\\n{\\r\\nint i,j,k,st_idx,st_num;\\r\\nMD_CTX m;\\r\\n#ifdef NORAND\\r\\nreturn;\\r\\n#endif\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nst_idx=state_index;\\r\\nst_num=state_num;\\r\\nstate_index=(state_index+num);\\r\\nif (state_index >= STATE_SIZE)\\r\\n{\\r\\nstate_index%=STATE_SIZE;\\r\\nstate_num=STATE_SIZE;\\r\\n}\\r\\nelse if (state_num < STATE_SIZE)\\r\\n{\\r\\nif (state_index > state_num)\\r\\nstate_num=state_index;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nfor (i=0; i<num; i+=MD_DIGEST_LENGTH)\\r\\n{\\r\\nj=(num-i);\\r\\nj=(j > MD_DIGEST_LENGTH)?MD_DIGEST_LENGTH:j;\\r\\nMD_Init(&m);\\r\\nMD_Update(&m,md,MD_DIGEST_LENGTH);\\r\\nk=(st_idx+j)-STATE_SIZE;\\r\\nif (k > 0)\\r\\n{\\r\\nMD_Update(&m,&(state[st_idx]),j-k);\\r\\nMD_Update(&m,&(state[0]),k);\\r\\n}\\r\\nelse\\r\\nMD_Update(&m,&(state[st_idx]),j);\\r\\nMD_Update(&m,buf,j);\\r\\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\\r\\nMD_Final(md,&m);\\r\\nmd_count[1]++;\\r\\nbuf=(const char *)buf + j;\\r\\nfor (k=0; k<j; k++)\\r\\n{\\r\\nstate[st_idx++]^=md[k];\\r\\nif (st_idx >= STATE_SIZE)\\r\\n{\\r\\nst_idx=0;\\r\\nst_num=STATE_SIZE;\\r\\n}\\r\\n}\\r\\n}\\r\\nmemset((char *)&m,0,sizeof(m));\\r\\n}\\r\\nstatic void ssleay_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nint i,j,k,st_num,st_idx;\\r\\nMD_CTX m;\\r\\nstatic int init=1;\\r\\nunsigned long l;\\r\\n#ifdef DEVRANDOM\\r\\nFILE *fh;\\r\\n#endif\\r\\n#ifdef PREDICT\\r\\n{\\r\\nstatic unsigned char val=0;\\r\\nfor (i=0; i<num; i++)\\r\\nbuf[i]=val++;\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nRAND_seed(&m,sizeof(m));\\r\\n#ifndef MSDOS\\r\\nl=getpid();\\r\\nRAND_seed(&l,sizeof(l));\\r\\nl=getuid();\\r\\nRAND_seed(&l,sizeof(l));\\r\\n#endif\\r\\nl=time(NULL);\\r\\nRAND_seed(&l,sizeof(l));\\r\\nif ((fh = fopen(DEVRANDOM, \"r\")) != NULL)\\r\\n{\\r\\nunsigned char tmpbuf[32];\\r\\nfread((unsigned char *)tmpbuf,1,32,fh);\\r\\nfclose(fh);\\r\\nRAND_seed(tmpbuf,32);\\r\\nmemset(tmpbuf,0,32);\\r\\n}\\r\\n#ifdef PURIFY\\r\\nmemset(state,0,STATE_SIZE);\\r\\nmemset(md,0,MD_DIGEST_LENGTH);\\r\\n#endif\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\ninit=0;\\r\\n}\\r\\nst_idx=state_index;\\r\\nst_num=state_num;\\r\\nstate_index+=num;\\r\\nif (state_index > state_num)\\r\\nstate_index=(state_index%state_num);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nwhile (num > 0)\\r\\n{\\r\\nj=(num >= MD_DIGEST_LENGTH/2)?MD_DIGEST_LENGTH/2:num;\\r\\nnum-=j;\\r\\nMD_Init(&m);\\r\\nMD_Update(&m,&(md[MD_DIGEST_LENGTH/2]),MD_DIGEST_LENGTH/2);\\r\\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\\r\\n#ifndef PURIFY\\r\\nMD_Update(&m,buf,j);\\r\\n#endif\\r\\nk=(st_idx+j)-st_num;\\r\\nif (k > 0)\\r\\n{\\r\\nMD_Update(&m,&(state[st_idx]),j-k);\\r\\nMD_Update(&m,&(state[0]),k);\\r\\n}\\r\\nelse\\r\\nMD_Update(&m,&(state[st_idx]),j);\\r\\nMD_Final(md,&m);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (st_idx >= st_num)\\r\\nst_idx=0;\\r\\nstate[st_idx++]^=md[i];\\r\\n*(buf++)=md[i+MD_DIGEST_LENGTH/2];\\r\\n}\\r\\n}\\r\\nMD_Init(&m);\\r\\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\\r\\nmd_count[0]++;\\r\\nMD_Update(&m,md,MD_DIGEST_LENGTH);\\r\\nMD_Final(md,&m);\\r\\nmemset(&m,0,sizeof(m));\\r\\n}\\r\\nvoid RAND_screen(void)\\r\\n{\\r\\nHDC hScrDC;\\r\\nHDC hMemDC;\\r\\nHBITMAP hBitmap;\\r\\nHBITMAP hOldBitmap;\\r\\nBITMAP bm;\\r\\nunsigned int size;\\r\\nchar *bmbits;\\r\\nint w;\\r\\nint h;\\r\\nint y;\\r\\nint n = 16;\\r\\nhScrDC = CreateDC(\"DISPLAY\", NULL, NULL, NULL);\\r\\nhMemDC = CreateCompatibleDC(hScrDC);\\r\\nw = GetDeviceCaps(hScrDC, HORZRES);\\r\\nh = GetDeviceCaps(hScrDC, VERTRES);\\r\\nhBitmap = CreateCompatibleBitmap(hScrDC, w, n);\\r\\nhOldBitmap = SelectObject(hMemDC, hBitmap);\\r\\nGetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);\\r\\nsize = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;\\r\\nbmbits = Malloc(size);\\r\\nif (bmbits) {\\r\\nfor (y = 0; y < h-n; y += n)\\r\\n{\\r\\nunsigned char md[MD_DIGEST_LENGTH];\\r\\nBitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);\\r\\nGetBitmapBits(hBitmap, size, bmbits);\\r\\nMD(bmbits,size,md);\\r\\nRAND_seed(md, MD_DIGEST_LENGTH);\\r\\n}\\r\\nFree(bmbits);\\r\\n}\\r\\nhBitmap = SelectObject(hMemDC, hOldBitmap);\\r\\nDeleteObject(hBitmap);\\r\\nDeleteDC(hMemDC);\\r\\nDeleteDC(hScrDC);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_mdc2_one_c", "target": 0, "func": "unsigned char *MDC2(unsigned char *d, unsigned long n, unsigned char *md)\\r\\n{\\r\\nMDC2_CTX c;\\r\\nstatic unsigned char m[MDC2_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nMDC2_Init(&c);\\r\\nMDC2_Update(&c,d,n);\\r\\nMDC2_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_i2d_fp_c", "target": 0, "func": "int ASN1_i2d_fp(int (*i2d)(), FILE *out, unsigned char *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_I2D_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,out,BIO_NOCLOSE);\\r\\nret=ASN1_i2d_bio(i2d,b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_i2d_bio(int (*i2d)(), BIO *out, unsigned char *x)\\r\\n{\\r\\nchar *b;\\r\\nunsigned char *p;\\r\\nint i,j=0,n,ret=1;\\r\\nn=i2d(x,NULL);\\r\\nb=(char *)Malloc(n);\\r\\nif (b == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_I2D_BIO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)b;\\r\\ni2d(x,&p);\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(out,&(b[j]),n);\\r\\nif (i == n) break;\\r\\nif (i <= 0)\\r\\n{\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nj+=i;\\r\\nn-=i;\\r\\n}\\r\\nFree((char *)b);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_i_c", "target": 0, "func": "EVP_CIPHER *EVP_idea_cbc(void)\\r\\n{\\r\\nreturn(&i_cbc_cipher);\\r\\n}\\r\\nstatic void idea_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\n{\\r\\nif (enc)\\r\\nidea_set_encrypt_key(key,&(ctx->c.idea_ks));\\r\\nelse\\r\\n{\\r\\nIDEA_KEY_SCHEDULE tmp;\\r\\nidea_set_encrypt_key(key,&tmp);\\r\\nidea_set_decrypt_key(&tmp,&(ctx->c.idea_ks));\\r\\nmemset((unsigned char *)&tmp,0,\\r\\nsizeof(IDEA_KEY_SCHEDULE));\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void idea_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nidea_cbc_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.idea_ks),&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_gentm_c", "target": 0, "func": "int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a, unsigned char **pp)\\r\\n{\\r\\n#ifdef CHARSET_EBCDIC\\r\\nint len;\\r\\nchar tmp[24];\\r\\nASN1_STRING tmpstr = *(ASN1_STRING *)a;\\r\\nlen = tmpstr.length;\\r\\nebcdic2ascii(tmp, tmpstr.data, (len >= sizeof tmp) ? sizeof tmp : len);\\r\\ntmpstr.data = tmp;\\r\\na = (ASN1_GENERALIZEDTIME *) &tmpstr;\\r\\n#endif\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_GENERALIZEDTIME,V_ASN1_UNIVERSAL));\\r\\n}\\r\\nASN1_GENERALIZEDTIME *d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nASN1_GENERALIZEDTIME *ret=NULL;\\r\\nret=(ASN1_GENERALIZEDTIME *)d2i_ASN1_bytes((ASN1_STRING **)a,pp,length,\\r\\nV_ASN1_GENERALIZEDTIME,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_GENERALIZEDTIME,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(ret->data, ret->data, ret->length);\\r\\n#endif\\r\\nif (!ASN1_GENERALIZEDTIME_check(ret))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_GENERALIZEDTIME,ASN1_R_INVALID_TIME_FORMAT);\\r\\ngoto err;\\r\\n}\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_GENERALIZEDTIME_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *d)\\r\\n{\\r\\nstatic int min[9]={ 0, 0, 1, 1, 0, 0, 0, 0, 0};\\r\\nstatic int max[9]={99, 99,12,31,23,59,59,12,59};\\r\\nchar *a;\\r\\nint n,i,l,o;\\r\\nif (d->type != V_ASN1_GENERALIZEDTIME) return(0);\\r\\nl=d->length;\\r\\na=(char *)d->data;\\r\\no=0;\\r\\nif (l < 13) goto err;\\r\\nfor (i=0; i<7; i++)\\r\\n{\\r\\nif ((i == 6) && ((a[o] == 'Z') ||\\r\\n(a[o] == '+') || (a[o] == '-')))\\r\\n{ i++; break; }\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif (++o > l) goto err;\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-'))\\r\\n{\\r\\no++;\\r\\nif (o+4 > l) goto err;\\r\\nfor (i=7; i<9; i++)\\r\\n{\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn= a[o]-'0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9')) goto err;\\r\\nn=(n*10)+ a[o]-'0';\\r\\nif ((n < min[i]) || (n > max[i])) goto err;\\r\\no++;\\r\\n}\\r\\n}\\r\\nreturn(o == l);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, char *str)\\r\\n{\\r\\nASN1_GENERALIZEDTIME t;\\r\\nt.type=V_ASN1_GENERALIZEDTIME;\\r\\nt.length=strlen(str);\\r\\nt.data=(unsigned char *)str;\\r\\nif (ASN1_GENERALIZEDTIME_check(&t))\\r\\n{\\r\\nif (s != NULL)\\r\\n{\\r\\nASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str,t.length);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,\\r\\ntime_t t)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\nstruct tm data;\\r\\n#endif\\r\\nif (s == NULL)\\r\\ns=ASN1_GENERALIZEDTIME_new();\\r\\nif (s == NULL)\\r\\nreturn(NULL);\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\ngmtime_r(&t,&data);\\r\\nts=&data;\\r\\n#else\\r\\nts=gmtime(&t);\\r\\n#endif\\r\\np=(char *)s->data;\\r\\nif ((p == NULL) || (s->length < 16))\\r\\n{\\r\\np=Malloc(20);\\r\\nif (p == NULL) return(NULL);\\r\\nif (s->data != NULL)\\r\\nFree(s->data);\\r\\ns->data=(unsigned char *)p;\\r\\n}\\r\\nsprintf(p,\"%04d%02d%02d%02d%02d%02dZ\",ts->tm_year + 1900,\\r\\nts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);\\r\\ns->length=strlen(p);\\r\\ns->type=V_ASN1_GENERALIZEDTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn(s);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_cb_c", "target": 0, "func": "long MS_CALLBACK BIO_debug_callback(BIO *bio, int cmd, const char *argp,\\r\\nint argi, long argl, long ret)\\r\\n{\\r\\nBIO *b;\\r\\nMS_STATIC char buf[256];\\r\\nchar *p;\\r\\nlong r=1;\\r\\nif (BIO_CB_RETURN & cmd)\\r\\nr=ret;\\r\\nsprintf(buf,\"BIO[%08lX]:\",(unsigned long)bio);\\r\\np= &(buf[14]);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CB_FREE:\\r\\nsprintf(p,\"Free - %s\\n\",bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_READ:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nsprintf(p,\"read(%d,%d) - %s fd=%d\\n\",bio->num,argi,bio->method->name,bio->num);\\r\\nelse\\r\\nsprintf(p,\"read(%d,%d) - %s\\n\",bio->num,argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_WRITE:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nsprintf(p,\"write(%d,%d) - %s fd=%d\\n\",bio->num,argi,bio->method->name,bio->num);\\r\\nelse\\r\\nsprintf(p,\"write(%d,%d) - %s\\n\",bio->num,argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_PUTS:\\r\\nsprintf(p,\"puts() - %s\\n\",bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_GETS:\\r\\nsprintf(p,\"gets(%d) - %s\\n\",argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_CTRL:\\r\\nsprintf(p,\"ctrl(%d) - %s\\n\",argi,bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_READ:\\r\\nsprintf(p,\"read return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_WRITE:\\r\\nsprintf(p,\"write return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_GETS:\\r\\nsprintf(p,\"gets return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_PUTS:\\r\\nsprintf(p,\"puts return %ld\\n\",ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN|BIO_CB_CTRL:\\r\\nsprintf(p,\"ctrl return %ld\\n\",ret);\\r\\nbreak;\\r\\ndefault:\\r\\nsprintf(p,\"bio callback - unknown type (%d)\\n\",cmd);\\r\\nbreak;\\r\\n}\\r\\nb=(BIO *)bio->cb_arg;\\r\\nif (b != NULL)\\r\\nBIO_write(b,buf,strlen(buf));\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nelse\\r\\nfputs(buf,stderr);\\r\\n#endif\\r\\nreturn(r);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_int_c", "target": 0, "func": "static ASN1_INTEGER *asn1_integer_new(void)\\r\\n{\\r\\nreturn ASN1_INTEGER_new();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_s_pr_c", "target": 0, "func": "DSA *d2i_DSAPrivateKey(DSA **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ASN1_R_PARSING;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,DSA *,DSA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif (bs->length == 0)\\r\\nret->version=0;\\r\\nelse ret->version=bs->data[0];\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->p=BN_bin2bn(bs->data,bs->length,ret->p)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->q=BN_bin2bn(bs->data,bs->length,ret->q)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->g=BN_bin2bn(bs->data,bs->length,ret->g)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->pub_key=BN_bin2bn(bs->data,bs->length,ret->pub_key))\\r\\n== NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->priv_key=BN_bin2bn(bs->data,bs->length,ret->priv_key))\\r\\n== NULL) goto err_bn;\\r\\nASN1_INTEGER_free(bs);\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_DSAPRIVATEKEY,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) DSA_free(ret);\\r\\nif (bs != NULL) ASN1_INTEGER_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_stat_c", "target": 0, "func": "char *SSL_state_string_long(SSL *s)\\r\\n{\\r\\nchar *str;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE: str=\"before SSL initialization\"; break;\\r\\ncase SSL_ST_ACCEPT: str=\"before accept initialization\"; break;\\r\\ncase SSL_ST_CONNECT: str=\"before connect initialization\"; break;\\r\\ncase SSL_ST_OK: str=\"SSL negotiation finished successfully\"; break;\\r\\ncase SSL_ST_RENEGOTIATE: str=\"SSL renegotiate ciphers\"; break;\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT: str=\"before/connect initialization\"; break;\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT: str=\"ok/connect SSL initialization\"; break;\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT: str=\"before/accept initialization\"; break;\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT: str=\"ok/accept SSL initialization\"; break;\\r\\n#ifndef NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION: str=\"SSLv2 client start encryption\"; break;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION: str=\"SSLv2 server start encryption\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A: str=\"SSLv2 write client hello A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B: str=\"SSLv2 write client hello B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A: str=\"SSLv2 read server hello A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B: str=\"SSLv2 read server hello B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str=\"SSLv2 write client master key A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str=\"SSLv2 write client master key B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A: str=\"SSLv2 write client finished A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B: str=\"SSLv2 write client finished B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str=\"SSLv2 write client certificate A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str=\"SSLv2 write client certificate B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str=\"SSLv2 write client certificate C\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str=\"SSLv2 write client certificate D\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A: str=\"SSLv2 read server verify A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B: str=\"SSLv2 read server verify B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A: str=\"SSLv2 read server finished A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B: str=\"SSLv2 read server finished B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A: str=\"SSLv2 read client hello A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B: str=\"SSLv2 read client hello B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C: str=\"SSLv2 read client hello C\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A: str=\"SSLv2 write server hello A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B: str=\"SSLv2 write server hello B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A: str=\"SSLv2 read client master key A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B: str=\"SSLv2 read client master key B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A: str=\"SSLv2 write server verify A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B: str=\"SSLv2 write server verify B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C: str=\"SSLv2 write server verify C\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A: str=\"SSLv2 read client finished A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B: str=\"SSLv2 read client finished B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A: str=\"SSLv2 write server finished A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B: str=\"SSLv2 write server finished B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str=\"SSLv2 write request certificate A\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str=\"SSLv2 write request certificate B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str=\"SSLv2 write request certificate C\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str=\"SSLv2 write request certificate D\"; break;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE: str=\"SSLv2 X509 read server certificate\"; break;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str=\"SSLv2 X509 read client certificate\"; break;\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A: str=\"SSLv3 write client hello A\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B: str=\"SSLv3 write client hello B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A: str=\"SSLv3 read server hello A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B: str=\"SSLv3 read server hello B\"; break;\\r\\ncase SSL3_ST_CR_CERT_A: str=\"SSLv3 read server certificate A\"; break;\\r\\ncase SSL3_ST_CR_CERT_B: str=\"SSLv3 read server certificate B\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A: str=\"SSLv3 read server key exchange A\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B: str=\"SSLv3 read server key exchange B\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_A: str=\"SSLv3 read server certificate request A\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_B: str=\"SSLv3 read server certificate request B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A: str=\"SSLv3 read server done A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B: str=\"SSLv3 read server done B\"; break;\\r\\ncase SSL3_ST_CW_CERT_A: str=\"SSLv3 write client certificate A\"; break;\\r\\ncase SSL3_ST_CW_CERT_B: str=\"SSLv3 write client certificate B\"; break;\\r\\ncase SSL3_ST_CW_CERT_C: str=\"SSLv3 write client certificate C\"; break;\\r\\ncase SSL3_ST_CW_CERT_D: str=\"SSLv3 write client certificate D\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A: str=\"SSLv3 write client key exchange A\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B: str=\"SSLv3 write client key exchange B\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A: str=\"SSLv3 write certificate verify A\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B: str=\"SSLv3 write certificate verify A\"; break;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_A: str=\"SSLv3 write change cipher spec A\"; break;\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\ncase SSL3_ST_SW_CHANGE_B: str=\"SSLv3 write change cipher spec B\"; break;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_A: str=\"SSLv3 write finished A\"; break;\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\ncase SSL3_ST_SW_FINISHED_B: str=\"SSLv3 write finished A\"; break;\\r\\ncase SSL3_ST_CR_CHANGE_A:\\r\\ncase SSL3_ST_SR_CHANGE_A: str=\"SSLv3 read change cipher spec A\"; break;\\r\\ncase SSL3_ST_CR_CHANGE_B:\\r\\ncase SSL3_ST_SR_CHANGE_B: str=\"SSLv3 read change cipher spec B\"; break;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_A: str=\"SSLv3 read finished A\"; break;\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\ncase SSL3_ST_SR_FINISHED_B: str=\"SSLv3 read finished B\"; break;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\ncase SSL3_ST_SW_FLUSH: str=\"SSLv3 flush data\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A: str=\"SSLv3 read client hello A\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B: str=\"SSLv3 read client hello B\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C: str=\"SSLv3 read client hello C\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A: str=\"SSLv3 write hello request A\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B: str=\"SSLv3 write hello request B\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C: str=\"SSLv3 write hello request C\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A: str=\"SSLv3 write server hello A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B: str=\"SSLv3 write server hello B\"; break;\\r\\ncase SSL3_ST_SW_CERT_A: str=\"SSLv3 write certificate A\"; break;\\r\\ncase SSL3_ST_SW_CERT_B: str=\"SSLv3 write certificate B\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A: str=\"SSLv3 write key exchange A\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B: str=\"SSLv3 write key exchange B\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_A: str=\"SSLv3 write certificate request A\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_B: str=\"SSLv3 write certificate request B\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A: str=\"SSLv3 write server done A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B: str=\"SSLv3 write server done B\"; break;\\r\\ncase SSL3_ST_SR_CERT_A: str=\"SSLv3 read client certificate A\"; break;\\r\\ncase SSL3_ST_SR_CERT_B: str=\"SSLv3 read client certificate B\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A: str=\"SSLv3 read client key exchange A\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B: str=\"SSLv3 read client key exchange B\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A: str=\"SSLv3 read certificate verify A\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B: str=\"SSLv3 read certificate verify B\"; break;\\r\\n#endif\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A: str=\"SSLv2/v3 write client hello A\"; break;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B: str=\"SSLv2/v3 write client hello B\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A: str=\"SSLv2/v3 read server hello A\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B: str=\"SSLv2/v3 read server hello B\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A: str=\"SSLv2/v3 read client hello A\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B: str=\"SSLv2/v3 read client hello B\"; break;\\r\\n#endif\\r\\ndefault: str=\"unknown state\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nchar *SSL_rstate_string_long(SSL *s)\\r\\n{\\r\\nchar *str;\\r\\nswitch (s->rstate)\\r\\n{\\r\\ncase SSL_ST_READ_HEADER: str=\"read header\"; break;\\r\\ncase SSL_ST_READ_BODY: str=\"read body\"; break;\\r\\ncase SSL_ST_READ_DONE: str=\"read done\"; break;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nchar *SSL_state_string(SSL *s)\\r\\n{\\r\\nchar *str;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE: str=\"PINIT \"; break;\\r\\ncase SSL_ST_ACCEPT: str=\"AINIT \"; break;\\r\\ncase SSL_ST_CONNECT: str=\"CINIT \"; break;\\r\\ncase SSL_ST_OK: str=\"SSLOK \"; break;\\r\\n#ifndef NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION: str=\"2CSENC\"; break;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION: str=\"2SSENC\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A: str=\"2SCH_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B: str=\"2SCH_B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A: str=\"2GSH_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B: str=\"2GSH_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A: str=\"2SCMKA\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B: str=\"2SCMKB\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A: str=\"2SCF_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B: str=\"2SCF_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A: str=\"2SCC_A\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B: str=\"2SCC_B\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C: str=\"2SCC_C\"; break;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D: str=\"2SCC_D\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A: str=\"2GSV_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B: str=\"2GSV_B\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A: str=\"2GSF_A\"; break;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B: str=\"2GSF_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A: str=\"2GCH_A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B: str=\"2GCH_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C: str=\"2GCH_C\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A: str=\"2SSH_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B: str=\"2SSH_B\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A: str=\"2GCMKA\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B: str=\"2GCMKA\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A: str=\"2SSV_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B: str=\"2SSV_B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C: str=\"2SSV_C\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A: str=\"2GCF_A\"; break;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B: str=\"2GCF_B\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A: str=\"2SSF_A\"; break;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B: str=\"2SSF_B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A: str=\"2SRC_A\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B: str=\"2SRC_B\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C: str=\"2SRC_C\"; break;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D: str=\"2SRC_D\"; break;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE: str=\"2X9GSC\"; break;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE: str=\"2X9GCC\"; break;\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\ncase SSL3_ST_CW_FLUSH: str=\"3FLUSH\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A: str=\"3WCH_A\"; break;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B: str=\"3WCH_B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A: str=\"3RSH_A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B: str=\"3RSH_B\"; break;\\r\\ncase SSL3_ST_CR_CERT_A: str=\"3RSC_A\"; break;\\r\\ncase SSL3_ST_CR_CERT_B: str=\"3RSC_B\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A: str=\"3RSKEA\"; break;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B: str=\"3RSKEB\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_A: str=\"3RCR_A\"; break;\\r\\ncase SSL3_ST_CR_CERT_REQ_B: str=\"3RCR_B\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A: str=\"3RSD_A\"; break;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B: str=\"3RSD_B\"; break;\\r\\ncase SSL3_ST_CW_CERT_A: str=\"3WCC_A\"; break;\\r\\ncase SSL3_ST_CW_CERT_B: str=\"3WCC_B\"; break;\\r\\ncase SSL3_ST_CW_CERT_C: str=\"3WCC_C\"; break;\\r\\ncase SSL3_ST_CW_CERT_D: str=\"3WCC_D\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A: str=\"3WCKEA\"; break;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B: str=\"3WCKEB\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A: str=\"3WCV_A\"; break;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B: str=\"3WCV_B\"; break;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_A: str=\"3WCCSA\"; break;\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ncase SSL3_ST_CW_CHANGE_B: str=\"3WCCSB\"; break;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_A: str=\"3WFINA\"; break;\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\ncase SSL3_ST_CW_FINISHED_B: str=\"3WFINB\"; break;\\r\\ncase SSL3_ST_SR_CHANGE_A:\\r\\ncase SSL3_ST_CR_CHANGE_A: str=\"3RCCSA\"; break;\\r\\ncase SSL3_ST_SR_CHANGE_B:\\r\\ncase SSL3_ST_CR_CHANGE_B: str=\"3RCCSB\"; break;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_A: str=\"3RFINA\"; break;\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\ncase SSL3_ST_CR_FINISHED_B: str=\"3RFINB\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A: str=\"3WHR_A\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B: str=\"3WHR_B\"; break;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C: str=\"3WHR_C\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A: str=\"3RCH_A\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B: str=\"3RCH_B\"; break;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C: str=\"3RCH_C\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A: str=\"3WSH_A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B: str=\"3WSH_B\"; break;\\r\\ncase SSL3_ST_SW_CERT_A: str=\"3WSC_A\"; break;\\r\\ncase SSL3_ST_SW_CERT_B: str=\"3WSC_B\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A: str=\"3WSKEA\"; break;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B: str=\"3WSKEB\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_A: str=\"3WCR_A\"; break;\\r\\ncase SSL3_ST_SW_CERT_REQ_B: str=\"3WCR_B\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A: str=\"3WSD_A\"; break;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B: str=\"3WSD_B\"; break;\\r\\ncase SSL3_ST_SR_CERT_A: str=\"3RCC_A\"; break;\\r\\ncase SSL3_ST_SR_CERT_B: str=\"3RCC_B\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A: str=\"3RCKEA\"; break;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B: str=\"3RCKEB\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A: str=\"3RCV_A\"; break;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B: str=\"3RCV_B\"; break;\\r\\n#endif\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A: str=\"23WCHA\"; break;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B: str=\"23WCHB\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A: str=\"23RSHA\"; break;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B: str=\"23RSHA\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A: str=\"23RCHA\"; break;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B: str=\"23RCHB\"; break;\\r\\n#endif\\r\\ndefault: str=\"UNKWN \"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nchar *SSL_alert_type_string_long(int value)\\r\\n{\\r\\nvalue>>=8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn(\"warning\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn(\"fatal\");\\r\\nelse\\r\\nreturn(\"unknown\");\\r\\n}\\r\\nchar *SSL_alert_type_string(int value)\\r\\n{\\r\\nvalue>>=8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn(\"W\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn(\"F\");\\r\\nelse\\r\\nreturn(\"U\");\\r\\n}\\r\\nchar *SSL_alert_desc_string(int value)\\r\\n{\\r\\nchar *str;\\r\\nswitch (value & 0xff)\\r\\n{\\r\\ncase SSL3_AD_CLOSE_NOTIFY: str=\"CN\"; break;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE: str=\"UM\"; break;\\r\\ncase SSL3_AD_BAD_RECORD_MAC: str=\"BM\"; break;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE: str=\"DF\"; break;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE: str=\"HF\"; break;\\r\\ncase SSL3_AD_NO_CERTIFICATE: str=\"NC\"; break;\\r\\ncase SSL3_AD_BAD_CERTIFICATE: str=\"BC\"; break;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE: str=\"UC\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED: str=\"CR\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED: str=\"CE\"; break;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN: str=\"CU\"; break;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER: str=\"IP\"; break;\\r\\ndefault: str=\"UK\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nchar *SSL_alert_desc_string_long(int value)\\r\\n{\\r\\nchar *str;\\r\\nswitch (value & 0xff)\\r\\n{\\r\\ncase SSL3_AD_CLOSE_NOTIFY:\\r\\nstr=\"close notify\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE:\\r\\nstr=\"unexected_message\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_RECORD_MAC:\\r\\nstr=\"bad record mac\";\\r\\nbreak;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE:\\r\\nstr=\"decompression failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE:\\r\\nstr=\"handshake failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_NO_CERTIFICATE:\\r\\nstr=\"no certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_CERTIFICATE:\\r\\nstr=\"bad certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE:\\r\\nstr=\"unsupported certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED:\\r\\nstr=\"certificate revoked\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED:\\r\\nstr=\"certificate expired\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN:\\r\\nstr=\"certifcate unknown\";\\r\\nbreak;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER:\\r\\nstr=\"illegal parameter\";\\r\\nbreak;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}\\r\\nchar *SSL_rstate_string(SSL *s)\\r\\n{\\r\\nchar *str;\\r\\nswitch (s->rstate)\\r\\n{\\r\\ncase SSL_ST_READ_HEADER:str=\"RH\"; break;\\r\\ncase SSL_ST_READ_BODY: str=\"RB\"; break;\\r\\ncase SSL_ST_READ_DONE: str=\"RD\"; break;\\r\\ndefault: str=\"unknown\"; break;\\r\\n}\\r\\nreturn(str);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsaref_c", "target": 0, "func": "RSA_METHOD *RSA_PKCS1_RSAref(void)\\r\\n{\\r\\nreturn(&rsa_pkcs1_ref_meth);\\r\\n}\\r\\nstatic int RSA_ref_mod_exp(BIGNUM *r0, BIGNUM *I, RSA *rsa)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int BN_ref_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_BN_REF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int RSAref_bn2bin(BIGNUM *from, unsigned char *to, int max)\\r\\n{\\r\\nint i;\\r\\ni=BN_num_bytes(from);\\r\\nif (i > max)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSAREF_BN2BIN,RSAREF_R_LEN);\\r\\nreturn(0);\\r\\n}\\r\\nmemset(to,0,(unsigned int)max);\\r\\nif (!BN_bn2bin(from,&(to[max-i])))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic BIGNUM *RSAref_bin2bn(unsigned char *from, BIGNUM *to, int max)\\r\\n{\\r\\nint i;\\r\\nBIGNUM *ret;\\r\\nfor (i=0; i<max; i++)\\r\\nif (from[i]) break;\\r\\nret=BN_bin2bn(&(from[i]),max-i,to);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int RSAref_Public_ref2eay(RSArefPublicKey *from, RSA *to)\\r\\n{\\r\\nto->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN);\\r\\nto->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN);\\r\\nif ((to->n == NULL) || (to->e == NULL)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Public_eay2ref(RSA *from, RSArefPublicKey *to)\\r\\n{\\r\\nto->bits=BN_num_bits(from->n);\\r\\nif (!RSAref_bn2bin(from->n,to->m,RSAref_MAX_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->e,to->e,RSAref_MAX_LEN)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Private_ref2eay(RSArefPrivateKey *from, RSA *to)\\r\\n{\\r\\nif ((to->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->d=RSAref_bin2bn(from->d,NULL,RSAref_MAX_LEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->p=RSAref_bin2bn(from->prime[0],NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->q=RSAref_bin2bn(from->prime[1],NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nif ((to->dmp1=RSAref_bin2bn(from->pexp[0],NULL,RSAref_MAX_PLEN))\\r\\n== NULL)\\r\\nreturn(0);\\r\\nif ((to->dmq1=RSAref_bin2bn(from->pexp[1],NULL,RSAref_MAX_PLEN))\\r\\n== NULL)\\r\\nreturn(0);\\r\\nif ((to->iqmp=RSAref_bin2bn(from->coef,NULL,RSAref_MAX_PLEN)) == NULL)\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int RSAref_Private_eay2ref(RSA *from, RSArefPrivateKey *to)\\r\\n{\\r\\nto->bits=BN_num_bits(from->n);\\r\\nif (!RSAref_bn2bin(from->n,to->m,RSAref_MAX_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->e,to->e,RSAref_MAX_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->d,to->d,RSAref_MAX_LEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->p,to->prime[0],RSAref_MAX_PLEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->q,to->prime[1],RSAref_MAX_PLEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->dmp1,to->pexp[0],RSAref_MAX_PLEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->dmq1,to->pexp[1],RSAref_MAX_PLEN)) return(0);\\r\\nif (!RSAref_bn2bin(from->iqmp,to->coef,RSAref_MAX_PLEN)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_ref_private_decrypt(int len, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nRSArefPrivateKey RSAkey;\\r\\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPrivateDecrypt(to,&outlen,from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PRIVATE_DECRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nint RSA_ref_private_encrypt(int len, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nRSArefPrivateKey RSAkey;\\r\\nif (padding != RSA_PKCS1_PADDING)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPrivateEncrypt(to,&outlen,from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PRIVATE_ENCRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nint RSA_ref_public_decrypt(int len, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint i,outlen= -1;\\r\\nRSArefPublicKey RSAkey;\\r\\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPublicDecrypt(to,&outlen,from,len,&RSAkey)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PUBLIC_DECRYPT,i);\\r\\noutlen= -1;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nreturn(outlen);\\r\\n}\\r\\nint RSA_ref_public_encrypt(int len, unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\nint outlen= -1;\\r\\nint i;\\r\\nRSArefPublicKey RSAkey;\\r\\nRSARandomState rnd;\\r\\nunsigned char buf[16];\\r\\nif (padding != RSA_PKCS1_PADDING && padding != RSA_SSLV23_PADDING)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nR_RandomInit(&rnd);\\r\\nR_GetRandomBytesNeeded((unsigned int *)&i,&rnd);\\r\\nwhile (i > 0)\\r\\n{\\r\\nRAND_bytes(buf,16);\\r\\nR_RandomUpdate(&rnd,buf,(unsigned int)((i>16)?16:i));\\r\\ni-=16;\\r\\n}\\r\\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\\r\\ngoto err;\\r\\nif ((i=RSAPublicEncrypt(to,&outlen,from,len,&RSAkey,&rnd)) != 0)\\r\\n{\\r\\nRSAREFerr(RSAREF_F_RSA_REF_PUBLIC_ENCRYPT,i);\\r\\noutlen= -1;\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nmemset(&RSAkey,0,sizeof(RSAkey));\\r\\nR_RandomFinal(&rnd);\\r\\nmemset(&rnd,0,sizeof(rnd));\\r\\nreturn(outlen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_ext_c", "target": 0, "func": "int X509_CRL_get_ext_count(X509_CRL *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->crl->extensions));\\r\\n}\\r\\nint X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->crl->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_OBJ(X509_CRL *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->crl->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->crl->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_get_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->crl->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->crl->extensions,loc));\\r\\n}\\r\\nint X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->crl->extensions),ex,loc) != NULL);\\r\\n}\\r\\nint X509_get_ext_count(X509 *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->cert_info->extensions));\\r\\n}\\r\\nint X509_get_ext_by_NID(X509 *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->cert_info->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->cert_info->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_get_ext_by_critical(X509 *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->cert_info->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_get_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->cert_info->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_delete_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->cert_info->extensions,loc));\\r\\n}\\r\\nint X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->cert_info->extensions),ex,loc) != NULL);\\r\\n}\\r\\nint X509_REVOKED_get_ext_count(X509_REVOKED *x)\\r\\n{\\r\\nreturn(X509v3_get_ext_count(x->extensions));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_NID(x->extensions,nid,lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_OBJ(x->extensions,obj,lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos)\\r\\n{\\r\\nreturn(X509v3_get_ext_by_critical(x->extensions,crit,lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn(X509v3_get_ext(x->extensions,loc));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn(X509v3_delete_ext(x->extensions,loc));\\r\\n}\\r\\nint X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn(X509v3_add_ext(&(x->extensions),ex,loc) != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_bmp_c", "target": 0, "func": "int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a, unsigned char **pp)\\r\\n{\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_BMPSTRING,V_ASN1_UNIVERSAL));\\r\\n}\\r\\nASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_BMPSTRING *ret=NULL;\\r\\nret=(ASN1_BMPSTRING *)d2i_ASN1_bytes((ASN1_STRING **)a,\\r\\npp,length,V_ASN1_BMPSTRING,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_BMPSTRING,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_txt_db_c", "target": 0, "func": "TXT_DB *TXT_DB_read(BIO *in, int num)\\r\\n{\\r\\nTXT_DB *ret=NULL;\\r\\nint er=1;\\r\\nint esc=0;\\r\\nlong ln=0;\\r\\nint i,add,n;\\r\\nint size=BUFSIZE;\\r\\nint offset=0;\\r\\nchar *p,**pp,*f;\\r\\nBUF_MEM *buf=NULL;\\r\\nif ((buf=BUF_MEM_new()) == NULL) goto err;\\r\\nif (!BUF_MEM_grow(buf,size)) goto err;\\r\\nif ((ret=(TXT_DB *)Malloc(sizeof(TXT_DB))) == NULL)\\r\\ngoto err;\\r\\nret->num_fields=num;\\r\\nret->index=NULL;\\r\\nret->qual=NULL;\\r\\nif ((ret->data=sk_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((ret->index=(LHASH **)Malloc(sizeof(LHASH *)*num)) == NULL)\\r\\ngoto err;\\r\\nif ((ret->qual=(int (**)())Malloc(sizeof(int (**)())*num)) == NULL)\\r\\ngoto err;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\nret->index[i]=NULL;\\r\\nret->qual[i]=NULL;\\r\\n}\\r\\nadd=(num+1)*sizeof(char *);\\r\\nbuf->data[size-1]='\\0';\\r\\noffset=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (offset != 0)\\r\\n{\\r\\nsize+=BUFSIZE;\\r\\nif (!BUF_MEM_grow(buf,size)) goto err;\\r\\n}\\r\\nbuf->data[offset]='\\0';\\r\\nBIO_gets(in,&(buf->data[offset]),size-offset);\\r\\nln++;\\r\\nif (buf->data[offset] == '\\0') break;\\r\\nif ((offset == 0) && (buf->data[0] == '#')) continue;\\r\\ni=strlen(&(buf->data[offset]));\\r\\noffset+=i;\\r\\nif (buf->data[offset-1] != '\\n')\\r\\ncontinue;\\r\\nelse\\r\\n{\\r\\nbuf->data[offset-1]='\\0';\\r\\np=(char *)Malloc(add+offset);\\r\\noffset=0;\\r\\n}\\r\\npp=(char **)p;\\r\\np+=add;\\r\\nn=0;\\r\\npp[n++]=p;\\r\\ni=0;\\r\\nf=buf->data;\\r\\nesc=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (*f == '\\0') break;\\r\\nif (*f == '\\t')\\r\\n{\\r\\nif (esc)\\r\\np--;\\r\\nelse\\r\\n{\\r\\n*(p++)='\\0';\\r\\nf++;\\r\\nif (n >= num) break;\\r\\npp[n++]=p;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nesc=(*f == '\\\\');\\r\\n*(p++)= *(f++);\\r\\n}\\r\\n*(p++)='\\0';\\r\\nif ((n != num) || (*f != '\\0'))\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\\n\",ln,num,n,f);\\r\\n#endif\\r\\ner=2;\\r\\ngoto err;\\r\\n}\\r\\npp[n]=p;\\r\\nif (!sk_push(ret->data,(char *)pp))\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"failure in sk_push\\n\");\\r\\n#endif\\r\\ner=2;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ner=0;\\r\\nerr:\\r\\nBUF_MEM_free(buf);\\r\\nif (er)\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nif (er == 1) fprintf(stderr,\"Malloc failure\\n\");\\r\\n#endif\\r\\nif (ret->data != NULL) sk_free(ret->data);\\r\\nif (ret->index != NULL) Free(ret->index);\\r\\nif (ret->qual != NULL) Free((char *)ret->qual);\\r\\nif (ret != NULL) Free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nreturn(ret);\\r\\n}\\r\\nchar **TXT_DB_get_by_index(TXT_DB *db, int idx, char **value)\\r\\n{\\r\\nchar **ret;\\r\\nLHASH *lh;\\r\\nif (idx >= db->num_fields)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\\r\\nreturn(NULL);\\r\\n}\\r\\nlh=db->index[idx];\\r\\nif (lh == NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_NO_INDEX;\\r\\nreturn(NULL);\\r\\n}\\r\\nret=(char **)lh_retrieve(lh,(char *)value);\\r\\ndb->error=DB_ERROR_OK;\\r\\nreturn(ret);\\r\\n}\\r\\nlong TXT_DB_write(BIO *out, TXT_DB *db)\\r\\n{\\r\\nlong i,j,n,nn,l,tot=0;\\r\\nchar *p,**pp,*f;\\r\\nBUF_MEM *buf=NULL;\\r\\nlong ret= -1;\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\ngoto err;\\r\\nn=sk_num(db->data);\\r\\nnn=db->num_fields;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\npp=(char **)sk_value(db->data,i);\\r\\nl=0;\\r\\nfor (j=0; j<nn; j++)\\r\\n{\\r\\nif (pp[j] != NULL)\\r\\nl+=strlen(pp[j]);\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,(int)(l*2+nn))) goto err;\\r\\np=buf->data;\\r\\nfor (j=0; j<nn; j++)\\r\\n{\\r\\nf=pp[j];\\r\\nif (f != NULL)\\r\\nfor (;;)\\r\\n{\\r\\nif (*f == '\\0') break;\\r\\nif (*f == '\\t') *(p++)='\\\\';\\r\\n*(p++)= *(f++);\\r\\n}\\r\\n*(p++)='\\t';\\r\\n}\\r\\np[-1]='\\n';\\r\\nj=p-buf->data;\\r\\nif (BIO_write(out,buf->data,(int)j) != j)\\r\\ngoto err;\\r\\ntot+=j;\\r\\n}\\r\\nret=tot;\\r\\nerr:\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nint TXT_DB_insert(TXT_DB *db, char **row)\\r\\n{\\r\\nint i;\\r\\nchar **r;\\r\\nfor (i=0; i<db->num_fields; i++)\\r\\n{\\r\\nif (db->index[i] != NULL)\\r\\n{\\r\\nif ((db->qual[i] != NULL) &&\\r\\n(db->qual[i](row) == 0)) continue;\\r\\nr=(char **)lh_retrieve(db->index[i],(char *)row);\\r\\nif (r != NULL)\\r\\n{\\r\\ndb->error=DB_ERROR_INDEX_CLASH;\\r\\ndb->arg1=i;\\r\\ndb->arg_row=r;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!sk_push(db->data,(char *)row))\\r\\n{\\r\\ndb->error=DB_ERROR_MALLOC;\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<db->num_fields; i++)\\r\\n{\\r\\nif (db->index[i] != NULL)\\r\\n{\\r\\nif ((db->qual[i] != NULL) &&\\r\\n(db->qual[i](row) == 0)) continue;\\r\\nlh_insert(db->index[i],(char *)row);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nvoid TXT_DB_free(TXT_DB *db)\\r\\n{\\r\\nint i,n;\\r\\nchar **p,*max;\\r\\nif(db == NULL)\\r\\nreturn;\\r\\nif (db->index != NULL)\\r\\n{\\r\\nfor (i=db->num_fields-1; i>=0; i--)\\r\\nif (db->index[i] != NULL) lh_free(db->index[i]);\\r\\nFree(db->index);\\r\\n}\\r\\nif (db->qual != NULL)\\r\\nFree(db->qual);\\r\\nif (db->data != NULL)\\r\\n{\\r\\nfor (i=sk_num(db->data)-1; i>=0; i--)\\r\\n{\\r\\np=(char **)sk_value(db->data,i);\\r\\nmax=p[db->num_fields];\\r\\nif (max == NULL)\\r\\n{\\r\\nfor (n=0; n<db->num_fields; n++)\\r\\nif (p[n] != NULL) Free(p[n]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (n=0; n<db->num_fields; n++)\\r\\n{\\r\\nif (((p[n] < (char *)p) || (p[n] > max))\\r\\n&& (p[n] != NULL))\\r\\nFree(p[n]);\\r\\n}\\r\\n}\\r\\nFree(sk_value(db->data,i));\\r\\n}\\r\\nsk_free(db->data);\\r\\n}\\r\\nFree(db);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3conf_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nLHASH *conf;\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nchar *conf_file;\\r\\nint i;\\r\\nint count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif(!argv[1]) {\\r\\nfprintf(stderr, \"Usage: v3conf cert.pem [file.cnf]\\n\");\\r\\nexit(1);\\r\\n}\\r\\nconf_file = argv[2];\\r\\nif(!conf_file) conf_file = \"test.cnf\";\\r\\nconf = CONF_load(NULL, \"test.cnf\", NULL);\\r\\nif(!conf) {\\r\\nfprintf(stderr, \"Error opening Config file %s\\n\", conf_file);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ninf = fopen(argv[1], \"r\");\\r\\nif(!inf) {\\r\\nfprintf(stderr, \"Can't open certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\ncert = PEM_read_X509(inf, NULL, NULL);\\r\\nif(!cert) {\\r\\nfprintf(stderr, \"Error reading certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\nsk_pop_free(cert->cert_info->extensions, X509_EXTENSION_free);\\r\\ncert->cert_info->extensions = NULL;\\r\\nif(!X509V3_EXT_add_conf(conf, NULL, \"test_section\", cert)) {\\r\\nfprintf(stderr, \"Error adding extensions\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor(i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif(ext->critical) printf(\",critical:\\n\");\\r\\nelse printf(\":\\n\");\\r\\nX509V3_EXT_print_fp(stdout, ext, 0);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_alpha_c", "target": 0, "func": "void func(a,b)\\r\\nTYPE *a;\\r\\nTYPE b;\\r\\n{\\r\\nprintf(\"%ld -1 == %ld\\n\",a[0],b);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nTYPE data[5]={1L,2L,3L,4L,5L};\\r\\nTYPE *p;\\r\\nint i;\\r\\np=data;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nfunc(p,*(p++));\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_lib_c", "target": 0, "func": "DSA *DSA_new(void)\\r\\n{\\r\\nDSA *ret;\\r\\nret=(DSA *)Malloc(sizeof(DSA));\\r\\nif (ret == NULL)\\r\\n{\\r\\nDSAerr(DSA_F_DSA_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->pad=0;\\r\\nret->version=0;\\r\\nret->write_params=1;\\r\\nret->p=NULL;\\r\\nret->q=NULL;\\r\\nret->g=NULL;\\r\\nret->flags=DSA_FLAG_CACHE_MONT_P;\\r\\nret->pub_key=NULL;\\r\\nret->priv_key=NULL;\\r\\nret->kinv=NULL;\\r\\nret->r=NULL;\\r\\nret->method_mont_p=NULL;\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid DSA_free(DSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL) return;\\r\\ni=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_DSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSA\",r);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"DSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->p != NULL) BN_clear_free(r->p);\\r\\nif (r->q != NULL) BN_clear_free(r->q);\\r\\nif (r->g != NULL) BN_clear_free(r->g);\\r\\nif (r->pub_key != NULL) BN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL) BN_clear_free(r->priv_key);\\r\\nif (r->kinv != NULL) BN_clear_free(r->kinv);\\r\\nif (r->r != NULL) BN_clear_free(r->r);\\r\\nif (r->method_mont_p != NULL)\\r\\nBN_MONT_CTX_free((BN_MONT_CTX *)r->method_mont_p);\\r\\nFree(r);\\r\\n}\\r\\nint DSA_size(DSA *r)\\r\\n{\\r\\nint ret,i;\\r\\nASN1_INTEGER bs;\\r\\nunsigned char buf[4];\\r\\ni=BN_num_bits(r->q);\\r\\nbs.length=(i+7)/8;\\r\\nbs.data=buf;\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbuf[0]=0xff;\\r\\ni=i2d_ASN1_INTEGER(&bs,NULL);\\r\\ni+=i;\\r\\nret=ASN1_object_size(1,i,V_ASN1_SEQUENCE);\\r\\nreturn(ret);\\r\\n}\\r\\nDH *DSA_dup_DH(DSA *r)\\r\\n{\\r\\nDH *ret = NULL;\\r\\nif (r == NULL)\\r\\ngoto err;\\r\\nret = DH_new();\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (r->p != NULL)\\r\\nif ((ret->p = BN_dup(r->p)) == NULL)\\r\\ngoto err;\\r\\nif (r->q != NULL)\\r\\nret->length = BN_num_bits(r->q);\\r\\nif (r->g != NULL)\\r\\nif ((ret->g = BN_dup(r->g)) == NULL)\\r\\ngoto err;\\r\\nif (r->pub_key != NULL)\\r\\nif ((ret->pub_key = BN_dup(r->pub_key)) == NULL)\\r\\ngoto err;\\r\\nif (r->priv_key != NULL)\\r\\nif ((ret->priv_key = BN_dup(r->priv_key)) == NULL)\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t1_enc_c", "target": 1, "func": "static void tls1_P_hash(const EVP_MD *md, const unsigned char *sec,\\r\\nint sec_len, unsigned char *seed, int seed_len,\\r\\nunsigned char *out, int olen)\\r\\n{\\r\\nint chunk,n;\\r\\nunsigned int j;\\r\\nHMAC_CTX ctx;\\r\\nHMAC_CTX ctx_tmp;\\r\\nunsigned char A1[HMAC_MAX_MD_CBLOCK];\\r\\nunsigned int A1_len;\\r\\nchunk=EVP_MD_size(md);\\r\\nHMAC_Init(&ctx,sec,sec_len,md);\\r\\nHMAC_Update(&ctx,seed,seed_len);\\r\\nHMAC_Final(&ctx,A1,&A1_len);\\r\\nn=0;\\r\\nfor (;;)\\r\\n{\\r\\nHMAC_Init(&ctx,NULL,0,NULL);\\r\\nHMAC_Update(&ctx,A1,A1_len);\\r\\nmemcpy(&ctx_tmp,&ctx,sizeof(ctx));\\r\\nHMAC_Update(&ctx,seed,seed_len);\\r\\nif (olen > chunk)\\r\\n{\\r\\nHMAC_Final(&ctx,out,&j);\\r\\nout+=j;\\r\\nolen-=j;\\r\\nHMAC_Final(&ctx_tmp,A1,&A1_len);\\r\\n}\\r\\nelse\\r\\n{\\r\\nHMAC_Final(&ctx,A1,&A1_len);\\r\\nmemcpy(out,A1,olen);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nHMAC_cleanup(&ctx);\\r\\nHMAC_cleanup(&ctx_tmp);\\r\\nmemset(A1,0,sizeof(A1));\\r\\n}\\r\\nstatic void tls1_PRF(const EVP_MD *md5, const EVP_MD *sha1,\\r\\nunsigned char *label, int label_len,\\r\\nconst unsigned char *sec, int slen, unsigned char *out1,\\r\\nunsigned char *out2, int olen)\\r\\n{\\r\\nint len,i;\\r\\nconst unsigned char *S1,*S2;\\r\\nlen=slen/2;\\r\\nS1=sec;\\r\\nS2= &(sec[len]);\\r\\nlen+=(slen&1);\\r\\ntls1_P_hash(md5 ,S1,len,label,label_len,out1,olen);\\r\\ntls1_P_hash(sha1,S2,len,label,label_len,out2,olen);\\r\\nfor (i=0; i<olen; i++)\\r\\nout1[i]^=out2[i];\\r\\n}\\r\\nstatic void tls1_generate_key_block(SSL *s, unsigned char *km,\\r\\nunsigned char *tmp, int num)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned char buf[SSL3_RANDOM_SIZE*2+\\r\\nTLS_MD_MAX_CONST_SIZE];\\r\\np=buf;\\r\\nmemcpy(p,TLS_MD_KEY_EXPANSION_CONST,\\r\\nTLS_MD_KEY_EXPANSION_CONST_SIZE);\\r\\np+=TLS_MD_KEY_EXPANSION_CONST_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),\\r\\ns->session->master_key,s->session->master_key_length,\\r\\nkm,tmp,num);\\r\\n}\\r\\nint tls1_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nstatic const unsigned char empty[]=\"\";\\r\\nunsigned char *p,*key_block,*mac_secret;\\r\\nunsigned char *exp_label,buf[TLS_MD_MAX_CONST_SIZE+\\r\\nSSL3_RANDOM_SIZE*2];\\r\\nunsigned char tmp1[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char tmp2[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv1[EVP_MAX_IV_LENGTH*2];\\r\\nunsigned char iv2[EVP_MAX_IV_LENGTH*2];\\r\\nunsigned char *ms,*key,*iv,*er1,*er2;\\r\\nint client_write;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\nconst SSL_COMP *comp;\\r\\nconst EVP_MD *m;\\r\\nint _exp,n,i,j,k,exp_label_len,cl;\\r\\n_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc=s->s3->tmp.new_sym_enc;\\r\\nm=s->s3->tmp.new_hash;\\r\\ncomp=s->s3->tmp.new_compression;\\r\\nkey_block=s->s3->tmp.key_block;\\r\\nif (which & SSL3_CC_READ)\\r\\n{\\r\\nif ((s->enc_read_ctx == NULL) &&\\r\\n((s->enc_read_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\ndd= s->enc_read_ctx;\\r\\ns->read_hash=m;\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->expand=COMP_CTX_new(comp->method);\\r\\nif (s->expand == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp=(unsigned char *)\\r\\nMalloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\nmemset(&(s->s3->read_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->read_mac_secret[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((s->enc_write_ctx == NULL) &&\\r\\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\ndd= s->enc_write_ctx;\\r\\ns->write_hash=m;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->compress=COMP_CTX_new(comp->method);\\r\\nif (s->compress == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\nmemset(&(s->s3->write_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->write_mac_secret[0]);\\r\\n}\\r\\nEVP_CIPHER_CTX_init(dd);\\r\\np=s->s3->tmp.key_block;\\r\\ni=EVP_MD_size(m);\\r\\ncl=EVP_CIPHER_key_length(c);\\r\\nj=_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nk=EVP_CIPHER_iv_length(c);\\r\\ner1= &(s->s3->client_random[0]);\\r\\ner2= &(s->s3->server_random[0]);\\r\\nif ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ))\\r\\n{\\r\\nms= &(p[ 0]); n=i+i;\\r\\nkey= &(p[ n]); n+=j+j;\\r\\niv= &(p[ n]); n+=k+k;\\r\\nexp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\\r\\nexp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\\r\\nclient_write=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=i;\\r\\nms= &(p[ n]); n+=i+j;\\r\\nkey= &(p[ n]); n+=j+k;\\r\\niv= &(p[ n]); n+=k;\\r\\nexp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\\r\\nexp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\\r\\nclient_write=0;\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nmemcpy(mac_secret,ms,i);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nmac key=\",which);\\r\\n{ int z; for (z=0; z<i; z++) printf(\"%02X%c\",ms[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\nif (_exp)\\r\\n{\\r\\np=buf;\\r\\nmemcpy(p,exp_label,exp_label_len);\\r\\np+=exp_label_len;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),key,j,\\r\\ntmp1,tmp2,EVP_CIPHER_key_length(c));\\r\\nkey=tmp1;\\r\\nif (k > 0)\\r\\n{\\r\\np=buf;\\r\\nmemcpy(p,TLS_MD_IV_BLOCK_CONST,\\r\\nTLS_MD_IV_BLOCK_CONST_SIZE);\\r\\np+=TLS_MD_IV_BLOCK_CONST_SIZE;\\r\\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,empty,0,\\r\\niv1,iv2,k*2);\\r\\nif (client_write)\\r\\niv=iv1;\\r\\nelse\\r\\niv= &(iv1[k]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length=0;\\r\\nEVP_CipherInit(dd,c,key,iv,(which & SSL3_CC_WRITE));\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nkey=\",which);\\r\\n{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(\"%02X%c\",key[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\niv=\");\\r\\n{ int z; for (z=0; z<k; z++) printf(\"%02X%c\",iv[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nmemset(tmp1,0,sizeof(tmp1));\\r\\nmemset(tmp2,0,sizeof(tmp1));\\r\\nmemset(iv1,0,sizeof(iv1));\\r\\nmemset(iv2,0,sizeof(iv2));\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn(0);\\r\\n}\\r\\nint tls1_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p1,*p2;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nSSL_COMP *comp;\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn(1);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn(0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc=c;\\r\\ns->s3->tmp.new_hash=hash;\\r\\nnum=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);\\r\\nnum*=2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p1=(unsigned char *)Malloc(num)) == NULL)\\r\\ngoto err;\\r\\nif ((p2=(unsigned char *)Malloc(num)) == NULL)\\r\\ngoto err;\\r\\ns->s3->tmp.key_block_length=num;\\r\\ns->s3->tmp.key_block=p1;\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"client random\\n\");\\r\\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf(\"%02X%c\",s->s3->client_random[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"server random\\n\");\\r\\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf(\"%02X%c\",s->s3->server_random[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"pre-master\\n\");\\r\\n{ int z; for (z=0; z<s->session->master_key_length; z++) printf(\"%02X%c\",s->session->master_key[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\ntls1_generate_key_block(s,p1,p2,num);\\r\\nmemset(p2,0,num);\\r\\nFree(p2);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"\\nkey block\\n\");\\r\\n{ int z; for (z=0; z<num; z++) printf(\"%02X%c\",p1[z],((z+1)%16)?' ':'\\n'); }\\r\\n#endif\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nint tls1_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs,i,ii,j,k,n=0;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send)\\r\\n{\\r\\nif (s->write_hash != NULL)\\r\\nn=EVP_MD_size(s->write_hash);\\r\\nds=s->enc_write_ctx;\\r\\nrec= &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->read_hash != NULL)\\r\\nn=EVP_MD_size(s->read_hash);\\r\\nds=s->enc_read_ctx;\\r\\nrec= &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\nif ((s->session == NULL) || (ds == NULL) ||\\r\\n(enc == NULL))\\r\\n{\\r\\nmemcpy(rec->data,rec->input,rec->length);\\r\\nrec->input=rec->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=rec->length;\\r\\nbs=EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send)\\r\\n{\\r\\ni=bs-((int)l%bs);\\r\\nj=i-1;\\r\\nif (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\nj++;\\r\\n}\\r\\nfor (k=(int)l; k<(int)(l+i); k++)\\r\\nrec->input[k]=j;\\r\\nl+=i;\\r\\nrec->length+=i;\\r\\n}\\r\\nEVP_Cipher(ds,rec->data,rec->input,l);\\r\\nif ((bs != 1) && !send)\\r\\n{\\r\\nii=i=rec->data[l-1];\\r\\ni++;\\r\\nif (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)\\r\\n{\\r\\nif ((memcmp(s->s3->read_sequence,\\r\\n\"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) && !(ii & 1))\\r\\ns->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\ni--;\\r\\n}\\r\\nif (i > (int)rec->length)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\\r\\nreturn(0);\\r\\n}\\r\\nfor (j=(int)(l-i); j<(int)l; j++)\\r\\n{\\r\\nif (rec->data[j] != ii)\\r\\n{\\r\\nSSLerr(SSL_F_TLS1_ENC,SSL_R_DECRYPTION_FAILED);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nrec->length-=i;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in_ctx, unsigned char *out)\\r\\n{\\r\\nunsigned int ret;\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_MD_CTX_copy(&ctx,in_ctx);\\r\\nEVP_DigestFinal(&ctx,out,&ret);\\r\\nreturn((int)ret);\\r\\n}\\r\\nint tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,\\r\\nunsigned char *str, int slen, unsigned char *out)\\r\\n{\\r\\nunsigned int i;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char buf[TLS_MD_MAX_CONST_SIZE+MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\nunsigned char *q,buf2[12];\\r\\nq=buf;\\r\\nmemcpy(q,str,slen);\\r\\nq+=slen;\\r\\nEVP_MD_CTX_copy(&ctx,in1_ctx);\\r\\nEVP_DigestFinal(&ctx,q,&i);\\r\\nq+=i;\\r\\nEVP_MD_CTX_copy(&ctx,in2_ctx);\\r\\nEVP_DigestFinal(&ctx,q,&i);\\r\\nq+=i;\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(q-buf),\\r\\ns->session->master_key,s->session->master_key_length,\\r\\nout,buf2,12);\\r\\nmemset(&ctx,0,sizeof(EVP_MD_CTX));\\r\\nreturn((int)12);\\r\\n}\\r\\nint tls1_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *mac_sec,*seq;\\r\\nconst EVP_MD *hash;\\r\\nunsigned int md_size;\\r\\nint i;\\r\\nHMAC_CTX hmac;\\r\\nunsigned char buf[5];\\r\\nif (send)\\r\\n{\\r\\nrec= &(ssl->s3->wrec);\\r\\nmac_sec= &(ssl->s3->write_mac_secret[0]);\\r\\nseq= &(ssl->s3->write_sequence[0]);\\r\\nhash=ssl->write_hash;\\r\\n}\\r\\nelse\\r\\n{\\r\\nrec= &(ssl->s3->rrec);\\r\\nmac_sec= &(ssl->s3->read_mac_secret[0]);\\r\\nseq= &(ssl->s3->read_sequence[0]);\\r\\nhash=ssl->read_hash;\\r\\n}\\r\\nmd_size=EVP_MD_size(hash);\\r\\nbuf[0]=rec->type;\\r\\nbuf[1]=TLS1_VERSION_MAJOR;\\r\\nbuf[2]=TLS1_VERSION_MINOR;\\r\\nbuf[3]=rec->length>>8;\\r\\nbuf[4]=rec->length&0xff;\\r\\nHMAC_Init(&hmac,mac_sec,EVP_MD_size(hash),hash);\\r\\nHMAC_Update(&hmac,seq,8);\\r\\nHMAC_Update(&hmac,buf,5);\\r\\nHMAC_Update(&hmac,rec->input,rec->length);\\r\\nHMAC_Final(&hmac,md,&md_size);\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"sec=\");\\r\\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",mac_sec[z]); printf(\"\\n\"); }\\r\\nprintf(\"seq=\");\\r\\n{int z; for (z=0; z<8; z++) printf(\"%02X \",seq[z]); printf(\"\\n\"); }\\r\\nprintf(\"buf=\");\\r\\n{int z; for (z=0; z<5; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\\r\\nprintf(\"rec=\");\\r\\n{unsigned int z; for (z=0; z<rec->length; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\\r\\n#endif\\r\\nfor (i=7; i>=0; i--)\\r\\nif (++seq[i]) break;\\r\\n#ifdef TLS_DEBUG\\r\\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",md[z]); printf(\"\\n\"); }\\r\\n#endif\\r\\nreturn(md_size);\\r\\n}\\r\\nint tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nunsigned char buf[SSL3_RANDOM_SIZE*2+TLS_MD_MASTER_SECRET_CONST_SIZE];\\r\\nunsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nmemcpy(buf,TLS_MD_MASTER_SECRET_CONST,\\r\\nTLS_MD_MASTER_SECRET_CONST_SIZE);\\r\\nmemcpy(&(buf[TLS_MD_MASTER_SECRET_CONST_SIZE]),\\r\\ns->s3->client_random,SSL3_RANDOM_SIZE);\\r\\nmemcpy(&(buf[SSL3_RANDOM_SIZE+TLS_MD_MASTER_SECRET_CONST_SIZE]),\\r\\ns->s3->server_random,SSL3_RANDOM_SIZE);\\r\\ntls1_PRF(s->ctx->md5,s->ctx->sha1,\\r\\nbuf,TLS_MD_MASTER_SECRET_CONST_SIZE+SSL3_RANDOM_SIZE*2,p,len,\\r\\ns->session->master_key,buff,SSL3_MASTER_SECRET_SIZE);\\r\\nreturn(SSL3_MASTER_SECRET_SIZE);\\r\\n}\\r\\nint tls1_alert_code(int code)\\r\\n{\\r\\nswitch (code)\\r\\n{\\r\\ncase SSL_AD_CLOSE_NOTIFY: return(SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE: return(SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED: return(TLS1_AD_DECRYPTION_FAILED);\\r\\ncase SSL_AD_RECORD_OVERFLOW: return(TLS1_AD_RECORD_OVERFLOW);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE: return(-1);\\r\\ncase SSL_AD_BAD_CERTIFICATE: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER: return(SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA: return(TLS1_AD_UNKNOWN_CA);\\r\\ncase SSL_AD_ACCESS_DENIED: return(TLS1_AD_ACCESS_DENIED);\\r\\ncase SSL_AD_DECODE_ERROR: return(TLS1_AD_DECODE_ERROR);\\r\\ncase SSL_AD_DECRYPT_ERROR: return(TLS1_AD_DECRYPT_ERROR);\\r\\ncase SSL_AD_EXPORT_RESTRICION: return(TLS1_AD_EXPORT_RESTRICION);\\r\\ncase SSL_AD_PROTOCOL_VERSION: return(TLS1_AD_PROTOCOL_VERSION);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:return(TLS1_AD_INSUFFICIENT_SECURITY);\\r\\ncase SSL_AD_INTERNAL_ERROR: return(TLS1_AD_INTERNAL_ERROR);\\r\\ncase SSL_AD_USER_CANCLED: return(TLS1_AD_USER_CANCLED);\\r\\ncase SSL_AD_NO_RENEGOTIATION: return(TLS1_AD_NO_RENEGOTIATION);\\r\\ndefault: return(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_c", "target": 1, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1;\\r\\nX509_REQ *req=NULL;\\r\\nX509 *x=NULL,*xca=NULL;\\r\\nEVP_PKEY *Upkey=NULL,*CApkey=NULL;\\r\\nint i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nBIO *STDout=NULL;\\r\\nint informat,outformat,keyformat,CAformat,CAkeyformat;\\r\\nchar *infile=NULL,*outfile=NULL,*keyfile=NULL,*CAfile=NULL;\\r\\nchar *CAkeyfile=NULL,*CAserial=NULL;\\r\\nint text=0,serial=0,hash=0,subject=0,issuer=0,startdate=0,enddate=0;\\r\\nint noout=0,sign_flag=0,CA_flag=0,CA_createserial=0;\\r\\nint C=0;\\r\\nint x509req=0,days=DEF_DAYS,modulus=0;\\r\\nchar **pp;\\r\\nX509_STORE *ctx=NULL;\\r\\nX509_REQ *rq=NULL;\\r\\nint fingerprint=0;\\r\\nchar buf[256];\\r\\nconst EVP_MD *md_alg,*digest=EVP_md5();\\r\\nLHASH *extconf = NULL;\\r\\nchar *extsect = NULL, *extfile = NULL;\\r\\nreqfile=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nSTDout=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nkeyformat=FORMAT_PEM;\\r\\nCAformat=FORMAT_PEM;\\r\\nCAkeyformat=FORMAT_PEM;\\r\\nctx=X509_STORE_new();\\r\\nif (ctx == NULL) goto end;\\r\\nX509_STORE_set_verify_cb_func(ctx,callb);\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-req\") == 0)\\r\\nreqfile=1;\\r\\nelse if (strcmp(*argv,\"-CAform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAkeyform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays=atoi(*(++argv));\\r\\nif (days == 0)\\r\\n{\\r\\nBIO_printf(STDout,\"bad number of days\\n\");\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\nelse if (strcmp(*argv,\"-extfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nextfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-signkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\nsign_flag= ++num;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CA\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\nCA_flag= ++num;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAserial\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAserial= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-C\") == 0)\\r\\nC= ++num;\\r\\nelse if (strcmp(*argv,\"-serial\") == 0)\\r\\nserial= ++num;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus= ++num;\\r\\nelse if (strcmp(*argv,\"-x509toreq\") == 0)\\r\\nx509req= ++num;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext= ++num;\\r\\nelse if (strcmp(*argv,\"-hash\") == 0)\\r\\nhash= ++num;\\r\\nelse if (strcmp(*argv,\"-subject\") == 0)\\r\\nsubject= ++num;\\r\\nelse if (strcmp(*argv,\"-issuer\") == 0)\\r\\nissuer= ++num;\\r\\nelse if (strcmp(*argv,\"-fingerprint\") == 0)\\r\\nfingerprint= ++num;\\r\\nelse if (strcmp(*argv,\"-dates\") == 0)\\r\\n{\\r\\nstartdate= ++num;\\r\\nenddate= ++num;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-startdate\") == 0)\\r\\nstartdate= ++num;\\r\\nelse if (strcmp(*argv,\"-enddate\") == 0)\\r\\nenddate= ++num;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse if (strcmp(*argv,\"-CAcreateserial\") == 0)\\r\\nCA_createserial= ++num;\\r\\nelse if ((md_alg=EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\n{\\r\\ndigest=md_alg;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=x509_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,*pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nX509V3_add_standard_extensions();\\r\\nif (!X509_STORE_set_default_paths(ctx))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif ((CAkeyfile == NULL) && (CA_flag) && (CAformat == FORMAT_PEM))\\r\\n{ CAkeyfile=CAfile; }\\r\\nelse if ((CA_flag) && (CAkeyfile == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"need to specify a CAkey if using the CA command\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (extfile) {\\r\\nlong errorline;\\r\\nX509V3_CTX ctx2;\\r\\nif (!(extconf=CONF_load(NULL,extfile,&errorline))) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err,\\r\\n\"error loading the config file '%s'\\n\",\\r\\nextfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\\r\\n\"error on line %ld of config file '%s'\\n\"\\r\\n,errorline,extfile);\\r\\ngoto end;\\r\\n}\\r\\nif(!(extsect = CONF_get_string(extconf, \"default\",\\r\\n\"extensions\"))) extsect = \"default\";\\r\\nX509V3_set_ctx_test(&ctx2);\\r\\nX509V3_set_conf_lhash(&ctx2, extconf);\\r\\nif(!X509V3_EXT_add_conf(extconf, &ctx2, extsect, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextsect);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (reqfile)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nX509_CINF *ci;\\r\\nBIO *in;\\r\\nif (!sign_flag && !CA_flag)\\r\\n{\\r\\nBIO_printf(bio_err,\"We need a private key to sign with\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nreq=PEM_read_bio_X509_REQ(in,NULL,NULL,NULL);\\r\\nBIO_free(in);\\r\\nif (req == NULL) { perror(infile); goto end; }\\r\\nif ( (req->req_info == NULL) ||\\r\\n(req->req_info->pubkey == NULL) ||\\r\\n(req->req_info->pubkey->public_key == NULL) ||\\r\\n(req->req_info->pubkey->public_key->data == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"The certificate request appears to corrupted\\n\");\\r\\nBIO_printf(bio_err,\"It does not contain a public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((pkey=X509_REQ_get_pubkey(req)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error unpacking public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni=X509_REQ_verify(req,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"Signature verification error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"Signature did not match the certificate request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\nBIO_printf(bio_err,\"Signature ok\\n\");\\r\\nX509_NAME_oneline(req->req_info->subject,buf,256);\\r\\nBIO_printf(bio_err,\"subject=%s\\n\",buf);\\r\\nif ((x=X509_new()) == NULL) goto end;\\r\\nci=x->cert_info;\\r\\nif (!ASN1_INTEGER_set(X509_get_serialNumber(x),0)) goto end;\\r\\nif (!X509_set_issuer_name(x,req->req_info->subject)) goto end;\\r\\nif (!X509_set_subject_name(x,req->req_info->subject)) goto end;\\r\\nX509_gmtime_adj(X509_get_notBefore(x),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);\\r\\n#if 0\\r\\nX509_PUBKEY_free(ci->key);\\r\\nci->key=req->req_info->pubkey;\\r\\nreq->req_info->pubkey=NULL;\\r\\n#else\\r\\npkey = X509_REQ_get_pubkey(req);\\r\\nX509_set_pubkey(x,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n#endif\\r\\n}\\r\\nelse\\r\\nx=load_cert(infile,informat);\\r\\nif (x == NULL) goto end;\\r\\nif (CA_flag)\\r\\n{\\r\\nxca=load_cert(CAfile,CAformat);\\r\\nif (xca == NULL) goto end;\\r\\n}\\r\\nif (!noout || text)\\r\\n{\\r\\nOBJ_create(\"2.99999.3\",\\r\\n\"SET.ex3\",\"SET x509v3 extension 3\");\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (num)\\r\\n{\\r\\nfor (i=1; i<=num; i++)\\r\\n{\\r\\nif (issuer == i)\\r\\n{\\r\\nX509_NAME_oneline(X509_get_issuer_name(x),\\r\\nbuf,256);\\r\\nBIO_printf(STDout,\"issuer= %s\\n\",buf);\\r\\n}\\r\\nelse if (subject == i)\\r\\n{\\r\\nX509_NAME_oneline(X509_get_subject_name(x),\\r\\nbuf,256);\\r\\nBIO_printf(STDout,\"subject=%s\\n\",buf);\\r\\n}\\r\\nelse if (serial == i)\\r\\n{\\r\\nBIO_printf(STDout,\"serial=\");\\r\\ni2a_ASN1_INTEGER(STDout,x->cert_info->serialNumber);\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nelse if (hash == i)\\r\\n{\\r\\nBIO_printf(STDout,\"%08lx\\n\",X509_subject_name_hash(x));\\r\\n}\\r\\nelse\\r\\nif (modulus == i)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Modulus=unavailable\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout,\"Modulus=\");\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nBN_print(STDout,pkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nBN_print(STDout,pkey->pkey.dsa->pub_key);\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(STDout,\"Wrong Algorithm type\");\\r\\nBIO_printf(STDout,\"\\n\");\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nelse\\r\\nif (C == i)\\r\\n{\\r\\nunsigned char *d;\\r\\nchar *m;\\r\\nint y,z;\\r\\nX509_NAME_oneline(X509_get_subject_name(x),\\r\\nbuf,256);\\r\\nBIO_printf(STDout,\"/* subject:%s */\\n\",buf);\\r\\nm=X509_NAME_oneline(\\r\\nX509_get_issuer_name(x),buf,256);\\r\\nBIO_printf(STDout,\"/* issuer :%s */\\n\",buf);\\r\\nz=i2d_X509(x,NULL);\\r\\nm=Malloc(z);\\r\\nd=(unsigned char *)m;\\r\\nz=i2d_X509_NAME(X509_get_subject_name(x),&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_subject_name[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f) BIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nz=i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x),&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_public_key[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nz=i2d_X509(x,&d);\\r\\nBIO_printf(STDout,\"unsigned char XXX_certificate[%d]={\\n\",z);\\r\\nd=(unsigned char *)m;\\r\\nfor (y=0; y<z; y++)\\r\\n{\\r\\nBIO_printf(STDout,\"0x%02X,\",d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nif (y%16 != 0) BIO_printf(STDout,\"\\n\");\\r\\nBIO_printf(STDout,\"};\\n\");\\r\\nFree(m);\\r\\n}\\r\\nelse if (text == i)\\r\\n{\\r\\nX509_print(out,x);\\r\\n}\\r\\nelse if (startdate == i)\\r\\n{\\r\\nBIO_puts(STDout,\"notBefore=\");\\r\\nASN1_TIME_print(STDout,X509_get_notBefore(x));\\r\\nBIO_puts(STDout,\"\\n\");\\r\\n}\\r\\nelse if (enddate == i)\\r\\n{\\r\\nBIO_puts(STDout,\"notAfter=\");\\r\\nASN1_TIME_print(STDout,X509_get_notAfter(x));\\r\\nBIO_puts(STDout,\"\\n\");\\r\\n}\\r\\nelse if (fingerprint == i)\\r\\n{\\r\\nint j;\\r\\nunsigned int n;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!X509_digest(x,EVP_md5(),md,&n))\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout,\"MD5 Fingerprint=\");\\r\\nfor (j=0; j<(int)n; j++)\\r\\n{\\r\\nBIO_printf(STDout,\"%02X%c\",md[j],\\r\\n(j+1 == (int)n)\\r\\n?'\\n':':');\\r\\n}\\r\\n}\\r\\nelse if ((sign_flag == i) && (x509req == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"Getting Private key\\n\");\\r\\nif (Upkey == NULL)\\r\\n{\\r\\nUpkey=load_key(keyfile,keyformat);\\r\\nif (Upkey == NULL) goto end;\\r\\n}\\r\\n#ifndef NO_DSA\\r\\nif (Upkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\nif (!sign(x,Upkey,days,digest,\\r\\nextconf, extsect)) goto end;\\r\\n}\\r\\nelse if (CA_flag == i)\\r\\n{\\r\\nBIO_printf(bio_err,\"Getting CA Private Key\\n\");\\r\\nif (CAkeyfile != NULL)\\r\\n{\\r\\nCApkey=load_key(CAkeyfile,CAkeyformat);\\r\\nif (CApkey == NULL) goto end;\\r\\n}\\r\\n#ifndef NO_DSA\\r\\nif (CApkey->type == EVP_PKEY_DSA)\\r\\ndigest=EVP_dss1();\\r\\n#endif\\r\\nif (!x509_certify(ctx,CAfile,digest,x,xca,\\r\\nCApkey, CAserial,CA_createserial,days,\\r\\nextconf, extsect))\\r\\ngoto end;\\r\\n}\\r\\nelse if (x509req == i)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nBIO_printf(bio_err,\"Getting request Private Key\\n\");\\r\\nif (keyfile == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no request key file specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\npk=load_key(keyfile,FORMAT_PEM);\\r\\nif (pk == NULL) goto end;\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating certificate request\\n\");\\r\\nrq=X509_to_X509_REQ(x,pk,EVP_md5());\\r\\nEVP_PKEY_free(pk);\\r\\nif (rq == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!noout)\\r\\n{\\r\\nX509_REQ_print(out,rq);\\r\\nPEM_write_bio_X509_REQ(out,rq);\\r\\n}\\r\\nnoout=1;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (noout)\\r\\n{\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_X509_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509(out,x);\\r\\nelse if (outformat == FORMAT_NETSCAPE)\\r\\n{\\r\\nASN1_HEADER ah;\\r\\nASN1_OCTET_STRING os;\\r\\nos.data=(unsigned char *)CERT_HDR;\\r\\nos.length=strlen(CERT_HDR);\\r\\nah.header= &os;\\r\\nah.data=(char *)x;\\r\\nah.meth=X509_asn1_meth();\\r\\ni=ASN1_i2d_bio(i2d_ASN1_HEADER,out,(unsigned char *)&ah);\\r\\n}\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err,\"unable to write certificate\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nOBJ_cleanup();\\r\\nCONF_free(extconf);\\r\\nBIO_free(out);\\r\\nBIO_free(STDout);\\r\\nX509_STORE_free(ctx);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x);\\r\\nX509_free(xca);\\r\\nEVP_PKEY_free(Upkey);\\r\\nEVP_PKEY_free(CApkey);\\r\\nX509_REQ_free(rq);\\r\\nX509V3_EXT_cleanup();\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic int x509_certify(X509_STORE *ctx, char *CAfile, const EVP_MD *digest,\\r\\nX509 *x, X509 *xca, EVP_PKEY *pkey, char *serialfile, int create,\\r\\nint days, LHASH *conf, char *section)\\r\\n{\\r\\nint ret=0;\\r\\nBIO *io=NULL;\\r\\nMS_STATIC char buf2[1024];\\r\\nchar *buf=NULL,*p;\\r\\nBIGNUM *serial=NULL;\\r\\nASN1_INTEGER *bs=NULL,bs2;\\r\\nX509_STORE_CTX xsc;\\r\\nEVP_PKEY *upkey;\\r\\nupkey = X509_get_pubkey(xca);\\r\\nEVP_PKEY_copy_parameters(upkey,pkey);\\r\\nEVP_PKEY_free(upkey);\\r\\nX509_STORE_CTX_init(&xsc,ctx,x,NULL);\\r\\nbuf=(char *)Malloc(EVP_PKEY_size(pkey)*2+\\r\\n((serialfile == NULL)\\r\\n?(strlen(CAfile)+strlen(POSTFIX)+1)\\r\\n:(strlen(serialfile)))+1);\\r\\nif (buf == NULL) { BIO_printf(bio_err,\"out of mem\\n\"); goto end; }\\r\\nif (serialfile == NULL)\\r\\n{\\r\\nstrcpy(buf,CAfile);\\r\\nfor (p=buf; *p; p++)\\r\\nif (*p == '.')\\r\\n{\\r\\n*p='\\0';\\r\\nbreak;\\r\\n}\\r\\nstrcat(buf,POSTFIX);\\r\\n}\\r\\nelse\\r\\nstrcpy(buf,serialfile);\\r\\nserial=BN_new();\\r\\nbs=ASN1_INTEGER_new();\\r\\nif ((serial == NULL) || (bs == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nio=BIO_new(BIO_s_file());\\r\\nif (io == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(io,buf) <= 0)\\r\\n{\\r\\nif (!create)\\r\\n{\\r\\nperror(buf);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nASN1_INTEGER_set(bs,0);\\r\\nBN_zero(serial);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!a2i_ASN1_INTEGER(io,bs,buf2,1024))\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load serial number from %s\\n\",buf);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nserial=BN_bin2bn(bs->data,bs->length,serial);\\r\\nif (serial == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error converting bin 2 bn\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!BN_add_word(serial,1))\\r\\n{ BIO_printf(bio_err,\"add_word failure\\n\"); goto end; }\\r\\nbs2.data=(unsigned char *)buf2;\\r\\nbs2.length=BN_bn2bin(serial,bs2.data);\\r\\nif (BIO_write_filename(io,buf) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"error attempting to write serial number file\\n\");\\r\\nperror(buf);\\r\\ngoto end;\\r\\n}\\r\\ni2a_ASN1_INTEGER(io,&bs2);\\r\\nBIO_puts(io,\"\\n\");\\r\\nBIO_free(io);\\r\\nio=NULL;\\r\\nif (!X509_STORE_add_cert(ctx,x)) goto end;\\r\\nX509_STORE_CTX_set_cert(&xsc,x);\\r\\nif (!reqfile && !X509_verify_cert(&xsc))\\r\\ngoto end;\\r\\nif (!X509_check_private_key(xca,pkey))\\r\\n{\\r\\nBIO_printf(bio_err,\"CA certificate and CA private key do not match\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_set_issuer_name(x,X509_get_subject_name(xca))) goto end;\\r\\nif (!X509_set_serialNumber(x,bs)) goto end;\\r\\nif (X509_gmtime_adj(X509_get_notBefore(x),0L) == NULL)\\r\\ngoto end;\\r\\nif (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)\\r\\ngoto end;\\r\\nif(conf) {\\r\\nX509V3_CTX ctx2;\\r\\nX509_set_version(x,2);\\r\\nX509V3_set_ctx(&ctx2, xca, x, NULL, NULL, 0);\\r\\nX509V3_set_conf_lhash(&ctx2, conf);\\r\\nif(!X509V3_EXT_add_conf(conf, &ctx2, section, x)) goto end;\\r\\n}\\r\\nif (!X509_sign(x,pkey,digest)) goto end;\\r\\nret=1;\\r\\nend:\\r\\nX509_STORE_CTX_cleanup(&xsc);\\r\\nif (!ret)\\r\\nERR_print_errors(bio_err);\\r\\nif (buf != NULL) Free(buf);\\r\\nif (bs != NULL) ASN1_INTEGER_free(bs);\\r\\nif (io != NULL) BIO_free(io);\\r\\nif (serial != NULL) BN_free(serial);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nint err;\\r\\nX509 *err_cert;\\r\\nerr=X509_STORE_CTX_get_error(ctx);\\r\\nif (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\\r\\nreturn(1);\\r\\nif (ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"error with certificate to be certified - should be self signed\\n\");\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);\\r\\nBIO_printf(bio_err,\"%s\\n\",buf);\\r\\nBIO_printf(bio_err,\"error with certificate - error %d at depth %d\\n%s\\n\",\\r\\nerr,X509_STORE_CTX_get_error_depth(ctx),\\r\\nX509_verify_cert_error_string(err));\\r\\nreturn(1);\\r\\n}\\r\\n}\\r\\nstatic EVP_PKEY *load_key(char *file, int format)\\r\\n{\\r\\nBIO *key=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nif (file == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no keyfile specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nkey=BIO_new(BIO_s_file());\\r\\nif (key == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(key,file) <= 0)\\r\\n{\\r\\nperror(file);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef NO_RSA\\r\\nif (format == FORMAT_ASN1)\\r\\n{\\r\\nRSA *rsa;\\r\\nrsa=d2i_RSAPrivateKey_bio(key,NULL);\\r\\nif (rsa != NULL)\\r\\n{\\r\\nif ((pkey=EVP_PKEY_new()) != NULL)\\r\\nEVP_PKEY_assign_RSA(pkey,rsa);\\r\\nelse\\r\\nRSA_free(rsa);\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nif (format == FORMAT_PEM)\\r\\n{\\r\\npkey=PEM_read_bio_PrivateKey(key,NULL,NULL,NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (key != NULL) BIO_free(key);\\r\\nif (pkey == NULL)\\r\\nBIO_printf(bio_err,\"unable to load Private Key\\n\");\\r\\nreturn(pkey);\\r\\n}\\r\\nstatic X509 *load_cert(char *file, int format)\\r\\n{\\r\\nASN1_HEADER *ah=NULL;\\r\\nBUF_MEM *buf=NULL;\\r\\nX509 *x=NULL;\\r\\nBIO *cert;\\r\\nif ((cert=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL)\\r\\nBIO_set_fp(cert,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(cert,file) <= 0)\\r\\n{\\r\\nperror(file);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_X509_bio(cert,NULL);\\r\\nelse if (format == FORMAT_NETSCAPE)\\r\\n{\\r\\nunsigned char *p,*op;\\r\\nint size=0,i;\\r\\nbuf=BUF_MEM_new();\\r\\nfor (;;)\\r\\n{\\r\\nif ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))\\r\\ngoto end;\\r\\ni=BIO_read(cert,&(buf->data[size]),1024*10);\\r\\nsize+=i;\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nperror(\"reading certificate\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np=(unsigned char *)buf->data;\\r\\nop=p;\\r\\nif ((ah=d2i_ASN1_HEADER(NULL,&p,(long)size)) == NULL)\\r\\ngoto end;\\r\\nif ((ah->header == NULL) || (ah->header->data == NULL) ||\\r\\n(strncmp(CERT_HDR,(char *)ah->header->data,\\r\\nah->header->length) != 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"Error reading header on certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\np=op;\\r\\nah->meth=X509_asn1_meth();\\r\\nif ((ah=d2i_ASN1_HEADER(&ah,&p,(long)size)) == NULL)\\r\\ngoto end;\\r\\nx=(X509 *)ah->data;\\r\\nah->data=NULL;\\r\\n}\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_X509(cert,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input cert\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load certificate\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (ah != NULL) ASN1_HEADER_free(ah);\\r\\nif (cert != NULL) BIO_free(cert);\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(x);\\r\\n}\\r\\nstatic int sign(X509 *x, EVP_PKEY *pkey, int days, const EVP_MD *digest,\\r\\nLHASH *conf, char *section)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(x);\\r\\nEVP_PKEY_copy_parameters(pktmp,pkey);\\r\\nEVP_PKEY_save_parameters(pktmp,1);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!X509_set_issuer_name(x,X509_get_subject_name(x))) goto err;\\r\\nif (X509_gmtime_adj(X509_get_notBefore(x),0) == NULL) goto err;\\r\\nif (X509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days) == NULL)\\r\\ngoto err;\\r\\nif (!X509_set_pubkey(x,pkey)) goto err;\\r\\nif(conf) {\\r\\nX509V3_CTX ctx;\\r\\nX509_set_version(x,2);\\r\\nX509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);\\r\\nX509V3_set_conf_lhash(&ctx, conf);\\r\\nif(!X509V3_EXT_add_conf(conf, &ctx, section, x)) goto err;\\r\\n}\\r\\nif (!X509_sign(x,pkey,digest)) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_s_e_c", "target": 0, "func": "int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len_SET_type(PKCS7_RECIP_INFO,a->recipientinfo,\\r\\ni2d_PKCS7_RECIP_INFO);\\r\\nM_ASN1_I2D_len_SET_type(X509_ALGOR,a->md_algs,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_len_IMP_SEQUENCE_opt_type(X509,a->cert,i2d_X509,0);\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type(X509_CRL,a->crl,i2d_X509_CRL,1);\\r\\nM_ASN1_I2D_len_SET_type(PKCS7_SIGNER_INFO,a->signer_info,\\r\\ni2d_PKCS7_SIGNER_INFO);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put_SET_type(PKCS7_RECIP_INFO,a->recipientinfo,\\r\\ni2d_PKCS7_RECIP_INFO);\\r\\nM_ASN1_I2D_put_SET_type(X509_ALGOR,a->md_algs,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->enc_data,i2d_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_I2D_put_IMP_SEQUENCE_opt_type(X509,a->cert,i2d_X509,0);\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type(X509_CRL,a->crl,i2d_X509_CRL,1);\\r\\nM_ASN1_I2D_put_SET_type(PKCS7_SIGNER_INFO,a->signer_info,\\r\\ni2d_PKCS7_SIGNER_INFO);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_SIGN_ENVELOPE *d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_SIGN_ENVELOPE *,PKCS7_SIGN_ENVELOPE_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_set_type(PKCS7_RECIP_INFO,ret->recipientinfo,\\r\\nd2i_PKCS7_RECIP_INFO,PKCS7_RECIP_INFO_free);\\r\\nM_ASN1_D2I_get_set_type(X509_ALGOR,ret->md_algs,d2i_X509_ALGOR,\\r\\nX509_ALGOR_free);\\r\\nM_ASN1_D2I_get(ret->enc_data,d2i_PKCS7_ENC_CONTENT);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509,ret->cert,d2i_X509,X509_free,0);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509_CRL,ret->crl,d2i_X509_CRL,\\r\\nX509_CRL_free,1);\\r\\nM_ASN1_D2I_get_set_type(PKCS7_SIGNER_INFO,ret->signer_info,\\r\\nd2i_PKCS7_SIGNER_INFO,PKCS7_SIGNER_INFO_free);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_SIGN_ENVELOPE_free,\\r\\nASN1_F_D2I_PKCS7_SIGN_ENVELOPE);\\r\\n}\\r\\nPKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void)\\r\\n{\\r\\nPKCS7_SIGN_ENVELOPE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_SIGN_ENVELOPE);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->recipientinfo,sk_PKCS7_RECIP_INFO_new_null);\\r\\nM_ASN1_New(ret->md_algs,sk_X509_ALGOR_new_null);\\r\\nM_ASN1_New(ret->enc_data,PKCS7_ENC_CONTENT_new);\\r\\nret->cert=NULL;\\r\\nret->crl=NULL;\\r\\nM_ASN1_New(ret->signer_info,sk_PKCS7_SIGNER_INFO_new_null);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_SIGN_ENVELOPE_NEW);\\r\\n}\\r\\nvoid PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nsk_PKCS7_RECIP_INFO_pop_free(a->recipientinfo,PKCS7_RECIP_INFO_free);\\r\\nsk_X509_ALGOR_pop_free(a->md_algs,X509_ALGOR_free);\\r\\nPKCS7_ENC_CONTENT_free(a->enc_data);\\r\\nsk_X509_pop_free(a->cert,X509_free);\\r\\nsk_X509_CRL_pop_free(a->crl,X509_CRL_free);\\r\\nsk_PKCS7_SIGNER_INFO_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);\\r\\nFree(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_nsseq_c", "target": 0, "func": "int i2d_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE *a, unsigned char **pp)\\r\\n{\\r\\nint v = 0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->type, i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_len_EXP_SEQUENCE_opt_type(X509,a->certs,i2d_X509,0,\\r\\nV_ASN1_SEQUENCE,v);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->type, i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_put_EXP_SEQUENCE_opt_type(X509,a->certs,i2d_X509,0,\\r\\nV_ASN1_SEQUENCE,v);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nNETSCAPE_CERT_SEQUENCE *NETSCAPE_CERT_SEQUENCE_new(void)\\r\\n{\\r\\nNETSCAPE_CERT_SEQUENCE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, NETSCAPE_CERT_SEQUENCE);\\r\\nret->type = OBJ_nid2obj(NID_netscape_cert_sequence);\\r\\nret->certs = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_NETSCAPE_CERT_SEQUENCE_NEW);\\r\\n}\\r\\nNETSCAPE_CERT_SEQUENCE *d2i_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,NETSCAPE_CERT_SEQUENCE *,\\r\\nNETSCAPE_CERT_SEQUENCE_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->type, d2i_ASN1_OBJECT);\\r\\nM_ASN1_D2I_get_EXP_set_opt_type(X509,ret->certs,d2i_X509,X509_free,0,\\r\\nV_ASN1_SEQUENCE);\\r\\nM_ASN1_D2I_Finish(a, NETSCAPE_CERT_SEQUENCE_free,\\r\\nASN1_F_D2I_NETSCAPE_CERT_SEQUENCE);\\r\\n}\\r\\nvoid NETSCAPE_CERT_SEQUENCE_free (NETSCAPE_CERT_SEQUENCE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->type);\\r\\nif(a->certs)\\r\\nsk_X509_pop_free(a->certs, X509_free);\\r\\nFree (a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_lib_c", "target": 1, "func": "static long ssl2_default_timeout(void)\\r\\n{\\r\\nreturn(300);\\r\\n}\\r\\nSSL_METHOD *sslv2_base_method(void)\\r\\n{\\r\\nreturn(&SSLv2_data);\\r\\n}\\r\\nint ssl2_num_ciphers(void)\\r\\n{\\r\\nreturn(SSL2_NUM_CIPHERS);\\r\\n}\\r\\nSSL_CIPHER *ssl2_get_cipher(unsigned int u)\\r\\n{\\r\\nif (u < SSL2_NUM_CIPHERS)\\r\\nreturn(&(ssl2_ciphers[SSL2_NUM_CIPHERS-1-u]));\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nint ssl2_pending(SSL *s)\\r\\n{\\r\\nreturn(s->s2->ract_data_length);\\r\\n}\\r\\nint ssl2_new(SSL *s)\\r\\n{\\r\\nSSL2_CTX *s2;\\r\\nif ((s2=(SSL2_CTX *)Malloc(sizeof(SSL2_CTX))) == NULL) goto err;\\r\\nmemset(s2,0,sizeof(SSL2_CTX));\\r\\nif ((s2->rbuf=(unsigned char *)Malloc(\\r\\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2)) == NULL) goto err;\\r\\nif ((s2->wbuf=(unsigned char *)Malloc(\\r\\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2)) == NULL) goto err;\\r\\ns->s2=s2;\\r\\nssl2_clear(s);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (s2 != NULL)\\r\\n{\\r\\nif (s2->wbuf != NULL) Free(s2->wbuf);\\r\\nif (s2->rbuf != NULL) Free(s2->rbuf);\\r\\nFree(s2);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl2_free(SSL *s)\\r\\n{\\r\\nSSL2_CTX *s2;\\r\\nif(s == NULL)\\r\\nreturn;\\r\\ns2=s->s2;\\r\\nif (s2->rbuf != NULL) Free(s2->rbuf);\\r\\nif (s2->wbuf != NULL) Free(s2->wbuf);\\r\\nmemset(s2,0,sizeof(SSL2_CTX));\\r\\nFree(s2);\\r\\ns->s2=NULL;\\r\\n}\\r\\nvoid ssl2_clear(SSL *s)\\r\\n{\\r\\nSSL2_CTX *s2;\\r\\nunsigned char *rbuf,*wbuf;\\r\\ns2=s->s2;\\r\\nrbuf=s2->rbuf;\\r\\nwbuf=s2->wbuf;\\r\\nmemset(s2,0,sizeof(SSL2_CTX));\\r\\ns2->rbuf=rbuf;\\r\\ns2->wbuf=wbuf;\\r\\ns2->clear_text=1;\\r\\ns->packet=s2->rbuf;\\r\\ns->version=SSL2_VERSION;\\r\\ns->packet_length=0;\\r\\n}\\r\\nlong ssl2_ctrl(SSL *s, int cmd, long larg, char *parg)\\r\\n{\\r\\nint ret=0;\\r\\nswitch(cmd)\\r\\n{\\r\\ncase SSL_CTRL_GET_SESSION_REUSED:\\r\\nret=s->hit;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nlong ssl2_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, char *parg)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nSSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_CIPHER *sorted[SSL2_NUM_CIPHERS];\\r\\nSSL_CIPHER c,*cp= &c,**cpp;\\r\\nunsigned long id;\\r\\nint i;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nfor (i=0; i<SSL2_NUM_CIPHERS; i++)\\r\\nsorted[i]= &(ssl2_ciphers[i]);\\r\\nqsort( (char *)sorted,\\r\\nSSL2_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\nFP_ICC ssl_cipher_ptr_id_cmp);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\ninit=0;\\r\\n}\\r\\nid=0x02000000L|((unsigned long)p[0]<<16L)|\\r\\n((unsigned long)p[1]<<8L)|(unsigned long)p[2];\\r\\nc.id=id;\\r\\ncpp=(SSL_CIPHER **)OBJ_bsearch((char *)&cp,\\r\\n(char *)sorted,\\r\\nSSL2_NUM_CIPHERS,sizeof(SSL_CIPHER *),\\r\\n(int (*)())ssl_cipher_ptr_id_cmp);\\r\\nif ((cpp == NULL) || !(*cpp)->valid)\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(*cpp);\\r\\n}\\r\\nint ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\nif ((l & 0xff000000) != 0x02000000) return(0);\\r\\np[0]=((unsigned char)(l>>16L))&0xFF;\\r\\np[1]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[2]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(3);\\r\\n}\\r\\nvoid ssl2_generate_key_material(SSL *s)\\r\\n{\\r\\nunsigned int i;\\r\\nMD5_CTX ctx;\\r\\nunsigned char *km;\\r\\nunsigned char c='0';\\r\\n#ifdef CHARSET_EBCDIC\\r\\nc = os_toascii['0'];\\r\\n#endif\\r\\nkm=s->s2->key_material;\\r\\nfor (i=0; i<s->s2->key_material_length; i+=MD5_DIGEST_LENGTH)\\r\\n{\\r\\nMD5_Init(&ctx);\\r\\nMD5_Update(&ctx,s->session->master_key,s->session->master_key_length);\\r\\nMD5_Update(&ctx,(unsigned char *)&c,1);\\r\\nc++;\\r\\nMD5_Update(&ctx,s->s2->challenge,s->s2->challenge_length);\\r\\nMD5_Update(&ctx,s->s2->conn_id,s->s2->conn_id_length);\\r\\nMD5_Final(km,&ctx);\\r\\nkm+=MD5_DIGEST_LENGTH;\\r\\n}\\r\\n}\\r\\nvoid ssl2_return_error(SSL *s, int err)\\r\\n{\\r\\nif (!s->error)\\r\\n{\\r\\ns->error=3;\\r\\ns->error_code=err;\\r\\nssl2_write_error(s);\\r\\n}\\r\\n}\\r\\nvoid ssl2_write_error(SSL *s)\\r\\n{\\r\\nunsigned char buf[3];\\r\\nint i,error;\\r\\nbuf[0]=SSL2_MT_ERROR;\\r\\nbuf[1]=(s->error_code>>8)&0xff;\\r\\nbuf[2]=(s->error_code)&0xff;\\r\\nerror=s->error;\\r\\ns->error=0;\\r\\ni=ssl2_write(s,&(buf[3-error]),error);\\r\\nif (i < 0)\\r\\ns->error=error;\\r\\nelse if (i != s->error)\\r\\ns->error=error-i;\\r\\n}\\r\\nint ssl2_shutdown(SSL *s)\\r\\n{\\r\\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_r5_c", "target": 0, "func": "EVP_CIPHER *EVP_rc5_32_12_16_ecb(void)\\r\\n{\\r\\nreturn(&rc5_ecb_cipher);\\r\\n}\\r\\nstatic void rc5_32_12_16_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\nRC5_32_set_key(&(ctx->c.rc5_ks),EVP_RC5_32_12_16_KEY_SIZE,key,\\r\\nRC5_12_ROUNDS);\\r\\n}\\r\\nstatic void rc5_32_12_16_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\nRC5_32_ecb_encrypt(\\r\\n&(in[i]),&(out[i]),\\r\\n&(ctx->c.rc5_ks),ctx->encrypt);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sign_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nX509 *x509;\\r\\nEVP_PKEY *pkey;\\r\\nPKCS7 *p7;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nBIO *in;\\r\\nBIO *data,*p7bio;\\r\\nchar buf[1024*4];\\r\\nint i;\\r\\nint nodetach=0;\\r\\nEVP_add_digest(EVP_md2());\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest(EVP_mdc2());\\r\\ndata=BIO_new(BIO_s_file());\\r\\nagain:\\r\\nif (argc > 1)\\r\\n{\\r\\nif (strcmp(argv[1],\"-nd\") == 0)\\r\\n{\\r\\nnodetach=1;\\r\\nargv++; argc--;\\r\\ngoto again;\\r\\n}\\r\\nif (!BIO_read_filename(data,argv[1]))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nBIO_set_fp(data,stdin,BIO_NOCLOSE);\\r\\nif ((in=BIO_new_file(\"server.pem\",\"r\")) == NULL) goto err;\\r\\nif ((x509=PEM_read_bio_X509(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_reset(in);\\r\\nif ((pkey=PEM_read_bio_PrivateKey(in,NULL,NULL)) == NULL) goto err;\\r\\nBIO_free(in);\\r\\np7=PKCS7_new();\\r\\nPKCS7_set_type(p7,NID_pkcs7_signed);\\r\\nsi=PKCS7_add_signature(p7,x509,pkey,EVP_sha1());\\r\\nif (si == NULL) goto err;\\r\\nPKCS7_add_signed_attribute(si, NID_pkcs9_contentType, V_ASN1_OBJECT,\\r\\nOBJ_nid2obj(NID_pkcs7_data));\\r\\nPKCS7_add_certificate(p7,x509);\\r\\nPKCS7_content_new(p7,NID_pkcs7_data);\\r\\nif (!nodetach)\\r\\nPKCS7_set_detached(p7,1);\\r\\nif ((p7bio=PKCS7_dataInit(p7,NULL)) == NULL) goto err;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(data,buf,sizeof(buf));\\r\\nif (i <= 0) break;\\r\\nBIO_write(p7bio,buf,i);\\r\\n}\\r\\nif (!PKCS7_dataFinal(p7,p7bio)) goto err;\\r\\nBIO_free(p7bio);\\r\\nPEM_write_PKCS7(stdout,p7);\\r\\nPKCS7_free(p7);\\r\\nexit(0);\\r\\nerr:\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1;\\r\\nRSA *rsa=NULL;\\r\\nint i,badops=0;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,text=0,check=0,noout=0;\\r\\nchar *infile,*outfile,*prog;\\r\\nint modulus=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if (strcmp(*argv,\"-check\") == 0)\\r\\ncheck=1;\\r\\nelse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err,\" -modulus print the RSA key modulus\\n\");\\r\\nBIO_printf(bio_err,\" -check verify key consistency\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"read RSA private key\\n\");\\r\\nif (informat == FORMAT_ASN1)\\r\\nrsa=d2i_RSAPrivateKey_bio(in,NULL);\\r\\n#ifndef NO_RC4\\r\\nelse if (informat == FORMAT_NETSCAPE)\\r\\n{\\r\\nBUF_MEM *buf=NULL;\\r\\nunsigned char *p;\\r\\nint size=0;\\r\\nbuf=BUF_MEM_new();\\r\\nfor (;;)\\r\\n{\\r\\nif ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))\\r\\ngoto end;\\r\\ni=BIO_read(in,&(buf->data[size]),1024*10);\\r\\nsize+=i;\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nperror(\"reading private key\");\\r\\nBUF_MEM_free(buf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np=(unsigned char *)buf->data;\\r\\nrsa=(RSA *)d2i_Netscape_RSA(NULL,&p,(long)size,NULL);\\r\\nBUF_MEM_free(buf);\\r\\n}\\r\\n#endif\\r\\nelse if (informat == FORMAT_PEM)\\r\\nrsa=PEM_read_bio_RSAPrivateKey(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Private Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!RSA_print(out,rsa,0))\\r\\n{\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nfprintf(stdout,\"Modulus=\");\\r\\nBN_print(out,rsa->n);\\r\\nfprintf(stdout,\"\\n\");\\r\\n}\\r\\nif (check)\\r\\n{\\r\\nint r = RSA_check_key(rsa);\\r\\nif (r == 1)\\r\\nBIO_printf(out,\"RSA key ok\\n\");\\r\\nelse if (r == 0)\\r\\n{\\r\\nlong e;\\r\\nwhile ((e = ERR_peek_error()) != 0 &&\\r\\nERR_GET_LIB(e) == ERR_LIB_RSA &&\\r\\nERR_GET_FUNC(e) == RSA_F_RSA_CHECK_KEY &&\\r\\nERR_GET_REASON(e) != ERR_R_MALLOC_FAILURE)\\r\\n{\\r\\nBIO_printf(out, \"RSA key error: %s\\n\", ERR_reason_error_string(e));\\r\\nERR_get_error();\\r\\n}\\r\\n}\\r\\nif (r == -1 || ERR_peek_error() != 0)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (noout) goto end;\\r\\nBIO_printf(bio_err,\"writing RSA private key\\n\");\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_RSAPrivateKey_bio(out,rsa);\\r\\n#ifndef NO_RC4\\r\\nelse if (outformat == FORMAT_NETSCAPE)\\r\\n{\\r\\nunsigned char *p,*pp;\\r\\nint size;\\r\\ni=1;\\r\\nsize=i2d_Netscape_RSA(rsa,NULL,NULL);\\r\\nif ((p=(unsigned char *)Malloc(size)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\npp=p;\\r\\ni2d_Netscape_RSA(rsa,&p,NULL);\\r\\nBIO_write(out,(char *)pp,size);\\r\\nFree(pp);\\r\\n}\\r\\n#endif\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,0,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (rsa != NULL) RSA_free(rsa);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_r_pu_c", "target": 0, "func": "int i2d_RSAPublicKey(RSA *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[2];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot=0,len,max=0,t;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nnum[0]=a->n;\\r\\nnum[1]=a->e;\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(t);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nbs.type=V_ASN1_INTEGER;\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSAPUBLICKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (i=0; i<2; i++)\\r\\n{\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\n*pp=p;\\r\\nreturn(t);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_lib_c", "target": 0, "func": "int EVP_PKEY_bits(EVP_PKEY *pkey)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nreturn(BN_num_bits(pkey->pkey.rsa->n));\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nreturn(BN_num_bits(pkey->pkey.dsa->p));\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_size(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey == NULL)\\r\\nreturn(0);\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nreturn(RSA_size(pkey->pkey.rsa));\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nreturn(DSA_size(pkey->pkey.dsa));\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nint ret=pkey->save_parameters=mode;\\r\\nif (mode >= 0)\\r\\npkey->save_parameters=mode;\\r\\nreturn(ret);\\r\\n}\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, EVP_PKEY *from)\\r\\n{\\r\\nif (to->type != from->type)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_DIFFERENT_KEY_TYPES);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_missing_parameters(from))\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARMATERS);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef NO_DSA\\r\\nif (to->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIGNUM *a;\\r\\nif ((a=BN_dup(from->pkey.dsa->p)) == NULL) goto err;\\r\\nif (to->pkey.dsa->p != NULL) BN_free(to->pkey.dsa->p);\\r\\nto->pkey.dsa->p=a;\\r\\nif ((a=BN_dup(from->pkey.dsa->q)) == NULL) goto err;\\r\\nif (to->pkey.dsa->q != NULL) BN_free(to->pkey.dsa->q);\\r\\nto->pkey.dsa->q=a;\\r\\nif ((a=BN_dup(from->pkey.dsa->g)) == NULL) goto err;\\r\\nif (to->pkey.dsa->g != NULL) BN_free(to->pkey.dsa->g);\\r\\nto->pkey.dsa->g=a;\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_missing_parameters(EVP_PKEY *pkey)\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nDSA *dsa;\\r\\ndsa=pkey->pkey.dsa;\\r\\nif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\nreturn(0);\\r\\n}\\r\\nint EVP_PKEY_cmp_parameters(EVP_PKEY *a, EVP_PKEY *b)\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nif ((a->type == EVP_PKEY_DSA) && (b->type == EVP_PKEY_DSA))\\r\\n{\\r\\nif ( BN_cmp(a->pkey.dsa->p,b->pkey.dsa->p) ||\\r\\nBN_cmp(a->pkey.dsa->q,b->pkey.dsa->q) ||\\r\\nBN_cmp(a->pkey.dsa->g,b->pkey.dsa->g))\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_new(void)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nret=(EVP_PKEY *)Malloc(sizeof(EVP_PKEY));\\r\\nif (ret == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->type=EVP_PKEY_NONE;\\r\\nret->references=1;\\r\\nret->pkey.ptr=NULL;\\r\\nret->attributes=NULL;\\r\\nret->save_parameters=1;\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)\\r\\n{\\r\\nif (pkey == NULL) return(0);\\r\\nif (pkey->pkey.ptr != NULL)\\r\\nEVP_PKEY_free_it(pkey);\\r\\npkey->type=EVP_PKEY_type(type);\\r\\npkey->save_type=type;\\r\\npkey->pkey.ptr=key;\\r\\nreturn(1);\\r\\n}\\r\\nint EVP_PKEY_type(int type)\\r\\n{\\r\\nswitch (type)\\r\\n{\\r\\ncase EVP_PKEY_RSA:\\r\\ncase EVP_PKEY_RSA2:\\r\\nreturn(EVP_PKEY_RSA);\\r\\ncase EVP_PKEY_DSA:\\r\\ncase EVP_PKEY_DSA1:\\r\\ncase EVP_PKEY_DSA2:\\r\\ncase EVP_PKEY_DSA3:\\r\\ncase EVP_PKEY_DSA4:\\r\\nreturn(EVP_PKEY_DSA);\\r\\ncase EVP_PKEY_DH:\\r\\nreturn(EVP_PKEY_DH);\\r\\ndefault:\\r\\nreturn(NID_undef);\\r\\n}\\r\\n}\\r\\nvoid EVP_PKEY_free(EVP_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"EVP_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nEVP_PKEY_free_it(x);\\r\\nFree((char *)x);\\r\\n}\\r\\nstatic void EVP_PKEY_free_it(EVP_PKEY *x)\\r\\n{\\r\\nswitch (x->type)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\ncase EVP_PKEY_RSA2:\\r\\nRSA_free(x->pkey.rsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\ncase EVP_PKEY_DSA2:\\r\\ncase EVP_PKEY_DSA3:\\r\\ncase EVP_PKEY_DSA4:\\r\\nDSA_free(x->pkey.dsa);\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\ncase EVP_PKEY_DH:\\r\\nDH_free(x->pkey.dh);\\r\\nbreak;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s_server_c", "target": 1, "func": "static DH *get_dh512(void)\\r\\n{\\r\\nDH *dh=NULL;\\r\\nif ((dh=DH_new()) == NULL) return(NULL);\\r\\ndh->p=BN_bin2bn(dh512_p,sizeof(dh512_p),NULL);\\r\\ndh->g=BN_bin2bn(dh512_g,sizeof(dh512_g),NULL);\\r\\nif ((dh->p == NULL) || (dh->g == NULL))\\r\\nreturn(NULL);\\r\\nreturn(dh);\\r\\n}\\r\\nstatic void sv_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"usage: s_server [args ...]\\n\");\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nBIO_printf(bio_err,\" -accept arg - port to accept on (default is %d)\\n\",PORT);\\r\\nBIO_printf(bio_err,\" -context arg - set session ID context\\n\");\\r\\nBIO_printf(bio_err,\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\" -Verify arg - turn on peer certificate verification, must have a cert.\\n\");\\r\\nBIO_printf(bio_err,\" -cert arg - certificate file to use, PEM format assumed\\n\");\\r\\nBIO_printf(bio_err,\" (default is %s)\\n\",TEST_CERT);\\r\\nBIO_printf(bio_err,\" -key arg - RSA file to use, PEM format assumed, in cert file if\\n\");\\r\\nBIO_printf(bio_err,\" not specified (default is %s)\\n\",TEST_CERT);\\r\\nBIO_printf(bio_err,\" -dcert arg - second certificate file to use (usually for DSA)\\n\");\\r\\nBIO_printf(bio_err,\" -dkey arg - second private key file to use (usually for DSA)\\n\");\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err,\" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -nbio_test - test with the non-blocking test bio\\n\");\\r\\n#ifdef APPS_CRLF\\r\\nBIO_printf(bio_err,\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -debug - Print more output\\n\");\\r\\nBIO_printf(bio_err,\" -state - Print the SSL states\\n\");\\r\\nBIO_printf(bio_err,\" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\" -nocert - Don't use any certificates (Anon-DH)\\n\");\\r\\nBIO_printf(bio_err,\" -cipher arg - play with 'openssl ciphers' to see what goes here\\n\");\\r\\nBIO_printf(bio_err,\" -quiet - No server output\\n\");\\r\\nBIO_printf(bio_err,\" -no_tmp_rsa - Do not generate a tmp RSA key\\n\");\\r\\nBIO_printf(bio_err,\" -ssl2 - Just talk SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -ssl3 - Just talk SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -tls1 - Just talk TLSv1\\n\");\\r\\nBIO_printf(bio_err,\" -no_ssl2 - Just disable SSLv2\\n\");\\r\\nBIO_printf(bio_err,\" -no_ssl3 - Just disable SSLv3\\n\");\\r\\nBIO_printf(bio_err,\" -no_tls1 - Just disable TLSv1\\n\");\\r\\n#ifndef NO_DH\\r\\nBIO_printf(bio_err,\" -no_dhe - Disable ephemeral DH\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -bugs - Turn on SSL bug compatability\\n\");\\r\\nBIO_printf(bio_err,\" -www - Respond to a 'GET /' with a status page\\n\");\\r\\nBIO_printf(bio_err,\" -WWW - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\\n\");\\r\\n}\\r\\nBIO_METHOD *BIO_f_ebcdic_filter()\\r\\n{\\r\\nreturn(&methods_ebcdic);\\r\\n}\\r\\nstatic int ebcdic_new(BIO *bi)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nwbuf = (EBCDIC_OUTBUFF *)Malloc(sizeof(EBCDIC_OUTBUFF) + 1024);\\r\\nwbuf->alloced = 1024;\\r\\nwbuf->buff[0] = '\\0';\\r\\nbi->ptr=(char *)wbuf;\\r\\nbi->init=1;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ebcdic_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->ptr != NULL)\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int ebcdic_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out == NULL || outl == 0) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (ret > 0)\\r\\nascii2ebcdic(out,out,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ebcdic_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nint ret=0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nwbuf=(EBCDIC_OUTBUFF *)b->ptr;\\r\\nif (inl > (num = wbuf->alloced))\\r\\n{\\r\\nnum = num + num;\\r\\nif (num < inl)\\r\\nnum = inl;\\r\\nFree((char*)wbuf);\\r\\nwbuf=(EBCDIC_OUTBUFF *)Malloc(sizeof(EBCDIC_OUTBUFF) + num);\\r\\nwbuf->alloced = num;\\r\\nwbuf->buff[0] = '\\0';\\r\\nb->ptr=(char *)wbuf;\\r\\n}\\r\\nebcdic2ascii(wbuf->buff, in, inl);\\r\\nret=BIO_write(b->next_bio, wbuf->buff, inl);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long ebcdic_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ebcdic_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i, ret;\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nfor (i=0; i<size-1; ++i)\\r\\n{\\r\\nret = ebcdic_read(bp,&buf[i],1);\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nelse if (buf[i] == '\\n')\\r\\n{\\r\\n++i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i < size)\\r\\nbuf[i] = '\\0';\\r\\nreturn (ret < 0 && i == 0) ? ret : i;\\r\\n}\\r\\nstatic int ebcdic_puts(BIO *bp, char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn ebcdic_write(bp, str, strlen(str));\\r\\n}\\r\\nint MAIN(int argc, char *argv[])\\r\\n{\\r\\nshort port=PORT;\\r\\nchar *CApath=NULL,*CAfile=NULL;\\r\\nchar *context = NULL;\\r\\nint badop=0,bugs=0;\\r\\nint ret=1;\\r\\nint off=0;\\r\\nint no_tmp_rsa=0,no_dhe=0,nocert=0;\\r\\nint state=0;\\r\\nSSL_METHOD *meth=NULL;\\r\\n#ifndef NO_DH\\r\\nDH *dh=NULL;\\r\\n#endif\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\nmeth=SSLv23_server_method();\\r\\n#elif !defined(NO_SSL3)\\r\\nmeth=SSLv3_server_method();\\r\\n#elif !defined(NO_SSL2)\\r\\nmeth=SSLv2_server_method();\\r\\n#endif\\r\\nlocal_argc=argc;\\r\\nlocal_argv=argv;\\r\\napps_startup();\\r\\ns_quiet=0;\\r\\ns_debug=0;\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nverify_depth=0;\\r\\n#ifdef FIONBIO\\r\\ns_nbio=0;\\r\\n#endif\\r\\ns_nbio_test=0;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif ((strcmp(*argv,\"-port\") == 0) ||\\r\\n(strcmp(*argv,\"-accept\") == 0))\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nif (!extract_port(*(++argv),&port))\\r\\ngoto bad;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-verify\") == 0)\\r\\n{\\r\\ns_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-Verify\") == 0)\\r\\n{\\r\\ns_server_verify=SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|\\r\\nSSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1) goto bad;\\r\\nverify_depth=atoi(*(++argv));\\r\\nBIO_printf(bio_err,\"verify depth is %d, must return a certificate\\n\",verify_depth);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-context\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncontext= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_cert_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_key_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dcert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dcert_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-dkey\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ns_dkey_file= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-nocert\") == 0)\\r\\n{\\r\\nnocert=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CApath\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCApath= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cipher\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncipher= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-CAfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nCAfile= *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv,\"-nbio\") == 0)\\r\\n{ s_nbio=1; }\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-nbio_test\") == 0)\\r\\n{\\r\\n#ifdef FIONBIO\\r\\ns_nbio=1;\\r\\n#endif\\r\\ns_nbio_test=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-debug\") == 0)\\r\\n{ s_debug=1; }\\r\\nelse if (strcmp(*argv,\"-hack\") == 0)\\r\\n{ hack=1; }\\r\\nelse if (strcmp(*argv,\"-state\") == 0)\\r\\n{ state=1; }\\r\\n#ifdef APPS_CRLF\\r\\nelse if (strcmp(*argv,\"-crlf\") == 0)\\r\\n{ s_crlf=1; }\\r\\n#endif\\r\\nelse if (strcmp(*argv,\"-quiet\") == 0)\\r\\n{ s_quiet=1; }\\r\\nelse if (strcmp(*argv,\"-bugs\") == 0)\\r\\n{ bugs=1; }\\r\\nelse if (strcmp(*argv,\"-no_tmp_rsa\") == 0)\\r\\n{ no_tmp_rsa=1; }\\r\\nelse if (strcmp(*argv,\"-no_dhe\") == 0)\\r\\n{ no_dhe=1; }\\r\\nelse if (strcmp(*argv,\"-www\") == 0)\\r\\n{ www=1; }\\r\\nelse if (strcmp(*argv,\"-WWW\") == 0)\\r\\n{ www=2; }\\r\\nelse if (strcmp(*argv,\"-no_ssl2\") == 0)\\r\\n{ off|=SSL_OP_NO_SSLv2; }\\r\\nelse if (strcmp(*argv,\"-no_ssl3\") == 0)\\r\\n{ off|=SSL_OP_NO_SSLv3; }\\r\\nelse if (strcmp(*argv,\"-no_tls1\") == 0)\\r\\n{ off|=SSL_OP_NO_TLSv1; }\\r\\n#ifndef NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\n{ meth=SSLv2_server_method(); }\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\n{ meth=SSLv3_server_method(); }\\r\\n#endif\\r\\n#ifndef NO_TLS1\\r\\nelse if (strcmp(*argv,\"-tls1\") == 0)\\r\\n{ meth=TLSv1_server_method(); }\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadop=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop)\\r\\n{\\r\\nbad:\\r\\nsv_usage();\\r\\ngoto end;\\r\\n}\\r\\nif (bio_s_out == NULL)\\r\\n{\\r\\nif (s_quiet && !s_debug)\\r\\n{\\r\\nbio_s_out=BIO_new(BIO_s_null());\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bio_s_out == NULL)\\r\\nbio_s_out=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\n#if !defined(NO_RSA) || !defined(NO_DSA)\\r\\nif (nocert)\\r\\n#endif\\r\\n{\\r\\ns_cert_file=NULL;\\r\\ns_key_file=NULL;\\r\\ns_dcert_file=NULL;\\r\\ns_dkey_file=NULL;\\r\\n}\\r\\nSSL_load_error_strings();\\r\\nSSLeay_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nSSL_CTX_set_quiet_shutdown(ctx,1);\\r\\nif (bugs) SSL_CTX_set_options(ctx,SSL_OP_ALL);\\r\\nif (hack) SSL_CTX_set_options(ctx,SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);\\r\\nSSL_CTX_set_options(ctx,off);\\r\\nif (hack) SSL_CTX_set_options(ctx,SSL_OP_NON_EXPORT_FIRST);\\r\\nif (state) SSL_CTX_set_info_callback(ctx,apps_ssl_info_callback);\\r\\nSSL_CTX_sess_set_cache_size(ctx,128);\\r\\n#if 0\\r\\nif (cipher == NULL) cipher=getenv(\"SSL_CIPHER\");\\r\\n#endif\\r\\n#if 0\\r\\nif (s_cert_file == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"You must specify a certificate file for the server to use\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nif ((!SSL_CTX_load_verify_locations(ctx,CAfile,CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx)))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#ifndef NO_DH\\r\\nif (!no_dhe)\\r\\n{\\r\\ndh=load_dh_param();\\r\\nif (dh != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Setting temp DH parameters\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Using default temp DH parameters\\n\");\\r\\ndh=get_dh512();\\r\\n}\\r\\n(void)BIO_flush(bio_s_out);\\r\\nSSL_CTX_set_tmp_dh(ctx,dh);\\r\\nDH_free(dh);\\r\\n}\\r\\n#endif\\r\\nif (!set_cert_stuff(ctx,s_cert_file,s_key_file))\\r\\ngoto end;\\r\\nif (s_dcert_file != NULL)\\r\\n{\\r\\nif (!set_cert_stuff(ctx,s_dcert_file,s_dkey_file))\\r\\ngoto end;\\r\\n}\\r\\n#ifndef NO_RSA\\r\\n#if 1\\r\\nSSL_CTX_set_tmp_rsa_callback(ctx,tmp_rsa_cb);\\r\\n#else\\r\\nif (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx))\\r\\n{\\r\\nRSA *rsa;\\r\\nBIO_printf(bio_s_out,\"Generating temp (512 bit) RSA key...\");\\r\\nBIO_flush(bio_s_out);\\r\\nrsa=RSA_generate_key(512,RSA_F4,NULL);\\r\\nif (!SSL_CTX_set_tmp_rsa(ctx,rsa))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nRSA_free(rsa);\\r\\nBIO_printf(bio_s_out,\"\\n\");\\r\\n}\\r\\n#endif\\r\\n#endif\\r\\nif (cipher != NULL)\\r\\nSSL_CTX_set_cipher_list(ctx,cipher);\\r\\nSSL_CTX_set_verify(ctx,s_server_verify,verify_callback);\\r\\nSSL_CTX_set_session_id_context(ctx,(void*)&s_server_session_id_context,\\r\\nsizeof s_server_session_id_context);\\r\\nSSL_CTX_set_client_CA_list(ctx,SSL_load_client_CA_file(CAfile));\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nif (www)\\r\\ndo_server(port,&accept_socket,www_body, context);\\r\\nelse\\r\\ndo_server(port,&accept_socket,sv_body, context);\\r\\nprint_stats(bio_s_out,ctx);\\r\\nret=0;\\r\\nend:\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (bio_s_out != NULL)\\r\\n{\\r\\nBIO_free(bio_s_out);\\r\\nbio_s_out=NULL;\\r\\n}\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void print_stats(BIO *bio, SSL_CTX *ssl_ctx)\\r\\n{\\r\\nBIO_printf(bio,\"%4ld items in the session cache\\n\",\\r\\nSSL_CTX_sess_number(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d client connects (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d client renegotiates (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d client connects that finished\\n\",\\r\\nSSL_CTX_sess_connect_good(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d server accepts (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d server renegotiates (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d server accepts that finished\\n\",\\r\\nSSL_CTX_sess_accept_good(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d session cache hits\\n\",SSL_CTX_sess_hits(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d session cache misses\\n\",SSL_CTX_sess_misses(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d session cache timeouts\\n\",SSL_CTX_sess_timeouts(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d callback cache hits\\n\",SSL_CTX_sess_cb_hits(ssl_ctx));\\r\\nBIO_printf(bio,\"%4d cache full overflows (%d allowed)\\n\",\\r\\nSSL_CTX_sess_cache_full(ssl_ctx),\\r\\nSSL_CTX_sess_get_cache_size(ssl_ctx));\\r\\n}\\r\\nstatic int sv_body(char *hostname, int s, unsigned char *context)\\r\\n{\\r\\nchar *buf=NULL;\\r\\nfd_set readfds;\\r\\nint ret=1,width;\\r\\nint k,i;\\r\\nunsigned long l;\\r\\nSSL *con=NULL;\\r\\nBIO *sbio;\\r\\nif ((buf=Malloc(bufsize)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio)\\r\\n{\\r\\nunsigned long sl=1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (con == NULL) {\\r\\ncon=(SSL *)SSL_new(ctx);\\r\\nif(context)\\r\\nSSL_set_session_id_context(con, context,\\r\\nstrlen((char *)context));\\r\\n}\\r\\nSSL_clear(con);\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (s_nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_accept_state(con);\\r\\nif (s_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(SSL_get_rbio(con),bio_dump_cb);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);\\r\\n}\\r\\nwidth=s+1;\\r\\nfor (;;)\\r\\n{\\r\\nFD_ZERO(&readfds);\\r\\n#ifndef WINDOWS\\r\\nFD_SET(fileno(stdin),&readfds);\\r\\n#endif\\r\\nFD_SET(s,&readfds);\\r\\ni=select(width,(void *)&readfds,NULL,NULL,NULL);\\r\\nif (i <= 0) continue;\\r\\nif (FD_ISSET(fileno(stdin),&readfds))\\r\\n{\\r\\n#ifdef APPS_CRLF\\r\\nif (s_crlf)\\r\\n{\\r\\nint j, lf_num;\\r\\ni=read(fileno(stdin), buf, bufsize/2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (buf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i-1; j >= 0; j--)\\r\\n{\\r\\nbuf[j+lf_num] = buf[j];\\r\\nif (buf[j] == '\\n')\\r\\n{\\r\\nlf_num--;\\r\\ni++;\\r\\nbuf[j+lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ni=read(fileno(stdin),buf,bufsize);\\r\\nif (!s_quiet)\\r\\n{\\r\\nif ((i <= 0) || (buf[0] == 'Q'))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nSHUTDOWN(s);\\r\\nclose_accept_socket();\\r\\nret= -11;\\r\\ngoto err;\\r\\n}\\r\\nif ((i <= 0) || (buf[0] == 'q'))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nSHUTDOWN(s);\\r\\ngoto err;\\r\\n}\\r\\nif ((buf[0] == 'r') &&\\r\\n((buf[1] == '\\n') || (buf[1] == '\\r')))\\r\\n{\\r\\nSSL_renegotiate(con);\\r\\ni=SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\",i);\\r\\ni=0;\\r\\ncontinue;\\r\\n}\\r\\nif ((buf[0] == 'R') &&\\r\\n((buf[1] == '\\n') || (buf[1] == '\\r')))\\r\\n{\\r\\nSSL_set_verify(con,\\r\\nSSL_VERIFY_PEER|SSL_VERIFY_CLIENT_ONCE,NULL);\\r\\nSSL_renegotiate(con);\\r\\ni=SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\",i);\\r\\ni=0;\\r\\ncontinue;\\r\\n}\\r\\nif (buf[0] == 'P')\\r\\n{\\r\\nstatic char *str=\"Lets print some clear text\\n\";\\r\\nBIO_write(SSL_get_wbio(con),str,strlen(str));\\r\\n}\\r\\nif (buf[0] == 'S')\\r\\n{\\r\\nprint_stats(bio_s_out,SSL_get_SSL_CTX(con));\\r\\n}\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf,buf,i);\\r\\n#endif\\r\\nl=k=0;\\r\\nfor (;;)\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static count=0; if (++count == 100) { count=0; SSL_renegotiate(con); } }\\r\\n#endif\\r\\nk=SSL_write(con,&(buf[l]),(unsigned int)i);\\r\\nswitch (SSL_get_error(con,k))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_s_out,\"Write BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out,\"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret=1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\nl+=k;\\r\\ni-=k;\\r\\nif (i <= 0) break;\\r\\n}\\r\\n}\\r\\nif (FD_ISSET(s,&readfds))\\r\\n{\\r\\nif (!SSL_is_init_finished(con))\\r\\n{\\r\\ni=init_ssl_connection(con);\\r\\nif (i < 0)\\r\\n{\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nagain:\\r\\ni=SSL_read(con,(char *)buf,bufsize);\\r\\nswitch (SSL_get_error(con,i))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(buf,buf,i);\\r\\n#endif\\r\\nwrite(fileno(stdout),buf,\\r\\n(unsigned int)i);\\r\\nif (SSL_pending(con)) goto again;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_s_out,\"Read BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out,\"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret=1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out,\"DONE\\n\");\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nBIO_printf(bio_s_out,\"shutting down SSL\\n\");\\r\\n#if 1\\r\\nSSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(con);\\r\\n#endif\\r\\nif (con != NULL) SSL_free(con);\\r\\nBIO_printf(bio_s_out,\"CONNECTION CLOSED\\n\");\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,bufsize);\\r\\nFree(buf);\\r\\n}\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void close_accept_socket(void)\\r\\n{\\r\\nBIO_printf(bio_err,\"shutdown accept socket\\n\");\\r\\nif (accept_socket >= 0)\\r\\n{\\r\\nSHUTDOWN2(accept_socket);\\r\\n}\\r\\n}\\r\\nstatic int init_ssl_connection(SSL *con)\\r\\n{\\r\\nint i;\\r\\nconst char *str;\\r\\nX509 *peer;\\r\\nlong verify_error;\\r\\nMS_STATIC char buf[BUFSIZ];\\r\\nif ((i=SSL_accept(con)) <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(i))\\r\\n{\\r\\nBIO_printf(bio_s_out,\"DELAY\\n\");\\r\\nreturn(1);\\r\\n}\\r\\nBIO_printf(bio_err,\"ERROR\\n\");\\r\\nverify_error=SSL_get_verify_result(con);\\r\\nif (verify_error != X509_V_OK)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\n}\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nPEM_write_bio_SSL_SESSION(bio_s_out,SSL_get_session(con));\\r\\npeer=SSL_get_peer_certificate(con);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(bio_s_out,\"Client certificate\\n\");\\r\\nPEM_write_bio_X509(bio_s_out,peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer),buf,BUFSIZ);\\r\\nBIO_printf(bio_s_out,\"subject=%s\\n\",buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer),buf,BUFSIZ);\\r\\nBIO_printf(bio_s_out,\"issuer=%s\\n\",buf);\\r\\nX509_free(peer);\\r\\n}\\r\\nif (SSL_get_shared_ciphers(con,buf,BUFSIZ) != NULL)\\r\\nBIO_printf(bio_s_out,\"Shared ciphers:%s\\n\",buf);\\r\\nstr=SSL_CIPHER_get_name(SSL_get_current_cipher(con));\\r\\nBIO_printf(bio_s_out,\"CIPHER is %s\\n\",(str != NULL)?str:\"(NONE)\");\\r\\nif (con->hit) BIO_printf(bio_s_out,\"Reused session-id\\n\");\\r\\nif (SSL_ctrl(con,SSL_CTRL_GET_FLAGS,0,NULL) &\\r\\nTLS1_FLAGS_TLS_PADDING_BUG)\\r\\nBIO_printf(bio_s_out,\"Peer has incorrect TLSv1 block padding\\n\");\\r\\nreturn(1);\\r\\n}\\r\\nstatic DH *load_dh_param(void)\\r\\n{\\r\\nDH *ret=NULL;\\r\\nBIO *bio;\\r\\nif ((bio=BIO_new_file(DH_PARAM,\"r\")) == NULL)\\r\\ngoto err;\\r\\nret=PEM_read_bio_DHparams(bio,NULL,NULL,NULL);\\r\\nerr:\\r\\nif (bio != NULL) BIO_free(bio);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int www_body(char *hostname, int s, unsigned char *context)\\r\\n{\\r\\nchar *buf=NULL;\\r\\nint ret=1;\\r\\nint i,j,k,blank,dot;\\r\\nstruct stat st_buf;\\r\\nSSL *con;\\r\\nSSL_CIPHER *c;\\r\\nBIO *io,*ssl_bio,*sbio;\\r\\nlong total_bytes;\\r\\nbuf=Malloc(bufsize);\\r\\nif (buf == NULL) return(0);\\r\\nio=BIO_new(BIO_f_buffer());\\r\\nssl_bio=BIO_new(BIO_f_ssl());\\r\\nif ((io == NULL) || (ssl_bio == NULL)) goto err;\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio)\\r\\n{\\r\\nunsigned long sl=1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s,FIONBIO,&sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (!BIO_set_write_buffer_size(io,bufsize)) goto err;\\r\\nif ((con=(SSL *)SSL_new(ctx)) == NULL) goto err;\\r\\nif(context) SSL_set_session_id_context(con, context,\\r\\nstrlen((char *)context));\\r\\nsbio=BIO_new_socket(s,BIO_NOCLOSE);\\r\\nif (s_nbio_test)\\r\\n{\\r\\nBIO *test;\\r\\ntest=BIO_new(BIO_f_nbio_test());\\r\\nsbio=BIO_push(test,sbio);\\r\\n}\\r\\nSSL_set_bio(con,sbio,sbio);\\r\\nSSL_set_accept_state(con);\\r\\nBIO_set_ssl(ssl_bio,con,BIO_CLOSE);\\r\\nBIO_push(io,ssl_bio);\\r\\n#ifdef CHARSET_EBCDIC\\r\\nio = BIO_push(BIO_new(BIO_f_ebcdic_filter()),io);\\r\\n#endif\\r\\nif (s_debug)\\r\\n{\\r\\ncon->debug=1;\\r\\nBIO_set_callback(SSL_get_rbio(con),bio_dump_cb);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con),bio_s_out);\\r\\n}\\r\\nblank=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (hack)\\r\\n{\\r\\ni=SSL_accept(con);\\r\\nswitch (SSL_get_error(con,i))\\r\\n{\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\ncontinue;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nret=1;\\r\\ngoto err;\\r\\n}\\r\\nSSL_renegotiate(con);\\r\\nSSL_write(con,NULL,0);\\r\\n}\\r\\ni=BIO_gets(io,buf,bufsize-1);\\r\\nif (i < 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\n{\\r\\nif (!s_quiet)\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"read R BLOCK\\n\");\\r\\n#ifndef MSDOS\\r\\nsleep(1);\\r\\n#endif\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nelse if (i == 0)\\r\\n{\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif ( ((www == 1) && (strncmp(\"GET \",buf,4) == 0)) ||\\r\\n((www == 2) && (strncmp(\"GET /stats \",buf,10) == 0)))\\r\\n{\\r\\nchar *p;\\r\\nX509 *peer;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nstatic char *space=\" \";\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nBIO_puts(io,\"<HTML><BODY BGCOLOR=\\\"#ffffff\\\">\\n\");\\r\\nBIO_puts(io,\"<pre>\\n\");\\r\\nBIO_puts(io,\"\\n\");\\r\\nfor (i=0; i<local_argc; i++)\\r\\n{\\r\\nBIO_puts(io,local_argv[i]);\\r\\nBIO_write(io,\" \",1);\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\nBIO_printf(io,\"Ciphers supported in s_server binary\\n\");\\r\\nsk=SSL_get_ciphers(con);\\r\\nj=sk_SSL_CIPHER_num(sk);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nBIO_printf(io,\"%-11s:%-25s\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nif ((((i+1)%2) == 0) && (i+1 != j))\\r\\nBIO_puts(io,\"\\n\");\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\np=SSL_get_shared_ciphers(con,buf,bufsize);\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO_printf(io,\"---\\nCiphers common between both SSL end points:\\n\");\\r\\nj=i=0;\\r\\nwhile (*p)\\r\\n{\\r\\nif (*p == ':')\\r\\n{\\r\\nBIO_write(io,space,26-j);\\r\\ni++;\\r\\nj=0;\\r\\nBIO_write(io,((i%3)?\" \":\"\\n\"),1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_write(io,p,1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_puts(io,\"\\n\");\\r\\n}\\r\\nBIO_printf(io,((con->hit)\\r\\n?\"---\\nReused, \"\\r\\n:\"---\\nNew, \"));\\r\\nc=SSL_get_current_cipher(con);\\r\\nBIO_printf(io,\"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c),\\r\\nSSL_CIPHER_get_name(c));\\r\\nSSL_SESSION_print(io,SSL_get_session(con));\\r\\nBIO_printf(io,\"---\\n\");\\r\\nprint_stats(io,SSL_get_SSL_CTX(con));\\r\\nBIO_printf(io,\"---\\n\");\\r\\npeer=SSL_get_peer_certificate(con);\\r\\nif (peer != NULL)\\r\\n{\\r\\nBIO_printf(io,\"Client certificate\\n\");\\r\\nX509_print(io,peer);\\r\\nPEM_write_bio_X509(io,peer);\\r\\n}\\r\\nelse\\r\\nBIO_puts(io,\"no client certificate available\\n\");\\r\\nBIO_puts(io,\"</BODY></HTML>\\r\\n\\r\\n\");\\r\\nbreak;\\r\\n}\\r\\nelse if ((www == 2) && (strncmp(\"GET /\",buf,5) == 0))\\r\\n{\\r\\nBIO *file;\\r\\nchar *p,*e;\\r\\nstatic char *text=\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\";\\r\\np= &(buf[5]);\\r\\ndot=0;\\r\\nfor (e=p; *e != '\\0'; e++)\\r\\n{\\r\\nif (e[0] == ' ') break;\\r\\nif ( (e[0] == '.') &&\\r\\n(strncmp(&(e[-1]),\"/../\",4) == 0))\\r\\ndot=1;\\r\\n}\\r\\nif (*e == '\\0')\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' is an invalid file name\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\n*e='\\0';\\r\\nif (dot)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' contains '..' reference\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\nif (*p == '/')\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"'%s' is an invalid path\\r\\n\",p);\\r\\nbreak;\\r\\n}\\r\\nif (e[-1] == '/')\\r\\nstrcat(p,\"index.html\");\\r\\nif (stat(p,&st_buf) < 0)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"Error accessing '%s'\\r\\n\",p);\\r\\nERR_print_errors(io);\\r\\nbreak;\\r\\n}\\r\\nif (S_ISDIR(st_buf.st_mode))\\r\\n{\\r\\nstrcat(p,\"/index.html\");\\r\\n}\\r\\nif ((file=BIO_new_file(p,\"r\")) == NULL)\\r\\n{\\r\\nBIO_puts(io,text);\\r\\nBIO_printf(io,\"Error opening '%s'\\r\\n\",p);\\r\\nERR_print_errors(io);\\r\\nbreak;\\r\\n}\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\"FILE:%s\\n\",p);\\r\\ni=strlen(p);\\r\\nif ( ((i > 5) && (strcmp(&(p[i-5]),\".html\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i-4]),\".php\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i-4]),\".htm\") == 0)))\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nelse\\r\\nBIO_puts(io,\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\");\\r\\ntotal_bytes=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(file,buf,bufsize);\\r\\nif (i <= 0) break;\\r\\n#ifdef RENEG\\r\\ntotal_bytes+=i;\\r\\nfprintf(stderr,\"%d\\n\",i);\\r\\nif (total_bytes > 3*1024)\\r\\n{\\r\\ntotal_bytes=0;\\r\\nfprintf(stderr,\"RENEGOTIATE\\n\");\\r\\nSSL_renegotiate(con);\\r\\n}\\r\\n#endif\\r\\nfor (j=0; j<i; )\\r\\n{\\r\\n#ifdef RENEG\\r\\n{ static count=0; if (++count == 13) { SSL_renegotiate(con); } }\\r\\n#endif\\r\\nk=BIO_write(io,&(buf[j]),i-j);\\r\\nif (k <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\ngoto write_error;\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_s_out,\"rwrite W BLOCK\\n\");\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nj+=k;\\r\\n}\\r\\n}\\r\\n}\\r\\nwrite_error:\\r\\nBIO_free(file);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=(int)BIO_flush(io);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(io))\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nend:\\r\\n#if 1\\r\\nSSL_set_shutdown(con,SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\n#endif\\r\\nerr:\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out,\"ACCEPT\\n\");\\r\\nif (buf != NULL) Free(buf);\\r\\nif (io != NULL) BIO_free_all(io);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)\\r\\n{\\r\\nstatic RSA *rsa_tmp=NULL;\\r\\nif (rsa_tmp == NULL)\\r\\n{\\r\\nif (!s_quiet)\\r\\n{\\r\\nBIO_printf(bio_err,\"Generating temp (%d bit) RSA key...\",keylength);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nrsa_tmp=RSA_generate_key(keylength,RSA_F4,NULL,NULL);\\r\\nif (!s_quiet)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\n}\\r\\nreturn(rsa_tmp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_selfsign_c", "target": 0, "func": "int main()\\r\\n{\\r\\nBIO *bio_err;\\r\\nX509 *x509=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\nX509V3_add_standard_extensions();\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE);\\r\\nmkit(&x509,&pkey,512,0,365);\\r\\nRSA_print_fp(stdout,pkey->pkey.rsa,0);\\r\\nX509_print_fp(stdout,x509);\\r\\nPEM_write_RSAPrivateKey(stdout,pkey->pkey.rsa,NULL,NULL,0,NULL);\\r\\nPEM_write_X509(stdout,x509);\\r\\nX509_free(x509);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free(bio_err);\\r\\nX509V3_EXT_cleanup();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nstatic void MS_CALLBACK callback(p, n, arg)\\r\\nint p;\\r\\nint n;\\r\\nvoid *arg;\\r\\n{\\r\\nchar c='B';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nfputc(c,stderr);\\r\\n}\\r\\nint mkit(x509p,pkeyp,bits,serial,days)\\r\\nX509 **x509p;\\r\\nEVP_PKEY **pkeyp;\\r\\nint bits;\\r\\nint serial;\\r\\nint days;\\r\\n{\\r\\nX509 *x;\\r\\nEVP_PKEY *pk;\\r\\nRSA *rsa;\\r\\nX509_NAME *name=NULL;\\r\\nX509_NAME_ENTRY *ne=NULL;\\r\\nX509_EXTENSION *ex=NULL;\\r\\nif ((pkeyp == NULL) || (*pkeyp == NULL))\\r\\n{\\r\\nif ((pk=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nabort();\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse\\r\\npk= *pkeyp;\\r\\nif ((x509p == NULL) || (*x509p == NULL))\\r\\n{\\r\\nif ((x=X509_new()) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nx= *x509p;\\r\\nrsa=RSA_generate_key(bits,RSA_F4,callback,NULL);\\r\\nif (!EVP_PKEY_assign_RSA(pk,rsa))\\r\\n{\\r\\nabort();\\r\\ngoto err;\\r\\n}\\r\\nrsa=NULL;\\r\\nX509_set_version(x,3);\\r\\nASN1_INTEGER_set(X509_get_serialNumber(x),serial);\\r\\nX509_gmtime_adj(X509_get_notBefore(x),0);\\r\\nX509_gmtime_adj(X509_get_notAfter(x),(long)60*60*24*days);\\r\\nX509_set_pubkey(x,pk);\\r\\nname=X509_NAME_new();\\r\\nne=X509_NAME_ENTRY_create_by_NID(NULL,NID_countryName,\\r\\nV_ASN1_APP_CHOOSE,\"AU\",-1);\\r\\nX509_NAME_add_entry(name,ne,0,0);\\r\\nX509_NAME_ENTRY_create_by_NID(&ne,NID_commonName,\\r\\nV_ASN1_APP_CHOOSE,\"Eric Young\",-1);\\r\\nX509_NAME_add_entry(name,ne,1,0);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nX509_set_subject_name(x,name);\\r\\nX509_set_issuer_name(x,name);\\r\\nX509_NAME_free(name);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_cert_type, \"server\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_comment,\\r\\n\"example comment extension\");\\r\\nX509_add_ext(x,ex,-1);\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_ssl_server_name,\\r\\n\"www.openssl.org\");\\r\\nX509_add_ext(x,ex,-1);\\r\\n#if 0\\r\\nex = X509V3_EXT_conf_nid(NULL, NULL, NID_basic_constraints,\\r\\n\"critical,CA:TRUE\");\\r\\nX509_add_ext(x,ex,-1);\\r\\n#endif\\r\\nif (!X509_sign(x,pk,EVP_md5()))\\r\\ngoto err;\\r\\n*x509p=x;\\r\\n*pkeyp=pk;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_srvr_c", "target": 1, "func": "static SSL_METHOD *ssl2_get_server_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_server_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_server_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_server_data.ssl_accept=ssl2_accept;\\r\\nSSLv2_server_data.get_ssl_method=ssl2_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv2_server_data);\\r\\n}\\r\\nint ssl2_accept(SSL *s)\\r\\n{\\r\\nunsigned long l=time(NULL);\\r\\nBUF_MEM *buf=NULL;\\r\\nint ret= -1;\\r\\nlong num1;\\r\\nvoid (*cb)()=NULL;\\r\\nint new_state,state;\\r\\nRAND_seed(&l,sizeof(l));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL2_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nclear_sys_error();\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->version=SSL2_VERSION;\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nbuf=s->init_buf;\\r\\nif ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))\\r\\n{ ret= -1; goto end; }\\r\\nif (!BUF_MEM_grow(buf,(int)\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{ ret= -1; goto end; }\\r\\ns->init_buf=buf;\\r\\ns->init_num=0;\\r\\ns->ctx->stats.sess_accept++;\\r\\ns->handshake_func=ssl2_accept;\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A:\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B:\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C:\\r\\ns->shutdown=0;\\r\\nret=get_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_HELLO_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A:\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B:\\r\\nret=server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (!s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_GET_CLIENT_MASTER_KEY_A;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_SERVER_START_ENCRYPTION;\\r\\nBREAK;\\r\\n}\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A:\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B:\\r\\nret=get_client_master_key(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SERVER_START_ENCRYPTION;\\r\\nBREAK;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION:\\r\\nif (!ssl2_enc_init(s,0))\\r\\n{ ret= -1; goto end; }\\r\\ns->s2->clear_text=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A:\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B:\\r\\nret=server_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\nif (s->hit)\\r\\n{\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_C;\\r\\nBREAK;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_A;\\r\\nbreak;\\r\\n}\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 != 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->wbio=BIO_pop(s->wbio);\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A:\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B:\\r\\nret=get_client_finished(s);\\r\\nif (ret <= 0)\\r\\ngoto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_A;\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C:\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D:\\r\\nif (!(s->verify_mode & SSL_VERIFY_PEER) ||\\r\\n((s->session->peer != NULL) &&\\r\\n(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)))\\r\\n{\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_A;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=request_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_A;\\r\\n}\\r\\nBREAK;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A:\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B:\\r\\nret=server_finish(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL_ST_OK;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nBUF_MEM_free(s->init_buf);\\r\\nssl_free_wbio_buffer(s);\\r\\ns->init_buf=NULL;\\r\\ns->init_num=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_SERVER);\\r\\ns->ctx->stats.sess_accept_good++;\\r\\nret=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL2_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int get_client_master_key(SSL *s)\\r\\n{\\r\\nint is_export,i,n,keya,ek;\\r\\nunsigned char *p;\\r\\nSSL_CIPHER *cp;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *md;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_MASTER_KEY_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),10-s->init_num);\\r\\nif (i < (10-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_MASTER_KEY,i));\\r\\nif (*(p++) != SSL2_MT_CLIENT_MASTER_KEY)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\\r\\nSSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ncp=ssl2_get_cipher_by_char(p);\\r\\nif (cp == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,\\r\\nSSL_R_NO_CIPHER_MATCH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->session->cipher= cp;\\r\\np+=3;\\r\\nn2s(p,i); s->s2->tmp.clear=i;\\r\\nn2s(p,i); s->s2->tmp.enc=i;\\r\\nn2s(p,i); s->session->key_arg_length=i;\\r\\ns->state=SSL2_ST_GET_CLIENT_MASTER_KEY_B;\\r\\ns->init_num=0;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nkeya=s->session->key_arg_length;\\r\\nn=s->s2->tmp.clear+s->s2->tmp.enc+keya - s->init_num;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i != n) return(ssl2_part_read(s,SSL_F_GET_CLIENT_MASTER_KEY,i));\\r\\nmemcpy(s->session->key_arg,&(p[s->s2->tmp.clear+s->s2->tmp.enc]),\\r\\n(unsigned int)keya);\\r\\nif (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_NO_PRIVATEKEY);\\r\\nreturn(-1);\\r\\n}\\r\\ni=ssl_rsa_private_decrypt(s->cert,s->s2->tmp.enc,\\r\\n&(p[s->s2->tmp.clear]),&(p[s->s2->tmp.clear]),\\r\\n(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);\\r\\nis_export=SSL_C_IS_EXPORT(s->session->cipher);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\\r\\nreturn(0);\\r\\n}\\r\\nif (s->session->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)\\r\\n{\\r\\nis_export=1;\\r\\nek=8;\\r\\n}\\r\\nelse\\r\\nek=5;\\r\\n#if 1\\r\\nif ((i < 0) ||\\r\\n((!is_export && (i != EVP_CIPHER_key_length(c)))\\r\\n|| (is_export && ((i != ek) || (s->s2->tmp.clear+i !=\\r\\nEVP_CIPHER_key_length(c))))))\\r\\n{\\r\\nif (is_export)\\r\\ni=ek;\\r\\nelse\\r\\ni=EVP_CIPHER_key_length(c);\\r\\nRAND_bytes(p,i);\\r\\n}\\r\\n#else\\r\\nif (i < 0)\\r\\n{\\r\\nerror=1;\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_RSA_DECRYPT);\\r\\n}\\r\\nelse if ((!is_export && (i != EVP_CIPHER_key_length(c)))\\r\\n|| (is_export && ((i != ek) || (s->s2->tmp.clear+i !=\\r\\nEVP_CIPHER_key_length(c)))))\\r\\n{\\r\\nerror=1;\\r\\nSSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_WRONG_NUMBER_OF_KEY_BITS);\\r\\n}\\r\\nif (error)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n#endif\\r\\nif (is_export) i+=s->s2->tmp.clear;\\r\\ns->session->master_key_length=i;\\r\\nmemcpy(s->session->master_key,p,(unsigned int)i);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int get_client_hello(SSL *s)\\r\\n{\\r\\nint i,n;\\r\\nunsigned char *p;\\r\\nSTACK_OF(SSL_CIPHER) *cs;\\r\\nSTACK_OF(SSL_CIPHER) *cl;\\r\\nint z;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_HELLO_A)\\r\\n{\\r\\ns->first_packet=1;\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_B;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_HELLO_B)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),9-s->init_num);\\r\\nif (i < (9-s->init_num))\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_HELLO,i));\\r\\nif (*(p++) != SSL2_MT_CLIENT_HELLO)\\r\\n{\\r\\nif (p[-1] != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nn2s(p,i);\\r\\nif (i < s->version) s->version=i;\\r\\nn2s(p,i); s->s2->tmp.cipher_spec_length=i;\\r\\nn2s(p,i); s->s2->tmp.session_id_length=i;\\r\\nn2s(p,i); s->s2->challenge_length=i;\\r\\nif ( (i < SSL2_MIN_CHALLENGE_LENGTH) ||\\r\\n(i > SSL2_MAX_CHALLENGE_LENGTH))\\r\\n{\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_INVALID_CHALLENGE_LENGTH);\\r\\nreturn(-1);\\r\\n}\\r\\ns->state=SSL2_ST_GET_CLIENT_HELLO_C;\\r\\ns->init_num=0;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nn=s->s2->tmp.cipher_spec_length+s->s2->challenge_length+\\r\\ns->s2->tmp.session_id_length-s->init_num;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),n);\\r\\nif (i != n) return(ssl2_part_read(s,SSL_F_GET_CLIENT_HELLO,i));\\r\\nif ((s->s2->tmp.session_id_length != 0) &&\\r\\n(s->s2->tmp.session_id_length != SSL2_SSL_SESSION_ID_LENGTH))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_BAD_SSL_SESSION_ID_LENGTH);\\r\\nreturn(-1);\\r\\n}\\r\\nif (s->s2->tmp.session_id_length == 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_get_prev_session(s,&(p[s->s2->tmp.cipher_spec_length]),\\r\\ns->s2->tmp.session_id_length);\\r\\nif (i == 1)\\r\\n{\\r\\ns->hit=1;\\r\\n}\\r\\nelse if (i == -1)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CERTIFICATE);\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nif (!ssl_get_new_session(s,1))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!s->hit)\\r\\n{\\r\\ncs=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.cipher_spec_length,\\r\\n&s->session->ciphers);\\r\\nif (cs == NULL) goto mem_err;\\r\\ncl=ssl_get_ciphers_by_id(s);\\r\\nfor (z=0; z<sk_SSL_CIPHER_num(cs); z++)\\r\\n{\\r\\nif (sk_SSL_CIPHER_find(cl,sk_SSL_CIPHER_value(cs,z)) < 0)\\r\\n{\\r\\nsk_SSL_CIPHER_delete(cs,z);\\r\\nz--;\\r\\n}\\r\\n}\\r\\n}\\r\\np+=s->s2->tmp.cipher_spec_length;\\r\\np+=s->s2->tmp.session_id_length;\\r\\nmemcpy(s->s2->challenge,p,(unsigned int)s->s2->challenge_length);\\r\\nreturn(1);\\r\\nmem_err:\\r\\nSSLerr(SSL_F_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nstatic int server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint n,hit;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_HELLO_A)\\r\\n{\\r\\nd=p+11;\\r\\n*(p++)=SSL2_MT_SERVER_HELLO;\\r\\nhit=s->hit;\\r\\n*(p++)=(unsigned char)hit;\\r\\n#if 1\\r\\nif (!hit)\\r\\n{\\r\\nif (s->session->sess_cert != NULL)\\r\\nssl_sess_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert = ssl_sess_cert_new();\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SERVER_HELLO, ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (!hit)\\r\\n{\\r\\nCRYPTO_add(&s->cert->references,1,CRYPTO_LOCK_SSL_CERT);\\r\\nif (s->session->sess_cert != NULL)\\r\\nssl_cert_free(s->session->sess_cert);\\r\\ns->session->sess_cert=s->cert;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nCRYPTO_add(&s->cert->references,1,\\r\\nCRYPTO_LOCK_SSL_CERT);\\r\\ns->session->sess_cert=s->cert;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_NO_CERTIFICATE);\\r\\nSSLerr(SSL_F_SERVER_HELLO,SSL_R_NO_CERTIFICATE_SPECIFIED);\\r\\nreturn(-1);\\r\\n}\\r\\nif (hit)\\r\\n{\\r\\n*(p++)=0;\\r\\ns2n(s->version,p);\\r\\ns2n(0,p);\\r\\ns2n(0,p);\\r\\n}\\r\\nelse\\r\\n{\\r\\n*(p++)=SSL2_CT_X509_CERTIFICATE;\\r\\ns2n(s->version,p);\\r\\nn=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,NULL);\\r\\ns2n(n,p);\\r\\ni2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,&d);\\r\\nn=0;\\r\\nsk= s->session->ciphers;\\r\\nn=ssl_cipher_list_to_bytes(s,s->session->ciphers,d);\\r\\nd+=n;\\r\\ns2n(n,p);\\r\\n}\\r\\ns2n(SSL2_CONNECTION_ID_LENGTH,p);\\r\\ns->s2->conn_id_length=SSL2_CONNECTION_ID_LENGTH;\\r\\nRAND_bytes(s->s2->conn_id,(int)s->s2->conn_id_length);\\r\\nmemcpy(d,s->s2->conn_id,SSL2_CONNECTION_ID_LENGTH);\\r\\nd+=SSL2_CONNECTION_ID_LENGTH;\\r\\ns->state=SSL2_ST_SEND_SERVER_HELLO_B;\\r\\ns->init_num=d-(unsigned char *)s->init_buf->data;\\r\\ns->init_off=0;\\r\\n}\\r\\nif (s->hit)\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) return(-1);\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int get_client_finished(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nint i;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL2_ST_GET_CLIENT_FINISHED_A)\\r\\n{\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);\\r\\nif (i < 1-s->init_num)\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_FINISHED,i));\\r\\nif (*p != SSL2_MT_CLIENT_FINISHED)\\r\\n{\\r\\nif (*p != SSL2_MT_ERROR)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);\\r\\n}\\r\\nelse\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_PEER_ERROR);\\r\\nreturn(-1);\\r\\n}\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_GET_CLIENT_FINISHED_B;\\r\\n}\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),s->s2->conn_id_length-s->init_num);\\r\\nif (i < (int)s->s2->conn_id_length-s->init_num)\\r\\n{\\r\\nreturn(ssl2_part_read(s,SSL_F_GET_CLIENT_FINISHED,i));\\r\\n}\\r\\nif (memcmp(p,s->s2->conn_id,(unsigned int)s->s2->conn_id_length) != 0)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_GET_CLIENT_FINISHED,SSL_R_CONNECTION_ID_IS_DIFFERENT);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int server_verify(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_VERIFY_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_SERVER_VERIFY;\\r\\nmemcpy(p,s->s2->challenge,(unsigned int)s->s2->challenge_length);\\r\\ns->state=SSL2_ST_SEND_SERVER_VERIFY_B;\\r\\ns->init_num=s->s2->challenge_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int server_finish(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL2_ST_SEND_SERVER_FINISHED_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_SERVER_FINISHED;\\r\\nmemcpy(p,s->session->session_id,\\r\\n(unsigned int)s->session->session_id_length);\\r\\ns->state=SSL2_ST_SEND_SERVER_FINISHED_B;\\r\\ns->init_num=s->session->session_id_length+1;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl2_do_write(s));\\r\\n}\\r\\nstatic int request_certificate(SSL *s)\\r\\n{\\r\\nunsigned char *p,*p2,*buf2;\\r\\nunsigned char *ccd;\\r\\nint i,j,ctype,ret= -1;\\r\\nX509 *x509=NULL;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nccd=s->s2->tmp.ccl;\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL2_MT_REQUEST_CERTIFICATE;\\r\\n*(p++)=SSL2_AT_MD5_WITH_RSA_ENCRYPTION;\\r\\nRAND_bytes(ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH);\\r\\nmemcpy(p,ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH);\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_B;\\r\\ns->init_num=SSL2_MIN_CERT_CHALLENGE_LENGTH+2;\\r\\ns->init_off=0;\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_B)\\r\\n{\\r\\ni=ssl2_do_write(s);\\r\\nif (i <= 0)\\r\\n{\\r\\nret=i;\\r\\ngoto end;\\r\\n}\\r\\ns->init_num=0;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_C;\\r\\n}\\r\\nif (s->state == SSL2_ST_SEND_REQUEST_CERTIFICATE_C)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),6-s->init_num);\\r\\nif (i < 3)\\r\\n{\\r\\nret=ssl2_part_read(s,SSL_F_REQUEST_CERTIFICATE,i);\\r\\ngoto end;\\r\\n}\\r\\nif ((*p == SSL2_MT_ERROR) && (i >= 3))\\r\\n{\\r\\nn2s(p,i);\\r\\nif (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\ngoto end;\\r\\n}\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif ((*(p++) != SSL2_MT_CLIENT_CERTIFICATE) || (i < 6))\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_SHORT_READ);\\r\\ngoto end;\\r\\n}\\r\\nctype= *(p++);\\r\\nif (ctype != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)\\r\\n{\\r\\nssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_RESPONSE_ARGUMENT);\\r\\ngoto end;\\r\\n}\\r\\nn2s(p,i); s->s2->tmp.clen=i;\\r\\nn2s(p,i); s->s2->tmp.rlen=i;\\r\\ns->state=SSL2_ST_SEND_REQUEST_CERTIFICATE_D;\\r\\ns->init_num=0;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nj=s->s2->tmp.clen+s->s2->tmp.rlen-s->init_num;\\r\\ni=ssl2_read(s,(char *)&(p[s->init_num]),j);\\r\\nif (i < j)\\r\\n{\\r\\nret=ssl2_part_read(s,SSL_F_REQUEST_CERTIFICATE,i);\\r\\ngoto end;\\r\\n}\\r\\nx509=(X509 *)d2i_X509(NULL,&p,(long)s->s2->tmp.clen);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_X509_LIB);\\r\\ngoto msg_end;\\r\\n}\\r\\nif (((sk=sk_X509_new_null()) == NULL) || (!sk_X509_push(sk,x509)))\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto msg_end;\\r\\n}\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif (i)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nEVP_VerifyInit(&ctx,s->ctx->rsa_md5);\\r\\nEVP_VerifyUpdate(&ctx,s->s2->key_material,\\r\\n(unsigned int)s->s2->key_material_length);\\r\\nEVP_VerifyUpdate(&ctx,ccd,SSL2_MIN_CERT_CHALLENGE_LENGTH);\\r\\ni=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,NULL);\\r\\nbuf2=(unsigned char *)Malloc((unsigned int)i);\\r\\nif (buf2 == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto msg_end;\\r\\n}\\r\\np2=buf2;\\r\\ni=i2d_X509(s->cert->pkeys[SSL_PKEY_RSA_ENC].x509,&p2);\\r\\nEVP_VerifyUpdate(&ctx,buf2,(unsigned int)i);\\r\\nFree(buf2);\\r\\npkey=X509_get_pubkey(x509);\\r\\nif (pkey == NULL) goto end;\\r\\ni=EVP_VerifyFinal(&ctx,p,s->s2->tmp.rlen,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nmemset(&ctx,0,sizeof(ctx));\\r\\nif (i)\\r\\n{\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\ns->session->peer=x509;\\r\\nCRYPTO_add(&x509->references,1,CRYPTO_LOCK_X509);\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_REQUEST_CERTIFICATE,SSL_R_BAD_CHECKSUM);\\r\\ngoto msg_end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmsg_end:\\r\\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\\r\\n}\\r\\nend:\\r\\nsk_X509_free(sk);\\r\\nX509_free(x509);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_rsa_private_decrypt(CERT *c, int len, unsigned char *from,\\r\\nunsigned char *to, int padding)\\r\\n{\\r\\nRSA *rsa;\\r\\nint i;\\r\\nif ((c == NULL) || (c->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,SSL_R_NO_PRIVATEKEY);\\r\\nreturn(-1);\\r\\n}\\r\\nif (c->pkeys[SSL_PKEY_RSA_ENC].privatekey->type != EVP_PKEY_RSA)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);\\r\\nreturn(-1);\\r\\n}\\r\\nrsa=c->pkeys[SSL_PKEY_RSA_ENC].privatekey->pkey.rsa;\\r\\ni=RSA_private_decrypt(len,from,to,rsa,padding);\\r\\nif (i < 0)\\r\\nSSLerr(SSL_F_SSL_RSA_PRIVATE_DECRYPT,ERR_R_RSA_LIB);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_d2_c", "target": 0, "func": "int X509_STORE_set_default_paths(X509_STORE *ctx)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nreturn(1);\\r\\n}\\r\\nint X509_STORE_load_locations(X509_STORE *ctx, const char *file,\\r\\nconst char *path)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nif (file != NULL)\\r\\n{\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_file());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_load_file(lookup,file,X509_FILETYPE_PEM);\\r\\n}\\r\\nif (path != NULL)\\r\\n{\\r\\nlookup=X509_STORE_add_lookup(ctx,X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) return(0);\\r\\nX509_LOOKUP_add_dir(lookup,path,X509_FILETYPE_PEM);\\r\\n}\\r\\nif ((path == NULL) && (file == NULL))\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_dsap_c", "target": 0, "func": "DSA *d2i_DSAparams(DSA **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ERR_R_NESTED_ASN1_ERROR;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,DSA *,DSA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->p=BN_bin2bn(bs->data,bs->length,ret->p)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->q=BN_bin2bn(bs->data,bs->length,ret->q)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->g=BN_bin2bn(bs->data,bs->length,ret->g)) == NULL) goto err_bn;\\r\\nASN1_BIT_STRING_free(bs);\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_DSAPARAMS,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) DSA_free(ret);\\r\\nif (bs != NULL) ASN1_BIT_STRING_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_rand_c", "target": 0, "func": "int BN_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nunsigned char *buf=NULL;\\r\\nint ret=0,bit,bytes,mask;\\r\\ntime_t tim;\\r\\nbytes=(bits+7)/8;\\r\\nbit=(bits-1)%8;\\r\\nmask=0xff<<bit;\\r\\nbuf=(unsigned char *)Malloc(bytes);\\r\\nif (buf == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_RAND,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntime(&tim);\\r\\nRAND_seed(&tim,sizeof(tim));\\r\\nRAND_bytes(buf,(int)bytes);\\r\\nif (top)\\r\\n{\\r\\nif (bit == 0)\\r\\n{\\r\\nbuf[0]=1;\\r\\nbuf[1]|=0x80;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]|=(3<<(bit-1));\\r\\nbuf[0]&= ~(mask<<1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nbuf[0]|=(1<<bit);\\r\\nbuf[0]&= ~(mask<<1);\\r\\n}\\r\\nif (bottom)\\r\\nbuf[bytes-1]|=1;\\r\\nif (!BN_bin2bn(buf,bytes,rnd)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,bytes);\\r\\nFree(buf);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_i_c", "target": 0, "func": "EVP_CIPHER *EVP_idea_cfb(void)\\r\\n{\\r\\nreturn(&i_cfb_cipher);\\r\\n}\\r\\nstatic void idea_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nidea_set_encrypt_key(key,&(ctx->c.idea_ks));\\r\\n}\\r\\nstatic void idea_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nidea_cfb64_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.idea_ks),&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_gcd_c", "target": 0, "func": "int BN_gcd(BIGNUM *r, BIGNUM *in_a, BIGNUM *in_b, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *a,*b,*t;\\r\\nint ret=0;\\r\\nbn_check_top(in_a);\\r\\nbn_check_top(in_b);\\r\\na= &(ctx->bn[ctx->tos]);\\r\\nb= &(ctx->bn[ctx->tos+1]);\\r\\nif (BN_copy(a,in_a) == NULL) goto err;\\r\\nif (BN_copy(b,in_b) == NULL) goto err;\\r\\nif (BN_cmp(a,b) < 0) { t=a; a=b; b=t; }\\r\\nt=euclid(a,b);\\r\\nif (t == NULL) goto err;\\r\\nif (BN_copy(r,t) == NULL) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic BIGNUM *euclid(BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint shifts=0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nfor (;;)\\r\\n{\\r\\nif (BN_is_zero(b))\\r\\nbreak;\\r\\nif (BN_is_odd(a))\\r\\n{\\r\\nif (BN_is_odd(b))\\r\\n{\\r\\nif (!BN_sub(a,a,b)) goto err;\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(b,b)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BN_is_odd(b))\\r\\n{\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (BN_cmp(a,b) < 0)\\r\\n{ t=a; a=b; b=t; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_rshift1(a,a)) goto err;\\r\\nif (!BN_rshift1(b,b)) goto err;\\r\\nshifts++;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (shifts)\\r\\n{\\r\\nif (!BN_lshift(a,a,shifts)) goto err;\\r\\n}\\r\\nreturn(a);\\r\\nerr:\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *BN_mod_inverse(BIGNUM *in, BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *A,*B,*X,*Y,*M,*D,*R;\\r\\nBIGNUM *T,*ret=NULL;\\r\\nint sign;\\r\\nbn_check_top(a);\\r\\nbn_check_top(n);\\r\\nA= &(ctx->bn[ctx->tos]);\\r\\nB= &(ctx->bn[ctx->tos+1]);\\r\\nX= &(ctx->bn[ctx->tos+2]);\\r\\nD= &(ctx->bn[ctx->tos+3]);\\r\\nM= &(ctx->bn[ctx->tos+4]);\\r\\nY= &(ctx->bn[ctx->tos+5]);\\r\\nctx->tos+=6;\\r\\nif (in == NULL)\\r\\nR=BN_new();\\r\\nelse\\r\\nR=in;\\r\\nif (R == NULL) goto err;\\r\\nBN_zero(X);\\r\\nBN_one(Y);\\r\\nif (BN_copy(A,a) == NULL) goto err;\\r\\nif (BN_copy(B,n) == NULL) goto err;\\r\\nsign=1;\\r\\nwhile (!BN_is_zero(B))\\r\\n{\\r\\nif (!BN_div(D,M,A,B,ctx)) goto err;\\r\\nT=A;\\r\\nA=B;\\r\\nB=M;\\r\\nif (!BN_mul(T,D,X,ctx)) goto err;\\r\\nif (!BN_add(T,T,Y)) goto err;\\r\\nM=Y;\\r\\nY=X;\\r\\nX=T;\\r\\nsign= -sign;\\r\\n}\\r\\nif (sign < 0)\\r\\n{\\r\\nif (!BN_sub(Y,n,Y)) goto err;\\r\\n}\\r\\nif (BN_is_one(A))\\r\\n{ if (!BN_mod(R,Y,n,ctx)) goto err; }\\r\\nelse\\r\\n{\\r\\nBNerr(BN_F_BN_MOD_INVERSE,BN_R_NO_INVERSE);\\r\\ngoto err;\\r\\n}\\r\\nret=R;\\r\\nerr:\\r\\nif ((ret == NULL) && (in == NULL)) BN_free(R);\\r\\nctx->tos-=6;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_mem_c", "target": 0, "func": "BIO_METHOD *BIO_s_mem(void)\\r\\n{\\r\\nreturn(&mem_method);\\r\\n}\\r\\nstatic int mem_new(BIO *bi)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nif ((b=BUF_MEM_new()) == NULL)\\r\\nreturn(0);\\r\\nbi->shutdown=1;\\r\\nbi->init=1;\\r\\nbi->num= -1;\\r\\nbi->ptr=(char *)b;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int mem_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif ((a->init) && (a->ptr != NULL))\\r\\n{\\r\\nBUF_MEM_free((BUF_MEM *)a->ptr);\\r\\na->ptr=NULL;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int mem_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret= -1;\\r\\nBUF_MEM *bm;\\r\\nint i;\\r\\nchar *from,*to;\\r\\nbm=(BUF_MEM *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nret=(outl > bm->length)?bm->length:outl;\\r\\nif ((out != NULL) && (ret > 0))\\r\\n{\\r\\nmemcpy(out,bm->data,ret);\\r\\nbm->length-=ret;\\r\\nfrom=(char *)&(bm->data[ret]);\\r\\nto=(char *)&(bm->data[0]);\\r\\nfor (i=0; i<bm->length; i++)\\r\\nto[i]=from[i];\\r\\n}\\r\\nelse if (bm->length == 0)\\r\\n{\\r\\nif (b->num != 0)\\r\\nBIO_set_retry_read(b);\\r\\nret= b->num;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret= -1;\\r\\nint blen;\\r\\nBUF_MEM *bm;\\r\\nbm=(BUF_MEM *)b->ptr;\\r\\nif (in == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_MEM_WRITE,BIO_R_NULL_PARAMETER);\\r\\ngoto end;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nblen=bm->length;\\r\\nif (BUF_MEM_grow(bm,blen+inl) != (blen+inl))\\r\\ngoto end;\\r\\nmemcpy(&(bm->data[blen]),in,inl);\\r\\nret=inl;\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long mem_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nchar **pptr;\\r\\nBUF_MEM *bm=(BUF_MEM *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nif (bm->data != NULL)\\r\\nmemset(bm->data,0,bm->max);\\r\\nbm->length=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nret=(long)(bm->length == 0);\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM_EOF_RETURN:\\r\\nb->num=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret=(long)bm->length;\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(char **)ptr;\\r\\n*pptr=(char *)&(bm->data[0]);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM:\\r\\nmem_free(b);\\r\\nb->shutdown=(int)num;\\r\\nb->ptr=ptr;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUF_MEM_PTR:\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(char **)ptr;\\r\\n*pptr=(char *)bm;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=(long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0L;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=(long)bm->length;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i,j;\\r\\nint ret= -1;\\r\\nchar *p;\\r\\nBUF_MEM *bm=(BUF_MEM *)bp->ptr;\\r\\nBIO_clear_retry_flags(bp);\\r\\nj=bm->length;\\r\\nif (j <= 0) return(0);\\r\\np=bm->data;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (p[i] == '\\n') break;\\r\\n}\\r\\nif (i == j)\\r\\n{\\r\\nBIO_set_retry_read(bp);\\r\\n}\\r\\nelse\\r\\ni++;\\r\\nif ((size-1) < i) i=size-1;\\r\\ni=mem_read(bp,buf,i);\\r\\nif (i > 0) buf[i]='\\0';\\r\\nret=i;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int mem_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=mem_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cfb_enc_c", "target": 0, "func": "void des_cfb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, des_key_schedule schedule, des_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG d0,d1,v0,v1,n=(numbits+7)/8;\\r\\nregister DES_LONG mask0,mask1;\\r\\nregister unsigned long l=length;\\r\\nregister int num=numbits;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nif (num > 64) return;\\r\\nif (num > 32)\\r\\n{\\r\\nmask0=0xffffffffL;\\r\\nif (num == 64)\\r\\nmask1=mask0;\\r\\nelse mask1=(1L<<(num-32))-1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (num == 32)\\r\\nmask0=0xffffffffL;\\r\\nelse mask0=(1L<<num)-1;\\r\\nmask1=0x00000000L;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nif (enc)\\r\\n{\\r\\nwhile (l >= n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndes_encrypt((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nd0=(d0^ti[0])&mask0;\\r\\nd1=(d1^ti[1])&mask1;\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (num == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse if (num > 32)\\r\\n{\\r\\nv0=((v1>>(num-32))|(d0<<(64-num)))&0xffffffffL;\\r\\nv1=((d0>>(num-32))|(d1<<(64-num)))&0xffffffffL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nv0=((v0>>num)|(v1<<(32-num)))&0xffffffffL;\\r\\nv1=((v1>>num)|(d0<<(32-num)))&0xffffffffL;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l >= n)\\r\\n{\\r\\nl-=n;\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndes_encrypt((DES_LONG *)ti,schedule,DES_ENCRYPT);\\r\\nc2ln(in,d0,d1,n);\\r\\nin+=n;\\r\\nif (num == 32)\\r\\n{ v0=v1; v1=d0; }\\r\\nelse if (num == 64)\\r\\n{ v0=d0; v1=d1; }\\r\\nelse if (num > 32)\\r\\n{\\r\\nv0=((v1>>(num-32))|(d0<<(64-num)))&0xffffffffL;\\r\\nv1=((d0>>(num-32))|(d1<<(64-num)))&0xffffffffL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nv0=((v0>>num)|(v1<<(32-num)))&0xffffffffL;\\r\\nv1=((v1>>num)|(d0<<(32-num)))&0xffffffffL;\\r\\n}\\r\\nd0=(d0^ti[0])&mask0;\\r\\nd1=(d1^ti[1])&mask1;\\r\\nl2cn(d0,d1,out,n);\\r\\nout+=n;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\nv0=v1=d0=d1=ti[0]=ti[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_add_c", "target": 0, "func": "int BN_add(BIGNUM *r, BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nBIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg ^ b->neg)\\r\\n{\\r\\nif (a->neg)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nif (BN_ucmp(a,b) < 0)\\r\\n{\\r\\nif (!BN_usub(r,b,a)) return(0);\\r\\nr->neg=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_usub(r,a,b)) return(0);\\r\\nr->neg=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nif (a->neg)\\r\\nr->neg=1;\\r\\nelse\\r\\nr->neg=0;\\r\\nif (!BN_uadd(r,a,b)) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nregister int i;\\r\\nint max,min;\\r\\nBN_ULONG *ap,*bp,*rp,carry,t1;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nmax=a->top;\\r\\nmin=b->top;\\r\\nif (bn_wexpand(r,max+1) == NULL)\\r\\nreturn(0);\\r\\nr->top=max;\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nrp=r->d;\\r\\ncarry=0;\\r\\ncarry=bn_add_words(rp,ap,bp,min);\\r\\nrp+=min;\\r\\nap+=min;\\r\\nbp+=min;\\r\\ni=min;\\r\\nif (carry)\\r\\n{\\r\\nwhile (i < max)\\r\\n{\\r\\ni++;\\r\\nt1= *(ap++);\\r\\nif ((*(rp++)=(t1+1)&BN_MASK2) >= t1)\\r\\n{\\r\\ncarry=0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif ((i >= max) && carry)\\r\\n{\\r\\n*(rp++)=1;\\r\\nr->top++;\\r\\n}\\r\\n}\\r\\nif (rp != ap)\\r\\n{\\r\\nfor (; i<max; i++)\\r\\n*(rp++)= *(ap++);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max,min;\\r\\nregister BN_ULONG t1,t2,*ap,*bp,*rp;\\r\\nint i,carry;\\r\\n#if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\nint dummy;\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top)\\r\\n{\\r\\nBNerr(BN_F_BN_USUB,BN_R_ARG2_LT_ARG3);\\r\\nreturn(0);\\r\\n}\\r\\nmax=a->top;\\r\\nmin=b->top;\\r\\nif (bn_wexpand(r,max) == NULL) return(0);\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nrp=r->d;\\r\\n#if 1\\r\\ncarry=0;\\r\\nfor (i=0; i<min; i++)\\r\\n{\\r\\nt1= *(ap++);\\r\\nt2= *(bp++);\\r\\nif (carry)\\r\\n{\\r\\ncarry=(t1 <= t2);\\r\\nt1=(t1-t2-1)&BN_MASK2;\\r\\n}\\r\\nelse\\r\\n{\\r\\ncarry=(t1 < t2);\\r\\nt1=(t1-t2)&BN_MASK2;\\r\\n}\\r\\n#if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\ndummy=t1;\\r\\n#endif\\r\\n*(rp++)=t1&BN_MASK2;\\r\\n}\\r\\n#else\\r\\ncarry=bn_sub_words(rp,ap,bp,min);\\r\\nap+=min;\\r\\nbp+=min;\\r\\nrp+=min;\\r\\ni=min;\\r\\n#endif\\r\\nif (carry)\\r\\n{\\r\\nwhile (i < max)\\r\\n{\\r\\ni++;\\r\\nt1= *(ap++);\\r\\nt2=(t1-1)&BN_MASK2;\\r\\n*(rp++)=t2;\\r\\nif (t1 > t2) break;\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nmemcpy(rp,ap,sizeof(*rp)*(max-i));\\r\\n#else\\r\\nif (rp != ap)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (i++ >= max) break;\\r\\nrp[0]=ap[0];\\r\\nif (i++ >= max) break;\\r\\nrp[1]=ap[1];\\r\\nif (i++ >= max) break;\\r\\nrp[2]=ap[2];\\r\\nif (i++ >= max) break;\\r\\nrp[3]=ap[3];\\r\\nrp+=4;\\r\\nap+=4;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nr->top=max;\\r\\nbn_fix_top(r);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max;\\r\\nint add=0,neg=0;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg)\\r\\n{\\r\\nif (b->neg)\\r\\n{ tmp=a; a=b; b=tmp; }\\r\\nelse\\r\\n{ add=1; neg=1; }\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (b->neg) { add=1; neg=0; }\\r\\n}\\r\\nif (add)\\r\\n{\\r\\nif (!BN_uadd(r,a,b)) return(0);\\r\\nr->neg=neg;\\r\\nreturn(1);\\r\\n}\\r\\nmax=(a->top > b->top)?a->top:b->top;\\r\\nif (bn_wexpand(r,max) == NULL) return(0);\\r\\nif (BN_ucmp(a,b) < 0)\\r\\n{\\r\\nif (!BN_usub(r,b,a)) return(0);\\r\\nr->neg=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (!BN_usub(r,a,b)) return(0);\\r\\nr->neg=0;\\r\\n}\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_b64_c", "target": 0, "func": "BIO_METHOD *BIO_f_base64(void)\\r\\n{\\r\\nreturn(&methods_b64);\\r\\n}\\r\\nstatic int b64_new(BIO *bi)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nctx=(BIO_B64_CTX *)Malloc(sizeof(BIO_B64_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nctx->buf_len=0;\\r\\nctx->tmp_len=0;\\r\\nctx->tmp_nl=0;\\r\\nctx->buf_off=0;\\r\\nctx->cont=1;\\r\\nctx->start=1;\\r\\nctx->encode=0;\\r\\nbi->init=1;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int b64_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int b64_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i,ii,j,k,x,n,num,ret_code=0;\\r\\nBIO_B64_CTX *ctx;\\r\\nunsigned char *p,*q;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->encode != B64_DECODE)\\r\\n{\\r\\nctx->encode=B64_DECODE;\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\nEVP_DecodeInit(&(ctx->base64));\\r\\n}\\r\\nif (ctx->buf_len > 0)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\n}\\r\\nret_code=0;\\r\\nwhile (outl > 0)\\r\\n{\\r\\nif (ctx->cont <= 0) break;\\r\\ni=BIO_read(b->next_bio,&(ctx->tmp[ctx->tmp_len]),\\r\\nB64_BLOCK_SIZE-ctx->tmp_len);\\r\\nif (i <= 0)\\r\\n{\\r\\nret_code=i;\\r\\nif (!BIO_should_retry(b->next_bio))\\r\\nctx->cont=i;\\r\\nbreak;\\r\\n}\\r\\ni+=ctx->tmp_len;\\r\\nif (ctx->start && (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL))\\r\\n{\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nelse if (ctx->start)\\r\\n{\\r\\nq=p=(unsigned char *)ctx->tmp;\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (*(q++) != '\\n') continue;\\r\\nif (ctx->tmp_nl)\\r\\n{\\r\\np=q;\\r\\nctx->tmp_nl=0;\\r\\ncontinue;\\r\\n}\\r\\nk=EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,\\r\\n&num,p,q-p);\\r\\nif ((k <= 0) && (num == 0) && (ctx->start))\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\nelse\\r\\n{\\r\\nif (p != (unsigned char *)\\r\\n&(ctx->tmp[0]))\\r\\n{\\r\\ni-=(p- (unsigned char *)\\r\\n&(ctx->tmp[0]));\\r\\nfor (x=0; x < i; x++)\\r\\nctx->tmp[x]=p[x];\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\n}\\r\\nctx->start=0;\\r\\nbreak;\\r\\n}\\r\\np=q;\\r\\n}\\r\\nif (j == i)\\r\\n{\\r\\nif (p == (unsigned char *)&(ctx->tmp[0]))\\r\\n{\\r\\nctx->tmp_nl=1;\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nelse if (p != q)\\r\\n{\\r\\nn=q-p;\\r\\nfor (ii=0; ii<n; ii++)\\r\\nctx->tmp[ii]=p[ii];\\r\\nctx->tmp_len=n;\\r\\n}\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\nctx->tmp_len=0;\\r\\n}\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nint z,jj;\\r\\njj=(i>>2)<<2;\\r\\nz=EVP_DecodeBlock((unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,jj);\\r\\nif (jj > 2)\\r\\n{\\r\\nif (ctx->tmp[jj-1] == '=')\\r\\n{\\r\\nz--;\\r\\nif (ctx->tmp[jj-2] == '=')\\r\\nz--;\\r\\n}\\r\\n}\\r\\nif (jj != i)\\r\\n{\\r\\nmemcpy((unsigned char *)ctx->tmp,\\r\\n(unsigned char *)&(ctx->tmp[jj]),i-jj);\\r\\nctx->tmp_len=i-jj;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nif (z > 0)\\r\\n{\\r\\nctx->buf_len=z;\\r\\ni=1;\\r\\n}\\r\\nelse\\r\\ni=z;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)ctx->tmp,i);\\r\\n}\\r\\nctx->cont=i;\\r\\nctx->buf_off=0;\\r\\nif (i < 0)\\r\\n{\\r\\nret_code=0;\\r\\nctx->buf_len=0;\\r\\nbreak;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni=ctx->buf_len;\\r\\nelse\\r\\ni=outl;\\r\\nmemcpy(out,ctx->buf,i);\\r\\nret+=i;\\r\\nctx->buf_off=i;\\r\\nif (ctx->buf_off == ctx->buf_len)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?ret_code:ret);\\r\\n}\\r\\nstatic int b64_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=inl,n,i;\\r\\nBIO_B64_CTX *ctx;\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->encode != B64_ENCODE)\\r\\n{\\r\\nctx->encode=B64_ENCODE;\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\nEVP_EncodeInit(&(ctx->base64));\\r\\n}\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx->buf_off=0;\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > B64_BLOCK_SIZE)?B64_BLOCK_SIZE:inl;\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nif (ctx->tmp_len > 0)\\r\\n{\\r\\nn=3-ctx->tmp_len;\\r\\nmemcpy(&(ctx->tmp[ctx->tmp_len]),in,n);\\r\\nctx->tmp_len+=n;\\r\\nn=ctx->tmp_len;\\r\\nif (n < 3)\\r\\nbreak;\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,n);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (n < 3)\\r\\n{\\r\\nmemcpy(&(ctx->tmp[0]),in,n);\\r\\nctx->tmp_len=n;\\r\\nbreak;\\r\\n}\\r\\nn-=n%3;\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)in,n);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nEVP_EncodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\n}\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?i:ret);\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long b64_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nctx=(BIO_B64_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->cont=1;\\r\\nctx->start=1;\\r\\nctx->encode=B64_NONE;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif ((ret == 0) && (ctx->base64.num != 0))\\r\\nret=1;\\r\\nelse if (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=b64_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)\\r\\n{\\r\\nif (ctx->tmp_len != 0)\\r\\n{\\r\\nctx->buf_len=EVP_EncodeBlock(\\r\\n(unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,\\r\\nctx->tmp_len);\\r\\nctx->buf_off=0;\\r\\nctx->tmp_len=0;\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\nelse if (ctx->base64.num != 0)\\r\\n{\\r\\nctx->buf_off=0;\\r\\nEVP_EncodeFinal(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_SET:\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_init_c", "target": 0, "func": "PKCS12 *PKCS12_init (int mode)\\r\\n{\\r\\nPKCS12 *pkcs12;\\r\\nif (!(pkcs12 = PKCS12_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(pkcs12->version = ASN1_INTEGER_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_set (pkcs12->version, 3);\\r\\nif (!(pkcs12->authsafes = PKCS7_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\npkcs12->authsafes->type = OBJ_nid2obj(mode);\\r\\nswitch (mode) {\\r\\ncase NID_pkcs7_data:\\r\\nif (!(pkcs12->authsafes->d.data =\\r\\nASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT,PKCS12_R_UNSUPPORTED_PKCS12_MODE);\\r\\nPKCS12_free(pkcs12);\\r\\nreturn NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn pkcs12;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5_enc_c", "target": 0, "func": "void RC5_32_cbc_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC5_32_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC5_32_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nRC5_32_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2c(tout0,out);\\r\\ntout1=tin[1]; l2c(tout1,out);\\r\\n}\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC5_32_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0;\\r\\nc2l(in,tin1); tin[1]=tin1;\\r\\nRC5_32_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid RC5_32_encrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a,b,*s;\\r\\ns=key->data;\\r\\na=d[0]+s[0];\\r\\nb=d[1]+s[1];\\r\\nE_RC5_32(a,b,s, 2);\\r\\nE_RC5_32(a,b,s, 4);\\r\\nE_RC5_32(a,b,s, 6);\\r\\nE_RC5_32(a,b,s, 8);\\r\\nE_RC5_32(a,b,s,10);\\r\\nE_RC5_32(a,b,s,12);\\r\\nE_RC5_32(a,b,s,14);\\r\\nE_RC5_32(a,b,s,16);\\r\\nif (key->rounds == 12)\\r\\n{\\r\\nE_RC5_32(a,b,s,18);\\r\\nE_RC5_32(a,b,s,20);\\r\\nE_RC5_32(a,b,s,22);\\r\\nE_RC5_32(a,b,s,24);\\r\\n}\\r\\nelse if (key->rounds == 16)\\r\\n{\\r\\nE_RC5_32(a,b,s,18);\\r\\nE_RC5_32(a,b,s,20);\\r\\nE_RC5_32(a,b,s,22);\\r\\nE_RC5_32(a,b,s,24);\\r\\nE_RC5_32(a,b,s,26);\\r\\nE_RC5_32(a,b,s,28);\\r\\nE_RC5_32(a,b,s,30);\\r\\nE_RC5_32(a,b,s,32);\\r\\n}\\r\\nd[0]=a;\\r\\nd[1]=b;\\r\\n}\\r\\nvoid RC5_32_decrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a,b,*s;\\r\\ns=key->data;\\r\\na=d[0];\\r\\nb=d[1];\\r\\nif (key->rounds == 16)\\r\\n{\\r\\nD_RC5_32(a,b,s,32);\\r\\nD_RC5_32(a,b,s,30);\\r\\nD_RC5_32(a,b,s,28);\\r\\nD_RC5_32(a,b,s,26);\\r\\nD_RC5_32(a,b,s,24);\\r\\nD_RC5_32(a,b,s,22);\\r\\nD_RC5_32(a,b,s,20);\\r\\nD_RC5_32(a,b,s,18);\\r\\n}\\r\\nelse if (key->rounds == 12)\\r\\n{\\r\\nD_RC5_32(a,b,s,24);\\r\\nD_RC5_32(a,b,s,22);\\r\\nD_RC5_32(a,b,s,20);\\r\\nD_RC5_32(a,b,s,18);\\r\\n}\\r\\nD_RC5_32(a,b,s,16);\\r\\nD_RC5_32(a,b,s,14);\\r\\nD_RC5_32(a,b,s,12);\\r\\nD_RC5_32(a,b,s,10);\\r\\nD_RC5_32(a,b,s, 8);\\r\\nD_RC5_32(a,b,s, 6);\\r\\nD_RC5_32(a,b,s, 4);\\r\\nD_RC5_32(a,b,s, 2);\\r\\nd[0]=a-s[0];\\r\\nd[1]=b-s[1];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_bytes_c", "target": 0, "func": "ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a, unsigned char **pp,\\r\\nlong length, int type)\\r\\n{\\r\\nASN1_STRING *ret=NULL;\\r\\nunsigned char *p,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80) goto err;\\r\\nif (tag >= 32)\\r\\n{\\r\\ni=ASN1_R_TAG_VALUE_TOO_HIGH;;\\r\\ngoto err;\\r\\n}\\r\\nif (!(tag2bit[tag] & type))\\r\\n{\\r\\ni=ASN1_R_WRONG_TYPE;\\r\\ngoto err;\\r\\n}\\r\\nif (tag == V_ASN1_BIT_STRING)\\r\\nreturn(d2i_ASN1_BIT_STRING(a,pp,length));\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\nif (len != 0)\\r\\n{\\r\\ns=(unsigned char *)Malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\ns[len]='\\0';\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->length=(int)len;\\r\\nret->data=s;\\r\\nret->type=tag;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_TYPE_BYTES,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_STRING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass)\\r\\n{\\r\\nint ret,r,constructed;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nif (tag == V_ASN1_BIT_STRING)\\r\\nreturn(i2d_ASN1_BIT_STRING(a,pp));\\r\\nret=a->length;\\r\\nr=ASN1_object_size(0,ret,tag);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nif ((tag == V_ASN1_SEQUENCE) || (tag == V_ASN1_SET))\\r\\nconstructed=1;\\r\\nelse\\r\\nconstructed=0;\\r\\nASN1_put_object(&p,constructed,ret,tag,xclass);\\r\\nmemcpy(p,a->data,a->length);\\r\\np+=a->length;\\r\\n*pp= p;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, unsigned char **pp, long length,\\r\\nint Ptag, int Pclass)\\r\\n{\\r\\nASN1_STRING *ret=NULL;\\r\\nunsigned char *p,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i=0;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != Ptag)\\r\\n{\\r\\ni=ASN1_R_WRONG_TAG;\\r\\ngoto err;\\r\\n}\\r\\nif (inf & V_ASN1_CONSTRUCTED)\\r\\n{\\r\\nASN1_CTX c;\\r\\nc.pp=pp;\\r\\nc.p=p;\\r\\nc.inf=inf;\\r\\nc.slen=len;\\r\\nc.tag=Ptag;\\r\\nc.xclass=Pclass;\\r\\nc.max=(length == 0)?0:(p+length);\\r\\nif (!asn1_collate_primative(ret,&c))\\r\\ngoto err;\\r\\nelse\\r\\n{\\r\\np=c.p;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (len != 0)\\r\\n{\\r\\nif ((ret->length < len) || (ret->data == NULL))\\r\\n{\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\ns=(unsigned char *)Malloc((int)len);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\ns=ret->data;\\r\\nmemcpy(s,p,(int)len);\\r\\np+=len;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns=NULL;\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\n}\\r\\nret->length=(int)len;\\r\\nret->data=s;\\r\\nret->type=Ptag;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_STRING_free(ret);\\r\\nASN1err(ASN1_F_D2I_ASN1_BYTES,i);\\r\\nreturn(NULL);\\r\\n}\\r\\nstatic int asn1_collate_primative(ASN1_STRING *a, ASN1_CTX *c)\\r\\n{\\r\\nASN1_STRING *os=NULL;\\r\\nBUF_MEM b;\\r\\nint num;\\r\\nb.length=0;\\r\\nb.max=0;\\r\\nb.data=NULL;\\r\\nif (a == NULL)\\r\\n{\\r\\nc->error=ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nnum=0;\\r\\nfor (;;)\\r\\n{\\r\\nif (c->inf & 1)\\r\\n{\\r\\nc->eos=ASN1_check_infinite_end(&c->p,\\r\\n(long)(c->max-c->p));\\r\\nif (c->eos) break;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (c->slen <= 0) break;\\r\\n}\\r\\nc->q=c->p;\\r\\nif (d2i_ASN1_bytes(&os,&c->p,c->max-c->p,c->tag,c->xclass)\\r\\n== NULL)\\r\\n{\\r\\nc->error=ERR_R_ASN1_LIB;\\r\\ngoto err;\\r\\n}\\r\\nif (!BUF_MEM_grow(&b,num+os->length))\\r\\n{\\r\\nc->error=ERR_R_BUF_LIB;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(&(b.data[num]),os->data,os->length);\\r\\nif (!(c->inf & 1))\\r\\nc->slen-=(c->p-c->q);\\r\\nnum+=os->length;\\r\\n}\\r\\nif (!asn1_Finish(c)) goto err;\\r\\na->length=num;\\r\\nif (a->data != NULL) Free(a->data);\\r\\na->data=(unsigned char *)b.data;\\r\\nif (os != NULL) ASN1_STRING_free(os);\\r\\nreturn(1);\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_COLLATE_PRIMITIVE,c->error);\\r\\nif (os != NULL) ASN1_STRING_free(os);\\r\\nif (b.data != NULL) Free(b.data);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_pbe_c", "target": 0, "func": "int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\\r\\n{\\r\\nEVP_PBE_CTL *pbetmp, pbelu;\\r\\nint i;\\r\\npbelu.pbe_nid = OBJ_obj2nid(pbe_obj);\\r\\nif (pbelu.pbe_nid != NID_undef) i = sk_find(pbe_algs, (char *)&pbelu);\\r\\nelse i = -1;\\r\\nif (i == -1) {\\r\\nchar obj_tmp[80];\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_UNKNOWN_PBE_ALGORITHM);\\r\\nif (!pbe_obj) strcpy (obj_tmp, \"NULL\");\\r\\nelse i2t_ASN1_OBJECT(obj_tmp, 80, pbe_obj);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\nreturn 0;\\r\\n}\\r\\nif (passlen == -1) passlen = strlen(pass);\\r\\npbetmp = (EVP_PBE_CTL *)sk_value (pbe_algs, i);\\r\\ni = (*pbetmp->keygen)(ctx, pass, passlen, param, pbetmp->cipher,\\r\\npbetmp->md, en_de);\\r\\nif (!i) {\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_KEYGEN_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pbe_cmp (EVP_PBE_CTL **pbe1, EVP_PBE_CTL **pbe2)\\r\\n{\\r\\nreturn ((*pbe1)->pbe_nid - (*pbe2)->pbe_nid);\\r\\n}\\r\\nint EVP_PBE_alg_add (int nid, EVP_CIPHER *cipher, EVP_MD *md,\\r\\nEVP_PBE_KEYGEN *keygen)\\r\\n{\\r\\nEVP_PBE_CTL *pbe_tmp;\\r\\nif (!pbe_algs) pbe_algs = sk_new (pbe_cmp);\\r\\nif (!(pbe_tmp = (EVP_PBE_CTL*) Malloc (sizeof(EVP_PBE_CTL)))) {\\r\\nEVPerr(EVP_F_EVP_PBE_ALG_ADD,ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npbe_tmp->pbe_nid = nid;\\r\\npbe_tmp->cipher = cipher;\\r\\npbe_tmp->md = md;\\r\\npbe_tmp->keygen = keygen;\\r\\nsk_push (pbe_algs, (char *)pbe_tmp);\\r\\nreturn 1;\\r\\n}\\r\\nvoid EVP_PBE_cleanup(void)\\r\\n{\\r\\nsk_pop_free(pbe_algs, FreeFunc);\\r\\npbe_algs = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_i_c", "target": 0, "func": "EVP_CIPHER *EVP_idea_ofb(void)\\r\\n{\\r\\nreturn(&i_ofb_cipher);\\r\\n}\\r\\nstatic void idea_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nidea_set_encrypt_key(key,&(ctx->c.idea_ks));\\r\\n}\\r\\nstatic void idea_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nidea_ofb64_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.idea_ks),&(ctx->iv[0]),\\r\\n&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s23_clnt_c", "target": 1, "func": "static SSL_METHOD *ssl23_get_client_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_client_method());\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_client_method());\\r\\nelse if (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv23_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv23_client_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv23_client_data,\\r\\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\\r\\nSSLv23_client_data.ssl_connect=ssl23_connect;\\r\\nSSLv23_client_data.get_ssl_method=ssl23_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv23_client_data);\\r\\n}\\r\\nint ssl23_connect(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long Time=time(NULL);\\r\\nvoid (*cb)()=NULL;\\r\\nint ret= -1;\\r\\nint new_state,state;\\r\\nRAND_seed(&Time,sizeof(Time));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch(s->state)\\r\\n{\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_CONNECT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\\r\\ncase SSL_ST_OK|SSL_ST_CONNECT:\\r\\nif (s->session != NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CONNECT,SSL_R_SSL23_DOING_SESSION_ID_REUSE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->server=0;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\ns->type=SSL_ST_CONNECT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s)) { ret= -1; goto end; }\\r\\nssl3_init_finished_mac(s);\\r\\ns->state=SSL23_ST_CW_CLNT_HELLO_A;\\r\\ns->ctx->stats.sess_connect++;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A:\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B:\\r\\ns->shutdown=0;\\r\\nret=ssl23_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL23_ST_CR_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A:\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B:\\r\\nret=ssl23_get_server_hello(s);\\r\\nif (ret >= 0) cb=NULL;\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL23_CONNECT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (s->debug) { (void)BIO_flush(s->wbio); }\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_CONNECT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nend:\\r\\ns->in_handshake--;\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_CONNECT_EXIT,ret);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl23_client_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,ch_len;\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL23_ST_CW_CLNT_HELLO_A)\\r\\n{\\r\\n#if 0\\r\\nif (!ssl_get_new_session(s,0))\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\n#endif\\r\\np=s->s3->client_random;\\r\\nRAND_bytes(p,SSL3_RANDOM_SIZE);\\r\\nd= &(buf[2]);\\r\\np=d+9;\\r\\n*(d++)=SSL2_MT_CLIENT_HELLO;\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\n*(d++)=TLS1_VERSION_MAJOR;\\r\\n*(d++)=TLS1_VERSION_MINOR;\\r\\ns->client_version=TLS1_VERSION;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\n*(d++)=SSL3_VERSION_MAJOR;\\r\\n*(d++)=SSL3_VERSION_MINOR;\\r\\ns->client_version=SSL3_VERSION;\\r\\n}\\r\\nelse if (!(s->options & SSL_OP_NO_SSLv2))\\r\\n{\\r\\n*(d++)=SSL2_VERSION_MAJOR;\\r\\n*(d++)=SSL2_VERSION_MINOR;\\r\\ns->client_version=SSL2_VERSION;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_PROTOCOLS_AVAILABLE);\\r\\nreturn(-1);\\r\\n}\\r\\ni=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),p);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\\r\\nreturn(-1);\\r\\n}\\r\\ns2n(i,d);\\r\\np+=i;\\r\\n#if 0\\r\\ns->session->session_id_length=0;\\r\\n#endif\\r\\ns2n(0,d);\\r\\nif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\\r\\nch_len=SSL2_CHALLENGE_LENGTH;\\r\\nelse\\r\\nch_len=SSL2_MAX_CHALLENGE_LENGTH;\\r\\nif (SSL3_RANDOM_SIZE < ch_len)\\r\\ni=SSL3_RANDOM_SIZE;\\r\\nelse\\r\\ni=ch_len;\\r\\ns2n(i,d);\\r\\nmemset(&(s->s3->client_random[0]),0,SSL3_RANDOM_SIZE);\\r\\nRAND_bytes(&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\\r\\nmemcpy(p,&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\\r\\np+=i;\\r\\ni= p- &(buf[2]);\\r\\nbuf[0]=((i>>8)&0xff)|0x80;\\r\\nbuf[1]=(i&0xff);\\r\\ns->state=SSL23_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=i+2;\\r\\ns->init_off=0;\\r\\nssl3_finish_mac(s,&(buf[2]),i);\\r\\n}\\r\\nreturn(ssl23_write_bytes(s));\\r\\n}\\r\\nstatic int ssl23_get_server_hello(SSL *s)\\r\\n{\\r\\nchar buf[8];\\r\\nunsigned char *p;\\r\\nint i,ch_len;\\r\\nint n;\\r\\nn=ssl23_read_bytes(s,7);\\r\\nif (n != 7) return(n);\\r\\np=s->packet;\\r\\nmemcpy(buf,p,n);\\r\\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&\\r\\n(p[5] == 0x00) && (p[6] == 0x02))\\r\\n{\\r\\nif (s->options & SSL_OP_NO_SSLv2)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\nif (s->s2 == NULL)\\r\\n{\\r\\nif (!ssl2_new(s))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nssl2_clear(s);\\r\\nif (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)\\r\\nch_len=SSL2_CHALLENGE_LENGTH;\\r\\nelse\\r\\nch_len=SSL2_MAX_CHALLENGE_LENGTH;\\r\\ni=(SSL3_RANDOM_SIZE < ch_len)\\r\\n?SSL3_RANDOM_SIZE:ch_len;\\r\\ns->s2->challenge_length=i;\\r\\nmemcpy(s->s2->challenge,\\r\\n&(s->s3->client_random[SSL3_RANDOM_SIZE-i]),i);\\r\\nif (s->s3 != NULL) ssl3_free(s);\\r\\nif (!BUF_MEM_grow(s->init_buf,\\r\\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->state=SSL2_ST_GET_SERVER_HELLO_A;\\r\\ns->s2->ssl2_rollback=1;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s2->rbuf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s2->rbuf_left=n;\\r\\ns->s2->rbuf_offs=0;\\r\\ns->s2->write_sequence=1;\\r\\ns->method=SSLv2_client_method();\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n((p[2] == SSL3_VERSION_MINOR) ||\\r\\n(p[2] == TLS1_VERSION_MINOR)) &&\\r\\n(p[5] == SSL3_MT_SERVER_HELLO))\\r\\n{\\r\\nif (!ssl_init_wbio_buffer(s,1)) goto err;\\r\\ns->state=SSL3_ST_CR_SRVR_HELLO_A;\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\ns->packet_length=n;\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nmemcpy(s->packet,buf,n);\\r\\ns->s3->rbuf.left=n;\\r\\ns->s3->rbuf.offset=0;\\r\\nif ((p[2] == SSL3_VERSION_MINOR) &&\\r\\n!(s->options & SSL_OP_NO_SSLv3))\\r\\n{\\r\\ns->version=SSL3_VERSION;\\r\\ns->method=SSLv3_client_method();\\r\\n}\\r\\nelse if ((p[2] == TLS1_VERSION_MINOR) &&\\r\\n!(s->options & SSL_OP_NO_TLSv1))\\r\\n{\\r\\ns->version=TLS1_VERSION;\\r\\ns->method=TLSv1_client_method();\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->handshake_func=s->method->ssl_connect;\\r\\n}\\r\\nelse if ((p[0] == SSL3_RT_ALERT) &&\\r\\n(p[1] == SSL3_VERSION_MAJOR) &&\\r\\n((p[2] == SSL3_VERSION_MINOR) ||\\r\\n(p[2] == TLS1_VERSION_MINOR)) &&\\r\\n(p[3] == 0) &&\\r\\n(p[4] == 2))\\r\\n{\\r\\nvoid (*cb)()=NULL;\\r\\nint j;\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\ni=p[5];\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(i<<8)|p[6];\\r\\ncb(s,SSL_CB_READ_ALERT,j);\\r\\n}\\r\\ns->rwstate=SSL_NOTHING;\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_AD_REASON_OFFSET+p[6]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_GET_SERVER_HELLO,SSL_R_UNKNOWN_PROTOCOL);\\r\\ngoto err;\\r\\n}\\r\\ns->init_num=0;\\r\\nif (!ssl_get_new_session(s,0))\\r\\ngoto err;\\r\\ns->first_packet=1;\\r\\nreturn(SSL_connect(s));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_cert_c", "target": 0, "func": "int SSL_get_ex_data_X509_STORE_CTX_idx(void)\\r\\n{\\r\\nstatic int ssl_x509_store_ctx_idx= -1;\\r\\nif (ssl_x509_store_ctx_idx < 0)\\r\\n{\\r\\nssl_x509_store_ctx_idx=X509_STORE_CTX_get_ex_new_index(\\r\\n0,\"SSL for verify callback\",NULL,NULL,NULL);\\r\\n}\\r\\nreturn(ssl_x509_store_ctx_idx);\\r\\n}\\r\\nCERT *ssl_cert_new(void)\\r\\n{\\r\\nCERT *ret;\\r\\nret=(CERT *)Malloc(sizeof(CERT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(CERT));\\r\\nret->key= &(ret->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\n}\\r\\nCERT *ssl_cert_dup(CERT *cert)\\r\\n{\\r\\nCERT *ret;\\r\\nint i;\\r\\nret = (CERT *)Malloc(sizeof(CERT));\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(CERT));\\r\\nret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];\\r\\nret->valid = cert->valid;\\r\\nret->mask = cert->mask;\\r\\nret->export_mask = cert->export_mask;\\r\\n#ifndef NO_RSA\\r\\nif (cert->rsa_tmp != NULL)\\r\\n{\\r\\nret->rsa_tmp = cert->rsa_tmp;\\r\\nCRYPTO_add(&ret->rsa_tmp->references, 1, CRYPTO_LOCK_RSA);\\r\\n}\\r\\nret->rsa_tmp_cb = cert->rsa_tmp_cb;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (cert->dh_tmp != NULL)\\r\\n{\\r\\nret->dh_tmp = DHparams_dup(cert->dh_tmp);\\r\\nif (ret->dh_tmp == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_NEW, ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nret->dh_tmp_cb = cert->dh_tmp_cb;\\r\\n#endif\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (cert->pkeys[i].x509 != NULL)\\r\\n{\\r\\nret->pkeys[i].x509 = cert->pkeys[i].x509;\\r\\nCRYPTO_add(&ret->pkeys[i].x509->references, 1,\\r\\nCRYPTO_LOCK_X509);\\r\\n}\\r\\nif (cert->pkeys[i].privatekey != NULL)\\r\\n{\\r\\nret->pkeys[i].privatekey = cert->pkeys[i].privatekey;\\r\\nCRYPTO_add(&ret->pkeys[i].privatekey->references, 1,\\r\\nCRYPTO_LOCK_EVP_PKEY);\\r\\nswitch(i)\\r\\n{\\r\\ncase SSL_PKEY_RSA_ENC:\\r\\ncase SSL_PKEY_RSA_SIGN:\\r\\nbreak;\\r\\ncase SSL_PKEY_DSA_SIGN:\\r\\nbreak;\\r\\ncase SSL_PKEY_DH_RSA:\\r\\ncase SSL_PKEY_DH_DSA:\\r\\nbreak;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, SSL_R_LIBRARY_BUG);\\r\\n}\\r\\n}\\r\\n}\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\nerr:\\r\\n#ifndef NO_RSA\\r\\nif (ret->rsa_tmp != NULL)\\r\\nRSA_free(ret->rsa_tmp);\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (ret->dh_tmp != NULL)\\r\\nDH_free(ret->dh_tmp);\\r\\n#endif\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (ret->pkeys[i].x509 != NULL)\\r\\nX509_free(ret->pkeys[i].x509);\\r\\nif (ret->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(ret->pkeys[i].privatekey);\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid ssl_cert_free(CERT *c)\\r\\n{\\r\\nint i;\\r\\nif(c == NULL)\\r\\nreturn;\\r\\ni=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"CERT\",c);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"ssl_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n#ifndef NO_RSA\\r\\nif (c->rsa_tmp) RSA_free(c->rsa_tmp);\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (c->dh_tmp) DH_free(c->dh_tmp);\\r\\n#endif\\r\\nfor (i=0; i<SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\nX509_free(c->pkeys[i].x509);\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\n#if 0\\r\\nif (c->pkeys[i].publickey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].publickey);\\r\\n#endif\\r\\n}\\r\\nFree(c);\\r\\n}\\r\\nint ssl_cert_inst(CERT **o)\\r\\n{\\r\\nif (o == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (*o == NULL)\\r\\n{\\r\\nif ((*o = ssl_cert_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nSESS_CERT *ssl_sess_cert_new(void)\\r\\n{\\r\\nSESS_CERT *ret;\\r\\nret = Malloc(sizeof *ret);\\r\\nif (ret == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESS_CERT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ret, 0 ,sizeof *ret);\\r\\nret->peer_key = &(ret->peer_pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nvoid ssl_sess_cert_free(SESS_CERT *sc)\\r\\n{\\r\\nint i;\\r\\nif (sc == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&sc->references, -1, CRYPTO_LOCK_SSL_SESS_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SESS_CERT\", sc);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"ssl_sess_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (sc->cert_chain != NULL)\\r\\nsk_X509_pop_free(sc->cert_chain, X509_free);\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++)\\r\\n{\\r\\nif (sc->peer_pkeys[i].x509 != NULL)\\r\\nX509_free(sc->peer_pkeys[i].x509);\\r\\n#if 0\\r\\nif (sc->peer_pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(sc->peer_pkeys[i].privatekey);\\r\\n#endif\\r\\n}\\r\\n#ifndef NO_RSA\\r\\nif (sc->peer_rsa_tmp != NULL)\\r\\nRSA_free(sc->peer_rsa_tmp);\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (sc->peer_dh_tmp != NULL)\\r\\nDH_free(sc->peer_dh_tmp);\\r\\n#endif\\r\\nFree(sc);\\r\\n}\\r\\nint ssl_set_peer_cert_type(SESS_CERT *sc,int type)\\r\\n{\\r\\nsc->peer_cert_type = type;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_add_client_CA(SSL *ssl,X509 *x)\\r\\n{\\r\\nreturn(add_client_CA(&(ssl->client_CA),x));\\r\\n}\\r\\nint SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x)\\r\\n{\\r\\nreturn(add_client_CA(&(ctx->client_CA),x));\\r\\n}\\r\\nstatic int name_cmp(X509_NAME **a,X509_NAME **b)\\r\\n{\\r\\nreturn(X509_NAME_cmp(*a,*b));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ciphers_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1,i;\\r\\nint verbose=0;\\r\\nchar **pp;\\r\\nconst char *p;\\r\\nint badops=0;\\r\\nSSL_CTX *ctx=NULL;\\r\\nSSL *ssl=NULL;\\r\\nchar *ciphers=NULL;\\r\\nSSL_METHOD *meth=NULL;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nchar buf[512];\\r\\nBIO *STDout=NULL;\\r\\n#if !defined(NO_SSL2) && !defined(NO_SSL3)\\r\\nmeth=SSLv23_server_method();\\r\\n#elif !defined(NO_SSL3)\\r\\nmeth=SSLv3_server_method();\\r\\n#elif !defined(NO_SSL2)\\r\\nmeth=SSLv2_server_method();\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err=BIO_new_fp(stderr,BIO_NOCLOSE);\\r\\nSTDout=BIO_new_fp(stdout,BIO_NOCLOSE);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-v\") == 0)\\r\\nverbose=1;\\r\\n#ifndef NO_SSL2\\r\\nelse if (strcmp(*argv,\"-ssl2\") == 0)\\r\\nmeth=SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef NO_SSL3\\r\\nelse if (strcmp(*argv,\"-ssl3\") == 0)\\r\\nmeth=SSLv3_client_method();\\r\\n#endif\\r\\nelse if ((strncmp(*argv,\"-h\",2) == 0) ||\\r\\n(strcmp(*argv,\"-?\") == 0))\\r\\n{\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nciphers= *argv;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nfor (pp=ciphers_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,*pp);\\r\\ngoto end;\\r\\n}\\r\\nSSLeay_add_ssl_algorithms();\\r\\nctx=SSL_CTX_new(meth);\\r\\nif (ctx == NULL) goto err;\\r\\nif (ciphers != NULL)\\r\\nSSL_CTX_set_cipher_list(ctx,ciphers);\\r\\nssl=SSL_new(ctx);\\r\\nif (ssl == NULL) goto err;\\r\\nif (!verbose)\\r\\n{\\r\\nfor (i=0; ; i++)\\r\\n{\\r\\np=SSL_get_cipher_list(ssl,i);\\r\\nif (p == NULL) break;\\r\\nif (i != 0) BIO_printf(STDout,\":\");\\r\\nBIO_printf(STDout,\"%s\",p);\\r\\n}\\r\\nBIO_printf(STDout,\"\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nsk=SSL_get_ciphers(ssl);\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nBIO_puts(STDout,SSL_CIPHER_description(\\r\\nsk_SSL_CIPHER_value(sk,i),\\r\\nbuf,512));\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nSSL_load_error_strings();\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nend:\\r\\nif (ctx != NULL) SSL_CTX_free(ctx);\\r\\nif (ssl != NULL) SSL_free(ssl);\\r\\nif (STDout != NULL) BIO_free(STDout);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_n_pkey_c", "target": 0, "func": "int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)())\\r\\n{\\r\\nint i,j,l[6];\\r\\nNETSCAPE_PKEY *pkey;\\r\\nunsigned char buf[256],*zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\nX509_ALGOR *alg=NULL;\\r\\nASN1_OCTET_STRING os,os2;\\r\\nM_ASN1_I2D_vars(a);\\r\\nif (a == NULL) return(0);\\r\\n#ifdef WIN32\\r\\nr=r;\\r\\n#endif\\r\\nos.data=os2.data=NULL;\\r\\nif ((pkey=NETSCAPE_PKEY_new()) == NULL) goto err;\\r\\nif (!ASN1_INTEGER_set(pkey->version,0)) goto err;\\r\\nif (pkey->algor->algorithm != NULL)\\r\\nASN1_OBJECT_free(pkey->algor->algorithm);\\r\\npkey->algor->algorithm=OBJ_nid2obj(NID_rsaEncryption);\\r\\nif ((pkey->algor->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\npkey->algor->parameter->type=V_ASN1_NULL;\\r\\nl[0]=i2d_RSAPrivateKey(a,NULL);\\r\\npkey->private_key->length=l[0];\\r\\nos2.length=i2d_NETSCAPE_PKEY(pkey,NULL);\\r\\nl[1]=i2d_ASN1_OCTET_STRING(&os2,NULL);\\r\\nif ((alg=X509_ALGOR_new()) == NULL) goto err;\\r\\nif (alg->algorithm != NULL)\\r\\nASN1_OBJECT_free(alg->algorithm);\\r\\nalg->algorithm=OBJ_nid2obj(NID_rc4);\\r\\nif ((alg->parameter=ASN1_TYPE_new()) == NULL) goto err;\\r\\nalg->parameter->type=V_ASN1_NULL;\\r\\nl[2]=i2d_X509_ALGOR(alg,NULL);\\r\\nl[3]=ASN1_object_size(1,l[2]+l[1],V_ASN1_SEQUENCE);\\r\\n#ifndef CONST_STRICT\\r\\nos.data=(unsigned char *)\"private-key\";\\r\\n#endif\\r\\nos.length=11;\\r\\nl[4]=i2d_ASN1_OCTET_STRING(&os,NULL);\\r\\nl[5]=ASN1_object_size(1,l[4]+l[3],V_ASN1_SEQUENCE);\\r\\nif (pp == NULL)\\r\\n{\\r\\nif (pkey != NULL) NETSCAPE_PKEY_free(pkey);\\r\\nif (alg != NULL) X509_ALGOR_free(alg);\\r\\nreturn(l[5]);\\r\\n}\\r\\nif (pkey->private_key->data != NULL)\\r\\nFree((char *)pkey->private_key->data);\\r\\nif ((pkey->private_key->data=(unsigned char *)Malloc(l[0])) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nzz=pkey->private_key->data;\\r\\ni2d_RSAPrivateKey(a,&zz);\\r\\nif ((os2.data=(unsigned char *)Malloc(os2.length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_NETSCAPE_RSA,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nzz=os2.data;\\r\\ni2d_NETSCAPE_PKEY(pkey,&zz);\\r\\nif (cb == NULL)\\r\\ncb=EVP_read_pw_string;\\r\\ni=cb(buf,256,\"Enter Private Key password:\",1);\\r\\nif (i != 0)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_NETSCAPE_RSA,ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\nEVP_BytesToKey(EVP_rc4(),EVP_md5(),NULL,buf,\\r\\nstrlen((char *)buf),1,key,NULL);\\r\\nmemset(buf,0,256);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_EncryptInit(&ctx,EVP_rc4(),key,NULL);\\r\\nEVP_EncryptUpdate(&ctx,os2.data,&i,os2.data,os2.length);\\r\\nEVP_EncryptFinal(&ctx,&(os2.data[i]),&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,l[4]+l[3],V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_OCTET_STRING(&os,&p);\\r\\nASN1_put_object(&p,1,l[2]+l[1],V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_X509_ALGOR(alg,&p);\\r\\ni2d_ASN1_OCTET_STRING(&os2,&p);\\r\\nret=l[5];\\r\\nerr:\\r\\nif (os2.data != NULL) Free(os2.data);\\r\\nif (alg != NULL) X509_ALGOR_free(alg);\\r\\nif (pkey != NULL) NETSCAPE_PKEY_free(pkey);\\r\\nr=r;\\r\\nreturn(ret);\\r\\n}\\r\\nRSA *d2i_Netscape_RSA(RSA **a, unsigned char **pp, long length, int (*cb)())\\r\\n{\\r\\nRSA *ret=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nASN1_CTX c;\\r\\nc.pp=pp;\\r\\nc.error=ASN1_R_DECODING_ERROR;\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(os,d2i_ASN1_OCTET_STRING);\\r\\nif ((os->length != 11) || (strncmp(\"private-key\",\\r\\n(char *)os->data,os->length) != 0))\\r\\n{\\r\\nASN1err(ASN1_F_D2I_NETSCAPE_RSA,ASN1_R_PRIVATE_KEY_HEADER_MISSING);\\r\\nASN1_BIT_STRING_free(os);\\r\\ngoto err;\\r\\n}\\r\\nASN1_BIT_STRING_free(os);\\r\\nc.q=c.p;\\r\\nif ((ret=d2i_Netscape_RSA_2(a,&c.p,c.slen,cb)) == NULL) goto err;\\r\\nc.slen-=(c.p-c.q);\\r\\nM_ASN1_D2I_Finish(a,RSA_free,ASN1_F_D2I_NETSCAPE_RSA);\\r\\n}\\r\\nRSA *d2i_Netscape_RSA_2(RSA **a, unsigned char **pp, long length,\\r\\nint (*cb)())\\r\\n{\\r\\nNETSCAPE_PKEY *pkey=NULL;\\r\\nRSA *ret=NULL;\\r\\nint i,j;\\r\\nunsigned char buf[256],*zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\nX509_ALGOR *alg=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\nASN1_CTX c;\\r\\nc.error=ERR_R_NESTED_ASN1_ERROR;\\r\\nc.pp=pp;\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(alg,d2i_X509_ALGOR);\\r\\nif (OBJ_obj2nid(alg->algorithm) != NID_rc4)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_NETSCAPE_RSA_2,ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nM_ASN1_D2I_get(os,d2i_ASN1_OCTET_STRING);\\r\\nif (cb == NULL)\\r\\ncb=EVP_read_pw_string;\\r\\ni=cb(buf,256,\"Enter Private Key password:\",0);\\r\\nif (i != 0)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_NETSCAPE_RSA_2,ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\nEVP_BytesToKey(EVP_rc4(),EVP_md5(),NULL,buf,\\r\\nstrlen((char *)buf),1,key,NULL);\\r\\nmemset(buf,0,256);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nEVP_DecryptInit(&ctx,EVP_rc4(),key,NULL);\\r\\nEVP_DecryptUpdate(&ctx,os->data,&i,os->data,os->length);\\r\\nEVP_DecryptFinal(&ctx,&(os->data[i]),&j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nos->length=i+j;\\r\\nzz=os->data;\\r\\nif ((pkey=d2i_NETSCAPE_PKEY(NULL,&zz,os->length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_NETSCAPE_RSA_2,ASN1_R_UNABLE_TO_DECODE_RSA_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nzz=pkey->private_key->data;\\r\\nif ((ret=d2i_RSAPrivateKey(a,&zz,pkey->private_key->length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_NETSCAPE_RSA_2,ASN1_R_UNABLE_TO_DECODE_RSA_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!asn1_Finish(&c)) goto err;\\r\\n*pp=c.p;\\r\\nerr:\\r\\nif (pkey != NULL) NETSCAPE_PKEY_free(pkey);\\r\\nif (os != NULL) ASN1_BIT_STRING_free(os);\\r\\nif (alg != NULL) X509_ALGOR_free(alg);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int i2d_NETSCAPE_PKEY(NETSCAPE_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->private_key, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->private_key, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nstatic NETSCAPE_PKEY *d2i_NETSCAPE_PKEY(NETSCAPE_PKEY **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,NETSCAPE_PKEY *,NETSCAPE_PKEY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->private_key,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,NETSCAPE_PKEY_free,ASN1_F_D2I_NETSCAPE_PKEY);\\r\\n}\\r\\nstatic NETSCAPE_PKEY *NETSCAPE_PKEY_new(void)\\r\\n{\\r\\nNETSCAPE_PKEY *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,NETSCAPE_PKEY);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->private_key,ASN1_OCTET_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_NETSCAPE_PKEY_NEW);\\r\\n}\\r\\nstatic void NETSCAPE_PKEY_free(NETSCAPE_PKEY *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nX509_ALGOR_free(a->algor);\\r\\nASN1_OCTET_STRING_free(a->private_key);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pcbc_enc_c", "target": 0, "func": "void des_pcbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, des_key_schedule schedule, des_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG sin0,sin1,xor0,xor1,tout0,tout1;\\r\\nDES_LONG tin[2];\\r\\nconst unsigned char *in;\\r\\nunsigned char *out,*iv;\\r\\nin=input;\\r\\nout=output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (; length>0; length-=8)\\r\\n{\\r\\nif (length >= 8)\\r\\n{\\r\\nc2l(in,sin0);\\r\\nc2l(in,sin1);\\r\\n}\\r\\nelse\\r\\nc2ln(in,sin0,sin1,length);\\r\\ntin[0]=sin0^xor0;\\r\\ntin[1]=sin1^xor1;\\r\\ndes_encrypt((DES_LONG *)tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nxor0=sin0^tout0;\\r\\nxor1=sin1^tout1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0); c2l(iv,xor1);\\r\\nfor (; length>0; length-=8)\\r\\n{\\r\\nc2l(in,sin0);\\r\\nc2l(in,sin1);\\r\\ntin[0]=sin0;\\r\\ntin[1]=sin1;\\r\\ndes_encrypt((DES_LONG *)tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nif (length >= 8)\\r\\n{\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\n}\\r\\nelse\\r\\nl2cn(tout0,tout1,out,length);\\r\\nxor0=tout0^sin0;\\r\\nxor1=tout1^sin1;\\r\\n}\\r\\n}\\r\\ntin[0]=tin[1]=0;\\r\\nsin0=sin1=xor0=xor1=tout0=tout1=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_genrsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1;\\r\\nchar buffer[200];\\r\\nRSA *rsa=NULL;\\r\\nint i,num=DEFBITS;\\r\\nlong rnum=0,l;\\r\\nEVP_CIPHER *enc=NULL;\\r\\nunsigned long f4=RSA_F4;\\r\\nchar *outfile=NULL;\\r\\nchar *inrand=NULL,*randfile;\\r\\nBIO *out=NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nif ((out=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to creat BIO for output\\n\");\\r\\ngoto err;\\r\\n}\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-3\") == 0)\\r\\nf4=3;\\r\\nelse if (strcmp(*argv,\"-F4\") == 0)\\r\\nf4=RSA_F4;\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\n#ifndef NO_DES\\r\\nelse if (strcmp(*argv,\"-des\") == 0)\\r\\nenc=EVP_des_cbc();\\r\\nelse if (strcmp(*argv,\"-des3\") == 0)\\r\\nenc=EVP_des_ede3_cbc();\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nelse if (strcmp(*argv,\"-idea\") == 0)\\r\\nenc=EVP_idea_cbc();\\r\\n#endif\\r\\nelse\\r\\nbreak;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: genrsa [args] [numbits]\\n\");\\r\\nBIO_printf(bio_err,\" -des - encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\" -des3 - encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea - encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -out file - output the key to 'file\\n\");\\r\\nBIO_printf(bio_err,\" -f4 - use F4 (0x10001) for the E value\\n\");\\r\\nBIO_printf(bio_err,\" -3 - use 3 for the E value\\n\");\\r\\nBIO_printf(bio_err,\" -rand file:file:...\\n\");\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifdef WINDOWS\\r\\nBIO_printf(bio_err,\"Loading 'screen' into random state -\");\\r\\nBIO_flush(bio_err);\\r\\nRAND_screen();\\r\\nBIO_printf(bio_err,\" done\\n\");\\r\\n#endif\\r\\nrandfile=RAND_file_name(buffer,200);\\r\\nif ((randfile == NULL) ||\\r\\n!(rnum=(long)RAND_load_file(randfile,1024L*1024L)))\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load 'random state'\\n\");\\r\\n}\\r\\nif (inrand == NULL)\\r\\n{\\r\\nif (rnum == 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nrnum+=gr_load_rand(inrand);\\r\\n}\\r\\nif (rnum != 0)\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",rnum);\\r\\nBIO_printf(bio_err,\"Generating RSA private key, %d bit long modulus\\n\",\\r\\nnum);\\r\\nrsa=RSA_generate_key(num,f4,genrsa_cb,bio_err);\\r\\nif (randfile == NULL)\\r\\nBIO_printf(bio_err,\"unable to write 'random state'\\n\");\\r\\nelse\\r\\nRAND_write_file(randfile);\\r\\nif (rsa == NULL) goto err;\\r\\nl=0L;\\r\\nfor (i=0; i<rsa->e->top; i++)\\r\\n{\\r\\n#ifndef SIXTY_FOUR_BIT\\r\\nl<<=BN_BITS4;\\r\\nl<<=BN_BITS4;\\r\\n#endif\\r\\nl+=rsa->e->d[i];\\r\\n}\\r\\nBIO_printf(bio_err,\"e is %ld (0x%lX)\\n\",l,l);\\r\\nif (!PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,0,NULL,NULL))\\r\\ngoto err;\\r\\nret=0;\\r\\nerr:\\r\\nif (rsa != NULL) RSA_free(rsa);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void MS_CALLBACK genrsa_cb(int p, int n, void *arg)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write((BIO *)arg,&c,1);\\r\\n(void)BIO_flush((BIO *)arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\n}\\r\\nstatic long gr_load_rand(char *name)\\r\\n{\\r\\nchar *p,*n;\\r\\nint last;\\r\\nlong tot=0;\\r\\nfor (;;)\\r\\n{\\r\\nlast=0;\\r\\nfor (p=name; ((*p != '\\0') && (*p != LIST_SEPARATOR_CHAR)); p++);\\r\\nif (*p == '\\0') last=1;\\r\\n*p='\\0';\\r\\nn=name;\\r\\nname=p+1;\\r\\nif (*n == '\\0') break;\\r\\ntot+=RAND_load_file(n,1024L*1024L);\\r\\nif (last) break;\\r\\n}\\r\\nreturn(tot);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_obj_dat_c", "target": 1, "func": "static int sn_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)\\r\\n{ return(strcmp((*ap)->sn,(*bp)->sn)); }\\r\\nstatic int ln_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)\\r\\n{ return(strcmp((*ap)->ln,(*bp)->ln)); }\\r\\nstatic unsigned long add_hash(ADDED_OBJ *ca)\\r\\n{\\r\\nASN1_OBJECT *a;\\r\\nint i;\\r\\nunsigned long ret=0;\\r\\nunsigned char *p;\\r\\na=ca->obj;\\r\\nswitch (ca->type)\\r\\n{\\r\\ncase ADDED_DATA:\\r\\nret=a->length<<20L;\\r\\np=(unsigned char *)a->data;\\r\\nfor (i=0; i<a->length; i++)\\r\\nret^=p[i]<<((i*3)%24);\\r\\nbreak;\\r\\ncase ADDED_SNAME:\\r\\nret=lh_strhash(a->sn);\\r\\nbreak;\\r\\ncase ADDED_LNAME:\\r\\nret=lh_strhash(a->ln);\\r\\nbreak;\\r\\ncase ADDED_NID:\\r\\nret=a->nid;\\r\\nbreak;\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\nret&=0x3fffffffL;\\r\\nret|=ca->type<<30L;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int add_cmp(ADDED_OBJ *ca, ADDED_OBJ *cb)\\r\\n{\\r\\nASN1_OBJECT *a,*b;\\r\\nint i;\\r\\ni=ca->type-cb->type;\\r\\nif (i) return(i);\\r\\na=ca->obj;\\r\\nb=cb->obj;\\r\\nswitch (ca->type)\\r\\n{\\r\\ncase ADDED_DATA:\\r\\ni=(a->length - b->length);\\r\\nif (i) return(i);\\r\\nreturn(memcmp(a->data,b->data,a->length));\\r\\ncase ADDED_SNAME:\\r\\nif (a->sn == NULL) return(-1);\\r\\nelse if (b->sn == NULL) return(1);\\r\\nelse return(strcmp(a->sn,b->sn));\\r\\ncase ADDED_LNAME:\\r\\nif (a->ln == NULL) return(-1);\\r\\nelse if (b->ln == NULL) return(1);\\r\\nelse return(strcmp(a->ln,b->ln));\\r\\ncase ADDED_NID:\\r\\nreturn(a->nid-b->nid);\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int init_added(void)\\r\\n{\\r\\nif (added != NULL) return(1);\\r\\nadded=lh_new(add_hash,add_cmp);\\r\\nreturn(added != NULL);\\r\\n}\\r\\nstatic void cleanup1(ADDED_OBJ *a)\\r\\n{\\r\\na->obj->nid=0;\\r\\na->obj->flags|=ASN1_OBJECT_FLAG_DYNAMIC|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\n}\\r\\nstatic void cleanup2(ADDED_OBJ *a)\\r\\n{ a->obj->nid++; }\\r\\nstatic void cleanup3(ADDED_OBJ *a)\\r\\n{\\r\\nif (--a->obj->nid == 0)\\r\\nASN1_OBJECT_free(a->obj);\\r\\nFree(a);\\r\\n}\\r\\nvoid OBJ_cleanup(void)\\r\\n{\\r\\nif (added == NULL) return;\\r\\nadded->down_load=0;\\r\\nlh_doall(added,cleanup1);\\r\\nlh_doall(added,cleanup2);\\r\\nlh_doall(added,cleanup3);\\r\\nlh_free(added);\\r\\nadded=NULL;\\r\\n}\\r\\nint OBJ_new_nid(int num)\\r\\n{\\r\\nint i;\\r\\ni=new_nid;\\r\\nnew_nid+=num;\\r\\nreturn(i);\\r\\n}\\r\\nint OBJ_add_object(ASN1_OBJECT *obj)\\r\\n{\\r\\nASN1_OBJECT *o;\\r\\nADDED_OBJ *ao[4],*aop;\\r\\nint i;\\r\\nif (added == NULL)\\r\\nif (!init_added()) return(0);\\r\\nif ((o=OBJ_dup(obj)) == NULL) goto err;\\r\\nao[ADDED_DATA]=NULL;\\r\\nao[ADDED_SNAME]=NULL;\\r\\nao[ADDED_LNAME]=NULL;\\r\\nao[ADDED_NID]=NULL;\\r\\nao[ADDED_NID]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));\\r\\nif ((o->length != 0) && (obj->data != NULL))\\r\\nao[ADDED_DATA]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));\\r\\nif (o->sn != NULL)\\r\\nao[ADDED_SNAME]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));\\r\\nif (o->ln != NULL)\\r\\nao[ADDED_LNAME]=(ADDED_OBJ *)Malloc(sizeof(ADDED_OBJ));\\r\\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\\r\\n{\\r\\nif (ao[i] != NULL)\\r\\n{\\r\\nao[i]->type=i;\\r\\nao[i]->obj=o;\\r\\naop=(ADDED_OBJ *)lh_insert(added,(char *)ao[i]);\\r\\nif (aop != NULL)\\r\\nFree(aop);\\r\\n}\\r\\n}\\r\\no->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn(o->nid);\\r\\nerr:\\r\\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\\r\\nif (ao[i] != NULL) Free(ao[i]);\\r\\nif (o != NULL) Free(o);\\r\\nreturn(NID_undef);\\r\\n}\\r\\nASN1_OBJECT *OBJ_nid2obj(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn((ASN1_OBJECT *)&(nid_objs[n]));\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2sn(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(nid_objs[n].sn);\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj->sn);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2ln(int n)\\r\\n{\\r\\nADDED_OBJ ad,*adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID))\\r\\n{\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(nid_objs[n].ln);\\r\\n}\\r\\nelse if (added == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nad.type=ADDED_NID;\\r\\nad.obj= &ob;\\r\\nob.nid=n;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL)\\r\\nreturn(adp->obj->ln);\\r\\nelse\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nint OBJ_obj2nid(ASN1_OBJECT *a)\\r\\n{\\r\\nASN1_OBJECT **op;\\r\\nADDED_OBJ ad,*adp;\\r\\nif (a == NULL)\\r\\nreturn(NID_undef);\\r\\nif (a->nid != 0)\\r\\nreturn(a->nid);\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_DATA;\\r\\nad.obj=a;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((char *)&a,(char *)obj_objs,NUM_OBJ,\\r\\nsizeof(ASN1_OBJECT *),(int (*)())obj_cmp);\\r\\nif (op == NULL)\\r\\nreturn(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\\r\\n{\\r\\nint nid = NID_undef;\\r\\nASN1_OBJECT *op=NULL;\\r\\nunsigned char *buf,*p;\\r\\nint i, j;\\r\\nif(!no_name) {\\r\\nif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\\r\\n((nid = OBJ_ln2nid(s)) != NID_undef) )\\r\\nreturn OBJ_nid2obj(nid);\\r\\n}\\r\\ni=a2d_ASN1_OBJECT(NULL,0,s,-1);\\r\\nif (i <= 0) {\\r\\nERR_get_error();\\r\\nreturn NULL;\\r\\n}\\r\\nj = ASN1_object_size(0,i,V_ASN1_OBJECT);\\r\\nif((buf=(unsigned char *)Malloc(j)) == NULL) return NULL;\\r\\np = buf;\\r\\nASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\\r\\na2d_ASN1_OBJECT(p,i,s,-1);\\r\\np=buf;\\r\\nop=d2i_ASN1_OBJECT(NULL,&p,i);\\r\\nFree(buf);\\r\\nreturn op;\\r\\n}\\r\\nint OBJ_obj2txt(char *buf, int buf_len, ASN1_OBJECT *a, int no_name)\\r\\n{\\r\\nint i,idx=0,n=0,len,nid;\\r\\nunsigned long l;\\r\\nunsigned char *p;\\r\\nconst char *s;\\r\\nchar tbuf[32];\\r\\nif (buf_len <= 0) return(0);\\r\\nif ((a == NULL) || (a->data == NULL)) {\\r\\nbuf[0]='\\0';\\r\\nreturn(0);\\r\\n}\\r\\nnid=OBJ_obj2nid(a);\\r\\nif ((nid == NID_undef) || no_name) {\\r\\nlen=a->length;\\r\\np=a->data;\\r\\nidx=0;\\r\\nl=0;\\r\\nwhile (idx < a->length) {\\r\\nl|=(p[idx]&0x7f);\\r\\nif (!(p[idx] & 0x80)) break;\\r\\nl<<=7L;\\r\\nidx++;\\r\\n}\\r\\nidx++;\\r\\ni=(int)(l/40);\\r\\nif (i > 2) i=2;\\r\\nl-=(long)(i*40);\\r\\nsprintf(tbuf,\"%d.%lu\",i,l);\\r\\ni=strlen(tbuf);\\r\\nstrncpy(buf,tbuf,buf_len);\\r\\nbuf_len-=i;\\r\\nbuf+=i;\\r\\nn+=i;\\r\\nl=0;\\r\\nfor (; idx<len; idx++) {\\r\\nl|=p[idx]&0x7f;\\r\\nif (!(p[idx] & 0x80)) {\\r\\nsprintf(tbuf,\".%lu\",l);\\r\\ni=strlen(tbuf);\\r\\nif (buf_len > 0)\\r\\nstrncpy(buf,tbuf,buf_len);\\r\\nbuf_len-=i;\\r\\nbuf+=i;\\r\\nn+=i;\\r\\nl=0;\\r\\n}\\r\\nl<<=7L;\\r\\n}\\r\\n} else {\\r\\ns=OBJ_nid2ln(nid);\\r\\nif (s == NULL)\\r\\ns=OBJ_nid2sn(nid);\\r\\nstrncpy(buf,s,buf_len);\\r\\nn=strlen(s);\\r\\n}\\r\\nbuf[buf_len-1]='\\0';\\r\\nreturn(n);\\r\\n}\\r\\nint OBJ_txt2nid(char *s)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint nid;\\r\\nobj = OBJ_txt2obj(s, 0);\\r\\nnid = OBJ_obj2nid(obj);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nid;\\r\\n}\\r\\nint OBJ_ln2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o,*oo= &o,**op;\\r\\nADDED_OBJ ad,*adp;\\r\\no.ln=s;\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_LNAME;\\r\\nad.obj= &o;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)ln_objs,NUM_LN,\\r\\nsizeof(ASN1_OBJECT *),(int (*)())ln_cmp);\\r\\nif (op == NULL) return(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nint OBJ_sn2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o,*oo= &o,**op;\\r\\nADDED_OBJ ad,*adp;\\r\\no.sn=s;\\r\\nif (added != NULL)\\r\\n{\\r\\nad.type=ADDED_SNAME;\\r\\nad.obj= &o;\\r\\nadp=(ADDED_OBJ *)lh_retrieve(added,(char *)&ad);\\r\\nif (adp != NULL) return (adp->obj->nid);\\r\\n}\\r\\nop=(ASN1_OBJECT **)OBJ_bsearch((char *)&oo,(char *)sn_objs,NUM_SN,\\r\\nsizeof(ASN1_OBJECT *),(int (*)())sn_cmp);\\r\\nif (op == NULL) return(NID_undef);\\r\\nreturn((*op)->nid);\\r\\n}\\r\\nstatic int obj_cmp(ASN1_OBJECT **ap, ASN1_OBJECT **bp)\\r\\n{\\r\\nint j;\\r\\nASN1_OBJECT *a= *ap;\\r\\nASN1_OBJECT *b= *bp;\\r\\nj=(a->length - b->length);\\r\\nif (j) return(j);\\r\\nreturn(memcmp(a->data,b->data,a->length));\\r\\n}\\r\\nchar *OBJ_bsearch(char *key, char *base, int num, int size, int (*cmp)())\\r\\n{\\r\\nint l,h,i,c;\\r\\nchar *p;\\r\\nif (num == 0) return(NULL);\\r\\nl=0;\\r\\nh=num;\\r\\nwhile (l < h)\\r\\n{\\r\\ni=(l+h)/2;\\r\\np= &(base[i*size]);\\r\\nc=(*cmp)(key,p);\\r\\nif (c < 0)\\r\\nh=i;\\r\\nelse if (c > 0)\\r\\nl=i+1;\\r\\nelse\\r\\nreturn(p);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nfor (i=0; i<num; ++i) {\\r\\np= &(base[i*size]);\\r\\nif ((*cmp)(key,p) == 0)\\r\\nreturn p;\\r\\n}\\r\\n#endif\\r\\nreturn(NULL);\\r\\n}\\r\\nint OBJ_create_objects(BIO *in)\\r\\n{\\r\\nMS_STATIC char buf[512];\\r\\nint i,num=0;\\r\\nchar *o,*s,*l=NULL;\\r\\nfor (;;)\\r\\n{\\r\\ns=o=NULL;\\r\\ni=BIO_gets(in,buf,512);\\r\\nif (i <= 0) return(num);\\r\\nbuf[i-1]='\\0';\\r\\nif (!isalnum((unsigned char)buf[0])) return(num);\\r\\no=s=buf;\\r\\nwhile (isdigit((unsigned char)*s) || (*s == '.'))\\r\\ns++;\\r\\nif (*s != '\\0')\\r\\n{\\r\\n*(s++)='\\0';\\r\\nwhile (isspace((unsigned char)*s))\\r\\ns++;\\r\\nif (*s == '\\0')\\r\\ns=NULL;\\r\\nelse\\r\\n{\\r\\nl=s;\\r\\nwhile ((*l != '\\0') && !isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l != '\\0')\\r\\n{\\r\\n*(l++)='\\0';\\r\\nwhile (isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l == '\\0') l=NULL;\\r\\n}\\r\\nelse\\r\\nl=NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\ns=NULL;\\r\\nif ((o == NULL) || (*o == '\\0')) return(num);\\r\\nif (!OBJ_create(o,s,l)) return(num);\\r\\nnum++;\\r\\n}\\r\\n}\\r\\nint OBJ_create(char *oid, char *sn, char *ln)\\r\\n{\\r\\nint ok=0;\\r\\nASN1_OBJECT *op=NULL;\\r\\nunsigned char *buf;\\r\\nint i;\\r\\ni=a2d_ASN1_OBJECT(NULL,0,oid,-1);\\r\\nif (i <= 0) return(0);\\r\\nif ((buf=(unsigned char *)Malloc(i)) == NULL)\\r\\n{\\r\\nOBJerr(OBJ_F_OBJ_CREATE,OBJ_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\ni=a2d_ASN1_OBJECT(buf,i,oid,-1);\\r\\nop=(ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1),buf,i,sn,ln);\\r\\nif (op == NULL)\\r\\ngoto err;\\r\\nok=OBJ_add_object(op);\\r\\nerr:\\r\\nASN1_OBJECT_free(op);\\r\\nFree((char *)buf);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_div_c", "target": 1, "func": "int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint norm_shift,i,j,loop;\\r\\nBIGNUM *tmp,wnum,*snum,*sdiv,*res;\\r\\nBN_ULONG *resp,*wnump;\\r\\nBN_ULONG d0,d1;\\r\\nint num_n,div_n;\\r\\nbn_check_top(num);\\r\\nbn_check_top(divisor);\\r\\nif (BN_is_zero(divisor))\\r\\n{\\r\\nBNerr(BN_F_BN_DIV,BN_R_DIV_BY_ZERO);\\r\\nreturn(0);\\r\\n}\\r\\nif (BN_ucmp(num,divisor) < 0)\\r\\n{\\r\\nif (rm != NULL)\\r\\n{ if (BN_copy(rm,num) == NULL) return(0); }\\r\\nif (dv != NULL) BN_zero(dv);\\r\\nreturn(1);\\r\\n}\\r\\ntmp= &(ctx->bn[ctx->tos]);\\r\\ntmp->neg=0;\\r\\nsnum= &(ctx->bn[ctx->tos+1]);\\r\\nsdiv= &(ctx->bn[ctx->tos+2]);\\r\\nif (dv == NULL)\\r\\nres= &(ctx->bn[ctx->tos+3]);\\r\\nelse res=dv;\\r\\nnorm_shift=BN_BITS2-((BN_num_bits(divisor))%BN_BITS2);\\r\\nBN_lshift(sdiv,divisor,norm_shift);\\r\\nsdiv->neg=0;\\r\\nnorm_shift+=BN_BITS2;\\r\\nBN_lshift(snum,num,norm_shift);\\r\\nsnum->neg=0;\\r\\ndiv_n=sdiv->top;\\r\\nnum_n=snum->top;\\r\\nloop=num_n-div_n;\\r\\nBN_init(&wnum);\\r\\nwnum.d= &(snum->d[loop]);\\r\\nwnum.top= div_n;\\r\\nwnum.max= snum->max+1;\\r\\nd0=sdiv->d[div_n-1];\\r\\nd1=(div_n == 1)?0:sdiv->d[div_n-2];\\r\\nwnump= &(snum->d[num_n-1]);\\r\\nres->neg= (num->neg^divisor->neg);\\r\\nif (!bn_wexpand(res,(loop+1))) goto err;\\r\\nres->top=loop;\\r\\nresp= &(res->d[loop-1]);\\r\\nif (!bn_wexpand(tmp,(div_n+1))) goto err;\\r\\nif (BN_ucmp(&wnum,sdiv) >= 0)\\r\\n{\\r\\nif (!BN_usub(&wnum,&wnum,sdiv)) goto err;\\r\\n*resp=1;\\r\\nres->d[res->top-1]=1;\\r\\n}\\r\\nelse\\r\\nres->top--;\\r\\nresp--;\\r\\nfor (i=0; i<loop-1; i++)\\r\\n{\\r\\nBN_ULONG q,l0;\\r\\n#ifdef BN_DIV3W\\r\\nq=bn_div_3_words(wnump,d0,d1);\\r\\n#else\\r\\n#if !defined(NO_ASM) && !defined(PEDANTIC)\\r\\n# if defined(__GNUC__) && __GNUC__>=2\\r\\n# if defined(__i386)\\r\\n# define bn_div_words(n0,n1,d0) \\\\r\\n({ asm volatile ( \\\\r\\n\"divl %4\" \\\\r\\n: \"=a\"(q), \"=d\"(rem) \\\\r\\n: \"a\"(n1), \"d\"(n0), \"g\"(d0) \\\\r\\n: \"cc\"); \\\\r\\nq; \\\\r\\n})\\r\\n# define REMINDER_IS_ALREADY_CALCULATED\\r\\n# endif\\r\\n# endif\\r\\n#endif\\r\\nBN_ULONG n0,n1,rem=0;\\r\\nn0=wnump[0];\\r\\nn1=wnump[-1];\\r\\nif (n0 == d0)\\r\\nq=BN_MASK2;\\r\\nelse\\r\\n#if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)\\r\\nq=((((BN_ULLONG)n0)<<BN_BITS2)|n1)/d0;\\r\\n#else\\r\\nq=bn_div_words(n0,n1,d0);\\r\\n#endif\\r\\n{\\r\\n#ifdef BN_LLONG\\r\\nBN_ULLONG t2;\\r\\n#ifndef REMINDER_IS_ALREADY_CALCULATED\\r\\nrem=(n1-q*d0)&BN_MASK2;\\r\\n#endif\\r\\nt2=(BN_ULLONG)d1*q;\\r\\nfor (;;)\\r\\n{\\r\\nif (t2 <= ((((BN_ULLONG)rem)<<BN_BITS2)|wnump[-2]))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0) break;\\r\\nt2 -= d1;\\r\\n}\\r\\n#else\\r\\nBN_ULONG t2l,t2h,ql,qh;\\r\\n#ifndef REMINDER_IS_ALREADY_CALCULATED\\r\\nrem=(n1-q*d0)&BN_MASK2;\\r\\n#endif\\r\\nt2l=LBITS(d1); t2h=HBITS(d1);\\r\\nql =LBITS(q); qh =HBITS(q);\\r\\nmul64(t2l,t2h,ql,qh);\\r\\nfor (;;)\\r\\n{\\r\\nif ((t2h < rem) ||\\r\\n((t2h == rem) && (t2l <= wnump[-2])))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0) break;\\r\\nif (t2l < d1) t2h--; t2l -= d1;\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#endif\\r\\nwnum.d--; wnum.top++;\\r\\nl0=bn_mul_words(tmp->d,sdiv->d,div_n,q);\\r\\ntmp->d[div_n]=l0;\\r\\nfor (j=div_n+1; j>0; j--)\\r\\nif (tmp->d[j-1]) break;\\r\\ntmp->top=j;\\r\\nj=wnum.top;\\r\\nBN_sub(&wnum,&wnum,tmp);\\r\\nsnum->top=snum->top+wnum.top-j;\\r\\nif (wnum.neg)\\r\\n{\\r\\nq--;\\r\\nj=wnum.top;\\r\\nBN_add(&wnum,&wnum,sdiv);\\r\\nsnum->top+=wnum.top-j;\\r\\n}\\r\\n*(resp--)=q;\\r\\nwnump--;\\r\\n}\\r\\nif (rm != NULL)\\r\\n{\\r\\nBN_rshift(rm,snum,norm_shift);\\r\\nrm->neg=num->neg;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint BN_mod(BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\n#if 0\\r\\nint i,nm,nd;\\r\\nBIGNUM *dv;\\r\\nif (BN_ucmp(m,d) < 0)\\r\\nreturn((BN_copy(rem,m) == NULL)?0:1);\\r\\ndv= &(ctx->bn[ctx->tos]);\\r\\nif (!BN_copy(rem,m)) return(0);\\r\\nnm=BN_num_bits(rem);\\r\\nnd=BN_num_bits(d);\\r\\nif (!BN_lshift(dv,d,nm-nd)) return(0);\\r\\nfor (i=nm-nd; i>=0; i--)\\r\\n{\\r\\nif (BN_cmp(rem,dv) >= 0)\\r\\n{\\r\\nif (!BN_sub(rem,rem,dv)) return(0);\\r\\n}\\r\\nif (!BN_rshift1(dv,dv)) return(0);\\r\\n}\\r\\nreturn(1);\\r\\n#else\\r\\nreturn(BN_div(NULL,rem,m,d,ctx));\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_3d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_ede_cbc(void)\\r\\n{\\r\\nreturn(&d_cbc_ede_cipher2);\\r\\n}\\r\\nEVP_CIPHER *EVP_des_ede3_cbc(void)\\r\\n{\\r\\nreturn(&d_cbc_ede_cipher3);\\r\\n}\\r\\nstatic void des_cbc_ede_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\nmemcpy( (char *)ctx->c.des_ede.ks3,\\r\\n(char *)ctx->c.des_ede.ks1,\\r\\nsizeof(ctx->c.des_ede.ks1));\\r\\n}\\r\\n}\\r\\nstatic void des_cbc_ede3_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\n{\\r\\ndes_set_key(&deskey[0],ctx->c.des_ede.ks1);\\r\\ndes_set_key(&deskey[1],ctx->c.des_ede.ks2);\\r\\ndes_set_key(&deskey[2],ctx->c.des_ede.ks3);\\r\\n}\\r\\n}\\r\\nstatic void des_cbc_ede_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_ede3_cbc_encrypt(in,out,inl, ctx->c.des_ede.ks1,\\r\\nctx->c.des_ede.ks2,ctx->c.des_ede.ks3,\\r\\n(des_cblock *) &(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509rset_c", "target": 0, "func": "int X509_REQ_set_version(X509_REQ *x, long version)\\r\\n{\\r\\nif (x == NULL) return(0);\\r\\nreturn(ASN1_INTEGER_set(x->req_info->version,version));\\r\\n}\\r\\nint X509_REQ_set_subject_name(X509_REQ *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->req_info->subject,name));\\r\\n}\\r\\nint X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL)) return(0);\\r\\nreturn(X509_PUBKEY_set(&x->req_info->pubkey,pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5_ecb_c", "target": 0, "func": "void RC5_32_ecb_encrypt(unsigned char *in, unsigned char *out, RC5_32_KEY *ks,\\r\\nint encrypt)\\r\\n{\\r\\nunsigned long l,d[2];\\r\\nc2l(in,l); d[0]=l;\\r\\nc2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nRC5_32_encrypt(d,ks);\\r\\nelse\\r\\nRC5_32_decrypt(d,ks);\\r\\nl=d[0]; l2c(l,out);\\r\\nl=d[1]; l2c(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_seal_c", "target": 0, "func": "int EVP_SealInit(EVP_CIPHER_CTX *ctx, EVP_CIPHER *type, unsigned char **ek,\\r\\nint *ekl, unsigned char *iv, EVP_PKEY **pubk, int npubk)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nint i;\\r\\nif (npubk <= 0) return(0);\\r\\nRAND_bytes(key,EVP_MAX_KEY_LENGTH);\\r\\nif (type->iv_len > 0)\\r\\nRAND_bytes(iv,type->iv_len);\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nEVP_EncryptInit(ctx,type,key,iv);\\r\\nfor (i=0; i<npubk; i++)\\r\\n{\\r\\nekl[i]=EVP_PKEY_encrypt(ek[i],key,EVP_CIPHER_key_length(type),\\r\\npubk[i]);\\r\\nif (ekl[i] <= 0) return(-1);\\r\\n}\\r\\nreturn(npubk);\\r\\n}\\r\\nvoid EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nEVP_EncryptFinal(ctx,out,outl);\\r\\nEVP_EncryptInit(ctx,NULL,NULL,NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_rtcp_c", "target": 0, "func": "BIO_METHOD *BIO_s_rtcp(void)\\r\\n{\\r\\nreturn(&rtcp_method);\\r\\n}\\r\\nstatic int get ( io_channel chan, char *buffer, int maxlen, int *length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = sys$qiow ( 0, chan, IO$_READVBLK, &iosb, 0, 0,\\r\\nbuffer, maxlen, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nif ( (status&1) == 1 ) *length = iosb.count;\\r\\nreturn status;\\r\\n}\\r\\nstatic int put ( io_channel chan, char *buffer, int length )\\r\\n{\\r\\nint status;\\r\\nstruct io_status iosb;\\r\\nstatus = sys$qiow ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,\\r\\nbuffer, length, 0, 0, 0, 0 );\\r\\nif ( (status&1) == 1 ) status = iosb.status;\\r\\nreturn status;\\r\\n}\\r\\nstatic int rtcp_new(BIO *bi)\\r\\n{\\r\\nstruct rpc_ctx *ctx;\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->flags = 0;\\r\\nbi->ptr=Malloc(sizeof(struct rpc_ctx));\\r\\nctx = (struct rpc_ctx *) bi->ptr;\\r\\nctx->filled = 0;\\r\\nctx->pos = 0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int rtcp_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif ( a->ptr ) Free ( a->ptr );\\r\\na->ptr = NULL;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int rtcp_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint status, length;\\r\\nstruct rpc_ctx *ctx;\\r\\nctx = (struct rpc_ctx *) b->ptr;\\r\\nif ( ctx->pos < ctx->filled ) {\\r\\nlength = ctx->filled - ctx->pos;\\r\\nif ( length > outl ) length = outl;\\r\\nmemmove ( out, &ctx->msg.data[ctx->pos], length );\\r\\nctx->pos += length;\\r\\nreturn length;\\r\\n}\\r\\nctx->msg.channel = 'R';\\r\\nctx->msg.function = 'G';\\r\\nctx->msg.length = sizeof(ctx->msg.data);\\r\\nstatus = put ( b->num, (char *) &ctx->msg, RPC_HDR_SIZE );\\r\\nif ( (status&1) == 0 ) {\\r\\nreturn -1;\\r\\n}\\r\\nctx->pos = ctx->filled = 0;\\r\\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\\r\\nif ( (status&1) == 0 ) length = -1;\\r\\nif ( ctx->msg.channel != 'R' || ctx->msg.function != 'C' ) {\\r\\nlength = -1;\\r\\n}\\r\\nctx->filled = length - RPC_HDR_SIZE;\\r\\nif ( ctx->pos < ctx->filled ) {\\r\\nlength = ctx->filled - ctx->pos;\\r\\nif ( length > outl ) length = outl;\\r\\nmemmove ( out, ctx->msg.data, length );\\r\\nctx->pos += length;\\r\\nreturn length;\\r\\n}\\r\\nreturn length;\\r\\n}\\r\\nstatic int rtcp_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint status, i, segment, length;\\r\\nstruct rpc_ctx *ctx;\\r\\nctx = (struct rpc_ctx *) b->ptr;\\r\\nfor ( i = 0; i < inl; i += segment ) {\\r\\nsegment = inl - i;\\r\\nif ( segment > sizeof(ctx->msg.data) ) segment = sizeof(ctx->msg.data);\\r\\nctx->msg.channel = 'R';\\r\\nctx->msg.function = 'P';\\r\\nctx->msg.length = segment;\\r\\nmemmove ( ctx->msg.data, &in[i], segment );\\r\\nstatus = put ( b->num, (char *) &ctx->msg, segment + RPC_HDR_SIZE );\\r\\nif ((status&1) == 0 ) { i = -1; break; }\\r\\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\\r\\nif ( ((status&1) == 0) || (length < RPC_HDR_SIZE) ) { i = -1; break; }\\r\\nif ( (ctx->msg.channel != 'R') || (ctx->msg.function != 'C') ) {\\r\\nprintf(\"unexpected response when confirming put %c %c\\n\",\\r\\nctx->msg.channel, ctx->msg.function );\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic long rtcp_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\ncase BIO_CTRL_EOF:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nb->num = num;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\ncase BIO_CTRL_FLUSH:\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int rtcp_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int rtcp_puts(BIO *bp, char *str)\\r\\n{\\r\\nint length;\\r\\nif (str == NULL) return(0);\\r\\nlength = strlen ( str );\\r\\nif ( length == 0 ) return (0);\\r\\nreturn rtcp_write ( bp,str, length );\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_castopts_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic char key[16]={ 0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};\\r\\nCAST_KEY sch;\\r\\ndouble d,tm[16],max=0;\\r\\nint rank[16];\\r\\nchar *str[16];\\r\\nint max_idx=0,i,num=0,j;\\r\\n#ifndef SIGALARM\\r\\nlong ca,cb,cc,cd,ce;\\r\\n#endif\\r\\nfor (i=0; i<12; i++)\\r\\n{\\r\\ntm[i]=0.0;\\r\\nrank[i]=0;\\r\\n}\\r\\n#ifndef TIMES\\r\\nfprintf(stderr,\"To get the most acurate results, try to run this\\n\");\\r\\nfprintf(stderr,\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nCAST_set_key(&sch,16,key);\\r\\n#ifndef SIGALRM\\r\\nfprintf(stderr,\"First we calculate the approximate speed ...\\n\");\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nCAST_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count;\\r\\ncb=count*3;\\r\\ncc=count*3*8/BUFSIZE+1;\\r\\ncd=count*8/BUFSIZE+1;\\r\\nce=count/20+1;\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nalarm(10);\\r\\n#endif\\r\\ntime_it(CAST_encrypt_normal, \"CAST_encrypt_normal \", 0);\\r\\ntime_it(CAST_encrypt_ptr, \"CAST_encrypt_ptr \", 1);\\r\\ntime_it(CAST_encrypt_ptr2, \"CAST_encrypt_ptr2 \", 2);\\r\\nnum+=3;\\r\\nstr[0]=\"<nothing>\";\\r\\nprint_it(\"CAST_encrypt_normal \",0);\\r\\nmax=tm[0];\\r\\nmax_idx=0;\\r\\nstr[1]=\"ptr \";\\r\\nprint_it(\"CAST_encrypt_ptr \",1);\\r\\nif (max < tm[1]) { max=tm[1]; max_idx=1; }\\r\\nstr[2]=\"ptr2 \";\\r\\nprint_it(\"CAST_encrypt_ptr2 \",2);\\r\\nif (max < tm[2]) { max=tm[2]; max_idx=2; }\\r\\nprintf(\"options CAST ecb/s\\n\");\\r\\nprintf(\"%s %12.2f 100.0%%\\n\",str[max_idx],tm[max_idx]);\\r\\nd=tm[max_idx];\\r\\ntm[max_idx]= -2.0;\\r\\nmax= -1.0;\\r\\nfor (;;)\\r\\n{\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nif (max < tm[i]) { max=tm[i]; j=i; }\\r\\n}\\r\\nif (max < 0.0) break;\\r\\nprintf(\"%s %12.2f %4.1f%%\\n\",str[j],tm[j],tm[j]/d*100.0);\\r\\ntm[j]= -2.0;\\r\\nmax= -1.0;\\r\\n}\\r\\nswitch (max_idx)\\r\\n{\\r\\ncase 0:\\r\\nprintf(\"-DCAST_DEFAULT_OPTIONS\\n\");\\r\\nbreak;\\r\\ncase 1:\\r\\nprintf(\"-DCAST_PTR\\n\");\\r\\nbreak;\\r\\ncase 2:\\r\\nprintf(\"-DCAST_PTR2\\n\");\\r\\nbreak;\\r\\n}\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_time_c", "target": 0, "func": "int i2d_ASN1_TIME(ASN1_TIME *a, unsigned char **pp)\\r\\n{\\r\\n#ifdef CHARSET_EBCDIC\\r\\nchar tmp[24];\\r\\nASN1_STRING tmpstr;\\r\\nif(a->type == V_ASN1_UTCTIME || a->type == V_ASN1_GENERALIZEDTIME) {\\r\\nint len;\\r\\ntmpstr = *(ASN1_STRING *)a;\\r\\nlen = tmpstr.length;\\r\\nebcdic2ascii(tmp, tmpstr.data, (len >= sizeof tmp) ? sizeof tmp : len);\\r\\ntmpstr.data = tmp;\\r\\na = (ASN1_GENERALIZEDTIME *) &tmpstr;\\r\\n}\\r\\n#endif\\r\\nif(a->type == V_ASN1_UTCTIME || a->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\na->type ,V_ASN1_UNIVERSAL));\\r\\nASN1err(ASN1_F_I2D_ASN1_TIME,ASN1_R_EXPECTING_A_TIME);\\r\\nreturn -1;\\r\\n}\\r\\nASN1_TIME *d2i_ASN1_TIME(ASN1_TIME **a, unsigned char **pp, long length)\\r\\n{\\r\\nunsigned char tag;\\r\\ntag = **pp & ~V_ASN1_CONSTRUCTED;\\r\\nif(tag == (V_ASN1_UTCTIME|V_ASN1_UNIVERSAL))\\r\\nreturn d2i_ASN1_UTCTIME(a, pp, length);\\r\\nif(tag == (V_ASN1_GENERALIZEDTIME|V_ASN1_UNIVERSAL))\\r\\nreturn d2i_ASN1_GENERALIZEDTIME(a, pp, length);\\r\\nASN1err(ASN1_F_D2I_ASN1_TIME,ASN1_R_EXPECTING_A_TIME);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t)\\r\\n{\\r\\nstruct tm *ts;\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\nstruct tm data;\\r\\n#endif\\r\\n#if defined(THREADS) && !defined(WIN32)\\r\\ngmtime_r(&t,&data);\\r\\nts=&data;\\r\\n#else\\r\\nts=gmtime(&t);\\r\\n#endif\\r\\nif((ts->tm_year >= 50) && (ts->tm_year < 150))\\r\\nreturn ASN1_UTCTIME_set(s, t);\\r\\nreturn ASN1_GENERALIZEDTIME_set(s,t);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret=1;\\r\\nDSA *dsa=NULL;\\r\\nint i,badops=0;\\r\\nconst EVP_CIPHER *enc=NULL;\\r\\nBIO *in=NULL,*out=NULL;\\r\\nint informat,outformat,text=0,noout=0;\\r\\nchar *infile,*outfile,*prog;\\r\\nint modulus=0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninfile=NULL;\\r\\noutfile=NULL;\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nprog=argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout=1;\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext=1;\\r\\nelse if (strcmp(*argv,\"-modulus\") == 0)\\r\\nmodulus=1;\\r\\nelse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\\r\\nBIO_printf(bio_err,\"where options are\\n\");\\r\\nBIO_printf(bio_err,\" -inform arg input format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -outform arg output format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n#ifndef NO_IDEA\\r\\nBIO_printf(bio_err,\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err,\" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err,\" -modulus print the DSA public value\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"read DSA private key\\n\");\\r\\nif (informat == FORMAT_ASN1)\\r\\ndsa=d2i_DSAPrivateKey_bio(in,NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndsa=PEM_read_bio_DSAPrivateKey(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dsa == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load Private Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!DSA_print(out,dsa,0))\\r\\n{\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus)\\r\\n{\\r\\nfprintf(stdout,\"Public Key=\");\\r\\nBN_print(out,dsa->pub_key);\\r\\nfprintf(stdout,\"\\n\");\\r\\n}\\r\\nif (noout) goto end;\\r\\nBIO_printf(bio_err,\"writing DSA private key\\n\");\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=i2d_DSAPrivateKey_bio(out,dsa);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_DSAPrivateKey(out,dsa,enc,NULL,0,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (dsa != NULL) DSA_free(dsa);\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_null_c", "target": 0, "func": "BIO_METHOD *BIO_s_null(void)\\r\\n{\\r\\nreturn(&null_method);\\r\\n}\\r\\nstatic int null_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->ptr=(NULL);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int null_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int null_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int null_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nreturn(inl);\\r\\n}\\r\\nstatic long null_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\ncase BIO_CTRL_EOF:\\r\\ncase BIO_CTRL_SET:\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\ncase BIO_CTRL_FLUSH:\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int null_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nstatic int null_puts(BIO *bp, char *str)\\r\\n{\\r\\nif (str == NULL) return(0);\\r\\nreturn(strlen(str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_enc_c", "target": 0, "func": "static void ssl3_generate_key_block(SSL *s, unsigned char *km, int num)\\r\\n{\\r\\nMD5_CTX m5;\\r\\nSHA_CTX s1;\\r\\nunsigned char buf[8],smd[SHA_DIGEST_LENGTH];\\r\\nunsigned char c='A';\\r\\nint i,j,k;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nc = os_toascii[c];\\r\\n#endif\\r\\nk=0;\\r\\nfor (i=0; i<num; i+=MD5_DIGEST_LENGTH)\\r\\n{\\r\\nk++;\\r\\nfor (j=0; j<k; j++)\\r\\nbuf[j]=c;\\r\\nc++;\\r\\nSHA1_Init( &s1);\\r\\nSHA1_Update(&s1,buf,k);\\r\\nSHA1_Update(&s1,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nSHA1_Update(&s1,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\nSHA1_Update(&s1,s->s3->client_random,SSL3_RANDOM_SIZE);\\r\\nSHA1_Final( smd,&s1);\\r\\nMD5_Init( &m5);\\r\\nMD5_Update(&m5,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nMD5_Update(&m5,smd,SHA_DIGEST_LENGTH);\\r\\nif ((i+MD5_DIGEST_LENGTH) > num)\\r\\n{\\r\\nMD5_Final(smd,&m5);\\r\\nmemcpy(km,smd,(num-i));\\r\\n}\\r\\nelse\\r\\nMD5_Final(km,&m5);\\r\\nkm+=MD5_DIGEST_LENGTH;\\r\\n}\\r\\nmemset(smd,0,SHA_DIGEST_LENGTH);\\r\\n}\\r\\nint ssl3_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nunsigned char *p,*key_block,*mac_secret;\\r\\nunsigned char exp_key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char exp_iv[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char *ms,*key,*iv,*er1,*er2;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\nCOMP_METHOD *comp;\\r\\nconst EVP_MD *m;\\r\\nMD5_CTX md;\\r\\nint exp,n,i,j,k,cl;\\r\\nexp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc=s->s3->tmp.new_sym_enc;\\r\\nm=s->s3->tmp.new_hash;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ncomp=NULL;\\r\\nelse\\r\\ncomp=s->s3->tmp.new_compression->method;\\r\\nkey_block=s->s3->tmp.key_block;\\r\\nif (which & SSL3_CC_READ)\\r\\n{\\r\\nif ((s->enc_read_ctx == NULL) &&\\r\\n((s->enc_read_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\ndd= s->enc_read_ctx;\\r\\ns->read_hash=m;\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->expand=COMP_CTX_new(comp);\\r\\nif (s->expand == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp=(unsigned char *)\\r\\nMalloc(SSL3_RT_MAX_PLAIN_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\nmemset(&(s->s3->read_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->read_mac_secret[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((s->enc_write_ctx == NULL) &&\\r\\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\\r\\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\\r\\ngoto err;\\r\\ndd= s->enc_write_ctx;\\r\\ns->write_hash=m;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress=NULL;\\r\\n}\\r\\nif (comp != NULL)\\r\\n{\\r\\ns->compress=COMP_CTX_new(comp);\\r\\nif (s->compress == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\nmemset(&(s->s3->write_sequence[0]),0,8);\\r\\nmac_secret= &(s->s3->write_mac_secret[0]);\\r\\n}\\r\\nEVP_CIPHER_CTX_init(dd);\\r\\np=s->s3->tmp.key_block;\\r\\ni=EVP_MD_size(m);\\r\\ncl=EVP_CIPHER_key_length(c);\\r\\nj=exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nk=EVP_CIPHER_iv_length(c);\\r\\nif ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ))\\r\\n{\\r\\nms= &(p[ 0]); n=i+i;\\r\\nkey= &(p[ n]); n+=j+j;\\r\\niv= &(p[ n]); n+=k+k;\\r\\ner1= &(s->s3->client_random[0]);\\r\\ner2= &(s->s3->server_random[0]);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn=i;\\r\\nms= &(p[ n]); n+=i+j;\\r\\nkey= &(p[ n]); n+=j+k;\\r\\niv= &(p[ n]); n+=k;\\r\\ner1= &(s->s3->server_random[0]);\\r\\ner2= &(s->s3->client_random[0]);\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,SSL_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nmemcpy(mac_secret,ms,i);\\r\\nif (exp)\\r\\n{\\r\\nMD5_Init(&md);\\r\\nMD5_Update(&md,key,j);\\r\\nMD5_Update(&md,er1,SSL3_RANDOM_SIZE);\\r\\nMD5_Update(&md,er2,SSL3_RANDOM_SIZE);\\r\\nMD5_Final(&(exp_key[0]),&md);\\r\\nkey= &(exp_key[0]);\\r\\nif (k > 0)\\r\\n{\\r\\nMD5_Init(&md);\\r\\nMD5_Update(&md,er1,SSL3_RANDOM_SIZE);\\r\\nMD5_Update(&md,er2,SSL3_RANDOM_SIZE);\\r\\nMD5_Final(&(exp_iv[0]),&md);\\r\\niv= &(exp_iv[0]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length=0;\\r\\nEVP_CipherInit(dd,c,key,iv,(which & SSL3_CC_WRITE));\\r\\nmemset(&(exp_key[0]),0,sizeof(exp_key));\\r\\nmemset(&(exp_iv[0]),0,sizeof(exp_iv));\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nSSL_COMP *comp;\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn(1);\\r\\nif (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn(0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc=c;\\r\\ns->s3->tmp.new_hash=hash;\\r\\ns->s3->tmp.new_compression=comp;\\r\\nnum=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);\\r\\nnum*=2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p=(unsigned char *)Malloc(num)) == NULL)\\r\\ngoto err;\\r\\ns->s3->tmp.key_block_length=num;\\r\\ns->s3->tmp.key_block=p;\\r\\nssl3_generate_key_block(s,p,num);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl3_cleanup_key_block(SSL *s)\\r\\n{\\r\\nif (s->s3->tmp.key_block != NULL)\\r\\n{\\r\\nmemset(s->s3->tmp.key_block,0,\\r\\ns->s3->tmp.key_block_length);\\r\\nFree(s->s3->tmp.key_block);\\r\\ns->s3->tmp.key_block=NULL;\\r\\n}\\r\\ns->s3->tmp.key_block_length=0;\\r\\n}\\r\\nint ssl3_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs,i;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send)\\r\\n{\\r\\nds=s->enc_write_ctx;\\r\\nrec= &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\n}\\r\\nelse\\r\\n{\\r\\nds=s->enc_read_ctx;\\r\\nrec= &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc=NULL;\\r\\nelse\\r\\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\nif ((s->session == NULL) || (ds == NULL) ||\\r\\n(enc == NULL))\\r\\n{\\r\\nmemcpy(rec->data,rec->input,rec->length);\\r\\nrec->input=rec->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=rec->length;\\r\\nbs=EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send)\\r\\n{\\r\\ni=bs-((int)l%bs);\\r\\nl+=i;\\r\\nrec->length+=i;\\r\\nrec->input[l-1]=(i-1);\\r\\n}\\r\\nEVP_Cipher(ds,rec->data,rec->input,l);\\r\\nif ((bs != 1) && !send)\\r\\n{\\r\\ni=rec->data[l-1]+1;\\r\\nif (i > bs)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPT_ERROR);\\r\\nreturn(0);\\r\\n}\\r\\nrec->length-=i;\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nvoid ssl3_init_finished_mac(SSL *s)\\r\\n{\\r\\nEVP_DigestInit(&(s->s3->finish_dgst1),s->ctx->md5);\\r\\nEVP_DigestInit(&(s->s3->finish_dgst2),s->ctx->sha1);\\r\\n}\\r\\nvoid ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)\\r\\n{\\r\\nEVP_DigestUpdate(&(s->s3->finish_dgst1),buf,len);\\r\\nEVP_DigestUpdate(&(s->s3->finish_dgst2),buf,len);\\r\\n}\\r\\nint ssl3_cert_verify_mac(SSL *s, EVP_MD_CTX *ctx, unsigned char *p)\\r\\n{\\r\\nreturn(ssl3_handshake_mac(s,ctx,NULL,0,p));\\r\\n}\\r\\nint ssl3_final_finish_mac(SSL *s, EVP_MD_CTX *ctx1, EVP_MD_CTX *ctx2,\\r\\nunsigned char *sender, int len, unsigned char *p)\\r\\n{\\r\\nint ret;\\r\\nret=ssl3_handshake_mac(s,ctx1,sender,len,p);\\r\\np+=ret;\\r\\nret+=ssl3_handshake_mac(s,ctx2,sender,len,p);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_handshake_mac(SSL *s, EVP_MD_CTX *in_ctx,\\r\\nunsigned char *sender, int len, unsigned char *p)\\r\\n{\\r\\nunsigned int ret;\\r\\nint npad,n;\\r\\nunsigned int i;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_MD_CTX_copy(&ctx,in_ctx);\\r\\nn=EVP_MD_CTX_size(&ctx);\\r\\nnpad=(48/n)*n;\\r\\nif (sender != NULL)\\r\\nEVP_DigestUpdate(&ctx,sender,len);\\r\\nEVP_DigestUpdate(&ctx,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx,ssl3_pad_1,npad);\\r\\nEVP_DigestFinal(&ctx,md_buf,&i);\\r\\nEVP_DigestInit(&ctx,EVP_MD_CTX_type(&ctx));\\r\\nEVP_DigestUpdate(&ctx,s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx,ssl3_pad_2,npad);\\r\\nEVP_DigestUpdate(&ctx,md_buf,i);\\r\\nEVP_DigestFinal(&ctx,p,&ret);\\r\\nmemset(&ctx,0,sizeof(EVP_MD_CTX));\\r\\nreturn((int)ret);\\r\\n}\\r\\nint ssl3_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *mac_sec,*seq;\\r\\nEVP_MD_CTX md_ctx;\\r\\nconst EVP_MD *hash;\\r\\nunsigned char *p,rec_char;\\r\\nunsigned int md_size;\\r\\nint npad,i;\\r\\nif (send)\\r\\n{\\r\\nrec= &(ssl->s3->wrec);\\r\\nmac_sec= &(ssl->s3->write_mac_secret[0]);\\r\\nseq= &(ssl->s3->write_sequence[0]);\\r\\nhash=ssl->write_hash;\\r\\n}\\r\\nelse\\r\\n{\\r\\nrec= &(ssl->s3->rrec);\\r\\nmac_sec= &(ssl->s3->read_mac_secret[0]);\\r\\nseq= &(ssl->s3->read_sequence[0]);\\r\\nhash=ssl->read_hash;\\r\\n}\\r\\nmd_size=EVP_MD_size(hash);\\r\\nnpad=(48/md_size)*md_size;\\r\\nEVP_DigestInit( &md_ctx,hash);\\r\\nEVP_DigestUpdate(&md_ctx,mac_sec,md_size);\\r\\nEVP_DigestUpdate(&md_ctx,ssl3_pad_1,npad);\\r\\nEVP_DigestUpdate(&md_ctx,seq,8);\\r\\nrec_char=rec->type;\\r\\nEVP_DigestUpdate(&md_ctx,&rec_char,1);\\r\\np=md;\\r\\ns2n(rec->length,p);\\r\\nEVP_DigestUpdate(&md_ctx,md,2);\\r\\nEVP_DigestUpdate(&md_ctx,rec->input,rec->length);\\r\\nEVP_DigestFinal( &md_ctx,md,NULL);\\r\\nEVP_DigestInit( &md_ctx,hash);\\r\\nEVP_DigestUpdate(&md_ctx,mac_sec,md_size);\\r\\nEVP_DigestUpdate(&md_ctx,ssl3_pad_2,npad);\\r\\nEVP_DigestUpdate(&md_ctx,md,md_size);\\r\\nEVP_DigestFinal( &md_ctx,md,&md_size);\\r\\nfor (i=7; i>=0; i--)\\r\\nif (++seq[i]) break;\\r\\nreturn(md_size);\\r\\n}\\r\\nint ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nstatic const unsigned char *salt[3]={\\r\\n#ifndef CHARSET_EBCDIC\\r\\n(const unsigned char *)\"A\",\\r\\n(const unsigned char *)\"BB\",\\r\\n(const unsigned char *)\"CCC\",\\r\\n#else\\r\\n(const unsigned char *)\"\\x41\",\\r\\n(const unsigned char *)\"\\x42\\x42\",\\r\\n(const unsigned char *)\"\\x43\\x43\\x43\",\\r\\n#endif\\r\\n};\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx;\\r\\nint i,ret=0;\\r\\nunsigned int n;\\r\\nfor (i=0; i<3; i++)\\r\\n{\\r\\nEVP_DigestInit(&ctx,s->ctx->sha1);\\r\\nEVP_DigestUpdate(&ctx,salt[i],strlen((const char *)salt[i]));\\r\\nEVP_DigestUpdate(&ctx,p,len);\\r\\nEVP_DigestUpdate(&ctx,&(s->s3->client_random[0]),\\r\\nSSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&ctx,&(s->s3->server_random[0]),\\r\\nSSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal(&ctx,buf,&n);\\r\\nEVP_DigestInit(&ctx,s->ctx->md5);\\r\\nEVP_DigestUpdate(&ctx,p,len);\\r\\nEVP_DigestUpdate(&ctx,buf,n);\\r\\nEVP_DigestFinal(&ctx,out,&n);\\r\\nout+=n;\\r\\nret+=n;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_alert_code(int code)\\r\\n{\\r\\nswitch (code)\\r\\n{\\r\\ncase SSL_AD_CLOSE_NOTIFY: return(SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE: return(SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_RECORD_OVERFLOW: return(SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE: return(SSL3_AD_NO_CERTIFICATE);\\r\\ncase SSL_AD_BAD_CERTIFICATE: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER: return(SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA: return(SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_ACCESS_DENIED: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECODE_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECRYPT_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_EXPORT_RESTRICION: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_PROTOCOL_VERSION: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INTERNAL_ERROR: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_USER_CANCLED: return(SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_RENEGOTIATION: return(-1);\\r\\ndefault: return(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_mpi_c", "target": 0, "func": "int BN_bn2mpi(const BIGNUM *a, unsigned char *d)\\r\\n{\\r\\nint bits;\\r\\nint num=0;\\r\\nint ext=0;\\r\\nlong l;\\r\\nbits=BN_num_bits(a);\\r\\nnum=(bits+7)/8;\\r\\nif (bits > 0)\\r\\n{\\r\\next=((bits & 0x07) == 0);\\r\\n}\\r\\nif (d == NULL)\\r\\nreturn(num+4+ext);\\r\\nl=num+ext;\\r\\nd[0]=(unsigned char)(l>>24)&0xff;\\r\\nd[1]=(unsigned char)(l>>16)&0xff;\\r\\nd[2]=(unsigned char)(l>> 8)&0xff;\\r\\nd[3]=(unsigned char)(l )&0xff;\\r\\nif (ext) d[4]=0;\\r\\nnum=BN_bn2bin(a,&(d[4+ext]));\\r\\nif (a->neg)\\r\\nd[4]|=0x80;\\r\\nreturn(num+4+ext);\\r\\n}\\r\\nBIGNUM *BN_mpi2bn(unsigned char *d, int n, BIGNUM *a)\\r\\n{\\r\\nlong len;\\r\\nint neg=0;\\r\\nif (n < 4)\\r\\n{\\r\\nBNerr(BN_F_BN_MPI2BN,BN_R_INVALID_LENGTH);\\r\\nreturn(NULL);\\r\\n}\\r\\nlen=((long)d[0]<<24)|((long)d[1]<<16)|((int)d[2]<<8)|(int)d[3];\\r\\nif ((len+4) != n)\\r\\n{\\r\\nBNerr(BN_F_BN_MPI2BN,BN_R_ENCODING_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nif (a == NULL) a=BN_new();\\r\\nif (a == NULL) return(NULL);\\r\\nif (len == 0)\\r\\n{\\r\\na->neg=0;\\r\\na->top=0;\\r\\nreturn(a);\\r\\n}\\r\\nd+=4;\\r\\nif ((*d) & 0x80)\\r\\nneg=1;\\r\\nif (BN_bin2bn(d,(int)len,a) == NULL)\\r\\nreturn(NULL);\\r\\na->neg=neg;\\r\\nif (neg)\\r\\n{\\r\\nBN_clear_bit(a,BN_num_bits(a)-1);\\r\\n}\\r\\nreturn(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_fcrypt_c", "target": 0, "func": "char *crypt(const char *buf, const char *salt)\\r\\n{\\r\\nreturn(des_crypt(buf, salt));\\r\\n}\\r\\nchar *des_crypt(const char *buf, const char *salt)\\r\\n{\\r\\nstatic char buff[14];\\r\\n#ifndef CHARSET_EBCDIC\\r\\nreturn(des_fcrypt(buf,salt,buff));\\r\\n#else\\r\\nchar e_salt[2+1];\\r\\nchar e_buf[32+1];\\r\\nchar *ret;\\r\\nif ((e_salt[0] = salt[0]) != '\\0')\\r\\ne_salt[1] = salt[1];\\r\\nstrncpy (e_buf, buf, sizeof(e_buf));\\r\\ne_salt[sizeof(e_salt)-1] = e_buf[sizeof(e_buf)-1] = '\\0';\\r\\nebcdic2ascii(e_salt, e_salt, sizeof e_salt);\\r\\nebcdic2ascii(e_buf, e_buf, sizeof e_buf);\\r\\nret = des_fcrypt(e_buf,e_salt,buff);\\r\\nascii2ebcdic(ret, ret, strlen(ret));\\r\\nreturn ret;\\r\\n#endif\\r\\n}\\r\\nchar *des_fcrypt(const char *buf, const char *salt, char *ret)\\r\\n{\\r\\nunsigned int i,j,x,y;\\r\\nDES_LONG Eswap0,Eswap1;\\r\\nDES_LONG out[2],ll;\\r\\ndes_cblock key;\\r\\ndes_key_schedule ks;\\r\\nunsigned char bb[9];\\r\\nunsigned char *b=bb;\\r\\nunsigned char c,u;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nx=ret[0]=((salt[0] == '\\0')?'A':salt[0]);\\r\\nEswap0=con_salt[x]<<2;\\r\\nx=ret[1]=((salt[1] == '\\0')?'A':salt[1]);\\r\\nEswap1=con_salt[x]<<6;\\r\\n#else\\r\\nx=ret[0]=((salt[0] == '\\0')?os_toascii['A']:salt[0]);\\r\\nEswap0=con_salt[x]<<2;\\r\\nx=ret[1]=((salt[1] == '\\0')?os_toascii['A']:salt[1]);\\r\\nEswap1=con_salt[x]<<6;\\r\\n#endif\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nc= *(buf++);\\r\\nif (!c) break;\\r\\nkey[i]=(c<<1);\\r\\n}\\r\\nfor (; i<8; i++)\\r\\nkey[i]=0;\\r\\ndes_set_key(&key,ks);\\r\\nfcrypt_body(&(out[0]),ks,Eswap0,Eswap1);\\r\\nll=out[0]; l2c(ll,b);\\r\\nll=out[1]; l2c(ll,b);\\r\\ny=0;\\r\\nu=0x80;\\r\\nbb[8]=0;\\r\\nfor (i=2; i<13; i++)\\r\\n{\\r\\nc=0;\\r\\nfor (j=0; j<6; j++)\\r\\n{\\r\\nc<<=1;\\r\\nif (bb[y] & u) c|=1;\\r\\nu>>=1;\\r\\nif (!u)\\r\\n{\\r\\ny++;\\r\\nu=0x80;\\r\\n}\\r\\n}\\r\\nret[i]=cov_2char[c];\\r\\n}\\r\\nret[13]='\\0';\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md2_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"MD2(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\nreturn(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nMD2_CTX c;\\r\\nunsigned char md[MD2_DIGEST_LENGTH];\\r\\nint fd,i;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nMD2_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nMD2_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nMD2_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<MD2_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_akey_c", "target": 0, "func": "int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len_IMP_opt (a->keyid, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len_IMP_opt (a->issuer, i2d_GENERAL_NAMES);\\r\\nM_ASN1_I2D_len_IMP_opt (a->serial, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put_IMP_opt (a->keyid, i2d_ASN1_OCTET_STRING, 0);\\r\\nM_ASN1_I2D_put_IMP_opt (a->issuer, i2d_GENERAL_NAMES, 1);\\r\\nM_ASN1_I2D_put_IMP_opt (a->serial, i2d_ASN1_INTEGER, 2);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nAUTHORITY_KEYID *AUTHORITY_KEYID_new(void)\\r\\n{\\r\\nAUTHORITY_KEYID *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, AUTHORITY_KEYID);\\r\\nret->keyid = NULL;\\r\\nret->issuer = NULL;\\r\\nret->serial = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_AUTHORITY_KEYID_NEW);\\r\\n}\\r\\nAUTHORITY_KEYID *d2i_AUTHORITY_KEYID(AUTHORITY_KEYID **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,AUTHORITY_KEYID *,AUTHORITY_KEYID_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_IMP_opt (ret->keyid, d2i_ASN1_OCTET_STRING, 0,\\r\\nV_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_get_IMP_opt (ret->issuer, d2i_GENERAL_NAMES, 1,\\r\\nV_ASN1_SEQUENCE);\\r\\nM_ASN1_D2I_get_IMP_opt (ret->serial, d2i_ASN1_INTEGER, 2,\\r\\nV_ASN1_INTEGER);\\r\\nM_ASN1_D2I_Finish(a, AUTHORITY_KEYID_free, ASN1_F_D2I_AUTHORITY_KEYID);\\r\\n}\\r\\nvoid AUTHORITY_KEYID_free(AUTHORITY_KEYID *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OCTET_STRING_free(a->keyid);\\r\\nsk_GENERAL_NAME_pop_free(a->issuer, GENERAL_NAME_free);\\r\\nASN1_INTEGER_free (a->serial);\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_txt_c", "target": 0, "func": "const char *X509_verify_cert_error_string(long n)\\r\\n{\\r\\nstatic char buf[100];\\r\\nswitch ((int)n)\\r\\n{\\r\\ncase X509_V_OK:\\r\\nreturn(\"ok\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nreturn(\"unable to get issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL:\\r\\nreturn(\"unable to get certificate CRL\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\\r\\nreturn(\"unable to decrypt certificate's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\\r\\nreturn(\"unable to decrypt CRL's's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\\r\\nreturn(\"unable to decode issuer public key\");\\r\\ncase X509_V_ERR_CERT_SIGNATURE_FAILURE:\\r\\nreturn(\"certificate signature failure\");\\r\\ncase X509_V_ERR_CRL_SIGNATURE_FAILURE:\\r\\nreturn(\"CRL signature failure\");\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\nreturn(\"certificate is not yet valid\");\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\nreturn(\"CRL is not yet valid\");\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\nreturn(\"Certificate has expired\");\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\nreturn(\"CRL has expired\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nreturn(\"format error in certificate's notBefore field\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nreturn(\"format error in certificate's notAfter field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\\r\\nreturn(\"format error in CRL's lastUpdate field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\\r\\nreturn(\"format error in CRL's nextUpdate field\");\\r\\ncase X509_V_ERR_OUT_OF_MEM:\\r\\nreturn(\"out of memory\");\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\nreturn(\"self signed certificate\");\\r\\ncase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\\r\\nreturn(\"self signed certificate in certificate chain\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\\r\\nreturn(\"unable to get local issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\\r\\nreturn(\"unable to verify the first certificate\");\\r\\ncase X509_V_ERR_CERT_CHAIN_TOO_LONG:\\r\\nreturn(\"certificate chain too long\");\\r\\ncase X509_V_ERR_CERT_REVOKED:\\r\\nreturn(\"certificate revoked\");\\r\\ncase X509_V_ERR_APPLICATION_VERIFICATION:\\r\\nreturn(\"application verification failure\");\\r\\ndefault:\\r\\nsprintf(buf,\"error number %ld\",n);\\r\\nreturn(buf);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3prin_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nint i, count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif(!argv[1]) {\\r\\nfprintf(stderr, \"Usage v3prin cert.pem\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif(!(inf = fopen(argv[1], \"r\"))) {\\r\\nfprintf(stderr, \"Can't open %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nif(!(cert = PEM_read_X509(inf, NULL, NULL))) {\\r\\nfprintf(stderr, \"Can't read certificate %s\\n\", argv[1]);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor(i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\\n\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif(!X509V3_EXT_print_fp(stdout, ext, 0, 0)) ERR_print_errors_fp(stderr);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_sbag_c", "target": 0, "func": "int i2d_PKCS12_SAFEBAG(PKCS12_SAFEBAG *a, unsigned char **pp)\\r\\n{\\r\\nint bagnid, v = 0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nbagnid = OBJ_obj2nid (a->type);\\r\\nM_ASN1_I2D_len (a->type, i2d_ASN1_OBJECT);\\r\\nswitch (bagnid) {\\r\\ncase NID_keyBag:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.keybag,\\r\\ni2d_PKCS8_PRIV_KEY_INFO, 0, v);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.shkeybag,\\r\\ni2d_X509_SIG, 0, v);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nM_ASN1_I2D_len_EXP_SEQUENCE_opt (a->value.safes,\\r\\ni2d_PKCS12_SAFEBAG, 0, V_ASN1_SEQUENCE, v);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\ncase NID_crlBag:\\r\\ncase NID_secretBag:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.bag,\\r\\ni2d_PKCS12_BAGS, 0, v);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.other,\\r\\ni2d_ASN1_TYPE, 0, v);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_len_SET_type (X509_ATTRIBUTE,a->attrib, i2d_X509_ATTRIBUTE);\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->type, i2d_ASN1_OBJECT);\\r\\nswitch (bagnid) {\\r\\ncase NID_keyBag:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.keybag,\\r\\ni2d_PKCS8_PRIV_KEY_INFO, 0, v);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.shkeybag,\\r\\ni2d_X509_SIG, 0, v);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nM_ASN1_I2D_put_EXP_SEQUENCE_opt (a->value.safes,\\r\\ni2d_PKCS12_SAFEBAG, 0, V_ASN1_SEQUENCE, v);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\ncase NID_crlBag:\\r\\ncase NID_secretBag:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.bag,\\r\\ni2d_PKCS12_BAGS, 0, v);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.other,\\r\\ni2d_ASN1_TYPE, 0, v);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_put_SET_type (X509_ATTRIBUTE, a->attrib, i2d_X509_ATTRIBUTE);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_SAFEBAG_new(void)\\r\\n{\\r\\nPKCS12_SAFEBAG *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKCS12_SAFEBAG);\\r\\nret->type=NULL;\\r\\nret->value.other=NULL;\\r\\nM_ASN1_New(ret->attrib, sk_X509_ATTRIBUTE_new_null);\\r\\nret->rest=NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS12_SAFEBAG_NEW);\\r\\n}\\r\\nPKCS12_SAFEBAG *d2i_PKCS12_SAFEBAG(PKCS12_SAFEBAG **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint bagnid;\\r\\nM_ASN1_D2I_vars(a,PKCS12_SAFEBAG *,PKCS12_SAFEBAG_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->type, d2i_ASN1_OBJECT);\\r\\nbagnid = OBJ_obj2nid (ret->type);\\r\\nswitch (bagnid) {\\r\\ncase NID_keyBag:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.keybag,\\r\\nd2i_PKCS8_PRIV_KEY_INFO, 0);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.shkeybag,\\r\\nd2i_X509_SIG, 0);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nM_ASN1_D2I_get_EXP_set_opt(ret->value.safes,\\r\\nd2i_PKCS12_SAFEBAG, PKCS12_SAFEBAG_free,\\r\\n0, V_ASN1_SEQUENCE);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\ncase NID_crlBag:\\r\\ncase NID_secretBag:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.bag,\\r\\nd2i_PKCS12_BAGS, 0);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.other,\\r\\nd2i_ASN1_TYPE, 0);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_D2I_get_set_opt_type(X509_ATTRIBUTE,ret->attrib,\\r\\nd2i_X509_ATTRIBUTE,X509_ATTRIBUTE_free);\\r\\nM_ASN1_D2I_Finish(a, PKCS12_SAFEBAG_free, ASN1_F_D2I_PKCS12_SAFEBAG);\\r\\n}\\r\\nvoid PKCS12_SAFEBAG_free (PKCS12_SAFEBAG *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nswitch (OBJ_obj2nid(a->type)) {\\r\\ncase NID_keyBag:\\r\\nPKCS8_PRIV_KEY_INFO_free (a->value.keybag);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nX509_SIG_free (a->value.shkeybag);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\ncase NID_crlBag:\\r\\ncase NID_secretBag:\\r\\nPKCS12_BAGS_free (a->value.bag);\\r\\nbreak;\\r\\ndefault:\\r\\nASN1_TYPE_free (a->value.other);\\r\\nbreak;\\r\\n}\\r\\nASN1_OBJECT_free (a->type);\\r\\nsk_X509_ATTRIBUTE_pop_free (a->attrib, X509_ATTRIBUTE_free);\\r\\nFree (a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_cbc_c", "target": 0, "func": "void BF_cbc_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nBF_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0,tin1;\\r\\nregister BF_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha1_one_c", "target": 0, "func": "unsigned char *SHA1(const unsigned char *d, unsigned long n, unsigned char *md)\\r\\n{\\r\\nSHA_CTX c;\\r\\nstatic unsigned char m[SHA_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nSHA1_Init(&c);\\r\\nSHA1_Update(&c,d,n);\\r\\nSHA1_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_ssl_c", "target": 0, "func": "int RSA_padding_add_SSLv23(unsigned char *to, int tlen, unsigned char *from,\\r\\nint flen)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-11))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_SSLV23,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=2;\\r\\nj=tlen-3-8-flen;\\r\\nRAND_bytes(p,j);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nRAND_bytes(p,1);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\nmemset(p,3,8);\\r\\np+=8;\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_SSLv23(unsigned char *to, int tlen, unsigned char *from,\\r\\nint flen, int num)\\r\\n{\\r\\nint i,j,k;\\r\\nunsigned char *p;\\r\\np=from;\\r\\nif (flen < 10)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_DATA_TOO_SMALL);\\r\\nreturn(-1);\\r\\n}\\r\\nif ((num != (flen+1)) || (*(p++) != 02))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_BLOCK_TYPE_IS_NOT_02);\\r\\nreturn(-1);\\r\\n}\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\nif (*(p++) == 0) break;\\r\\nif ((i == j) || (i < 8))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (k= -8; k<0; k++)\\r\\n{\\r\\nif (p[k] != 0x03) break;\\r\\n}\\r\\nif (k == 0)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,RSA_R_SSLV3_ROLLBACK_ATTACK);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_attrib_c", "target": 0, "func": "int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a, unsigned char **pp)\\r\\n{\\r\\nint k=0;\\r\\nint r=0,ret=0;\\r\\nunsigned char **p=NULL;\\r\\nif (a == NULL) return(0);\\r\\np=NULL;\\r\\nfor (;;)\\r\\n{\\r\\nif (k)\\r\\n{\\r\\nr=ASN1_object_size(1,ret,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(r);\\r\\np=pp;\\r\\nASN1_put_object(p,1,ret,V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL);\\r\\n}\\r\\nret+=i2d_ASN1_OBJECT(a->object,p);\\r\\nif (a->set)\\r\\nret+=i2d_ASN1_SET_OF_ASN1_TYPE(a->value.set,p,i2d_ASN1_TYPE,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);\\r\\nelse\\r\\nret+=i2d_ASN1_TYPE(a->value.single,p);\\r\\nif (k++) return(r);\\r\\n}\\r\\n}\\r\\nX509_ATTRIBUTE *d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_ATTRIBUTE *,X509_ATTRIBUTE_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->object,d2i_ASN1_OBJECT);\\r\\nif ((c.slen != 0) &&\\r\\n(M_ASN1_next == (V_ASN1_CONSTRUCTED|V_ASN1_UNIVERSAL|V_ASN1_SET)))\\r\\n{\\r\\nret->set=1;\\r\\nM_ASN1_D2I_get_set_type(ASN1_TYPE,ret->value.set,d2i_ASN1_TYPE,\\r\\nASN1_TYPE_free);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret->set=0;\\r\\nM_ASN1_D2I_get(ret->value.single,d2i_ASN1_TYPE);\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_ATTRIBUTE_free,ASN1_F_D2I_X509_ATTRIBUTE);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int atrtype, void *value)\\r\\n{\\r\\nX509_ATTRIBUTE *ret=NULL;\\r\\nASN1_TYPE *val=NULL;\\r\\nif ((ret=X509_ATTRIBUTE_new()) == NULL)\\r\\nreturn(NULL);\\r\\nret->object=OBJ_nid2obj(nid);\\r\\nret->set=1;\\r\\nif ((ret->value.set=sk_ASN1_TYPE_new_null()) == NULL) goto err;\\r\\nif ((val=ASN1_TYPE_new()) == NULL) goto err;\\r\\nif (!sk_ASN1_TYPE_push(ret->value.set,val)) goto err;\\r\\nASN1_TYPE_set(val,atrtype,value);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL) X509_ATTRIBUTE_free(ret);\\r\\nif (val != NULL) ASN1_TYPE_free(val);\\r\\nreturn(NULL);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_ATTRIBUTE_new(void)\\r\\n{\\r\\nX509_ATTRIBUTE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_ATTRIBUTE);\\r\\nret->object=OBJ_nid2obj(NID_undef);\\r\\nret->set=0;\\r\\nret->value.ptr=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_ATTRIBUTE_NEW);\\r\\n}\\r\\nvoid X509_ATTRIBUTE_free(X509_ATTRIBUTE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->object);\\r\\nif (a->set)\\r\\nsk_ASN1_TYPE_pop_free(a->value.set,ASN1_TYPE_free);\\r\\nelse\\r\\nASN1_TYPE_free(a->value.single);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_lhash_c", "target": 0, "func": "void lh_free(LHASH *lh)\\r\\n{\\r\\nunsigned int i;\\r\\nLHASH_NODE *n,*nn;\\r\\nif(lh == NULL)\\r\\nreturn;\\r\\nfor (i=0; i<lh->num_nodes; i++)\\r\\n{\\r\\nn=lh->b[i];\\r\\nwhile (n != NULL)\\r\\n{\\r\\nnn=n->next;\\r\\nFree(n);\\r\\nn=nn;\\r\\n}\\r\\n}\\r\\nFree((char *)lh->b);\\r\\nFree((char *)lh);\\r\\n}\\r\\nchar *lh_insert(LHASH *lh, char *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn,**rn;\\r\\nchar *ret;\\r\\nlh->error=0;\\r\\nif (lh->up_load <= (lh->num_items*LH_LOAD_MULT/lh->num_nodes))\\r\\nexpand(lh);\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nif ((nn=(LHASH_NODE *)Malloc(sizeof(LHASH_NODE))) == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nreturn(NULL);\\r\\n}\\r\\nnn->data=data;\\r\\nnn->next=NULL;\\r\\n#ifndef NO_HASH_COMP\\r\\nnn->hash=hash;\\r\\n#endif\\r\\n*rn=nn;\\r\\nret=NULL;\\r\\nlh->num_insert++;\\r\\nlh->num_items++;\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= (*rn)->data;\\r\\n(*rn)->data=data;\\r\\nlh->num_replace++;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nchar *lh_delete(LHASH *lh, char *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn,**rn;\\r\\nchar *ret;\\r\\nlh->error=0;\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nlh->num_no_delete++;\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nnn= *rn;\\r\\n*rn=nn->next;\\r\\nret=nn->data;\\r\\nFree((char *)nn);\\r\\nlh->num_delete++;\\r\\n}\\r\\nlh->num_items--;\\r\\nif ((lh->num_nodes > MIN_NODES) &&\\r\\n(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))\\r\\ncontract(lh);\\r\\nreturn(ret);\\r\\n}\\r\\nchar *lh_retrieve(LHASH *lh, char *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE **rn;\\r\\nchar *ret;\\r\\nlh->error=0;\\r\\nrn=getrn(lh,data,&hash);\\r\\nif (*rn == NULL)\\r\\n{\\r\\nlh->num_retrieve_miss++;\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= (*rn)->data;\\r\\nlh->num_retrieve++;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid lh_doall(LHASH *lh, void (*func)())\\r\\n{\\r\\nlh_doall_arg(lh,func,NULL);\\r\\n}\\r\\nvoid lh_doall_arg(LHASH *lh, void (*func)(), char *arg)\\r\\n{\\r\\nint i;\\r\\nLHASH_NODE *a,*n;\\r\\nfor (i=lh->num_nodes-1; i>=0; i--)\\r\\n{\\r\\na=lh->b[i];\\r\\nwhile (a != NULL)\\r\\n{\\r\\nn=a->next;\\r\\nfunc(a->data,arg);\\r\\na=n;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void expand(LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n,**n1,**n2,*np;\\r\\nunsigned int p,i,j;\\r\\nunsigned long hash,nni;\\r\\nlh->num_nodes++;\\r\\nlh->num_expands++;\\r\\np=(int)lh->p++;\\r\\nn1= &(lh->b[p]);\\r\\nn2= &(lh->b[p+(int)lh->pmax]);\\r\\n*n2=NULL;\\r\\nnni=lh->num_alloc_nodes;\\r\\nfor (np= *n1; np != NULL; )\\r\\n{\\r\\n#ifndef NO_HASH_COMP\\r\\nhash=np->hash;\\r\\n#else\\r\\nhash=(*(lh->hash))(np->data);\\r\\nlh->num_hash_calls++;\\r\\n#endif\\r\\nif ((hash%nni) != p)\\r\\n{\\r\\n*n1= (*n1)->next;\\r\\nnp->next= *n2;\\r\\n*n2=np;\\r\\n}\\r\\nelse\\r\\nn1= &((*n1)->next);\\r\\nnp= *n1;\\r\\n}\\r\\nif ((lh->p) >= lh->pmax)\\r\\n{\\r\\nj=(int)lh->num_alloc_nodes*2;\\r\\nn=(LHASH_NODE **)Realloc((char *)lh->b,\\r\\n(unsigned int)sizeof(LHASH_NODE *)*j);\\r\\nif (n == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nlh->p=0;\\r\\nreturn;\\r\\n}\\r\\nfor (i=(int)lh->num_alloc_nodes; i<j; i++)\\r\\nn[i]=NULL;\\r\\nlh->pmax=lh->num_alloc_nodes;\\r\\nlh->num_alloc_nodes=j;\\r\\nlh->num_expand_reallocs++;\\r\\nlh->p=0;\\r\\nlh->b=n;\\r\\n}\\r\\n}\\r\\nstatic void contract(LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n,*n1,*np;\\r\\nnp=lh->b[lh->p+lh->pmax-1];\\r\\nlh->b[lh->p+lh->pmax-1]=NULL;\\r\\nif (lh->p == 0)\\r\\n{\\r\\nn=(LHASH_NODE **)Realloc((char *)lh->b,\\r\\n(unsigned int)(sizeof(LHASH_NODE *)*lh->pmax));\\r\\nif (n == NULL)\\r\\n{\\r\\nlh->error++;\\r\\nreturn;\\r\\n}\\r\\nlh->num_contract_reallocs++;\\r\\nlh->num_alloc_nodes/=2;\\r\\nlh->pmax/=2;\\r\\nlh->p=lh->pmax-1;\\r\\nlh->b=n;\\r\\n}\\r\\nelse\\r\\nlh->p--;\\r\\nlh->num_nodes--;\\r\\nlh->num_contracts++;\\r\\nn1=lh->b[(int)lh->p];\\r\\nif (n1 == NULL)\\r\\nlh->b[(int)lh->p]=np;\\r\\nelse\\r\\n{\\r\\nwhile (n1->next != NULL)\\r\\nn1=n1->next;\\r\\nn1->next=np;\\r\\n}\\r\\n}\\r\\nstatic LHASH_NODE **getrn(LHASH *lh, char *data, unsigned long *rhash)\\r\\n{\\r\\nLHASH_NODE **ret,*n1;\\r\\nunsigned long hash,nn;\\r\\nint (*cf)();\\r\\nhash=(*(lh->hash))(data);\\r\\nlh->num_hash_calls++;\\r\\n*rhash=hash;\\r\\nnn=hash%lh->pmax;\\r\\nif (nn < lh->p)\\r\\nnn=hash%lh->num_alloc_nodes;\\r\\ncf=lh->comp;\\r\\nret= &(lh->b[(int)nn]);\\r\\nfor (n1= *ret; n1 != NULL; n1=n1->next)\\r\\n{\\r\\n#ifndef NO_HASH_COMP\\r\\nlh->num_hash_comps++;\\r\\nif (n1->hash != hash)\\r\\n{\\r\\nret= &(n1->next);\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\nlh->num_comp_calls++;\\r\\nif ((*cf)(n1->data,data) == 0)\\r\\nbreak;\\r\\nret= &(n1->next);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nunsigned long lh_strhash(const char *c)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nlong n;\\r\\nunsigned long v;\\r\\nint r;\\r\\nif ((c == NULL) || (*c == '\\0'))\\r\\nreturn(ret);\\r\\nn=0x100;\\r\\nwhile (*c)\\r\\n{\\r\\nv=n|(*c);\\r\\nn+=0x100;\\r\\nr= (int)((v>>2)^v)&0x0f;\\r\\nret=(ret<<r)|(ret>>(32-r));\\r\\nret&=0xFFFFFFFFL;\\r\\nret^=v*v;\\r\\nc++;\\r\\n}\\r\\nreturn((ret>>16)^ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc5speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC5_32_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC5_32_encrypt(data,&sch);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncb=count;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC5_32_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC5_32_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\nRC5_32_set_key(&sch,16,key,12);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC5_32_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC5_32_encrypt %ld times\\n\",cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cb); count+=4)\\r\\n{\\r\\nunsigned long data[2];\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\nRC5_32_encrypt(data,&sch);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_encrypt's in %.2f second\\n\",count,d);\\r\\nb=((double)COUNT(cb)*8)/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC5_32_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC5_32_cbc_encrypt %ld times on %ld byte blocks\\n\",cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC5_32_cbc_encrypt(buf,buf,BUFSIZE,&sch,\\r\\n&(key[0]),RC5_ENCRYPT);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC5_32_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC5_32/12/16 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC5_32/12/16 raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\",b,8.0e6/b);\\r\\nprintf(\"RC5_32/12/16 cbc bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_txt_c", "target": 0, "func": "int SSL_SESSION_print_fp(FILE *fp, SSL_SESSION *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file_internal())) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SESSION_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=SSL_SESSION_print(b,x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_SESSION_print(BIO *bp, SSL_SESSION *x)\\r\\n{\\r\\nunsigned int i;\\r\\nchar str[128],*s;\\r\\nif (x == NULL) goto err;\\r\\nif (BIO_puts(bp,\"SSL-Session:\\n\") <= 0) goto err;\\r\\nif (x->ssl_version == SSL2_VERSION)\\r\\ns=\"SSLv2\";\\r\\nelse if (x->ssl_version == SSL3_VERSION)\\r\\ns=\"SSLv3\";\\r\\nelse if (x->ssl_version == TLS1_VERSION)\\r\\ns=\"TLSv1\";\\r\\nelse\\r\\ns=\"unknown\";\\r\\nsprintf(str,\" Protocol : %s\\n\",s);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nif (x->cipher == NULL)\\r\\n{\\r\\nif (((x->cipher_id) & 0xff000000) == 0x02000000)\\r\\nsprintf(str,\" Cipher : %06lX\\n\",x->cipher_id&0xffffff);\\r\\nelse\\r\\nsprintf(str,\" Cipher : %04lX\\n\",x->cipher_id&0xffff);\\r\\n}\\r\\nelse\\r\\nsprintf(str,\" Cipher : %s\\n\",(x->cipher == NULL)?\"unknown\":x->cipher->name);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nif (BIO_puts(bp,\" Session-ID: \") <= 0) goto err;\\r\\nfor (i=0; i<x->session_id_length; i++)\\r\\n{\\r\\nsprintf(str,\"%02X\",x->session_id[i]);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\nSession-ID-ctx: \") <= 0) goto err;\\r\\nfor (i=0; i<x->sid_ctx_length; i++)\\r\\n{\\r\\nsprintf(str,\"%02X\",x->sid_ctx[i]);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n Master-Key: \") <= 0) goto err;\\r\\nfor (i=0; i<(unsigned int)x->master_key_length; i++)\\r\\n{\\r\\nsprintf(str,\"%02X\",x->master_key[i]);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n Key-Arg : \") <= 0) goto err;\\r\\nif (x->key_arg_length == 0)\\r\\n{\\r\\nif (BIO_puts(bp,\"None\") <= 0) goto err;\\r\\n}\\r\\nelse\\r\\nfor (i=0; i<x->key_arg_length; i++)\\r\\n{\\r\\nsprintf(str,\"%02X\",x->key_arg[i]);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (x->compress_meth != 0)\\r\\n{\\r\\nSSL_COMP *comp;\\r\\nssl_cipher_get_evp(x,NULL,NULL,&comp);\\r\\nif (comp == NULL)\\r\\n{\\r\\nsprintf(str,\"\\n Compression: %d\",x->compress_meth);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsprintf(str,\"\\n Compression: %d (%s)\",\\r\\ncomp->id,comp->method->name);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\n}\\r\\nif (x->time != 0L)\\r\\n{\\r\\nsprintf(str,\"\\n Start Time: %ld\",x->time);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (x->timeout != 0L)\\r\\n{\\r\\nsprintf(str,\"\\n Timeout : %ld (sec)\",x->timeout);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n\") <= 0) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s2_meth_c", "target": 0, "func": "static SSL_METHOD *ssl2_get_method(int ver)\\r\\n{\\r\\nif (ver == SSL2_VERSION)\\r\\nreturn(SSLv2_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv2_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv2_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv2_data,(char *)sslv2_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv2_data.ssl_connect=ssl2_connect;\\r\\nSSLv2_data.ssl_accept=ssl2_accept;\\r\\nSSLv2_data.get_ssl_method=ssl2_get_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv2_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_sqr_c", "target": 0, "func": "int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nint max,al;\\r\\nBIGNUM *tmp,*rr;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\"BN_sqr %d * %d\\n\",a->top,a->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\ntmp= &(ctx->bn[ctx->tos]);\\r\\nrr=(a != r)?r: (&ctx->bn[ctx->tos+1]);\\r\\nal=a->top;\\r\\nif (al <= 0)\\r\\n{\\r\\nr->top=0;\\r\\nreturn(1);\\r\\n}\\r\\nmax=(al+al);\\r\\nif (bn_wexpand(rr,max+1) == NULL) return(0);\\r\\nr->neg=0;\\r\\nif (al == 4)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(rr->d,a->d,4,t);\\r\\n#else\\r\\nbn_sqr_comba4(rr->d,a->d);\\r\\n#endif\\r\\n}\\r\\nelse if (al == 8)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(rr->d,a->d,8,t);\\r\\n#else\\r\\nbn_sqr_comba8(rr->d,a->d);\\r\\n#endif\\r\\n}\\r\\nelse\\r\\n{\\r\\n#if defined(BN_RECURSION)\\r\\nif (al < BN_SQR_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nBN_ULONG t[BN_SQR_RECURSIVE_SIZE_NORMAL*2];\\r\\nbn_sqr_normal(rr->d,a->d,al,t);\\r\\n}\\r\\nelse\\r\\n{\\r\\nint j,k;\\r\\nj=BN_num_bits_word((BN_ULONG)al);\\r\\nj=1<<(j-1);\\r\\nk=j+j;\\r\\nif (al == j)\\r\\n{\\r\\nif (bn_wexpand(a,k*2) == NULL) return(0);\\r\\nif (bn_wexpand(tmp,k*2) == NULL) return(0);\\r\\nbn_sqr_recursive(rr->d,a->d,al,tmp->d);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (bn_wexpand(tmp,max) == NULL) return(0);\\r\\nbn_sqr_normal(rr->d,a->d,al,tmp->d);\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (bn_wexpand(tmp,max) == NULL) return(0);\\r\\nbn_sqr_normal(rr->d,a->d,al,tmp->d);\\r\\n#endif\\r\\n}\\r\\nrr->top=max;\\r\\nif ((max > 0) && (rr->d[max-1] == 0)) rr->top--;\\r\\nif (rr != r) BN_copy(r,rr);\\r\\nreturn(1);\\r\\n}\\r\\nvoid bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp)\\r\\n{\\r\\nint i,j,max;\\r\\nBN_ULONG *ap,*rp;\\r\\nmax=n*2;\\r\\nap=a;\\r\\nrp=r;\\r\\nrp[0]=rp[max-1]=0;\\r\\nrp++;\\r\\nj=n;\\r\\nif (--j > 0)\\r\\n{\\r\\nap++;\\r\\nrp[j]=bn_mul_words(rp,ap,j,ap[-1]);\\r\\nrp+=2;\\r\\n}\\r\\nfor (i=n-2; i>0; i--)\\r\\n{\\r\\nj--;\\r\\nap++;\\r\\nrp[j]=bn_mul_add_words(rp,ap,j,ap[-1]);\\r\\nrp+=2;\\r\\n}\\r\\nbn_add_words(r,r,r,max);\\r\\nbn_sqr_words(tmp,a,n);\\r\\nbn_add_words(r,r,tmp,max);\\r\\n}\\r\\nvoid bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *t)\\r\\n{\\r\\nint n=n2/2;\\r\\nint zero,c1;\\r\\nBN_ULONG ln,lo,*p;\\r\\n#ifdef BN_COUNT\\r\\nprintf(\" bn_sqr_recursive %d * %d\\n\",n2,n2);\\r\\n#endif\\r\\nif (n2 == 4)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r,a,4,t);\\r\\n#else\\r\\nbn_sqr_comba4(r,a);\\r\\n#endif\\r\\nreturn;\\r\\n}\\r\\nelse if (n2 == 8)\\r\\n{\\r\\n#ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r,a,8,t);\\r\\n#else\\r\\nbn_sqr_comba8(r,a);\\r\\n#endif\\r\\nreturn;\\r\\n}\\r\\nif (n2 < BN_SQR_RECURSIVE_SIZE_NORMAL)\\r\\n{\\r\\nbn_sqr_normal(r,a,n2,t);\\r\\nreturn;\\r\\n}\\r\\nc1=bn_cmp_words(a,&(a[n]),n);\\r\\nzero=0;\\r\\nif (c1 > 0)\\r\\nbn_sub_words(t,a,&(a[n]),n);\\r\\nelse if (c1 < 0)\\r\\nbn_sub_words(t,&(a[n]),a,n);\\r\\nelse\\r\\nzero=1;\\r\\np= &(t[n2*2]);\\r\\nif (!zero)\\r\\nbn_sqr_recursive(&(t[n2]),t,n,p);\\r\\nelse\\r\\nmemset(&(t[n2]),0,n*sizeof(BN_ULONG));\\r\\nbn_sqr_recursive(r,a,n,p);\\r\\nbn_sqr_recursive(&(r[n2]),&(a[n]),n,p);\\r\\nc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\\r\\nc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\\r\\nc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\\r\\nif (c1)\\r\\n{\\r\\np= &(r[n+n2]);\\r\\nlo= *p;\\r\\nln=(lo+c1)&BN_MASK2;\\r\\n*p=ln;\\r\\nif (ln < (BN_ULONG)c1)\\r\\n{\\r\\ndo {\\r\\np++;\\r\\nlo= *p;\\r\\nln=(lo+1)&BN_MASK2;\\r\\n*p=ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_base64_c", "target": 0, "func": "main()\\r\\n{\\r\\nint i;\\r\\nBIO *mbio,*b64bio,*bio;\\r\\nchar buf[512];\\r\\nchar *p;\\r\\nmbio=BIO_new(BIO_s_mem());\\r\\nb64bio=BIO_new(BIO_f_base64());\\r\\nbio=BIO_push(b64bio,mbio);\\r\\nfor (;;)\\r\\n{\\r\\ni=fread(buf,1,512,stdin);\\r\\nif (i <= 0) break;\\r\\nBIO_write(bio,buf,i);\\r\\n}\\r\\nBIO_flush(bio);\\r\\nprintf(\"We have %d bytes available\\n\",BIO_pending(mbio));\\r\\ni=(int)BIO_ctrl(mbio,BIO_CTRL_INFO,0,(char *)&p);\\r\\nprintf(\"%d\\n\",i);\\r\\nfwrite(\"---\\n\",1,4,stdout);\\r\\nfwrite(p,1,i,stdout);\\r\\nfwrite(\"---\\n\",1,4,stdout);\\r\\nBIO_free_all(bio);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_errstr_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i,ret=0;\\r\\nchar buf[256];\\r\\nunsigned long l;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nSSL_load_error_strings();\\r\\nif ((argc > 1) && (strcmp(argv[1],\"-stats\") == 0))\\r\\n{\\r\\nBIO *out=NULL;\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((out != NULL) && BIO_set_fp(out,stdout,BIO_NOCLOSE))\\r\\n{\\r\\nlh_node_stats_bio((LHASH *)ERR_get_string_table(),out);\\r\\nlh_stats_bio((LHASH *)ERR_get_string_table(),out);\\r\\nlh_node_usage_stats_bio((LHASH *)\\r\\nERR_get_string_table(),out);\\r\\n}\\r\\nif (out != NULL) BIO_free(out);\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nif (sscanf(argv[i],\"%lx\",&l))\\r\\nprintf(\"%s\\n\",ERR_error_string(l,buf));\\r\\nelse\\r\\n{\\r\\nprintf(\"%s: bad error code\\n\",argv[i]);\\r\\nprintf(\"usage: errstr [-stats] <errno> ...\\n\");\\r\\nret++;\\r\\n}\\r\\n}\\r\\nEXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_pkt_c", "target": 1, "func": "static int ssl3_read_n(SSL *s, int n, int max, int extend)\\r\\n{\\r\\nint i,off,newb;\\r\\nif (s->s3->rbuf.left >= (int)n)\\r\\n{\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\n{\\r\\ns->packet= &(s->s3->rbuf.buf[s->s3->rbuf.offset]);\\r\\ns->packet_length=n;\\r\\n}\\r\\ns->s3->rbuf.left-=n;\\r\\ns->s3->rbuf.offset+=n;\\r\\nreturn(n);\\r\\n}\\r\\nif (!s->read_ahead) max=n;\\r\\nif (max > SSL3_RT_MAX_PACKET_SIZE)\\r\\nmax=SSL3_RT_MAX_PACKET_SIZE;\\r\\noff=0;\\r\\nif ( (s->s3->rbuf.left != 0) ||\\r\\n((s->packet_length != 0) && extend))\\r\\n{\\r\\nnewb=s->s3->rbuf.left;\\r\\nif (extend)\\r\\n{\\r\\noff=s->packet_length;\\r\\nif (s->packet != s->s3->rbuf.buf)\\r\\nmemcpy(s->s3->rbuf.buf,s->packet,newb+off);\\r\\n}\\r\\nelse if (s->s3->rbuf.offset != 0)\\r\\n{\\r\\nmemcpy(s->s3->rbuf.buf,\\r\\n&(s->s3->rbuf.buf[s->s3->rbuf.offset]),newb);\\r\\ns->s3->rbuf.offset=0;\\r\\n}\\r\\ns->s3->rbuf.left=0;\\r\\n}\\r\\nelse\\r\\nnewb=0;\\r\\ns->packet=s->s3->rbuf.buf;\\r\\nwhile (newb < n)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->rbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_READING;\\r\\ni=BIO_read(s->rbio,\\r\\n(char *)&(s->s3->rbuf.buf[off+newb]),\\r\\nmax-newb);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_N,SSL_R_READ_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->rbuf.left+=newb;\\r\\nreturn(i);\\r\\n}\\r\\nnewb+=i;\\r\\n}\\r\\nif (newb > n)\\r\\n{\\r\\ns->s3->rbuf.offset=n+off;\\r\\ns->s3->rbuf.left=newb-n;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->rbuf.offset=0;\\r\\ns->s3->rbuf.left=0;\\r\\n}\\r\\nif (extend)\\r\\ns->packet_length+=n;\\r\\nelse\\r\\ns->packet_length+=n;\\r\\nreturn(n);\\r\\n}\\r\\nstatic int ssl3_get_record(SSL *s)\\r\\n{\\r\\nint ssl_major,ssl_minor,al;\\r\\nint n,i,ret= -1;\\r\\nSSL3_BUFFER *rb;\\r\\nSSL3_RECORD *rr;\\r\\nSSL_SESSION *sess;\\r\\nunsigned char *p;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nshort version;\\r\\nunsigned int mac_size;\\r\\nint clear=0,extra;\\r\\nrr= &(s->s3->rrec);\\r\\nrb= &(s->s3->rbuf);\\r\\nsess=s->session;\\r\\nif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\\r\\nextra=SSL3_RT_MAX_EXTRA;\\r\\nelse\\r\\nextra=0;\\r\\nagain:\\r\\nif ( (s->rstate != SSL_ST_READ_BODY) ||\\r\\n(s->packet_length < SSL3_RT_HEADER_LENGTH))\\r\\n{\\r\\nn=ssl3_read_n(s,SSL3_RT_HEADER_LENGTH,\\r\\nSSL3_RT_MAX_PACKET_SIZE,0);\\r\\nif (n <= 0) return(n);\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\np=s->packet;\\r\\nrr->type= *(p++);\\r\\nssl_major= *(p++);\\r\\nssl_minor= *(p++);\\r\\nversion=(ssl_major<<8)|ssl_minor;\\r\\nn2s(p,rr->length);\\r\\nif (s->first_packet)\\r\\n{\\r\\ns->first_packet=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (version != s->version)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ns->version=version;\\r\\nal=SSL_AD_PROTOCOL_VERSION;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif ((version>>8) != SSL3_VERSION_MAJOR)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_WRONG_VERSION_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nif (rr->length >\\r\\n(unsigned int)SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PACKET_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\ns->rstate=SSL_ST_READ_BODY;\\r\\n}\\r\\nif (s->rstate == SSL_ST_READ_BODY)\\r\\n{\\r\\nif (rr->length > (s->packet_length-SSL3_RT_HEADER_LENGTH))\\r\\n{\\r\\ni=rr->length;\\r\\nn=ssl3_read_n(s,i,i,1);\\r\\nif (n <= 0) return(n);\\r\\n}\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\n}\\r\\nrr->input= &(s->packet[SSL3_RT_HEADER_LENGTH]);\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nif (rr->length > (unsigned int)SSL3_RT_MAX_ENCRYPTED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->data=rr->input;\\r\\nif (!s->method->ssl3_enc->enc(s,0))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"dec %d\\n\",rr->length);\\r\\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_read_ctx == NULL) ||\\r\\n(s->read_hash == NULL))\\r\\nclear=1;\\r\\nif (!clear)\\r\\n{\\r\\nmac_size=EVP_MD_size(s->read_hash);\\r\\nif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+extra+mac_size)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_PRE_MAC_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nif (rr->length < mac_size)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_LENGTH_TOO_SHORT);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->length-=mac_size;\\r\\ni=s->method->ssl3_enc->mac(s,md,0);\\r\\nif (memcmp(md,&(rr->data[rr->length]),mac_size) != 0)\\r\\n{\\r\\nal=SSL_AD_BAD_RECORD_MAC;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_MAC_DECODE);\\r\\nret= -1;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (s->expand != NULL)\\r\\n{\\r\\nif (rr->length >\\r\\n(unsigned int)SSL3_RT_MAX_COMPRESSED_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!do_uncompress(s))\\r\\n{\\r\\nal=SSL_AD_DECOMPRESSION_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_BAD_DECOMPRESSION);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (rr->length > (unsigned int)SSL3_RT_MAX_PLAIN_LENGTH+extra)\\r\\n{\\r\\nal=SSL_AD_RECORD_OVERFLOW;\\r\\nSSLerr(SSL_F_SSL3_GET_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->off=0;\\r\\ns->packet_length=0;\\r\\nif (rr->length == 0) goto again;\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int do_uncompress(SSL *ssl)\\r\\n{\\r\\nint i;\\r\\nSSL3_RECORD *rr;\\r\\nrr= &(ssl->s3->rrec);\\r\\ni=COMP_expand_block(ssl->expand,rr->comp,\\r\\nSSL3_RT_MAX_PLAIN_LENGTH,rr->data,(int)rr->length);\\r\\nif (i < 0)\\r\\nreturn(0);\\r\\nelse\\r\\nrr->length=i;\\r\\nrr->data=rr->comp;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int do_compress(SSL *ssl)\\r\\n{\\r\\nint i;\\r\\nSSL3_RECORD *wr;\\r\\nwr= &(ssl->s3->wrec);\\r\\ni=COMP_compress_block(ssl->compress,wr->data,\\r\\nSSL3_RT_MAX_COMPRESSED_LENGTH,\\r\\nwr->input,(int)wr->length);\\r\\nif (i < 0)\\r\\nreturn(0);\\r\\nelse\\r\\nwr->length=i;\\r\\nwr->input=wr->data;\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_write_bytes(SSL *s, int type, const void *_buf, int len)\\r\\n{\\r\\nconst unsigned char *buf=_buf;\\r\\nunsigned int tot,n,nw;\\r\\nint i;\\r\\ns->rwstate=SSL_NOTHING;\\r\\ntot=s->s3->wnum;\\r\\ns->s3->wnum=0;\\r\\nif (SSL_in_init(s) && !s->in_handshake)\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nn=(len-tot);\\r\\nfor (;;)\\r\\n{\\r\\nif (n > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\nnw=SSL3_RT_MAX_PLAIN_LENGTH;\\r\\nelse\\r\\nnw=n;\\r\\ni=do_ssl3_write(s,type,&(buf[tot]),nw);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->wnum=tot;\\r\\nreturn(i);\\r\\n}\\r\\nif (type == SSL3_RT_HANDSHAKE)\\r\\nssl3_finish_mac(s,&(buf[tot]),i);\\r\\nif ((i == (int)n) ||\\r\\n(type == SSL3_RT_APPLICATION_DATA &&\\r\\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE)))\\r\\n{\\r\\nreturn(tot+i);\\r\\n}\\r\\nn-=i;\\r\\ntot+=i;\\r\\n}\\r\\n}\\r\\nstatic int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\\r\\nunsigned int len)\\r\\n{\\r\\nunsigned char *p,*plen;\\r\\nint i,mac_size,clear=0;\\r\\nSSL3_RECORD *wr;\\r\\nSSL3_BUFFER *wb;\\r\\nSSL_SESSION *sess;\\r\\nif (s->s3->wbuf.left != 0)\\r\\nreturn(ssl3_write_pending(s,type,buf,len));\\r\\nif (s->s3->alert_dispatch)\\r\\n{\\r\\ni=ssl3_dispatch_alert(s);\\r\\nif (i <= 0)\\r\\nreturn(i);\\r\\n}\\r\\nif (len <= 0) return(len);\\r\\nwr= &(s->s3->wrec);\\r\\nwb= &(s->s3->wbuf);\\r\\nsess=s->session;\\r\\nif ( (sess == NULL) ||\\r\\n(s->enc_write_ctx == NULL) ||\\r\\n(s->write_hash == NULL))\\r\\nclear=1;\\r\\nif (clear)\\r\\nmac_size=0;\\r\\nelse\\r\\nmac_size=EVP_MD_size(s->write_hash);\\r\\np=wb->buf;\\r\\n*(p++)=type&0xff;\\r\\nwr->type=type;\\r\\n*(p++)=(s->version>>8);\\r\\n*(p++)=s->version&0xff;\\r\\nplen=p;\\r\\np+=2;\\r\\nwr->data=p;\\r\\nwr->length=(int)len;\\r\\nwr->input=(unsigned char *)buf;\\r\\nif (s->compress != NULL)\\r\\n{\\r\\nif (!do_compress(s))\\r\\n{\\r\\nSSLerr(SSL_F_DO_SSL3_WRITE,SSL_R_COMPRESSION_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(wr->data,wr->input,wr->length);\\r\\nwr->input=wr->data;\\r\\n}\\r\\nif (mac_size != 0)\\r\\n{\\r\\ns->method->ssl3_enc->mac(s,&(p[wr->length]),1);\\r\\nwr->length+=mac_size;\\r\\nwr->input=p;\\r\\nwr->data=p;\\r\\n}\\r\\ns->method->ssl3_enc->enc(s,1);\\r\\ns2n(wr->length,plen);\\r\\nwr->type=type;\\r\\nwr->length+=SSL3_RT_HEADER_LENGTH;\\r\\nwb->left=wr->length;\\r\\nwb->offset=0;\\r\\ns->s3->wpend_tot=len;\\r\\ns->s3->wpend_buf=buf;\\r\\ns->s3->wpend_type=type;\\r\\ns->s3->wpend_ret=len;\\r\\nreturn(ssl3_write_pending(s,type,buf,len));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,\\r\\nunsigned int len)\\r\\n{\\r\\nint i;\\r\\nif ((s->s3->wpend_tot > (int)len)\\r\\n|| ((s->s3->wpend_buf != buf) &&\\r\\n!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))\\r\\n|| (s->s3->wpend_type != type))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nclear_sys_error();\\r\\nif (s->wbio != NULL)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\ni=BIO_write(s->wbio,\\r\\n(char *)&(s->s3->wbuf.buf[s->s3->wbuf.offset]),\\r\\n(unsigned int)s->s3->wbuf.left);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_WRITE_PENDING,SSL_R_BIO_NOT_SET);\\r\\ni= -1;\\r\\n}\\r\\nif (i == s->s3->wbuf.left)\\r\\n{\\r\\ns->s3->wbuf.left=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(s->s3->wpend_ret);\\r\\n}\\r\\nelse if (i <= 0)\\r\\nreturn(i);\\r\\ns->s3->wbuf.offset+=i;\\r\\ns->s3->wbuf.left-=i;\\r\\n}\\r\\n}\\r\\nint ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len)\\r\\n{\\r\\nint al,i,j,n,ret;\\r\\nSSL3_RECORD *rr;\\r\\nvoid (*cb)()=NULL;\\r\\nBIO *bio;\\r\\nif (s->s3->rbuf.buf == NULL)\\r\\nif (!ssl3_setup_buffers(s))\\r\\nreturn(-1);\\r\\nif (!s->in_handshake && SSL_in_init(s))\\r\\n{\\r\\ni=s->handshake_func(s);\\r\\nif (i < 0) return(i);\\r\\nif (i == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstart:\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr= &(s->s3->rrec);\\r\\nif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\\r\\n{\\r\\nret=ssl3_get_record(s);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nif (s->s3->change_cipher_spec && (rr->type != SSL3_RT_HANDSHAKE))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\\r\\ngoto err;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\nrr->length=0;\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\nif ((rr->type == SSL3_RT_HANDSHAKE) && (rr->length == 4) &&\\r\\n(rr->data[0] == SSL3_MT_CLIENT_REQUEST) &&\\r\\n(s->session != NULL) && (s->session->cipher != NULL))\\r\\n{\\r\\nif ((rr->data[1] != 0) || (rr->data[2] != 0) ||\\r\\n(rr->data[3] != 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CLIENT_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nif (SSL_is_init_finished(s) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\\r\\n!s->s3->renegotiate)\\r\\n{\\r\\nssl3_renegotiate(s);\\r\\nif (ssl3_renegotiate_check(s))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n}\\r\\nrr->length=0;\\r\\ngoto start;\\r\\n}\\r\\nif ((rr->type != type) || (s->shutdown & SSL_SENT_SHUTDOWN))\\r\\n{\\r\\nif (rr->type == SSL3_RT_ALERT)\\r\\n{\\r\\nif ((rr->length != 2) || (rr->off != 0))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_ALERT_RECORD);\\r\\ngoto f_err;\\r\\n}\\r\\ni=rr->data[0];\\r\\nn=rr->data[1];\\r\\nrr->length=0;\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(i<<8)|n;\\r\\ncb(s,SSL_CB_READ_ALERT,j);\\r\\n}\\r\\nif (i == 1)\\r\\n{\\r\\ns->s3->warn_alert=n;\\r\\nif (n == SSL_AD_CLOSE_NOTIFY)\\r\\n{\\r\\ns->shutdown|=SSL_RECEIVED_SHUTDOWN;\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nelse if (i == 2)\\r\\n{\\r\\nchar tmp[16];\\r\\ns->rwstate=SSL_NOTHING;\\r\\ns->s3->fatal_alert=n;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,\\r\\nSSL_AD_REASON_OFFSET+n);\\r\\nsprintf(tmp,\"%d\",n);\\r\\nERR_add_error_data(2,\"SSL alert number \",tmp);\\r\\ns->shutdown|=SSL_RECEIVED_SHUTDOWN;\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nrr->length=0;\\r\\ngoto start;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nrr->length=0;\\r\\nreturn(0);\\r\\n}\\r\\nif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\\r\\n{\\r\\nif ( (rr->length != 1) || (rr->off != 0) ||\\r\\n(rr->data[0] != SSL3_MT_CCS))\\r\\n{\\r\\ni=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\\r\\ngoto err;\\r\\n}\\r\\nrr->length=0;\\r\\ns->s3->change_cipher_spec=1;\\r\\nif (!do_change_cipher_spec(s))\\r\\ngoto err;\\r\\nelse\\r\\ngoto start;\\r\\n}\\r\\nif ((rr->type == SSL3_RT_HANDSHAKE) &&\\r\\n!s->in_handshake)\\r\\n{\\r\\nif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\\r\\n!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\\r\\n{\\r\\ns->state=SSL_ST_BEFORE|(s->server)\\r\\n?SSL_ST_ACCEPT\\r\\n:SSL_ST_CONNECT;\\r\\ns->new_session=1;\\r\\n}\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\ns->rwstate=SSL_READING;\\r\\nbio=SSL_get_rbio(s);\\r\\nBIO_clear_retry_flags(bio);\\r\\nBIO_set_retry_read(bio);\\r\\nreturn(-1);\\r\\n}\\r\\nswitch (rr->type)\\r\\n{\\r\\ndefault:\\r\\n#ifndef NO_TLS\\r\\nif (s->version == TLS1_VERSION)\\r\\n{\\r\\ngoto start;\\r\\n}\\r\\n#endif\\r\\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\\r\\ncase SSL3_RT_ALERT:\\r\\ncase SSL3_RT_HANDSHAKE:\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\ncase SSL3_RT_APPLICATION_DATA:\\r\\nif (s->s3->in_read_app_data &&\\r\\n(s->s3->total_renegotiations != 0) &&\\r\\n((\\r\\n(s->state & SSL_ST_CONNECT) &&\\r\\n(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\\r\\n(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\\r\\n) || (\\r\\n(s->state & SSL_ST_ACCEPT) &&\\r\\n(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\\r\\n(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\\r\\n)\\r\\n))\\r\\n{\\r\\ns->s3->in_read_app_data=0;\\r\\nreturn(-1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\\r\\n(s->enc_read_ctx == NULL))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (len <= 0) return(len);\\r\\nif ((unsigned int)len > rr->length)\\r\\nn=rr->length;\\r\\nelse\\r\\nn=len;\\r\\nmemcpy(buf,&(rr->data[rr->off]),(unsigned int)n);\\r\\nrr->length-=n;\\r\\nrr->off+=n;\\r\\nif (rr->length <= 0)\\r\\n{\\r\\ns->rstate=SSL_ST_READ_HEADER;\\r\\nrr->off=0;\\r\\n}\\r\\nif (type == SSL3_RT_HANDSHAKE)\\r\\nssl3_finish_mac(s,buf,n);\\r\\nreturn(n);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int do_change_cipher_spec(SSL *s)\\r\\n{\\r\\nint i;\\r\\nunsigned char *sender;\\r\\nint slen;\\r\\nif (s->state & SSL_ST_ACCEPT)\\r\\ni=SSL3_CHANGE_CIPHER_SERVER_READ;\\r\\nelse\\r\\ni=SSL3_CHANGE_CIPHER_CLIENT_READ;\\r\\nif (s->s3->tmp.key_block == NULL)\\r\\n{\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\\r\\n}\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,i))\\r\\nreturn(0);\\r\\nif (s->state & SSL_ST_CONNECT)\\r\\n{\\r\\nsender=s->method->ssl3_enc->server_finished;\\r\\nslen=s->method->ssl3_enc->server_finished_len;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsender=s->method->ssl3_enc->client_finished;\\r\\nslen=s->method->ssl3_enc->client_finished_len;\\r\\n}\\r\\ns->method->ssl3_enc->final_finish_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->finish_dgst2),\\r\\nsender,slen,&(s->s3->tmp.finish_md[0]));\\r\\nreturn(1);\\r\\n}\\r\\nint ssl3_do_write(SSL *s, int type)\\r\\n{\\r\\nint ret;\\r\\nret=ssl3_write_bytes(s,type,&s->init_buf->data[s->init_off],\\r\\ns->init_num);\\r\\nif (ret == s->init_num)\\r\\nreturn(1);\\r\\nif (ret < 0) return(-1);\\r\\ns->init_off+=ret;\\r\\ns->init_num-=ret;\\r\\nreturn(0);\\r\\n}\\r\\nvoid ssl3_send_alert(SSL *s, int level, int desc)\\r\\n{\\r\\ndesc=s->method->ssl3_enc->alert_value(desc);\\r\\nif (desc < 0) return;\\r\\nif ((level == 2) && (s->session != NULL))\\r\\nSSL_CTX_remove_session(s->ctx,s->session);\\r\\ns->s3->alert_dispatch=1;\\r\\ns->s3->send_alert[0]=level;\\r\\ns->s3->send_alert[1]=desc;\\r\\nif (s->s3->wbuf.left == 0)\\r\\nssl3_dispatch_alert(s);\\r\\n}\\r\\nint ssl3_dispatch_alert(SSL *s)\\r\\n{\\r\\nint i,j;\\r\\nvoid (*cb)()=NULL;\\r\\ns->s3->alert_dispatch=0;\\r\\ni=do_ssl3_write(s,SSL3_RT_ALERT,&s->s3->send_alert[0],2);\\r\\nif (i <= 0)\\r\\n{\\r\\ns->s3->alert_dispatch=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->s3->send_alert[0] == SSL3_AL_FATAL)\\r\\n(void)BIO_flush(s->wbio);\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (cb != NULL)\\r\\n{\\r\\nj=(s->s3->send_alert[0]<<8)|s->s3->send_alert[1];\\r\\ncb(s,SSL_CB_WRITE_ALERT,j);\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_pr_c", "target": 0, "func": "EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL))\\r\\n{\\r\\nif ((ret=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nelse ret= *a;\\r\\nret->save_type=type;\\r\\nret->type=EVP_PKEY_type(type);\\r\\nswitch (ret->type)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif ((ret->pkey.rsa=d2i_RSAPrivateKey(NULL,pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif ((ret->pkey.dsa=d2i_DSAPrivateKey(NULL,pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY,ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) EVP_PKEY_free(ret);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_f_int_c", "target": 0, "func": "int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) != 2) goto err;\\r\\nn=2;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbs->type=V_ASN1_INTEGER;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1) goto err_sl;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nif (first)\\r\\n{\\r\\nfirst=0;\\r\\nif ((bufp[0] == '0') && (buf[1] == '0'))\\r\\n{\\r\\nbufp+=2;\\r\\ni-=2;\\r\\n}\\r\\n}\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)Malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=(unsigned char *)Realloc(s,\\r\\n(unsigned int)num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) Free((char *)s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ofb64enc_c", "target": 0, "func": "void des_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length, des_key_schedule schedule,\\r\\ndes_cblock *ivec, int *num)\\r\\n{\\r\\nregister DES_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\ndes_cblock d;\\r\\nregister unsigned char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv,v0);\\r\\nc2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=d;\\r\\nl2c(v0,dp);\\r\\nl2c(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\ndes_encrypt(ti,schedule,DES_ENCRYPT);\\r\\ndp=d;\\r\\nt=ti[0]; l2c(t,dp);\\r\\nt=ti[1]; l2c(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0,iv);\\r\\nl2c(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_tab_c", "target": 0, "func": "main()\\r\\n{\\r\\nint i,j;\\r\\nfor (i=0; i<256; i++)\\r\\n{\\r\\nfor (j=0; j<256; j++)\\r\\nif (ebits_to_num[j] == i)\\r\\n{\\r\\nprintf(\"0x%02x,\",j);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_rsa_c", "target": 0, "func": "int SSL_use_certificate(SSL *ssl, X509 *x)\\r\\n{\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_cert(ssl->cert,x));\\r\\n}\\r\\nint SSL_use_certificate_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nx=d2i_X509_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nx=PEM_read_bio_X509(in,NULL,ssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_certificate(ssl,x);\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx=d2i_X509(NULL,&d,(long)len);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_certificate(ssl,x);\\r\\nX509_free(x);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint ret;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((pkey=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);\\r\\nEVP_PKEY_assign_RSA(pkey,rsa);\\r\\nret=ssl_set_pkey(ssl->cert,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)\\r\\n{\\r\\nint i,ok=0,bad=0;\\r\\ni=ssl_cert_type(NULL,pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_PKEY,SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nreturn(0);\\r\\n}\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(c->pkeys[i].x509);\\r\\nEVP_PKEY_copy_parameters(pktmp,pkey);\\r\\nEVP_PKEY_free(pktmp);\\r\\nERR_clear_error();\\r\\n#ifndef NO_RSA\\r\\nif ((pkey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(pkey->pkey.rsa) &\\r\\nRSA_METHOD_FLAG_NO_CHECK))\\r\\nok=1;\\r\\nelse\\r\\n#endif\\r\\nif (!X509_check_private_key(c->pkeys[i].x509,pkey))\\r\\n{\\r\\nif ((i == SSL_PKEY_DH_RSA) || (i == SSL_PKEY_DH_DSA))\\r\\n{\\r\\ni=(i == SSL_PKEY_DH_RSA)?\\r\\nSSL_PKEY_DH_DSA:SSL_PKEY_DH_RSA;\\r\\nif (c->pkeys[i].x509 == NULL)\\r\\nok=1;\\r\\nelse\\r\\n{\\r\\nif (!X509_check_private_key(\\r\\nc->pkeys[i].x509,pkey))\\r\\nbad=1;\\r\\nelse\\r\\nok=1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbad=1;\\r\\n}\\r\\nelse\\r\\nok=1;\\r\\n}\\r\\nelse\\r\\nok=1;\\r\\nif (bad)\\r\\n{\\r\\nX509_free(c->pkeys[i].x509);\\r\\nc->pkeys[i].x509=NULL;\\r\\nreturn(0);\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nCRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\nc->pkeys[i].privatekey=pkey;\\r\\nc->key= &(c->pkeys[i]);\\r\\nc->valid=0;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nRSA *rsa=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nrsa=d2i_RSAPrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nrsa=PEM_read_bio_RSAPrivateKey(in,NULL,\\r\\nssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_RSAPrivateKey(ssl,rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nRSA *rsa;\\r\\np=d;\\r\\nif ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_RSAPrivateKey(ssl,rsa);\\r\\nRSA_free(rsa);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)\\r\\n{\\r\\nint ret;\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nret=ssl_set_pkey(ssl->cert,pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,\\r\\nssl->ctx->default_passwd_callback,ssl->ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_use_PrivateKey(ssl,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_ASN1(int type, SSL *ssl, unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np=d;\\r\\nif ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_use_PrivateKey(ssl,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)\\r\\n{\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_cert(ctx->cert, x));\\r\\n}\\r\\nstatic int ssl_set_cert(CERT *c, X509 *x)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint i,ok=0,bad=0;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_CERT,SSL_R_X509_LIB);\\r\\nreturn(0);\\r\\n}\\r\\ni=ssl_cert_type(x,pkey);\\r\\nif (i < 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_SET_CERT,SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(0);\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\n{\\r\\nEVP_PKEY_copy_parameters(pkey,c->pkeys[i].privatekey);\\r\\nERR_clear_error();\\r\\n#ifndef NO_RSA\\r\\nif ((c->pkeys[i].privatekey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(c->pkeys[i].privatekey->pkey.rsa) &\\r\\nRSA_METHOD_FLAG_NO_CHECK))\\r\\nok=1;\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nif (!X509_check_private_key(x,c->pkeys[i].privatekey))\\r\\n{\\r\\nif ((i == SSL_PKEY_DH_RSA) || (i == SSL_PKEY_DH_DSA))\\r\\n{\\r\\ni=(i == SSL_PKEY_DH_RSA)?\\r\\nSSL_PKEY_DH_DSA:SSL_PKEY_DH_RSA;\\r\\nif (c->pkeys[i].privatekey == NULL)\\r\\nok=1;\\r\\nelse\\r\\n{\\r\\nif (!X509_check_private_key(x,\\r\\nc->pkeys[i].privatekey))\\r\\nbad=1;\\r\\nelse\\r\\nok=1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nbad=1;\\r\\n}\\r\\nelse\\r\\nok=1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nok=1;\\r\\nEVP_PKEY_free(pkey);\\r\\nif (bad)\\r\\n{\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nc->pkeys[i].privatekey=NULL;\\r\\n}\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\nX509_free(c->pkeys[i].x509);\\r\\nCRYPTO_add(&x->references,1,CRYPTO_LOCK_X509);\\r\\nc->pkeys[i].x509=x;\\r\\nc->key= &(c->pkeys[i]);\\r\\nc->valid=0;\\r\\nreturn(1);\\r\\n}\\r\\nint SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nx=d2i_X509_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nx=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx=d2i_X509(NULL,&d,(long)len);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nX509_free(x);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)\\r\\n{\\r\\nint ret;\\r\\nEVP_PKEY *pkey;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((pkey=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY,ERR_R_EVP_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nCRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);\\r\\nEVP_PKEY_assign_RSA(pkey,rsa);\\r\\nret=ssl_set_pkey(ctx->cert, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nRSA *rsa=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1)\\r\\n{\\r\\nj=ERR_R_ASN1_LIB;\\r\\nrsa=d2i_RSAPrivateKey_bio(in,NULL);\\r\\n}\\r\\nelse if (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\nrsa=PEM_read_bio_RSAPrivateKey(in,NULL,\\r\\nctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nRSA *rsa;\\r\\np=d;\\r\\nif ((rsa=d2i_RSAPrivateKey(NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_RSAPrivateKey(ctx,rsa);\\r\\nRSA_free(rsa);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn(0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ssl_set_pkey(ctx->cert,pkey));\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j,ret=0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM)\\r\\n{\\r\\nj=ERR_R_PEM_LIB;\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,\\r\\nctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE,j);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_PrivateKey(ctx,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx, unsigned char *d,\\r\\nlong len)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np=d;\\r\\nif ((pkey=d2i_PrivateKey(type,NULL,&p,(long)len)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1,ERR_R_ASN1_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nret=SSL_CTX_use_PrivateKey(ctx,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)\\r\\n{\\r\\nBIO *in;\\r\\nint ret=0;\\r\\nX509 *x=NULL;\\r\\nin=BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in,file) <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nx=PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE,ERR_R_PEM_LIB);\\r\\ngoto end;\\r\\n}\\r\\nret=SSL_CTX_use_certificate(ctx,x);\\r\\nif (ERR_peek_error() != 0)\\r\\nret = 0;\\r\\nif (ret)\\r\\n{\\r\\nX509 *ca;\\r\\nint r;\\r\\nunsigned long err;\\r\\nif (ctx->extra_certs != NULL)\\r\\n{\\r\\nsk_X509_pop_free(ctx->extra_certs, X509_free);\\r\\nctx->extra_certs = NULL;\\r\\n}\\r\\nwhile ((ca = PEM_read_bio_X509(in,NULL,ctx->default_passwd_callback,ctx->default_passwd_callback_userdata))\\r\\n!= NULL)\\r\\n{\\r\\nr = SSL_CTX_add_extra_chain_cert(ctx, ca);\\r\\nif (!r)\\r\\n{\\r\\nX509_free(ca);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nerr = ERR_peek_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE)\\r\\n(void) ERR_get_error();\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nend:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_type_c", "target": 1, "func": "int i2d_ASN1_TYPE(ASN1_TYPE *a, unsigned char **pp)\\r\\n{\\r\\nint r=0;\\r\\nif (a == NULL) return(0);\\r\\nswitch (a->type)\\r\\n{\\r\\ncase V_ASN1_NULL:\\r\\nif (pp != NULL)\\r\\nASN1_put_object(pp,0,0,V_ASN1_NULL,V_ASN1_UNIVERSAL);\\r\\nr=2;\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\nr=i2d_ASN1_INTEGER(a->value.integer,pp);\\r\\nbreak;\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\nr=i2d_ASN1_ENUMERATED(a->value.enumerated,pp);\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nr=i2d_ASN1_BIT_STRING(a->value.bit_string,pp);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\nr=i2d_ASN1_OCTET_STRING(a->value.octet_string,pp);\\r\\nbreak;\\r\\ncase V_ASN1_OBJECT:\\r\\nr=i2d_ASN1_OBJECT(a->value.object,pp);\\r\\nbreak;\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\nr=M_i2d_ASN1_PRINTABLESTRING(a->value.printablestring,pp);\\r\\nbreak;\\r\\ncase V_ASN1_T61STRING:\\r\\nr=M_i2d_ASN1_T61STRING(a->value.t61string,pp);\\r\\nbreak;\\r\\ncase V_ASN1_IA5STRING:\\r\\nr=M_i2d_ASN1_IA5STRING(a->value.ia5string,pp);\\r\\nbreak;\\r\\ncase V_ASN1_GENERALSTRING:\\r\\nr=M_i2d_ASN1_GENERALSTRING(a->value.generalstring,pp);\\r\\nbreak;\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\nr=M_i2d_ASN1_UNIVERSALSTRING(a->value.universalstring,pp);\\r\\nbreak;\\r\\ncase V_ASN1_UTF8STRING:\\r\\nr=M_i2d_ASN1_UTF8STRING(a->value.utf8string,pp);\\r\\nbreak;\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\nr=M_i2d_ASN1_VISIBLESTRING(a->value.visiblestring,pp);\\r\\nbreak;\\r\\ncase V_ASN1_BMPSTRING:\\r\\nr=M_i2d_ASN1_BMPSTRING(a->value.bmpstring,pp);\\r\\nbreak;\\r\\ncase V_ASN1_UTCTIME:\\r\\nr=i2d_ASN1_UTCTIME(a->value.utctime,pp);\\r\\nbreak;\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\nr=i2d_ASN1_GENERALIZEDTIME(a->value.generalizedtime,pp);\\r\\nbreak;\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_SEQUENCE:\\r\\nif (a->value.set == NULL)\\r\\nr=0;\\r\\nelse\\r\\n{\\r\\nr=a->value.set->length;\\r\\nif (pp != NULL)\\r\\n{\\r\\nmemcpy(*pp,a->value.set->data,r);\\r\\n*pp+=r;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn(r);\\r\\n}\\r\\nASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE **a, unsigned char **pp, long length)\\r\\n{\\r\\nASN1_TYPE *ret=NULL;\\r\\nunsigned char *q,*p,*max;\\r\\nint inf,tag,xclass;\\r\\nlong len;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_TYPE_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\nq=p;\\r\\nmax=(p+length);\\r\\ninf=ASN1_get_object(&q,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80) goto err;\\r\\nASN1_TYPE_component_free(ret);\\r\\nswitch (tag)\\r\\n{\\r\\ncase V_ASN1_NULL:\\r\\np=q;\\r\\nret->value.ptr=NULL;\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\nif ((ret->value.integer=\\r\\nd2i_ASN1_INTEGER(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_ENUMERATED:\\r\\nif ((ret->value.enumerated=\\r\\nd2i_ASN1_ENUMERATED(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nif ((ret->value.bit_string=\\r\\nd2i_ASN1_BIT_STRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\nif ((ret->value.octet_string=\\r\\nd2i_ASN1_OCTET_STRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\nif ((ret->value.visiblestring=\\r\\nd2i_ASN1_VISIBLESTRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_UTF8STRING:\\r\\nif ((ret->value.utf8string=\\r\\nd2i_ASN1_UTF8STRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_OBJECT:\\r\\nif ((ret->value.object=\\r\\nd2i_ASN1_OBJECT(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\nif ((ret->value.printablestring=\\r\\nd2i_ASN1_PRINTABLESTRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_T61STRING:\\r\\nif ((ret->value.t61string=\\r\\nM_d2i_ASN1_T61STRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_IA5STRING:\\r\\nif ((ret->value.ia5string=\\r\\nM_d2i_ASN1_IA5STRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_GENERALSTRING:\\r\\nif ((ret->value.generalstring=\\r\\nM_d2i_ASN1_GENERALSTRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\nif ((ret->value.universalstring=\\r\\nM_d2i_ASN1_UNIVERSALSTRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_BMPSTRING:\\r\\nif ((ret->value.bmpstring=\\r\\nM_d2i_ASN1_BMPSTRING(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_UTCTIME:\\r\\nif ((ret->value.utctime=\\r\\nd2i_ASN1_UTCTIME(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\nif ((ret->value.generalizedtime=\\r\\nd2i_ASN1_GENERALIZEDTIME(NULL,&p,max-p)) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_SEQUENCE:\\r\\nif ((ret->value.set=ASN1_STRING_new()) == NULL) goto err;\\r\\nret->value.set->type=tag;\\r\\nlen+=(q-p);\\r\\nif (!ASN1_STRING_set(ret->value.set,p,(int)len)) goto err;\\r\\np+=len;\\r\\nbreak;\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_ASN1_TYPE,ASN1_R_BAD_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nret->type=tag;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) ASN1_TYPE_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_TYPE *ASN1_TYPE_new(void)\\r\\n{\\r\\nASN1_TYPE *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,ASN1_TYPE);\\r\\nret->type= -1;\\r\\nret->value.ptr=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_ASN1_TYPE_NEW);\\r\\n}\\r\\nvoid ASN1_TYPE_free(ASN1_TYPE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_TYPE_component_free(a);\\r\\nFree((char *)(char *)a);\\r\\n}\\r\\nint ASN1_TYPE_get(ASN1_TYPE *a)\\r\\n{\\r\\nif (a->value.ptr != NULL)\\r\\nreturn(a->type);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nvoid ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)\\r\\n{\\r\\nif (a->value.ptr != NULL)\\r\\nASN1_TYPE_component_free(a);\\r\\na->type=type;\\r\\na->value.ptr=value;\\r\\n}\\r\\nstatic void ASN1_TYPE_component_free(ASN1_TYPE *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif (a->value.ptr != NULL)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\ncase V_ASN1_OBJECT:\\r\\nASN1_OBJECT_free(a->value.object);\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\ncase V_ASN1_BIT_STRING:\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\nASN1_STRING_free((ASN1_STRING *)a->value.ptr);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\na->type=0;\\r\\na->value.ptr=NULL;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_err_c", "target": 0, "func": "void ERR_load_EVP_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_EVP,EVP_str_functs);\\r\\nERR_load_strings(ERR_LIB_EVP,EVP_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_lib_c", "target": 1, "func": "void BN_set_params(int mult, int high, int low, int mont)\\r\\n{\\r\\nif (mult >= 0)\\r\\n{\\r\\nif (mult > (sizeof(int)*8)-1)\\r\\nmult=sizeof(int)*8-1;\\r\\nbn_limit_bits=mult;\\r\\nbn_limit_num=1<<mult;\\r\\n}\\r\\nif (high >= 0)\\r\\n{\\r\\nif (high > (sizeof(int)*8)-1)\\r\\nhigh=sizeof(int)*8-1;\\r\\nbn_limit_bits_high=high;\\r\\nbn_limit_num_high=1<<high;\\r\\n}\\r\\nif (low >= 0)\\r\\n{\\r\\nif (low > (sizeof(int)*8)-1)\\r\\nlow=sizeof(int)*8-1;\\r\\nbn_limit_bits_low=low;\\r\\nbn_limit_num_low=1<<low;\\r\\n}\\r\\nif (mont >= 0)\\r\\n{\\r\\nif (mont > (sizeof(int)*8)-1)\\r\\nmont=sizeof(int)*8-1;\\r\\nbn_limit_bits_mont=mont;\\r\\nbn_limit_num_mont=1<<mont;\\r\\n}\\r\\n}\\r\\nint BN_get_params(int which)\\r\\n{\\r\\nif (which == 0) return(bn_limit_bits);\\r\\nelse if (which == 1) return(bn_limit_bits_high);\\r\\nelse if (which == 2) return(bn_limit_bits_low);\\r\\nelse if (which == 3) return(bn_limit_bits_mont);\\r\\nelse return(0);\\r\\n}\\r\\nBIGNUM *BN_value_one(void)\\r\\n{\\r\\nstatic BN_ULONG data_one=1L;\\r\\nstatic BIGNUM const_one={&data_one,1,1,0};\\r\\nreturn(&const_one);\\r\\n}\\r\\nchar *BN_options(void)\\r\\n{\\r\\nstatic int init=0;\\r\\nstatic char data[16];\\r\\nif (!init)\\r\\n{\\r\\ninit++;\\r\\n#ifdef BN_LLONG\\r\\nsprintf(data,\"bn(%d,%d)\",(int)sizeof(BN_ULLONG)*8,\\r\\n(int)sizeof(BN_ULONG)*8);\\r\\n#else\\r\\nsprintf(data,\"bn(%d,%d)\",(int)sizeof(BN_ULONG)*8,\\r\\n(int)sizeof(BN_ULONG)*8);\\r\\n#endif\\r\\n}\\r\\nreturn(data);\\r\\n}\\r\\nint BN_num_bits_word(BN_ULONG l)\\r\\n{\\r\\nstatic const char bits[256]={\\r\\n0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,\\r\\n5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\\r\\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\r\\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\\r\\n};\\r\\n#if defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffffffff00000000L)\\r\\n{\\r\\nif (l & 0xffff000000000000L)\\r\\n{\\r\\nif (l & 0xff00000000000000L)\\r\\n{\\r\\nreturn(bits[(int)(l>>56)]+56);\\r\\n}\\r\\nelse return(bits[(int)(l>>48)]+48);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (l & 0x0000ff0000000000L)\\r\\n{\\r\\nreturn(bits[(int)(l>>40)]+40);\\r\\n}\\r\\nelse return(bits[(int)(l>>32)]+32);\\r\\n}\\r\\n}\\r\\nelse\\r\\n#else\\r\\n#ifdef SIXTY_FOUR_BIT\\r\\nif (l & 0xffffffff00000000LL)\\r\\n{\\r\\nif (l & 0xffff000000000000LL)\\r\\n{\\r\\nif (l & 0xff00000000000000LL)\\r\\n{\\r\\nreturn(bits[(int)(l>>56)]+56);\\r\\n}\\r\\nelse return(bits[(int)(l>>48)]+48);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (l & 0x0000ff0000000000LL)\\r\\n{\\r\\nreturn(bits[(int)(l>>40)]+40);\\r\\n}\\r\\nelse return(bits[(int)(l>>32)]+32);\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#endif\\r\\n{\\r\\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffff0000L)\\r\\n{\\r\\nif (l & 0xff000000L)\\r\\nreturn(bits[(int)(l>>24L)]+24);\\r\\nelse return(bits[(int)(l>>16L)]+16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\n#if defined(SIXTEEN_BIT) || defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xff00L)\\r\\nreturn(bits[(int)(l>>8)]+8);\\r\\nelse\\r\\n#endif\\r\\nreturn(bits[(int)(l )] );\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_num_bits(const BIGNUM *a)\\r\\n{\\r\\nBN_ULONG l;\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nif (a->top == 0) return(0);\\r\\nl=a->d[a->top-1];\\r\\ni=(a->top-1)*BN_BITS2;\\r\\nif (l == 0)\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"BAD TOP VALUE\\n\");\\r\\n#endif\\r\\nabort();\\r\\n}\\r\\nreturn(i+BN_num_bits_word(l));\\r\\n}\\r\\nvoid BN_clear_free(BIGNUM *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL) return;\\r\\nif (a->d != NULL)\\r\\n{\\r\\nmemset(a->d,0,a->max*sizeof(a->d[0]));\\r\\nif (!(BN_get_flags(a,BN_FLG_STATIC_DATA)))\\r\\nFree(a->d);\\r\\n}\\r\\ni=BN_get_flags(a,BN_FLG_MALLOCED);\\r\\nmemset(a,0,sizeof(BIGNUM));\\r\\nif (i)\\r\\nFree(a);\\r\\n}\\r\\nvoid BN_free(BIGNUM *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif ((a->d != NULL) && !(BN_get_flags(a,BN_FLG_STATIC_DATA)))\\r\\nFree(a->d);\\r\\na->flags|=BN_FLG_FREE;\\r\\nif (a->flags & BN_FLG_MALLOCED)\\r\\nFree(a);\\r\\n}\\r\\nvoid BN_init(BIGNUM *a)\\r\\n{\\r\\nmemset(a,0,sizeof(BIGNUM));\\r\\n}\\r\\nBIGNUM *BN_new(void)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=(BIGNUM *)Malloc(sizeof(BIGNUM))) == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nret->top=0;\\r\\nret->neg=0;\\r\\nret->max=0;\\r\\nret->d=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nBN_CTX *BN_CTX_new(void)\\r\\n{\\r\\nBN_CTX *ret;\\r\\nret=(BN_CTX *)Malloc(sizeof(BN_CTX));\\r\\nif (ret == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nBN_CTX_init(ret);\\r\\nret->flags=BN_FLG_MALLOCED;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BN_CTX_init(BN_CTX *ctx)\\r\\n{\\r\\nmemset(ctx,0,sizeof(BN_CTX));\\r\\nctx->tos=0;\\r\\nctx->flags=0;\\r\\n}\\r\\nvoid BN_CTX_free(BN_CTX *c)\\r\\n{\\r\\nint i;\\r\\nif(c == NULL)\\r\\nreturn;\\r\\nfor (i=0; i<BN_CTX_NUM; i++)\\r\\nBN_clear_free(&(c->bn[i]));\\r\\nif (c->flags & BN_FLG_MALLOCED)\\r\\nFree(c);\\r\\n}\\r\\nBIGNUM *bn_expand2(BIGNUM *b, int words)\\r\\n{\\r\\nBN_ULONG *A,*a;\\r\\nconst BN_ULONG *B;\\r\\nint i;\\r\\nbn_check_top(b);\\r\\nif (words > b->max)\\r\\n{\\r\\nbn_check_top(b);\\r\\nif (BN_get_flags(b,BN_FLG_STATIC_DATA))\\r\\n{\\r\\nBNerr(BN_F_BN_EXPAND2,BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);\\r\\nreturn(NULL);\\r\\n}\\r\\na=A=(BN_ULONG *)Malloc(sizeof(BN_ULONG)*(words+1));\\r\\nif (A == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_EXPAND2,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\n#if 1\\r\\nB=b->d;\\r\\nif (B != NULL)\\r\\n{\\r\\n#if 0\\r\\nfor (i=b->top&(~7); i>0; i-=8)\\r\\n{\\r\\nA[0]=B[0]; A[1]=B[1]; A[2]=B[2]; A[3]=B[3];\\r\\nA[4]=B[4]; A[5]=B[5]; A[6]=B[6]; A[7]=B[7];\\r\\nA+=8;\\r\\nB+=8;\\r\\n}\\r\\nswitch (b->top&7)\\r\\n{\\r\\ncase 7:\\r\\nA[6]=B[6];\\r\\ncase 6:\\r\\nA[5]=B[5];\\r\\ncase 5:\\r\\nA[4]=B[4];\\r\\ncase 4:\\r\\nA[3]=B[3];\\r\\ncase 3:\\r\\nA[2]=B[2];\\r\\ncase 2:\\r\\nA[1]=B[1];\\r\\ncase 1:\\r\\nA[0]=B[0];\\r\\ncase 0:\\r\\n;\\r\\n}\\r\\n#else\\r\\nfor (i=b->top>>2; i>0; i--,A+=4,B+=4)\\r\\n{\\r\\nBN_ULONG a0,a1,a2,a3;\\r\\na0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];\\r\\nA[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;\\r\\n}\\r\\nswitch (b->top&3)\\r\\n{\\r\\ncase 3: A[2]=B[2];\\r\\ncase 2: A[1]=B[1];\\r\\ncase 1: A[0]=B[0];\\r\\ncase 0: ;\\r\\n}\\r\\n#endif\\r\\nFree(b->d);\\r\\n}\\r\\nb->d=a;\\r\\nb->max=words;\\r\\nA= &(b->d[b->top]);\\r\\nfor (i=(b->max - b->top)>>3; i>0; i--,A+=8)\\r\\n{\\r\\nA[0]=0; A[1]=0; A[2]=0; A[3]=0;\\r\\nA[4]=0; A[5]=0; A[6]=0; A[7]=0;\\r\\n}\\r\\nfor (i=(b->max - b->top)&7; i>0; i--,A++)\\r\\nA[0]=0;\\r\\n#else\\r\\nmemset(A,0,sizeof(BN_ULONG)*(words+1));\\r\\nmemcpy(A,b->d,sizeof(b->d[0])*b->top);\\r\\nb->d=a;\\r\\nb->max=words;\\r\\n#endif\\r\\n}\\r\\nreturn(b);\\r\\n}\\r\\nBIGNUM *BN_dup(const BIGNUM *a)\\r\\n{\\r\\nBIGNUM *r;\\r\\nif (a == NULL) return NULL;\\r\\nbn_check_top(a);\\r\\nr=BN_new();\\r\\nif (r == NULL) return(NULL);\\r\\nreturn((BIGNUM *)BN_copy(r,a));\\r\\n}\\r\\nBIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *A;\\r\\nconst BN_ULONG *B;\\r\\nbn_check_top(b);\\r\\nif (a == b) return(a);\\r\\nif (bn_wexpand(a,b->top) == NULL) return(NULL);\\r\\n#if 1\\r\\nA=a->d;\\r\\nB=b->d;\\r\\nfor (i=b->top>>2; i>0; i--,A+=4,B+=4)\\r\\n{\\r\\nBN_ULONG a0,a1,a2,a3;\\r\\na0=B[0]; a1=B[1]; a2=B[2]; a3=B[3];\\r\\nA[0]=a0; A[1]=a1; A[2]=a2; A[3]=a3;\\r\\n}\\r\\nswitch (b->top&3)\\r\\n{\\r\\ncase 3: A[2]=B[2];\\r\\ncase 2: A[1]=B[1];\\r\\ncase 1: A[0]=B[0];\\r\\ncase 0: ;\\r\\n}\\r\\n#else\\r\\nmemcpy(a->d,b->d,sizeof(b->d[0])*b->top);\\r\\n#endif\\r\\na->top=b->top;\\r\\nif ((a->top == 0) && (a->d != NULL))\\r\\na->d[0]=0;\\r\\na->neg=b->neg;\\r\\nreturn(a);\\r\\n}\\r\\nvoid BN_clear(BIGNUM *a)\\r\\n{\\r\\nif (a->d != NULL)\\r\\nmemset(a->d,0,a->max*sizeof(a->d[0]));\\r\\na->top=0;\\r\\na->neg=0;\\r\\n}\\r\\nBN_ULONG BN_get_word(BIGNUM *a)\\r\\n{\\r\\nint i,n;\\r\\nBN_ULONG ret=0;\\r\\nn=BN_num_bytes(a);\\r\\nif (n > sizeof(BN_ULONG))\\r\\nreturn(BN_MASK2);\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\n#ifndef SIXTY_FOUR_BIT\\r\\nret<<=BN_BITS4;\\r\\nret<<=BN_BITS4;\\r\\n#else\\r\\nret=0;\\r\\n#endif\\r\\nret|=a->d[i];\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_set_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nint i,n;\\r\\nif (bn_expand(a,sizeof(BN_ULONG)*8) == NULL) return(0);\\r\\nn=sizeof(BN_ULONG)/BN_BYTES;\\r\\na->neg=0;\\r\\na->top=0;\\r\\na->d[0]=(BN_ULONG)w&BN_MASK2;\\r\\nif (a->d[0] != 0) a->top=1;\\r\\nfor (i=1; i<n; i++)\\r\\n{\\r\\n#ifndef SIXTY_FOUR_BIT\\r\\nw>>=BN_BITS4;\\r\\nw>>=BN_BITS4;\\r\\n#else\\r\\nw=0;\\r\\n#endif\\r\\na->d[i]=(BN_ULONG)w&BN_MASK2;\\r\\nif (a->d[i] != 0) a->top=i+1;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nBIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)\\r\\n{\\r\\nunsigned int i,m;\\r\\nunsigned int n;\\r\\nBN_ULONG l;\\r\\nif (ret == NULL) ret=BN_new();\\r\\nif (ret == NULL) return(NULL);\\r\\nl=0;\\r\\nn=len;\\r\\nif (n == 0)\\r\\n{\\r\\nret->top=0;\\r\\nreturn(ret);\\r\\n}\\r\\nif (bn_expand(ret,(int)(n+2)*8) == NULL)\\r\\nreturn(NULL);\\r\\ni=((n-1)/BN_BYTES)+1;\\r\\nm=((n-1)%(BN_BYTES));\\r\\nret->top=i;\\r\\nwhile (n-- > 0)\\r\\n{\\r\\nl=(l<<8L)| *(s++);\\r\\nif (m-- == 0)\\r\\n{\\r\\nret->d[--i]=l;\\r\\nl=0;\\r\\nm=BN_BYTES-1;\\r\\n}\\r\\n}\\r\\nbn_fix_top(ret);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_bn2bin(const BIGNUM *a, unsigned char *to)\\r\\n{\\r\\nint n,i;\\r\\nBN_ULONG l;\\r\\nn=i=BN_num_bytes(a);\\r\\nwhile (i-- > 0)\\r\\n{\\r\\nl=a->d[i/BN_BYTES];\\r\\n*(to++)=(unsigned char)(l>>(8*(i%BN_BYTES)))&0xff;\\r\\n}\\r\\nreturn(n);\\r\\n}\\r\\nint BN_ucmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG t1,t2,*ap,*bp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\ni=a->top-b->top;\\r\\nif (i != 0) return(i);\\r\\nap=a->d;\\r\\nbp=b->d;\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt1= ap[i];\\r\\nt2= bp[i];\\r\\nif (t1 != t2)\\r\\nreturn(t1 > t2?1:-1);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BN_cmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nint gt,lt;\\r\\nBN_ULONG t1,t2;\\r\\nif ((a == NULL) || (b == NULL))\\r\\n{\\r\\nif (a != NULL)\\r\\nreturn(-1);\\r\\nelse if (b != NULL)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg != b->neg)\\r\\n{\\r\\nif (a->neg)\\r\\nreturn(-1);\\r\\nelse return(1);\\r\\n}\\r\\nif (a->neg == 0)\\r\\n{ gt=1; lt= -1; }\\r\\nelse { gt= -1; lt=1; }\\r\\nif (a->top > b->top) return(gt);\\r\\nif (a->top < b->top) return(lt);\\r\\nfor (i=a->top-1; i>=0; i--)\\r\\n{\\r\\nt1=a->d[i];\\r\\nt2=b->d[i];\\r\\nif (t1 > t2) return(gt);\\r\\nif (t1 < t2) return(lt);\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nint BN_set_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i,j,k;\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i)\\r\\n{\\r\\nif (bn_wexpand(a,i+1) == NULL) return(0);\\r\\nfor(k=a->top; k<i+1; k++)\\r\\na->d[k]=0;\\r\\na->top=i+1;\\r\\n}\\r\\na->d[i]|=(((BN_ULONG)1)<<j);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_clear_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i,j;\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i) return(0);\\r\\na->d[i]&=(~(((BN_ULONG)1)<<j));\\r\\nbn_fix_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint BN_is_bit_set(const BIGNUM *a, int n)\\r\\n{\\r\\nint i,j;\\r\\nif (n < 0) return(0);\\r\\ni=n/BN_BITS2;\\r\\nj=n%BN_BITS2;\\r\\nif (a->top <= i) return(0);\\r\\nreturn((a->d[i]&(((BN_ULONG)1)<<j))?1:0);\\r\\n}\\r\\nint BN_mask_bits(BIGNUM *a, int n)\\r\\n{\\r\\nint b,w;\\r\\nw=n/BN_BITS2;\\r\\nb=n%BN_BITS2;\\r\\nif (w >= a->top) return(0);\\r\\nif (b == 0)\\r\\na->top=w;\\r\\nelse\\r\\n{\\r\\na->top=w+1;\\r\\na->d[w]&= ~(BN_MASK2<<b);\\r\\n}\\r\\nbn_fix_top(a);\\r\\nreturn(1);\\r\\n}\\r\\nint bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG aa,bb;\\r\\naa=a[n-1];\\r\\nbb=b[n-1];\\r\\nif (aa != bb) return((aa > bb)?1:-1);\\r\\nfor (i=n-2; i>=0; i--)\\r\\n{\\r\\naa=a[i];\\r\\nbb=b[i];\\r\\nif (aa != bb) return((aa > bb)?1:-1);\\r\\n}\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_buf_err_c", "target": 0, "func": "void ERR_load_BUF_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_BUF,BUF_str_functs);\\r\\nERR_load_strings(ERR_LIB_BUF,BUF_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_val_c", "target": 0, "func": "int i2d_X509_VAL(X509_VAL *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->notBefore,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_len(a->notAfter,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->notBefore,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_put(a->notAfter,i2d_ASN1_TIME);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_VAL *d2i_X509_VAL(X509_VAL **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_VAL *,X509_VAL_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->notBefore,d2i_ASN1_TIME);\\r\\nM_ASN1_D2I_get(ret->notAfter,d2i_ASN1_TIME);\\r\\nM_ASN1_D2I_Finish(a,X509_VAL_free,ASN1_F_D2I_X509_VAL);\\r\\n}\\r\\nX509_VAL *X509_VAL_new(void)\\r\\n{\\r\\nX509_VAL *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_VAL);\\r\\nM_ASN1_New(ret->notBefore,ASN1_TIME_new);\\r\\nM_ASN1_New(ret->notAfter,ASN1_TIME_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_VAL_NEW);\\r\\n}\\r\\nvoid X509_VAL_free(X509_VAL *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_TIME_free(a->notBefore);\\r\\nASN1_TIME_free(a->notAfter);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_lib_c", "target": 0, "func": "int i2d_PKCS7(PKCS7 *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nif (a->asn1 != NULL)\\r\\n{\\r\\nif (pp == NULL)\\r\\nreturn((int)a->length);\\r\\nmemcpy(*pp,a->asn1,(int)a->length);\\r\\n*pp+=a->length;\\r\\nreturn((int)a->length);\\r\\n}\\r\\nret+=4;\\r\\nM_ASN1_I2D_len(a->type,i2d_ASN1_OBJECT);\\r\\nif (a->d.ptr != NULL)\\r\\n{\\r\\nret+=4;\\r\\nswitch (OBJ_obj2nid(a->type))\\r\\n{\\r\\ncase NID_pkcs7_data:\\r\\nM_ASN1_I2D_len(a->d.data,i2d_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nM_ASN1_I2D_len(a->d.sign,i2d_PKCS7_SIGNED);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nM_ASN1_I2D_len(a->d.enveloped,i2d_PKCS7_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nM_ASN1_I2D_len(a->d.signed_and_enveloped,\\r\\ni2d_PKCS7_SIGN_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nM_ASN1_I2D_len(a->d.digest,i2d_PKCS7_DIGEST);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\nM_ASN1_I2D_len(a->d.encrypted,i2d_PKCS7_ENCRYPT);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nr=ret;\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nM_ASN1_I2D_INF_seq_start(V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nM_ASN1_I2D_put(a->type,i2d_ASN1_OBJECT);\\r\\nif (a->d.ptr != NULL)\\r\\n{\\r\\nM_ASN1_I2D_INF_seq_start(0,V_ASN1_CONTEXT_SPECIFIC);\\r\\nswitch (OBJ_obj2nid(a->type))\\r\\n{\\r\\ncase NID_pkcs7_data:\\r\\nM_ASN1_I2D_put(a->d.data,i2d_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nM_ASN1_I2D_put(a->d.sign,i2d_PKCS7_SIGNED);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nM_ASN1_I2D_put(a->d.enveloped,i2d_PKCS7_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nM_ASN1_I2D_put(a->d.signed_and_enveloped,\\r\\ni2d_PKCS7_SIGN_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nM_ASN1_I2D_put(a->d.digest,i2d_PKCS7_DIGEST);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\nM_ASN1_I2D_put(a->d.encrypted,i2d_PKCS7_ENCRYPT);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_INF_seq_end();\\r\\n}\\r\\nM_ASN1_I2D_INF_seq_end();\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7 *d2i_PKCS7(PKCS7 **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7 *,PKCS7_new);\\r\\nif ((a != NULL) && ((*a) != NULL))\\r\\n{\\r\\nif ((*a)->asn1 != NULL)\\r\\n{\\r\\nFree((char *)(*a)->asn1);\\r\\n(*a)->asn1=NULL;\\r\\n}\\r\\n(*a)->length=0;\\r\\n}\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->type,d2i_ASN1_OBJECT);\\r\\nif (!M_ASN1_D2I_end_sequence())\\r\\n{\\r\\nint Tinf,Ttag,Tclass;\\r\\nlong Tlen;\\r\\nif (M_ASN1_next != (V_ASN1_CONSTRUCTED|\\r\\nV_ASN1_CONTEXT_SPECIFIC|0))\\r\\n{\\r\\nc.error=ASN1_R_BAD_PKCS7_CONTENT;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nret->detached=0;\\r\\nc.q=c.p;\\r\\nTinf=ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,\\r\\n(c.inf & 1)?(length+ *pp-c.q):c.slen);\\r\\nif (Tinf & 0x80) { c.line=__LINE__; goto err; }\\r\\nc.slen-=(c.p-c.q);\\r\\nswitch (OBJ_obj2nid(ret->type))\\r\\n{\\r\\ncase NID_pkcs7_data:\\r\\nM_ASN1_D2I_get(ret->d.data,d2i_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nM_ASN1_D2I_get(ret->d.sign,d2i_PKCS7_SIGNED);\\r\\nif (ret->d.sign->contents->d.ptr == NULL)\\r\\nret->detached=1;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nM_ASN1_D2I_get(ret->d.enveloped,d2i_PKCS7_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nM_ASN1_D2I_get(ret->d.signed_and_enveloped,\\r\\nd2i_PKCS7_SIGN_ENVELOPE);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nM_ASN1_D2I_get(ret->d.digest,d2i_PKCS7_DIGEST);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\nM_ASN1_D2I_get(ret->d.encrypted,d2i_PKCS7_ENCRYPT);\\r\\nbreak;\\r\\ndefault:\\r\\nc.error=ASN1_R_BAD_PKCS7_TYPE;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nif (Tinf == (1|V_ASN1_CONSTRUCTED))\\r\\n{\\r\\nif (!ASN1_check_infinite_end(&c.p,c.slen))\\r\\n{\\r\\nc.error=ERR_R_MISSING_ASN1_EOS;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\nret->detached=1;\\r\\nM_ASN1_D2I_Finish(a,PKCS7_free,ASN1_F_D2I_PKCS7);\\r\\n}\\r\\nPKCS7 *PKCS7_new(void)\\r\\n{\\r\\nPKCS7 *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7);\\r\\nret->type=OBJ_nid2obj(NID_undef);\\r\\nret->asn1=NULL;\\r\\nret->length=0;\\r\\nret->detached=0;\\r\\nret->d.ptr=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_NEW);\\r\\n}\\r\\nvoid PKCS7_free(PKCS7 *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nPKCS7_content_free(a);\\r\\nif (a->type != NULL)\\r\\n{\\r\\nASN1_OBJECT_free(a->type);\\r\\n}\\r\\nFree((char *)(char *)a);\\r\\n}\\r\\nvoid PKCS7_content_free(PKCS7 *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->asn1 != NULL) Free((char *)a->asn1);\\r\\nif (a->d.ptr != NULL)\\r\\n{\\r\\nif (a->type == NULL) return;\\r\\nswitch (OBJ_obj2nid(a->type))\\r\\n{\\r\\ncase NID_pkcs7_data:\\r\\nASN1_OCTET_STRING_free(a->d.data);\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nPKCS7_SIGNED_free(a->d.sign);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nPKCS7_ENVELOPE_free(a->d.enveloped);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nPKCS7_SIGN_ENVELOPE_free(a->d.signed_and_enveloped);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nPKCS7_DIGEST_free(a->d.digest);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\nPKCS7_ENCRYPT_free(a->d.encrypted);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\na->d.ptr=NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ca_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint total=0;\\r\\nint total_done=0;\\r\\nint badops=0;\\r\\nint ret=1;\\r\\nint req=0;\\r\\nint verbose=0;\\r\\nint gencrl=0;\\r\\nint dorevoke=0;\\r\\nlong crldays=0;\\r\\nlong crlhours=0;\\r\\nlong errorline= -1;\\r\\nchar *configfile=NULL;\\r\\nchar *md=NULL;\\r\\nchar *policy=NULL;\\r\\nchar *keyfile=NULL;\\r\\nchar *certfile=NULL;\\r\\nchar *infile=NULL;\\r\\nchar *spkac_file=NULL;\\r\\nchar *ss_cert_file=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nint output_der = 0;\\r\\nchar *outfile=NULL;\\r\\nchar *outdir=NULL;\\r\\nchar *serialfile=NULL;\\r\\nchar *extensions=NULL;\\r\\nchar *crl_ext=NULL;\\r\\nBIGNUM *serial=NULL;\\r\\nchar *startdate=NULL;\\r\\nchar *enddate=NULL;\\r\\nint days=0;\\r\\nint batch=0;\\r\\nX509 *x509=NULL;\\r\\nX509 *x=NULL;\\r\\nBIO *in=NULL,*out=NULL,*Sout=NULL,*Cout=NULL;\\r\\nchar *dbfile=NULL;\\r\\nTXT_DB *db=NULL;\\r\\nX509_CRL *crl=NULL;\\r\\nX509_CRL_INFO *ci=NULL;\\r\\nX509_REVOKED *r=NULL;\\r\\nchar **pp,*p,*f;\\r\\nint i,j;\\r\\nlong l;\\r\\nconst EVP_MD *dgst=NULL;\\r\\nSTACK_OF(CONF_VALUE) *attribs=NULL;\\r\\nSTACK *cert_sk=NULL;\\r\\nBIO *hex=NULL;\\r\\n#undef BSIZE\\r\\n#define BSIZE 256\\r\\nMS_STATIC char buf[3][BSIZE];\\r\\n#ifdef EFENCE\\r\\nEF_PROTECT_FREE=1;\\r\\nEF_PROTECT_BELOW=1;\\r\\nEF_ALIGNMENT=0;\\r\\n#endif\\r\\napps_startup();\\r\\nX509V3_add_standard_extensions();\\r\\npreserve=0;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-verbose\") == 0)\\r\\nverbose=1;\\r\\nelse if (strcmp(*argv,\"-config\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nconfigfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-name\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nsection= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-startdate\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nstartdate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-enddate\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nenddate= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-days\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ndays=atoi(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-md\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nmd= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-policy\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\npolicy= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-keyfile\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeyfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkey= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncertfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outdir\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutdir= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-batch\") == 0)\\r\\nbatch=1;\\r\\nelse if (strcmp(*argv,\"-preserveDN\") == 0)\\r\\npreserve=1;\\r\\nelse if (strcmp(*argv,\"-gencrl\") == 0)\\r\\ngencrl=1;\\r\\nelse if (strcmp(*argv,\"-msie_hack\") == 0)\\r\\nmsie_hack=1;\\r\\nelse if (strcmp(*argv,\"-crldays\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncrldays= atol(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-crlhours\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ncrlhours= atol(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-infiles\") == 0)\\r\\n{\\r\\nargc--;\\r\\nargv++;\\r\\nreq=1;\\r\\nbreak;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-ss_cert\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nss_cert_file = *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv, \"-spkac\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nspkac_file = *(++argv);\\r\\nreq=1;\\r\\n}\\r\\nelse if (strcmp(*argv,\"-revoke\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\ndorevoke=1;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nfor (pp=ca_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,*pp);\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (configfile == NULL) configfile = getenv(\"OPENSSL_CONF\");\\r\\nif (configfile == NULL) configfile = getenv(\"SSLEAY_CONF\");\\r\\nif (configfile == NULL)\\r\\n{\\r\\n#ifdef VMS\\r\\nstrncpy(buf[0],X509_get_default_cert_area(),\\r\\nsizeof(buf[0])-1-sizeof(CONFIG_FILE));\\r\\n#else\\r\\nstrncpy(buf[0],X509_get_default_cert_area(),\\r\\nsizeof(buf[0])-2-sizeof(CONFIG_FILE));\\r\\nstrcat(buf[0],\"/\");\\r\\n#endif\\r\\nstrcat(buf[0],CONFIG_FILE);\\r\\nconfigfile=buf[0];\\r\\n}\\r\\nBIO_printf(bio_err,\"Using configuration from %s\\n\",configfile);\\r\\nif ((conf=CONF_load(NULL,configfile,&errorline)) == NULL)\\r\\n{\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err,\"error loading the config file '%s'\\n\",\\r\\nconfigfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\"error on line %ld of config file '%s'\\n\"\\r\\n,errorline,configfile);\\r\\ngoto err;\\r\\n}\\r\\nif (section == NULL)\\r\\n{\\r\\nsection=CONF_get_string(conf,BASE_SECTION,ENV_DEFAULT_CA);\\r\\nif (section == NULL)\\r\\n{\\r\\nlookup_fail(BASE_SECTION,ENV_DEFAULT_CA);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (conf != NULL)\\r\\n{\\r\\np=CONF_get_string(conf,NULL,\"oid_file\");\\r\\nif (p != NULL)\\r\\n{\\r\\nBIO *oid_bio;\\r\\noid_bio=BIO_new_file(p,\"r\");\\r\\nif (oid_bio == NULL)\\r\\n{\\r\\nERR_clear_error();\\r\\n}\\r\\nelse\\r\\n{\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\n}\\r\\nif(!add_oid_section(conf)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nSout=BIO_new(BIO_s_file());\\r\\nCout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL) || (Sout == NULL) || (Cout == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif ((keyfile == NULL) && ((keyfile=CONF_get_string(conf,\\r\\nsection,ENV_PRIVATE_KEY)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in,keyfile) <= 0)\\r\\n{\\r\\nperror(keyfile);\\r\\nBIO_printf(bio_err,\"trying to load CA private key\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (key == NULL)\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,NULL,NULL);\\r\\nelse\\r\\n{\\r\\npkey=PEM_read_bio_PrivateKey(in,NULL,key_callback,NULL);\\r\\nmemset(key,0,strlen(key));\\r\\n}\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CA private key\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((certfile == NULL) && ((certfile=CONF_get_string(conf,\\r\\nsection,ENV_CERTIFICATE)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in,certfile) <= 0)\\r\\n{\\r\\nperror(certfile);\\r\\nBIO_printf(bio_err,\"trying to load CA certificate\\n\");\\r\\ngoto err;\\r\\n}\\r\\nx509=PEM_read_bio_X509(in,NULL,NULL,NULL);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load CA certificate\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!X509_check_private_key(x509,pkey))\\r\\n{\\r\\nBIO_printf(bio_err,\"CA certificate and CA private key do not match\\n\");\\r\\ngoto err;\\r\\n}\\r\\nf=CONF_get_string(conf,BASE_SECTION,ENV_PRESERVE);\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\npreserve=1;\\r\\nf=CONF_get_string(conf,BASE_SECTION,ENV_MSIE_HACK);\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\nmsie_hack=1;\\r\\nif ((outdir == NULL) && (req))\\r\\n{\\r\\nstruct stat sb;\\r\\nif ((outdir=CONF_get_string(conf,section,ENV_NEW_CERTS_DIR))\\r\\n== NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"there needs to be defined a directory for new certificate to be placed in\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef VMS\\r\\nif (access(outdir,R_OK|W_OK) != 0)\\r\\n#else\\r\\nif (access(outdir,R_OK|W_OK|X_OK) != 0)\\r\\n#endif\\r\\n{\\r\\nBIO_printf(bio_err,\"I am unable to acces the %s directory\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\nif (stat(outdir,&sb) != 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to stat(%s)\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\nif (!(sb.st_mode & S_IFDIR))\\r\\n{\\r\\nBIO_printf(bio_err,\"%s need to be a directory\\n\",outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((dbfile=CONF_get_string(conf,section,ENV_DATABASE)) == NULL)\\r\\n{\\r\\nlookup_fail(section,ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in,dbfile) <= 0)\\r\\n{\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\",dbfile);\\r\\ngoto err;\\r\\n}\\r\\ndb=TXT_DB_read(in,DB_NUMBER);\\r\\nif (db == NULL) goto err;\\r\\nfor (i=0; i<sk_num(db->data); i++)\\r\\n{\\r\\npp=(char **)sk_value(db->data,i);\\r\\nif ((pp[DB_type][0] != DB_TYPE_REV) &&\\r\\n(pp[DB_rev_date][0] != '\\0'))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: not revoked yet, but has a revocation date\\n\",i+1);\\r\\ngoto err;\\r\\n}\\r\\nif ((pp[DB_type][0] == DB_TYPE_REV) &&\\r\\n!check_time_format(pp[DB_rev_date]))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: invalid revocation date\\n\",\\r\\ni+1);\\r\\ngoto err;\\r\\n}\\r\\nif (!check_time_format(pp[DB_exp_date]))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: invalid expiry date\\n\",i+1);\\r\\ngoto err;\\r\\n}\\r\\np=pp[DB_serial];\\r\\nj=strlen(p);\\r\\nif ((j&1) || (j < 2))\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: bad serial number length (%d)\\n\",i+1,j);\\r\\ngoto err;\\r\\n}\\r\\nwhile (*p)\\r\\n{\\r\\nif (!( ((*p >= '0') && (*p <= '9')) ||\\r\\n((*p >= 'A') && (*p <= 'F')) ||\\r\\n((*p >= 'a') && (*p <= 'f'))) )\\r\\n{\\r\\nBIO_printf(bio_err,\"entry %d: bad serial number characters, char pos %ld, char is '%c'\\n\",i+1,(long)(p-pp[DB_serial]),*p);\\r\\ngoto err;\\r\\n}\\r\\np++;\\r\\n}\\r\\n}\\r\\nif (verbose)\\r\\n{\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nTXT_DB_write(out,db);\\r\\nBIO_printf(bio_err,\"%d entries loaded from the database\\n\",\\r\\ndb->data->num);\\r\\nBIO_printf(bio_err,\"generating indexs\\n\");\\r\\n}\\r\\nif (!TXT_DB_create_index(db,DB_serial,NULL,index_serial_hash,\\r\\nindex_serial_cmp))\\r\\n{\\r\\nBIO_printf(bio_err,\"error creating serial number index:(%ld,%ld,%ld)\\n\",db->error,db->arg1,db->arg2);\\r\\ngoto err;\\r\\n}\\r\\nif (!TXT_DB_create_index(db,DB_name,index_name_qual,index_name_hash,\\r\\nindex_name_cmp))\\r\\n{\\r\\nBIO_printf(bio_err,\"error creating name index:(%ld,%ld,%ld)\\n\",\\r\\ndb->error,db->arg1,db->arg2);\\r\\ngoto err;\\r\\n}\\r\\nif (req || gencrl)\\r\\n{\\r\\nif (outfile != NULL)\\r\\n{\\r\\nif (BIO_write_filename(Sout,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nBIO_set_fp(Sout,stdout,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\n}\\r\\nif (req)\\r\\n{\\r\\nif ((md == NULL) && ((md=CONF_get_string(conf,\\r\\nsection,ENV_DEFAULT_MD)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_DEFAULT_MD);\\r\\ngoto err;\\r\\n}\\r\\nif ((dgst=EVP_get_digestbyname(md)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s is an unsupported message digest type\\n\",md);\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"message digest is %s\\n\",\\r\\nOBJ_nid2ln(dgst->type));\\r\\nif ((policy == NULL) && ((policy=CONF_get_string(conf,\\r\\nsection,ENV_POLICY)) == NULL))\\r\\n{\\r\\nlookup_fail(section,ENV_POLICY);\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"policy is %s\\n\",policy);\\r\\nif ((serialfile=CONF_get_string(conf,section,ENV_SERIAL))\\r\\n== NULL)\\r\\n{\\r\\nlookup_fail(section,ENV_SERIAL);\\r\\ngoto err;\\r\\n}\\r\\nextensions=CONF_get_string(conf,section,ENV_EXTENSIONS);\\r\\nif(extensions) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_conf_lhash(&ctx, conf);\\r\\nif(!X509V3_EXT_add_conf(conf, &ctx, extensions, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (startdate == NULL)\\r\\n{\\r\\nstartdate=CONF_get_string(conf,section,\\r\\nENV_DEFAULT_STARTDATE);\\r\\n}\\r\\nif (startdate && !ASN1_UTCTIME_set_string(NULL,startdate))\\r\\n{\\r\\nBIO_printf(bio_err,\"start date is invalid, it should be YYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (startdate == NULL) startdate=\"today\";\\r\\nif (enddate == NULL)\\r\\n{\\r\\nenddate=CONF_get_string(conf,section,\\r\\nENV_DEFAULT_ENDDATE);\\r\\n}\\r\\nif (enddate && !ASN1_UTCTIME_set_string(NULL,enddate))\\r\\n{\\r\\nBIO_printf(bio_err,\"end date is invalid, it should be YYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (days == 0)\\r\\n{\\r\\ndays=(int)CONF_get_number(conf,section,\\r\\nENV_DEFAULT_DAYS);\\r\\n}\\r\\nif (!enddate && (days == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"cannot lookup how many days to certify for\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((serial=load_serial(serialfile)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error while loading serial number\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\n{\\r\\nif ((f=BN_bn2hex(serial)) == NULL) goto err;\\r\\nBIO_printf(bio_err,\"next serial number is %s\\n\",f);\\r\\nFree(f);\\r\\n}\\r\\nif ((attribs=CONF_get_section(conf,policy)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to find 'section' for %s\\n\",policy);\\r\\ngoto err;\\r\\n}\\r\\nif ((cert_sk=sk_new_null()) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (spkac_file != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify_spkac(&x,spkac_file,pkey,x509,dgst,attribs,db,\\r\\nserial,startdate,enddate, days,extensions,conf,\\r\\nverbose);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_push(cert_sk,(char *)x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (outfile)\\r\\n{\\r\\noutput_der = 1;\\r\\nbatch = 1;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (ss_cert_file != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify_cert(&x,ss_cert_file,pkey,x509,dgst,attribs,\\r\\ndb,serial,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_push(cert_sk,(char *)x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (infile != NULL)\\r\\n{\\r\\ntotal++;\\r\\nj=certify(&x,infile,pkey,x509,dgst,attribs,db,\\r\\nserial,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_push(cert_sk,(char *)x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nfor (i=0; i<argc; i++)\\r\\n{\\r\\ntotal++;\\r\\nj=certify(&x,argv[i],pkey,x509,dgst,attribs,db,\\r\\nserial,startdate,enddate,days,batch,\\r\\nextensions,conf,verbose);\\r\\nif (j < 0) goto err;\\r\\nif (j > 0)\\r\\n{\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nif (!BN_add_word(serial,1)) goto err;\\r\\nif (!sk_push(cert_sk,(char *)x))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (sk_num(cert_sk) > 0)\\r\\n{\\r\\nif (!batch)\\r\\n{\\r\\nBIO_printf(bio_err,\"\\n%d out of %d certificate requests certified, commit? [y/n]\",total_done,total);\\r\\n(void)BIO_flush(bio_err);\\r\\nbuf[0][0]='\\0';\\r\\nfgets(buf[0],10,stdin);\\r\\nif ((buf[0][0] != 'y') && (buf[0][0] != 'Y'))\\r\\n{\\r\\nBIO_printf(bio_err,\"CERTIFICATION CANCELED\\n\");\\r\\nret=0;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err,\"Write out database with %d new entries\\n\",sk_num(cert_sk));\\r\\nstrncpy(buf[0],serialfile,BSIZE-4);\\r\\n#ifdef VMS\\r\\nstrcat(buf[0],\"-new\");\\r\\n#else\\r\\nstrcat(buf[0],\".new\");\\r\\n#endif\\r\\nif (!save_serial(buf[0],serial)) goto err;\\r\\nstrncpy(buf[1],dbfile,BSIZE-4);\\r\\n#ifdef VMS\\r\\nstrcat(buf[1],\"-new\");\\r\\n#else\\r\\nstrcat(buf[1],\".new\");\\r\\n#endif\\r\\nif (BIO_write_filename(out,buf[1]) <= 0)\\r\\n{\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\",dbfile);\\r\\ngoto err;\\r\\n}\\r\\nl=TXT_DB_write(out,db);\\r\\nif (l <= 0) goto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"writing new certificates\\n\");\\r\\nfor (i=0; i<sk_num(cert_sk); i++)\\r\\n{\\r\\nint k;\\r\\nunsigned char *n;\\r\\nx=(X509 *)sk_value(cert_sk,i);\\r\\nj=x->cert_info->serialNumber->length;\\r\\np=(char *)x->cert_info->serialNumber->data;\\r\\nstrncpy(buf[2],outdir,BSIZE-(j*2)-6);\\r\\n#ifndef VMS\\r\\nstrcat(buf[2],\"/\");\\r\\n#endif\\r\\nn=(unsigned char *)&(buf[2][strlen(buf[2])]);\\r\\nif (j > 0)\\r\\n{\\r\\nfor (k=0; k<j; k++)\\r\\n{\\r\\nsprintf((char *)n,\"%02X\",(unsigned char)*(p++));\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n*(n++)='0';\\r\\n*(n++)='0';\\r\\n}\\r\\n*(n++)='.'; *(n++)='p'; *(n++)='e'; *(n++)='m';\\r\\n*n='\\0';\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\"writing %s\\n\",buf[2]);\\r\\nif (BIO_write_filename(Cout,buf[2]) <= 0)\\r\\n{\\r\\nperror(buf[2]);\\r\\ngoto err;\\r\\n}\\r\\nwrite_new_certificate(Cout,x, 0);\\r\\nwrite_new_certificate(Sout,x, output_der);\\r\\n}\\r\\nif (sk_num(cert_sk))\\r\\n{\\r\\nstrncpy(buf[2],serialfile,BSIZE-4);\\r\\n#ifdef VMS\\r\\nstrcat(buf[2],\"-old\");\\r\\n#else\\r\\nstrcat(buf[2],\".old\");\\r\\n#endif\\r\\nBIO_free(in);\\r\\nBIO_free(out);\\r\\nin=NULL;\\r\\nout=NULL;\\r\\nif (rename(serialfile,buf[2]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unabel to rename %s to %s\\n\",\\r\\nserialfile,buf[2]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\nif (rename(buf[0],serialfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unabel to rename %s to %s\\n\",\\r\\nbuf[0],serialfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[2],serialfile);\\r\\ngoto err;\\r\\n}\\r\\nstrncpy(buf[2],dbfile,BSIZE-4);\\r\\n#ifdef VMS\\r\\nstrcat(buf[2],\"-old\");\\r\\n#else\\r\\nstrcat(buf[2],\".old\");\\r\\n#endif\\r\\nif (rename(dbfile,buf[2]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unabel to rename %s to %s\\n\",\\r\\ndbfile,buf[2]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\nif (rename(buf[1],dbfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unabel to rename %s to %s\\n\",\\r\\nbuf[1],dbfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[2],dbfile);\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(bio_err,\"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nif (gencrl)\\r\\n{\\r\\ncrl_ext=CONF_get_string(conf,section,ENV_CRLEXT);\\r\\nif(crl_ext) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_conf_lhash(&ctx, conf);\\r\\nif(!X509V3_EXT_add_conf(conf, &ctx, crl_ext, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading CRL extension section %s\\n\",\\r\\ncrl_ext);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((hex=BIO_new(BIO_s_mem())) == NULL) goto err;\\r\\nif (!crldays && !crlhours)\\r\\n{\\r\\ncrldays=CONF_get_number(conf,section,\\r\\nENV_DEFAULT_CRL_DAYS);\\r\\ncrlhours=CONF_get_number(conf,section,\\r\\nENV_DEFAULT_CRL_HOURS);\\r\\n}\\r\\nif ((crldays == 0) && (crlhours == 0))\\r\\n{\\r\\nBIO_printf(bio_err,\"cannot lookup how long until the next CRL is issuer\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose) BIO_printf(bio_err,\"making CRL\\n\");\\r\\nif ((crl=X509_CRL_new()) == NULL) goto err;\\r\\nci=crl->crl;\\r\\nX509_NAME_free(ci->issuer);\\r\\nci->issuer=X509_NAME_dup(x509->cert_info->subject);\\r\\nif (ci->issuer == NULL) goto err;\\r\\nX509_gmtime_adj(ci->lastUpdate,0);\\r\\nif (ci->nextUpdate == NULL)\\r\\nci->nextUpdate=ASN1_UTCTIME_new();\\r\\nX509_gmtime_adj(ci->nextUpdate,(crldays*24+crlhours)*60*60);\\r\\nfor (i=0; i<sk_num(db->data); i++)\\r\\n{\\r\\npp=(char **)sk_value(db->data,i);\\r\\nif (pp[DB_type][0] == DB_TYPE_REV)\\r\\n{\\r\\nif ((r=X509_REVOKED_new()) == NULL) goto err;\\r\\nASN1_STRING_set((ASN1_STRING *)\\r\\nr->revocationDate,\\r\\n(unsigned char *)pp[DB_rev_date],\\r\\nstrlen(pp[DB_rev_date]));\\r\\n(void)BIO_reset(hex);\\r\\nif (!BIO_puts(hex,pp[DB_serial]))\\r\\ngoto err;\\r\\nif (!a2i_ASN1_INTEGER(hex,r->serialNumber,\\r\\nbuf[0],BSIZE)) goto err;\\r\\nsk_X509_REVOKED_push(ci->revoked,r);\\r\\n}\\r\\n}\\r\\nsk_X509_REVOKED_sort(ci->revoked);\\r\\nfor (i=0; i<sk_X509_REVOKED_num(ci->revoked); i++)\\r\\n{\\r\\nr=sk_X509_REVOKED_value(ci->revoked,i);\\r\\nr->sequence=i;\\r\\n}\\r\\nif (verbose) BIO_printf(bio_err,\"signing CRL\\n\");\\r\\nif (md != NULL)\\r\\n{\\r\\nif ((dgst=EVP_get_digestbyname(md)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s is an unsupported message digest type\\n\",md);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\ndgst=EVP_dss1();\\r\\nelse\\r\\n#endif\\r\\ndgst=EVP_md5();\\r\\n}\\r\\nif(crl_ext) {\\r\\nX509V3_CTX crlctx;\\r\\nif (ci->version == NULL)\\r\\nif ((ci->version=ASN1_INTEGER_new()) == NULL) goto err;\\r\\nASN1_INTEGER_set(ci->version,1);\\r\\nX509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\\r\\nX509V3_set_conf_lhash(&crlctx, conf);\\r\\nif(!X509V3_EXT_CRL_add_conf(conf, &crlctx,\\r\\ncrl_ext, crl)) goto err;\\r\\n}\\r\\nif (!X509_CRL_sign(crl,pkey,dgst)) goto err;\\r\\nPEM_write_bio_X509_CRL(Sout,crl);\\r\\n}\\r\\nif (dorevoke)\\r\\n{\\r\\nin=BIO_new(BIO_s_file());\\r\\nout=BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (infile == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"no input files\\n\");\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\nBIO_printf(bio_err,\"error trying to load '%s' certificate\\n\",infile);\\r\\ngoto err;\\r\\n}\\r\\nx509=PEM_read_bio_X509(in,NULL,NULL,NULL);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load '%s' certificate\\n\",infile);\\r\\ngoto err;\\r\\n}\\r\\nj=do_revoke(x509,db);\\r\\nstrncpy(buf[0],dbfile,BSIZE-4);\\r\\nstrcat(buf[0],\".new\");\\r\\nif (BIO_write_filename(out,buf[0]) <= 0)\\r\\n{\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err,\"unable to open '%s'\\n\",dbfile);\\r\\ngoto err;\\r\\n}\\r\\nj=TXT_DB_write(out,db);\\r\\nif (j <= 0) goto err;\\r\\nBIO_free(in);\\r\\nBIO_free(out);\\r\\nin=NULL;\\r\\nout=NULL;\\r\\nstrncpy(buf[1],dbfile,BSIZE-4);\\r\\nstrcat(buf[1],\".old\");\\r\\nif (rename(dbfile,buf[1]) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to rename %s to %s\\n\", dbfile, buf[1]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\nif (rename(buf[0],dbfile) < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to rename %s to %s\\n\", buf[0],dbfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[1],dbfile);\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(bio_err,\"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nerr:\\r\\nBIO_free(hex);\\r\\nBIO_free(Cout);\\r\\nBIO_free(Sout);\\r\\nBIO_free(out);\\r\\nBIO_free(in);\\r\\nsk_pop_free(cert_sk,X509_free);\\r\\nif (ret) ERR_print_errors(bio_err);\\r\\nBN_free(serial);\\r\\nTXT_DB_free(db);\\r\\nEVP_PKEY_free(pkey);\\r\\nX509_free(x509);\\r\\nX509_CRL_free(crl);\\r\\nCONF_free(conf);\\r\\nX509V3_EXT_cleanup();\\r\\nOBJ_cleanup();\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void lookup_fail(char *name, char *tag)\\r\\n{\\r\\nBIO_printf(bio_err,\"variable lookup failed for %s::%s\\n\",name,tag);\\r\\n}\\r\\nstatic int MS_CALLBACK key_callback(char *buf, int len, int verify, void *u)\\r\\n{\\r\\nint i;\\r\\nif (key == NULL) return(0);\\r\\ni=strlen(key);\\r\\ni=(i > len)?len:i;\\r\\nmemcpy(buf,key,i);\\r\\nreturn(i);\\r\\n}\\r\\nstatic unsigned long index_serial_hash(char **a)\\r\\n{\\r\\nchar *n;\\r\\nn=a[DB_serial];\\r\\nwhile (*n == '0') n++;\\r\\nreturn(lh_strhash(n));\\r\\n}\\r\\nstatic int index_serial_cmp(char **a, char **b)\\r\\n{\\r\\nchar *aa,*bb;\\r\\nfor (aa=a[DB_serial]; *aa == '0'; aa++);\\r\\nfor (bb=b[DB_serial]; *bb == '0'; bb++);\\r\\nreturn(strcmp(aa,bb));\\r\\n}\\r\\nstatic unsigned long index_name_hash(char **a)\\r\\n{ return(lh_strhash(a[DB_name])); }\\r\\nstatic int index_name_qual(char **a)\\r\\n{ return(a[0][0] == 'V'); }\\r\\nstatic int index_name_cmp(char **a, char **b)\\r\\n{ return(strcmp(a[DB_name],\\r\\nb[DB_name])); }\\r\\nstatic BIGNUM *load_serial(char *serialfile)\\r\\n{\\r\\nBIO *in=NULL;\\r\\nBIGNUM *ret=NULL;\\r\\nMS_STATIC char buf[1024];\\r\\nASN1_INTEGER *ai=NULL;\\r\\nif ((in=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in,serialfile) <= 0)\\r\\n{\\r\\nperror(serialfile);\\r\\ngoto err;\\r\\n}\\r\\nai=ASN1_INTEGER_new();\\r\\nif (ai == NULL) goto err;\\r\\nif (!a2i_ASN1_INTEGER(in,ai,buf,1024))\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load number from %s\\n\",\\r\\nserialfile);\\r\\ngoto err;\\r\\n}\\r\\nret=ASN1_INTEGER_to_BN(ai,NULL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error converting number from bin to BIGNUM\");\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (ai != NULL) ASN1_INTEGER_free(ai);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int save_serial(char *serialfile, BIGNUM *serial)\\r\\n{\\r\\nBIO *out;\\r\\nint ret=0;\\r\\nASN1_INTEGER *ai=NULL;\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_write_filename(out,serialfile) <= 0)\\r\\n{\\r\\nperror(serialfile);\\r\\ngoto err;\\r\\n}\\r\\nif ((ai=BN_to_ASN1_INTEGER(serial,NULL)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"error converting serial to ASN.1 format\\n\");\\r\\ngoto err;\\r\\n}\\r\\ni2a_ASN1_INTEGER(out,ai);\\r\\nBIO_puts(out,\"\\n\");\\r\\nret=1;\\r\\nerr:\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (ai != NULL) ASN1_INTEGER_free(ai);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void write_new_certificate(BIO *bp, X509 *x, int output_der)\\r\\n{\\r\\nchar *f;\\r\\nchar buf[256];\\r\\nif (output_der)\\r\\n{\\r\\n(void)i2d_X509_bio(bp,x);\\r\\nreturn;\\r\\n}\\r\\nf=X509_NAME_oneline(X509_get_issuer_name(x),buf,256);\\r\\nBIO_printf(bp,\"issuer :%s\\n\",f);\\r\\nf=X509_NAME_oneline(X509_get_subject_name(x),buf,256);\\r\\nBIO_printf(bp,\"subject:%s\\n\",f);\\r\\nBIO_puts(bp,\"serial :\");\\r\\ni2a_ASN1_INTEGER(bp,x->cert_info->serialNumber);\\r\\nBIO_puts(bp,\"\\n\\n\");\\r\\nX509_print(bp,x);\\r\\nBIO_puts(bp,\"\\n\");\\r\\nPEM_write_bio_X509(bp,x);\\r\\nBIO_puts(bp,\"\\n\");\\r\\n}\\r\\nstatic int fix_data(int nid, int *type)\\r\\n{\\r\\nif (nid == NID_pkcs9_emailAddress)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nif ((nid == NID_commonName) && (*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_challengePassword) && (*type == V_ASN1_IA5STRING))\\r\\n*type=V_ASN1_T61STRING;\\r\\nif ((nid == NID_pkcs9_unstructuredName) && (*type == V_ASN1_T61STRING))\\r\\nreturn(0);\\r\\nif (nid == NID_pkcs9_unstructuredName)\\r\\n*type=V_ASN1_IA5STRING;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int check_time_format(char *str)\\r\\n{\\r\\nASN1_UTCTIME tm;\\r\\ntm.data=(unsigned char *)str;\\r\\ntm.length=strlen(str);\\r\\ntm.type=V_ASN1_UTCTIME;\\r\\nreturn(ASN1_UTCTIME_check(&tm));\\r\\n}\\r\\nstatic int add_oid_section(LHASH *hconf)\\r\\n{\\r\\nchar *p;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *cnf;\\r\\nint i;\\r\\nif(!(p=CONF_get_string(hconf,NULL,\"oid_section\"))) return 1;\\r\\nif(!(sktmp = CONF_get_section(hconf, p))) {\\r\\nBIO_printf(bio_err, \"problem loading oid section %s\\n\", p);\\r\\nreturn 0;\\r\\n}\\r\\nfor(i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\ncnf = sk_CONF_VALUE_value(sktmp, i);\\r\\nif(OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {\\r\\nBIO_printf(bio_err, \"problem creating object %s=%s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_revoke(X509 *x509, TXT_DB *db)\\r\\n{\\r\\nASN1_UTCTIME *tm=NULL;\\r\\nchar *row[DB_NUMBER],**rrow,**irow;\\r\\nint ok=-1,i;\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\nrow[i]=NULL;\\r\\nrow[DB_name]=X509_NAME_oneline(x509->cert_info->subject,NULL,0);\\r\\nrow[DB_serial]=BN_bn2hex(ASN1_INTEGER_to_BN(x509->cert_info->serialNumber,NULL));\\r\\nif ((row[DB_name] == NULL) || (row[DB_serial] == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nrrow=TXT_DB_get_by_index(db,DB_name,row);\\r\\nif (rrow == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Adding Entry to DB for %s\\n\", row[DB_name]);\\r\\nrow[DB_type]=(char *)Malloc(2);\\r\\ntm=X509_get_notAfter(x509);\\r\\nrow[DB_exp_date]=(char *)Malloc(tm->length+1);\\r\\nmemcpy(row[DB_exp_date],tm->data,tm->length);\\r\\nrow[DB_exp_date][tm->length]='\\0';\\r\\nrow[DB_rev_date]=NULL;\\r\\nrow[DB_file]=(char *)Malloc(8);\\r\\nif ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||\\r\\n(row[DB_file] == NULL))\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nstrcpy(row[DB_file],\"unknown\");\\r\\nrow[DB_type][0]='V';\\r\\nrow[DB_type][1]='\\0';\\r\\nif ((irow=(char **)Malloc(sizeof(char *)*(DB_NUMBER+1))) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\n{\\r\\nirow[i]=row[i];\\r\\nrow[i]=NULL;\\r\\n}\\r\\nirow[DB_NUMBER]=NULL;\\r\\nif (!TXT_DB_insert(db,irow))\\r\\n{\\r\\nBIO_printf(bio_err,\"failed to update database\\n\");\\r\\nBIO_printf(bio_err,\"TXT_DB error number %ld\\n\",db->error);\\r\\ngoto err;\\r\\n}\\r\\ndo_revoke(x509,db);\\r\\nok=1;\\r\\ngoto err;\\r\\n}\\r\\nelse if (index_serial_cmp(row,rrow))\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR:no same serial number %s\\n\",\\r\\nrow[DB_serial]);\\r\\ngoto err;\\r\\n}\\r\\nelse if (rrow[DB_type][0]=='R')\\r\\n{\\r\\nBIO_printf(bio_err,\"ERROR:Already revoked, serial number %s\\n\",\\r\\nrow[DB_serial]);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"Revoking Certificate %s.\\n\", rrow[DB_serial]);\\r\\ntm=X509_gmtime_adj(tm,0);\\r\\nrrow[DB_type][0]='R';\\r\\nrrow[DB_type][1]='\\0';\\r\\nrrow[DB_rev_date]=(char *)Malloc(tm->length+1);\\r\\nmemcpy(rrow[DB_rev_date],tm->data,tm->length);\\r\\nrrow[DB_rev_date][tm->length]='\\0';\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nfor (i=0; i<DB_NUMBER; i++)\\r\\n{\\r\\nif (row[i] != NULL)\\r\\nFree(row[i]);\\r\\n}\\r\\nASN1_UTCTIME_free(tm);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_r2_c", "target": 0, "func": "EVP_CIPHER *EVP_rc2_cbc(void)\\r\\n{\\r\\nreturn(&r2_cbc_cipher);\\r\\n}\\r\\nEVP_CIPHER *EVP_rc2_64_cbc(void)\\r\\n{\\r\\nreturn(&r2_64_cbc_cipher);\\r\\n}\\r\\nEVP_CIPHER *EVP_rc2_40_cbc(void)\\r\\n{\\r\\nreturn(&r2_40_cbc_cipher);\\r\\n}\\r\\nstatic void rc2_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC2_set_key(&(ctx->c.rc2_ks),EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey,EVP_CIPHER_CTX_key_length(ctx)*8);\\r\\n}\\r\\nstatic void rc2_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC2_cbc_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.rc2_ks),&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}\\r\\nstatic int rc2_meth_to_magic(const EVP_CIPHER *e)\\r\\n{\\r\\nint i;\\r\\ni=EVP_CIPHER_key_length(e);\\r\\nif (i == 16) return(RC2_128_MAGIC);\\r\\nelse if (i == 8) return(RC2_64_MAGIC);\\r\\nelse if (i == 5) return(RC2_40_MAGIC);\\r\\nelse return(0);\\r\\n}\\r\\nstatic EVP_CIPHER *rc2_magic_to_meth(int i)\\r\\n{\\r\\nif (i == RC2_128_MAGIC) return(EVP_rc2_cbc());\\r\\nelse if (i == RC2_64_MAGIC) return(EVP_rc2_64_cbc());\\r\\nelse if (i == RC2_40_MAGIC) return(EVP_rc2_40_cbc());\\r\\nelse\\r\\n{\\r\\nEVPerr(EVP_F_RC2_MAGIC_TO_METH,EVP_R_UNSUPPORTED_KEY_SIZE);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nstatic int rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num=0;\\r\\nint i=0,l;\\r\\nEVP_CIPHER *e;\\r\\nif (type != NULL)\\r\\n{\\r\\nl=EVP_CIPHER_CTX_iv_length(c);\\r\\ni=ASN1_TYPE_get_int_octetstring(type,&num,c->oiv,l);\\r\\nif (i != l)\\r\\nreturn(-1);\\r\\nelse if (i > 0)\\r\\nmemcpy(c->iv,c->oiv,l);\\r\\ne=rc2_magic_to_meth((int)num);\\r\\nif (e == NULL)\\r\\nreturn(-1);\\r\\nif (e != EVP_CIPHER_CTX_cipher(c))\\r\\n{\\r\\nEVP_CIPHER_CTX_cipher(c)=e;\\r\\nrc2_cbc_init_key(c,NULL,NULL,1);\\r\\n}\\r\\n}\\r\\nreturn(i);\\r\\n}\\r\\nstatic int rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num;\\r\\nint i=0,j;\\r\\nif (type != NULL)\\r\\n{\\r\\nnum=rc2_meth_to_magic(EVP_CIPHER_CTX_cipher(c));\\r\\nj=EVP_CIPHER_CTX_iv_length(c);\\r\\ni=ASN1_TYPE_set_int_octetstring(type,num,c->oiv,j);\\r\\n}\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_conn_c", "target": 0, "func": "static int conn_state(BIO *b, BIO_CONNECT *c)\\r\\n{\\r\\nint ret= -1,i;\\r\\nunsigned long l;\\r\\nchar *p,*q;\\r\\nint (*cb)()=NULL;\\r\\nif (c->info_callback != NULL)\\r\\ncb=c->info_callback;\\r\\nfor (;;)\\r\\n{\\r\\nswitch (c->state)\\r\\n{\\r\\ncase BIO_CONN_S_BEFORE:\\r\\np=c->param_hostname;\\r\\nif (p == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_HOSTNAME_SPECIFIED);\\r\\ngoto exit_loop;\\r\\n}\\r\\nfor ( ; *p != '\\0'; p++)\\r\\n{\\r\\nif ((*p == ':') || (*p == '/')) break;\\r\\n}\\r\\ni= *p;\\r\\nif ((i == ':') || (i == '/'))\\r\\n{\\r\\n*(p++)='\\0';\\r\\nif (i == ':')\\r\\n{\\r\\nfor (q=p; *q; q++)\\r\\nif (*q == '/')\\r\\n{\\r\\n*q='\\0';\\r\\nbreak;\\r\\n}\\r\\nif (c->param_port != NULL)\\r\\nFree(c->param_port);\\r\\nc->param_port=BUF_strdup(p);\\r\\n}\\r\\n}\\r\\nif (c->param_port == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_PORT_SPECIFIED);\\r\\nERR_add_error_data(2,\"host=\",c->param_hostname);\\r\\ngoto exit_loop;\\r\\n}\\r\\nc->state=BIO_CONN_S_GET_IP;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_IP:\\r\\nif (BIO_get_host_ip(c->param_hostname,&(c->ip[0])) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state=BIO_CONN_S_GET_PORT;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_PORT:\\r\\nif (c->param_port == NULL)\\r\\n{\\r\\nabort();\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse if (BIO_get_port(c->param_port,&c->port) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state=BIO_CONN_S_CREATE_SOCKET;\\r\\nbreak;\\r\\ncase BIO_CONN_S_CREATE_SOCKET:\\r\\nmemset((char *)&c->them,0,sizeof(c->them));\\r\\nc->them.sin_family=AF_INET;\\r\\nc->them.sin_port=htons((unsigned short)c->port);\\r\\nl=(unsigned long)\\r\\n((unsigned long)c->ip[0]<<24L)|\\r\\n((unsigned long)c->ip[1]<<16L)|\\r\\n((unsigned long)c->ip[2]<< 8L)|\\r\\n((unsigned long)c->ip[3]);\\r\\nc->them.sin_addr.s_addr=htonl(l);\\r\\nc->state=BIO_CONN_S_CREATE_SOCKET;\\r\\nret=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",c->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto exit_loop;\\r\\n}\\r\\nb->num=ret;\\r\\nc->state=BIO_CONN_S_NBIO;\\r\\nbreak;\\r\\ncase BIO_CONN_S_NBIO:\\r\\nif (c->nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(b->num,1))\\r\\n{\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_ERROR_SETTING_NBIO);\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\ngoto exit_loop;\\r\\n}\\r\\n}\\r\\nc->state=BIO_CONN_S_CONNECT;\\r\\n#ifdef SO_KEEPALIVE\\r\\ni=1;\\r\\ni=setsockopt(b->num,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\\r\\nif (i < 0)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",c->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_KEEPALIVE);\\r\\ngoto exit_loop;\\r\\n}\\r\\n#endif\\r\\nbreak;\\r\\ncase BIO_CONN_S_CONNECT:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=connect(b->num,\\r\\n(struct sockaddr *)&c->them,\\r\\nsizeof(c->them));\\r\\nb->retry_reason=0;\\r\\nif (ret < 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\n{\\r\\nBIO_set_retry_special(b);\\r\\nc->state=BIO_CONN_S_BLOCKED_CONNECT;\\r\\nb->retry_reason=BIO_RR_CONNECT;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSYSerr(SYS_F_CONNECT,get_last_socket_error());\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_CONNECT_ERROR);\\r\\n}\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse\\r\\nc->state=BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_BLOCKED_CONNECT:\\r\\ni=BIO_sock_error(b->num);\\r\\nif (i)\\r\\n{\\r\\nBIO_clear_retry_flags(b);\\r\\nSYSerr(SYS_F_CONNECT,i);\\r\\nERR_add_error_data(4,\"host=\",\\r\\nc->param_hostname,\\r\\n\":\",c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE,BIO_R_NBIO_CONNECT_ERROR);\\r\\nret=0;\\r\\ngoto exit_loop;\\r\\n}\\r\\nelse\\r\\nc->state=BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_OK:\\r\\nret=1;\\r\\ngoto exit_loop;\\r\\ndefault:\\r\\nabort();\\r\\ngoto exit_loop;\\r\\n}\\r\\nif (cb != NULL)\\r\\n{\\r\\nif (!(ret=cb((BIO *)b,c->state,ret)))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nexit_loop:\\r\\nif (cb != NULL)\\r\\nret=cb((BIO *)b,c->state,ret);\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nBIO_CONNECT *BIO_CONNECT_new(void)\\r\\n{\\r\\nBIO_CONNECT *ret;\\r\\nif ((ret=(BIO_CONNECT *)Malloc(sizeof(BIO_CONNECT))) == NULL)\\r\\nreturn(NULL);\\r\\nret->state=BIO_CONN_S_BEFORE;\\r\\nret->param_hostname=NULL;\\r\\nret->param_port=NULL;\\r\\nret->info_callback=NULL;\\r\\nret->nbio=0;\\r\\nret->ip[0]=0;\\r\\nret->ip[1]=0;\\r\\nret->ip[2]=0;\\r\\nret->ip[3]=0;\\r\\nret->port=0;\\r\\nmemset((char *)&ret->them,0,sizeof(ret->them));\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_CONNECT_free(BIO_CONNECT *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->param_hostname != NULL)\\r\\nFree(a->param_hostname);\\r\\nif (a->param_port != NULL)\\r\\nFree(a->param_port);\\r\\nFree(a);\\r\\n}\\r\\nBIO_METHOD *BIO_s_connect(void)\\r\\n{\\r\\nreturn(&methods_connectp);\\r\\n}\\r\\nstatic int conn_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=INVALID_SOCKET;\\r\\nbi->flags=0;\\r\\nif ((bi->ptr=(char *)BIO_CONNECT_new()) == NULL)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nstatic void conn_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_CONNECT *c;\\r\\nc=(BIO_CONNECT *)bio->ptr;\\r\\nif (bio->num != INVALID_SOCKET)\\r\\n{\\r\\nif (c->state == BIO_CONN_S_OK)\\r\\nshutdown(bio->num,2);\\r\\nclosesocket(bio->num);\\r\\nbio->num=INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int conn_free(BIO *a)\\r\\n{\\r\\nBIO_CONNECT *data;\\r\\nif (a == NULL) return(0);\\r\\ndata=(BIO_CONNECT *)a->ptr;\\r\\nif (a->shutdown)\\r\\n{\\r\\nconn_close_socket(a);\\r\\nBIO_CONNECT_free(data);\\r\\na->ptr=NULL;\\r\\na->flags=0;\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int conn_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK)\\r\\n{\\r\\nret=conn_state(b,data);\\r\\nif (ret <= 0)\\r\\nreturn(ret);\\r\\n}\\r\\nif (out != NULL)\\r\\n{\\r\\nclear_socket_error();\\r\\nret=readsocket(b->num,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int conn_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK)\\r\\n{\\r\\nret=conn_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nclear_socket_error();\\r\\nret=writesocket(b->num,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0)\\r\\n{\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long conn_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nint *ip;\\r\\nconst char **pptr;\\r\\nlong ret=1;\\r\\nBIO_CONNECT *data;\\r\\ndata=(BIO_CONNECT *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nret=0;\\r\\ndata->state=BIO_CONN_S_BEFORE;\\r\\nconn_close_socket(b);\\r\\nb->flags=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (!data->state != BIO_CONN_S_OK)\\r\\nret=(long)conn_state(b,data);\\r\\nelse\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_CONNECT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\npptr=(const char **)ptr;\\r\\nif (num == 0)\\r\\n{\\r\\n*pptr=data->param_hostname;\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\n*pptr=data->param_port;\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\n*pptr= (char *)&(data->ip[0]);\\r\\n}\\r\\nelse if (num == 3)\\r\\n{\\r\\n*((int *)ptr)=data->port;\\r\\n}\\r\\nif ((!b->init) || (ptr == NULL))\\r\\n*pptr=\"not initalised\";\\r\\nret=1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_CONNECT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nb->init=1;\\r\\nif (num == 0)\\r\\n{\\r\\nif (data->param_hostname != NULL)\\r\\nFree(data->param_hostname);\\r\\ndata->param_hostname=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\nif (data->param_port != NULL)\\r\\nFree(data->param_port);\\r\\ndata->param_port=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\nchar buf[16];\\r\\nsprintf(buf,\"%d.%d.%d.%d\",\\r\\nptr[0],ptr[1],ptr[2],ptr[3]);\\r\\nif (data->param_hostname != NULL)\\r\\nFree(data->param_hostname);\\r\\ndata->param_hostname=BUF_strdup(buf);\\r\\nmemcpy(&(data->ip[0]),ptr,4);\\r\\n}\\r\\nelse if (num == 3)\\r\\n{\\r\\nchar buf[16];\\r\\nsprintf(buf,\"%d\",*(int *)ptr);\\r\\nif (data->param_port != NULL)\\r\\nFree(data->param_port);\\r\\ndata->param_port=BUF_strdup(buf);\\r\\ndata->port= *(int *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip=b->num;\\r\\nret=b->num;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nif (data->param_port)\\r\\nBIO_set_conn_port(dbio,data->param_port);\\r\\nif (data->param_hostname)\\r\\nBIO_set_conn_hostname(dbio,data->param_hostname);\\r\\nBIO_set_nbio(dbio,data->nbio);\\r\\n(void)BIO_set_info_callback(dbio,data->info_callback);\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\ndata->info_callback=(int (*)())ptr;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nint (**fptr)();\\r\\nfptr=(int (**)())ptr;\\r\\n*fptr=data->info_callback;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int conn_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=conn_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_connect(char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_connect());\\r\\nif (ret == NULL) return(NULL);\\r\\nif (BIO_set_conn_hostname(ret,str))\\r\\nreturn(ret);\\r\\nelse\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pk7_doit_c", "target": 1, "func": "BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint i,j;\\r\\nBIO *out=NULL,*btmp=NULL;\\r\\nX509_ALGOR *xa;\\r\\nconst EVP_MD *evp_md;\\r\\nconst EVP_CIPHER *evp_cipher=NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk=NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\\r\\nX509_ALGOR *xalg=NULL;\\r\\nPKCS7_RECIP_INFO *ri=NULL;\\r\\nEVP_PKEY *pkey;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\nmd_sk=p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk=p7->d.signed_and_enveloped->md_algs;\\r\\nxalg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher=p7->d.signed_and_enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,\\r\\nPKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk=p7->d.enveloped->recipientinfo;\\r\\nxalg=p7->d.enveloped->enc_data->algorithm;\\r\\nevp_cipher=p7->d.enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,\\r\\nPKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (md_sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\n{\\r\\nxa=sk_X509_ALGOR_value(md_sk,i);\\r\\nif ((btmp=BIO_new(BIO_f_md())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nj=OBJ_obj2nid(xa->algorithm);\\r\\nevp_md=EVP_get_digestbyname(OBJ_nid2sn(j));\\r\\nif (evp_md == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp,evp_md);\\r\\nif (out == NULL)\\r\\nout=btmp;\\r\\nelse\\r\\nBIO_push(out,btmp);\\r\\nbtmp=NULL;\\r\\n}\\r\\n}\\r\\nif (evp_cipher != NULL)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nint keylen,ivlen;\\r\\nint jj,max;\\r\\nunsigned char *tmp;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nif ((btmp=BIO_new(BIO_f_cipher())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_cipher_ctx(btmp, &ctx);\\r\\nkeylen=EVP_CIPHER_key_length(evp_cipher);\\r\\nivlen=EVP_CIPHER_iv_length(evp_cipher);\\r\\nRAND_bytes(key,keylen);\\r\\nxalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));\\r\\nif (ivlen > 0) RAND_bytes(iv,ivlen);\\r\\nEVP_CipherInit(ctx, evp_cipher, key, iv, 1);\\r\\nif (ivlen > 0) {\\r\\nif (xalg->parameter == NULL)\\r\\nxalg->parameter=ASN1_TYPE_new();\\r\\nif(EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)\\r\\ngoto err;\\r\\n}\\r\\nmax=0;\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)\\r\\n{\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\nif (ri->cert == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,PKCS7_R_MISSING_CERIPEND_INFO);\\r\\ngoto err;\\r\\n}\\r\\npkey=X509_get_pubkey(ri->cert);\\r\\njj=EVP_PKEY_size(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (max < jj) max=jj;\\r\\n}\\r\\nif ((tmp=(unsigned char *)Malloc(max)) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++)\\r\\n{\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\npkey=X509_get_pubkey(ri->cert);\\r\\njj=EVP_PKEY_encrypt(tmp,key,keylen,pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (jj <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT,ERR_R_EVP_LIB);\\r\\nFree(tmp);\\r\\ngoto err;\\r\\n}\\r\\nASN1_OCTET_STRING_set(ri->enc_key,tmp,jj);\\r\\n}\\r\\nFree(tmp);\\r\\nmemset(key, 0, keylen);\\r\\nif (out == NULL)\\r\\nout=btmp;\\r\\nelse\\r\\nBIO_push(out,btmp);\\r\\nbtmp=NULL;\\r\\n}\\r\\nif (bio == NULL)\\r\\n{\\r\\nif (p7->detached)\\r\\nbio=BIO_new(BIO_s_null());\\r\\nelse\\r\\n{\\r\\nbio=BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio,0);\\r\\nif (PKCS7_type_is_signed(p7) &&\\r\\nPKCS7_type_is_data(p7->d.sign->contents))\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nos=p7->d.sign->contents->d.data;\\r\\nif (os->length > 0)\\r\\nBIO_write(bio,(char *)os->data,\\r\\nos->length);\\r\\n}\\r\\n}\\r\\n}\\r\\nBIO_push(out,bio);\\r\\nbio=NULL;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (btmp != NULL)\\r\\nBIO_free_all(btmp);\\r\\nout=NULL;\\r\\n}\\r\\nreturn(out);\\r\\n}\\r\\nBIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\\r\\n{\\r\\nint i,j;\\r\\nBIO *out=NULL,*btmp=NULL,*etmp=NULL,*bio=NULL;\\r\\nchar *tmp=NULL;\\r\\nX509_ALGOR *xa;\\r\\nASN1_OCTET_STRING *data_body=NULL;\\r\\nconst EVP_MD *evp_md;\\r\\nconst EVP_CIPHER *evp_cipher=NULL;\\r\\nEVP_CIPHER_CTX *evp_ctx=NULL;\\r\\nX509_ALGOR *enc_alg=NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk=NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\\r\\nX509_ALGOR *xalg=NULL;\\r\\nPKCS7_RECIP_INFO *ri=NULL;\\r\\n#if 0\\r\\nX509_STORE_CTX s_ctx;\\r\\n#endif\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signed:\\r\\ndata_body=p7->d.sign->contents->d.data;\\r\\nmd_sk=p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk=p7->d.signed_and_enveloped->md_algs;\\r\\ndata_body=p7->d.signed_and_enveloped->enc_data->enc_data;\\r\\nenc_alg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nxalg=p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk=p7->d.enveloped->recipientinfo;\\r\\nenc_alg=p7->d.enveloped->enc_data->algorithm;\\r\\ndata_body=p7->d.enveloped->enc_data->enc_data;\\r\\nevp_cipher=EVP_get_cipherbyname(OBJ_nid2sn(OBJ_obj2nid(enc_alg->algorithm)));\\r\\nif (evp_cipher == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nxalg=p7->d.enveloped->enc_data->algorithm;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (md_sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_ALGOR_num(md_sk); i++)\\r\\n{\\r\\nxa=sk_X509_ALGOR_value(md_sk,i);\\r\\nif ((btmp=BIO_new(BIO_f_md())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nj=OBJ_obj2nid(xa->algorithm);\\r\\nevp_md=EVP_get_digestbyname(OBJ_nid2sn(j));\\r\\nif (evp_md == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp,evp_md);\\r\\nif (out == NULL)\\r\\nout=btmp;\\r\\nelse\\r\\nBIO_push(out,btmp);\\r\\nbtmp=NULL;\\r\\n}\\r\\n}\\r\\nif (evp_cipher != NULL)\\r\\n{\\r\\n#if 0\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *p;\\r\\nint keylen,ivlen;\\r\\nint max;\\r\\nX509_OBJECT ret;\\r\\n#endif\\r\\nint jj;\\r\\nif ((etmp=BIO_new(BIO_f_cipher())) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,i);\\r\\nif(!X509_NAME_cmp(ri->issuer_and_serial->issuer,\\r\\npcert->cert_info->issuer) &&\\r\\n!ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,\\r\\nri->issuer_and_serial->serial)) break;\\r\\nri=NULL;\\r\\n}\\r\\nif (ri == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\\r\\nreturn(NULL);\\r\\n}\\r\\njj=EVP_PKEY_size(pkey);\\r\\ntmp=Malloc(jj+10);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\njj=EVP_PKEY_decrypt((unsigned char *)tmp,\\r\\nASN1_STRING_data(ri->enc_key),\\r\\nASN1_STRING_length(ri->enc_key),\\r\\npkey);\\r\\nif (jj <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nevp_ctx=NULL;\\r\\nBIO_get_cipher_ctx(etmp,&evp_ctx);\\r\\nEVP_CipherInit(evp_ctx,evp_cipher,NULL,NULL,0);\\r\\nif (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)\\r\\nreturn(NULL);\\r\\nif (jj != EVP_CIPHER_CTX_key_length(evp_ctx))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nEVP_CipherInit(evp_ctx,NULL,(unsigned char *)tmp,NULL,0);\\r\\nmemset(tmp,0,jj);\\r\\nif (out == NULL)\\r\\nout=etmp;\\r\\nelse\\r\\nBIO_push(out,etmp);\\r\\netmp=NULL;\\r\\n}\\r\\n#if 1\\r\\nif (p7->detached || (in_bio != NULL))\\r\\n{\\r\\nbio=in_bio;\\r\\n}\\r\\nelse\\r\\n{\\r\\nbio=BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio,0);\\r\\nif (data_body->length > 0)\\r\\nBIO_write(bio,(char *)data_body->data,data_body->length);\\r\\n}\\r\\nBIO_push(out,bio);\\r\\nbio=NULL;\\r\\n#endif\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (out != NULL) BIO_free_all(out);\\r\\nif (btmp != NULL) BIO_free_all(btmp);\\r\\nif (etmp != NULL) BIO_free_all(etmp);\\r\\nif (bio != NULL) BIO_free_all(bio);\\r\\nout=NULL;\\r\\n}\\r\\nif (tmp != NULL)\\r\\nFree(tmp);\\r\\nreturn(out);\\r\\n}\\r\\nint PKCS7_dataFinal(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j;\\r\\nBIO *btmp;\\r\\nBUF_MEM *buf_mem=NULL;\\r\\nBUF_MEM *buf=NULL;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nEVP_MD_CTX *mdc,ctx_tmp;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *si_sk=NULL;\\r\\nunsigned char *p,*pp=NULL;\\r\\nint x;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\np7->state=PKCS7_S_HEADER;\\r\\nswitch (i)\\r\\n{\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsi_sk=p7->d.signed_and_enveloped->signer_info;\\r\\nos=ASN1_OCTET_STRING_new();\\r\\np7->d.signed_and_enveloped->enc_data->enc_data=os;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nos=ASN1_OCTET_STRING_new();\\r\\np7->d.enveloped->enc_data->enc_data=os;\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nsi_sk=p7->d.sign->signer_info;\\r\\nos=p7->d.sign->contents->d.data;\\r\\nif(p7->detached) {\\r\\nASN1_OCTET_STRING_free(os);\\r\\np7->d.sign->contents->d.data = NULL;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (si_sk != NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<sk_PKCS7_SIGNER_INFO_num(si_sk); i++)\\r\\n{\\r\\nsi=sk_PKCS7_SIGNER_INFO_value(si_sk,i);\\r\\nif (si->pkey == NULL) continue;\\r\\nj=OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp=bio;\\r\\nfor (;;)\\r\\n{\\r\\nif ((btmp=BIO_find_type(btmp,BIO_TYPE_MD))\\r\\n== NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_md_ctx(btmp,&mdc);\\r\\nif (mdc == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_MD_type(EVP_MD_CTX_type(mdc)) == j)\\r\\nbreak;\\r\\nelse\\r\\nbtmp=btmp->next_bio;\\r\\n}\\r\\nmemcpy(&ctx_tmp,mdc,sizeof(ctx_tmp));\\r\\nif (!BUF_MEM_grow(buf,EVP_PKEY_size(si->pkey)))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nsk=si->auth_attr;\\r\\nif ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))\\r\\n{\\r\\nunsigned char md_data[EVP_MAX_MD_SIZE];\\r\\nunsigned int md_len;\\r\\nASN1_OCTET_STRING *digest;\\r\\nASN1_UTCTIME *sign_time;\\r\\nconst EVP_MD *md_tmp;\\r\\nsign_time=X509_gmtime_adj(NULL,0);\\r\\nPKCS7_add_signed_attribute(si,\\r\\nNID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME,sign_time);\\r\\nmd_tmp=EVP_MD_CTX_type(&ctx_tmp);\\r\\nEVP_DigestFinal(&ctx_tmp,md_data,&md_len);\\r\\ndigest=ASN1_OCTET_STRING_new();\\r\\nASN1_OCTET_STRING_set(digest,md_data,md_len);\\r\\nPKCS7_add_signed_attribute(si,\\r\\nNID_pkcs9_messageDigest,\\r\\nV_ASN1_OCTET_STRING,digest);\\r\\nEVP_SignInit(&ctx_tmp,md_tmp);\\r\\nx=i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,NULL,\\r\\ni2d_X509_ATTRIBUTE,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);\\r\\npp=(unsigned char *)Malloc(x);\\r\\np=pp;\\r\\ni2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,&p,\\r\\ni2d_X509_ATTRIBUTE,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL,IS_SET);\\r\\nEVP_SignUpdate(&ctx_tmp,pp,x);\\r\\nFree(pp);\\r\\npp=NULL;\\r\\n}\\r\\nif (si->pkey->type == EVP_PKEY_DSA)\\r\\nctx_tmp.digest=EVP_dss1();\\r\\nif (!EVP_SignFinal(&ctx_tmp,(unsigned char *)buf->data,\\r\\n(unsigned int *)&buf->length,si->pkey))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_STRING_set(si->enc_digest,\\r\\n(unsigned char *)buf->data,buf->length))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!p7->detached)\\r\\n{\\r\\nbtmp=BIO_find_type(bio,BIO_TYPE_MEM);\\r\\nif (btmp == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATASIGN,PKCS7_R_UNABLE_TO_FIND_MEM_BIO);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_mem_ptr(btmp,&buf_mem);\\r\\nASN1_OCTET_STRING_set(os,\\r\\n(unsigned char *)buf_mem->data,buf_mem->length);\\r\\n}\\r\\nif (pp != NULL) Free(pp);\\r\\npp=NULL;\\r\\nret=1;\\r\\nerr:\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nint PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,\\r\\nPKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nPKCS7_ISSUER_AND_SERIAL *ias;\\r\\nint ret=0,i;\\r\\nSTACK_OF(X509) *cert;\\r\\nX509 *x509;\\r\\nif (PKCS7_type_is_signed(p7))\\r\\n{\\r\\ncert=p7->d.sign->cert;\\r\\n}\\r\\nelse if (PKCS7_type_is_signedAndEnveloped(p7))\\r\\n{\\r\\ncert=p7->d.signed_and_enveloped->cert;\\r\\n}\\r\\nelse\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nias=si->issuer_and_serial;\\r\\nx509=X509_find_by_issuer_and_serial(cert,ias->issuer,ias->serial);\\r\\nif (x509 == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_init(ctx,cert_store,x509,cert);\\r\\ni=X509_verify_cert(ctx);\\r\\nif (i <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\nreturn PKCS7_signatureVerify(bio, p7, si, x509);\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\\r\\nX509 *x509)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nEVP_MD_CTX mdc_tmp,*mdc;\\r\\nunsigned char *pp,*p;\\r\\nint ret=0,i;\\r\\nint md_type;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nBIO *btmp;\\r\\nEVP_PKEY *pkey;\\r\\nif (!PKCS7_type_is_signed(p7) &&\\r\\n!PKCS7_type_is_signedAndEnveloped(p7)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nmd_type=OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp=bio;\\r\\nfor (;;)\\r\\n{\\r\\nif ((btmp == NULL) ||\\r\\n((btmp=BIO_find_type(btmp,BIO_TYPE_MD)) == NULL))\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_md_ctx(btmp,&mdc);\\r\\nif (mdc == NULL)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_MD_type(EVP_MD_CTX_type(mdc)) == md_type)\\r\\nbreak;\\r\\nbtmp=btmp->next_bio;\\r\\n}\\r\\nmemcpy(&mdc_tmp,mdc,sizeof(mdc_tmp));\\r\\nsk=si->auth_attr;\\r\\nif ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0))\\r\\n{\\r\\nunsigned char md_dat[EVP_MAX_MD_SIZE];\\r\\nunsigned int md_len;\\r\\nASN1_OCTET_STRING *message_digest;\\r\\nEVP_DigestFinal(&mdc_tmp,md_dat,&md_len);\\r\\nmessage_digest=PKCS7_digest_from_attributes(sk);\\r\\nif (!message_digest)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nif ((message_digest->length != (int)md_len) ||\\r\\n(memcmp(message_digest->data,md_dat,md_len)))\\r\\n{\\r\\n#if 0\\r\\n{\\r\\nint ii;\\r\\nfor (ii=0; ii<message_digest->length; ii++)\\r\\nprintf(\"%02X\",message_digest->data[ii]); printf(\" sent\\n\");\\r\\nfor (ii=0; ii<md_len; ii++) printf(\"%02X\",md_dat[ii]); printf(\" calc\\n\");\\r\\n}\\r\\n#endif\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_DIGEST_FAILURE);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nEVP_VerifyInit(&mdc_tmp,EVP_get_digestbynid(md_type));\\r\\ni=i2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,NULL,i2d_X509_ATTRIBUTE,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL, IS_SEQUENCE);\\r\\npp=Malloc(i);\\r\\np=pp;\\r\\ni2d_ASN1_SET_OF_X509_ATTRIBUTE(sk,&p,i2d_X509_ATTRIBUTE,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL, IS_SEQUENCE);\\r\\nEVP_VerifyUpdate(&mdc_tmp,pp,i);\\r\\nFree(pp);\\r\\n}\\r\\nos=si->enc_digest;\\r\\npkey = X509_get_pubkey(x509);\\r\\nif(pkey->type == EVP_PKEY_DSA) mdc_tmp.digest=EVP_dss1();\\r\\ni=EVP_VerifyFinal(&mdc_tmp,os->data,os->length, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i <= 0)\\r\\n{\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_SIGNATURE_FAILURE);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nPKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)\\r\\n{\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk;\\r\\nPKCS7_RECIP_INFO *ri;\\r\\nint i;\\r\\ni=OBJ_obj2nid(p7->type);\\r\\nif (i != NID_pkcs7_signedAndEnveloped) return(NULL);\\r\\nrsk=p7->d.signed_and_enveloped->recipientinfo;\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,0);\\r\\nif (sk_PKCS7_RECIP_INFO_num(rsk) <= idx) return(NULL);\\r\\nri=sk_PKCS7_RECIP_INFO_value(rsk,idx);\\r\\nreturn(ri->issuer_and_serial);\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn(get_attribute(si->auth_attr,nid));\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn(get_attribute(si->unauth_attr,nid));\\r\\n}\\r\\nint PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn(add_attribute(&(p7si->auth_attr),nid,atrtype,value));\\r\\n}\\r\\nint PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn(add_attribute(&(p7si->unauth_attr),nid,atrtype,value));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rmd_one_c", "target": 0, "func": "unsigned char *RIPEMD160(unsigned char *d, unsigned long n,\\r\\nunsigned char *md)\\r\\n{\\r\\nRIPEMD160_CTX c;\\r\\nstatic unsigned char m[RIPEMD160_DIGEST_LENGTH];\\r\\nif (md == NULL) md=m;\\r\\nRIPEMD160_Init(&c);\\r\\nRIPEMD160_Update(&c,d,n);\\r\\nRIPEMD160_Final(md,&c);\\r\\nmemset(&c,0,sizeof(c));\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t1_meth_c", "target": 0, "func": "static SSL_METHOD *tls1_get_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_data.ssl_connect=ssl3_connect;\\r\\nTLSv1_data.ssl_accept=ssl3_accept;\\r\\nTLSv1_data.get_ssl_method=tls1_get_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&TLSv1_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_asn1_par_c", "target": 0, "func": "static int asn1_print_info(BIO *bp, int tag, int xclass, int constructed,\\r\\nint indent)\\r\\n{\\r\\nstatic const char fmt[]=\"%-18s\";\\r\\nstatic const char fmt2[]=\"%2d %-15s\";\\r\\nchar str[128];\\r\\nconst char *p,*p2=NULL;\\r\\nif (constructed & V_ASN1_CONSTRUCTED)\\r\\np=\"cons: \";\\r\\nelse\\r\\np=\"prim: \";\\r\\nif (BIO_write(bp,p,6) < 6) goto err;\\r\\nif (indent)\\r\\n{\\r\\nif (indent > 128) indent=128;\\r\\nmemset(str,' ',indent);\\r\\nif (BIO_write(bp,str,indent) < indent) goto err;\\r\\n}\\r\\np=str;\\r\\nif ((xclass & V_ASN1_PRIVATE) == V_ASN1_PRIVATE)\\r\\nsprintf(str,\"priv [ %d ] \",tag);\\r\\nelse if ((xclass & V_ASN1_CONTEXT_SPECIFIC) == V_ASN1_CONTEXT_SPECIFIC)\\r\\nsprintf(str,\"cont [ %d ]\",tag);\\r\\nelse if ((xclass & V_ASN1_APPLICATION) == V_ASN1_APPLICATION)\\r\\nsprintf(str,\"appl [ %d ]\",tag);\\r\\nelse if ((tag == V_ASN1_EOC) )\\r\\np=\"EOC\";\\r\\nelse if (tag == V_ASN1_BOOLEAN)\\r\\np=\"BOOLEAN\";\\r\\nelse if (tag == V_ASN1_INTEGER)\\r\\np=\"INTEGER\";\\r\\nelse if (tag == V_ASN1_ENUMERATED)\\r\\np=\"ENUMERATED\";\\r\\nelse if (tag == V_ASN1_BIT_STRING)\\r\\np=\"BIT STRING\";\\r\\nelse if (tag == V_ASN1_OCTET_STRING)\\r\\np=\"OCTET STRING\";\\r\\nelse if (tag == V_ASN1_NULL)\\r\\np=\"NULL\";\\r\\nelse if (tag == V_ASN1_OBJECT)\\r\\np=\"OBJECT\";\\r\\nelse if (tag == V_ASN1_SEQUENCE)\\r\\np=\"SEQUENCE\";\\r\\nelse if (tag == V_ASN1_SET)\\r\\np=\"SET\";\\r\\nelse if (tag == V_ASN1_PRINTABLESTRING)\\r\\np=\"PRINTABLESTRING\";\\r\\nelse if (tag == V_ASN1_T61STRING)\\r\\np=\"T61STRING\";\\r\\nelse if (tag == V_ASN1_IA5STRING)\\r\\np=\"IA5STRING\";\\r\\nelse if (tag == V_ASN1_UTCTIME)\\r\\np=\"UTCTIME\";\\r\\nelse if (tag == V_ASN1_NUMERICSTRING)\\r\\np=\"NUMERICSTRING\";\\r\\nelse if (tag == V_ASN1_VIDEOTEXSTRING)\\r\\np=\"VIDEOTEXSTRING\";\\r\\nelse if (tag == V_ASN1_GENERALIZEDTIME)\\r\\np=\"GENERALIZEDTIME\";\\r\\nelse if (tag == V_ASN1_GRAPHICSTRING)\\r\\np=\"GRAPHICSTRING\";\\r\\nelse if (tag == V_ASN1_VISIBLESTRING)\\r\\np=\"VISIBLESTRING\";\\r\\nelse if (tag == V_ASN1_GENERALSTRING)\\r\\np=\"GENERALSTRING\";\\r\\nelse if (tag == V_ASN1_UNIVERSALSTRING)\\r\\np=\"UNIVERSALSTRING\";\\r\\nelse if (tag == V_ASN1_BMPSTRING)\\r\\np=\"BMPSTRING\";\\r\\nelse\\r\\np2=\"(unknown)\";\\r\\nif (p2 != NULL)\\r\\n{\\r\\nif (BIO_printf(bp,fmt2,tag,p2) <= 0) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,fmt,p) <= 0) goto err;\\r\\n}\\r\\nreturn(1);\\r\\nerr:\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_parse(BIO *bp, unsigned char *pp, long len, int indent)\\r\\n{\\r\\nreturn(asn1_parse2(bp,&pp,len,0,0,indent));\\r\\n}\\r\\nstatic int asn1_parse2(BIO *bp, unsigned char **pp, long length, int offset,\\r\\nint depth, int indent)\\r\\n{\\r\\nunsigned char *p,*ep,*tot,*op,*opp;\\r\\nlong len;\\r\\nint tag,xclass,ret=0;\\r\\nint nl,hl,j,r;\\r\\nASN1_OBJECT *o=NULL;\\r\\nASN1_OCTET_STRING *os=NULL;\\r\\np= *pp;\\r\\ntot=p+length;\\r\\nop=p-1;\\r\\nwhile ((p < tot) && (op < p))\\r\\n{\\r\\nop=p;\\r\\nj=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\n#ifdef LINT\\r\\nj=j;\\r\\n#endif\\r\\nif (j & 0x80)\\r\\n{\\r\\nif (BIO_write(bp,\"Error in encoding\\n\",18) <= 0)\\r\\ngoto end;\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nhl=(p-op);\\r\\nlength-=hl;\\r\\nif (BIO_printf(bp,\"%5ld:\",(long)offset+(long)(op- *pp))\\r\\n<= 0) goto end;\\r\\nif (j != (V_ASN1_CONSTRUCTED | 1))\\r\\n{\\r\\nif (BIO_printf(bp,\"d=%-2d hl=%ld l=%4ld \",\\r\\ndepth,(long)hl,len) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_printf(bp,\"d=%-2d hl=%ld l=inf \",\\r\\ndepth,(long)hl) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (!asn1_print_info(bp,tag,xclass,j,(indent)?depth:0))\\r\\ngoto end;\\r\\nif (j & V_ASN1_CONSTRUCTED)\\r\\n{\\r\\nep=p+len;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\nif (len > length)\\r\\n{\\r\\nBIO_printf(bp,\\r\\n\"length is greater than %ld\\n\",length);\\r\\nret=0;\\r\\ngoto end;\\r\\n}\\r\\nif ((j == 0x21) && (len == 0))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nr=asn1_parse2(bp,&p,(long)(tot-p),\\r\\noffset+(p - *pp),depth+1,\\r\\nindent);\\r\\nif (r == 0) { ret=0; goto end; }\\r\\nif ((r == 2) || (p >= tot)) break;\\r\\n}\\r\\n}\\r\\nelse\\r\\nwhile (p < ep)\\r\\n{\\r\\nr=asn1_parse2(bp,&p,(long)len,\\r\\noffset+(p - *pp),depth+1,\\r\\nindent);\\r\\nif (r == 0) { ret=0; goto end; }\\r\\n}\\r\\n}\\r\\nelse if (xclass != 0)\\r\\n{\\r\\np+=len;\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\n}\\r\\nelse\\r\\n{\\r\\nnl=0;\\r\\nif ( (tag == V_ASN1_PRINTABLESTRING) ||\\r\\n(tag == V_ASN1_T61STRING) ||\\r\\n(tag == V_ASN1_IA5STRING) ||\\r\\n(tag == V_ASN1_VISIBLESTRING) ||\\r\\n(tag == V_ASN1_UTCTIME) ||\\r\\n(tag == V_ASN1_GENERALIZEDTIME))\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif ((len > 0) &&\\r\\nBIO_write(bp,(char *)p,(int)len)\\r\\n!= (int)len)\\r\\ngoto end;\\r\\n}\\r\\nelse if (tag == V_ASN1_OBJECT)\\r\\n{\\r\\nopp=op;\\r\\nif (d2i_ASN1_OBJECT(&o,&opp,len+hl) != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\ni2a_ASN1_OBJECT(bp,o);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\":BAD OBJECT\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (tag == V_ASN1_BOOLEAN)\\r\\n{\\r\\nint ii;\\r\\nopp=op;\\r\\nii=d2i_ASN1_BOOLEAN(NULL,&opp,len+hl);\\r\\nif (ii < 0)\\r\\n{\\r\\nif (BIO_write(bp,\"Bad boolean\\n\",12))\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bp,\":%d\",ii);\\r\\n}\\r\\nelse if (tag == V_ASN1_BMPSTRING)\\r\\n{\\r\\n}\\r\\nelse if (tag == V_ASN1_OCTET_STRING)\\r\\n{\\r\\nint i,printable=1;\\r\\nopp=op;\\r\\nos=d2i_ASN1_OCTET_STRING(NULL,&opp,len+hl);\\r\\nif (os != NULL)\\r\\n{\\r\\nopp=os->data;\\r\\nfor (i=0; i<os->length; i++)\\r\\n{\\r\\nif (( (opp[i] < ' ') &&\\r\\n(opp[i] != '\\n') &&\\r\\n(opp[i] != '\\r') &&\\r\\n(opp[i] != '\\t')) ||\\r\\n(opp[i] > '~'))\\r\\n{\\r\\nprintable=0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (printable && (os->length > 0))\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0)\\r\\ngoto end;\\r\\nif (BIO_write(bp,(char *)opp,\\r\\nos->length) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nASN1_OCTET_STRING_free(os);\\r\\nos=NULL;\\r\\n}\\r\\n}\\r\\nelse if (tag == V_ASN1_INTEGER)\\r\\n{\\r\\nASN1_INTEGER *bs;\\r\\nint i;\\r\\nopp=op;\\r\\nbs=d2i_ASN1_INTEGER(NULL,&opp,len+hl);\\r\\nif (bs != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif (bs->type == V_ASN1_NEG_INTEGER)\\r\\nif (BIO_write(bp,\"-\",1) <= 0)\\r\\ngoto end;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",\\r\\nbs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\"BAD INTEGER\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nASN1_INTEGER_free(bs);\\r\\n}\\r\\nelse if (tag == V_ASN1_ENUMERATED)\\r\\n{\\r\\nASN1_ENUMERATED *bs;\\r\\nint i;\\r\\nopp=op;\\r\\nbs=d2i_ASN1_ENUMERATED(NULL,&opp,len+hl);\\r\\nif (bs != NULL)\\r\\n{\\r\\nif (BIO_write(bp,\":\",1) <= 0) goto end;\\r\\nif (bs->type == V_ASN1_NEG_ENUMERATED)\\r\\nif (BIO_write(bp,\"-\",1) <= 0)\\r\\ngoto end;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02X\",\\r\\nbs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (BIO_write(bp,\"BAD ENUMERATED\",11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nASN1_ENUMERATED_free(bs);\\r\\n}\\r\\nif (!nl)\\r\\n{\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto end;\\r\\n}\\r\\np+=len;\\r\\nif ((tag == V_ASN1_EOC) && (xclass == 0))\\r\\n{\\r\\nret=2;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nlength-=len;\\r\\n}\\r\\nret=1;\\r\\nend:\\r\\nif (o != NULL) ASN1_OBJECT_free(o);\\r\\nif (os != NULL) ASN1_OCTET_STRING_free(os);\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_bitst_c", "target": 0, "func": "static ASN1_BIT_STRING *asn1_bit_string_new(void)\\r\\n{\\r\\nreturn ASN1_BIT_STRING_new();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_pu_c", "target": 0, "func": "EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL))\\r\\n{\\r\\nif ((ret=EVP_PKEY_new()) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_EVP_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\nelse ret= *a;\\r\\nret->save_type=type;\\r\\nret->type=EVP_PKEY_type(type);\\r\\nswitch (ret->type)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif ((ret->pkey.rsa=d2i_RSAPublicKey(NULL,pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif ((ret->pkey.dsa=d2i_DSAPublicKey(NULL,pp,length)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY,ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) EVP_PKEY_free(ret);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_enc_c", "target": 0, "func": "BIO_METHOD *BIO_f_cipher(void)\\r\\n{\\r\\nreturn(&methods_enc);\\r\\n}\\r\\nstatic int enc_new(BIO *bi)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)Malloc(sizeof(BIO_ENC_CTX));\\r\\nEVP_CIPHER_CTX_init(&ctx->cipher);\\r\\nif (ctx == NULL) return(0);\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\nctx->cont=1;\\r\\nctx->finished=0;\\r\\nctx->ok=1;\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int enc_free(BIO *a)\\r\\n{\\r\\nBIO_ENC_CTX *b;\\r\\nif (a == NULL) return(0);\\r\\nb=(BIO_ENC_CTX *)a->ptr;\\r\\nEVP_CIPHER_CTX_cleanup(&(b->cipher));\\r\\nmemset(a->ptr,0,sizeof(BIO_ENC_CTX));\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int enc_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nif (ctx->buf_len > 0)\\r\\n{\\r\\ni=ctx->buf_len-ctx->buf_off;\\r\\nif (i > outl) i=outl;\\r\\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\\r\\nret=i;\\r\\nout+=i;\\r\\noutl-=i;\\r\\nctx->buf_off+=i;\\r\\nif (ctx->buf_len == ctx->buf_off)\\r\\n{\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\n}\\r\\nwhile (outl > 0)\\r\\n{\\r\\nif (ctx->cont <= 0) break;\\r\\ni=BIO_read(b->next_bio,&(ctx->buf[8]),ENC_BLOCK_SIZE);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (!BIO_should_retry(b->next_bio))\\r\\n{\\r\\nctx->cont=i;\\r\\ni=EVP_CipherFinal(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=i;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nelse\\r\\nret=(ret == 0)?i:ret;\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\n{\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)&(ctx->buf[8]),i);\\r\\nctx->cont=1;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni=ctx->buf_len;\\r\\nelse\\r\\ni=outl;\\r\\nif (i <= 0) break;\\r\\nmemcpy(out,ctx->buf,i);\\r\\nret+=i;\\r\\nctx->buf_off=i;\\r\\noutl-=i;\\r\\nout+=i;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn((ret == 0)?ctx->cont:ret);\\r\\n}\\r\\nstatic int enc_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0,n,i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nret=inl;\\r\\nBIO_clear_retry_flags(b);\\r\\nn=ctx->buf_len-ctx->buf_off;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nctx->buf_off+=i;\\r\\nn-=i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx->buf_off=0;\\r\\nwhile (inl > 0)\\r\\n{\\r\\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,&ctx->buf_len,\\r\\n(unsigned char *)in,n);\\r\\ninl-=n;\\r\\nin+=n;\\r\\nctx->buf_off=0;\\r\\nn=ctx->buf_len;\\r\\nwhile (n > 0)\\r\\n{\\r\\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\\r\\nif (i <= 0)\\r\\n{\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(i);\\r\\n}\\r\\nn-=i;\\r\\nctx->buf_off+=i;\\r\\n}\\r\\nctx->buf_len=0;\\r\\nctx->buf_off=0;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long enc_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_ENC_CTX *ctx,*dctx;\\r\\nlong ret=1;\\r\\nint i;\\r\\nEVP_CIPHER_CTX **c_ctx;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ok=1;\\r\\nctx->finished=0;\\r\\nEVP_CipherInit(&(ctx->cipher),NULL,NULL,NULL,\\r\\nctx->cipher.encrypt);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret=1;\\r\\nelse\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret=ctx->buf_len-ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off)\\r\\n{\\r\\ni=enc_write(b,NULL,0);\\r\\nif (i < 0)\\r\\n{\\r\\nret=i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ctx->finished)\\r\\n{\\r\\nctx->finished=1;\\r\\nctx->buf_off=0;\\r\\nret=EVP_CipherFinal(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok=(int)ret;\\r\\nif (ret <= 0) break;\\r\\ngoto again;\\r\\n}\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_STATUS:\\r\\nret=(long)ctx->ok;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_CTX:\\r\\nc_ctx=(EVP_CIPHER_CTX **)ptr;\\r\\n(*c_ctx)= &(ctx->cipher);\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\ndctx=(BIO_ENC_CTX *)dbio->ptr;\\r\\nmemcpy(&(dctx->cipher),&(ctx->cipher),sizeof(ctx->cipher));\\r\\ndbio->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_set_cipher(BIO *b, const EVP_CIPHER *c, unsigned char *k,\\r\\nunsigned char *i, int e)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (b == NULL) return;\\r\\nif ((b->callback != NULL) &&\\r\\n(b->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,0L) <= 0))\\r\\nreturn;\\r\\nb->init=1;\\r\\nctx=(BIO_ENC_CTX *)b->ptr;\\r\\nEVP_CipherInit(&(ctx->cipher),c,k,i,e);\\r\\nif (b->callback != NULL)\\r\\nb->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,1L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_acpt_c", "target": 0, "func": "BIO_METHOD *BIO_s_accept(void)\\r\\n{\\r\\nreturn(&methods_acceptp);\\r\\n}\\r\\nstatic int acpt_new(BIO *bi)\\r\\n{\\r\\nBIO_ACCEPT *ba;\\r\\nbi->init=0;\\r\\nbi->num=INVALID_SOCKET;\\r\\nbi->flags=0;\\r\\nif ((ba=BIO_ACCEPT_new()) == NULL)\\r\\nreturn(0);\\r\\nbi->ptr=(char *)ba;\\r\\nba->state=ACPT_S_BEFORE;\\r\\nbi->shutdown=1;\\r\\nreturn(1);\\r\\n}\\r\\nBIO_ACCEPT *BIO_ACCEPT_new(void)\\r\\n{\\r\\nBIO_ACCEPT *ret;\\r\\nif ((ret=(BIO_ACCEPT *)Malloc(sizeof(BIO_ACCEPT))) == NULL)\\r\\nreturn(NULL);\\r\\nmemset(ret,0,sizeof(BIO_ACCEPT));\\r\\nret->accept_sock=INVALID_SOCKET;\\r\\nret->bind_mode=BIO_BIND_NORMAL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BIO_ACCEPT_free(BIO_ACCEPT *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->param_addr != NULL) Free(a->param_addr);\\r\\nif (a->addr != NULL) Free(a->addr);\\r\\nif (a->bio_chain != NULL) BIO_free(a->bio_chain);\\r\\nFree(a);\\r\\n}\\r\\nstatic void acpt_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_ACCEPT *c;\\r\\nc=(BIO_ACCEPT *)bio->ptr;\\r\\nif (c->accept_sock != INVALID_SOCKET)\\r\\n{\\r\\nshutdown(c->accept_sock,2);\\r\\nclosesocket(c->accept_sock);\\r\\nc->accept_sock=INVALID_SOCKET;\\r\\nbio->num=INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int acpt_free(BIO *a)\\r\\n{\\r\\nBIO_ACCEPT *data;\\r\\nif (a == NULL) return(0);\\r\\ndata=(BIO_ACCEPT *)a->ptr;\\r\\nif (a->shutdown)\\r\\n{\\r\\nacpt_close_socket(a);\\r\\nBIO_ACCEPT_free(data);\\r\\na->ptr=NULL;\\r\\na->flags=0;\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int acpt_state(BIO *b, BIO_ACCEPT *c)\\r\\n{\\r\\nBIO *bio=NULL,*dbio;\\r\\nint s= -1;\\r\\nint i;\\r\\nagain:\\r\\nswitch (c->state)\\r\\n{\\r\\ncase ACPT_S_BEFORE:\\r\\nif (c->param_addr == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_NO_ACCEPT_PORT_SPECIFIED);\\r\\nreturn(-1);\\r\\n}\\r\\ns=BIO_get_accept_socket(c->param_addr,c->bind_mode);\\r\\nif (s == INVALID_SOCKET)\\r\\nreturn(-1);\\r\\nif (c->accept_nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(s,1))\\r\\n{\\r\\nclosesocket(s);\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_ERROR_SETTING_NBIO_ON_ACCEPT_SOCKET);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nc->accept_sock=s;\\r\\nb->num=s;\\r\\nc->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\nreturn(1);\\r\\ncase ACPT_S_GET_ACCEPT_SOCKET:\\r\\nif (b->next_bio != NULL)\\r\\n{\\r\\nc->state=ACPT_S_OK;\\r\\ngoto again;\\r\\n}\\r\\ni=BIO_accept(c->accept_sock,&(c->addr));\\r\\nif (i < 0) return(i);\\r\\nbio=BIO_new_socket(i,BIO_CLOSE);\\r\\nif (bio == NULL) goto err;\\r\\nBIO_set_callback(bio,BIO_get_callback(b));\\r\\nBIO_set_callback_arg(bio,BIO_get_callback_arg(b));\\r\\nif (c->nbio)\\r\\n{\\r\\nif (!BIO_socket_nbio(i,1))\\r\\n{\\r\\nBIOerr(BIO_F_ACPT_STATE,BIO_R_ERROR_SETTING_NBIO_ON_ACCEPTED_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (c->bio_chain != NULL)\\r\\n{\\r\\nif ((dbio=BIO_dup_chain(c->bio_chain)) == NULL)\\r\\ngoto err;\\r\\nif (!BIO_push(dbio,bio)) goto err;\\r\\nbio=dbio;\\r\\n}\\r\\nif (BIO_push(b,bio) == NULL) goto err;\\r\\nc->state=ACPT_S_OK;\\r\\nreturn(1);\\r\\nerr:\\r\\nif (bio != NULL)\\r\\nBIO_free(bio);\\r\\nelse if (s >= 0)\\r\\nclosesocket(s);\\r\\nreturn(0);\\r\\ncase ACPT_S_OK:\\r\\nif (b->next_bio == NULL)\\r\\n{\\r\\nc->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\ngoto again;\\r\\n}\\r\\nreturn(1);\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nstatic int acpt_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL)\\r\\n{\\r\\nret=acpt_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int acpt_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL)\\r\\n{\\r\\nret=acpt_state(b,data);\\r\\nif (ret <= 0) return(ret);\\r\\n}\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long acpt_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nint *ip;\\r\\nlong ret=1;\\r\\nBIO_ACCEPT *data;\\r\\nchar **pp;\\r\\ndata=(BIO_ACCEPT *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nret=0;\\r\\ndata->state=ACPT_S_BEFORE;\\r\\nacpt_close_socket(b);\\r\\nb->flags=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nret=(long)acpt_state(b,data);\\r\\nbreak;\\r\\ncase BIO_C_SET_ACCEPT:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nif (num == 0)\\r\\n{\\r\\nb->init=1;\\r\\nif (data->param_addr != NULL)\\r\\nFree(data->param_addr);\\r\\ndata->param_addr=BUF_strdup(ptr);\\r\\n}\\r\\nelse if (num == 1)\\r\\n{\\r\\ndata->accept_nbio=(ptr != NULL);\\r\\n}\\r\\nelse if (num == 2)\\r\\n{\\r\\nif (data->bio_chain != NULL)\\r\\nBIO_free(data->bio_chain);\\r\\ndata->bio_chain=(BIO *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nb->init=1;\\r\\nb->num= *((int *)ptr);\\r\\ndata->accept_sock=b->num;\\r\\ndata->state=ACPT_S_GET_ACCEPT_SOCKET;\\r\\nb->shutdown=(int)num;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init)\\r\\n{\\r\\nip=(int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip=data->accept_sock;\\r\\nret=data->accept_sock;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_C_GET_ACCEPT:\\r\\nif (b->init)\\r\\n{\\r\\nif (ptr != NULL)\\r\\n{\\r\\npp=(char **)ptr;\\r\\n*pp=data->param_addr;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_C_SET_BIND_MODE:\\r\\ndata->bind_mode=(int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_BIND_MODE:\\r\\nret=(long)data->bind_mode;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\nbreak;\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int acpt_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=acpt_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_accept(char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret=BIO_new(BIO_s_accept());\\r\\nif (ret == NULL) return(NULL);\\r\\nif (BIO_set_accept_port(ret,str))\\r\\nreturn(ret);\\r\\nelse\\r\\n{\\r\\nBIO_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_example3_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nif ((argc == 2))\\r\\n{\\r\\ndo_cipher(argv[1],ENCRYPT);\\r\\n}\\r\\nelse if ((argc == 3) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\ndo_cipher(argv[2],DECRYPT);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"%s\", usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid do_cipher(char *pw, int operation)\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN + 8];\\r\\nunsigned int ebuflen;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH], key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ectx;\\r\\nmemcpy(iv, INIT_VECTOR, sizeof(iv));\\r\\nEVP_BytesToKey(ALG, EVP_md5(), \"salu\", pw, strlen(pw), 1, key, iv);\\r\\nEVP_CipherInit(&ectx, ALG, key, iv, operation);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nEVP_CipherUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_CipherFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_meth_c", "target": 0, "func": "ASN1_METHOD *ASN1_IA5STRING_asn1_meth(void)\\r\\n{\\r\\nreturn(&ia5string_meth);\\r\\n}\\r\\nASN1_METHOD *ASN1_BIT_STRING_asn1_meth(void)\\r\\n{\\r\\nreturn(&bit_string_meth);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_pk1_c", "target": 0, "func": "int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen)\\r\\n{\\r\\nint j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-11))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=1;\\r\\nj=tlen-3-flen;\\r\\nmemset(p,0xff,j);\\r\\np+=j;\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen, int num)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\np=from;\\r\\nif ((num != (flen+1)) || (*(p++) != 01))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BLOCK_TYPE_IS_NOT_01);\\r\\nreturn(-1);\\r\\n}\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p != 0xff)\\r\\n{\\r\\nif (*p == 0)\\r\\n{ p++; break; }\\r\\nelse {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_FIXED_HEADER_DECRYPT);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (i == j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nif (i < 8)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_PAD_BYTE_COUNT);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}\\r\\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen-11))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)to;\\r\\n*(p++)=0;\\r\\n*(p++)=2;\\r\\nj=tlen-3-flen;\\r\\nRAND_bytes(p,j);\\r\\nfor (i=0; i<j; i++)\\r\\n{\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nRAND_bytes(p,1);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\n*(p++)='\\0';\\r\\nmemcpy(p,from,(unsigned int)flen);\\r\\nreturn(1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen, int num)\\r\\n{\\r\\nint i,j;\\r\\nunsigned char *p;\\r\\np=from;\\r\\nif ((num != (flen+1)) || (*(p++) != 02))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BLOCK_TYPE_IS_NOT_02);\\r\\nreturn(-1);\\r\\n}\\r\\n#ifdef PKCS1_CHECK\\r\\nreturn(num-11);\\r\\n#endif\\r\\nj=flen-1;\\r\\nfor (i=0; i<j; i++)\\r\\nif (*(p++) == 0) break;\\r\\nif (i == j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn(-1);\\r\\n}\\r\\nif (i < 8)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BAD_PAD_BYTE_COUNT);\\r\\nreturn(-1);\\r\\n}\\r\\ni++;\\r\\nj-=i;\\r\\nmemcpy(to,p,(unsigned int)j);\\r\\nreturn(j);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t_x509_c", "target": 0, "func": "int X509_print_fp(FILE *fp, X509 *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_print(BIO *bp, X509 *x)\\r\\n{\\r\\nlong l;\\r\\nint ret=0,i,j,n;\\r\\nchar *m=NULL,*s;\\r\\nX509_CINF *ci;\\r\\nASN1_INTEGER *bs;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nconst char *neg;\\r\\nX509_EXTENSION *ex;\\r\\nASN1_STRING *str=NULL;\\r\\nci=x->cert_info;\\r\\nif (BIO_write(bp,\"Certificate:\\n\",13) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Data:\\n\",10) <= 0) goto err;\\r\\nl=X509_get_version(x);\\r\\nif (BIO_printf(bp,\"%8sVersion: %lu (0x%lx)\\n\",\"\",l+1,l) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Serial Number:\",22) <= 0) goto err;\\r\\nbs=X509_get_serialNumber(x);\\r\\nif (bs->length <= 4)\\r\\n{\\r\\nl=ASN1_INTEGER_get(bs);\\r\\nif (l < 0)\\r\\n{\\r\\nl= -l;\\r\\nneg=\"-\";\\r\\n}\\r\\nelse\\r\\nneg=\"\";\\r\\nif (BIO_printf(bp,\" %s%lu (%s0x%lx)\\n\",neg,l,neg,l) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nneg=(bs->type == V_ASN1_NEG_INTEGER)?\" (Negative)\":\"\";\\r\\nif (BIO_printf(bp,\"\\n%12s%s\",\"\",neg) <= 0) goto err;\\r\\nfor (i=0; i<bs->length; i++)\\r\\n{\\r\\nif (BIO_printf(bp,\"%02x%c\",bs->data[i],\\r\\n((i+1 == bs->length)?'\\n':':')) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni=OBJ_obj2nid(ci->signature->algorithm);\\r\\nif (BIO_printf(bp,\"%8sSignature Algorithm: %s\\n\",\"\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i)) <= 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp,\" Issuer: \",16) <= 0) goto err;\\r\\nif (!X509_NAME_print(bp,X509_get_issuer_name(x),16)) goto err;\\r\\nif (BIO_write(bp,\"\\n Validity\\n\",18) <= 0) goto err;\\r\\nif (BIO_write(bp,\" Not Before: \",24) <= 0) goto err;\\r\\nif (!ASN1_TIME_print(bp,X509_get_notBefore(x))) goto err;\\r\\nif (BIO_write(bp,\"\\n Not After : \",25) <= 0) goto err;\\r\\nif (!ASN1_TIME_print(bp,X509_get_notAfter(x))) goto err;\\r\\nif (BIO_write(bp,\"\\n Subject: \",18) <= 0) goto err;\\r\\nif (!X509_NAME_print(bp,X509_get_subject_name(x),16)) goto err;\\r\\nif (BIO_write(bp,\"\\n Subject Public Key Info:\\n\",34) <= 0)\\r\\ngoto err;\\r\\ni=OBJ_obj2nid(ci->key->algor->algorithm);\\r\\nif (BIO_printf(bp,\"%12sPublic Key Algorithm: %s\\n\",\"\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i)) <= 0) goto err;\\r\\npkey=X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\n{\\r\\nBIO_printf(bp,\"%12sUnable to load Public Key\\n\",\"\");\\r\\nERR_print_errors(bp);\\r\\n}\\r\\nelse\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sRSA Public Key: (%d bit)\\n\",\"\",\\r\\nBN_num_bits(pkey->pkey.rsa->n));\\r\\nRSA_print(bp,pkey->pkey.rsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sDSA Public Key:\\n\",\"\");\\r\\nDSA_print(bp,pkey->pkey.dsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(bp,\"%12sUnknown Public Key:\\n\",\"\");\\r\\nEVP_PKEY_free(pkey);\\r\\nn=X509_get_ext_count(x);\\r\\nif (n > 0)\\r\\n{\\r\\nBIO_printf(bp,\"%8sX509v3 extensions:\\n\",\"\");\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\n#if 0\\r\\nint data_type,pack_type;\\r\\n#endif\\r\\nASN1_OBJECT *obj;\\r\\nex=X509_get_ext(x,i);\\r\\nif (BIO_printf(bp,\"%12s\",\"\") <= 0) goto err;\\r\\nobj=X509_EXTENSION_get_object(ex);\\r\\ni2a_ASN1_OBJECT(bp,obj);\\r\\nj=X509_EXTENSION_get_critical(ex);\\r\\nif (BIO_printf(bp,\": %s\\n\",j?\"critical\":\"\",\"\") <= 0)\\r\\ngoto err;\\r\\nif(!X509V3_EXT_print(bp, ex, 0, 16))\\r\\n{\\r\\nBIO_printf(bp, \"%16s\", \"\");\\r\\nASN1_OCTET_STRING_print(bp,ex->value);\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) <= 0) goto err;\\r\\n}\\r\\n}\\r\\ni=OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nif (BIO_printf(bp,\"%4sSignature Algorithm: %s\",\"\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i)) <= 0) goto err;\\r\\nn=x->signature->length;\\r\\ns=(char *)x->signature->data;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%18) == 0)\\r\\nif (BIO_write(bp,\"\\n \",9) <= 0) goto err;\\r\\nif (BIO_printf(bp,\"%02x%s\",(unsigned char)s[i],\\r\\n((i+1) == n)?\"\":\":\") <= 0) goto err;\\r\\n}\\r\\nif (BIO_write(bp,\"\\n\",1) != 1) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nif (str != NULL) ASN1_STRING_free(str);\\r\\nif (m != NULL) Free((char *)m);\\r\\nreturn(ret);\\r\\n}\\r\\nint ASN1_STRING_print(BIO *bp, ASN1_STRING *v)\\r\\n{\\r\\nint i,n;\\r\\nchar buf[80],*p;;\\r\\nif (v == NULL) return(0);\\r\\nn=0;\\r\\np=(char *)v->data;\\r\\nfor (i=0; i<v->length; i++)\\r\\n{\\r\\nif ((p[i] > '~') || ((p[i] < ' ') &&\\r\\n(p[i] != '\\n') && (p[i] != '\\r')))\\r\\nbuf[n]='.';\\r\\nelse\\r\\nbuf[n]=p[i];\\r\\nn++;\\r\\nif (n >= 80)\\r\\n{\\r\\nif (BIO_write(bp,buf,n) <= 0)\\r\\nreturn(0);\\r\\nn=0;\\r\\n}\\r\\n}\\r\\nif (n > 0)\\r\\nif (BIO_write(bp,buf,n) <= 0)\\r\\nreturn(0);\\r\\nreturn(1);\\r\\n}\\r\\nint ASN1_TIME_print(BIO *bp, ASN1_TIME *tm)\\r\\n{\\r\\nif(tm->type == V_ASN1_UTCTIME) return ASN1_UTCTIME_print(bp, tm);\\r\\nif(tm->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_print(bp, tm);\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_print(BIO *bp, ASN1_GENERALIZEDTIME *tm)\\r\\n{\\r\\nchar *v;\\r\\nint gmt=0;\\r\\nint i;\\r\\nint y=0,M=0,d=0,h=0,m=0,s=0;\\r\\ni=tm->length;\\r\\nv=(char *)tm->data;\\r\\nif (i < 12) goto err;\\r\\nif (v[i-1] == 'Z') gmt=1;\\r\\nfor (i=0; i<12; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0')) goto err;\\r\\ny= (v[0]-'0')*1000+(v[1]-'0')*100 + (v[2]-'0')*10+(v[3]-'0');\\r\\nM= (v[4]-'0')*10+(v[5]-'0');\\r\\nif ((M > 12) || (M < 1)) goto err;\\r\\nd= (v[6]-'0')*10+(v[7]-'0');\\r\\nh= (v[8]-'0')*10+(v[9]-'0');\\r\\nm= (v[10]-'0')*10+(v[11]-'0');\\r\\nif ( (v[12] >= '0') && (v[12] <= '9') &&\\r\\n(v[13] >= '0') && (v[13] <= '9'))\\r\\ns= (v[12]-'0')*10+(v[13]-'0');\\r\\nif (BIO_printf(bp,\"%s %2d %02d:%02d:%02d %d%s\",\\r\\nmon[M-1],d,h,m,s,y,(gmt)?\" GMT\":\"\") <= 0)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\nerr:\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint ASN1_UTCTIME_print(BIO *bp, ASN1_UTCTIME *tm)\\r\\n{\\r\\nchar *v;\\r\\nint gmt=0;\\r\\nint i;\\r\\nint y=0,M=0,d=0,h=0,m=0,s=0;\\r\\ni=tm->length;\\r\\nv=(char *)tm->data;\\r\\nif (i < 10) goto err;\\r\\nif (v[i-1] == 'Z') gmt=1;\\r\\nfor (i=0; i<10; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0')) goto err;\\r\\ny= (v[0]-'0')*10+(v[1]-'0');\\r\\nif (y < 50) y+=100;\\r\\nM= (v[2]-'0')*10+(v[3]-'0');\\r\\nif ((M > 12) || (M < 1)) goto err;\\r\\nd= (v[4]-'0')*10+(v[5]-'0');\\r\\nh= (v[6]-'0')*10+(v[7]-'0');\\r\\nm= (v[8]-'0')*10+(v[9]-'0');\\r\\nif ( (v[10] >= '0') && (v[10] <= '9') &&\\r\\n(v[11] >= '0') && (v[11] <= '9'))\\r\\ns= (v[10]-'0')*10+(v[11]-'0');\\r\\nif (BIO_printf(bp,\"%s %2d %02d:%02d:%02d %d%s\",\\r\\nmon[M-1],d,h,m,s,y+1900,(gmt)?\" GMT\":\"\") <= 0)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn(1);\\r\\nerr:\\r\\nBIO_write(bp,\"Bad time value\",14);\\r\\nreturn(0);\\r\\n}\\r\\nint X509_NAME_print(BIO *bp, X509_NAME *name, int obase)\\r\\n{\\r\\nchar *s,*c;\\r\\nint ret=0,l,ll,i,first=1;\\r\\nchar buf[256];\\r\\nll=80-2-obase;\\r\\ns=X509_NAME_oneline(name,buf,256);\\r\\ns++;\\r\\nl=ll;\\r\\nc=s;\\r\\nfor (;;)\\r\\n{\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ( ((*s == '/') &&\\r\\n((s[1] >= 'A') && (s[1] <= 'Z') && (\\r\\n(s[2] == '=') ||\\r\\n((s[2] >= 'A') && (s[2] <= 'Z') &&\\r\\n(s[3] == '='))\\r\\n))) ||\\r\\n(*s == '\\0'))\\r\\n#else\\r\\nif ( ((*s == '/') &&\\r\\n(isupper(s[1]) && (\\r\\n(s[2] == '=') ||\\r\\n(isupper(s[2]) &&\\r\\n(s[3] == '='))\\r\\n))) ||\\r\\n(*s == '\\0'))\\r\\n#endif\\r\\n{\\r\\nif ((l <= 0) && !first)\\r\\n{\\r\\nfirst=0;\\r\\nif (BIO_write(bp,\"\\n\",1) != 1) goto err;\\r\\nfor (i=0; i<obase; i++)\\r\\n{\\r\\nif (BIO_write(bp,\" \",1) != 1) goto err;\\r\\n}\\r\\nl=ll;\\r\\n}\\r\\ni=s-c;\\r\\nif (BIO_write(bp,c,i) != i) goto err;\\r\\nc+=i;\\r\\nc++;\\r\\nif (*s != '\\0')\\r\\n{\\r\\nif (BIO_write(bp,\", \",2) != 2) goto err;\\r\\n}\\r\\nl--;\\r\\n}\\r\\nif (*s == '\\0') break;\\r\\ns++;\\r\\nl--;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_PRINT,ERR_R_BUF_LIB);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_b_sock_c", "target": 0, "func": "int BIO_get_host_ip(const char *str, unsigned char *ip)\\r\\n{\\r\\nint i;\\r\\nint err = 1;\\r\\nint locked = 0;\\r\\nstruct hostent *he;\\r\\ni=get_ip(str,ip);\\r\\nif (i > 0) return(1);\\r\\nif (i < 0)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_INVALID_IP_ADDRESS);\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_sock_init())\\r\\nreturn(0);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nlocked = 1;\\r\\nhe=BIO_gethostbyname(str);\\r\\nif (he == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_BAD_HOSTNAME_LOOKUP);\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);\\r\\ngoto err;\\r\\n}\\r\\nfor (i=0; i<4; i++)\\r\\nip[i]=he->h_addr_list[0][i];\\r\\nerr = 0;\\r\\nerr:\\r\\nif (locked)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nif (err)\\r\\n{\\r\\nERR_add_error_data(2,\"host=\",str);\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint BIO_get_port(const char *str, unsigned short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\nif (str == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GET_PORT,BIO_R_NO_PORT_DEFINED);\\r\\nreturn(0);\\r\\n}\\r\\ni=atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr=(unsigned short)i;\\r\\nelse\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\ns=getservbyname(str,\"tcp\");\\r\\nif(s != NULL)\\r\\n*port_ptr=ntohs((unsigned short)s->s_port);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\nif(s == NULL)\\r\\n{\\r\\nif (strcmp(str,\"http\") == 0)\\r\\n*port_ptr=80;\\r\\nelse if (strcmp(str,\"telnet\") == 0)\\r\\n*port_ptr=23;\\r\\nelse if (strcmp(str,\"socks\") == 0)\\r\\n*port_ptr=1080;\\r\\nelse if (strcmp(str,\"https\") == 0)\\r\\n*port_ptr=443;\\r\\nelse if (strcmp(str,\"ssl\") == 0)\\r\\n*port_ptr=443;\\r\\nelse if (strcmp(str,\"ftp\") == 0)\\r\\n*port_ptr=21;\\r\\nelse if (strcmp(str,\"gopher\") == 0)\\r\\n*port_ptr=70;\\r\\n#if 0\\r\\nelse if (strcmp(str,\"wais\") == 0)\\r\\n*port_ptr=21;\\r\\n#endif\\r\\nelse\\r\\n{\\r\\nSYSerr(SYS_F_GETSERVBYNAME,get_last_socket_error());\\r\\nERR_add_error_data(3,\"service='\",str,\"'\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_sock_error(int sock)\\r\\n{\\r\\nint j,i;\\r\\nint size;\\r\\nsize=sizeof(int);\\r\\ni=getsockopt(sock,SOL_SOCKET,SO_ERROR,(void *)&j,(void *)&size);\\r\\nif (i < 0)\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(j);\\r\\n}\\r\\nlong BIO_ghbn_ctrl(int cmd, int iarg, char *parg)\\r\\n{\\r\\nint i;\\r\\nchar **p;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_GHBN_CTRL_HITS:\\r\\nreturn(BIO_ghbn_hits);\\r\\ncase BIO_GHBN_CTRL_MISSES:\\r\\nreturn(BIO_ghbn_miss);\\r\\ncase BIO_GHBN_CTRL_CACHE_SIZE:\\r\\nreturn(GHBN_NUM);\\r\\ncase BIO_GHBN_CTRL_GET_ENTRY:\\r\\nif ((iarg >= 0) && (iarg <GHBN_NUM) &&\\r\\n(ghbn_cache[iarg].order > 0))\\r\\n{\\r\\np=(char **)parg;\\r\\nif (p == NULL) return(0);\\r\\n*p=ghbn_cache[iarg].name;\\r\\nghbn_cache[iarg].name[128]='\\0';\\r\\nreturn(1);\\r\\n}\\r\\nreturn(0);\\r\\ncase BIO_GHBN_CTRL_FLUSH:\\r\\nfor (i=0; i<GHBN_NUM; i++)\\r\\nghbn_cache[i].order=0;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn(0);\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic struct hostent *ghbn_dup(struct hostent *a)\\r\\n{\\r\\nstruct hostent *ret;\\r\\nint i,j;\\r\\nMemCheck_off();\\r\\nret=(struct hostent *)Malloc(sizeof(struct hostent));\\r\\nif (ret == NULL) return(NULL);\\r\\nmemset(ret,0,sizeof(struct hostent));\\r\\nfor (i=0; a->h_aliases[i] != NULL; i++)\\r\\n;\\r\\ni++;\\r\\nret->h_aliases = (char **)Malloc(i*sizeof(char *));\\r\\nif (ret->h_aliases == NULL)\\r\\ngoto err;\\r\\nmemset(ret->h_aliases, 0, i*sizeof(char *));\\r\\nfor (i=0; a->h_addr_list[i] != NULL; i++)\\r\\n;\\r\\ni++;\\r\\nret->h_addr_list=(char **)Malloc(i*sizeof(char *));\\r\\nif (ret->h_addr_list == NULL)\\r\\ngoto err;\\r\\nmemset(ret->h_addr_list, 0, i*sizeof(char *));\\r\\nj=strlen(a->h_name)+1;\\r\\nif ((ret->h_name=Malloc(j)) == NULL) goto err;\\r\\nmemcpy((char *)ret->h_name,a->h_name,j+1);\\r\\nfor (i=0; a->h_aliases[i] != NULL; i++)\\r\\n{\\r\\nj=strlen(a->h_aliases[i])+1;\\r\\nif ((ret->h_aliases[i]=Malloc(j)) == NULL) goto err;\\r\\nmemcpy(ret->h_aliases[i],a->h_aliases[i],j+1);\\r\\n}\\r\\nret->h_length=a->h_length;\\r\\nret->h_addrtype=a->h_addrtype;\\r\\nfor (i=0; a->h_addr_list[i] != NULL; i++)\\r\\n{\\r\\nif ((ret->h_addr_list[i]=Malloc(a->h_length)) == NULL)\\r\\ngoto err;\\r\\nmemcpy(ret->h_addr_list[i],a->h_addr_list[i],a->h_length);\\r\\n}\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nghbn_free(ret);\\r\\nret=NULL;\\r\\n}\\r\\nMemCheck_on();\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void ghbn_free(struct hostent *a)\\r\\n{\\r\\nint i;\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->h_aliases != NULL)\\r\\n{\\r\\nfor (i=0; a->h_aliases[i] != NULL; i++)\\r\\nFree(a->h_aliases[i]);\\r\\nFree(a->h_aliases);\\r\\n}\\r\\nif (a->h_addr_list != NULL)\\r\\n{\\r\\nfor (i=0; a->h_addr_list[i] != NULL; i++)\\r\\nFree(a->h_addr_list[i]);\\r\\nFree(a->h_addr_list);\\r\\n}\\r\\nif (a->h_name != NULL) Free((char *)a->h_name);\\r\\nFree(a);\\r\\n}\\r\\nstruct hostent *BIO_gethostbyname(const char *name)\\r\\n{\\r\\nstruct hostent *ret;\\r\\nint i,lowi=0,j;\\r\\nunsigned long low= (unsigned long)-1;\\r\\n#if 0\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n#endif\\r\\nj=strlen(name);\\r\\nif (j < 128)\\r\\n{\\r\\nfor (i=0; i<GHBN_NUM; i++)\\r\\n{\\r\\nif (low > ghbn_cache[i].order)\\r\\n{\\r\\nlow=ghbn_cache[i].order;\\r\\nlowi=i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0)\\r\\n{\\r\\nif (strncmp(name,ghbn_cache[i].name,128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\ni=GHBN_NUM;\\r\\nif (i == GHBN_NUM)\\r\\n{\\r\\nBIO_ghbn_miss++;\\r\\nret=gethostbyname(name);\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (j > 128)\\r\\n{\\r\\n#if 0\\r\\nret = NULL;\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nif (ghbn_cache[lowi].ent != NULL)\\r\\nghbn_free(ghbn_cache[lowi].ent);\\r\\nghbn_cache[lowi].name[0] = '\\0';\\r\\nif((ret=ghbn_cache[lowi].ent=ghbn_dup(ret)) == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_GETHOSTBYNAME,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nstrncpy(ghbn_cache[lowi].name,name,128);\\r\\nghbn_cache[lowi].order=BIO_ghbn_miss+BIO_ghbn_hits;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_ghbn_hits++;\\r\\nret= ghbn_cache[i].ent;\\r\\nghbn_cache[i].order=BIO_ghbn_miss+BIO_ghbn_hits;\\r\\n}\\r\\nend:\\r\\n#if 0\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_sock_init(void)\\r\\n{\\r\\n#ifdef WINDOWS\\r\\nstatic struct WSAData wsa_state;\\r\\nif (!wsa_init_done)\\r\\n{\\r\\nint err;\\r\\n#ifdef SIGINT\\r\\nsignal(SIGINT,(void (*)(int))BIO_sock_cleanup);\\r\\n#endif\\r\\nwsa_init_done=1;\\r\\nmemset(&wsa_state,0,sizeof(wsa_state));\\r\\nif (WSAStartup(0x0101,&wsa_state)!=0)\\r\\n{\\r\\nerr=WSAGetLastError();\\r\\nSYSerr(SYS_F_WSASTARTUP,err);\\r\\nBIOerr(BIO_F_BIO_SOCK_INIT,BIO_R_WSASTARTUP);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nvoid BIO_sock_cleanup(void)\\r\\n{\\r\\n#ifdef WINDOWS\\r\\nif (wsa_init_done)\\r\\n{\\r\\nwsa_init_done=0;\\r\\nWSACancelBlockingCall();\\r\\nWSACleanup();\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint BIO_socket_ioctl(int fd, long type, unsigned long *arg)\\r\\n{\\r\\nint i;\\r\\ni=ioctlsocket(fd,type,arg);\\r\\nif (i < 0)\\r\\nSYSerr(SYS_F_IOCTLSOCKET,get_last_socket_error());\\r\\nreturn(i);\\r\\n}\\r\\nstatic int get_ip(const char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int tmp[4];\\r\\nint num=0,c,ok=0;\\r\\ntmp[0]=tmp[1]=tmp[2]=tmp[3]=0;\\r\\nfor (;;)\\r\\n{\\r\\nc= *(str++);\\r\\nif ((c >= '0') && (c <= '9'))\\r\\n{\\r\\nok=1;\\r\\ntmp[num]=tmp[num]*10+c-'0';\\r\\nif (tmp[num] > 255) return(-1);\\r\\n}\\r\\nelse if (c == '.')\\r\\n{\\r\\nif (!ok) return(-1);\\r\\nif (num == 3) break;\\r\\nnum++;\\r\\nok=0;\\r\\n}\\r\\nelse if ((num == 3) && ok)\\r\\nbreak;\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nip[0]=tmp[0];\\r\\nip[1]=tmp[1];\\r\\nip[2]=tmp[2];\\r\\nip[3]=tmp[3];\\r\\nreturn(1);\\r\\n}\\r\\nint BIO_get_accept_socket(char *host, int bind_mode)\\r\\n{\\r\\nint ret=0;\\r\\nstruct sockaddr_in server,client;\\r\\nint s= -1,cs;\\r\\nunsigned char ip[4];\\r\\nunsigned short port;\\r\\nchar *str,*e;\\r\\nconst char *h,*p;\\r\\nunsigned long l;\\r\\nint err_num;\\r\\nif (!BIO_sock_init()) return(INVALID_SOCKET);\\r\\nif ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);\\r\\nh=p=NULL;\\r\\nh=str;\\r\\nfor (e=str; *e; e++)\\r\\n{\\r\\nif (*e == ':')\\r\\n{\\r\\np= &(e[1]);\\r\\n*e='\\0';\\r\\n}\\r\\nelse if (*e == '/')\\r\\n{\\r\\n*e='\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p == NULL)\\r\\n{\\r\\np=h;\\r\\nh=\"*\";\\r\\n}\\r\\nif (!BIO_get_port(p,&port)) return(INVALID_SOCKET);\\r\\nmemset((char *)&server,0,sizeof(server));\\r\\nserver.sin_family=AF_INET;\\r\\nserver.sin_port=htons(port);\\r\\nif (strcmp(h,\"*\") == 0)\\r\\nserver.sin_addr.s_addr=INADDR_ANY;\\r\\nelse\\r\\n{\\r\\nif (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET);\\r\\nl=(unsigned long)\\r\\n((unsigned long)ip[0]<<24L)|\\r\\n((unsigned long)ip[1]<<16L)|\\r\\n((unsigned long)ip[2]<< 8L)|\\r\\n((unsigned long)ip[3]);\\r\\nserver.sin_addr.s_addr=htonl(l);\\r\\n}\\r\\nagain:\\r\\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET)\\r\\n{\\r\\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef SO_REUSEADDR\\r\\nif (bind_mode == BIO_BIND_REUSEADDR)\\r\\n{\\r\\nint i=1;\\r\\nret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));\\r\\nbind_mode=BIO_BIND_NORMAL;\\r\\n}\\r\\n#endif\\r\\nif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\\r\\n{\\r\\n#ifdef SO_REUSEADDR\\r\\nerr_num=get_last_socket_error();\\r\\nif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\\r\\n(err_num == EADDRINUSE))\\r\\n{\\r\\nmemcpy((char *)&client,(char *)&server,sizeof(server));\\r\\nif (strcmp(h,\"*\") == 0)\\r\\nclient.sin_addr.s_addr=htonl(0x7F000001);\\r\\ncs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\\r\\nif (cs != INVALID_SOCKET)\\r\\n{\\r\\nint ii;\\r\\nii=connect(cs,(struct sockaddr *)&client,\\r\\nsizeof(client));\\r\\nclosesocket(cs);\\r\\nif (ii == INVALID_SOCKET)\\r\\n{\\r\\nbind_mode=BIO_BIND_REUSEADDR;\\r\\nclosesocket(s);\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\nSYSerr(SYS_F_BIND,err_num);\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\nif (listen(s,MAX_LISTEN) == -1)\\r\\n{\\r\\nSYSerr(SYS_F_BIND,get_last_socket_error());\\r\\nERR_add_error_data(3,\"port='\",host,\"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\nret=1;\\r\\nerr:\\r\\nif (str != NULL) Free(str);\\r\\nif ((ret == 0) && (s != INVALID_SOCKET))\\r\\n{\\r\\nclosesocket(s);\\r\\ns= INVALID_SOCKET;\\r\\n}\\r\\nreturn(s);\\r\\n}\\r\\nint BIO_accept(int sock, char **addr)\\r\\n{\\r\\nint ret=INVALID_SOCKET;\\r\\nstatic struct sockaddr_in from;\\r\\nunsigned long l;\\r\\nunsigned short port;\\r\\nint len;\\r\\nchar *p;\\r\\nmemset((char *)&from,0,sizeof(from));\\r\\nlen=sizeof(from);\\r\\nret=accept(sock,(struct sockaddr *)&from,(void *)&len);\\r\\nif (ret == INVALID_SOCKET)\\r\\n{\\r\\nSYSerr(SYS_F_ACCEPT,get_last_socket_error());\\r\\nBIOerr(BIO_F_BIO_ACCEPT,BIO_R_ACCEPT_ERROR);\\r\\ngoto end;\\r\\n}\\r\\nif (addr == NULL) goto end;\\r\\nl=ntohl(from.sin_addr.s_addr);\\r\\nport=ntohs(from.sin_port);\\r\\nif (*addr == NULL)\\r\\n{\\r\\nif ((p=Malloc(24)) == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_ACCEPT,ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\n*addr=p;\\r\\n}\\r\\nsprintf(*addr,\"%d.%d.%d.%d:%d\",\\r\\n(unsigned char)(l>>24L)&0xff,\\r\\n(unsigned char)(l>>16L)&0xff,\\r\\n(unsigned char)(l>> 8L)&0xff,\\r\\n(unsigned char)(l )&0xff,\\r\\nport);\\r\\nend:\\r\\nreturn(ret);\\r\\n}\\r\\nint BIO_set_tcp_ndelay(int s, int on)\\r\\n{\\r\\nint ret=0;\\r\\n#if defined(TCP_NODELAY) && (defined(IPPROTO_TCP) || defined(SOL_TCP))\\r\\nint opt;\\r\\n#ifdef SOL_TCP\\r\\nopt=SOL_TCP;\\r\\n#else\\r\\n#ifdef IPPROTO_TCP\\r\\nopt=IPPROTO_TCP;\\r\\n#endif\\r\\n#endif\\r\\nret=setsockopt(s,opt,TCP_NODELAY,(char *)&on,sizeof(on));\\r\\n#endif\\r\\nreturn(ret == 0);\\r\\n}\\r\\nint BIO_socket_nbio(int s, int mode)\\r\\n{\\r\\nint ret= -1;\\r\\nunsigned long l;\\r\\nl=mode;\\r\\n#ifdef FIONBIO\\r\\nret=BIO_socket_ioctl(s,FIONBIO,&l);\\r\\n#endif\\r\\nreturn(ret == 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_c_ofb64_c", "target": 0, "func": "void CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, CAST_KEY *schedule, unsigned char *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister CAST_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nCAST_encrypt((CAST_LONG *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_conf_c", "target": 0, "func": "LHASH *CONF_load(LHASH *h, const char *file, long *line)\\r\\n{\\r\\nLHASH *ltmp;\\r\\nFILE *in=NULL;\\r\\n#ifdef VMS\\r\\nin=fopen(file,\"r\");\\r\\n#else\\r\\nin=fopen(file,\"rb\");\\r\\n#endif\\r\\nif (in == NULL)\\r\\n{\\r\\nSYSerr(SYS_F_FOPEN,get_last_sys_error());\\r\\nERR_set_error_data(BUF_strdup(file),\\r\\nERR_TXT_MALLOCED|ERR_TXT_STRING);\\r\\nCONFerr(CONF_F_CONF_LOAD,ERR_R_SYS_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nltmp = CONF_load_fp(h, in, line);\\r\\nfclose(in);\\r\\nreturn ltmp;\\r\\n}\\r\\nLHASH *CONF_load_fp(LHASH *h, FILE *in, long *line)\\r\\n{\\r\\nBIO *btmp;\\r\\nLHASH *ltmp;\\r\\nif(!(btmp = BIO_new_fp(in, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_CONF_LOAD_FP,ERR_R_BUF_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nltmp = CONF_load_bio(h, btmp, line);\\r\\nBIO_free(btmp);\\r\\nreturn ltmp;\\r\\n}\\r\\nLHASH *CONF_load_bio(LHASH *h, BIO *in, long *line)\\r\\n{\\r\\nLHASH *ret=NULL;\\r\\n#define BUFSIZE 512\\r\\nchar btmp[16];\\r\\nint bufnum=0,i,ii;\\r\\nBUF_MEM *buff=NULL;\\r\\nchar *s,*p,*end;\\r\\nint again,n;\\r\\nlong eline=0;\\r\\nCONF_VALUE *v=NULL,*vv,*tv;\\r\\nCONF_VALUE *sv=NULL;\\r\\nchar *section=NULL,*buf;\\r\\nSTACK_OF(CONF_VALUE) *section_sk=NULL,*ts;\\r\\nchar *start,*psection,*pname;\\r\\nif ((buff=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nsection=(char *)Malloc(10);\\r\\nif (section == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nstrcpy(section,\"default\");\\r\\nif (h == NULL)\\r\\n{\\r\\nif ((ret=lh_new(hash,cmp_conf)) == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret=h;\\r\\nsv=new_section(ret,section);\\r\\nif (sv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\\r\\nbufnum=0;\\r\\nfor (;;)\\r\\n{\\r\\nagain=0;\\r\\nif (!BUF_MEM_grow(buff,bufnum+BUFSIZE))\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np= &(buff->data[bufnum]);\\r\\n*p='\\0';\\r\\nBIO_gets(in, p, BUFSIZE-1);\\r\\np[BUFSIZE-1]='\\0';\\r\\nii=i=strlen(p);\\r\\nif (i == 0) break;\\r\\nwhile (i > 0)\\r\\n{\\r\\nif ((p[i-1] != '\\r') && (p[i-1] != '\\n'))\\r\\nbreak;\\r\\nelse\\r\\ni--;\\r\\n}\\r\\nif (i == ii)\\r\\nagain=1;\\r\\nelse\\r\\n{\\r\\np[i]='\\0';\\r\\neline++;\\r\\n}\\r\\nbufnum+=i;\\r\\nv=NULL;\\r\\nif (bufnum >= 1)\\r\\n{\\r\\np= &(buff->data[bufnum-1]);\\r\\nif ( IS_ESC(p[0]) &&\\r\\n((bufnum <= 1) || !IS_ESC(p[-1])))\\r\\n{\\r\\nbufnum--;\\r\\nagain=1;\\r\\n}\\r\\n}\\r\\nif (again) continue;\\r\\nbufnum=0;\\r\\nbuf=buff->data;\\r\\nclear_comments(buf);\\r\\nn=strlen(buf);\\r\\ns=eat_ws(buf);\\r\\nif (IS_EOF(*s)) continue;\\r\\nif (*s == '[')\\r\\n{\\r\\nchar *ss;\\r\\ns++;\\r\\nstart=eat_ws(s);\\r\\nss=start;\\r\\nagain:\\r\\nend=eat_alpha_numeric(ss);\\r\\np=eat_ws(end);\\r\\nif (*p != ']')\\r\\n{\\r\\nif (*p != '\\0')\\r\\n{\\r\\nss=p;\\r\\ngoto again;\\r\\n}\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nCONF_R_MISSING_CLOSE_SQUARE_BRACKET);\\r\\ngoto err;\\r\\n}\\r\\n*end='\\0';\\r\\nif (!str_copy(ret,NULL,&section,start)) goto err;\\r\\nif ((sv=get_section(ret,section)) == NULL)\\r\\nsv=new_section(ret,section);\\r\\nif (sv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\npname=s;\\r\\npsection=NULL;\\r\\nend=eat_alpha_numeric(s);\\r\\nif ((end[0] == ':') && (end[1] == ':'))\\r\\n{\\r\\n*end='\\0';\\r\\nend+=2;\\r\\npsection=pname;\\r\\npname=end;\\r\\nend=eat_alpha_numeric(end);\\r\\n}\\r\\np=eat_ws(end);\\r\\nif (*p != '=')\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nCONF_R_MISSING_EQUAL_SIGN);\\r\\ngoto err;\\r\\n}\\r\\n*end='\\0';\\r\\np++;\\r\\nstart=eat_ws(p);\\r\\nwhile (!IS_EOF(*p))\\r\\np++;\\r\\np--;\\r\\nwhile ((p != start) && (IS_WS(*p)))\\r\\np--;\\r\\np++;\\r\\n*p='\\0';\\r\\nif (!(v=(CONF_VALUE *)Malloc(sizeof(CONF_VALUE))))\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (psection == NULL) psection=section;\\r\\nv->name=(char *)Malloc(strlen(pname)+1);\\r\\nv->value=NULL;\\r\\nif (v->name == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nstrcpy(v->name,pname);\\r\\nif (!str_copy(ret,psection,&(v->value),start)) goto err;\\r\\nif (strcmp(psection,section) != 0)\\r\\n{\\r\\nif ((tv=get_section(ret,psection))\\r\\n== NULL)\\r\\ntv=new_section(ret,psection);\\r\\nif (tv == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nts=(STACK_OF(CONF_VALUE) *)tv->value;\\r\\n}\\r\\nelse\\r\\n{\\r\\ntv=sv;\\r\\nts=section_sk;\\r\\n}\\r\\nv->section=tv->section;\\r\\nif (!sk_CONF_VALUE_push(ts,v))\\r\\n{\\r\\nCONFerr(CONF_F_CONF_LOAD_BIO,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nvv=(CONF_VALUE *)lh_insert(ret,(char *)v);\\r\\nif (vv != NULL)\\r\\n{\\r\\nsk_CONF_VALUE_delete_ptr(ts,vv);\\r\\nFree(vv->name);\\r\\nFree(vv->value);\\r\\nFree(vv);\\r\\n}\\r\\nv=NULL;\\r\\n}\\r\\n}\\r\\nif (buff != NULL) BUF_MEM_free(buff);\\r\\nif (section != NULL) Free(section);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (buff != NULL) BUF_MEM_free(buff);\\r\\nif (section != NULL) Free(section);\\r\\nif (line != NULL) *line=eline;\\r\\nsprintf(btmp,\"%ld\",eline);\\r\\nERR_add_error_data(2,\"line \",btmp);\\r\\nif ((h != ret) && (ret != NULL)) CONF_free(ret);\\r\\nif (v != NULL)\\r\\n{\\r\\nif (v->name != NULL) Free(v->name);\\r\\nif (v->value != NULL) Free(v->value);\\r\\nif (v != NULL) Free(v);\\r\\n}\\r\\nreturn(NULL);\\r\\n}\\r\\nchar *CONF_get_string(LHASH *conf, char *section, char *name)\\r\\n{\\r\\nCONF_VALUE *v,vv;\\r\\nchar *p;\\r\\nif (name == NULL) return(NULL);\\r\\nif (conf != NULL)\\r\\n{\\r\\nif (section != NULL)\\r\\n{\\r\\nvv.name=name;\\r\\nvv.section=section;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf,(char *)&vv);\\r\\nif (v != NULL) return(v->value);\\r\\nif (strcmp(section,\"ENV\") == 0)\\r\\n{\\r\\np=Getenv(name);\\r\\nif (p != NULL) return(p);\\r\\n}\\r\\n}\\r\\nvv.section=\"default\";\\r\\nvv.name=name;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf,(char *)&vv);\\r\\nif (v != NULL)\\r\\nreturn(v->value);\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nelse\\r\\nreturn(Getenv(name));\\r\\n}\\r\\nstatic CONF_VALUE *get_section(LHASH *conf, char *section)\\r\\n{\\r\\nCONF_VALUE *v,vv;\\r\\nif ((conf == NULL) || (section == NULL)) return(NULL);\\r\\nvv.name=NULL;\\r\\nvv.section=section;\\r\\nv=(CONF_VALUE *)lh_retrieve(conf,(char *)&vv);\\r\\nreturn(v);\\r\\n}\\r\\nlong CONF_get_number(LHASH *conf, char *section, char *name)\\r\\n{\\r\\nchar *str;\\r\\nlong ret=0;\\r\\nstr=CONF_get_string(conf,section,name);\\r\\nif (str == NULL) return(0);\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_NUMER(*str))\\r\\nret=ret*10+(*str -'0');\\r\\nelse\\r\\nreturn(ret);\\r\\nstr++;\\r\\n}\\r\\n}\\r\\nvoid CONF_free(LHASH *conf)\\r\\n{\\r\\nif (conf == NULL) return;\\r\\nconf->down_load=0;\\r\\nlh_doall_arg(conf,(void (*)())value_free_hash,(char *)conf);\\r\\nlh_doall_arg(conf,(void (*)())value_free_stack,(char *)conf);\\r\\nlh_free(conf);\\r\\n}\\r\\nstatic void value_free_hash(CONF_VALUE *a, LHASH *conf)\\r\\n{\\r\\nif (a->name != NULL)\\r\\n{\\r\\na=(CONF_VALUE *)lh_delete(conf,(char *)a);\\r\\n}\\r\\n}\\r\\nstatic void value_free_stack(CONF_VALUE *a, LHASH *conf)\\r\\n{\\r\\nCONF_VALUE *vv;\\r\\nSTACK *sk;\\r\\nint i;\\r\\nif (a->name != NULL) return;\\r\\nsk=(STACK *)a->value;\\r\\nfor (i=sk_num(sk)-1; i>=0; i--)\\r\\n{\\r\\nvv=(CONF_VALUE *)sk_value(sk,i);\\r\\nFree(vv->value);\\r\\nFree(vv->name);\\r\\nFree(vv);\\r\\n}\\r\\nif (sk != NULL) sk_free(sk);\\r\\nFree(a->section);\\r\\nFree(a);\\r\\n}\\r\\nstatic void clear_comments(char *p)\\r\\n{\\r\\nchar *to;\\r\\nto=p;\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_COMMENT(*p))\\r\\n{\\r\\n*p='\\0';\\r\\nreturn;\\r\\n}\\r\\nif (IS_QUOTE(*p))\\r\\n{\\r\\np=scan_quote(p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_ESC(*p))\\r\\n{\\r\\np=scan_esc(p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_EOF(*p))\\r\\nreturn;\\r\\nelse\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic int str_copy(LHASH *conf, char *section, char **pto, char *from)\\r\\n{\\r\\nint q,r,rr=0,to=0,len=0;\\r\\nchar *s,*e,*rp,*p,*rrp,*np,*cp,v;\\r\\nBUF_MEM *buf;\\r\\nif ((buf=BUF_MEM_new()) == NULL) return(0);\\r\\nlen=strlen(from)+1;\\r\\nif (!BUF_MEM_grow(buf,len)) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_QUOTE(*from))\\r\\n{\\r\\nq= *from;\\r\\nfrom++;\\r\\nwhile ((*from != '\\0') && (*from != q))\\r\\n{\\r\\nif (*from == '\\\\')\\r\\n{\\r\\nfrom++;\\r\\nif (*from == '\\0') break;\\r\\n}\\r\\nbuf->data[to++]= *(from++);\\r\\n}\\r\\n}\\r\\nelse if (*from == '\\\\')\\r\\n{\\r\\nfrom++;\\r\\nv= *(from++);\\r\\nif (v == '\\0') break;\\r\\nelse if (v == 'r') v='\\r';\\r\\nelse if (v == 'n') v='\\n';\\r\\nelse if (v == 'b') v='\\b';\\r\\nelse if (v == 't') v='\\t';\\r\\nbuf->data[to++]= v;\\r\\n}\\r\\nelse if (*from == '\\0')\\r\\nbreak;\\r\\nelse if (*from == '$')\\r\\n{\\r\\nrrp=NULL;\\r\\ns= &(from[1]);\\r\\nif (*s == '{')\\r\\nq='}';\\r\\nelse if (*s == '(')\\r\\nq=')';\\r\\nelse q=0;\\r\\nif (q) s++;\\r\\ncp=section;\\r\\ne=np=s;\\r\\nwhile (IS_ALPHA_NUMERIC(*e))\\r\\ne++;\\r\\nif ((e[0] == ':') && (e[1] == ':'))\\r\\n{\\r\\ncp=np;\\r\\nrrp=e;\\r\\nrr= *e;\\r\\n*rrp='\\0';\\r\\ne+=2;\\r\\nnp=e;\\r\\nwhile (IS_ALPHA_NUMERIC(*e))\\r\\ne++;\\r\\n}\\r\\nr= *e;\\r\\n*e='\\0';\\r\\nrp=e;\\r\\nif (q)\\r\\n{\\r\\nif (r != q)\\r\\n{\\r\\nCONFerr(CONF_F_STR_COPY,CONF_R_NO_CLOSE_BRACE);\\r\\ngoto err;\\r\\n}\\r\\ne++;\\r\\n}\\r\\np=CONF_get_string(conf,cp,np);\\r\\nif (rrp != NULL) *rrp=rr;\\r\\n*rp=r;\\r\\nif (p == NULL)\\r\\n{\\r\\nCONFerr(CONF_F_STR_COPY,CONF_R_VARIABLE_HAS_NO_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_MEM_grow(buf,(strlen(p)+len-(e-from)));\\r\\nwhile (*p)\\r\\nbuf->data[to++]= *(p++);\\r\\nfrom=e;\\r\\n}\\r\\nelse\\r\\nbuf->data[to++]= *(from++);\\r\\n}\\r\\nbuf->data[to]='\\0';\\r\\nif (*pto != NULL) Free(*pto);\\r\\n*pto=buf->data;\\r\\nFree(buf);\\r\\nreturn(1);\\r\\nerr:\\r\\nif (buf != NULL) BUF_MEM_free(buf);\\r\\nreturn(0);\\r\\n}\\r\\nstatic char *eat_ws(char *p)\\r\\n{\\r\\nwhile (IS_WS(*p) && (!IS_EOF(*p)))\\r\\np++;\\r\\nreturn(p);\\r\\n}\\r\\nstatic char *eat_alpha_numeric(char *p)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (IS_ESC(*p))\\r\\n{\\r\\np=scan_esc(p);\\r\\ncontinue;\\r\\n}\\r\\nif (!IS_ALPHA_NUMERIC_PUNCT(*p))\\r\\nreturn(p);\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic unsigned long hash(CONF_VALUE *v)\\r\\n{\\r\\nreturn((lh_strhash(v->section)<<2)^lh_strhash(v->name));\\r\\n}\\r\\nstatic int cmp_conf(CONF_VALUE *a, CONF_VALUE *b)\\r\\n{\\r\\nint i;\\r\\nif (a->section != b->section)\\r\\n{\\r\\ni=strcmp(a->section,b->section);\\r\\nif (i) return(i);\\r\\n}\\r\\nif ((a->name != NULL) && (b->name != NULL))\\r\\n{\\r\\ni=strcmp(a->name,b->name);\\r\\nreturn(i);\\r\\n}\\r\\nelse if (a->name == b->name)\\r\\nreturn(0);\\r\\nelse\\r\\nreturn((a->name == NULL)?-1:1);\\r\\n}\\r\\nstatic char *scan_quote(char *p)\\r\\n{\\r\\nint q= *p;\\r\\np++;\\r\\nwhile (!(IS_EOF(*p)) && (*p != q))\\r\\n{\\r\\nif (IS_ESC(*p))\\r\\n{\\r\\np++;\\r\\nif (IS_EOF(*p)) return(p);\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (*p == q) p++;\\r\\nreturn(p);\\r\\n}\\r\\nstatic CONF_VALUE *new_section(LHASH *conf, char *section)\\r\\n{\\r\\nSTACK *sk=NULL;\\r\\nint ok=0,i;\\r\\nCONF_VALUE *v=NULL,*vv;\\r\\nif ((sk=sk_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((v=(CONF_VALUE *)Malloc(sizeof(CONF_VALUE))) == NULL)\\r\\ngoto err;\\r\\ni=strlen(section)+1;\\r\\nif ((v->section=(char *)Malloc(i)) == NULL)\\r\\ngoto err;\\r\\nmemcpy(v->section,section,i);\\r\\nv->name=NULL;\\r\\nv->value=(char *)sk;\\r\\nvv=(CONF_VALUE *)lh_insert(conf,(char *)v);\\r\\nif (vv != NULL)\\r\\n{\\r\\n#if !defined(NO_STDIO) && !defined(WIN16)\\r\\nfprintf(stderr,\"internal fault\\n\");\\r\\n#endif\\r\\nabort();\\r\\n}\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nif (sk != NULL) sk_free(sk);\\r\\nif (v != NULL) Free(v);\\r\\nv=NULL;\\r\\n}\\r\\nreturn(v);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_ia5_c", "target": 0, "func": "static ASN1_IA5STRING *ia5string_new(void)\\r\\n{\\r\\nreturn ASN1_IA5STRING_new();\\r\\n}\\r\\nstatic char *i2s_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nASN1_IA5STRING *ia5)\\r\\n{\\r\\nchar *tmp;\\r\\nif(!ia5 || !ia5->length) return NULL;\\r\\ntmp = Malloc(ia5->length + 1);\\r\\nmemcpy(tmp, ia5->data, ia5->length);\\r\\ntmp[ia5->length] = 0;\\r\\nreturn tmp;\\r\\n}\\r\\nstatic ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_IA5STRING *ia5;\\r\\nif(!str) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(ia5 = ASN1_IA5STRING_new())) goto err;\\r\\nif(!ASN1_STRING_set((ASN1_STRING *)ia5, (unsigned char*)str,\\r\\nstrlen(str))) {\\r\\nASN1_IA5STRING_free(ia5);\\r\\ngoto err;\\r\\n}\\r\\nreturn ia5;\\r\\nerr:\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc4_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nFILE *in=NULL,*out=NULL;\\r\\nchar *infile=NULL,*outfile=NULL,*keystr=NULL;\\r\\nRC4_KEY key;\\r\\nchar buf[BUFSIZ];\\r\\nint badops=0,i;\\r\\nchar **pp;\\r\\nunsigned char md[MD5_DIGEST_LENGTH];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-key\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\nkeystr= *(++argv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=usage; (*pp != NULL); pp++)\\r\\nfprintf(stderr,*pp);\\r\\nexit(1);\\r\\n}\\r\\nif (infile == NULL)\\r\\nin=stdin;\\r\\nelse\\r\\n{\\r\\nin=fopen(infile,\"r\");\\r\\nif (in == NULL)\\r\\n{\\r\\nperror(\"open\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nif (outfile == NULL)\\r\\nout=stdout;\\r\\nelse\\r\\n{\\r\\nout=fopen(outfile,\"w\");\\r\\nif (out == NULL)\\r\\n{\\r\\nperror(\"open\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\n#ifdef MSDOS\\r\\n{\\r\\n#include <fcntl.h>\\r\\nsetmode(fileno(in),O_BINARY);\\r\\nsetmode(fileno(out),O_BINARY);\\r\\n}\\r\\n#endif\\r\\nif (keystr == NULL)\\r\\n{\\r\\ni=EVP_read_pw_string(buf,BUFSIZ,\"Enter RC4 password:\",0);\\r\\nif (i != 0)\\r\\n{\\r\\nmemset(buf,0,BUFSIZ);\\r\\nfprintf(stderr,\"bad password read\\n\");\\r\\nexit(1);\\r\\n}\\r\\nkeystr=buf;\\r\\n}\\r\\nMD5((unsigned char *)keystr,(unsigned long)strlen(keystr),md);\\r\\nmemset(keystr,0,strlen(keystr));\\r\\nRC4_set_key(&key,MD5_DIGEST_LENGTH,md);\\r\\nfor(;;)\\r\\n{\\r\\ni=fread(buf,1,BUFSIZ,in);\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\nRC4(&key,(unsigned int)i,(unsigned char *)buf,\\r\\n(unsigned char *)buf);\\r\\ni=fwrite(buf,(unsigned int)i,1,out);\\r\\nif (i != 1)\\r\\n{\\r\\nperror(\"write\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nfclose(out);\\r\\nfclose(in);\\r\\nexit(0);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_spkigen_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nRSA *rsa=NULL;\\r\\nNETSCAPE_SPKI *spki=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\nchar buf[128];\\r\\nint ok=0,i;\\r\\nFILE *fp;\\r\\npkey=EVP_PKEY_new();\\r\\nif (argc < 2)\\r\\n{\\r\\nfprintf(stderr,\"generating RSA key, could take some time...\\n\");\\r\\nif ((rsa=RSA_generate_key(512,RSA_F4,NULL)) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif ((fp=fopen(argv[1],\"r\")) == NULL)\\r\\n{ perror(argv[1]); goto err; }\\r\\nif ((rsa=PEM_read_RSAPrivateKey(fp,NULL,NULL)) == NULL)\\r\\ngoto err;\\r\\nfclose(fp);\\r\\n}\\r\\nif (!EVP_PKEY_assign_RSA(pkey,rsa)) goto err;\\r\\nrsa=NULL;\\r\\nif ((spki=NETSCAPE_SPKI_new()) == NULL) goto err;\\r\\nif (!SPKI_set_pubkey(spki,pkey)) goto err;\\r\\nfprintf(stderr,\"please enter challenge string:\");\\r\\nfflush(stderr);\\r\\nfgets(buf,120,stdin);\\r\\ni=strlen(buf);\\r\\nif (i > 0) buf[--i]='\\0';\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)spki->spkac->challenge,\\r\\nbuf,i)) goto err;\\r\\nif (!NETSCAPE_SPKI_sign(spki,pkey,EVP_md5())) goto err;\\r\\nPEM_write_SPKI(stdout,spki);\\r\\nif (argc < 2)\\r\\nPEM_write_RSAPrivateKey(stdout,pkey->pkey.rsa,NULL,NULL,0,NULL);\\r\\nok=1;\\r\\nerr:\\r\\nif (!ok)\\r\\n{\\r\\nfprintf(stderr,\"something bad happened....\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nNETSCAPE_SPKI_free(spki);\\r\\nEVP_PKEY_free(pkey);\\r\\nexit(!ok);\\r\\n}\\r\\nint EVP_PKEY_assign(pkey,type,key)\\r\\nEVP_PKEY *pkey;\\r\\nint type;\\r\\nchar *key;\\r\\n{\\r\\nif (pkey == NULL) return(0);\\r\\nif (pkey->pkey.ptr != NULL)\\r\\n{\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nRSA_free(pkey->pkey.rsa);\\r\\n}\\r\\npkey->type=type;\\r\\npkey->pkey.ptr=key;\\r\\nreturn(1);\\r\\n}\\r\\nint SPKI_set_pubkey(x,pkey)\\r\\nNETSCAPE_SPKI *x;\\r\\nEVP_PKEY *pkey;\\r\\n{\\r\\nint ok=0;\\r\\nX509_PUBKEY *pk;\\r\\nX509_ALGOR *a;\\r\\nASN1_OBJECT *o;\\r\\nunsigned char *s,*p;\\r\\nint i;\\r\\nif (x == NULL) return(0);\\r\\nif ((pk=X509_PUBKEY_new()) == NULL) goto err;\\r\\na=pk->algor;\\r\\nif ((o=OBJ_nid2obj(pkey->type)) == NULL) goto err;\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=o;\\r\\nif ((a->parameter == NULL) || (a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter=ASN1_TYPE_new();\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\ni=i2d_PublicKey(pkey,NULL);\\r\\nif ((s=(unsigned char *)malloc(i+1)) == NULL) goto err;\\r\\np=s;\\r\\ni2d_PublicKey(pkey,&p);\\r\\nif (!ASN1_BIT_STRING_set(pk->public_key,s,i)) goto err;\\r\\nfree(s);\\r\\nX509_PUBKEY_free(x->spkac->pubkey);\\r\\nx->spkac->pubkey=pk;\\r\\npk=NULL;\\r\\nok=1;\\r\\nerr:\\r\\nif (pk != NULL) X509_PUBKEY_free(pk);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_sxnet_c", "target": 0, "func": "int i2d_SXNET(SXNET *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len_SEQUENCE_type (SXNETID, a->ids, i2d_SXNETID);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->version, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put_SEQUENCE_type (SXNETID, a->ids, i2d_SXNETID);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nSXNET *SXNET_new(void)\\r\\n{\\r\\nSXNET *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, SXNET);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->ids,sk_SXNETID_new_null);\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_SXNET_NEW);\\r\\n}\\r\\nSXNET *d2i_SXNET(SXNET **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,SXNET *,SXNET_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->version, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_seq_type (SXNETID, ret->ids, d2i_SXNETID, SXNETID_free);\\r\\nM_ASN1_D2I_Finish(a, SXNET_free, ASN1_F_D2I_SXNET);\\r\\n}\\r\\nvoid SXNET_free(SXNET *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nsk_SXNETID_pop_free(a->ids, SXNETID_free);\\r\\nFree (a);\\r\\n}\\r\\nint i2d_SXNETID(SXNETID *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len (a->zone, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len (a->user, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put (a->zone, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put (a->user, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nSXNETID *SXNETID_new(void)\\r\\n{\\r\\nSXNETID *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, SXNETID);\\r\\nret->zone = NULL;\\r\\nM_ASN1_New(ret->user,ASN1_OCTET_STRING_new);\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_SXNETID_NEW);\\r\\n}\\r\\nSXNETID *d2i_SXNETID(SXNETID **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,SXNETID *,SXNETID_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->zone, d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get(ret->user, d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a, SXNETID_free, ASN1_F_D2I_SXNETID);\\r\\n}\\r\\nvoid SXNETID_free(SXNETID *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->zone);\\r\\nASN1_OCTET_STRING_free(a->user);\\r\\nFree (a);\\r\\n}\\r\\nstatic int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,\\r\\nint indent)\\r\\n{\\r\\nlong v;\\r\\nchar *tmp;\\r\\nSXNETID *id;\\r\\nint i;\\r\\nv = ASN1_INTEGER_get(sx->version);\\r\\nBIO_printf(out, \"%*sVersion: %d (0x%X)\", indent, \"\", v + 1, v);\\r\\nfor(i = 0; i < sk_SXNETID_num(sx->ids); i++) {\\r\\nid = sk_SXNETID_value(sx->ids, i);\\r\\ntmp = i2s_ASN1_INTEGER(NULL, id->zone);\\r\\nBIO_printf(out, \"\\n%*sZone: %s, User: \", indent, \"\", tmp);\\r\\nFree(tmp);\\r\\nASN1_OCTET_STRING_print(out, id->user);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SXNET_add_id_asc(SXNET **psx, char *zone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif(!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ASC,X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif(!(izone = ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_ULONG,ERR_R_MALLOC_FAILURE);\\r\\nASN1_INTEGER_free(izone);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nSXNET *sx = NULL;\\r\\nSXNETID *id = NULL;\\r\\nif(!psx || !zone || !user) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif(userlen == -1) userlen = strlen(user);\\r\\nif(userlen > 64) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_USER_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif(!*psx) {\\r\\nif(!(sx = SXNET_new())) goto err;\\r\\nif(!ASN1_INTEGER_set(sx->version, 0)) goto err;\\r\\n*psx = sx;\\r\\n} else sx = *psx;\\r\\nif(SXNET_get_id_INTEGER(sx, zone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,X509V3_R_DUPLICATE_ZONE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nif(!(id = SXNETID_new())) goto err;\\r\\nif(userlen == -1) userlen = strlen(user);\\r\\nif(!ASN1_OCTET_STRING_set(id->user, user, userlen)) goto err;\\r\\nif(!sk_SXNETID_push(sx->ids, id)) goto err;\\r\\nid->zone = zone;\\r\\nreturn 1;\\r\\nerr:\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,ERR_R_MALLOC_FAILURE);\\r\\nSXNETID_free(id);\\r\\nSXNET_free(sx);\\r\\n*psx = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, char *zone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif(!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ASC,X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif(!(izone = ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ULONG,ERR_R_MALLOC_FAILURE);\\r\\nASN1_INTEGER_free(izone);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)\\r\\n{\\r\\nSXNETID *id;\\r\\nint i;\\r\\nfor(i = 0; i < sk_SXNETID_num(sx->ids); i++) {\\r\\nid = sk_SXNETID_value(sx->ids, i);\\r\\nif(!ASN1_INTEGER_cmp(id->zone, zone)) return id->user;\\r\\n}\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc4_skey_c", "target": 0, "func": "const char *RC4_options(void)\\r\\n{\\r\\n#ifdef RC4_INDEX\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn(\"rc4(idx,char)\");\\r\\nelse\\r\\nreturn(\"rc4(idx,int)\");\\r\\n#else\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn(\"rc4(ptr,char)\");\\r\\nelse\\r\\nreturn(\"rc4(ptr,int)\");\\r\\n#endif\\r\\n}\\r\\nvoid RC4_set_key(RC4_KEY *key, int len, register unsigned char *data)\\r\\n{\\r\\nregister RC4_INT tmp;\\r\\nregister int id1,id2;\\r\\nregister RC4_INT *d;\\r\\nunsigned int i;\\r\\nd= &(key->data[0]);\\r\\nfor (i=0; i<256; i++)\\r\\nd[i]=i;\\r\\nkey->x = 0;\\r\\nkey->y = 0;\\r\\nid1=id2=0;\\r\\n#define SK_LOOP(n) { \\\\r\\ntmp=d[(n)]; \\\\r\\nid2 = (data[id1] + tmp + id2) & 0xff; \\\\r\\nif (++id1 == len) id1=0; \\\\r\\nd[(n)]=d[id2]; \\\\r\\nd[id2]=tmp; }\\r\\nfor (i=0; i < 256; i+=4)\\r\\n{\\r\\nSK_LOOP(i+0);\\r\\nSK_LOOP(i+1);\\r\\nSK_LOOP(i+2);\\r\\nSK_LOOP(i+3);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sconnect_c", "target": 0, "func": "int main(argc,argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *host;\\r\\nBIO *out;\\r\\nchar buf[1024*10],*p;\\r\\nSSL_CTX *ssl_ctx=NULL;\\r\\nSSL *ssl;\\r\\nBIO *ssl_bio;\\r\\nint i,len,off,ret=1;\\r\\nif (argc <= 1)\\r\\nhost=\"localhost:4433\";\\r\\nelse\\r\\nhost=argv[1];\\r\\nSSL_load_error_strings();\\r\\nSSLeay_add_ssl_algorithms();\\r\\nssl_ctx=SSL_CTX_new(SSLv23_client_method());\\r\\nssl=SSL_new(ssl_ctx);\\r\\nSSL_set_connect_state(ssl);\\r\\nssl_bio=BIO_new(BIO_f_ssl());\\r\\nBIO_set_ssl(ssl_bio,ssl,BIO_CLOSE);\\r\\nout=BIO_new(BIO_s_connect());\\r\\nBIO_set_conn_hostname(out,host);\\r\\nBIO_set_nbio(out,1);\\r\\nout=BIO_push(ssl_bio,out);\\r\\np=\"GET / HTTP/1.0\\r\\n\\r\\n\";\\r\\nlen=strlen(p);\\r\\noff=0;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_write(out,&(p[off]),len);\\r\\nif (i <= 0)\\r\\n{\\r\\nif (BIO_should_retry(out))\\r\\n{\\r\\nfprintf(stderr,\"write DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\nelse\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\noff+=i;\\r\\nlen-=i;\\r\\nif (len <= 0) break;\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(out,buf,sizeof(buf));\\r\\nif (i == 0) break;\\r\\nif (i < 0)\\r\\n{\\r\\nif (BIO_should_retry(out))\\r\\n{\\r\\nfprintf(stderr,\"read DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf,1,i,stdout);\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nerr:\\r\\nif (ERR_peek_error() == 0)\\r\\n{\\r\\nfprintf(stderr,\"errno=%d \",errno);\\r\\nperror(\"error\");\\r\\n}\\r\\nelse\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nBIO_free_all(out);\\r\\nif (ssl_ctx != NULL) SSL_CTX_free(ssl_ctx);\\r\\nexit(!ret);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_print_c", "target": 1, "func": "char *BN_bn2hex(const BIGNUM *a)\\r\\n{\\r\\nint i,j,v,z=0;\\r\\nchar *buf;\\r\\nchar *p;\\r\\nbuf=(char *)Malloc(a->top*BN_BYTES*2+2);\\r\\nif (buf == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_BN2HEX,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np=buf;\\r\\nif (a->neg) *(p++)='-';\\r\\nif (a->top == 0) *(p++)='0';\\r\\nfor (i=a->top-1; i >=0; i--)\\r\\n{\\r\\nfor (j=BN_BITS2-8; j >= 0; j-=8)\\r\\n{\\r\\nv=((int)(a->d[i]>>(long)j))&0xff;\\r\\nif (z || (v != 0))\\r\\n{\\r\\n*(p++)=Hex[v>>4];\\r\\n*(p++)=Hex[v&0x0f];\\r\\nz=1;\\r\\n}\\r\\n}\\r\\n}\\r\\n*p='\\0';\\r\\nerr:\\r\\nreturn(buf);\\r\\n}\\r\\nchar *BN_bn2dec(const BIGNUM *a)\\r\\n{\\r\\nint i=0,num;\\r\\nchar *buf=NULL;\\r\\nchar *p;\\r\\nBIGNUM *t=NULL;\\r\\nBN_ULONG *bn_data=NULL,*lp;\\r\\ni=BN_num_bits(a)*3;\\r\\nnum=(i/10+i/1000+3)+1;\\r\\nbn_data=(BN_ULONG *)Malloc((num/BN_DEC_NUM+1)*sizeof(BN_ULONG));\\r\\nbuf=(char *)Malloc(num+3);\\r\\nif ((buf == NULL) || (bn_data == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BN2DEC,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((t=BN_dup(a)) == NULL) goto err;\\r\\np=buf;\\r\\nlp=bn_data;\\r\\nif (t->neg) *(p++)='-';\\r\\nif (t->top == 0)\\r\\n{\\r\\n*(p++)='0';\\r\\n*(p++)='\\0';\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=0;\\r\\nwhile (!BN_is_zero(t))\\r\\n{\\r\\n*lp=BN_div_word(t,BN_DEC_CONV);\\r\\nlp++;\\r\\n}\\r\\nlp--;\\r\\nsprintf(p,BN_DEC_FMT1,*lp);\\r\\nwhile (*p) p++;\\r\\nwhile (lp != bn_data)\\r\\n{\\r\\nlp--;\\r\\nsprintf(p,BN_DEC_FMT2,*lp);\\r\\nwhile (*p) p++;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (bn_data != NULL) Free(bn_data);\\r\\nif (t != NULL) BN_free(t);\\r\\nreturn(buf);\\r\\n}\\r\\nint BN_hex2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret=NULL;\\r\\nBN_ULONG l=0;\\r\\nint neg=0,h,m,i,j,k,c;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0')) return(0);\\r\\nif (*a == '-') { neg=1; a++; }\\r\\nfor (i=0; isxdigit((unsigned char) a[i]); i++)\\r\\n;\\r\\nnum=i+neg;\\r\\nif (bn == NULL) return(num);\\r\\nif (*bn == NULL)\\r\\n{\\r\\nif ((ret=BN_new()) == NULL) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret,i*4) == NULL) goto err;\\r\\nj=i;\\r\\nm=0;\\r\\nh=0;\\r\\nwhile (j > 0)\\r\\n{\\r\\nm=((BN_BYTES*2) <= j)?(BN_BYTES*2):j;\\r\\nl=0;\\r\\nfor (;;)\\r\\n{\\r\\nc=a[j-m];\\r\\nif ((c >= '0') && (c <= '9')) k=c-'0';\\r\\nelse if ((c >= 'a') && (c <= 'f')) k=c-'a'+10;\\r\\nelse if ((c >= 'A') && (c <= 'F')) k=c-'A'+10;\\r\\nelse k=0;\\r\\nl=(l<<4)|k;\\r\\nif (--m <= 0)\\r\\n{\\r\\nret->d[h++]=l;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nj-=(BN_BYTES*2);\\r\\n}\\r\\nret->top=h;\\r\\nbn_fix_top(ret);\\r\\nret->neg=neg;\\r\\n*bn=ret;\\r\\nreturn(num);\\r\\nerr:\\r\\nif (*bn == NULL) BN_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint BN_dec2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret=NULL;\\r\\nBN_ULONG l=0;\\r\\nint neg=0,i,j;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0')) return(0);\\r\\nif (*a == '-') { neg=1; a++; }\\r\\nfor (i=0; isdigit((unsigned char) a[i]); i++)\\r\\n;\\r\\nnum=i+neg;\\r\\nif (bn == NULL) return(num);\\r\\nif (*bn == NULL)\\r\\n{\\r\\nif ((ret=BN_new()) == NULL) return(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret= *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret,i*4) == NULL) goto err;\\r\\nj=BN_DEC_NUM-(i%BN_DEC_NUM);\\r\\nif (j == BN_DEC_NUM) j=0;\\r\\nl=0;\\r\\nwhile (*a)\\r\\n{\\r\\nl*=10;\\r\\nl+= *a-'0';\\r\\na++;\\r\\nif (++j == BN_DEC_NUM)\\r\\n{\\r\\nBN_mul_word(ret,BN_DEC_CONV);\\r\\nBN_add_word(ret,l);\\r\\nl=0;\\r\\nj=0;\\r\\n}\\r\\n}\\r\\nret->neg=neg;\\r\\nbn_fix_top(ret);\\r\\n*bn=ret;\\r\\nreturn(num);\\r\\nerr:\\r\\nif (*bn == NULL) BN_free(ret);\\r\\nreturn(0);\\r\\n}\\r\\nint BN_print_fp(FILE *fp, BIGNUM *a)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\nreturn(0);\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=BN_print(b,a);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_print(BIO *bp, const BIGNUM *a)\\r\\n{\\r\\nint i,j,v,z=0;\\r\\nint ret=0;\\r\\nif ((a->neg) && (BIO_write(bp,\"-\",1) != 1)) goto end;\\r\\nif ((a->top == 0) && (BIO_write(bp,\"0\",1) != 1)) goto end;\\r\\nfor (i=a->top-1; i >=0; i--)\\r\\n{\\r\\nfor (j=BN_BITS2-4; j >= 0; j-=4)\\r\\n{\\r\\nv=((int)(a->d[i]>>(long)j))&0x0f;\\r\\nif (z || (v != 0))\\r\\n{\\r\\nif (BIO_write(bp,&(Hex[v]),1) != 1)\\r\\ngoto end;\\r\\nz=1;\\r\\n}\\r\\n}\\r\\n}\\r\\nret=1;\\r\\nend:\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_vrf_c", "target": 0, "func": "int DSA_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,\\r\\nDSA *dsa)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM u1,u2,t1;\\r\\nBN_MONT_CTX *mont=NULL;\\r\\nint ret = -1;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nBN_init(&u1);\\r\\nBN_init(&u2);\\r\\nBN_init(&t1);\\r\\nif ((BN_mod_inverse(&u2,sig->s,dsa->q,ctx)) == NULL) goto err;\\r\\nif (BN_bin2bn(dgst,dgst_len,&u1) == NULL) goto err;\\r\\nif (!BN_mod_mul(&u1,&u1,&u2,dsa->q,ctx)) goto err;\\r\\nif (!BN_mod_mul(&u2,sig->r,&u2,dsa->q,ctx)) goto err;\\r\\nif ((dsa->method_mont_p == NULL) && (dsa->flags & DSA_FLAG_CACHE_MONT_P))\\r\\n{\\r\\nif ((dsa->method_mont_p=(char *)BN_MONT_CTX_new()) != NULL)\\r\\nif (!BN_MONT_CTX_set((BN_MONT_CTX *)dsa->method_mont_p,\\r\\ndsa->p,ctx)) goto err;\\r\\n}\\r\\nmont=(BN_MONT_CTX *)dsa->method_mont_p;\\r\\n#if 0\\r\\n{\\r\\nBIGNUM t2;\\r\\nBN_init(&t2);\\r\\nif (!BN_mod_exp_mont(&t1,dsa->g,&u1,dsa->p,ctx,mont)) goto err;\\r\\nif (!BN_mod_exp_mont(&t2,dsa->pub_key,&u2,dsa->p,ctx,mont)) goto err;\\r\\nif (!BN_mod_mul(&u1,&t1,&t2,dsa->p,ctx)) goto err_bn;\\r\\nBN_free(&t2);\\r\\n}\\r\\nif (!BN_mod(&u1,&u1,dsa->q,ctx)) goto err;\\r\\n#else\\r\\n{\\r\\nif (!BN_mod_exp2_mont(&t1,dsa->g,&u1,dsa->pub_key,&u2,dsa->p,ctx,mont))\\r\\ngoto err;\\r\\nif (!BN_mod(&u1,&t1,dsa->q,ctx)) goto err;\\r\\n}\\r\\n#endif\\r\\nret=(BN_ucmp(&u1, sig->r) == 0);\\r\\nerr:\\r\\nif (ret != 1) DSAerr(DSA_F_DSA_DO_VERIFY,ERR_R_BN_LIB);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nBN_free(&u1);\\r\\nBN_free(&u2);\\r\\nBN_free(&t1);\\r\\nreturn(ret);\\r\\n}\\r\\nint DSA_verify(int type, const unsigned char *dgst, int dgst_len,\\r\\nunsigned char *sigbuf, int siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\nint ret=-1;\\r\\ns = DSA_SIG_new();\\r\\nif (s == NULL) return(ret);\\r\\nif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\\r\\nret=DSA_do_verify(dgst,dgst_len,s,dsa);\\r\\nerr:\\r\\nDSA_SIG_free(s);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cversion_c", "target": 0, "func": "const char *SSLeay_version(int t)\\r\\n{\\r\\nif (t == SSLEAY_VERSION)\\r\\nreturn OPENSSL_VERSION_TEXT;\\r\\nif (t == SSLEAY_BUILT_ON)\\r\\n{\\r\\n#ifdef DATE\\r\\nstatic char buf[sizeof(DATE)+11];\\r\\nsprintf(buf,\"built on: %s\",DATE);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"built on: date not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_CFLAGS)\\r\\n{\\r\\n#ifdef CFLAGS\\r\\nstatic char buf[sizeof(CFLAGS)+11];\\r\\nsprintf(buf,\"compiler: %s\",CFLAGS);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"compiler: information not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_PLATFORM)\\r\\n{\\r\\n#ifdef PLATFORM\\r\\nstatic char buf[sizeof(PLATFORM)+11];\\r\\nsprintf(buf,\"platform: %s\", PLATFORM);\\r\\nreturn(buf);\\r\\n#else\\r\\nreturn(\"platform: information not available\");\\r\\n#endif\\r\\n}\\r\\nreturn(\"not available\");\\r\\n}\\r\\nunsigned long SSLeay(void)\\r\\n{\\r\\nreturn(SSLEAY_VERSION_NUMBER);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_xcbc_enc_c", "target": 0, "func": "void des_xwhite_in2out(const_des_cblock *des_key, const_des_cblock *in_white,\\r\\ndes_cblock *out_white)\\r\\n{\\r\\nint out0,out1;\\r\\nint i;\\r\\nconst unsigned char *key = &(*des_key)[0];\\r\\nconst unsigned char *in = &(*in_white)[0];\\r\\nunsigned char *out = &(*out_white)[0];\\r\\nout[0]=out[1]=out[2]=out[3]=out[4]=out[5]=out[6]=out[7]=0;\\r\\nout0=out1=0;\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nout[i]=key[i]^desx_white_in2out[out0^out1];\\r\\nout0=out1;\\r\\nout1=(int)out[i&0x07];\\r\\n}\\r\\nout0=out[0];\\r\\nout1=out[i];\\r\\nfor (i=0; i<8; i++)\\r\\n{\\r\\nout[i]=in[i]^desx_white_in2out[out0^out1];\\r\\nout0=out1;\\r\\nout1=(int)out[i&0x07];\\r\\n}\\r\\n}\\r\\nvoid des_xcbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, des_key_schedule schedule, des_cblock *ivec,\\r\\nconst_des_cblock *inw, const_des_cblock *outw, int enc)\\r\\n{\\r\\nregister DES_LONG tin0,tin1;\\r\\nregister DES_LONG tout0,tout1,xor0,xor1;\\r\\nregister DES_LONG inW0,inW1,outW0,outW1;\\r\\nregister const unsigned char *in2;\\r\\nregister long l=length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin2 = &(*inw)[0];\\r\\nc2l(in2,inW0);\\r\\nc2l(in2,inW1);\\r\\nin2 = &(*outw)[0];\\r\\nc2l(in2,outW0);\\r\\nc2l(in2,outW1);\\r\\niv = &(*ivec)[0];\\r\\nif (enc)\\r\\n{\\r\\nc2l(iv,tout0);\\r\\nc2l(iv,tout1);\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nc2l(in,tin0);\\r\\nc2l(in,tin1);\\r\\ntin0^=tout0^inW0; tin[0]=tin0;\\r\\ntin1^=tout1^inW1; tin[1]=tin1;\\r\\ndes_encrypt(tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0]^outW0; l2c(tout0,out);\\r\\ntout1=tin[1]^outW1; l2c(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0^inW0; tin[0]=tin0;\\r\\ntin1^=tout1^inW1; tin[1]=tin1;\\r\\ndes_encrypt(tin,schedule,DES_ENCRYPT);\\r\\ntout0=tin[0]^outW0; l2c(tout0,out);\\r\\ntout1=tin[1]^outW1; l2c(tout1,out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0,iv);\\r\\nl2c(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nc2l(iv,xor0);\\r\\nc2l(iv,xor1);\\r\\nfor (l-=8; l>0; l-=8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0^outW0;\\r\\nc2l(in,tin1); tin[1]=tin1^outW1;\\r\\ndes_encrypt(tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0^inW0;\\r\\ntout1=tin[1]^xor1^inW1;\\r\\nl2c(tout0,out);\\r\\nl2c(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nc2l(in,tin0); tin[0]=tin0^outW0;\\r\\nc2l(in,tin1); tin[1]=tin1^outW1;\\r\\ndes_encrypt(tin,schedule,DES_DECRYPT);\\r\\ntout0=tin[0]^xor0^inW0;\\r\\ntout1=tin[1]^xor1^inW1;\\r\\nl2cn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0,iv);\\r\\nl2c(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ninW0=inW1=outW0=outW1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_pubkey_c", "target": 0, "func": "int i2d_X509_PUBKEY(X509_PUBKEY *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->public_key, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->public_key, i2d_ASN1_BIT_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_PUBKEY *d2i_X509_PUBKEY(X509_PUBKEY **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_PUBKEY *,X509_PUBKEY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->public_key,d2i_ASN1_BIT_STRING);\\r\\nif (ret->pkey != NULL)\\r\\n{\\r\\nEVP_PKEY_free(ret->pkey);\\r\\nret->pkey=NULL;\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_PUBKEY_free,ASN1_F_D2I_X509_PUBKEY);\\r\\n}\\r\\nX509_PUBKEY *X509_PUBKEY_new(void)\\r\\n{\\r\\nX509_PUBKEY *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_PUBKEY);\\r\\nM_ASN1_New(ret->algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->public_key,ASN1_BIT_STRING_new);\\r\\nret->pkey=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_PUBKEY_NEW);\\r\\n}\\r\\nvoid X509_PUBKEY_free(X509_PUBKEY *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_ALGOR_free(a->algor);\\r\\nASN1_BIT_STRING_free(a->public_key);\\r\\nif (a->pkey != NULL) EVP_PKEY_free(a->pkey);\\r\\nFree((char *)a);\\r\\n}\\r\\nint X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)\\r\\n{\\r\\nint ok=0;\\r\\nX509_PUBKEY *pk;\\r\\nX509_ALGOR *a;\\r\\nASN1_OBJECT *o;\\r\\nunsigned char *s,*p;\\r\\nint i;\\r\\nif (x == NULL) return(0);\\r\\nif ((pk=X509_PUBKEY_new()) == NULL) goto err;\\r\\na=pk->algor;\\r\\nif ((o=OBJ_nid2obj(pkey->type)) == NULL) goto err;\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm=o;\\r\\nif (!pkey->save_parameters || (pkey->type == EVP_PKEY_RSA))\\r\\n{\\r\\nif ((a->parameter == NULL) ||\\r\\n(a->parameter->type != V_ASN1_NULL))\\r\\n{\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter=ASN1_TYPE_new();\\r\\na->parameter->type=V_ASN1_NULL;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nunsigned char *pp;\\r\\nDSA *dsa;\\r\\ndsa=pkey->pkey.dsa;\\r\\ndsa->write_params=0;\\r\\nASN1_TYPE_free(a->parameter);\\r\\ni=i2d_DSAparams(dsa,NULL);\\r\\np=(unsigned char *)Malloc(i);\\r\\npp=p;\\r\\ni2d_DSAparams(dsa,&pp);\\r\\na->parameter=ASN1_TYPE_new();\\r\\na->parameter->type=V_ASN1_SEQUENCE;\\r\\na->parameter->value.sequence=ASN1_STRING_new();\\r\\nASN1_STRING_set(a->parameter->value.sequence,p,i);\\r\\nFree(p);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nX509err(X509_F_X509_PUBKEY_SET,X509_R_UNSUPPORTED_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif ((i=i2d_PublicKey(pkey,NULL)) <= 0) goto err;\\r\\nif ((s=(unsigned char *)Malloc(i+1)) == NULL) goto err;\\r\\np=s;\\r\\ni2d_PublicKey(pkey,&p);\\r\\nif (!ASN1_BIT_STRING_set(pk->public_key,s,i)) goto err;\\r\\npk->public_key->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\\r\\npk->public_key->flags|=ASN1_STRING_FLAG_BITS_LEFT;\\r\\nFree(s);\\r\\nCRYPTO_add(&pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\npk->pkey=pkey;\\r\\nif (*x != NULL)\\r\\nX509_PUBKEY_free(*x);\\r\\n*x=pk;\\r\\npk=NULL;\\r\\nok=1;\\r\\nerr:\\r\\nif (pk != NULL) X509_PUBKEY_free(pk);\\r\\nreturn(ok);\\r\\n}\\r\\nEVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key)\\r\\n{\\r\\nEVP_PKEY *ret=NULL;\\r\\nlong j;\\r\\nint type;\\r\\nunsigned char *p;\\r\\n#ifndef NO_DSA\\r\\nX509_ALGOR *a;\\r\\n#endif\\r\\nif (key == NULL) goto err;\\r\\nif (key->pkey != NULL)\\r\\n{\\r\\nCRYPTO_add(&key->pkey->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\nreturn(key->pkey);\\r\\n}\\r\\nif (key->public_key == NULL) goto err;\\r\\ntype=OBJ_obj2nid(key->algor->algorithm);\\r\\np=key->public_key->data;\\r\\nj=key->public_key->length;\\r\\nif ((ret=d2i_PublicKey(type,NULL,&p,(long)j)) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_PUBKEY_GET,X509_R_ERR_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->save_parameters=0;\\r\\n#ifndef NO_DSA\\r\\na=key->algor;\\r\\nif (ret->type == EVP_PKEY_DSA)\\r\\n{\\r\\nif (a->parameter->type == V_ASN1_SEQUENCE)\\r\\n{\\r\\nret->pkey.dsa->write_params=0;\\r\\np=a->parameter->value.sequence->data;\\r\\nj=a->parameter->value.sequence->length;\\r\\nif (!d2i_DSAparams(&ret->pkey.dsa,&p,(long)j))\\r\\ngoto err;\\r\\n}\\r\\nret->save_parameters=1;\\r\\n}\\r\\n#endif\\r\\nkey->pkey=ret;\\r\\nCRYPTO_add(&ret->references,1,CRYPTO_LOCK_EVP_PKEY);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nEVP_PKEY_free(ret);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s_cb_c", "target": 0, "func": "int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nchar buf[256];\\r\\nX509 *err_cert;\\r\\nint err,depth;\\r\\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr= X509_STORE_CTX_get_error(ctx);\\r\\ndepth= X509_STORE_CTX_get_error_depth(ctx);\\r\\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);\\r\\nBIO_printf(bio_err,\"depth=%d %s\\n\",depth,buf);\\r\\nif (!ok)\\r\\n{\\r\\nBIO_printf(bio_err,\"verify error:num=%d:%s\\n\",err,\\r\\nX509_verify_cert_error_string(err));\\r\\nif (verify_depth >= depth)\\r\\n{\\r\\nok=1;\\r\\nverify_error=X509_V_OK;\\r\\n}\\r\\nelse\\r\\n{\\r\\nok=0;\\r\\nverify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG;\\r\\n}\\r\\n}\\r\\nswitch (ctx->error)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256);\\r\\nBIO_printf(bio_err,\"issuer= %s\\n\",buf);\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nBIO_printf(bio_err,\"notBefore=\");\\r\\nASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nBIO_printf(bio_err,\"notAfter=\");\\r\\nASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));\\r\\nBIO_printf(bio_err,\"\\n\");\\r\\nbreak;\\r\\n}\\r\\nBIO_printf(bio_err,\"verify return:%d\\n\",ok);\\r\\nreturn(ok);\\r\\n}\\r\\nint set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)\\r\\n{\\r\\nif (cert_file != NULL)\\r\\n{\\r\\nif (SSL_CTX_use_certificate_file(ctx,cert_file,\\r\\nSSL_FILETYPE_PEM) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get certificate from '%s'\\n\",cert_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nif (key_file == NULL) key_file=cert_file;\\r\\nif (SSL_CTX_use_PrivateKey_file(ctx,key_file,\\r\\nSSL_FILETYPE_PEM) <= 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to get private key from '%s'\\n\",key_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn(0);\\r\\n}\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\n{\\r\\nBIO_printf(bio_err,\"Private key does not match the certificate public key\\n\");\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nlong MS_CALLBACK bio_dump_cb(BIO *bio, int cmd, const char *argp, int argi,\\r\\nlong argl, long ret)\\r\\n{\\r\\nBIO *out;\\r\\nout=(BIO *)BIO_get_callback_arg(bio);\\r\\nif (out == NULL) return(ret);\\r\\nif (cmd == (BIO_CB_READ|BIO_CB_RETURN))\\r\\n{\\r\\nBIO_printf(out,\"read from %08X [%08lX] (%d bytes => %ld (0x%X))\\n\",\\r\\nbio,argp,argi,ret,ret);\\r\\nBIO_dump(out,argp,(int)ret);\\r\\nreturn(ret);\\r\\n}\\r\\nelse if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))\\r\\n{\\r\\nBIO_printf(out,\"write to %08X [%08lX] (%d bytes => %ld (0x%X))\\n\",\\r\\nbio,argp,argi,ret,ret);\\r\\nBIO_dump(out,argp,(int)ret);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid MS_CALLBACK apps_ssl_info_callback(SSL *s, int where, int ret)\\r\\n{\\r\\nchar *str;\\r\\nint w;\\r\\nw=where& ~SSL_ST_MASK;\\r\\nif (w & SSL_ST_CONNECT) str=\"SSL_connect\";\\r\\nelse if (w & SSL_ST_ACCEPT) str=\"SSL_accept\";\\r\\nelse str=\"undefined\";\\r\\nif (where & SSL_CB_LOOP)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s:%s\\n\",str,SSL_state_string_long(s));\\r\\n}\\r\\nelse if (where & SSL_CB_ALERT)\\r\\n{\\r\\nstr=(where & SSL_CB_READ)?\"read\":\"write\";\\r\\nBIO_printf(bio_err,\"SSL3 alert %s:%s:%s\\n\",\\r\\nstr,\\r\\nSSL_alert_type_string_long(ret),\\r\\nSSL_alert_desc_string_long(ret));\\r\\n}\\r\\nelse if (where & SSL_CB_EXIT)\\r\\n{\\r\\nif (ret == 0)\\r\\nBIO_printf(bio_err,\"%s:failed in %s\\n\",\\r\\nstr,SSL_state_string_long(s));\\r\\nelse if (ret < 0)\\r\\n{\\r\\nBIO_printf(bio_err,\"%s:error in %s\\n\",\\r\\nstr,SSL_state_string_long(s));\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ofb_bf_c", "target": 0, "func": "EVP_CIPHER *EVP_bf_ofb(void)\\r\\n{\\r\\nreturn(&bfish_ofb_cipher);\\r\\n}\\r\\nstatic void bf_ofb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nBF_set_key(&(ctx->c.bf_ks),EVP_BLOWFISH_KEY_SIZE,key);\\r\\n}\\r\\nstatic void bf_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nBF_ofb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.bf_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i_ofb64_c", "target": 0, "func": "void idea_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nIDEA_KEY_SCHEDULE *schedule, unsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nidea_encrypt((unsigned long *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_obj_c", "target": 1, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint i;\\r\\nint n,lold,l,l1,l2,num,j,type;\\r\\nconst char *s;\\r\\nchar *p;\\r\\nunsigned char *q;\\r\\nBUF_MEM *b=NULL;\\r\\nstatic char hex[17]=\"0123456789ABCDEF\";\\r\\nint gs_doit[4];\\r\\nchar tmp_buf[80];\\r\\n#ifdef CHARSET_EBCDIC\\r\\nchar ebcdic_buf[1024];\\r\\n#endif\\r\\nif (buf == NULL)\\r\\n{\\r\\nif ((b=BUF_MEM_new()) == NULL) goto err;\\r\\nif (!BUF_MEM_grow(b,200)) goto err;\\r\\nb->data[0]='\\0';\\r\\nlen=200;\\r\\n}\\r\\nif (a == NULL)\\r\\n{\\r\\nif(b)\\r\\n{\\r\\nbuf=b->data;\\r\\nFree(b);\\r\\n}\\r\\nstrncpy(buf,\"NO X509_NAME\",len);\\r\\nreturn buf;\\r\\n}\\r\\nlen--;\\r\\nl=0;\\r\\nfor (i=0; i<sk_X509_NAME_ENTRY_num(a->entries); i++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(a->entries,i);\\r\\nn=OBJ_obj2nid(ne->object);\\r\\nif ((n == NID_undef) || ((s=OBJ_nid2sn(n)) == NULL))\\r\\n{\\r\\ni2t_ASN1_OBJECT(tmp_buf,sizeof(tmp_buf),ne->object);\\r\\ns=tmp_buf;\\r\\n}\\r\\nl1=strlen(s);\\r\\ntype=ne->value->type;\\r\\nnum=ne->value->length;\\r\\nq=ne->value->data;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nif (type == V_ASN1_GENERALSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING ||\\r\\ntype == V_ASN1_PRINTABLESTRING ||\\r\\ntype == V_ASN1_TELETEXSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING ||\\r\\ntype == V_ASN1_IA5STRING) {\\r\\nascii2ebcdic(ebcdic_buf, q,\\r\\n(num > sizeof ebcdic_buf)\\r\\n? sizeof ebcdic_buf : num);\\r\\nq=ebcdic_buf;\\r\\n}\\r\\n#endif\\r\\nif ((type == V_ASN1_GENERALSTRING) && ((num%4) == 0))\\r\\n{\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=0;\\r\\nfor (j=0; j<num; j++)\\r\\nif (q[j] != 0) gs_doit[j&3]=1;\\r\\nif (gs_doit[0]|gs_doit[1]|gs_doit[2])\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\\r\\nelse\\r\\n{\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=0;\\r\\ngs_doit[3]=1;\\r\\n}\\r\\n}\\r\\nelse\\r\\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\\r\\nfor (l2=j=0; j<num; j++)\\r\\n{\\r\\nif (!gs_doit[j&3]) continue;\\r\\nl2++;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ((q[j] < ' ') || (q[j] > '~')) l2+=3;\\r\\n#else\\r\\nif ((os_toascii[q[j]] < os_toascii[' ']) ||\\r\\n(os_toascii[q[j]] > os_toascii['~'])) l2+=3;\\r\\n#endif\\r\\n}\\r\\nlold=l;\\r\\nl+=1+l1+1+l2;\\r\\nif (b != NULL)\\r\\n{\\r\\nif (!BUF_MEM_grow(b,l+1)) goto err;\\r\\np= &(b->data[lold]);\\r\\n}\\r\\nelse if (l > len)\\r\\n{\\r\\nbreak;\\r\\n}\\r\\nelse\\r\\np= &(buf[lold]);\\r\\n*(p++)='/';\\r\\nmemcpy(p,s,(unsigned int)l1); p+=l1;\\r\\n*(p++)='=';\\r\\n#ifndef CHARSET_EBCDIC\\r\\nq=ne->value->data;\\r\\n#endif\\r\\nfor (j=0; j<num; j++)\\r\\n{\\r\\nif (!gs_doit[j&3]) continue;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nn=q[j];\\r\\nif ((n < ' ') || (n > '~'))\\r\\n{\\r\\n*(p++)='\\\\';\\r\\n*(p++)='x';\\r\\n*(p++)=hex[(n>>4)&0x0f];\\r\\n*(p++)=hex[n&0x0f];\\r\\n}\\r\\nelse\\r\\n*(p++)=n;\\r\\n#else\\r\\nn=os_toascii[q[j]];\\r\\nif ((n < os_toascii[' ']) ||\\r\\n(n > os_toascii['~']))\\r\\n{\\r\\n*(p++)='\\\\';\\r\\n*(p++)='x';\\r\\n*(p++)=hex[(n>>4)&0x0f];\\r\\n*(p++)=hex[n&0x0f];\\r\\n}\\r\\nelse\\r\\n*(p++)=q[j];\\r\\n#endif\\r\\n}\\r\\n*p='\\0';\\r\\n}\\r\\nif (b != NULL)\\r\\n{\\r\\np=b->data;\\r\\nFree(b);\\r\\n}\\r\\nelse\\r\\np=buf;\\r\\nreturn(p);\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);\\r\\nif (b != NULL) BUF_MEM_free(b);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_asn1_c", "target": 0, "func": "int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)\\r\\n{\\r\\n#define LSIZE2 (sizeof(long)*2)\\r\\nint v1=0,v2=0,v3=0,v4=0;\\r\\nunsigned char buf[4],ibuf1[LSIZE2],ibuf2[LSIZE2];\\r\\nunsigned char ibuf3[LSIZE2],ibuf4[LSIZE2];\\r\\nlong l;\\r\\nSSL_SESSION_ASN1 a;\\r\\nM_ASN1_I2D_vars(in);\\r\\nif ((in == NULL) || ((in->cipher == NULL) && (in->cipher_id == 0)))\\r\\nreturn(0);\\r\\na.version.length=LSIZE2;\\r\\na.version.type=V_ASN1_INTEGER;\\r\\na.version.data=ibuf1;\\r\\nASN1_INTEGER_set(&(a.version),SSL_SESSION_ASN1_VERSION);\\r\\na.ssl_version.length=LSIZE2;\\r\\na.ssl_version.type=V_ASN1_INTEGER;\\r\\na.ssl_version.data=ibuf2;\\r\\nASN1_INTEGER_set(&(a.ssl_version),in->ssl_version);\\r\\na.cipher.type=V_ASN1_OCTET_STRING;\\r\\na.cipher.data=buf;\\r\\nif (in->cipher == NULL)\\r\\nl=in->cipher_id;\\r\\nelse\\r\\nl=in->cipher->id;\\r\\nif (in->ssl_version == SSL2_VERSION)\\r\\n{\\r\\na.cipher.length=3;\\r\\nbuf[0]=((unsigned char)(l>>16L))&0xff;\\r\\nbuf[1]=((unsigned char)(l>> 8L))&0xff;\\r\\nbuf[2]=((unsigned char)(l ))&0xff;\\r\\n}\\r\\nelse\\r\\n{\\r\\na.cipher.length=2;\\r\\nbuf[0]=((unsigned char)(l>>8L))&0xff;\\r\\nbuf[1]=((unsigned char)(l ))&0xff;\\r\\n}\\r\\na.master_key.length=in->master_key_length;\\r\\na.master_key.type=V_ASN1_OCTET_STRING;\\r\\na.master_key.data=in->master_key;\\r\\na.session_id.length=in->session_id_length;\\r\\na.session_id.type=V_ASN1_OCTET_STRING;\\r\\na.session_id.data=in->session_id;\\r\\na.session_id_context.length=in->sid_ctx_length;\\r\\na.session_id_context.type=V_ASN1_OCTET_STRING;\\r\\na.session_id_context.data=in->sid_ctx;\\r\\na.key_arg.length=in->key_arg_length;\\r\\na.key_arg.type=V_ASN1_OCTET_STRING;\\r\\na.key_arg.data=in->key_arg;\\r\\nif (in->time != 0L)\\r\\n{\\r\\na.time.length=LSIZE2;\\r\\na.time.type=V_ASN1_INTEGER;\\r\\na.time.data=ibuf3;\\r\\nASN1_INTEGER_set(&(a.time),in->time);\\r\\n}\\r\\nif (in->timeout != 0L)\\r\\n{\\r\\na.timeout.length=LSIZE2;\\r\\na.timeout.type=V_ASN1_INTEGER;\\r\\na.timeout.data=ibuf4;\\r\\nASN1_INTEGER_set(&(a.timeout),in->timeout);\\r\\n}\\r\\nM_ASN1_I2D_len(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_len_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_len_EXP_opt(in->peer,i2d_X509,3,v3);\\r\\nM_ASN1_I2D_len_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,v4);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_put_IMP_opt(&(a.key_arg),i2d_ASN1_OCTET_STRING,0);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.time),i2d_ASN1_INTEGER,1,v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.timeout),i2d_ASN1_INTEGER,2,v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_put_EXP_opt(in->peer,i2d_X509,3,v3);\\r\\nM_ASN1_I2D_put_EXP_opt(&a.session_id_context,i2d_ASN1_OCTET_STRING,4,\\r\\nv4);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nSSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint version,ssl_version=0,i;\\r\\nlong id;\\r\\nASN1_INTEGER ai,*aip;\\r\\nASN1_OCTET_STRING os,*osp;\\r\\nM_ASN1_D2I_vars(a,SSL_SESSION *,SSL_SESSION_new);\\r\\naip= &ai;\\r\\nosp= &os;\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nai.data=NULL; ai.length=0;\\r\\nM_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);\\r\\nversion=(int)ASN1_INTEGER_get(aip);\\r\\nif (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }\\r\\nM_ASN1_D2I_get(aip,d2i_ASN1_INTEGER);\\r\\nssl_version=(int)ASN1_INTEGER_get(aip);\\r\\nret->ssl_version=ssl_version;\\r\\nif (ai.data != NULL) { Free(ai.data); ai.data=NULL; ai.length=0; }\\r\\nos.data=NULL; os.length=0;\\r\\nM_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);\\r\\nif (ssl_version == SSL2_VERSION)\\r\\n{\\r\\nif (os.length != 3)\\r\\n{\\r\\nc.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nid=0x02000000L|\\r\\n((unsigned long)os.data[0]<<16L)|\\r\\n((unsigned long)os.data[1]<< 8L)|\\r\\n(unsigned long)os.data[2];\\r\\n}\\r\\nelse if ((ssl_version>>8) == 3)\\r\\n{\\r\\nif (os.length != 2)\\r\\n{\\r\\nc.error=SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\ngoto err;\\r\\n}\\r\\nid=0x03000000L|\\r\\n((unsigned long)os.data[0]<<8L)|\\r\\n(unsigned long)os.data[1];\\r\\n}\\r\\nelse\\r\\n{\\r\\nSSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_UNKNOWN_SSL_VERSION);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->cipher=NULL;\\r\\nret->cipher_id=id;\\r\\nM_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);\\r\\nif ((ssl_version>>8) == SSL3_VERSION)\\r\\ni=SSL3_MAX_SSL_SESSION_ID_LENGTH;\\r\\nelse\\r\\ni=SSL2_MAX_SSL_SESSION_ID_LENGTH;\\r\\nif (os.length > i)\\r\\nos.length=i;\\r\\nret->session_id_length=os.length;\\r\\nmemcpy(ret->session_id,os.data,os.length);\\r\\nM_ASN1_D2I_get(osp,d2i_ASN1_OCTET_STRING);\\r\\nif (ret->master_key_length > SSL_MAX_MASTER_KEY_LENGTH)\\r\\nret->master_key_length=SSL_MAX_MASTER_KEY_LENGTH;\\r\\nelse\\r\\nret->master_key_length=os.length;\\r\\nmemcpy(ret->master_key,os.data,ret->master_key_length);\\r\\nos.length=0;\\r\\nM_ASN1_D2I_get_IMP_opt(osp,d2i_ASN1_OCTET_STRING,0,V_ASN1_OCTET_STRING);\\r\\nif (os.length > SSL_MAX_KEY_ARG_LENGTH)\\r\\nret->key_arg_length=SSL_MAX_KEY_ARG_LENGTH;\\r\\nelse\\r\\nret->key_arg_length=os.length;\\r\\nmemcpy(ret->key_arg,os.data,ret->key_arg_length);\\r\\nif (os.data != NULL) Free(os.data);\\r\\nai.length=0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,1);\\r\\nif (ai.data != NULL)\\r\\n{\\r\\nret->time=ASN1_INTEGER_get(aip);\\r\\nFree(ai.data); ai.data=NULL; ai.length=0;\\r\\n}\\r\\nelse\\r\\nret->time=time(NULL);\\r\\nai.length=0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip,d2i_ASN1_INTEGER,2);\\r\\nif (ai.data != NULL)\\r\\n{\\r\\nret->timeout=ASN1_INTEGER_get(aip);\\r\\nFree(ai.data); ai.data=NULL; ai.length=0;\\r\\n}\\r\\nelse\\r\\nret->timeout=3;\\r\\nif (ret->peer != NULL)\\r\\n{\\r\\nX509_free(ret->peer);\\r\\nret->peer=NULL;\\r\\n}\\r\\nM_ASN1_D2I_get_EXP_opt(ret->peer,d2i_X509,3);\\r\\nos.length=0;\\r\\nos.data=NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp,d2i_ASN1_OCTET_STRING,4);\\r\\nif(os.data != NULL)\\r\\n{\\r\\nif (os.length > SSL_MAX_SID_CTX_LENGTH)\\r\\nSSLerr(SSL_F_D2I_SSL_SESSION,SSL_R_BAD_LENGTH);\\r\\nret->sid_ctx_length=os.length;\\r\\nmemcpy(ret->sid_ctx,os.data,os.length);\\r\\nFree(os.data); os.data=NULL; os.length=0;\\r\\n}\\r\\nelse\\r\\nret->sid_ctx_length=0;\\r\\nM_ASN1_D2I_Finish(a,SSL_SESSION_free,SSL_F_D2I_SSL_SESSION);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_srvr_c", "target": 1, "func": "static SSL_METHOD *ssl3_get_server_method(int ver)\\r\\n{\\r\\nif (ver == SSL3_VERSION)\\r\\nreturn(SSLv3_server_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *SSLv3_server_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD SSLv3_server_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&SSLv3_server_data,(char *)sslv3_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nSSLv3_server_data.ssl_accept=ssl3_accept;\\r\\nSSLv3_server_data.get_ssl_method=ssl3_get_server_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&SSLv3_server_data);\\r\\n}\\r\\nint ssl3_accept(SSL *s)\\r\\n{\\r\\nBUF_MEM *buf;\\r\\nunsigned long l,Time=time(NULL);\\r\\nvoid (*cb)()=NULL;\\r\\nlong num1;\\r\\nint ret= -1;\\r\\nint new_state,state,skip=0;\\r\\nRAND_seed(&Time,sizeof(Time));\\r\\nERR_clear_error();\\r\\nclear_sys_error();\\r\\nif (s->info_callback != NULL)\\r\\ncb=s->info_callback;\\r\\nelse if (s->ctx->info_callback != NULL)\\r\\ncb=s->ctx->info_callback;\\r\\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\\r\\ns->in_handshake++;\\r\\nif (s->cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (;;)\\r\\n{\\r\\nstate=s->state;\\r\\nswitch (s->state)\\r\\n{\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\ns->new_session=1;\\r\\ncase SSL_ST_BEFORE:\\r\\ncase SSL_ST_ACCEPT:\\r\\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\\r\\ncase SSL_ST_OK|SSL_ST_ACCEPT:\\r\\ns->server=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\\r\\nif ((s->version>>8) != 3)\\r\\nabort();\\r\\ns->type=SSL_ST_ACCEPT;\\r\\nif (s->init_buf == NULL)\\r\\n{\\r\\nif ((buf=BUF_MEM_new()) == NULL)\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\ns->init_buf=buf;\\r\\n}\\r\\nif (!ssl3_setup_buffers(s))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\\r\\ns->init_num=0;\\r\\nif (s->state != SSL_ST_RENEGOTIATE)\\r\\n{\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\\r\\nssl3_init_finished_mac(s);\\r\\ns->ctx->stats.sess_accept++;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->ctx->stats.sess_accept_renegotiate++;\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_A;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A:\\r\\ncase SSL3_ST_SW_HELLO_REQ_B:\\r\\ns->shutdown=0;\\r\\nret=ssl3_send_hello_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nssl3_init_finished_mac(s);\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C:\\r\\ns->state=SSL_ST_OK;\\r\\nret=1;\\r\\ngoto end;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B:\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C:\\r\\ns->shutdown=0;\\r\\nret=ssl3_get_client_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_SRVR_HELLO_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A:\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B:\\r\\nret=ssl3_send_server_hello(s);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CERT_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_A:\\r\\ncase SSL3_ST_SW_CERT_B:\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nret=ssl3_send_server_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_KEY_EXCH_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A:\\r\\ncase SSL3_ST_SW_KEY_EXCH_B:\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\nif (s->options & SSL_OP_EPHEMERAL_RSA)\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\nelse\\r\\ns->s3->tmp.use_rsa_tmp=0;\\r\\nif (s->s3->tmp.use_rsa_tmp\\r\\n|| (l & (SSL_DH|SSL_kFZA))\\r\\n|| ((l & SSL_kRSA)\\r\\n&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\\r\\n|| (SSL_IS_EXPORT(l)\\r\\n&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_EXPORT_PKEYLENGTH(l)\\r\\n)\\r\\n)\\r\\n)\\r\\n)\\r\\n{\\r\\nret=ssl3_send_server_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\n}\\r\\nelse\\r\\nskip=1;\\r\\ns->state=SSL3_ST_SW_CERT_REQ_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_A:\\r\\ncase SSL3_ST_SW_CERT_REQ_B:\\r\\nif (!(s->verify_mode & SSL_VERIFY_PEER) ||\\r\\n((s->session->peer != NULL) &&\\r\\n(s->verify_mode & SSL_VERIFY_CLIENT_ONCE)))\\r\\n{\\r\\nskip=1;\\r\\ns->s3->tmp.cert_request=0;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns->s3->tmp.cert_request=1;\\r\\nret=ssl3_send_certificate_request(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_A;\\r\\ns->init_num=0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A:\\r\\ncase SSL3_ST_SW_SRVR_DONE_B:\\r\\nret=ssl3_send_server_done(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\nnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\\r\\nif (num1 > 0)\\r\\n{\\r\\ns->rwstate=SSL_WRITING;\\r\\nnum1=BIO_flush(s->wbio);\\r\\nif (num1 <= 0) { ret= -1; goto end; }\\r\\ns->rwstate=SSL_NOTHING;\\r\\n}\\r\\ns->state=s->s3->tmp.next_state;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_A:\\r\\ncase SSL3_ST_SR_CERT_B:\\r\\nret=ssl3_get_client_certificate(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->init_num=0;\\r\\ns->state=SSL3_ST_SR_KEY_EXCH_A;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A:\\r\\ncase SSL3_ST_SR_KEY_EXCH_B:\\r\\nret=ssl3_get_client_key_exchange(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SR_CERT_VRFY_A;\\r\\ns->init_num=0;\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->tmp.finish_md[0]));\\r\\ns->method->ssl3_enc->cert_verify_mac(s,\\r\\n&(s->s3->finish_dgst2),\\r\\n&(s->s3->tmp.finish_md[MD5_DIGEST_LENGTH]));\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A:\\r\\ncase SSL3_ST_SR_CERT_VRFY_B:\\r\\nret=ssl3_get_cert_verify(s);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SR_FINISHED_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\nret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\\r\\nSSL3_ST_SR_FINISHED_B);\\r\\nif (ret <= 0) goto end;\\r\\nif (s->hit)\\r\\ns->state=SSL_ST_OK;\\r\\nelse\\r\\ns->state=SSL3_ST_SW_CHANGE_A;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ns->session->cipher=s->s3->tmp.new_cipher;\\r\\nif (!s->method->ssl3_enc->setup_key_block(s))\\r\\n{ ret= -1; goto end; }\\r\\nret=ssl3_send_change_cipher_spec(s,\\r\\nSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FINISHED_A;\\r\\ns->init_num=0;\\r\\nif (!s->method->ssl3_enc->change_cipher_state(s,\\r\\nSSL3_CHANGE_CIPHER_SERVER_WRITE))\\r\\n{\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\nret=ssl3_send_finished(s,\\r\\nSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\\r\\ns->method->ssl3_enc->server_finished,\\r\\ns->method->ssl3_enc->server_finished_len);\\r\\nif (ret <= 0) goto end;\\r\\ns->state=SSL3_ST_SW_FLUSH;\\r\\nif (s->hit)\\r\\ns->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\\r\\nelse\\r\\ns->s3->tmp.next_state=SSL_ST_OK;\\r\\ns->init_num=0;\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nssl3_cleanup_key_block(s);\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf=NULL;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->new_session=0;\\r\\ns->init_num=0;\\r\\nssl_update_cache(s,SSL_SESS_CACHE_SERVER);\\r\\ns->ctx->stats.sess_accept_good++;\\r\\ns->handshake_func=ssl3_accept;\\r\\nret=1;\\r\\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\\r\\ngoto end;\\r\\ndefault:\\r\\nSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\\r\\nret= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (!s->s3->tmp.reuse_message && !skip)\\r\\n{\\r\\nif (s->debug)\\r\\n{\\r\\nif ((ret=BIO_flush(s->wbio)) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif ((cb != NULL) && (s->state != state))\\r\\n{\\r\\nnew_state=s->state;\\r\\ns->state=state;\\r\\ncb(s,SSL_CB_ACCEPT_LOOP,1);\\r\\ns->state=new_state;\\r\\n}\\r\\n}\\r\\nskip=0;\\r\\n}\\r\\nend:\\r\\nif (cb != NULL)\\r\\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\\r\\ns->in_handshake--;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_send_hello_request(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_HELLO_REQ_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL3_MT_CLIENT_REQUEST;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->state=SSL3_ST_SW_HELLO_REQ_B;\\r\\ns->init_num=4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nstatic int ssl3_get_client_hello(SSL *s)\\r\\n{\\r\\nint i,j,ok,al,ret= -1;\\r\\nlong n;\\r\\nunsigned long id;\\r\\nunsigned char *p,*d,*q;\\r\\nSSL_CIPHER *c;\\r\\nSSL_COMP *comp=NULL;\\r\\nSTACK_OF(SSL_CIPHER) *ciphers=NULL;\\r\\nif (s->state == SSL3_ST_SR_CLNT_HELLO_A)\\r\\n{\\r\\ns->first_packet=1;\\r\\ns->state=SSL3_ST_SR_CLNT_HELLO_B;\\r\\n}\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_SR_CLNT_HELLO_B,\\r\\nSSL3_ST_SR_CLNT_HELLO_C,\\r\\nSSL3_MT_CLIENT_HELLO,\\r\\nSSL3_RT_MAX_PLAIN_LENGTH,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nd=p=(unsigned char *)s->init_buf->data;\\r\\np+=2;\\r\\nmemcpy(s->s3->client_random,p,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nj= *(p++);\\r\\ns->hit=0;\\r\\nif (j == 0)\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_get_prev_session(s,p,j);\\r\\nif (i == 1)\\r\\n{\\r\\ns->hit=1;\\r\\n}\\r\\nelse if (i == -1)\\r\\ngoto err;\\r\\nelse\\r\\n{\\r\\nif (!ssl_get_new_session(s,1))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\np+=j;\\r\\nn2s(p,i);\\r\\nif ((i == 0) && (j != 0))\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((i+p) > (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((i > 0) && (ssl_bytes_to_cipher_list(s,p,i,&(ciphers))\\r\\n== NULL))\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\np+=i;\\r\\nif ((s->hit) && (i > 0))\\r\\n{\\r\\nj=0;\\r\\nid=s->session->cipher->id;\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"client sent %d ciphers\\n\",sk_num(ciphers));\\r\\n#endif\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(ciphers); i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(ciphers,i);\\r\\n#ifdef CIPHER_DEBUG\\r\\nprintf(\"client [%2d of %2d]:%s\\n\",\\r\\ni,sk_num(ciphers),SSL_CIPHER_get_name(c));\\r\\n#endif\\r\\nif (c->id == id)\\r\\n{\\r\\nj=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (j == 0)\\r\\n{\\r\\nif ((s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG) && (sk_SSL_CIPHER_num(ciphers) == 1))\\r\\n{\\r\\ns->session->cipher=sk_SSL_CIPHER_value(ciphers,\\r\\n0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_REQUIRED_CIPHER_MISSING);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n}\\r\\ni= *(p++);\\r\\nq=p;\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (p[j] == 0) break;\\r\\n}\\r\\np+=i;\\r\\nif (j >= i)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_COMPRESSION_SPECIFIED);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.new_compression=NULL;\\r\\nif (s->ctx->comp_methods != NULL)\\r\\n{\\r\\nint m,nn,o,v,done=0;\\r\\nnn=sk_SSL_COMP_num(s->ctx->comp_methods);\\r\\nfor (m=0; m<nn; m++)\\r\\n{\\r\\ncomp=sk_SSL_COMP_value(s->ctx->comp_methods,m);\\r\\nv=comp->id;\\r\\nfor (o=0; o<i; o++)\\r\\n{\\r\\nif (v == q[o])\\r\\n{\\r\\ndone=1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (done) break;\\r\\n}\\r\\nif (done)\\r\\ns->s3->tmp.new_compression=comp;\\r\\nelse\\r\\ncomp=NULL;\\r\\n}\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\nif (p > (d+n))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (!s->hit)\\r\\n{\\r\\ns->session->compress_meth=(comp == NULL)?0:comp->id;\\r\\nif (s->session->ciphers != NULL)\\r\\nsk_SSL_CIPHER_free(s->session->ciphers);\\r\\ns->session->ciphers=ciphers;\\r\\nif (ciphers == NULL)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_PASSED);\\r\\ngoto f_err;\\r\\n}\\r\\nciphers=NULL;\\r\\nc=ssl3_choose_cipher(s,s->session->ciphers,\\r\\nssl_get_ciphers_by_id(s));\\r\\nif (c == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_SHARED_CIPHER);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.new_cipher=c;\\r\\n}\\r\\nelse\\r\\n{\\r\\n#ifdef REUSE_CIPHER_BUG\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *nc=NULL;\\r\\nSSL_CIPHER *ec=NULL;\\r\\nif (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG)\\r\\n{\\r\\nsk=s->session->ciphers;\\r\\nfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\\r\\n{\\r\\nc=sk_SSL_CIPHER_value(sk,i);\\r\\nif (c->algorithms & SSL_eNULL)\\r\\nnc=c;\\r\\nif (SSL_C_IS_EXPORT(c))\\r\\nec=c;\\r\\n}\\r\\nif (nc != NULL)\\r\\ns->s3->tmp.new_cipher=nc;\\r\\nelse if (ec != NULL)\\r\\ns->s3->tmp.new_cipher=ec;\\r\\nelse\\r\\ns->s3->tmp.new_cipher=s->session->cipher;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\ns->s3->tmp.new_cipher=s->session->cipher;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nif (ciphers != NULL) sk_SSL_CIPHER_free(ciphers);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_send_server_hello(SSL *s)\\r\\n{\\r\\nunsigned char *buf;\\r\\nunsigned char *p,*d;\\r\\nint i,sl;\\r\\nunsigned long l,Time;\\r\\nif (s->state == SSL3_ST_SW_SRVR_HELLO_A)\\r\\n{\\r\\nbuf=(unsigned char *)s->init_buf->data;\\r\\np=s->s3->server_random;\\r\\nTime=time(NULL);\\r\\nl2n(Time,p);\\r\\nRAND_bytes(p,SSL3_RANDOM_SIZE-sizeof(Time));\\r\\nd=p= &(buf[4]);\\r\\n*(p++)=s->version>>8;\\r\\n*(p++)=s->version&0xff;\\r\\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\\r\\np+=SSL3_RANDOM_SIZE;\\r\\nif (!(s->ctx->session_cache_mode & SSL_SESS_CACHE_SERVER))\\r\\ns->session->session_id_length=0;\\r\\nsl=s->session->session_id_length;\\r\\n*(p++)=sl;\\r\\nmemcpy(p,s->session->session_id,sl);\\r\\np+=sl;\\r\\ni=ssl3_put_cipher_by_char(s->s3->tmp.new_cipher,p);\\r\\np+=i;\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\n*(p++)=0;\\r\\nelse\\r\\n*(p++)=s->s3->tmp.new_compression->id;\\r\\nl=(p-d);\\r\\nd=buf;\\r\\n*(d++)=SSL3_MT_SERVER_HELLO;\\r\\nl2n3(l,d);\\r\\ns->state=SSL3_ST_CW_CLNT_HELLO_B;\\r\\ns->init_num=p-buf;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nstatic int ssl3_send_server_done(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == SSL3_ST_SW_SRVR_DONE_A)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*(p++)=SSL3_MT_SERVER_DONE;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\n*(p++)=0;\\r\\ns->state=SSL3_ST_SW_SRVR_DONE_B;\\r\\ns->init_num=4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nstatic int ssl3_send_server_key_exchange(SSL *s)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nunsigned char *q;\\r\\nint j,num;\\r\\nRSA *rsa;\\r\\nunsigned char md_buf[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nDH *dh,*dhp;\\r\\n#endif\\r\\nEVP_PKEY *pkey;\\r\\nunsigned char *p,*d;\\r\\nint al,i;\\r\\nunsigned long type;\\r\\nint n;\\r\\nCERT *cert;\\r\\nBIGNUM *r[4];\\r\\nint nr[4],kn;\\r\\nBUF_MEM *buf;\\r\\nEVP_MD_CTX md_ctx;\\r\\nif (s->state == SSL3_ST_SW_KEY_EXCH_A)\\r\\n{\\r\\ntype=s->s3->tmp.new_cipher->algorithms & SSL_MKEY_MASK;\\r\\ncert=s->cert;\\r\\nbuf=s->init_buf;\\r\\nr[0]=r[1]=r[2]=r[3]=NULL;\\r\\nn=0;\\r\\n#ifndef NO_RSA\\r\\nif (type & SSL_kRSA)\\r\\n{\\r\\nrsa=cert->rsa_tmp;\\r\\nif ((rsa == NULL) && (s->cert->rsa_tmp_cb != NULL))\\r\\n{\\r\\nrsa=s->cert->rsa_tmp_cb(s,\\r\\nSSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nCRYPTO_add(&rsa->references,1,CRYPTO_LOCK_RSA);\\r\\ncert->rsa_tmp=rsa;\\r\\n}\\r\\nif (rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nr[0]=rsa->n;\\r\\nr[1]=rsa->e;\\r\\ns->s3->tmp.use_rsa_tmp=1;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (type & SSL_kEDH)\\r\\n{\\r\\ndhp=cert->dh_tmp;\\r\\nif ((dhp == NULL) && (s->cert->dh_tmp_cb != NULL))\\r\\ndhp=s->cert->dh_tmp_cb(s,\\r\\n!SSL_C_IS_EXPORT(s->s3->tmp.new_cipher),\\r\\nSSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher));\\r\\nif (dhp == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((dh=DHparams_dup(dhp)) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.dh=dh;\\r\\nif ((dhp->pub_key == NULL ||\\r\\ndhp->priv_key == NULL ||\\r\\n(s->options & SSL_OP_SINGLE_DH_USE)))\\r\\n{\\r\\nif(!DH_generate_key(dh))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,\\r\\nERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ndh->pub_key=BN_dup(dhp->pub_key);\\r\\ndh->priv_key=BN_dup(dhp->priv_key);\\r\\nif ((dh->pub_key == NULL) ||\\r\\n(dh->priv_key == NULL))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr[0]=dh->p;\\r\\nr[1]=dh->g;\\r\\nr[2]=dh->pub_key;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\nnr[i]=BN_num_bytes(r[i]);\\r\\nn+=2+nr[i];\\r\\n}\\r\\nif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\\r\\n{\\r\\nif ((pkey=ssl_get_sign_pkey(s,s->s3->tmp.new_cipher))\\r\\n== NULL)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\nkn=EVP_PKEY_size(pkey);\\r\\n}\\r\\nelse\\r\\n{\\r\\npkey=NULL;\\r\\nkn=0;\\r\\n}\\r\\nif (!BUF_MEM_grow(buf,n+4+kn))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_BUF);\\r\\ngoto err;\\r\\n}\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\nfor (i=0; r[i] != NULL; i++)\\r\\n{\\r\\ns2n(nr[i],p);\\r\\nBN_bn2bin(r[i],p);\\r\\np+=nr[i];\\r\\n}\\r\\nif (pkey != NULL)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nq=md_buf;\\r\\nj=0;\\r\\nfor (num=2; num > 0; num--)\\r\\n{\\r\\nEVP_DigestInit(&md_ctx,(num == 2)\\r\\n?s->ctx->md5:s->ctx->sha1);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md_ctx,&(d[4]),n);\\r\\nEVP_DigestFinal(&md_ctx,q,\\r\\n(unsigned int *)&i);\\r\\nq+=i;\\r\\nj+=i;\\r\\n}\\r\\ni=RSA_private_encrypt(j,md_buf,&(p[2]),\\r\\npkey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_RSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn+=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#if !defined(NO_DSA)\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nEVP_SignInit(&md_ctx,EVP_dss1());\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->client_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(s->s3->server_random[0]),SSL3_RANDOM_SIZE);\\r\\nEVP_SignUpdate(&md_ctx,&(d[4]),n);\\r\\nif (!EVP_SignFinal(&md_ctx,&(p[2]),\\r\\n(unsigned int *)&i,pkey))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,ERR_LIB_DSA);\\r\\ngoto err;\\r\\n}\\r\\ns2n(i,p);\\r\\nn+=i+2;\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_PKEY_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\n*(d++)=SSL3_MT_SERVER_KEY_EXCHANGE;\\r\\nl2n3(n,d);\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_send_certificate_request(SSL *s)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i,j,nl,off,n;\\r\\nSTACK_OF(X509_NAME) *sk=NULL;\\r\\nX509_NAME *name;\\r\\nBUF_MEM *buf;\\r\\nif (s->state == SSL3_ST_SW_CERT_REQ_A)\\r\\n{\\r\\nbuf=s->init_buf;\\r\\nd=p=(unsigned char *)&(buf->data[4]);\\r\\np++;\\r\\nn=ssl3_get_req_cert_type(s,p);\\r\\nd[0]=n;\\r\\np+=n;\\r\\nn++;\\r\\noff=n;\\r\\np+=2;\\r\\nn+=2;\\r\\nsk=SSL_get_client_CA_list(s);\\r\\nnl=0;\\r\\nif (sk != NULL)\\r\\n{\\r\\nfor (i=0; i<sk_X509_NAME_num(sk); i++)\\r\\n{\\r\\nname=sk_X509_NAME_value(sk,i);\\r\\nj=i2d_X509_NAME(name,NULL);\\r\\nif (!BUF_MEM_grow(buf,4+n+j+2))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_CERTIFICATE_REQUEST,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np=(unsigned char *)&(buf->data[4+n]);\\r\\nif (!(s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\\r\\n{\\r\\ns2n(j,p);\\r\\ni2d_X509_NAME(name,&p);\\r\\nn+=2+j;\\r\\nnl+=2+j;\\r\\n}\\r\\nelse\\r\\n{\\r\\nd=p;\\r\\ni2d_X509_NAME(name,&p);\\r\\nj-=2; s2n(j,d); j+=2;\\r\\nn+=j;\\r\\nnl+=j;\\r\\n}\\r\\n}\\r\\n}\\r\\np=(unsigned char *)&(buf->data[4+off]);\\r\\ns2n(nl,p);\\r\\nd=(unsigned char *)buf->data;\\r\\n*(d++)=SSL3_MT_CERTIFICATE_REQUEST;\\r\\nl2n3(n,d);\\r\\ns->init_num=n+4;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_get_client_key_exchange(SSL *s)\\r\\n{\\r\\nint i,al,ok;\\r\\nlong n;\\r\\nunsigned long l;\\r\\nunsigned char *p;\\r\\n#ifndef NO_RSA\\r\\nRSA *rsa=NULL;\\r\\nEVP_PKEY *pkey=NULL;\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nBIGNUM *pub=NULL;\\r\\nDH *dh_srvr;\\r\\n#endif\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_SR_KEY_EXCH_A,\\r\\nSSL3_ST_SR_KEY_EXCH_B,\\r\\nSSL3_MT_CLIENT_KEY_EXCHANGE,\\r\\n400,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nl=s->s3->tmp.new_cipher->algorithms;\\r\\n#ifndef NO_RSA\\r\\nif (l & SSL_kRSA)\\r\\n{\\r\\nif (s->s3->tmp.use_rsa_tmp)\\r\\n{\\r\\nif ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))\\r\\nrsa=s->cert->rsa_tmp;\\r\\nif (rsa == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\npkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;\\r\\nif ( (pkey == NULL) ||\\r\\n(pkey->type != EVP_PKEY_RSA) ||\\r\\n(pkey->pkey.rsa == NULL))\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);\\r\\ngoto f_err;\\r\\n}\\r\\nrsa=pkey->pkey.rsa;\\r\\n}\\r\\nif (s->version > SSL3_VERSION)\\r\\n{\\r\\nn2s(p,i);\\r\\nif (n != i+2)\\r\\n{\\r\\nif (!(s->options & SSL_OP_TLS_D5_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\np-=2;\\r\\n}\\r\\nelse\\r\\nn=i;\\r\\n}\\r\\ni=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);\\r\\n#if 1\\r\\nif ((i != SSL_MAX_MASTER_KEY_LENGTH) ||\\r\\n((p[0] != (s->client_version>>8)) ||\\r\\n(p[1] != (s->client_version & 0xff))))\\r\\n{\\r\\nint bad=1;\\r\\nif ((i == SSL_MAX_MASTER_KEY_LENGTH) &&\\r\\n(p[0] == (s->version>>8)) &&\\r\\n(p[1] == 0))\\r\\n{\\r\\nif (s->options & SSL_OP_TLS_ROLLBACK_BUG)\\r\\nbad=0;\\r\\n}\\r\\nif (bad)\\r\\n{\\r\\np[0]=(s->version>>8);\\r\\np[1]=(s->version & 0xff);\\r\\nRAND_bytes(&(p[2]),SSL_MAX_MASTER_KEY_LENGTH-2);\\r\\ni=SSL_MAX_MASTER_KEY_LENGTH;\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (i != SSL_MAX_MASTER_KEY_LENGTH)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((p[0] != (s->version>>8)) || (p[1] != (s->version & 0xff)))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER);\\r\\ngoto f_err;\\r\\n}\\r\\n#endif\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,\\r\\np,i);\\r\\nmemset(p,0,i);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DH\\r\\nif (l & (SSL_kEDH|SSL_kDHr|SSL_kDHd))\\r\\n{\\r\\nn2s(p,i);\\r\\nif (n != i+2)\\r\\n{\\r\\nif (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);\\r\\ngoto err;\\r\\n}\\r\\nelse\\r\\n{\\r\\np-=2;\\r\\ni=(int)n;\\r\\n}\\r\\n}\\r\\nif (n == 0L)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNABLE_TO_DECODE_DH_CERTS);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (s->s3->tmp.dh == NULL)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_DH_KEY);\\r\\ngoto f_err;\\r\\n}\\r\\nelse\\r\\ndh_srvr=s->s3->tmp.dh;\\r\\n}\\r\\npub=BN_bin2bn(p,i,NULL);\\r\\nif (pub == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni=DH_compute_key(p,pub,dh_srvr);\\r\\nif (i <= 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nDH_free(s->s3->tmp.dh);\\r\\ns->s3->tmp.dh=NULL;\\r\\nBN_clear_free(pub);\\r\\npub=NULL;\\r\\ns->session->master_key_length=\\r\\ns->method->ssl3_enc->generate_master_secret(s,\\r\\ns->session->master_key,p,i);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_UNKNOWN_CIPHER_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n#if !defined(NO_DH) || !defined(NO_RSA)\\r\\nerr:\\r\\n#endif\\r\\nreturn(-1);\\r\\n}\\r\\nstatic int ssl3_get_cert_verify(SSL *s)\\r\\n{\\r\\nEVP_PKEY *pkey=NULL;\\r\\nunsigned char *p;\\r\\nint al,ok,ret=0;\\r\\nlong n;\\r\\nint type=0,i,j;\\r\\nX509 *peer;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_SR_CERT_VRFY_A,\\r\\nSSL3_ST_SR_CERT_VRFY_B,\\r\\n-1,\\r\\n512,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->session->peer != NULL)\\r\\n{\\r\\npeer=s->session->peer;\\r\\npkey=X509_get_pubkey(peer);\\r\\ntype=X509_certificate_type(peer,pkey);\\r\\n}\\r\\nelse\\r\\n{\\r\\npeer=NULL;\\r\\npkey=NULL;\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\\r\\n{\\r\\ns->s3->tmp.reuse_message=1;\\r\\nif ((peer != NULL) && (type | EVP_PKT_SIGN))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\nret=1;\\r\\ngoto end;\\r\\n}\\r\\nif (peer == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\nif (!(type & EVP_PKT_SIGN))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\ngoto f_err;\\r\\n}\\r\\nif (s->s3->change_cipher_spec)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nn2s(p,i);\\r\\nn-=2;\\r\\nif (i > n)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\nj=EVP_PKEY_size(pkey);\\r\\nif ((i > j) || (n > j) || (n <= 0))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\ngoto f_err;\\r\\n}\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\ni=RSA_public_decrypt(i,p,p,pkey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nif (i < 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\\r\\ngoto f_err;\\r\\n}\\r\\nif ((i != (MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH)) ||\\r\\nmemcmp(&(s->s3->tmp.finish_md[0]),p,\\r\\nMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH))\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nj=DSA_verify(pkey->save_type,\\r\\n&(s->s3->tmp.finish_md[MD5_DIGEST_LENGTH]),\\r\\nSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\\r\\nif (j <= 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_INTERNAL_ERROR);\\r\\nal=SSL_AD_UNSUPPORTED_CERTIFICATE;\\r\\ngoto f_err;\\r\\n}\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int ssl3_get_client_certificate(SSL *s)\\r\\n{\\r\\nint i,ok,al,ret= -1;\\r\\nX509 *x=NULL;\\r\\nunsigned long l,nc,llen,n;\\r\\nunsigned char *p,*d,*q;\\r\\nSTACK_OF(X509) *sk=NULL;\\r\\nn=ssl3_get_message(s,\\r\\nSSL3_ST_SR_CERT_A,\\r\\nSSL3_ST_SR_CERT_B,\\r\\n-1,\\r\\n#if defined(MSDOS) && !defined(WIN32)\\r\\n1024*30,\\r\\n#else\\r\\n1024*100,\\r\\n#endif\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE)\\r\\n{\\r\\nif ( (s->verify_mode & SSL_VERIFY_PEER) &&\\r\\n(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\ngoto f_err;\\r\\n}\\r\\nif ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.reuse_message=1;\\r\\nreturn(1);\\r\\n}\\r\\nif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_WRONG_MESSAGE_TYPE);\\r\\ngoto f_err;\\r\\n}\\r\\nd=p=(unsigned char *)s->init_buf->data;\\r\\nif ((sk=sk_X509_new_null()) == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nn2l3(p,llen);\\r\\nif (llen+3 != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nfor (nc=0; nc<llen; )\\r\\n{\\r\\nn2l3(p,l);\\r\\nif ((l+nc+3) > llen)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nq=p;\\r\\nx=d2i_X509(NULL,&p,l);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (p != (q+l))\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_CERT_LENGTH_MISMATCH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (!sk_X509_push(sk,x))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nx=NULL;\\r\\nnc+=l+3;\\r\\n}\\r\\nif (sk_X509_num(sk) <= 0)\\r\\n{\\r\\nif (s->version == SSL3_VERSION)\\r\\n{\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATES_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\nelse if ((s->verify_mode & SSL_VERIFY_PEER) &&\\r\\n(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\ni=ssl_verify_cert_chain(s,sk);\\r\\nif (!i)\\r\\n{\\r\\nal=ssl_verify_alarm_type(s->verify_result);\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,SSL_R_NO_CERTIFICATE_RETURNED);\\r\\ngoto f_err;\\r\\n}\\r\\n}\\r\\nif (s->session->peer != NULL)\\r\\nX509_free(s->session->peer);\\r\\ns->session->peer=sk_X509_shift(sk);\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\ns->session->sess_cert = ssl_sess_cert_new();\\r\\nif (s->session->sess_cert == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (s->session->sess_cert->cert_chain != NULL)\\r\\nsk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);\\r\\ns->session->sess_cert->cert_chain=sk;\\r\\nsk=NULL;\\r\\nret=1;\\r\\nif (0)\\r\\n{\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\n}\\r\\nerr:\\r\\nif (x != NULL) X509_free(x);\\r\\nif (sk != NULL) sk_X509_pop_free(sk,X509_free);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl3_send_server_certificate(SSL *s)\\r\\n{\\r\\nunsigned long l;\\r\\nX509 *x;\\r\\nif (s->state == SSL3_ST_SW_CERT_A)\\r\\n{\\r\\nx=ssl_get_server_send_cert(s);\\r\\nif (x == NULL)\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,SSL_R_INTERNAL_ERROR);\\r\\nreturn(0);\\r\\n}\\r\\nl=ssl3_output_cert_chain(s,x);\\r\\ns->state=SSL3_ST_SW_CERT_B;\\r\\ns->init_num=(int)l;\\r\\ns->init_off=0;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3err_c", "target": 0, "func": "void ERR_load_X509V3_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_X509V3,X509V3_str_functs);\\r\\nERR_load_strings(ERR_LIB_X509V3,X509V3_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cnf_save_c", "target": 0, "func": "main()\\r\\n{\\r\\nLHASH *conf;\\r\\nlong l;\\r\\nconf=CONF_load(NULL,\"../../apps/openssl.cnf\",&l);\\r\\nif (conf == NULL)\\r\\n{\\r\\nfprintf(stderr,\"error loading config, line %ld\\n\",l);\\r\\nexit(1);\\r\\n}\\r\\nlh_doall(conf,print_conf);\\r\\n}\\r\\nvoid print_conf(CONF_VALUE *cv)\\r\\n{\\r\\nint i;\\r\\nCONF_VALUE *v;\\r\\nchar *section;\\r\\nchar *name;\\r\\nchar *value;\\r\\nSTACK *s;\\r\\nif (cv->name != NULL) return;\\r\\nprintf(\"[ %s ]\\n\",cv->section);\\r\\ns=(STACK *)cv->value;\\r\\nfor (i=0; i<sk_num(s); i++)\\r\\n{\\r\\nv=(CONF_VALUE *)sk_value(s,i);\\r\\nsection=(v->section == NULL)?\"None\":v->section;\\r\\nname=(v->name == NULL)?\"None\":v->name;\\r\\nvalue=(v->value == NULL)?\"None\":v->value;\\r\\nprintf(\"%s=%s\\n\",name,value);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_enc_c", "target": 0, "func": "int EVP_PKEY_encrypt(unsigned char *ek, unsigned char *key, int key_len,\\r\\nEVP_PKEY *pubk)\\r\\n{\\r\\nint ret=0;\\r\\n#ifndef NO_RSA\\r\\nif (pubk->type != EVP_PKEY_RSA)\\r\\n{\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret=RSA_public_encrypt(key_len,key,ek,pubk->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_enc_c", "target": 0, "func": "void BF_encrypt(BF_LONG *data, BF_KEY *key)\\r\\n{\\r\\n#ifndef BF_PTR2\\r\\nregister BF_LONG l,r,*p,*s;\\r\\np=key->P;\\r\\ns= &(key->S[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nl^=p[0];\\r\\nBF_ENC(r,l,s,p[ 1]);\\r\\nBF_ENC(l,r,s,p[ 2]);\\r\\nBF_ENC(r,l,s,p[ 3]);\\r\\nBF_ENC(l,r,s,p[ 4]);\\r\\nBF_ENC(r,l,s,p[ 5]);\\r\\nBF_ENC(l,r,s,p[ 6]);\\r\\nBF_ENC(r,l,s,p[ 7]);\\r\\nBF_ENC(l,r,s,p[ 8]);\\r\\nBF_ENC(r,l,s,p[ 9]);\\r\\nBF_ENC(l,r,s,p[10]);\\r\\nBF_ENC(r,l,s,p[11]);\\r\\nBF_ENC(l,r,s,p[12]);\\r\\nBF_ENC(r,l,s,p[13]);\\r\\nBF_ENC(l,r,s,p[14]);\\r\\nBF_ENC(r,l,s,p[15]);\\r\\nBF_ENC(l,r,s,p[16]);\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,s,p[17]);\\r\\nBF_ENC(l,r,s,p[18]);\\r\\nBF_ENC(r,l,s,p[19]);\\r\\nBF_ENC(l,r,s,p[20]);\\r\\n#endif\\r\\nr^=p[BF_ROUNDS+1];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#else\\r\\nregister BF_LONG l,r,t,*k;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nk=(BF_LONG*)key;\\r\\nl^=k[0];\\r\\nBF_ENC(r,l,k, 1);\\r\\nBF_ENC(l,r,k, 2);\\r\\nBF_ENC(r,l,k, 3);\\r\\nBF_ENC(l,r,k, 4);\\r\\nBF_ENC(r,l,k, 5);\\r\\nBF_ENC(l,r,k, 6);\\r\\nBF_ENC(r,l,k, 7);\\r\\nBF_ENC(l,r,k, 8);\\r\\nBF_ENC(r,l,k, 9);\\r\\nBF_ENC(l,r,k,10);\\r\\nBF_ENC(r,l,k,11);\\r\\nBF_ENC(l,r,k,12);\\r\\nBF_ENC(r,l,k,13);\\r\\nBF_ENC(l,r,k,14);\\r\\nBF_ENC(r,l,k,15);\\r\\nBF_ENC(l,r,k,16);\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,k,17);\\r\\nBF_ENC(l,r,k,18);\\r\\nBF_ENC(r,l,k,19);\\r\\nBF_ENC(l,r,k,20);\\r\\n#endif\\r\\nr^=k[BF_ROUNDS+1];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#endif\\r\\n}\\r\\nvoid BF_decrypt(BF_LONG *data, BF_KEY *key)\\r\\n{\\r\\n#ifndef BF_PTR2\\r\\nregister BF_LONG l,r,*p,*s;\\r\\np=key->P;\\r\\ns= &(key->S[0]);\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nl^=p[BF_ROUNDS+1];\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,s,p[20]);\\r\\nBF_ENC(l,r,s,p[19]);\\r\\nBF_ENC(r,l,s,p[18]);\\r\\nBF_ENC(l,r,s,p[17]);\\r\\n#endif\\r\\nBF_ENC(r,l,s,p[16]);\\r\\nBF_ENC(l,r,s,p[15]);\\r\\nBF_ENC(r,l,s,p[14]);\\r\\nBF_ENC(l,r,s,p[13]);\\r\\nBF_ENC(r,l,s,p[12]);\\r\\nBF_ENC(l,r,s,p[11]);\\r\\nBF_ENC(r,l,s,p[10]);\\r\\nBF_ENC(l,r,s,p[ 9]);\\r\\nBF_ENC(r,l,s,p[ 8]);\\r\\nBF_ENC(l,r,s,p[ 7]);\\r\\nBF_ENC(r,l,s,p[ 6]);\\r\\nBF_ENC(l,r,s,p[ 5]);\\r\\nBF_ENC(r,l,s,p[ 4]);\\r\\nBF_ENC(l,r,s,p[ 3]);\\r\\nBF_ENC(r,l,s,p[ 2]);\\r\\nBF_ENC(l,r,s,p[ 1]);\\r\\nr^=p[0];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#else\\r\\nregister BF_LONG l,r,t,*k;\\r\\nl=data[0];\\r\\nr=data[1];\\r\\nk=(BF_LONG *)key;\\r\\nl^=k[BF_ROUNDS+1];\\r\\n#if BF_ROUNDS == 20\\r\\nBF_ENC(r,l,k,20);\\r\\nBF_ENC(l,r,k,19);\\r\\nBF_ENC(r,l,k,18);\\r\\nBF_ENC(l,r,k,17);\\r\\n#endif\\r\\nBF_ENC(r,l,k,16);\\r\\nBF_ENC(l,r,k,15);\\r\\nBF_ENC(r,l,k,14);\\r\\nBF_ENC(l,r,k,13);\\r\\nBF_ENC(r,l,k,12);\\r\\nBF_ENC(l,r,k,11);\\r\\nBF_ENC(r,l,k,10);\\r\\nBF_ENC(l,r,k, 9);\\r\\nBF_ENC(r,l,k, 8);\\r\\nBF_ENC(l,r,k, 7);\\r\\nBF_ENC(r,l,k, 6);\\r\\nBF_ENC(l,r,k, 5);\\r\\nBF_ENC(r,l,k, 4);\\r\\nBF_ENC(l,r,k, 3);\\r\\nBF_ENC(r,l,k, 2);\\r\\nBF_ENC(l,r,k, 1);\\r\\nr^=k[0];\\r\\ndata[1]=l&0xffffffffL;\\r\\ndata[0]=r&0xffffffffL;\\r\\n#endif\\r\\n}\\r\\nvoid BF_cbc_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nBF_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0,tin1;\\r\\nregister BF_LONG tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_encrypt(tin,ks);\\r\\ntout0=tin[0];\\r\\ntout1=tin[1];\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nBF_decrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_name_c", "target": 0, "func": "int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->object,i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_len(a->value,i2d_ASN1_PRINTABLE);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->object,i2d_ASN1_OBJECT);\\r\\nM_ASN1_I2D_put(a->value,i2d_ASN1_PRINTABLE);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_NAME_ENTRY *d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_NAME_ENTRY *,X509_NAME_ENTRY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->object,d2i_ASN1_OBJECT);\\r\\nM_ASN1_D2I_get(ret->value,d2i_ASN1_PRINTABLE);\\r\\nret->set=0;\\r\\nM_ASN1_D2I_Finish(a,X509_NAME_ENTRY_free,ASN1_F_D2I_X509_NAME_ENTRY);\\r\\n}\\r\\nint i2d_X509_NAME(X509_NAME *a, unsigned char **pp)\\r\\n{\\r\\nint ret;\\r\\nif (a == NULL) return(0);\\r\\nif (a->modified)\\r\\n{\\r\\nret=i2d_X509_NAME_entries(a);\\r\\nif (ret < 0) return(ret);\\r\\n}\\r\\nret=a->bytes->length;\\r\\nif (pp != NULL)\\r\\n{\\r\\nmemcpy(*pp,a->bytes->data,ret);\\r\\n*pp+=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int i2d_X509_NAME_entries(X509_NAME *a)\\r\\n{\\r\\nX509_NAME_ENTRY *ne,*fe=NULL;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nBUF_MEM *buf=NULL;\\r\\nint set=0,r,ret=0;\\r\\nint i;\\r\\nunsigned char *p;\\r\\nint size=0;\\r\\nsk=a->entries;\\r\\nfor (i=0; i<sk_X509_NAME_ENTRY_num(sk); i++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(sk,i);\\r\\nif (fe == NULL)\\r\\n{\\r\\nfe=ne;\\r\\nsize=0;\\r\\n}\\r\\nif (ne->set != set)\\r\\n{\\r\\nret+=ASN1_object_size(1,size,V_ASN1_SET);\\r\\nfe->size=size;\\r\\nfe=ne;\\r\\nsize=0;\\r\\nset=ne->set;\\r\\n}\\r\\nsize+=i2d_X509_NAME_ENTRY(ne,NULL);\\r\\n}\\r\\nret+=ASN1_object_size(1,size,V_ASN1_SET);\\r\\nif (fe != NULL)\\r\\nfe->size=size;\\r\\nr=ASN1_object_size(1,ret,V_ASN1_SEQUENCE);\\r\\nbuf=a->bytes;\\r\\nif (!BUF_MEM_grow(buf,r)) goto err;\\r\\np=(unsigned char *)buf->data;\\r\\nASN1_put_object(&p,1,ret,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\nset= -1;\\r\\nfor (i=0; i<sk_X509_NAME_ENTRY_num(sk); i++)\\r\\n{\\r\\nne=sk_X509_NAME_ENTRY_value(sk,i);\\r\\nif (set != ne->set)\\r\\n{\\r\\nset=ne->set;\\r\\nASN1_put_object(&p,1,ne->size,\\r\\nV_ASN1_SET,V_ASN1_UNIVERSAL);\\r\\n}\\r\\ni2d_X509_NAME_ENTRY(ne,&p);\\r\\n}\\r\\na->modified=0;\\r\\nreturn(r);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nX509_NAME *d2i_X509_NAME(X509_NAME **a, unsigned char **pp, long length)\\r\\n{\\r\\nint set=0,i;\\r\\nint idx=0;\\r\\nunsigned char *orig;\\r\\nM_ASN1_D2I_vars(a,X509_NAME *,X509_NAME_new);\\r\\norig= *pp;\\r\\nif (sk_X509_NAME_ENTRY_num(ret->entries) > 0)\\r\\n{\\r\\nwhile (sk_X509_NAME_ENTRY_num(ret->entries) > 0)\\r\\nX509_NAME_ENTRY_free(\\r\\nsk_X509_NAME_ENTRY_pop(ret->entries));\\r\\n}\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nfor (;;)\\r\\n{\\r\\nif (M_ASN1_D2I_end_sequence()) break;\\r\\nM_ASN1_D2I_get_set_type(X509_NAME_ENTRY,ret->entries,\\r\\nd2i_X509_NAME_ENTRY,\\r\\nX509_NAME_ENTRY_free);\\r\\nfor (; idx < sk_X509_NAME_ENTRY_num(ret->entries); idx++)\\r\\n{\\r\\nsk_X509_NAME_ENTRY_value(ret->entries,idx)->set=set;\\r\\n}\\r\\nset++;\\r\\n}\\r\\ni=(int)(c.p-orig);\\r\\nif (!BUF_MEM_grow(ret->bytes,i)) goto err;\\r\\nmemcpy(ret->bytes->data,orig,i);\\r\\nret->bytes->length=i;\\r\\nret->modified=0;\\r\\nM_ASN1_D2I_Finish(a,X509_NAME_free,ASN1_F_D2I_X509_NAME);\\r\\n}\\r\\nX509_NAME *X509_NAME_new(void)\\r\\n{\\r\\nX509_NAME *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_NAME);\\r\\nif ((ret->entries=sk_X509_NAME_ENTRY_new(NULL)) == NULL)\\r\\n{ c.line=__LINE__; goto err2; }\\r\\nM_ASN1_New(ret->bytes,BUF_MEM_new);\\r\\nret->modified=1;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_NAME_NEW);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_new(void)\\r\\n{\\r\\nX509_NAME_ENTRY *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_NAME_ENTRY);\\r\\nret->object=NULL;\\r\\nret->set=0;\\r\\nM_ASN1_New(ret->value,ASN1_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_NAME_ENTRY_NEW);\\r\\n}\\r\\nvoid X509_NAME_free(X509_NAME *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nBUF_MEM_free(a->bytes);\\r\\nsk_X509_NAME_ENTRY_pop_free(a->entries,X509_NAME_ENTRY_free);\\r\\nFree(a);\\r\\n}\\r\\nvoid X509_NAME_ENTRY_free(X509_NAME_ENTRY *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->object);\\r\\nASN1_BIT_STRING_free(a->value);\\r\\nFree(a);\\r\\n}\\r\\nint X509_NAME_set(X509_NAME **xn, X509_NAME *name)\\r\\n{\\r\\nX509_NAME *in;\\r\\nif (*xn == NULL) return(0);\\r\\nif (*xn != name)\\r\\n{\\r\\nin=X509_NAME_dup(name);\\r\\nif (in != NULL)\\r\\n{\\r\\nX509_NAME_free(*xn);\\r\\n*xn=in;\\r\\n}\\r\\n}\\r\\nreturn(*xn != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_example2_c", "target": 0, "func": "int main()\\r\\n{\\r\\nchar *ct = \"This the clear text\";\\r\\nchar *buf;\\r\\nchar *buf2;\\r\\nEVP_PKEY *pubKey;\\r\\nEVP_PKEY *privKey;\\r\\nint len;\\r\\nERR_load_crypto_strings();\\r\\nprivKey = ReadPrivateKey(PRIVFILE);\\r\\nif (!privKey)\\r\\n{\\r\\nERR_print_errors_fp (stderr);\\r\\nexit (1);\\r\\n}\\r\\npubKey = ReadPublicKey(PUBFILE);\\r\\nif(!pubKey)\\r\\n{\\r\\nEVP_PKEY_free(privKey);\\r\\nfprintf(stderr,\"Error: can't load public key\");\\r\\nexit(1);\\r\\n}\\r\\nbuf = malloc(EVP_PKEY_size(pubKey));\\r\\nbuf2 = malloc(EVP_PKEY_size(pubKey));\\r\\nlen = RSA_public_encrypt(strlen(ct)+1, ct, buf, pubKey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nif (len != EVP_PKEY_size(pubKey))\\r\\n{\\r\\nfprintf(stderr,\"Error: ciphertext should match length of key\\n\");\\r\\nexit(1);\\r\\n}\\r\\nRSA_private_decrypt(len, buf, buf2, privKey->pkey.rsa,RSA_PKCS1_PADDING);\\r\\nprintf(\"%s\\n\", buf2);\\r\\nEVP_PKEY_free(privKey);\\r\\nEVP_PKEY_free(pubKey);\\r\\nfree(buf);\\r\\nfree(buf2);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_all_c", "target": 1, "func": "int X509_verify(X509 *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_verify((int (*)())i2d_X509_CINF,a->sig_alg,\\r\\na->signature,(char *)a->cert_info,r));\\r\\n}\\r\\nint X509_REQ_verify(X509_REQ *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn( ASN1_verify((int (*)())i2d_X509_REQ_INFO,\\r\\na->sig_alg,a->signature,(char *)a->req_info,r));\\r\\n}\\r\\nint X509_CRL_verify(X509_CRL *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_verify((int (*)())i2d_X509_CRL_INFO,\\r\\na->sig_alg, a->signature,(char *)a->crl,r));\\r\\n}\\r\\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn(ASN1_verify((int (*)())i2d_NETSCAPE_SPKAC,\\r\\na->sig_algor,a->signature, (char *)a->spkac,r));\\r\\n}\\r\\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_sign((int (*)())i2d_X509_CINF, x->cert_info->signature,\\r\\nx->sig_alg, x->signature, (char *)x->cert_info,pkey,md));\\r\\n}\\r\\nint X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_sign((int (*)())i2d_X509_REQ_INFO,x->sig_alg, NULL,\\r\\nx->signature, (char *)x->req_info,pkey,md));\\r\\n}\\r\\nint X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_sign((int (*)())i2d_X509_CRL_INFO,x->crl->sig_alg,\\r\\nx->sig_alg, x->signature, (char *)x->crl,pkey,md));\\r\\n}\\r\\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn(ASN1_sign((int (*)())i2d_NETSCAPE_SPKAC, x->sig_algor,NULL,\\r\\nx->signature, (char *)x->spkac,pkey,md));\\r\\n}\\r\\nX509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa)\\r\\n{\\r\\nreturn((X509_ATTRIBUTE *)ASN1_dup((int (*)())i2d_X509_ATTRIBUTE,\\r\\n(char *(*)())d2i_X509_ATTRIBUTE,(char *)xa));\\r\\n}\\r\\nX509 *X509_dup(X509 *x509)\\r\\n{\\r\\nreturn((X509 *)ASN1_dup((int (*)())i2d_X509,\\r\\n(char *(*)())d2i_X509,(char *)x509));\\r\\n}\\r\\nX509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *ex)\\r\\n{\\r\\nreturn((X509_EXTENSION *)ASN1_dup(\\r\\n(int (*)())i2d_X509_EXTENSION,\\r\\n(char *(*)())d2i_X509_EXTENSION,(char *)ex));\\r\\n}\\r\\nX509 *d2i_X509_fp(FILE *fp, X509 **x509)\\r\\n{\\r\\nreturn((X509 *)ASN1_d2i_fp((char *(*)())X509_new,\\r\\n(char *(*)())d2i_X509, (fp),(unsigned char **)(x509)));\\r\\n}\\r\\nint i2d_X509_fp(FILE *fp, X509 *x509)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_X509,fp,(unsigned char *)x509));\\r\\n}\\r\\nX509 *d2i_X509_bio(BIO *bp, X509 **x509)\\r\\n{\\r\\nreturn((X509 *)ASN1_d2i_bio((char *(*)())X509_new,\\r\\n(char *(*)())d2i_X509, (bp),(unsigned char **)(x509)));\\r\\n}\\r\\nint i2d_X509_bio(BIO *bp, X509 *x509)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_X509,bp,(unsigned char *)x509));\\r\\n}\\r\\nX509_CRL *X509_CRL_dup(X509_CRL *crl)\\r\\n{\\r\\nreturn((X509_CRL *)ASN1_dup((int (*)())i2d_X509_CRL,\\r\\n(char *(*)())d2i_X509_CRL,(char *)crl));\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl)\\r\\n{\\r\\nreturn((X509_CRL *)ASN1_d2i_fp((char *(*)())\\r\\nX509_CRL_new,(char *(*)())d2i_X509_CRL, (fp),\\r\\n(unsigned char **)(crl)));\\r\\n}\\r\\nint i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_X509_CRL,fp,(unsigned char *)crl));\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl)\\r\\n{\\r\\nreturn((X509_CRL *)ASN1_d2i_bio((char *(*)())\\r\\nX509_CRL_new,(char *(*)())d2i_X509_CRL, (bp),\\r\\n(unsigned char **)(crl)));\\r\\n}\\r\\nint i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_X509_CRL,bp,(unsigned char *)crl));\\r\\n}\\r\\nPKCS7 *PKCS7_dup(PKCS7 *p7)\\r\\n{\\r\\nreturn((PKCS7 *)ASN1_dup((int (*)())i2d_PKCS7,\\r\\n(char *(*)())d2i_PKCS7,(char *)p7));\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)\\r\\n{\\r\\nreturn((PKCS7 *)ASN1_d2i_fp((char *(*)())\\r\\nPKCS7_new,(char *(*)())d2i_PKCS7, (fp),\\r\\n(unsigned char **)(p7)));\\r\\n}\\r\\nint i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_PKCS7,fp,(unsigned char *)p7));\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)\\r\\n{\\r\\nreturn((PKCS7 *)ASN1_d2i_bio((char *(*)())\\r\\nPKCS7_new,(char *(*)())d2i_PKCS7, (bp),\\r\\n(unsigned char **)(p7)));\\r\\n}\\r\\nint i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_PKCS7,bp,(unsigned char *)p7));\\r\\n}\\r\\nX509_REQ *X509_REQ_dup(X509_REQ *req)\\r\\n{\\r\\nreturn((X509_REQ *)ASN1_dup((int (*)())i2d_X509_REQ,\\r\\n(char *(*)())d2i_X509_REQ,(char *)req));\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req)\\r\\n{\\r\\nreturn((X509_REQ *)ASN1_d2i_fp((char *(*)())\\r\\nX509_REQ_new, (char *(*)())d2i_X509_REQ, (fp),\\r\\n(unsigned char **)(req)));\\r\\n}\\r\\nint i2d_X509_REQ_fp(FILE *fp, X509_REQ *req)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_X509_REQ,fp,(unsigned char *)req));\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req)\\r\\n{\\r\\nreturn((X509_REQ *)ASN1_d2i_bio((char *(*)())\\r\\nX509_REQ_new, (char *(*)())d2i_X509_REQ, (bp),\\r\\n(unsigned char **)(req)));\\r\\n}\\r\\nint i2d_X509_REQ_bio(BIO *bp, X509_REQ *req)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_X509_REQ,bp,(unsigned char *)req));\\r\\n}\\r\\nRSA *RSAPublicKey_dup(RSA *rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_dup((int (*)())i2d_RSAPublicKey,\\r\\n(char *(*)())d2i_RSAPublicKey,(char *)rsa));\\r\\n}\\r\\nRSA *RSAPrivateKey_dup(RSA *rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_dup((int (*)())i2d_RSAPrivateKey,\\r\\n(char *(*)())d2i_RSAPrivateKey,(char *)rsa));\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_d2i_fp((char *(*)())\\r\\nRSA_new,(char *(*)())d2i_RSAPrivateKey, (fp),\\r\\n(unsigned char **)(rsa)));\\r\\n}\\r\\nint i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_RSAPrivateKey,fp,(unsigned char *)rsa));\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_d2i_fp((char *(*)())\\r\\nRSA_new,(char *(*)())d2i_RSAPublicKey, (fp),\\r\\n(unsigned char **)(rsa)));\\r\\n}\\r\\nint i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_RSAPublicKey,fp,(unsigned char *)rsa));\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_d2i_bio((char *(*)())\\r\\nRSA_new,(char *(*)())d2i_RSAPrivateKey, (bp),\\r\\n(unsigned char **)(rsa)));\\r\\n}\\r\\nint i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_RSAPrivateKey,bp,(unsigned char *)rsa));\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn((RSA *)ASN1_d2i_bio((char *(*)())\\r\\nRSA_new,(char *(*)())d2i_RSAPublicKey, (bp),\\r\\n(unsigned char **)(rsa)));\\r\\n}\\r\\nint i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_RSAPublicKey,bp,(unsigned char *)rsa));\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa)\\r\\n{\\r\\nreturn((DSA *)ASN1_d2i_fp((char *(*)())\\r\\nDSA_new,(char *(*)())d2i_DSAPrivateKey, (fp),\\r\\n(unsigned char **)(dsa)));\\r\\n}\\r\\nint i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_DSAPrivateKey,fp,(unsigned char *)dsa));\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa)\\r\\n{\\r\\nreturn((DSA *)ASN1_d2i_bio((char *(*)())\\r\\nDSA_new,(char *(*)())d2i_DSAPrivateKey, (bp),\\r\\n(unsigned char **)(dsa)));\\r\\n}\\r\\nint i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_DSAPrivateKey,bp,(unsigned char *)dsa));\\r\\n}\\r\\nX509_ALGOR *X509_ALGOR_dup(X509_ALGOR *xn)\\r\\n{\\r\\nreturn((X509_ALGOR *)ASN1_dup((int (*)())i2d_X509_ALGOR,\\r\\n(char *(*)())d2i_X509_ALGOR,(char *)xn));\\r\\n}\\r\\nX509_NAME *X509_NAME_dup(X509_NAME *xn)\\r\\n{\\r\\nreturn((X509_NAME *)ASN1_dup((int (*)())i2d_X509_NAME,\\r\\n(char *(*)())d2i_X509_NAME,(char *)xn));\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nreturn((X509_NAME_ENTRY *)ASN1_dup((int (*)())i2d_X509_NAME_ENTRY,\\r\\n(char *(*)())d2i_X509_NAME_ENTRY,(char *)ne));\\r\\n}\\r\\nint X509_digest(X509 *data, EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_digest((int (*)())i2d_X509,type,(char *)data,md,len));\\r\\n}\\r\\nint X509_NAME_digest(X509_NAME *data, EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn(ASN1_digest((int (*)())i2d_X509_NAME,type,(char *)data,md,len));\\r\\n}\\r\\nint PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data, EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nreturn(ASN1_digest((int (*)())i2d_PKCS7_ISSUER_AND_SERIAL,type,\\r\\n(char *)data,md,len));\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8)\\r\\n{\\r\\nreturn((X509_SIG *)ASN1_d2i_fp((char *(*)())X509_SIG_new,\\r\\n(char *(*)())d2i_X509_SIG, (fp),(unsigned char **)(p8)));\\r\\n}\\r\\nint i2d_PKCS8_fp(FILE *fp, X509_SIG *p8)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_X509_SIG,fp,(unsigned char *)p8));\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8)\\r\\n{\\r\\nreturn((X509_SIG *)ASN1_d2i_bio((char *(*)())X509_SIG_new,\\r\\n(char *(*)())d2i_X509_SIG, (bp),(unsigned char **)(p8)));\\r\\n}\\r\\nint i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_X509_SIG,bp,(unsigned char *)p8));\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn((PKCS8_PRIV_KEY_INFO *)ASN1_d2i_fp(\\r\\n(char *(*)())PKCS8_PRIV_KEY_INFO_new,\\r\\n(char *(*)())d2i_PKCS8_PRIV_KEY_INFO, (fp),\\r\\n(unsigned char **)(p8inf)));\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn(ASN1_i2d_fp(i2d_PKCS8_PRIV_KEY_INFO,fp,(unsigned char *)p8inf));\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn((PKCS8_PRIV_KEY_INFO *)ASN1_d2i_bio(\\r\\n(char *(*)())PKCS8_PRIV_KEY_INFO_new,\\r\\n(char *(*)())d2i_PKCS8_PRIV_KEY_INFO, (bp),\\r\\n(unsigned char **)(p8inf)));\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn(ASN1_i2d_bio(i2d_PKCS8_PRIV_KEY_INFO,bp,(unsigned char *)p8inf));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_null_c", "target": 0, "func": "static void function(void)\\r\\n{\\r\\n}\\r\\nEVP_MD *EVP_md_null(void)\\r\\n{\\r\\nreturn(&null_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_err_c", "target": 0, "func": "void ERR_load_BN_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_BN,BN_str_functs);\\r\\nERR_load_strings(ERR_LIB_BN,BN_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_bcons_c", "target": 0, "func": "int i2d_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nif(a->ca) M_ASN1_I2D_len (a->ca, i2d_ASN1_BOOLEAN);\\r\\nM_ASN1_I2D_len (a->pathlen, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_seq_total();\\r\\nif (a->ca) M_ASN1_I2D_put (a->ca, i2d_ASN1_BOOLEAN);\\r\\nM_ASN1_I2D_put (a->pathlen, i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nBASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void)\\r\\n{\\r\\nBASIC_CONSTRAINTS *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, BASIC_CONSTRAINTS);\\r\\nret->ca = 0;\\r\\nret->pathlen = NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_BASIC_CONSTRAINTS_NEW);\\r\\n}\\r\\nBASIC_CONSTRAINTS *d2i_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,BASIC_CONSTRAINTS *,BASIC_CONSTRAINTS_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nif((M_ASN1_next & (~V_ASN1_CONSTRUCTED)) ==\\r\\n(V_ASN1_UNIVERSAL|V_ASN1_BOOLEAN) ) {\\r\\nM_ASN1_D2I_get_int (ret->ca, d2i_ASN1_BOOLEAN);\\r\\n}\\r\\nM_ASN1_D2I_get_opt (ret->pathlen, d2i_ASN1_INTEGER, V_ASN1_INTEGER);\\r\\nM_ASN1_D2I_Finish(a, BASIC_CONSTRAINTS_free, ASN1_F_D2I_BASIC_CONSTRAINTS);\\r\\n}\\r\\nvoid BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free (a->pathlen);\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_bags_c", "target": 0, "func": "int i2d_PKCS12_BAGS(PKCS12_BAGS *a, unsigned char **pp)\\r\\n{\\r\\nint bagnid, v = 0;\\r\\nM_ASN1_I2D_vars(a);\\r\\nbagnid = OBJ_obj2nid (a->type);\\r\\nM_ASN1_I2D_len (a->type, i2d_ASN1_OBJECT);\\r\\nswitch (bagnid) {\\r\\ncase NID_x509Certificate:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.x509cert,\\r\\ni2d_ASN1_OCTET_STRING, 0, v);\\r\\nbreak;\\r\\ncase NID_x509Crl:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.x509crl,\\r\\ni2d_ASN1_OCTET_STRING, 0, v);\\r\\nbreak;\\r\\ncase NID_sdsiCertificate:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.sdsicert,\\r\\ni2d_ASN1_IA5STRING, 0, v);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_len_EXP_opt (a->value.other,\\r\\ni2d_ASN1_TYPE, 0, v);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_seq_total ();\\r\\nM_ASN1_I2D_put (a->type, i2d_ASN1_OBJECT);\\r\\nswitch (bagnid) {\\r\\ncase NID_x509Certificate:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.x509cert,\\r\\ni2d_ASN1_OCTET_STRING, 0, v);\\r\\nbreak;\\r\\ncase NID_x509Crl:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.x509crl,\\r\\ni2d_ASN1_OCTET_STRING, 0, v);\\r\\nbreak;\\r\\ncase NID_sdsiCertificate:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.sdsicert,\\r\\ni2d_ASN1_IA5STRING, 0, v);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_I2D_put_EXP_opt (a->value.other, i2d_ASN1_TYPE, 0, v);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS12_BAGS *PKCS12_BAGS_new(void)\\r\\n{\\r\\nPKCS12_BAGS *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, PKCS12_BAGS);\\r\\nret->type=NULL;\\r\\nret->value.other=NULL;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS12_BAGS_NEW);\\r\\n}\\r\\nPKCS12_BAGS *d2i_PKCS12_BAGS(PKCS12_BAGS **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint bagnid;\\r\\nM_ASN1_D2I_vars(a,PKCS12_BAGS *,PKCS12_BAGS_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get (ret->type, d2i_ASN1_OBJECT);\\r\\nbagnid = OBJ_obj2nid (ret->type);\\r\\nswitch (bagnid) {\\r\\ncase NID_x509Certificate:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.x509cert,\\r\\nd2i_ASN1_OCTET_STRING, 0);\\r\\nbreak;\\r\\ncase NID_x509Crl:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.x509crl,\\r\\nd2i_ASN1_OCTET_STRING, 0);\\r\\nbreak;\\r\\ncase NID_sdsiCertificate:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.sdsicert,\\r\\nd2i_ASN1_IA5STRING, 0);\\r\\nbreak;\\r\\ndefault:\\r\\nM_ASN1_D2I_get_EXP_opt (ret->value.other,\\r\\nd2i_ASN1_TYPE, 0);\\r\\nbreak;\\r\\n}\\r\\nM_ASN1_D2I_Finish(a, PKCS12_BAGS_free, ASN1_F_D2I_PKCS12_BAGS);\\r\\n}\\r\\nvoid PKCS12_BAGS_free (PKCS12_BAGS *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nswitch (OBJ_obj2nid(a->type)) {\\r\\ncase NID_x509Certificate:\\r\\nASN1_OCTET_STRING_free (a->value.x509cert);\\r\\nbreak;\\r\\ncase NID_x509Crl:\\r\\nASN1_OCTET_STRING_free (a->value.x509crl);\\r\\nbreak;\\r\\ncase NID_sdsiCertificate:\\r\\nASN1_IA5STRING_free (a->value.sdsicert);\\r\\nbreak;\\r\\ndefault:\\r\\nASN1_TYPE_free (a->value.other);\\r\\nbreak;\\r\\n}\\r\\nASN1_OBJECT_free (a->type);\\r\\nFree ((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_f_enum_c", "target": 0, "func": "int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)\\r\\n{\\r\\nint i,n=0;\\r\\nstatic const char *h=\"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL) return(0);\\r\\nif (a->length == 0)\\r\\n{\\r\\nif (BIO_write(bp,\"00\",2) != 2) goto err;\\r\\nn=2;\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nif ((i != 0) && (i%35 == 0))\\r\\n{\\r\\nif (BIO_write(bp,\"\\\\\\n\",2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\nbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];\\r\\nbuf[1]=h[((unsigned char)a->data[i] )&0x0f];\\r\\nif (BIO_write(bp,buf,2) != 2) goto err;\\r\\nn+=2;\\r\\n}\\r\\n}\\r\\nreturn(n);\\r\\nerr:\\r\\nreturn(-1);\\r\\n}\\r\\nint a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nint i,j,k,m,n,again,bufsize;\\r\\nunsigned char *s=NULL,*sp;\\r\\nunsigned char *bufp;\\r\\nint num=0,slen=0,first=1;\\r\\nbs->type=V_ASN1_ENUMERATED;\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nfor (;;)\\r\\n{\\r\\nif (bufsize < 1) goto err_sl;\\r\\ni=bufsize;\\r\\nif (buf[i-1] == '\\n') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nif (buf[i-1] == '\\r') buf[--i]='\\0';\\r\\nif (i == 0) goto err_sl;\\r\\nagain=(buf[i-1] == '\\\\');\\r\\nfor (j=0; j<i; j++)\\r\\n{\\r\\nif (!( ((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n{\\r\\ni=j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i]='\\0';\\r\\nif (i < 2) goto err_sl;\\r\\nbufp=(unsigned char *)buf;\\r\\nif (first)\\r\\n{\\r\\nfirst=0;\\r\\nif ((bufp[0] == '0') && (buf[1] == '0'))\\r\\n{\\r\\nbufp+=2;\\r\\ni-=2;\\r\\n}\\r\\n}\\r\\nk=0;\\r\\ni-=again;\\r\\nif (i%2 != 0)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni/=2;\\r\\nif (num+i > slen)\\r\\n{\\r\\nif (s == NULL)\\r\\nsp=(unsigned char *)Malloc(\\r\\n(unsigned int)num+i*2);\\r\\nelse\\r\\nsp=(unsigned char *)Realloc(s,\\r\\n(unsigned int)num+i*2);\\r\\nif (sp == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL) Free((char *)s);\\r\\ngoto err;\\r\\n}\\r\\ns=sp;\\r\\nslen=num+i*2;\\r\\n}\\r\\nfor (j=0; j<i; j++,k+=2)\\r\\n{\\r\\nfor (n=0; n<2; n++)\\r\\n{\\r\\nm=bufp[k+n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm-='0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm=m-'a'+10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm=m-'A'+10;\\r\\nelse\\r\\n{\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num+j]<<=4;\\r\\ns[num+j]|=m;\\r\\n}\\r\\n}\\r\\nnum+=i;\\r\\nif (again)\\r\\nbufsize=BIO_gets(bp,buf,size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length=num;\\r\\nbs->data=s;\\r\\nret=1;\\r\\nerr:\\r\\nif (0)\\r\\n{\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_ENUMERATED,ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bn_blind_c", "target": 0, "func": "BN_BLINDING *BN_BLINDING_new(BIGNUM *A, BIGNUM *Ai, BIGNUM *mod)\\r\\n{\\r\\nBN_BLINDING *ret=NULL;\\r\\nbn_check_top(Ai);\\r\\nbn_check_top(mod);\\r\\nif ((ret=(BN_BLINDING *)Malloc(sizeof(BN_BLINDING))) == NULL)\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(BN_BLINDING));\\r\\nif ((ret->A=BN_new()) == NULL) goto err;\\r\\nif ((ret->Ai=BN_new()) == NULL) goto err;\\r\\nif (!BN_copy(ret->A,A)) goto err;\\r\\nif (!BN_copy(ret->Ai,Ai)) goto err;\\r\\nret->mod=mod;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != NULL) BN_BLINDING_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nvoid BN_BLINDING_free(BN_BLINDING *r)\\r\\n{\\r\\nif(r == NULL)\\r\\nreturn;\\r\\nif (r->A != NULL) BN_free(r->A );\\r\\nif (r->Ai != NULL) BN_free(r->Ai);\\r\\nFree(r);\\r\\n}\\r\\nint BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret=0;\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_UPDATE,BN_R_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(b->A,b->A,b->A,b->mod,ctx)) goto err;\\r\\nif (!BN_mod_mul(b->Ai,b->Ai,b->Ai,b->mod,ctx)) goto err;\\r\\nret=1;\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nbn_check_top(n);\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_CONVERT,BN_R_NOT_INITIALIZED);\\r\\nreturn(0);\\r\\n}\\r\\nreturn(BN_mod_mul(n,n,b->A,b->mod,ctx));\\r\\n}\\r\\nint BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(n);\\r\\nif ((b->A == NULL) || (b->Ai == NULL))\\r\\n{\\r\\nBNerr(BN_F_BN_BLINDING_INVERT,BN_R_NOT_INITIALIZED);\\r\\nreturn(0);\\r\\n}\\r\\nif ((ret=BN_mod_mul(n,n,b->Ai,b->mod,ctx)) >= 0)\\r\\n{\\r\\nif (!BN_BLINDING_update(b,ctx))\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_set_c", "target": 0, "func": "int X509_set_version(X509 *x, long version)\\r\\n{\\r\\nif (x == NULL) return(0);\\r\\nif (x->cert_info->version == NULL)\\r\\n{\\r\\nif ((x->cert_info->version=ASN1_INTEGER_new()) == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nreturn(ASN1_INTEGER_set(x->cert_info->version,version));\\r\\n}\\r\\nint X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *in;\\r\\nif (x == NULL) return(0);\\r\\nin=x->cert_info->serialNumber;\\r\\nif (in != serial)\\r\\n{\\r\\nin=ASN1_INTEGER_dup(serial);\\r\\nif (in != NULL)\\r\\n{\\r\\nASN1_INTEGER_free(x->cert_info->serialNumber);\\r\\nx->cert_info->serialNumber=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_issuer_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->cert_info->issuer,name));\\r\\n}\\r\\nint X509_set_subject_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_NAME_set(&x->cert_info->subject,name));\\r\\n}\\r\\nint X509_set_notBefore(X509 *x, ASN1_UTCTIME *tm)\\r\\n{\\r\\nASN1_UTCTIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL)) return(0);\\r\\nin=x->cert_info->validity->notBefore;\\r\\nif (in != tm)\\r\\n{\\r\\nin=ASN1_UTCTIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nASN1_UTCTIME_free(x->cert_info->validity->notBefore);\\r\\nx->cert_info->validity->notBefore=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_notAfter(X509 *x, ASN1_UTCTIME *tm)\\r\\n{\\r\\nASN1_UTCTIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL)) return(0);\\r\\nin=x->cert_info->validity->notAfter;\\r\\nif (in != tm)\\r\\n{\\r\\nin=ASN1_UTCTIME_dup(tm);\\r\\nif (in != NULL)\\r\\n{\\r\\nASN1_UTCTIME_free(x->cert_info->validity->notAfter);\\r\\nx->cert_info->validity->notAfter=in;\\r\\n}\\r\\n}\\r\\nreturn(in != NULL);\\r\\n}\\r\\nint X509_set_pubkey(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL)) return(0);\\r\\nreturn(X509_PUBKEY_set(&(x->cert_info->key),pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc2cfb64_c", "target": 0, "func": "void RC2_cfb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nRC2_KEY *schedule, unsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv,c,cc;\\r\\niv=(unsigned char *)ivec;\\r\\nif (encrypt)\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\nc= *(in++)^iv[n];\\r\\n*(out++)=c;\\r\\niv[n]=c;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nc2l(iv,v0); ti[0]=v0;\\r\\nc2l(iv,v1); ti[1]=v1;\\r\\nRC2_encrypt((unsigned long *)ti,schedule);\\r\\niv=(unsigned char *)ivec;\\r\\nt=ti[0]; l2c(t,iv);\\r\\nt=ti[1]; l2c(t,iv);\\r\\niv=(unsigned char *)ivec;\\r\\n}\\r\\ncc= *(in++);\\r\\nc=iv[n];\\r\\niv[n]=cc;\\r\\n*(out++)=c^cc;\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\n}\\r\\nv0=v1=ti[0]=ti[1]=t=c=cc=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_r5_c", "target": 0, "func": "EVP_CIPHER *EVP_rc5_32_12_16_cfb(void)\\r\\n{\\r\\nreturn(&rc5_cfb_cipher);\\r\\n}\\r\\nstatic void rc5_32_12_16_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nRC5_32_set_key(&(ctx->c.rc5_ks),EVP_RC5_32_12_16_KEY_SIZE,key,\\r\\nRC5_12_ROUNDS);\\r\\n}\\r\\nstatic void rc5_32_12_16_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC5_32_cfb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.rc5_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i_ecb_c", "target": 0, "func": "const char *idea_options(void)\\r\\n{\\r\\nif (sizeof(short) != sizeof(IDEA_INT))\\r\\nreturn(\"idea(int)\");\\r\\nelse\\r\\nreturn(\"idea(short)\");\\r\\n}\\r\\nvoid idea_ecb_encrypt(unsigned char *in, unsigned char *out,\\r\\nIDEA_KEY_SCHEDULE *ks)\\r\\n{\\r\\nunsigned long l0,l1,d[2];\\r\\nn2l(in,l0); d[0]=l0;\\r\\nn2l(in,l1); d[1]=l1;\\r\\nidea_encrypt(d,ks);\\r\\nl0=d[0]; l2n(l0,out);\\r\\nl1=d[1]; l2n(l1,out);\\r\\nl0=l1=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t_req_c", "target": 0, "func": "int X509_REQ_print_fp(FILE *fp, X509_REQ *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b=BIO_new(BIO_s_file())) == NULL)\\r\\n{\\r\\nX509err(X509_F_X509_REQ_PRINT_FP,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nBIO_set_fp(b,fp,BIO_NOCLOSE);\\r\\nret=X509_REQ_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn(ret);\\r\\n}\\r\\nint X509_REQ_print(BIO *bp, X509_REQ *x)\\r\\n{\\r\\nunsigned long l;\\r\\nint i,n;\\r\\nchar *s;\\r\\nconst char *neg;\\r\\nX509_REQ_INFO *ri;\\r\\nEVP_PKEY *pkey;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nchar str[128];\\r\\nri=x->req_info;\\r\\nsprintf(str,\"Certificate Request:\\n\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nsprintf(str,\"%4sData:\\n\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nneg=(ri->version->type == V_ASN1_NEG_INTEGER)?\"-\":\"\";\\r\\nl=0;\\r\\nfor (i=0; i<ri->version->length; i++)\\r\\n{ l<<=8; l+=ri->version->data[i]; }\\r\\nsprintf(str,\"%8sVersion: %s%lu (%s0x%lx)\\n\",\"\",neg,l,neg,l);\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nsprintf(str,\"%8sSubject: \",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nX509_NAME_print(bp,ri->subject,16);\\r\\nsprintf(str,\"\\n%8sSubject Public Key Info:\\n\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\ni=OBJ_obj2nid(ri->pubkey->algor->algorithm);\\r\\nsprintf(str,\"%12sPublic Key Algorithm: %s\\n\",\"\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i));\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\npkey=X509_REQ_get_pubkey(x);\\r\\n#ifndef NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sRSA Public Key: (%d bit)\\n\",\"\",\\r\\nBN_num_bits(pkey->pkey.rsa->n));\\r\\nRSA_print(bp,pkey->pkey.rsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\n{\\r\\nBIO_printf(bp,\"%12sDSA Public Key:\\n\",\"\");\\r\\nDSA_print(bp,pkey->pkey.dsa,16);\\r\\n}\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(bp,\"%12sUnknown Public Key:\\n\",\"\");\\r\\nEVP_PKEY_free(pkey);\\r\\nsprintf(str,\"%8sAttributes:\\n\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nsk=x->req_info->attributes;\\r\\nif ((sk == NULL) || (sk_X509_ATTRIBUTE_num(sk) == 0))\\r\\n{\\r\\nif (!x->req_info->req_kludge)\\r\\n{\\r\\nsprintf(str,\"%12sa0:00\\n\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)\\r\\n{\\r\\nASN1_TYPE *at;\\r\\nX509_ATTRIBUTE *a;\\r\\nASN1_BIT_STRING *bs=NULL;\\r\\nASN1_TYPE *t;\\r\\nint j,type=0,count=1,ii=0;\\r\\na=sk_X509_ATTRIBUTE_value(sk,i);\\r\\nsprintf(str,\"%12s\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nif ((j=i2a_ASN1_OBJECT(bp,a->object)) > 0)\\r\\n{\\r\\nif (a->set)\\r\\n{\\r\\nii=0;\\r\\ncount=sk_ASN1_TYPE_num(a->value.set);\\r\\nget_next:\\r\\nat=sk_ASN1_TYPE_value(a->value.set,ii);\\r\\ntype=at->type;\\r\\nbs=at->value.asn1_string;\\r\\n}\\r\\nelse\\r\\n{\\r\\nt=a->value.single;\\r\\ntype=t->type;\\r\\nbs=t->value.bit_string;\\r\\n}\\r\\n}\\r\\nfor (j=25-j; j>0; j--)\\r\\nif (BIO_write(bp,\" \",1) != 1) goto err;\\r\\nif (BIO_puts(bp,\":\") <= 0) goto err;\\r\\nif ( (type == V_ASN1_PRINTABLESTRING) ||\\r\\n(type == V_ASN1_T61STRING) ||\\r\\n(type == V_ASN1_IA5STRING))\\r\\n{\\r\\nif (BIO_write(bp,(char *)bs->data,bs->length)\\r\\n!= bs->length)\\r\\ngoto err;\\r\\nBIO_puts(bp,\"\\n\");\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_puts(bp,\"unable to print attribute\\n\");\\r\\n}\\r\\nif (++ii < count) goto get_next;\\r\\n}\\r\\n}\\r\\ni=OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nsprintf(str,\"%4sSignature Algorithm: %s\",\"\",\\r\\n(i == NID_undef)?\"UNKNOWN\":OBJ_nid2ln(i));\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\nn=x->signature->length;\\r\\ns=(char *)x->signature->data;\\r\\nfor (i=0; i<n; i++)\\r\\n{\\r\\nif ((i%18) == 0)\\r\\n{\\r\\nsprintf(str,\"\\n%8s\",\"\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nsprintf(str,\"%02x%s\",(unsigned char)s[i],((i+1) == n)?\"\":\":\");\\r\\nif (BIO_puts(bp,str) <= 0) goto err;\\r\\n}\\r\\nif (BIO_puts(bp,\"\\n\") <= 0) goto err;\\r\\nreturn(1);\\r\\nerr:\\r\\nX509err(X509_F_X509_REQ_PRINT,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ultrixcc_c", "target": 0, "func": "main()\\r\\n{\\r\\nf(5);\\r\\nf(0);\\r\\n}\\r\\nint f(a)\\r\\nint a;\\r\\n{\\r\\nswitch(a&7)\\r\\n{\\r\\ncase 7:\\r\\nprintf(\"7\\n\");\\r\\ncase 6:\\r\\nprintf(\"6\\n\");\\r\\ncase 5:\\r\\nprintf(\"5\\n\");\\r\\ncase 4:\\r\\nprintf(\"4\\n\");\\r\\ncase 3:\\r\\nprintf(\"3\\n\");\\r\\ncase 2:\\r\\nprintf(\"2\\n\");\\r\\ncase 1:\\r\\nprintf(\"1\\n\");\\r\\n#ifdef FIX_BUG\\r\\ncase 0:\\r\\n;\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_sig_c", "target": 0, "func": "int i2d_X509_SIG(X509_SIG *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->digest, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->algor, i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->digest, i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_SIG *d2i_X509_SIG(X509_SIG **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_SIG *,X509_SIG_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->digest,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,X509_SIG_free,ASN1_F_D2I_X509_SIG);\\r\\n}\\r\\nX509_SIG *X509_SIG_new(void)\\r\\n{\\r\\nX509_SIG *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_SIG);\\r\\nM_ASN1_New(ret->algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->digest,ASN1_OCTET_STRING_new);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_SIG_NEW);\\r\\n}\\r\\nvoid X509_SIG_free(X509_SIG *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nX509_ALGOR_free(a->algor);\\r\\nASN1_OCTET_STRING_free(a->digest);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_mdc2_c", "target": 0, "func": "EVP_MD *EVP_mdc2(void)\\r\\n{\\r\\nreturn(&mdc2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_buffer_c", "target": 1, "func": "BUF_MEM *BUF_MEM_new(void)\\r\\n{\\r\\nBUF_MEM *ret;\\r\\nret=Malloc(sizeof(BUF_MEM));\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEM_NEW,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nret->length=0;\\r\\nret->max=0;\\r\\nret->data=NULL;\\r\\nreturn(ret);\\r\\n}\\r\\nvoid BUF_MEM_free(BUF_MEM *a)\\r\\n{\\r\\nif(a == NULL)\\r\\nreturn;\\r\\nif (a->data != NULL)\\r\\n{\\r\\nmemset(a->data,0,(unsigned int)a->max);\\r\\nFree(a->data);\\r\\n}\\r\\nFree(a);\\r\\n}\\r\\nint BUF_MEM_grow(BUF_MEM *str, int len)\\r\\n{\\r\\nchar *ret;\\r\\nunsigned int n;\\r\\nif (str->length >= len)\\r\\n{\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nif (str->max >= len)\\r\\n{\\r\\nmemset(&str->data[str->length],0,len-str->length);\\r\\nstr->length=len;\\r\\nreturn(len);\\r\\n}\\r\\nn=(len+3)/3*4;\\r\\nif (str->data == NULL)\\r\\nret=Malloc(n);\\r\\nelse\\r\\nret=Realloc(str->data,n);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_MEM_GROW,ERR_R_MALLOC_FAILURE);\\r\\nlen=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nstr->data=ret;\\r\\nstr->length=len;\\r\\nstr->max=n;\\r\\n}\\r\\nreturn(len);\\r\\n}\\r\\nchar *BUF_strdup(const char *str)\\r\\n{\\r\\nchar *ret;\\r\\nint n;\\r\\nif (str == NULL) return(NULL);\\r\\nn=strlen(str);\\r\\nret=Malloc(n+1);\\r\\nif (ret == NULL)\\r\\n{\\r\\nBUFerr(BUF_F_BUF_STRDUP,ERR_R_MALLOC_FAILURE);\\r\\nreturn(NULL);\\r\\n}\\r\\nmemcpy(ret,str,n+1);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_ofb64_c", "target": 0, "func": "void BF_ofb64_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nBF_KEY *schedule, unsigned char *ivec, int *num)\\r\\n{\\r\\nregister BF_LONG v0,v1,t;\\r\\nregister int n= *num;\\r\\nregister long l=length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save=0;\\r\\niv=(unsigned char *)ivec;\\r\\nn2l(iv,v0);\\r\\nn2l(iv,v1);\\r\\nti[0]=v0;\\r\\nti[1]=v1;\\r\\ndp=(char *)d;\\r\\nl2n(v0,dp);\\r\\nl2n(v1,dp);\\r\\nwhile (l--)\\r\\n{\\r\\nif (n == 0)\\r\\n{\\r\\nBF_encrypt((BF_LONG *)ti,schedule);\\r\\ndp=(char *)d;\\r\\nt=ti[0]; l2n(t,dp);\\r\\nt=ti[1]; l2n(t,dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++)= *(in++)^d[n];\\r\\nn=(n+1)&0x07;\\r\\n}\\r\\nif (save)\\r\\n{\\r\\nv0=ti[0];\\r\\nv1=ti[1];\\r\\niv=(unsigned char *)ivec;\\r\\nl2n(v0,iv);\\r\\nl2n(v1,iv);\\r\\n}\\r\\nt=v0=v1=ti[0]=ti[1]=0;\\r\\n*num=n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_encode_c", "target": 1, "func": "void EVP_EncodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length=48;\\r\\nctx->num=0;\\r\\nctx->line_num=0;\\r\\n}\\r\\nvoid EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nint i,j;\\r\\nunsigned int total=0;\\r\\n*outl=0;\\r\\nif (inl == 0) return;\\r\\nif ((ctx->num+inl) < ctx->length)\\r\\n{\\r\\nmemcpy(&(ctx->enc_data[ctx->num]),in,inl);\\r\\nctx->num+=inl;\\r\\nreturn;\\r\\n}\\r\\nif (ctx->num != 0)\\r\\n{\\r\\ni=ctx->length-ctx->num;\\r\\nmemcpy(&(ctx->enc_data[ctx->num]),in,i);\\r\\nin+=i;\\r\\ninl-=i;\\r\\nj=EVP_EncodeBlock(out,ctx->enc_data,ctx->length);\\r\\nctx->num=0;\\r\\nout+=j;\\r\\n*(out++)='\\n';\\r\\n*out='\\0';\\r\\ntotal=j+1;\\r\\n}\\r\\nwhile (inl >= ctx->length)\\r\\n{\\r\\nj=EVP_EncodeBlock(out,in,ctx->length);\\r\\nin+=ctx->length;\\r\\ninl-=ctx->length;\\r\\nout+=j;\\r\\n*(out++)='\\n';\\r\\n*out='\\0';\\r\\ntotal+=j+1;\\r\\n}\\r\\nif (inl != 0)\\r\\nmemcpy(&(ctx->enc_data[0]),in,inl);\\r\\nctx->num=inl;\\r\\n*outl=total;\\r\\n}\\r\\nvoid EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nunsigned int ret=0;\\r\\nif (ctx->num != 0)\\r\\n{\\r\\nret=EVP_EncodeBlock(out,ctx->enc_data,ctx->num);\\r\\nout[ret++]='\\n';\\r\\nout[ret]='\\0';\\r\\nctx->num=0;\\r\\n}\\r\\n*outl=ret;\\r\\n}\\r\\nint EVP_EncodeBlock(unsigned char *t, unsigned char *f, int dlen)\\r\\n{\\r\\nint i,ret=0;\\r\\nunsigned long l;\\r\\nfor (i=dlen; i > 0; i-=3)\\r\\n{\\r\\nif (i >= 3)\\r\\n{\\r\\nl= (((unsigned long)f[0])<<16L)|\\r\\n(((unsigned long)f[1])<< 8L)|f[2];\\r\\n*(t++)=conv_bin2ascii(l>>18L);\\r\\n*(t++)=conv_bin2ascii(l>>12L);\\r\\n*(t++)=conv_bin2ascii(l>> 6L);\\r\\n*(t++)=conv_bin2ascii(l );\\r\\n}\\r\\nelse\\r\\n{\\r\\nl=((unsigned long)f[0])<<16L;\\r\\nif (i == 2) l|=((unsigned long)f[1]<<8L);\\r\\n*(t++)=conv_bin2ascii(l>>18L);\\r\\n*(t++)=conv_bin2ascii(l>>12L);\\r\\n*(t++)=(i == 1)?'=':conv_bin2ascii(l>> 6L);\\r\\n*(t++)='=';\\r\\n}\\r\\nret+=4;\\r\\nf+=3;\\r\\n}\\r\\n*t='\\0';\\r\\nreturn(ret);\\r\\n}\\r\\nvoid EVP_DecodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length=30;\\r\\nctx->num=0;\\r\\nctx->line_num=0;\\r\\nctx->expect_nl=0;\\r\\n}\\r\\nint EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nunsigned char *in, int inl)\\r\\n{\\r\\nint seof= -1,eof=0,rv= -1,ret=0,i,v,tmp,n,ln,tmp2,exp_nl;\\r\\nunsigned char *d;\\r\\nn=ctx->num;\\r\\nd=ctx->enc_data;\\r\\nln=ctx->line_num;\\r\\nexp_nl=ctx->expect_nl;\\r\\nif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF)))\\r\\n{ rv=0; goto end; }\\r\\nfor (i=0; i<inl; i++)\\r\\n{\\r\\nif (ln >= 80) { rv= -1; goto end; }\\r\\ntmp= *(in++);\\r\\nv=conv_ascii2bin(tmp);\\r\\nif (!B64_NOT_BASE64(v))\\r\\n{\\r\\nd[n++]=tmp;\\r\\nln++;\\r\\n}\\r\\nelse if (v == B64_ERROR)\\r\\n{\\r\\nrv= -1;\\r\\ngoto end;\\r\\n}\\r\\nif (tmp == '=')\\r\\n{\\r\\nif (seof == -1) seof=n;\\r\\neof++;\\r\\n}\\r\\nif (v == B64_EOLN)\\r\\n{\\r\\nln=0;\\r\\nif (exp_nl)\\r\\n{\\r\\nexp_nl=0;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nexp_nl=0;\\r\\nif (((i+1) == inl) && (((n&3) == 0) || eof))\\r\\nv=B64_EOF;\\r\\nif ((v == B64_EOF) || (n >= 64))\\r\\n{\\r\\nif ((v != B64_EOF) && (n >= 64)) exp_nl=1;\\r\\ntmp2=v;\\r\\nif (n > 0)\\r\\n{\\r\\nv=EVP_DecodeBlock(out,d,n);\\r\\nif (v < 0) { rv=0; goto end; }\\r\\nn=0;\\r\\nret+=(v-eof);\\r\\n}\\r\\nelse\\r\\n{\\r\\neof=1;\\r\\nv=0;\\r\\n}\\r\\nif ((v < ctx->length) && eof)\\r\\n{\\r\\nrv=0;\\r\\ngoto end;\\r\\n}\\r\\nelse\\r\\nctx->length=v;\\r\\nif (seof >= 0) { rv=0; goto end; }\\r\\nout+=v;\\r\\n}\\r\\n}\\r\\nrv=1;\\r\\nend:\\r\\n*outl=ret;\\r\\nctx->num=n;\\r\\nctx->line_num=ln;\\r\\nctx->expect_nl=exp_nl;\\r\\nreturn(rv);\\r\\n}\\r\\nint EVP_DecodeBlock(unsigned char *t, unsigned char *f, int n)\\r\\n{\\r\\nint i,ret=0,a,b,c,d;\\r\\nunsigned long l;\\r\\nwhile ((conv_ascii2bin(*f) == B64_WS) && (n > 0))\\r\\n{\\r\\nf++;\\r\\nn--;\\r\\n}\\r\\nwhile ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n-1]))))\\r\\nn--;\\r\\nif (n%4 != 0) return(-1);\\r\\nfor (i=0; i<n; i+=4)\\r\\n{\\r\\na=conv_ascii2bin(*(f++));\\r\\nb=conv_ascii2bin(*(f++));\\r\\nc=conv_ascii2bin(*(f++));\\r\\nd=conv_ascii2bin(*(f++));\\r\\nif ( (a & 0x80) || (b & 0x80) ||\\r\\n(c & 0x80) || (d & 0x80))\\r\\nreturn(-1);\\r\\nl=( (((unsigned long)a)<<18L)|\\r\\n(((unsigned long)b)<<12L)|\\r\\n(((unsigned long)c)<< 6L)|\\r\\n(((unsigned long)d) ));\\r\\n*(t++)=(unsigned char)(l>>16L)&0xff;\\r\\n*(t++)=(unsigned char)(l>> 8L)&0xff;\\r\\n*(t++)=(unsigned char)(l )&0xff;\\r\\nret+=3;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\n*outl=0;\\r\\nif (ctx->num != 0)\\r\\n{\\r\\ni=EVP_DecodeBlock(out,ctx->enc_data,ctx->num);\\r\\nif (i < 0) return(-1);\\r\\nctx->num=0;\\r\\n*outl=i;\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint EVP_DecodeValid(unsigned char *buf, int len)\\r\\n{\\r\\nint i,num=0,bad=0;\\r\\nif (len == 0) return(-1);\\r\\nwhile (conv_ascii2bin(*buf) == B64_WS)\\r\\n{\\r\\nbuf++;\\r\\nlen--;\\r\\nif (len == 0) return(-1);\\r\\n}\\r\\nfor (i=len; i >= 4; i-=4)\\r\\n{\\r\\nif ( (conv_ascii2bin(buf[0]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[1]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[2]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[3]) >= 0x40))\\r\\nreturn(-1);\\r\\nbuf+=4;\\r\\nnum+=1+(buf[2] != '=')+(buf[3] != '=');\\r\\n}\\r\\nif ((i == 1) && (conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn(num);\\r\\nif ((i == 2) && (conv_ascii2bin(buf[0]) == B64_EOLN) &&\\r\\n(conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn(num);\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_file_c", "target": 0, "func": "BIO *BIO_new_file(const char *filename, const char *mode)\\r\\n{\\r\\nBIO *ret;\\r\\nFILE *file;\\r\\nif ((file=fopen(filename,mode)) == NULL)\\r\\n{\\r\\nSYSerr(SYS_F_FOPEN,get_last_sys_error());\\r\\nERR_add_error_data(5,\"fopen('\",filename,\"','\",mode,\"')\");\\r\\nBIOerr(BIO_F_BIO_NEW_FILE,ERR_R_SYS_LIB);\\r\\nreturn(NULL);\\r\\n}\\r\\nif ((ret=BIO_new(BIO_s_file_internal())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_set_fp(ret,file,BIO_CLOSE);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO *BIO_new_fp(FILE *stream, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nif ((ret=BIO_new(BIO_s_file())) == NULL)\\r\\nreturn(NULL);\\r\\nBIO_set_fp(ret,stream,close_flag);\\r\\nreturn(ret);\\r\\n}\\r\\nBIO_METHOD *BIO_s_file(void)\\r\\n{\\r\\nreturn(&methods_filep);\\r\\n}\\r\\nstatic int MS_CALLBACK file_new(BIO *bi)\\r\\n{\\r\\nbi->init=0;\\r\\nbi->num=0;\\r\\nbi->ptr=NULL;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nif (a->shutdown)\\r\\n{\\r\\nif ((a->init) && (a->ptr != NULL))\\r\\n{\\r\\nfclose((FILE *)a->ptr);\\r\\na->ptr=NULL;\\r\\n}\\r\\na->init=0;\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (b->init && (out != NULL))\\r\\n{\\r\\nret=fread(out,1,(int)outl,(FILE *)b->ptr);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nif (b->init && (in != NULL))\\r\\n{\\r\\nif (fwrite(in,(int)inl,1,(FILE *)b->ptr))\\r\\nret=inl;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret=1;\\r\\nFILE *fp=(FILE *)b->ptr;\\r\\nFILE **fpp;\\r\\nchar p[4];\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_FILE_SEEK:\\r\\ncase BIO_CTRL_RESET:\\r\\nret=(long)fseek(fp,num,0);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nret=(long)feof(fp);\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret=ftell(fp);\\r\\nbreak;\\r\\ncase BIO_C_SET_FILE_PTR:\\r\\nfile_free(b);\\r\\nb->shutdown=(int)num&BIO_CLOSE;\\r\\nb->ptr=(char *)ptr;\\r\\nb->init=1;\\r\\n#if defined(MSDOS) || defined(WINDOWS)\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fileno((FILE *)ptr),_O_TEXT);\\r\\nelse\\r\\n_setmode(fileno((FILE *)ptr),_O_BINARY);\\r\\n#endif\\r\\nbreak;\\r\\ncase BIO_C_SET_FILENAME:\\r\\nfile_free(b);\\r\\nb->shutdown=(int)num&BIO_CLOSE;\\r\\nif (num & BIO_FP_APPEND)\\r\\n{\\r\\nif (num & BIO_FP_READ)\\r\\nstrcpy(p,\"a+\");\\r\\nelse strcpy(p,\"a\");\\r\\n}\\r\\nelse if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))\\r\\nstrcpy(p,\"r+\");\\r\\nelse if (num & BIO_FP_WRITE)\\r\\nstrcpy(p,\"w\");\\r\\nelse if (num & BIO_FP_READ)\\r\\nstrcpy(p,\"r\");\\r\\nelse\\r\\n{\\r\\nBIOerr(BIO_F_FILE_CTRL,BIO_R_BAD_FOPEN_MODE);\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\n#if defined(MSDOS) || defined(WINDOWS)\\r\\nif (!(num & BIO_FP_TEXT))\\r\\nstrcat(p,\"b\");\\r\\nelse\\r\\nstrcat(p,\"t\");\\r\\n#endif\\r\\nfp=fopen(ptr,p);\\r\\nif (fp == NULL)\\r\\n{\\r\\nSYSerr(SYS_F_FOPEN,get_last_sys_error());\\r\\nERR_add_error_data(5,\"fopen('\",ptr,\"','\",p,\"')\");\\r\\nBIOerr(BIO_F_FILE_CTRL,ERR_R_SYS_LIB);\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nb->ptr=(char *)fp;\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FILE_PTR:\\r\\nif (ptr != NULL)\\r\\n{\\r\\nfpp=(FILE **)ptr;\\r\\n*fpp=(FILE *)b->ptr;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret=(long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown=(int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nfflush((FILE *)b->ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint ret=0;\\r\\nbuf[0]='\\0';\\r\\nfgets(buf,size,(FILE *)bp->ptr);\\r\\nif (buf[0] != '\\0')\\r\\nret=strlen(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=file_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_ecb_c", "target": 0, "func": "const char *BF_options(void)\\r\\n{\\r\\n#ifdef BF_PTR\\r\\nreturn(\"blowfish(ptr)\");\\r\\n#elif defined(BF_PTR2)\\r\\nreturn(\"blowfish(ptr2)\");\\r\\n#else\\r\\nreturn(\"blowfish(idx)\");\\r\\n#endif\\r\\n}\\r\\nvoid BF_ecb_encrypt(unsigned char *in, unsigned char *out, BF_KEY *ks,\\r\\nint encrypt)\\r\\n{\\r\\nBF_LONG l,d[2];\\r\\nn2l(in,l); d[0]=l;\\r\\nn2l(in,l); d[1]=l;\\r\\nif (encrypt)\\r\\nBF_encrypt(d,ks);\\r\\nelse\\r\\nBF_decrypt(d,ks);\\r\\nl=d[0]; l2n(l,out);\\r\\nl=d[1]; l2n(l,out);\\r\\nl=d[0]=d[1]=0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_evp_key_c", "target": 0, "func": "void EVP_set_pw_prompt(char *prompt)\\r\\n{\\r\\nif (prompt == NULL)\\r\\nprompt_string[0]='\\0';\\r\\nelse\\r\\nstrncpy(prompt_string,prompt,79);\\r\\n}\\r\\nchar *EVP_get_pw_prompt(void)\\r\\n{\\r\\nif (prompt_string[0] == '\\0')\\r\\nreturn(NULL);\\r\\nelse\\r\\nreturn(prompt_string);\\r\\n}\\r\\nint EVP_read_pw_string(char *buf, int len, const char *prompt, int verify)\\r\\n{\\r\\nif ((prompt == NULL) && (prompt_string[0] != '\\0'))\\r\\nprompt=prompt_string;\\r\\nreturn(des_read_pw_string(buf,len,prompt,verify));\\r\\n}\\r\\nint EVP_BytesToKey(const EVP_CIPHER *type, EVP_MD *md, unsigned char *salt,\\r\\nunsigned char *data, int datal, int count, unsigned char *key,\\r\\nunsigned char *iv)\\r\\n{\\r\\nEVP_MD_CTX c;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nint niv,nkey,addmd=0;\\r\\nunsigned int mds=0,i;\\r\\nnkey=type->key_len;\\r\\nniv=type->iv_len;\\r\\nif (data == NULL) return(nkey);\\r\\nfor (;;)\\r\\n{\\r\\nEVP_DigestInit(&c,md);\\r\\nif (addmd++)\\r\\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\\r\\nEVP_DigestUpdate(&c,data,datal);\\r\\nif (salt != NULL)\\r\\nEVP_DigestUpdate(&c,salt,8);\\r\\nEVP_DigestFinal(&c,&(md_buf[0]),&mds);\\r\\nfor (i=1; i<(unsigned int)count; i++)\\r\\n{\\r\\nEVP_DigestInit(&c,md);\\r\\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\\r\\nEVP_DigestFinal(&c,&(md_buf[0]),&mds);\\r\\n}\\r\\ni=0;\\r\\nif (nkey)\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (nkey == 0) break;\\r\\nif (i == mds) break;\\r\\nif (key != NULL)\\r\\n*(key++)=md_buf[i];\\r\\nnkey--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif (niv && (i != mds))\\r\\n{\\r\\nfor (;;)\\r\\n{\\r\\nif (niv == 0) break;\\r\\nif (i == mds) break;\\r\\nif (iv != NULL)\\r\\n*(iv++)=md_buf[i];\\r\\nniv--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif ((nkey == 0) && (niv == 0)) break;\\r\\n}\\r\\nmemset(&c,0,sizeof(c));\\r\\nmemset(&(md_buf[0]),0,EVP_MAX_MD_SIZE);\\r\\nreturn(type->key_len);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dsa_key_c", "target": 0, "func": "int DSA_generate_key(DSA *dsa)\\r\\n{\\r\\nint ok=0;\\r\\nunsigned int i;\\r\\nBN_CTX *ctx=NULL;\\r\\nBIGNUM *pub_key=NULL,*priv_key=NULL;\\r\\nif ((ctx=BN_CTX_new()) == NULL) goto err;\\r\\nif (dsa->priv_key == NULL)\\r\\n{\\r\\nif ((priv_key=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npriv_key=dsa->priv_key;\\r\\ni=BN_num_bits(dsa->q);\\r\\nfor (;;)\\r\\n{\\r\\nBN_rand(priv_key,i,1,0);\\r\\nif (BN_cmp(priv_key,dsa->q) >= 0)\\r\\nBN_sub(priv_key,priv_key,dsa->q);\\r\\nif (!BN_is_zero(priv_key)) break;\\r\\n}\\r\\nif (dsa->pub_key == NULL)\\r\\n{\\r\\nif ((pub_key=BN_new()) == NULL) goto err;\\r\\n}\\r\\nelse\\r\\npub_key=dsa->pub_key;\\r\\nif (!BN_mod_exp(pub_key,dsa->g,priv_key,dsa->p,ctx)) goto err;\\r\\ndsa->priv_key=priv_key;\\r\\ndsa->pub_key=pub_key;\\r\\nok=1;\\r\\nerr:\\r\\nif ((pub_key != NULL) && (dsa->pub_key == NULL)) BN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dsa->priv_key == NULL)) BN_free(priv_key);\\r\\nif (ctx != NULL) BN_CTX_free(ctx);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_add_c", "target": 0, "func": "PKCS12_SAFEBAG *PKCS12_pack_safebag (char *obj, int (*i2d)(), int nid1,\\r\\nint nid2)\\r\\n{\\r\\nPKCS12_BAGS *bag;\\r\\nPKCS12_SAFEBAG *safebag;\\r\\nif (!(bag = PKCS12_BAGS_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(nid1);\\r\\nif (!ASN1_pack_string(obj, i2d, &bag->value.octet)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(safebag = PKCS12_SAFEBAG_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nsafebag->value.bag = bag;\\r\\nsafebag->type = OBJ_nid2obj(nid2);\\r\\nreturn safebag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG (PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nif (!(bag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_KEYBAG,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_keyBag);\\r\\nbag->value.keybag = p8;\\r\\nreturn bag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG (int pbe_nid, const char *pass,\\r\\nint passlen, unsigned char *salt, int saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nif (!(bag = PKCS12_SAFEBAG_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_pkcs8ShroudedKeyBag);\\r\\nif (!(bag->value.shkeybag =\\r\\nPKCS8_encrypt(pbe_nid, NULL, pass, passlen, salt, saltlen, iter,\\r\\np8))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn bag;\\r\\n}\\r\\nPKCS7 *PKCS12_pack_p7data (STACK *sk)\\r\\n{\\r\\nPKCS7 *p7;\\r\\nif (!(p7 = PKCS7_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np7->type = OBJ_nid2obj(NID_pkcs7_data);\\r\\nif (!(p7->d.data = ASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!ASN1_seq_pack(sk, i2d_PKCS12_SAFEBAG, &p7->d.data->data,\\r\\n&p7->d.data->length)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, PKCS12_R_CANT_PACK_STRUCTURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn p7;\\r\\n}\\r\\nPKCS7 *PKCS12_pack_p7encdata (int pbe_nid, const char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter, STACK *bags)\\r\\n{\\r\\nPKCS7 *p7;\\r\\nX509_ALGOR *pbe;\\r\\nif (!(p7 = PKCS7_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np7->type = OBJ_nid2obj(NID_pkcs7_encrypted);\\r\\nif (!(p7->d.encrypted = PKCS7_ENCRYPT_new ())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_set (p7->d.encrypted->version, 0);\\r\\np7->d.encrypted->enc_data->content_type = OBJ_nid2obj(NID_pkcs7_data);\\r\\nif (!(pbe = PKCS5_pbe_set (pbe_nid, iter, salt, saltlen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_ALGOR_free(p7->d.encrypted->enc_data->algorithm);\\r\\np7->d.encrypted->enc_data->algorithm = pbe;\\r\\nASN1_OCTET_STRING_free(p7->d.encrypted->enc_data->enc_data);\\r\\nif (!(p7->d.encrypted->enc_data->enc_data =\\r\\nPKCS12_i2d_encrypt (pbe, i2d_PKCS12_SAFEBAG, pass, passlen,\\r\\n(char *)bags, 1))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, PKCS12_R_ENCRYPT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn p7;\\r\\n}\\r\\nX509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,\\r\\nconst char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nX509_SIG *p8;\\r\\nX509_ALGOR *pbe;\\r\\nif (!(p8 = X509_SIG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(pbe_nid == -1) pbe = PKCS5_pbe2_set(cipher, iter, salt, saltlen);\\r\\nelse pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);\\r\\nif(!pbe) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_ALGOR_free(p8->algor);\\r\\np8->algor = pbe;\\r\\nASN1_OCTET_STRING_free(p8->digest);\\r\\nif (!(p8->digest =\\r\\nPKCS12_i2d_encrypt (pbe, i2d_PKCS8_PRIV_KEY_INFO, pass, passlen,\\r\\n(char *)p8inf, 0))) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, PKCS12_R_ENCRYPT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn p8;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i_skey_c", "target": 0, "func": "void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks)\\r\\n{\\r\\nint i;\\r\\nregister IDEA_INT *kt,*kf,r0,r1,r2;\\r\\nkt= &(ks->data[0][0]);\\r\\nn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);\\r\\nn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);\\r\\nkf=kt;\\r\\nkt+=8;\\r\\nfor (i=0; i<6; i++)\\r\\n{\\r\\nr2= kf[1];\\r\\nr1= kf[2];\\r\\n*(kt++)= ((r2<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[3];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[4];\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[5];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[6];\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\nr0= kf[7];\\r\\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\\r\\nr1= kf[0];\\r\\nif (i >= 5) break;\\r\\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\\r\\n*(kt++)= ((r1<<9) | (r2>>7))&0xffff;\\r\\nkf+=8;\\r\\n}\\r\\n}\\r\\nvoid idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)\\r\\n{\\r\\nint r;\\r\\nregister IDEA_INT *fp,*tp,t;\\r\\ntp= &(dk->data[0][0]);\\r\\nfp= &(ek->data[8][0]);\\r\\nfor (r=0; r<9; r++)\\r\\n{\\r\\n*(tp++)=inverse(fp[0]);\\r\\n*(tp++)=((int)(0x10000L-fp[2])&0xffff);\\r\\n*(tp++)=((int)(0x10000L-fp[1])&0xffff);\\r\\n*(tp++)=inverse(fp[3]);\\r\\nif (r == 8) break;\\r\\nfp-=6;\\r\\n*(tp++)=fp[4];\\r\\n*(tp++)=fp[5];\\r\\n}\\r\\ntp= &(dk->data[0][0]);\\r\\nt=tp[1];\\r\\ntp[1]=tp[2];\\r\\ntp[2]=t;\\r\\nt=tp[49];\\r\\ntp[49]=tp[50];\\r\\ntp[50]=t;\\r\\n}\\r\\nstatic IDEA_INT inverse(unsigned int xin)\\r\\n{\\r\\nlong n1,n2,q,r,b1,b2,t;\\r\\nif (xin == 0)\\r\\nb2=0;\\r\\nelse\\r\\n{\\r\\nn1=0x10001;\\r\\nn2=xin;\\r\\nb2=1;\\r\\nb1=0;\\r\\ndo {\\r\\nr=(n1%n2);\\r\\nq=(n1-r)/n2;\\r\\nif (r == 0)\\r\\n{ if (b2 < 0) b2=0x10001+b2; }\\r\\nelse\\r\\n{\\r\\nn1=n2;\\r\\nn2=r;\\r\\nt=b2;\\r\\nb2=b1-q*b2;\\r\\nb1=t;\\r\\n}\\r\\n} while (r != 0);\\r\\n}\\r\\nreturn((IDEA_INT)b2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_b_dump_c", "target": 0, "func": "int BIO_dump(BIO *bio, const char *s, int len)\\r\\n{\\r\\nint ret=0;\\r\\nchar buf[160+1],tmp[20];\\r\\nint i,j,rows,trunc;\\r\\nunsigned char ch;\\r\\ntrunc=0;\\r\\n#ifdef TRUNCATE\\r\\nfor(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\\0')); len--)\\r\\ntrunc++;\\r\\n#endif\\r\\nrows=(len/DUMP_WIDTH);\\r\\nif ((rows*DUMP_WIDTH)<len)\\r\\nrows++;\\r\\nfor(i=0;i<rows;i++) {\\r\\nbuf[0]='\\0';\\r\\nsprintf(tmp,\"%04x - \",i*DUMP_WIDTH);\\r\\nstrcpy(buf,tmp);\\r\\nfor(j=0;j<DUMP_WIDTH;j++) {\\r\\nif (((i*DUMP_WIDTH)+j)>=len) {\\r\\nstrcat(buf,\" \");\\r\\n} else {\\r\\nch=((unsigned char)*((char *)(s)+i*DUMP_WIDTH+j)) & 0xff;\\r\\nsprintf(tmp,\"%02x%c\",ch,j==7?'-':' ');\\r\\nstrcat(buf,tmp);\\r\\n}\\r\\n}\\r\\nstrcat(buf,\" \");\\r\\nfor(j=0;j<DUMP_WIDTH;j++) {\\r\\nif (((i*DUMP_WIDTH)+j)>=len)\\r\\nbreak;\\r\\nch=((unsigned char)*((char *)(s)+i*DUMP_WIDTH+j)) & 0xff;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nsprintf(tmp,\"%c\",((ch>=' ')&&(ch<='~'))?ch:'.');\\r\\n#else\\r\\nsprintf(tmp,\"%c\",((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))\\r\\n? os_toebcdic[ch]\\r\\n: '.');\\r\\n#endif\\r\\nstrcat(buf,tmp);\\r\\n}\\r\\nstrcat(buf,\"\\n\");\\r\\nret+=BIO_write(bio,(char *)buf,strlen(buf));\\r\\n}\\r\\n#ifdef TRUNCATE\\r\\nif (trunc > 0) {\\r\\nsprintf(buf,\"%04x - <SPACES/NULS>\\n\",len+trunc);\\r\\nret+=BIO_write(bio,(char *)buf,strlen(buf));\\r\\n}\\r\\n#endif\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_randfile_c", "target": 0, "func": "int RAND_load_file(const char *file, long bytes)\\r\\n{\\r\\nMS_STATIC unsigned char buf[BUFSIZE];\\r\\nstruct stat sb;\\r\\nint i,ret=0,n;\\r\\nFILE *in;\\r\\nif (file == NULL) return(0);\\r\\ni=stat(file,&sb);\\r\\nRAND_seed(&sb,sizeof(sb));\\r\\nret+=sizeof(sb);\\r\\nif (i < 0) return(0);\\r\\nif (bytes <= 0) return(ret);\\r\\nin=fopen(file,\"rb\");\\r\\nif (in == NULL) goto err;\\r\\nfor (;;)\\r\\n{\\r\\nn=(bytes < BUFSIZE)?(int)bytes:BUFSIZE;\\r\\ni=fread(buf,1,n,in);\\r\\nif (i <= 0) break;\\r\\nRAND_seed(buf,n);\\r\\nret+=i;\\r\\nbytes-=n;\\r\\nif (bytes <= 0) break;\\r\\n}\\r\\nfclose(in);\\r\\nmemset(buf,0,BUFSIZE);\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nint RAND_write_file(const char *file)\\r\\n{\\r\\nunsigned char buf[BUFSIZE];\\r\\nint i,ret=0;\\r\\nFILE *out;\\r\\nint n;\\r\\nout=fopen(file,\"rb+\");\\r\\nif (out == NULL && errno == ENOENT)\\r\\n{\\r\\nerrno = 0;\\r\\nout=fopen(file,\"wb\");\\r\\n}\\r\\nif (out == NULL) goto err;\\r\\nchmod(file,0600);\\r\\nn=RAND_DATA;\\r\\nfor (;;)\\r\\n{\\r\\ni=(n > BUFSIZE)?BUFSIZE:n;\\r\\nn-=BUFSIZE;\\r\\nRAND_bytes(buf,i);\\r\\ni=fwrite(buf,1,i,out);\\r\\nif (i <= 0)\\r\\n{\\r\\nret=0;\\r\\nbreak;\\r\\n}\\r\\nret+=i;\\r\\nif (n <= 0) break;\\r\\n}\\r\\nfclose(out);\\r\\nmemset(buf,0,BUFSIZE);\\r\\nerr:\\r\\nreturn(ret);\\r\\n}\\r\\nchar *RAND_file_name(char *buf, int size)\\r\\n{\\r\\nchar *s;\\r\\nchar *ret=NULL;\\r\\ns=getenv(\"RANDFILE\");\\r\\nif (s != NULL)\\r\\n{\\r\\nstrncpy(buf,s,size-1);\\r\\nbuf[size-1]='\\0';\\r\\nret=buf;\\r\\n}\\r\\nelse\\r\\n{\\r\\ns=getenv(\"HOME\");\\r\\nif (s == NULL) return(RFILE);\\r\\nif (((int)(strlen(s)+strlen(RFILE)+2)) > size)\\r\\nreturn(RFILE);\\r\\nstrcpy(buf,s);\\r\\n#ifndef VMS\\r\\nstrcat(buf,\"/\");\\r\\n#endif\\r\\nstrcat(buf,RFILE);\\r\\nret=buf;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bnspeed_c", "target": 0, "func": "static double Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret < 1e-3)?1e-3:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\\r\\nreturn((ret < 0.001)?0.001:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM a,b,c;\\r\\nctx=BN_CTX_new();\\r\\nBN_init(&a);\\r\\nBN_init(&b);\\r\\nBN_init(&c);\\r\\ndo_mul(&a,&b,&c,ctx);\\r\\n}\\r\\nvoid do_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint i,j,k;\\r\\ndouble tm;\\r\\nlong num;\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i],1,0);\\r\\nfor (j=i; j<NUM_SIZES; j++)\\r\\n{\\r\\nBN_rand(b,sizes[j],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<num; k++)\\r\\nBN_mul(r,b,a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"mul %4d x %4d -> %8.3fms\\n\",sizes[i],sizes[j],tm*1000.0/num);\\r\\n}\\r\\n}\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<num; k++)\\r\\nBN_sqr(r,a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"sqr %4d x %4d -> %8.3fms\\n\",sizes[i],sizes[i],tm*1000.0/num);\\r\\n}\\r\\nfor (i=0; i<NUM_SIZES; i++)\\r\\n{\\r\\nnum=BASENUM/10;\\r\\nif (i) num/=(i*3);\\r\\nBN_rand(a,sizes[i]-1,1,0);\\r\\nfor (j=i; j<NUM_SIZES; j++)\\r\\n{\\r\\nBN_rand(b,sizes[j],1,0);\\r\\nTime_F(START);\\r\\nfor (k=0; k<100000; k++)\\r\\nBN_div(r, NULL, b, a,ctx);\\r\\ntm=Time_F(STOP);\\r\\nprintf(\"div %4d / %4d -> %8.3fms\\n\",sizes[j],sizes[i]-1,tm*1000.0/num);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_cryptlib_c", "target": 0, "func": "int CRYPTO_get_new_lockid(char *name)\\r\\n{\\r\\nchar *str;\\r\\nint i;\\r\\n#if defined(WIN32) || defined(WIN16)\\r\\nSSLeay_MSVC5_hack=(double)name[0]*(double)name[1];\\r\\n#endif\\r\\nif ((app_locks == NULL) && ((app_locks=sk_new_null()) == NULL))\\r\\n{\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nif ((str=BUF_strdup(name)) == NULL)\\r\\nreturn(0);\\r\\ni=sk_push(app_locks,str);\\r\\nif (!i)\\r\\nFree(str);\\r\\nelse\\r\\ni+=CRYPTO_NUM_LOCKS;\\r\\nreturn(i);\\r\\n}\\r\\nint CRYPTO_num_locks(void)\\r\\n{\\r\\nreturn CRYPTO_NUM_LOCKS;\\r\\n}\\r\\nvoid CRYPTO_set_locking_callback(void (*func)(int mode,int type,\\r\\nconst char *file,int line))\\r\\n{\\r\\nlocking_callback=func;\\r\\n}\\r\\nvoid CRYPTO_set_add_lock_callback(int (*func)(int *num,int mount,int type,\\r\\nconst char *file,int line))\\r\\n{\\r\\nadd_lock_callback=func;\\r\\n}\\r\\nunsigned long CRYPTO_thread_id(void)\\r\\n{\\r\\nunsigned long ret=0;\\r\\nif (id_callback == NULL)\\r\\n{\\r\\n#ifdef WIN16\\r\\nret=(unsigned long)GetCurrentTask();\\r\\n#elif defined(WIN32)\\r\\nret=(unsigned long)GetCurrentThreadId();\\r\\n#elif defined(MSDOS)\\r\\nret=1L;\\r\\n#else\\r\\nret=(unsigned long)getpid();\\r\\n#endif\\r\\n}\\r\\nelse\\r\\nret=id_callback();\\r\\nreturn(ret);\\r\\n}\\r\\nvoid CRYPTO_lock(int mode, int type, const char *file, int line)\\r\\n{\\r\\n#ifdef LOCK_DEBUG\\r\\n{\\r\\nchar *rw_text,*operation_text;\\r\\nif (mode & CRYPTO_LOCK)\\r\\noperation_text=\"lock \";\\r\\nelse if (mode & CRYPTO_UNLOCK)\\r\\noperation_text=\"unlock\";\\r\\nelse\\r\\noperation_text=\"ERROR \";\\r\\nif (mode & CRYPTO_READ)\\r\\nrw_text=\"r\";\\r\\nelse if (mode & CRYPTO_WRITE)\\r\\nrw_text=\"w\";\\r\\nelse\\r\\nrw_text=\"ERROR\";\\r\\nfprintf(stderr,\"lock:%08lx:(%s)%s %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(), rw_text, operation_text,\\r\\nCRYPTO_get_lock_name(type), file, line);\\r\\n}\\r\\n#endif\\r\\nif (locking_callback != NULL)\\r\\nlocking_callback(mode,type,file,line);\\r\\n}\\r\\nint CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\\r\\nint line)\\r\\n{\\r\\nint ret;\\r\\nif (add_lock_callback != NULL)\\r\\n{\\r\\n#ifdef LOCK_DEBUG\\r\\nint before= *pointer;\\r\\n#endif\\r\\nret=add_lock_callback(pointer,amount,type,file,line);\\r\\n#ifdef LOCK_DEBUG\\r\\nfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\nbefore,amount,ret,\\r\\nCRYPTO_get_lock_name(type),\\r\\nfile,line);\\r\\n#endif\\r\\n*pointer=ret;\\r\\n}\\r\\nelse\\r\\n{\\r\\nCRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,file,line);\\r\\nret= *pointer+amount;\\r\\n#ifdef LOCK_DEBUG\\r\\nfprintf(stderr,\"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_thread_id(),\\r\\n*pointer,amount,ret,\\r\\nCRYPTO_get_lock_name(type),\\r\\nfile,line);\\r\\n#endif\\r\\n*pointer=ret;\\r\\nCRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,file,line);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nconst char *CRYPTO_get_lock_name(int type)\\r\\n{\\r\\nif (type < 0)\\r\\nreturn(\"ERROR\");\\r\\nelse if (type < CRYPTO_NUM_LOCKS)\\r\\nreturn(lock_names[type]);\\r\\nelse if (type-CRYPTO_NUM_LOCKS >= sk_num(app_locks))\\r\\nreturn(\"ERROR\");\\r\\nelse\\r\\nreturn(sk_value(app_locks,type-CRYPTO_NUM_LOCKS));\\r\\n}\\r\\nBOOL WINAPI DLLEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason,\\r\\nLPVOID lpvReserved)\\r\\n{\\r\\nswitch(fdwReason)\\r\\n{\\r\\ncase DLL_PROCESS_ATTACH:\\r\\nbreak;\\r\\ncase DLL_THREAD_ATTACH:\\r\\nbreak;\\r\\ncase DLL_THREAD_DETACH:\\r\\nERR_remove_state(0);\\r\\nbreak;\\r\\ncase DLL_PROCESS_DETACH:\\r\\nbreak;\\r\\n}\\r\\nreturn(TRUE);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_int_c", "target": 0, "func": "int i2d_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)\\r\\n{\\r\\nint pad=0,ret,r,i,t;\\r\\nunsigned char *p,*n,pb=0;\\r\\nif ((a == NULL) || (a->data == NULL)) return(0);\\r\\nt=a->type;\\r\\nif (a->length == 0)\\r\\nret=1;\\r\\nelse\\r\\n{\\r\\nret=a->length;\\r\\ni=a->data[0];\\r\\nif ((t == V_ASN1_INTEGER) && (i > 127)) {\\r\\npad=1;\\r\\npb=0;\\r\\n} else if(t == V_ASN1_NEG_INTEGER) {\\r\\nif(i>128) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\n} else if(i == 128) {\\r\\nfor(i = 1; i < a->length; i++) if(a->data[i]) {\\r\\npad=1;\\r\\npb=0xFF;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nret+=pad;\\r\\n}\\r\\nr=ASN1_object_size(0,ret,V_ASN1_INTEGER);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,0,ret,V_ASN1_INTEGER,V_ASN1_UNIVERSAL);\\r\\nif (pad) *(p++)=pb;\\r\\nif (a->length == 0) *(p++)=0;\\r\\nelse if (t == V_ASN1_INTEGER) memcpy(p,a->data,(unsigned int)a->length);\\r\\nelse {\\r\\nn=a->data + a->length - 1;\\r\\np += a->length - 1;\\r\\ni = a->length;\\r\\nwhile(!*n) {\\r\\n*(p--) = 0;\\r\\nn--;\\r\\ni--;\\r\\n}\\r\\n*(p--) = ((*(n--)) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(p--) = *(n--) ^ 0xff;\\r\\n}\\r\\n*pp+=r;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_INTEGER *d2i_ASN1_INTEGER(ASN1_INTEGER **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_INTEGER *ret=NULL;\\r\\nunsigned char *p,*to,*s, *pend;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_INTEGER_new()) == NULL) return(NULL);\\r\\nret->type=V_ASN1_INTEGER;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\npend = p + len;\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_INTEGER)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_INTEGER;\\r\\ngoto err;\\r\\n}\\r\\ns=(unsigned char *)Malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto=s;\\r\\nif (*p & 0x80)\\r\\n{\\r\\nret->type=V_ASN1_NEG_INTEGER;\\r\\nif ((*p == 0xff) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\ni = len;\\r\\np += i - 1;\\r\\nto += i - 1;\\r\\nwhile((!*p) && i) {\\r\\n*(to--) = 0;\\r\\ni--;\\r\\np--;\\r\\n}\\r\\nif(!i) {\\r\\n*s = 1;\\r\\ns[len] = 0;\\r\\nlen++;\\r\\n} else {\\r\\n*(to--) = (*(p--) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor(;i > 0; i--) *(to--) = *(p--) ^ 0xff;\\r\\n}\\r\\n} else {\\r\\nret->type=V_ASN1_INTEGER;\\r\\nif ((*p == 0) && (len != 1))\\r\\n{\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\n}\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->data=s;\\r\\nret->length=(int)len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=pend;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_INTEGER,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_INTEGER *ret=NULL;\\r\\nunsigned char *p,*to,*s;\\r\\nlong len;\\r\\nint inf,tag,xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{\\r\\nif ((ret=ASN1_INTEGER_new()) == NULL) return(NULL);\\r\\nret->type=V_ASN1_INTEGER;\\r\\n}\\r\\nelse\\r\\nret=(*a);\\r\\np= *pp;\\r\\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\\r\\nif (inf & 0x80)\\r\\n{\\r\\ni=ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_INTEGER)\\r\\n{\\r\\ni=ASN1_R_EXPECTING_AN_INTEGER;\\r\\ngoto err;\\r\\n}\\r\\ns=(unsigned char *)Malloc((int)len+1);\\r\\nif (s == NULL)\\r\\n{\\r\\ni=ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto=s;\\r\\nret->type=V_ASN1_INTEGER;\\r\\nif ((*p == 0) && (len != 1))\\r\\n{\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s,p,(int)len);\\r\\np+=len;\\r\\nif (ret->data != NULL) Free((char *)ret->data);\\r\\nret->data=s;\\r\\nret->length=(int)len;\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_UINTEGER,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nint ASN1_INTEGER_set(ASN1_INTEGER *a, long v)\\r\\n{\\r\\nint i,j,k;\\r\\nunsigned char buf[sizeof(long)+1];\\r\\nlong d;\\r\\na->type=V_ASN1_INTEGER;\\r\\nif (a->length < (sizeof(long)+1))\\r\\n{\\r\\nif (a->data != NULL)\\r\\nFree((char *)a->data);\\r\\nif ((a->data=(unsigned char *)Malloc(sizeof(long)+1)) != NULL)\\r\\nmemset((char *)a->data,0,sizeof(long)+1);\\r\\n}\\r\\nif (a->data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_ASN1_INTEGER_SET,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nd=v;\\r\\nif (d < 0)\\r\\n{\\r\\nd= -d;\\r\\na->type=V_ASN1_NEG_INTEGER;\\r\\n}\\r\\nfor (i=0; i<sizeof(long); i++)\\r\\n{\\r\\nif (d == 0) break;\\r\\nbuf[i]=(int)d&0xff;\\r\\nd>>=8;\\r\\n}\\r\\nj=0;\\r\\nfor (k=i-1; k >=0; k--)\\r\\na->data[j++]=buf[k];\\r\\na->length=j;\\r\\nreturn(1);\\r\\n}\\r\\nlong ASN1_INTEGER_get(ASN1_INTEGER *a)\\r\\n{\\r\\nint neg=0,i;\\r\\nlong r=0;\\r\\nif (a == NULL) return(0L);\\r\\ni=a->type;\\r\\nif (i == V_ASN1_NEG_INTEGER)\\r\\nneg=1;\\r\\nelse if (i != V_ASN1_INTEGER)\\r\\nreturn(0);\\r\\nif (a->length > sizeof(long))\\r\\n{\\r\\nreturn(0xffffffffL);\\r\\n}\\r\\nif (a->data == NULL)\\r\\nreturn(0);\\r\\nfor (i=0; i<a->length; i++)\\r\\n{\\r\\nr<<=8;\\r\\nr|=(unsigned char)a->data[i];\\r\\n}\\r\\nif (neg) r= -r;\\r\\nreturn(r);\\r\\n}\\r\\nASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *bn, ASN1_INTEGER *ai)\\r\\n{\\r\\nASN1_INTEGER *ret;\\r\\nint len,j;\\r\\nif (ai == NULL)\\r\\nret=ASN1_INTEGER_new();\\r\\nelse\\r\\nret=ai;\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_BN_TO_ASN1_INTEGER,ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif(bn->neg) ret->type = V_ASN1_NEG_INTEGER;\\r\\nelse ret->type=V_ASN1_INTEGER;\\r\\nj=BN_num_bits(bn);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nret->data=(unsigned char *)Malloc(len+4);\\r\\nret->length=BN_bn2bin(bn,ret->data);\\r\\nreturn(ret);\\r\\nerr:\\r\\nif (ret != ai) ASN1_INTEGER_free(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nBIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *ai, BIGNUM *bn)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret=BN_bin2bn(ai->data,ai->length,bn)) == NULL)\\r\\nASN1err(ASN1_F_ASN1_INTEGER_TO_BN,ASN1_R_BN_LIB);\\r\\nif(ai->type == V_ASN1_NEG_INTEGER) bn->neg = 1;\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_r_pr_c", "target": 0, "func": "int i2d_RSAPrivateKey(RSA *a, unsigned char **pp)\\r\\n{\\r\\nBIGNUM *num[9];\\r\\nunsigned char data[1];\\r\\nASN1_INTEGER bs;\\r\\nunsigned int j,i,tot,t,len,max=0;\\r\\nunsigned char *p;\\r\\nif (a == NULL) return(0);\\r\\nnum[1]=a->n;\\r\\nnum[2]=a->e;\\r\\nnum[3]=a->d;\\r\\nnum[4]=a->p;\\r\\nnum[5]=a->q;\\r\\nnum[6]=a->dmp1;\\r\\nnum[7]=a->dmq1;\\r\\nnum[8]=a->iqmp;\\r\\nbs.length=1;\\r\\nbs.data=data;\\r\\nbs.type=V_ASN1_INTEGER;\\r\\ndata[0]=a->version&0x7f;\\r\\ntot=i2d_ASN1_INTEGER(&(bs),NULL);\\r\\nfor (i=1; i<9; i++)\\r\\n{\\r\\nj=BN_num_bits(num[i]);\\r\\nlen=((j == 0)?0:((j/8)+1));\\r\\nif (len > max) max=len;\\r\\nlen=ASN1_object_size(0,len,\\r\\n(num[i]->neg)?V_ASN1_NEG_INTEGER:V_ASN1_INTEGER);\\r\\ntot+=len;\\r\\n}\\r\\nt=ASN1_object_size(1,tot,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(t);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,tot,V_ASN1_SEQUENCE,V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\nbs.data=(unsigned char *)Malloc(max+4);\\r\\nif (bs.data == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_I2D_RSAPRIVATEKEY,ERR_R_MALLOC_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nfor (i=1; i<9; i++)\\r\\n{\\r\\nbs.length=BN_bn2bin(num[i],bs.data);\\r\\ni2d_ASN1_INTEGER(&bs,&p);\\r\\n}\\r\\nFree((char *)bs.data);\\r\\n*pp=p;\\r\\nreturn(t);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_asn_pack_c", "target": 0, "func": "STACK *ASN1_seq_unpack(unsigned char *buf, int len, char *(*d2i)(),\\r\\nvoid (*free_func)())\\r\\n{\\r\\nSTACK *sk;\\r\\nunsigned char *pbuf;\\r\\npbuf = buf;\\r\\nif (!(sk = d2i_ASN1_SET(NULL, &pbuf, len, d2i, free_func,\\r\\nV_ASN1_SEQUENCE, V_ASN1_UNIVERSAL)))\\r\\nASN1err(ASN1_F_ASN1_SEQ_UNPACK,ASN1_R_DECODE_ERROR);\\r\\nreturn sk;\\r\\n}\\r\\nunsigned char *ASN1_seq_pack(STACK *safes, int (*i2d)(), unsigned char **buf,\\r\\nint *len)\\r\\n{\\r\\nint safelen;\\r\\nunsigned char *safe, *p;\\r\\nif (!(safelen = i2d_ASN1_SET(safes, NULL, i2d, V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL, IS_SEQUENCE))) {\\r\\nASN1err(ASN1_F_ASN1_SEQ_PACK,ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(safe = Malloc (safelen))) {\\r\\nASN1err(ASN1_F_ASN1_SEQ_PACK,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np = safe;\\r\\ni2d_ASN1_SET(safes, &p, i2d, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL,\\r\\nIS_SEQUENCE);\\r\\nif (len) *len = safelen;\\r\\nif (buf) *buf = safe;\\r\\nreturn safe;\\r\\n}\\r\\nvoid *ASN1_unpack_string (ASN1_STRING *oct, char *(*d2i)())\\r\\n{\\r\\nunsigned char *p;\\r\\nchar *ret;\\r\\np = oct->data;\\r\\nif(!(ret = d2i(NULL, &p, oct->length)))\\r\\nASN1err(ASN1_F_ASN1_UNPACK_STRING,ASN1_R_DECODE_ERROR);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_STRING *ASN1_pack_string (void *obj, int (*i2d)(), ASN1_STRING **oct)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_STRING *octmp;\\r\\nif (!oct || !*oct) {\\r\\nif (!(octmp = ASN1_STRING_new ())) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (oct) *oct = octmp;\\r\\n} else octmp = *oct;\\r\\nif (!(octmp->length = i2d(obj, NULL))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(p = Malloc (octmp->length))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\noctmp->data = p;\\r\\ni2d (obj, &p);\\r\\nreturn octmp;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sess_id_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nSSL_SESSION *x=NULL;\\r\\nint ret=1,i,num,badops=0;\\r\\nBIO *out=NULL;\\r\\nint informat,outformat;\\r\\nchar *infile=NULL,*outfile=NULL,*context=NULL;\\r\\nint cert=0,noout=0,text=0;\\r\\nchar **pp;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\ninformat=FORMAT_PEM;\\r\\noutformat=FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum=0;\\r\\nwhile (argc >= 1)\\r\\n{\\r\\nif (strcmp(*argv,\"-inform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-outform\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutformat=str2fmt(*(++argv));\\r\\n}\\r\\nelse if (strcmp(*argv,\"-in\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-text\") == 0)\\r\\ntext= ++num;\\r\\nelse if (strcmp(*argv,\"-cert\") == 0)\\r\\ncert= ++num;\\r\\nelse if (strcmp(*argv,\"-noout\") == 0)\\r\\nnoout= ++num;\\r\\nelse if (strcmp(*argv,\"-context\") == 0)\\r\\n{\\r\\nif(--argc < 1) goto bad;\\r\\ncontext=*++argv;\\r\\n}\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\\r\\nbadops=1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops)\\r\\n{\\r\\nbad:\\r\\nfor (pp=sess_id_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err,*pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nx=load_sess_id(infile,informat);\\r\\nif (x == NULL) { goto end; }\\r\\nif(context)\\r\\n{\\r\\nx->sid_ctx_length=strlen(context);\\r\\nif(x->sid_ctx_length > SSL_MAX_SID_CTX_LENGTH)\\r\\n{\\r\\nBIO_printf(bio_err,\"Context too long\\n\");\\r\\ngoto end;\\r\\n}\\r\\nmemcpy(x->sid_ctx,context,x->sid_ctx_length);\\r\\n}\\r\\n#ifdef undef\\r\\n{\\r\\nSSL_SESSION *s;\\r\\nchar buf[1024*10],*p;\\r\\nint i;\\r\\ns=SSL_SESSION_new();\\r\\np= &buf;\\r\\ni=i2d_SSL_SESSION(x,&p);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\np= &buf;\\r\\nd2i_SSL_SESSION(&s,&p,(long)i);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n#endif\\r\\nif (!noout || text)\\r\\n{\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (text)\\r\\n{\\r\\nSSL_SESSION_print(out,x);\\r\\nif (cert)\\r\\n{\\r\\nif (x->peer == NULL)\\r\\nBIO_puts(out,\"No certificate present\\n\");\\r\\nelse\\r\\nX509_print(out,x->peer);\\r\\n}\\r\\n}\\r\\nif (!noout && !cert)\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=(int)i2d_SSL_SESSION_bio(out,x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_SSL_SESSION(out,x);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err,\"unable to write SSL_SESSION\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse if (!noout && (x->peer != NULL))\\r\\n{\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni=(int)i2d_X509_bio(out,x->peer);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni=PEM_write_bio_X509(out,x->peer);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err,\"unable to write X509\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret=0;\\r\\nend:\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (x != NULL) SSL_SESSION_free(x);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic SSL_SESSION *load_sess_id(char *infile, int format)\\r\\n{\\r\\nSSL_SESSION *x=NULL;\\r\\nBIO *in=NULL;\\r\\nin=BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_read_filename(in,infile) <= 0)\\r\\n{\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx=d2i_SSL_SESSION_bio(in,NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx=PEM_read_bio_SSL_SESSION(in,NULL,NULL,NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"unable to load SSL_SESSION\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (in != NULL) BIO_free(in);\\r\\nreturn(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_rc4_c", "target": 0, "func": "EVP_CIPHER *EVP_rc4(void)\\r\\n{\\r\\nreturn(&r4_cipher);\\r\\n}\\r\\nEVP_CIPHER *EVP_rc4_40(void)\\r\\n{\\r\\nreturn(&r4_40_cipher);\\r\\n}\\r\\nstatic void rc4_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\nmemcpy(&(ctx->c.rc4.key[0]),key,EVP_CIPHER_CTX_key_length(ctx));\\r\\nRC4_set_key(&(ctx->c.rc4.ks),EVP_CIPHER_CTX_key_length(ctx),\\r\\nctx->c.rc4.key);\\r\\n}\\r\\nstatic void rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nRC4(&(ctx->c.rc4.ks),inl,in,out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sha1_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i,err=0;\\r\\nFILE *IN;\\r\\nif (argc == 1)\\r\\n{\\r\\ndo_fp(stdin);\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=1; i<argc; i++)\\r\\n{\\r\\nIN=fopen(argv[i],\"r\");\\r\\nif (IN == NULL)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"SHA1(%s)= \",argv[i]);\\r\\ndo_fp(IN);\\r\\nfclose(IN);\\r\\n}\\r\\n}\\r\\nexit(err);\\r\\n}\\r\\nvoid do_fp(FILE *f)\\r\\n{\\r\\nSHA_CTX c;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nint fd;\\r\\nint i;\\r\\nunsigned char buf[BUFSIZE];\\r\\nfd=fileno(f);\\r\\nSHA1_Init(&c);\\r\\nfor (;;)\\r\\n{\\r\\ni=read(fd,buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\nSHA1_Update(&c,buf,(unsigned long)i);\\r\\n}\\r\\nSHA1_Final(&(md[0]),&c);\\r\\npt(md);\\r\\n}\\r\\nvoid pt(unsigned char *md)\\r\\n{\\r\\nint i;\\r\\nfor (i=0; i<SHA_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02x\",md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_d2i_r_pu_c", "target": 0, "func": "RSA *d2i_RSAPublicKey(RSA **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i=ASN1_R_PARSING;\\r\\nASN1_INTEGER *bs=NULL;\\r\\nM_ASN1_D2I_vars(a,RSA *,RSA_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->n=BN_bin2bn(bs->data,bs->length,ret->n)) == NULL) goto err_bn;\\r\\nM_ASN1_D2I_get(bs,d2i_ASN1_INTEGER);\\r\\nif ((ret->e=BN_bin2bn(bs->data,bs->length,ret->e)) == NULL) goto err_bn;\\r\\nASN1_INTEGER_free(bs);\\r\\nbs=NULL;\\r\\nM_ASN1_D2I_Finish_2(a);\\r\\nerr_bn:\\r\\ni=ERR_R_BN_LIB;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_RSAPUBLICKEY,i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret))) RSA_free(ret);\\r\\nif (bs != NULL) ASN1_INTEGER_free(bs);\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_pem_err_c", "target": 0, "func": "void ERR_load_PEM_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_PEM,PEM_str_functs);\\r\\nERR_load_strings(ERR_LIB_PEM,PEM_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dgst_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nunsigned char *buf=NULL;\\r\\nint i,err=0;\\r\\nconst EVP_MD *md=NULL,*m;\\r\\nBIO *in=NULL,*inp;\\r\\nBIO *bmd=NULL;\\r\\nconst char *name;\\r\\n#define PROG_NAME_SIZE 16\\r\\nchar pname[PROG_NAME_SIZE];\\r\\nint separator=0;\\r\\nint debug=0;\\r\\napps_startup();\\r\\nif ((buf=(unsigned char *)Malloc(BUFSIZE)) == NULL)\\r\\n{\\r\\nBIO_printf(bio_err,\"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nprogram_name(argv[0],pname,PROG_NAME_SIZE);\\r\\nmd=EVP_get_digestbyname(pname);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc > 0)\\r\\n{\\r\\nif ((*argv)[0] != '-') break;\\r\\nif (strcmp(*argv,\"-c\") == 0)\\r\\nseparator=1;\\r\\nelse if (strcmp(*argv,\"-d\") == 0)\\r\\ndebug=1;\\r\\nelse if ((m=EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\nmd=m;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (md == NULL)\\r\\nmd=EVP_md5();\\r\\nif ((argc > 0) && (argv[0][0] == '-'))\\r\\n{\\r\\nBIO_printf(bio_err,\"unknown option '%s'\\n\",*argv);\\r\\nBIO_printf(bio_err,\"options are\\n\");\\r\\nBIO_printf(bio_err,\"-c to output the digest with separating colons\\n\");\\r\\nBIO_printf(bio_err,\"-d to output debug info\\n\");\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm (default)\\n\",\\r\\nLN_md5,LN_md5);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_md2,LN_md2);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha1,LN_sha1);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_sha,LN_sha);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_mdc2,LN_mdc2);\\r\\nBIO_printf(bio_err,\"-%3s to use the %s message digest algorithm\\n\",\\r\\nLN_ripemd160,LN_ripemd160);\\r\\nerr=1;\\r\\ngoto end;\\r\\n}\\r\\nin=BIO_new(BIO_s_file());\\r\\nbmd=BIO_new(BIO_f_md());\\r\\nif (debug)\\r\\n{\\r\\nBIO_set_callback(in,BIO_debug_callback);\\r\\nBIO_set_callback_arg(in,bio_err);\\r\\n}\\r\\nif ((in == NULL) || (bmd == NULL))\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_set_md(bmd,md);\\r\\ninp=BIO_push(bmd,in);\\r\\nif (argc == 0)\\r\\n{\\r\\nBIO_set_fp(in,stdin,BIO_NOCLOSE);\\r\\ndo_fp(buf,inp,separator);\\r\\n}\\r\\nelse\\r\\n{\\r\\nname=OBJ_nid2sn(md->type);\\r\\nfor (i=0; i<argc; i++)\\r\\n{\\r\\nif (BIO_read_filename(in,argv[i]) <= 0)\\r\\n{\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n}\\r\\nprintf(\"%s(%s)= \",name,argv[i]);\\r\\ndo_fp(buf,inp,separator);\\r\\n(void)BIO_reset(bmd);\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (buf != NULL)\\r\\n{\\r\\nmemset(buf,0,BUFSIZE);\\r\\nFree(buf);\\r\\n}\\r\\nif (in != NULL) BIO_free(in);\\r\\nif (bmd != NULL) BIO_free(bmd);\\r\\nEXIT(err);\\r\\n}\\r\\nvoid do_fp(unsigned char *buf, BIO *bp, int sep)\\r\\n{\\r\\nint len;\\r\\nint i;\\r\\nfor (;;)\\r\\n{\\r\\ni=BIO_read(bp,(char *)buf,BUFSIZE);\\r\\nif (i <= 0) break;\\r\\n}\\r\\nlen=BIO_gets(bp,(char *)buf,BUFSIZE);\\r\\nfor (i=0; i<len; i++)\\r\\n{\\r\\nif (sep && (i != 0))\\r\\nputc(':',stdout);\\r\\nprintf(\"%02x\",buf[i]);\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cbc_bf_c", "target": 0, "func": "EVP_CIPHER *EVP_bf_cbc(void)\\r\\n{\\r\\nreturn(&bfish_cbc_cipher);\\r\\n}\\r\\nstatic void bf_cbc_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nBF_set_key(&(ctx->c.bf_ks),EVP_BLOWFISH_KEY_SIZE,key);\\r\\n}\\r\\nstatic void bf_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nBF_cbc_encrypt(\\r\\nin,out,(long)inl,\\r\\n&(ctx->c.bf_ks),&(ctx->iv[0]),\\r\\nctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_str2key_c", "target": 0, "func": "void des_string_to_key(const char *str, des_cblock *key)\\r\\n{\\r\\ndes_key_schedule ks;\\r\\nint i,length;\\r\\nregister unsigned char j;\\r\\nmemset(key,0,8);\\r\\nlength=strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nfor (i=0; i<length; i++)\\r\\n(*key)[i%8]^=(str[i]<<1);\\r\\n#else\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nj=str[i];\\r\\nif ((i%16) < 8)\\r\\n(*key)[i%8]^=(j<<1);\\r\\nelse\\r\\n{\\r\\nj=((j<<4)&0xf0)|((j>>4)&0x0f);\\r\\nj=((j<<2)&0xcc)|((j>>2)&0x33);\\r\\nj=((j<<1)&0xaa)|((j>>1)&0x55);\\r\\n(*key)[7-(i%8)]^=j;\\r\\n}\\r\\n}\\r\\n#endif\\r\\ndes_set_odd_parity(key);\\r\\ni=des_check_key;\\r\\ndes_check_key=0;\\r\\ndes_set_key(key,ks);\\r\\ndes_check_key=i;\\r\\ndes_cbc_cksum((unsigned char*)str,key,length,ks,key);\\r\\nmemset(ks,0,sizeof(ks));\\r\\ndes_set_odd_parity(key);\\r\\n}\\r\\nvoid des_string_to_2keys(const char *str, des_cblock *key1, des_cblock *key2)\\r\\n{\\r\\ndes_key_schedule ks;\\r\\nint i,length;\\r\\nregister unsigned char j;\\r\\nmemset(key1,0,8);\\r\\nmemset(key2,0,8);\\r\\nlength=strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nif (length <= 8)\\r\\n{\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\n(*key2)[i]=(*key1)[i]=(str[i]<<1);\\r\\n}\\r\\n}\\r\\nelse\\r\\n{\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nif ((i/8)&1)\\r\\n(*key2)[i%8]^=(str[i]<<1);\\r\\nelse\\r\\n(*key1)[i%8]^=(str[i]<<1);\\r\\n}\\r\\n}\\r\\n#else\\r\\nfor (i=0; i<length; i++)\\r\\n{\\r\\nj=str[i];\\r\\nif ((i%32) < 16)\\r\\n{\\r\\nif ((i%16) < 8)\\r\\n(*key1)[i%8]^=(j<<1);\\r\\nelse\\r\\n(*key2)[i%8]^=(j<<1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nj=((j<<4)&0xf0)|((j>>4)&0x0f);\\r\\nj=((j<<2)&0xcc)|((j>>2)&0x33);\\r\\nj=((j<<1)&0xaa)|((j>>1)&0x55);\\r\\nif ((i%16) < 8)\\r\\n(*key1)[7-(i%8)]^=j;\\r\\nelse\\r\\n(*key2)[7-(i%8)]^=j;\\r\\n}\\r\\n}\\r\\nif (length <= 8) memcpy(key2,key1,8);\\r\\n#endif\\r\\ndes_set_odd_parity(key1);\\r\\ndes_set_odd_parity(key2);\\r\\ni=des_check_key;\\r\\ndes_check_key=0;\\r\\ndes_set_key(key1,ks);\\r\\ndes_cbc_cksum((unsigned char*)str,key1,length,ks,key1);\\r\\ndes_set_key(key2,ks);\\r\\ndes_cbc_cksum((unsigned char*)str,key2,length,ks,key2);\\r\\ndes_check_key=i;\\r\\nmemset(ks,0,sizeof(ks));\\r\\ndes_set_odd_parity(key1);\\r\\ndes_set_odd_parity(key2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s3_both_c", "target": 1, "func": "int ssl3_send_finished(SSL *s, int a, int b, unsigned char *sender,\\r\\nint slen)\\r\\n{\\r\\nunsigned char *p,*d;\\r\\nint i;\\r\\nunsigned long l;\\r\\nif (s->state == a)\\r\\n{\\r\\nd=(unsigned char *)s->init_buf->data;\\r\\np= &(d[4]);\\r\\ni=s->method->ssl3_enc->final_finish_mac(s,\\r\\n&(s->s3->finish_dgst1),\\r\\n&(s->s3->finish_dgst2),\\r\\nsender,slen,p);\\r\\np+=i;\\r\\nl=i;\\r\\n#ifdef WIN16\\r\\nl&=0xffff;\\r\\n#endif\\r\\n*(d++)=SSL3_MT_FINISHED;\\r\\nl2n3(l,d);\\r\\ns->init_num=(int)l+4;\\r\\ns->init_off=0;\\r\\ns->state=b;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\\r\\n}\\r\\nint ssl3_get_finished(SSL *s, int a, int b)\\r\\n{\\r\\nint al,i,ok;\\r\\nlong n;\\r\\nunsigned char *p;\\r\\nn=ssl3_get_message(s,\\r\\na,\\r\\nb,\\r\\nSSL3_MT_FINISHED,\\r\\n64,\\r\\n&ok);\\r\\nif (!ok) return((int)n);\\r\\nif (!s->s3->change_cipher_spec)\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_GOT_A_FIN_BEFORE_A_CCS);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->change_cipher_spec=0;\\r\\np=(unsigned char *)s->init_buf->data;\\r\\ni=s->method->ssl3_enc->finish_mac_length;\\r\\nif (i != n)\\r\\n{\\r\\nal=SSL_AD_DECODE_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_BAD_DIGEST_LENGTH);\\r\\ngoto f_err;\\r\\n}\\r\\nif (memcmp( p, (char *)&(s->s3->tmp.finish_md[0]),i) != 0)\\r\\n{\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nSSLerr(SSL_F_SSL3_GET_FINISHED,SSL_R_DIGEST_CHECK_FAILED);\\r\\ngoto f_err;\\r\\n}\\r\\nreturn(1);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nreturn(0);\\r\\n}\\r\\nint ssl3_send_change_cipher_spec(SSL *s, int a, int b)\\r\\n{\\r\\nunsigned char *p;\\r\\nif (s->state == a)\\r\\n{\\r\\np=(unsigned char *)s->init_buf->data;\\r\\n*p=SSL3_MT_CCS;\\r\\ns->init_num=1;\\r\\ns->init_off=0;\\r\\ns->state=b;\\r\\n}\\r\\nreturn(ssl3_do_write(s,SSL3_RT_CHANGE_CIPHER_SPEC));\\r\\n}\\r\\nunsigned long ssl3_output_cert_chain(SSL *s, X509 *x)\\r\\n{\\r\\nunsigned char *p;\\r\\nint n,i;\\r\\nunsigned long l=7;\\r\\nBUF_MEM *buf;\\r\\nX509_STORE_CTX xs_ctx;\\r\\nX509_OBJECT obj;\\r\\nbuf=s->init_buf;\\r\\nif (!BUF_MEM_grow(buf,(int)(10)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\nif (x != NULL)\\r\\n{\\r\\nX509_STORE_CTX_init(&xs_ctx,s->ctx->cert_store,NULL,NULL);\\r\\nfor (;;)\\r\\n{\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\nif (X509_NAME_cmp(X509_get_subject_name(x),\\r\\nX509_get_issuer_name(x)) == 0) break;\\r\\ni=X509_STORE_get_by_subject(&xs_ctx,X509_LU_X509,\\r\\nX509_get_issuer_name(x),&obj);\\r\\nif (i <= 0) break;\\r\\nx=obj.data.x509;\\r\\nX509_free(x);\\r\\n}\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\n}\\r\\nif (s->ctx->extra_certs != NULL)\\r\\nfor (i=0; i<sk_X509_num(s->ctx->extra_certs); i++)\\r\\n{\\r\\nx=sk_X509_value(s->ctx->extra_certs,i);\\r\\nn=i2d_X509(x,NULL);\\r\\nif (!BUF_MEM_grow(buf,(int)(n+l+3)))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_OUTPUT_CERT_CHAIN,ERR_R_BUF_LIB);\\r\\nreturn(0);\\r\\n}\\r\\np=(unsigned char *)&(buf->data[l]);\\r\\nl2n3(n,p);\\r\\ni2d_X509(x,&p);\\r\\nl+=n+3;\\r\\n}\\r\\nl-=7;\\r\\np=(unsigned char *)&(buf->data[4]);\\r\\nl2n3(l,p);\\r\\nl+=3;\\r\\np=(unsigned char *)&(buf->data[0]);\\r\\n*(p++)=SSL3_MT_CERTIFICATE;\\r\\nl2n3(l,p);\\r\\nl+=4;\\r\\nreturn(l);\\r\\n}\\r\\nlong ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned long l;\\r\\nlong n;\\r\\nint i,al;\\r\\nif (s->s3->tmp.reuse_message)\\r\\n{\\r\\ns->s3->tmp.reuse_message=0;\\r\\nif ((mt >= 0) && (s->s3->tmp.message_type != mt))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\n*ok=1;\\r\\nreturn((int)s->s3->tmp.message_size);\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nif (s->state == st1)\\r\\n{\\r\\ni=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\\r\\n4-s->init_num);\\r\\nif (i < (4-s->init_num))\\r\\n{\\r\\n*ok=0;\\r\\nreturn(ssl3_part_read(s,i));\\r\\n}\\r\\nif ((mt >= 0) && (*p != mt))\\r\\n{\\r\\nal=SSL_AD_UNEXPECTED_MESSAGE;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\\r\\ngoto f_err;\\r\\n}\\r\\ns->s3->tmp.message_type= *(p++);\\r\\nn2l3(p,l);\\r\\nif (l > (unsigned long)max)\\r\\n{\\r\\nal=SSL_AD_ILLEGAL_PARAMETER;\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\\r\\ngoto f_err;\\r\\n}\\r\\nif (l && !BUF_MEM_grow(s->init_buf,(int)l))\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.message_size=l;\\r\\ns->state=stn;\\r\\ns->init_num=0;\\r\\n}\\r\\np=(unsigned char *)s->init_buf->data;\\r\\nn=s->s3->tmp.message_size;\\r\\nif (n > 0)\\r\\n{\\r\\ni=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\\r\\nif (i != (int)n)\\r\\n{\\r\\n*ok=0;\\r\\nreturn(ssl3_part_read(s,i));\\r\\n}\\r\\n}\\r\\n*ok=1;\\r\\nreturn(n);\\r\\nf_err:\\r\\nssl3_send_alert(s,SSL3_AL_FATAL,al);\\r\\nerr:\\r\\n*ok=0;\\r\\nreturn(-1);\\r\\n}\\r\\nint ssl_cert_type(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret= -1,i,j;\\r\\nif (pkey == NULL)\\r\\npk=X509_get_pubkey(x);\\r\\nelse\\r\\npk=pkey;\\r\\nif (pk == NULL) goto err;\\r\\ni=pk->type;\\r\\nif (i == EVP_PKEY_RSA)\\r\\n{\\r\\nret=SSL_PKEY_RSA_ENC;\\r\\nif (x != NULL)\\r\\n{\\r\\nj=X509_get_ext_count(x);\\r\\n}\\r\\n}\\r\\nelse if (i == EVP_PKEY_DSA)\\r\\n{\\r\\nret=SSL_PKEY_DSA_SIGN;\\r\\n}\\r\\nelse if (i == EVP_PKEY_DH)\\r\\n{\\r\\nif (x == NULL)\\r\\nret=SSL_PKEY_DH_DSA;\\r\\nelse\\r\\n{\\r\\nj=X509_get_signature_type(x);\\r\\nif (j == EVP_PKEY_RSA)\\r\\nret=SSL_PKEY_DH_RSA;\\r\\nelse if (j== EVP_PKEY_DSA)\\r\\nret=SSL_PKEY_DH_DSA;\\r\\nelse ret= -1;\\r\\n}\\r\\n}\\r\\nelse\\r\\nret= -1;\\r\\nerr:\\r\\nif(!pkey) EVP_PKEY_free(pk);\\r\\nreturn(ret);\\r\\n}\\r\\nint ssl_verify_alarm_type(long type)\\r\\n{\\r\\nint al;\\r\\nswitch(type)\\r\\n{\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL:\\r\\nal=SSL_AD_UNKNOWN_CA;\\r\\nbreak;\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\\r\\ncase X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\\r\\ncase X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\nal=SSL_AD_BAD_CERTIFICATE;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_SIGNATURE_FAILURE:\\r\\ncase X509_V_ERR_CRL_SIGNATURE_FAILURE:\\r\\nal=SSL_AD_DECRYPT_ERROR;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\nal=SSL_AD_CERTIFICATE_EXPIRED;\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_REVOKED:\\r\\nal=SSL_AD_CERTIFICATE_REVOKED;\\r\\nbreak;\\r\\ncase X509_V_ERR_OUT_OF_MEM:\\r\\nal=SSL_AD_INTERNAL_ERROR;\\r\\nbreak;\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\ncase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\\r\\ncase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\\r\\ncase X509_V_ERR_CERT_CHAIN_TOO_LONG:\\r\\nal=SSL_AD_UNKNOWN_CA;\\r\\nbreak;\\r\\ncase X509_V_ERR_APPLICATION_VERIFICATION:\\r\\nal=SSL_AD_HANDSHAKE_FAILURE;\\r\\nbreak;\\r\\ndefault:\\r\\nal=SSL_AD_CERTIFICATE_UNKNOWN;\\r\\nbreak;\\r\\n}\\r\\nreturn(al);\\r\\n}\\r\\nint ssl3_setup_buffers(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned int extra;\\r\\nif (s->s3->rbuf.buf == NULL)\\r\\n{\\r\\nif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\\r\\nextra=SSL3_RT_MAX_EXTRA;\\r\\nelse\\r\\nextra=0;\\r\\nif ((p=(unsigned char *)Malloc(SSL3_RT_MAX_PACKET_SIZE+extra))\\r\\n== NULL)\\r\\ngoto err;\\r\\ns->s3->rbuf.buf=p;\\r\\n}\\r\\nif (s->s3->wbuf.buf == NULL)\\r\\n{\\r\\nif ((p=(unsigned char *)Malloc(SSL3_RT_MAX_PACKET_SIZE))\\r\\n== NULL)\\r\\ngoto err;\\r\\ns->s3->wbuf.buf=p;\\r\\n}\\r\\ns->packet= &(s->s3->rbuf.buf[0]);\\r\\nreturn(1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_SETUP_BUFFERS,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_sgiccbug_c", "target": 0, "func": "main()\\r\\n{\\r\\nunsigned long r[4];\\r\\nsub(r,a,b);\\r\\nfprintf(stderr,\"input a= %08X %08X %08X %08X\\n\",a[3],a[2],a[1],a[0]);\\r\\nfprintf(stderr,\"input b= %08X %08X %08X %08X\\n\",b[3],b[2],b[1],b[0]);\\r\\nfprintf(stderr,\"output = %08X %08X %08X %08X\\n\",r[3],r[2],r[1],r[0]);\\r\\nfprintf(stderr,\"correct= %08X %08X %08X %08X\\n\",c[3],c[2],c[1],c[0]);\\r\\n}\\r\\nint sub(r,a,b)\\r\\nunsigned long *r,*a,*b;\\r\\n{\\r\\nregister unsigned long t1,t2,*ap,*bp,*rp;\\r\\nint i,carry;\\r\\n#ifdef FIXBUG\\r\\nunsigned long dummy;\\r\\n#endif\\r\\nap=a;\\r\\nbp=b;\\r\\nrp=r;\\r\\ncarry=0;\\r\\nfor (i=0; i<4; i++)\\r\\n{\\r\\nt1= *(ap++);\\r\\nt2= *(bp++);\\r\\nt1=(t1-t2);\\r\\n#ifdef FIXBUG\\r\\ndummy=t1;\\r\\n#endif\\r\\n*(rp++)=t1&0xffffffff;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_set_c", "target": 0, "func": "static int SetBlobCmp(const void *elem1, const void *elem2 )\\r\\n{\\r\\nconst MYBLOB *b1 = (const MYBLOB *)elem1;\\r\\nconst MYBLOB *b2 = (const MYBLOB *)elem2;\\r\\nint r;\\r\\nr = memcmp(b1->pbData, b2->pbData,\\r\\nb1->cbData < b2->cbData ? b1->cbData : b2->cbData);\\r\\nif(r != 0)\\r\\nreturn r;\\r\\nreturn b1->cbData-b2->cbData;\\r\\n}\\r\\nint i2d_ASN1_SET(STACK *a, unsigned char **pp, int (*func)(), int ex_tag,\\r\\nint ex_class, int is_set)\\r\\n{\\r\\nint ret=0,r;\\r\\nint i;\\r\\nunsigned char *p;\\r\\nunsigned char *pStart, *pTempMem;\\r\\nMYBLOB *rgSetBlob;\\r\\nint totSize;\\r\\nif (a == NULL) return(0);\\r\\nfor (i=sk_num(a)-1; i>=0; i--)\\r\\nret+=func(sk_value(a,i),NULL);\\r\\nr=ASN1_object_size(1,ret,ex_tag);\\r\\nif (pp == NULL) return(r);\\r\\np= *pp;\\r\\nASN1_put_object(&p,1,ret,ex_tag,ex_class);\\r\\nif(!is_set || (sk_num(a) < 2))\\r\\n{\\r\\nfor (i=0; i<sk_num(a); i++)\\r\\nfunc(sk_value(a,i),&p);\\r\\n*pp=p;\\r\\nreturn(r);\\r\\n}\\r\\npStart = p;\\r\\nrgSetBlob = (MYBLOB *)Malloc( sk_num(a) * sizeof(MYBLOB));\\r\\nfor (i=0; i<sk_num(a); i++)\\r\\n{\\r\\nrgSetBlob[i].pbData = p;\\r\\nfunc(sk_value(a,i),&p);\\r\\nrgSetBlob[i].cbData = p - rgSetBlob[i].pbData;\\r\\n}\\r\\n*pp=p;\\r\\ntotSize = p - pStart;\\r\\nqsort( rgSetBlob, sk_num(a), sizeof(MYBLOB), SetBlobCmp);\\r\\npTempMem = Malloc(totSize);\\r\\np = pTempMem;\\r\\nfor(i=0; i<sk_num(a); ++i)\\r\\n{\\r\\nmemcpy(p, rgSetBlob[i].pbData, rgSetBlob[i].cbData);\\r\\np += rgSetBlob[i].cbData;\\r\\n}\\r\\nmemcpy(pStart, pTempMem, totSize);\\r\\nFree(pTempMem);\\r\\nFree(rgSetBlob);\\r\\nreturn(r);\\r\\n}\\r\\nSTACK *d2i_ASN1_SET(STACK **a, unsigned char **pp, long length,\\r\\nchar *(*func)(), void (*free_func)(), int ex_tag, int ex_class)\\r\\n{\\r\\nASN1_CTX c;\\r\\nSTACK *ret=NULL;\\r\\nif ((a == NULL) || ((*a) == NULL))\\r\\n{ if ((ret=sk_new(NULL)) == NULL) goto err; }\\r\\nelse\\r\\nret=(*a);\\r\\nc.p= *pp;\\r\\nc.max=(length == 0)?0:(c.p+length);\\r\\nc.inf=ASN1_get_object(&c.p,&c.slen,&c.tag,&c.xclass,c.max-c.p);\\r\\nif (c.inf & 0x80) goto err;\\r\\nif (ex_class != c.xclass)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_CLASS);\\r\\ngoto err;\\r\\n}\\r\\nif (ex_tag != c.tag)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_TAG);\\r\\ngoto err;\\r\\n}\\r\\nif ((c.slen+c.p) > c.max)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_LENGTH_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (c.inf == (V_ASN1_CONSTRUCTED+1))\\r\\nc.slen=length+ *pp-c.p;\\r\\nc.max=c.p+c.slen;\\r\\nwhile (c.p < c.max)\\r\\n{\\r\\nchar *s;\\r\\nif (M_ASN1_D2I_end_sequence()) break;\\r\\nif ((s=func(NULL,&c.p,c.slen,c.max-c.p)) == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_ERROR_PARSING_SET_ELEMENT);\\r\\nasn1_add_error(*pp,(int)(c.q- *pp));\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_push(ret,s)) goto err;\\r\\n}\\r\\nif (a != NULL) (*a)=ret;\\r\\n*pp=c.p;\\r\\nreturn(ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\n{\\r\\nif (free_func != NULL)\\r\\nsk_pop_free(ret,free_func);\\r\\nelse\\r\\nsk_free(ret);\\r\\n}\\r\\nreturn(NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bf_null_c", "target": 0, "func": "BIO_METHOD *BIO_f_null(void)\\r\\n{\\r\\nreturn(&methods_nullf);\\r\\n}\\r\\nstatic int nullf_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->ptr=NULL;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nullf_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int nullf_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nif (out == NULL) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nullf_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nif (b->next_bio == NULL) return(0);\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long nullf_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL) return(0);\\r\\nswitch(cmd)\\r\\n{\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret=0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int nullf_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_gets(bp->next_bio,buf,size));\\r\\n}\\r\\nstatic int nullf_puts(BIO *bp, char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL) return(0);\\r\\nreturn(BIO_puts(bp->next_bio,str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_d_c", "target": 0, "func": "EVP_CIPHER *EVP_des_cfb(void)\\r\\n{\\r\\nreturn(&d_cfb_cipher);\\r\\n}\\r\\nstatic void des_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\ndes_cblock *deskey = (des_cblock *)key;\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (deskey != NULL)\\r\\ndes_set_key(deskey,ctx->c.des_ks);\\r\\n}\\r\\nstatic void des_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\ndes_cfb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, ctx->c.des_ks,\\r\\n(des_cblock *)&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i_cbc_c", "target": 0, "func": "void idea_cbc_encrypt(unsigned char *in, unsigned char *out, long length,\\r\\nIDEA_KEY_SCHEDULE *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0,tin1;\\r\\nregister unsigned long tout0,tout1,xor0,xor1;\\r\\nregister long l=length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt)\\r\\n{\\r\\nn2l(iv,tout0);\\r\\nn2l(iv,tout1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0);\\r\\nn2l(in,tin1);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2n(tout0,out);\\r\\ntout1=tin[1]; l2n(tout1,out);\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2ln(in,tin0,tin1,l+8);\\r\\ntin0^=tout0;\\r\\ntin1^=tout1;\\r\\ntin[0]=tin0;\\r\\ntin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]; l2n(tout0,out);\\r\\ntout1=tin[1]; l2n(tout1,out);\\r\\n}\\r\\nl2n(tout0,iv);\\r\\nl2n(tout1,iv);\\r\\n}\\r\\nelse\\r\\n{\\r\\nn2l(iv,xor0);\\r\\nn2l(iv,xor1);\\r\\niv-=8;\\r\\nfor (l-=8; l>=0; l-=8)\\r\\n{\\r\\nn2l(in,tin0); tin[0]=tin0;\\r\\nn2l(in,tin1); tin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2n(tout0,out);\\r\\nl2n(tout1,out);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nif (l != -8)\\r\\n{\\r\\nn2l(in,tin0); tin[0]=tin0;\\r\\nn2l(in,tin1); tin[1]=tin1;\\r\\nidea_encrypt(tin,ks);\\r\\ntout0=tin[0]^xor0;\\r\\ntout1=tin[1]^xor1;\\r\\nl2nn(tout0,tout1,out,l+8);\\r\\nxor0=tin0;\\r\\nxor1=tin1;\\r\\n}\\r\\nl2n(xor0,iv);\\r\\nl2n(xor1,iv);\\r\\n}\\r\\ntin0=tin1=tout0=tout1=xor0=xor1=0;\\r\\ntin[0]=tin[1]=0;\\r\\n}\\r\\nvoid idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)\\r\\n{\\r\\nregister IDEA_INT *p;\\r\\nregister unsigned long x1,x2,x3,x4,t0,t1,ul;\\r\\nx2=d[0];\\r\\nx1=(x2>>16);\\r\\nx4=d[1];\\r\\nx3=(x4>>16);\\r\\np= &(key->data[0][0]);\\r\\nE_IDEA(0);\\r\\nE_IDEA(1);\\r\\nE_IDEA(2);\\r\\nE_IDEA(3);\\r\\nE_IDEA(4);\\r\\nE_IDEA(5);\\r\\nE_IDEA(6);\\r\\nE_IDEA(7);\\r\\nx1&=0xffff;\\r\\nidea_mul(x1,x1,*p,ul); p++;\\r\\nt0= x3+ *(p++);\\r\\nt1= x2+ *(p++);\\r\\nx4&=0xffff;\\r\\nidea_mul(x4,x4,*p,ul);\\r\\nd[0]=(t0&0xffff)|((x1&0xffff)<<16);\\r\\nd[1]=(x4&0xffff)|((t1&0xffff)<<16);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p12_crt_c", "target": 0, "func": "PKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert,\\r\\nSTACK *ca, int nid_key, int nid_cert, int iter, int mac_iter,\\r\\nint keytype)\\r\\n{\\r\\nPKCS12 *p12;\\r\\nSTACK *bags, *safes;\\r\\nPKCS12_SAFEBAG *bag;\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nPKCS7 *authsafe;\\r\\nX509 *tcert;\\r\\nint i;\\r\\nunsigned char keyid[EVP_MAX_MD_SIZE];\\r\\nunsigned int keyidlen;\\r\\nif(!nid_cert) nid_cert = NID_pbe_WithSHA1And40BitRC2_CBC;\\r\\nif(!nid_key) nid_key = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nif(!iter) iter = PKCS12_DEFAULT_ITER;\\r\\nif(!mac_iter) mac_iter = 1;\\r\\nif(!pkey || !cert) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,PKCS12_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(bags = sk_new (NULL))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(bag = M_PKCS12_x5092certbag(cert))) return NULL;\\r\\nif(name && !PKCS12_add_friendlyname(bag, name, -1)) return NULL;\\r\\nX509_digest(cert, EVP_sha1(), keyid, &keyidlen);\\r\\nif(!PKCS12_add_localkeyid(bag, keyid, keyidlen)) return NULL;\\r\\nif(!sk_push(bags, (char *)bag)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(ca) {\\r\\nfor(i = 0; i < sk_num(ca); i++) {\\r\\ntcert = (X509 *)sk_value(ca, i);\\r\\nif(!(bag = M_PKCS12_x5092certbag(tcert))) return NULL;\\r\\nif(!sk_push(bags, (char *)bag)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n}\\r\\nauthsafe = PKCS12_pack_p7encdata (nid_cert, pass, -1, NULL, 0,\\r\\niter, bags);\\r\\nsk_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nif (!authsafe) return NULL;\\r\\nif(!(safes = sk_new (NULL)) || !sk_push(safes, (char *)authsafe)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(p8 = EVP_PKEY2PKCS8 (pkey))) return NULL;\\r\\nif(keytype && !PKCS8_add_keyusage(p8, keytype)) return NULL;\\r\\nbag = PKCS12_MAKE_SHKEYBAG (nid_key, pass, -1, NULL, 0, iter, p8);\\r\\nif(!bag) return NULL;\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nif (name && !PKCS12_add_friendlyname (bag, name, -1)) return NULL;\\r\\nif(!PKCS12_add_localkeyid (bag, keyid, keyidlen)) return NULL;\\r\\nif(!(bags = sk_new(NULL)) || !sk_push (bags, (char *)bag)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(authsafe = PKCS12_pack_p7data (bags))) return NULL;\\r\\nsk_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nif(!sk_push(safes, (char *)authsafe)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_CREATE,ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif(!(p12 = PKCS12_init (NID_pkcs7_data))) return NULL;\\r\\nif(!M_PKCS12_pack_authsafes (p12, safes)) return NULL;\\r\\nsk_pop_free(safes, PKCS7_free);\\r\\nif(!PKCS12_set_mac (p12, pass, -1, NULL, 0, mac_iter, NULL))\\r\\nreturn NULL;\\r\\nreturn p12;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_md2_dgst_c", "target": 0, "func": "const char *MD2_options(void)\\r\\n{\\r\\nif (sizeof(MD2_INT) == 1)\\r\\nreturn(\"md2(char)\");\\r\\nelse\\r\\nreturn(\"md2(int)\");\\r\\n}\\r\\nvoid MD2_Init(MD2_CTX *c)\\r\\n{\\r\\nc->num=0;\\r\\nmemset(c->state,0,MD2_BLOCK*sizeof(MD2_INT));\\r\\nmemset(c->cksm,0,MD2_BLOCK*sizeof(MD2_INT));\\r\\nmemset(c->data,0,MD2_BLOCK);\\r\\n}\\r\\nvoid MD2_Update(MD2_CTX *c, register unsigned char *data, unsigned long len)\\r\\n{\\r\\nregister UCHAR *p;\\r\\nif (len == 0) return;\\r\\np=c->data;\\r\\nif (c->num != 0)\\r\\n{\\r\\nif ((c->num+len) >= MD2_BLOCK)\\r\\n{\\r\\nmemcpy(&(p[c->num]),data,MD2_BLOCK-c->num);\\r\\nmd2_block(c,c->data);\\r\\ndata+=(MD2_BLOCK - c->num);\\r\\nlen-=(MD2_BLOCK - c->num);\\r\\nc->num=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(&(p[c->num]),data,(int)len);\\r\\nc->num+=(int)len;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nwhile (len >= MD2_BLOCK)\\r\\n{\\r\\nmd2_block(c,data);\\r\\ndata+=MD2_BLOCK;\\r\\nlen-=MD2_BLOCK;\\r\\n}\\r\\nmemcpy(p,data,(int)len);\\r\\nc->num=(int)len;\\r\\n}\\r\\nstatic void md2_block(MD2_CTX *c, unsigned char *d)\\r\\n{\\r\\nregister MD2_INT t,*sp1,*sp2;\\r\\nregister int i,j;\\r\\nMD2_INT state[48];\\r\\nsp1=c->state;\\r\\nsp2=c->cksm;\\r\\nj=sp2[MD2_BLOCK-1];\\r\\nfor (i=0; i<16; i++)\\r\\n{\\r\\nstate[i]=sp1[i];\\r\\nstate[i+16]=t=d[i];\\r\\nstate[i+32]=(t^sp1[i]);\\r\\nj=sp2[i]^=S[t^j];\\r\\n}\\r\\nt=0;\\r\\nfor (i=0; i<18; i++)\\r\\n{\\r\\nfor (j=0; j<48; j+=8)\\r\\n{\\r\\nt= state[j+ 0]^=S[t];\\r\\nt= state[j+ 1]^=S[t];\\r\\nt= state[j+ 2]^=S[t];\\r\\nt= state[j+ 3]^=S[t];\\r\\nt= state[j+ 4]^=S[t];\\r\\nt= state[j+ 5]^=S[t];\\r\\nt= state[j+ 6]^=S[t];\\r\\nt= state[j+ 7]^=S[t];\\r\\n}\\r\\nt=(t+i)&0xff;\\r\\n}\\r\\nmemcpy(sp1,state,16*sizeof(MD2_INT));\\r\\nmemset(state,0,48*sizeof(MD2_INT));\\r\\n}\\r\\nvoid MD2_Final(unsigned char *md, MD2_CTX *c)\\r\\n{\\r\\nint i,v;\\r\\nregister UCHAR *cp;\\r\\nregister MD2_INT *p1,*p2;\\r\\ncp=c->data;\\r\\np1=c->state;\\r\\np2=c->cksm;\\r\\nv=MD2_BLOCK-c->num;\\r\\nfor (i=c->num; i<MD2_BLOCK; i++)\\r\\ncp[i]=(UCHAR)v;\\r\\nmd2_block(c,cp);\\r\\nfor (i=0; i<MD2_BLOCK; i++)\\r\\ncp[i]=(UCHAR)p2[i];\\r\\nmd2_block(c,cp);\\r\\nfor (i=0; i<16; i++)\\r\\nmd[i]=(UCHAR)(p1[i]&0xff);\\r\\nmemset((char *)&c,0,sizeof(c));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_o_names_c", "target": 0, "func": "int OBJ_NAME_init(void)\\r\\n{\\r\\nif (names_lh != NULL) return(1);\\r\\nMemCheck_off();\\r\\nnames_lh=lh_new(obj_name_hash,obj_name_cmp);\\r\\nMemCheck_on();\\r\\nreturn(names_lh != NULL);\\r\\n}\\r\\nstatic int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b)\\r\\n{\\r\\nint ret;\\r\\nint (*cmp)();\\r\\nret=a->type-b->type;\\r\\nif (ret == 0)\\r\\n{\\r\\nif ((names_cmp != NULL) && (sk_num(names_cmp) > a->type))\\r\\n{\\r\\ncmp=(int (*)())sk_value(names_cmp,a->type);\\r\\nret=cmp(a->name,b->name);\\r\\n}\\r\\nelse\\r\\nret=strcmp(a->name,b->name);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic unsigned long obj_name_hash(OBJ_NAME *a)\\r\\n{\\r\\nunsigned long ret;\\r\\nunsigned long (*hash)();\\r\\nif ((names_hash != NULL) && (sk_num(names_hash) > a->type))\\r\\n{\\r\\nhash=(unsigned long (*)())sk_value(names_hash,a->type);\\r\\nret=hash(a->name);\\r\\n}\\r\\nelse\\r\\n{\\r\\nret=lh_strhash(a->name);\\r\\n}\\r\\nret^=a->type;\\r\\nreturn(ret);\\r\\n}\\r\\nconst char *OBJ_NAME_get(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on,*ret;\\r\\nint num=0,alias;\\r\\nif (name == NULL) return(NULL);\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(NULL);\\r\\nalias=type&OBJ_NAME_ALIAS;\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\non.name=name;\\r\\non.type=type;\\r\\nfor (;;)\\r\\n{\\r\\nret=(OBJ_NAME *)lh_retrieve(names_lh,(char *)&on);\\r\\nif (ret == NULL) return(NULL);\\r\\nif ((ret->alias) && !alias)\\r\\n{\\r\\nif (++num > 10) return(NULL);\\r\\non.name=ret->data;\\r\\n}\\r\\nelse\\r\\n{\\r\\nreturn(ret->data);\\r\\n}\\r\\n}\\r\\n}\\r\\nint OBJ_NAME_add(const char *name, int type, const char *data)\\r\\n{\\r\\nvoid (*f)();\\r\\nOBJ_NAME *onp,*ret;\\r\\nint alias;\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(0);\\r\\nalias=type&OBJ_NAME_ALIAS;\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\nonp=(OBJ_NAME *)Malloc(sizeof(OBJ_NAME));\\r\\nif (onp == NULL)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nonp->name=name;\\r\\nonp->alias=alias;\\r\\nonp->type=type;\\r\\nonp->data=data;\\r\\nret=(OBJ_NAME *)lh_insert(names_lh,(char *)onp);\\r\\nif (ret != NULL)\\r\\n{\\r\\nif ((names_free != NULL) && (sk_num(names_free) > ret->type))\\r\\n{\\r\\nf=(void (*)())sk_value(names_free,ret->type);\\r\\nf(ret->name,ret->type,ret->data);\\r\\n}\\r\\nFree((char *)ret);\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (lh_error(names_lh))\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\n}\\r\\nreturn(1);\\r\\n}\\r\\nint OBJ_NAME_remove(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on,*ret;\\r\\nvoid (*f)();\\r\\nif (names_lh == NULL) return(0);\\r\\ntype&= ~OBJ_NAME_ALIAS;\\r\\non.name=name;\\r\\non.type=type;\\r\\nret=(OBJ_NAME *)lh_delete(names_lh,(char *)&on);\\r\\nif (ret != NULL)\\r\\n{\\r\\nif ((names_free != NULL) && (sk_num(names_free) > type))\\r\\n{\\r\\nf=(void (*)())sk_value(names_free,type);\\r\\nf(ret->name,ret->type,ret->data);\\r\\n}\\r\\nFree((char *)ret);\\r\\nreturn(1);\\r\\n}\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nstatic void names_lh_free(OBJ_NAME *onp, int type)\\r\\n{\\r\\nif(onp == NULL)\\r\\nreturn;\\r\\nif ((free_type < 0) || (free_type == onp->type))\\r\\n{\\r\\nOBJ_NAME_remove(onp->name,onp->type);\\r\\n}\\r\\n}\\r\\nvoid OBJ_NAME_cleanup(int type)\\r\\n{\\r\\nunsigned long down_load;\\r\\nif (names_lh == NULL) return;\\r\\nfree_type=type;\\r\\ndown_load=names_lh->down_load;\\r\\nnames_lh->down_load=0;\\r\\nlh_doall(names_lh,names_lh_free);\\r\\nif (type < 0)\\r\\n{\\r\\nlh_free(names_lh);\\r\\nsk_free(names_hash);\\r\\nsk_free(names_cmp);\\r\\nsk_free(names_free);\\r\\nnames_lh=NULL;\\r\\nnames_hash=NULL;\\r\\nnames_cmp=NULL;\\r\\nnames_free=NULL;\\r\\n}\\r\\nelse\\r\\nnames_lh->down_load=down_load;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_supp_c", "target": 0, "func": "void des_cblock_print_file(const_des_cblock *cb, FILE *fp)\\r\\n{\\r\\nint i;\\r\\nconst unsigned int *p = (const unsigned int *)cb;\\r\\nfprintf(fp, \" 0x { \");\\r\\nfor (i = 0; i < 8; i++) {\\r\\nfprintf(fp, \"%x\", p[i]);\\r\\nif (i != 7) fprintf(fp, \", \");\\r\\n}\\r\\nfprintf(fp, \" }\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_oaep_c", "target": 0, "func": "int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen, unsigned char *param, int plen)\\r\\n{\\r\\nint i, emlen = tlen - 1;\\r\\nunsigned char *db, *seed;\\r\\nunsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];\\r\\nif (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\nif (emlen < 2 * SHA_DIGEST_LENGTH + 1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);\\r\\nreturn (0);\\r\\n}\\r\\ndbmask = Malloc(emlen - SHA_DIGEST_LENGTH);\\r\\nif (dbmask == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nto[0] = 0;\\r\\nseed = to + 1;\\r\\ndb = to + SHA_DIGEST_LENGTH + 1;\\r\\nSHA1(param, plen, db);\\r\\nmemset(db + SHA_DIGEST_LENGTH, 0,\\r\\nemlen - flen - 2 * SHA_DIGEST_LENGTH - 1);\\r\\ndb[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;\\r\\nmemcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);\\r\\nRAND_bytes(seed, SHA_DIGEST_LENGTH);\\r\\n#ifdef PKCS_TESTVECT\\r\\nmemcpy(seed,\\r\\n\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\\xf0\\x6c\\xb5\\x8f\",\\r\\n20);\\r\\n#endif\\r\\nMGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)\\r\\ndb[i] ^= dbmask[i];\\r\\nMGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < SHA_DIGEST_LENGTH; i++)\\r\\nseed[i] ^= seedmask[i];\\r\\nFree(dbmask);\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nunsigned char *from, int flen, int num, unsigned char *param,\\r\\nint plen)\\r\\n{\\r\\nint i, dblen, mlen = -1;\\r\\nunsigned char *maskeddb;\\r\\nint lzero;\\r\\nunsigned char *db, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];\\r\\nif (--num < 2 * SHA_DIGEST_LENGTH + 1)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);\\r\\nreturn (-1);\\r\\n}\\r\\ndblen = num - SHA_DIGEST_LENGTH;\\r\\ndb = Malloc(dblen);\\r\\nif (db == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\\r\\nreturn (-1);\\r\\n}\\r\\nlzero = num - flen;\\r\\nmaskeddb = from - lzero + SHA_DIGEST_LENGTH;\\r\\nMGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);\\r\\nfor (i = lzero; i < SHA_DIGEST_LENGTH; i++)\\r\\nseed[i] ^= from[i - lzero];\\r\\nMGF1(db, dblen, seed, SHA_DIGEST_LENGTH);\\r\\nfor (i = 0; i < dblen; i++)\\r\\ndb[i] ^= maskeddb[i];\\r\\nSHA1(param, plen, phash);\\r\\nif (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0)\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);\\r\\nelse\\r\\n{\\r\\nfor (i = SHA_DIGEST_LENGTH; i < dblen; i++)\\r\\nif (db[i] != 0x00)\\r\\nbreak;\\r\\nif (db[i] != 0x01 || i++ >= dblen)\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP,\\r\\nRSA_R_OAEP_DECODING_ERROR);\\r\\nelse\\r\\n{\\r\\nmlen = dblen - i;\\r\\nif (tlen < mlen)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);\\r\\nmlen = -1;\\r\\n}\\r\\nelse\\r\\nmemcpy(to, db + i, mlen);\\r\\n}\\r\\n}\\r\\nFree(db);\\r\\nreturn (mlen);\\r\\n}\\r\\nint MGF1(unsigned char *mask, long len, unsigned char *seed, long seedlen)\\r\\n{\\r\\nlong i, outlen = 0;\\r\\nunsigned char cnt[4];\\r\\nSHA_CTX c;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\nfor (i = 0; outlen < len; i++)\\r\\n{\\r\\ncnt[0] = (i >> 24) & 255, cnt[1] = (i >> 16) & 255,\\r\\ncnt[2] = (i >> 8) & 255, cnt[3] = i & 255;\\r\\nSHA1_Init(&c);\\r\\nSHA1_Update(&c, seed, seedlen);\\r\\nSHA1_Update(&c, cnt, 4);\\r\\nif (outlen + SHA_DIGEST_LENGTH <= len)\\r\\n{\\r\\nSHA1_Final(mask + outlen, &c);\\r\\noutlen += SHA_DIGEST_LENGTH;\\r\\n}\\r\\nelse\\r\\n{\\r\\nSHA1_Final(md, &c);\\r\\nmemcpy(mask + outlen, md, len - outlen);\\r\\noutlen = len;\\r\\n}\\r\\n}\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_i2d_pu_c", "target": 0, "func": "int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\n#ifndef NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nreturn(i2d_RSAPublicKey(a->pkey.rsa,pp));\\r\\n#endif\\r\\n#ifndef NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nreturn(i2d_DSAPublicKey(a->pkey.dsa,pp));\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_I2D_PUBLICKEY,ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_bio_c", "target": 0, "func": "BIO_METHOD *BIO_s_bio(void)\\r\\n{\\r\\nreturn &methods_biop;\\r\\n}\\r\\nstatic int bio_new(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nb = Malloc(sizeof *b);\\r\\nif (b == NULL)\\r\\nreturn 0;\\r\\nb->peer = NULL;\\r\\nb->size = 17*1024;\\r\\nb->buf = NULL;\\r\\nbio->ptr = b;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_free(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nif (bio == NULL)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nif (b->peer)\\r\\nbio_destroy_pair(bio);\\r\\nif (b->buf != NULL)\\r\\n{\\r\\nFree(b->buf);\\r\\n}\\r\\nFree(b);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_read(BIO *bio, char *buf, int size_)\\r\\n{\\r\\nsize_t size = size_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\npeer_b = b->peer->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->request = 0;\\r\\nif (buf == NULL || size == 0)\\r\\nreturn 0;\\r\\nif (peer_b->len == 0)\\r\\n{\\r\\nif (peer_b->closed)\\r\\nreturn 0;\\r\\nelse\\r\\n{\\r\\nBIO_set_retry_read(bio);\\r\\nif (size <= peer_b->size)\\r\\npeer_b->request = size;\\r\\nelse\\r\\npeer_b->request = peer_b->size;\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (peer_b->len < size)\\r\\nsize = peer_b->len;\\r\\nrest = size;\\r\\nassert(rest > 0);\\r\\ndo\\r\\n{\\r\\nsize_t chunk;\\r\\nassert(rest <= peer_b->len);\\r\\nif (peer_b->offset + rest <= peer_b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = peer_b->size - peer_b->offset;\\r\\nassert(peer_b->offset + chunk <= peer_b->size);\\r\\nmemcpy(buf, peer_b->buf + peer_b->offset, chunk);\\r\\npeer_b->len -= chunk;\\r\\nif (peer_b->len)\\r\\n{\\r\\npeer_b->offset += chunk;\\r\\nassert(peer_b->offset <= peer_b->size);\\r\\nif (peer_b->offset == peer_b->size)\\r\\npeer_b->offset = 0;\\r\\nbuf += chunk;\\r\\n}\\r\\nelse\\r\\n{\\r\\nassert(chunk == rest);\\r\\npeer_b->offset = 0;\\r\\n}\\r\\nrest -= chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn size;\\r\\n}\\r\\nstatic int bio_write(BIO *bio, char *buf, int num_)\\r\\n{\\r\\nsize_t num = num_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init || buf == NULL || num == 0)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\nassert(b->buf != NULL);\\r\\nb->request = 0;\\r\\nif (b->closed)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_WRITE, BIO_R_BROKEN_PIPE);\\r\\nreturn -1;\\r\\n}\\r\\nassert(b->len <= b->size);\\r\\nif (b->len == b->size)\\r\\n{\\r\\nBIO_set_retry_write(bio);\\r\\nreturn -1;\\r\\n}\\r\\nif (num > b->size - b->len)\\r\\nnum = b->size - b->len;\\r\\nrest = num;\\r\\nassert(rest > 0);\\r\\ndo\\r\\n{\\r\\nsize_t write_offset;\\r\\nsize_t chunk;\\r\\nassert(b->len + rest <= b->size);\\r\\nwrite_offset = b->offset + b->len;\\r\\nif (write_offset >= b->size)\\r\\nwrite_offset -= b->size;\\r\\nif (write_offset + rest <= b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = b->size - write_offset;\\r\\nmemcpy(b->buf + write_offset, buf, chunk);\\r\\nb->len += chunk;\\r\\nassert(b->len <= b->size);\\r\\nrest -= chunk;\\r\\nbuf += chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn num;\\r\\n}\\r\\nstatic long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nassert(b != NULL);\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_C_SET_WRITE_BUF_SIZE:\\r\\nif (b->peer)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);\\r\\nret = 0;\\r\\n}\\r\\nelse if (num == 0)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);\\r\\nret = 0;\\r\\n}\\r\\nelse\\r\\n{\\r\\nsize_t new_size = num;\\r\\nif (b->size != new_size)\\r\\n{\\r\\nif (b->buf)\\r\\n{\\r\\nFree(b->buf);\\r\\nb->buf = NULL;\\r\\n}\\r\\nb->size = new_size;\\r\\n}\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_BUF_SIZE:\\r\\nnum = (long) b->size;\\r\\ncase BIO_C_MAKE_BIO_PAIR:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (bio_make_pair(bio, other_bio))\\r\\nret = 1;\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DESTROY_BIO_PAIR:\\r\\nbio_destroy_pair(bio);\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_GUARANTEE:\\r\\nif (b->peer == NULL || b->closed)\\r\\nret = 0;\\r\\nelse\\r\\nret = (long) b->size - b->len;\\r\\nbreak;\\r\\ncase BIO_C_GET_READ_REQUEST:\\r\\nret = (long) b->request;\\r\\nbreak;\\r\\ncase BIO_C_SHUTDOWN_WR:\\r\\nb->closed = 1;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->buf != NULL)\\r\\n{\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = bio->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nbio->shutdown = (int) num;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nif (b->peer != NULL)\\r\\n{\\r\\nstruct bio_bio_st *peer_b = b->peer->ptr;\\r\\nret = (long) peer_b->len;\\r\\n}\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nif (b->buf != NULL)\\r\\nret = (long) b->len;\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nstruct bio_bio_st *other_b;\\r\\nassert(other_bio != NULL);\\r\\nother_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nassert(other_b->buf == NULL);\\r\\nother_b->size = b->size;\\r\\n}\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (other_bio)\\r\\n{\\r\\nstruct bio_bio_st *other_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nret = other_b->len == 0 && other_b->closed;\\r\\n}\\r\\nelse\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int bio_puts(BIO *bio, char *str)\\r\\n{\\r\\nreturn bio_write(bio, str, strlen(str));\\r\\n}\\r\\nstatic int bio_make_pair(BIO *bio1, BIO *bio2)\\r\\n{\\r\\nstruct bio_bio_st *b1, *b2;\\r\\nassert(bio1 != NULL);\\r\\nassert(bio2 != NULL);\\r\\nb1 = bio1->ptr;\\r\\nb2 = bio2->ptr;\\r\\nif (b1->peer != NULL || b2->peer != NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, BIO_R_IN_USE);\\r\\nreturn 0;\\r\\n}\\r\\nif (b1->buf == NULL)\\r\\n{\\r\\nb1->buf = Malloc(b1->size);\\r\\nif (b1->buf == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb1->len = 0;\\r\\nb1->offset = 0;\\r\\n}\\r\\nif (b2->buf == NULL)\\r\\n{\\r\\nb2->buf = Malloc(b2->size);\\r\\nif (b2->buf == NULL)\\r\\n{\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb2->len = 0;\\r\\nb2->offset = 0;\\r\\n}\\r\\nb1->peer = bio2;\\r\\nb1->closed = 0;\\r\\nb1->request = 0;\\r\\nb2->peer = bio1;\\r\\nb2->closed = 0;\\r\\nb2->request = 0;\\r\\nbio1->init = 1;\\r\\nbio2->init = 1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void bio_destroy_pair(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nif (b != NULL)\\r\\n{\\r\\nBIO *peer_bio = b->peer;\\r\\nif (peer_bio != NULL)\\r\\n{\\r\\nstruct bio_bio_st *peer_b = peer_bio->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->peer == bio);\\r\\npeer_b->peer = NULL;\\r\\npeer_bio->init = 0;\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->len = 0;\\r\\npeer_b->offset = 0;\\r\\nb->peer = NULL;\\r\\nbio->init = 0;\\r\\nassert(b->buf != NULL);\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nint BIO_new_bio_pair(BIO **bio1_p, size_t writebuf1,\\r\\nBIO **bio2_p, size_t writebuf2)\\r\\n{\\r\\nBIO *bio1 = NULL, *bio2 = NULL;\\r\\nlong r;\\r\\nint ret = 0;\\r\\nbio1 = BIO_new(BIO_s_bio());\\r\\nif (bio1 == NULL)\\r\\ngoto err;\\r\\nbio2 = BIO_new(BIO_s_bio());\\r\\nif (bio2 == NULL)\\r\\ngoto err;\\r\\nif (writebuf1)\\r\\n{\\r\\nr = BIO_set_write_buf_size(bio1, writebuf1);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nif (writebuf2)\\r\\n{\\r\\nr = BIO_set_write_buf_size(bio2, writebuf2);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nr = BIO_make_bio_pair(bio1, bio2);\\r\\nif (!r)\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ret == 0)\\r\\n{\\r\\nif (bio1)\\r\\n{\\r\\nBIO_free(bio1);\\r\\nbio1 = NULL;\\r\\n}\\r\\nif (bio2)\\r\\n{\\r\\nBIO_free(bio2);\\r\\nbio2 = NULL;\\r\\n}\\r\\n}\\r\\n*bio1_p = bio1;\\r\\n*bio2_p = bio2;\\r\\nreturn ret;\\r\\n}\\r\\nsize_t BIO_ctrl_get_write_guarantee(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_WRITE_GUARANTEE, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_get_read_request(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_READ_REQUEST, 0, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_hmac_c", "target": 0, "func": "void HMAC_Init(HMAC_CTX *ctx, const void *key, int len,\\r\\nconst EVP_MD *md)\\r\\n{\\r\\nint i,j,reset=0;\\r\\nunsigned char pad[HMAC_MAX_MD_CBLOCK];\\r\\nif (md != NULL)\\r\\n{\\r\\nreset=1;\\r\\nctx->md=md;\\r\\n}\\r\\nelse\\r\\nmd=ctx->md;\\r\\nif (key != NULL)\\r\\n{\\r\\nreset=1;\\r\\nj=EVP_MD_block_size(md);\\r\\nif (j < len)\\r\\n{\\r\\nEVP_DigestInit(&ctx->md_ctx,md);\\r\\nEVP_DigestUpdate(&ctx->md_ctx,key,len);\\r\\nEVP_DigestFinal(&(ctx->md_ctx),ctx->key,\\r\\n&ctx->key_length);\\r\\n}\\r\\nelse\\r\\n{\\r\\nmemcpy(ctx->key,key,len);\\r\\nmemset(&(ctx->key[len]),0,sizeof(ctx->key)-len);\\r\\nctx->key_length=len;\\r\\n}\\r\\n}\\r\\nif (reset)\\r\\n{\\r\\nfor (i=0; i<HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i]=0x36^ctx->key[i];\\r\\nEVP_DigestInit(&ctx->i_ctx,md);\\r\\nEVP_DigestUpdate(&ctx->i_ctx,pad,EVP_MD_block_size(md));\\r\\nfor (i=0; i<HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i]=0x5c^ctx->key[i];\\r\\nEVP_DigestInit(&ctx->o_ctx,md);\\r\\nEVP_DigestUpdate(&ctx->o_ctx,pad,EVP_MD_block_size(md));\\r\\n}\\r\\nmemcpy(&ctx->md_ctx,&ctx->i_ctx,sizeof(ctx->i_ctx));\\r\\n}\\r\\nvoid HMAC_Update(HMAC_CTX *ctx, unsigned char *data, int len)\\r\\n{\\r\\nEVP_DigestUpdate(&(ctx->md_ctx),data,len);\\r\\n}\\r\\nvoid HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len)\\r\\n{\\r\\nint j;\\r\\nunsigned int i;\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\nj=EVP_MD_block_size(ctx->md);\\r\\nEVP_DigestFinal(&(ctx->md_ctx),buf,&i);\\r\\nmemcpy(&(ctx->md_ctx),&(ctx->o_ctx),sizeof(ctx->o_ctx));\\r\\nEVP_DigestUpdate(&(ctx->md_ctx),buf,i);\\r\\nEVP_DigestFinal(&(ctx->md_ctx),md,len);\\r\\n}\\r\\nvoid HMAC_cleanup(HMAC_CTX *ctx)\\r\\n{\\r\\nmemset(ctx,0,sizeof(HMAC_CTX));\\r\\n}\\r\\nunsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,\\r\\nunsigned char *d, int n, unsigned char *md,\\r\\nunsigned int *md_len)\\r\\n{\\r\\nHMAC_CTX c;\\r\\nstatic unsigned char m[EVP_MAX_MD_SIZE];\\r\\nif (md == NULL) md=m;\\r\\nHMAC_Init(&c,key,key_len,evp_md);\\r\\nHMAC_Update(&c,d,n);\\r\\nHMAC_Final(&c,md,md_len);\\r\\nHMAC_cleanup(&c);\\r\\nreturn(md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_read2pwd_c", "target": 0, "func": "int des_read_password(des_cblock *key, const char *prompt, int verify)\\r\\n{\\r\\nint ok;\\r\\nchar buf[BUFSIZ],buff[BUFSIZ];\\r\\nif ((ok=des_read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)\\r\\ndes_string_to_key(buf,key);\\r\\nmemset(buf,0,BUFSIZ);\\r\\nmemset(buff,0,BUFSIZ);\\r\\nreturn(ok);\\r\\n}\\r\\nint des_read_2passwords(des_cblock *key1, des_cblock *key2, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nint ok;\\r\\nchar buf[BUFSIZ],buff[BUFSIZ];\\r\\nif ((ok=des_read_pw(buf,buff,BUFSIZ,prompt,verify)) == 0)\\r\\ndes_string_to_2keys(buf,key1,key2);\\r\\nmemset(buf,0,BUFSIZ);\\r\\nmemset(buff,0,BUFSIZ);\\r\\nreturn(ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_sha1_c", "target": 0, "func": "EVP_MD *EVP_sha1(void)\\r\\n{\\r\\nreturn(&sha1_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_err_c", "target": 1, "func": "void ERR_load_SSL_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_SSL,SSL_str_functs);\\r\\nERR_load_strings(ERR_LIB_SSL,SSL_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_dh_err_c", "target": 1, "func": "void ERR_load_DH_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_DH,DH_str_functs);\\r\\nERR_load_strings(ERR_LIB_DH,DH_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_t1_clnt_c", "target": 0, "func": "static SSL_METHOD *tls1_get_client_method(int ver)\\r\\n{\\r\\nif (ver == TLS1_VERSION)\\r\\nreturn(TLSv1_client_method());\\r\\nelse\\r\\nreturn(NULL);\\r\\n}\\r\\nSSL_METHOD *TLSv1_client_method(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nstatic SSL_METHOD TLSv1_client_data;\\r\\nif (init)\\r\\n{\\r\\nmemcpy((char *)&TLSv1_client_data,(char *)tlsv1_base_method(),\\r\\nsizeof(SSL_METHOD));\\r\\nTLSv1_client_data.ssl_connect=ssl3_connect;\\r\\nTLSv1_client_data.get_ssl_method=tls1_get_client_method;\\r\\ninit=0;\\r\\n}\\r\\nreturn(&TLSv1_client_data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_stream_c", "target": 0, "func": "main()\\r\\n{\\r\\nfprintf(stderr,\"rc4\\n\");\\r\\nrc4();\\r\\nfprintf(stderr,\"cfb des\\n\");\\r\\ndes();\\r\\n}\\r\\nint des()\\r\\n{\\r\\ndes_key_schedule ks;\\r\\ndes_cblock iv,key;\\r\\nint num;\\r\\nstatic char *keystr=\"01234567\";\\r\\nstatic char *in1=\"0123456789ABCEDFdata 12345\";\\r\\nstatic char *in2=\"9876543210abcdefdata 12345\";\\r\\nunsigned char out[100];\\r\\nint i;\\r\\ndes_set_key((des_cblock *)keystr,ks);\\r\\nnum=0;\\r\\nmemset(iv,0,8);\\r\\ndes_cfb64_encrypt(in1,out,26,ks,(des_cblock *)iv,&num,1);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\nnum=0;\\r\\nmemset(iv,0,8);\\r\\ndes_cfb64_encrypt(in2,out,26,ks,(des_cblock *)iv,&num,1);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\n}\\r\\nint rc4()\\r\\n{\\r\\nstatic char *keystr=\"0123456789abcdef\";\\r\\nRC4_KEY key;\\r\\nunsigned char in[100],out[100];\\r\\nint i;\\r\\nRC4_set_key(&key,16,keystr);\\r\\nin[0]='\\0';\\r\\nstrcpy(in,\"0123456789ABCEDFdata 12345\");\\r\\nRC4(key,26,in,out);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\nRC4_set_key(&key,16,keystr);\\r\\nin[0]='\\0';\\r\\nstrcpy(in,\"9876543210abcdefdata 12345\");\\r\\nRC4(key,26,in,out);\\r\\nfor (i=0; i<26; i++)\\r\\nfprintf(stderr,\"%02X \",out[i]);\\r\\nfprintf(stderr,\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p5_crpt_c", "target": 0, "func": "void PKCS5_PBE_add(void)\\r\\n{\\r\\n#ifndef NO_DES\\r\\n# ifndef NO_MD5\\r\\nEVP_PBE_alg_add(NID_pbeWithMD5AndDES_CBC, EVP_des_cbc(), EVP_md5(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef NO_MD2\\r\\nEVP_PBE_alg_add(NID_pbeWithMD2AndDES_CBC, EVP_des_cbc(), EVP_md2(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef NO_SHA\\r\\nEVP_PBE_alg_add(NID_pbeWithSHA1AndDES_CBC, EVP_des_cbc(), EVP_sha1(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef NO_RC2\\r\\n# ifndef NO_MD5\\r\\nEVP_PBE_alg_add(NID_pbeWithMD5AndRC2_CBC, EVP_rc2_64_cbc(), EVP_md5(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef NO_MD2\\r\\nEVP_PBE_alg_add(NID_pbeWithMD2AndRC2_CBC, EVP_rc2_64_cbc(), EVP_md2(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n# ifndef NO_SHA\\r\\nEVP_PBE_alg_add(NID_pbeWithSHA1AndRC2_CBC, EVP_rc2_64_cbc(), EVP_sha1(),\\r\\nPKCS5_PBE_keyivgen);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef NO_HMAC\\r\\nEVP_PBE_alg_add(NID_pbes2, NULL, NULL, PKCS5_v2_PBE_keyivgen);\\r\\n#endif\\r\\n}\\r\\nint PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER *cipher, EVP_MD *md,\\r\\nint en_de)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char md_tmp[EVP_MAX_MD_SIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\nint i;\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter;\\r\\nunsigned char *salt, *pbuf;\\r\\npbuf = param->value.sequence->data;\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE) ||\\r\\n!(pbe = d2i_PBEPARAM (NULL, &pbuf, param->value.sequence->length))) {\\r\\nEVPerr(EVP_F_PKCS5_PBE_KEYIVGEN,EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter) iter = 1;\\r\\nelse iter = ASN1_INTEGER_get (pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nEVP_DigestInit (&ctx, md);\\r\\nEVP_DigestUpdate (&ctx, pass, passlen);\\r\\nEVP_DigestUpdate (&ctx, salt, saltlen);\\r\\nPBEPARAM_free(pbe);\\r\\nEVP_DigestFinal (&ctx, md_tmp, NULL);\\r\\nfor (i = 1; i < iter; i++) {\\r\\nEVP_DigestInit(&ctx, md);\\r\\nEVP_DigestUpdate(&ctx, md_tmp, EVP_MD_size(md));\\r\\nEVP_DigestFinal (&ctx, md_tmp, NULL);\\r\\n}\\r\\nmemcpy (key, md_tmp, EVP_CIPHER_key_length(cipher));\\r\\nmemcpy (iv, md_tmp + (16 - EVP_CIPHER_iv_length(cipher)),\\r\\nEVP_CIPHER_iv_length(cipher));\\r\\nEVP_CipherInit(cctx, cipher, key, iv, en_de);\\r\\nmemset(md_tmp, 0, EVP_MAX_MD_SIZE);\\r\\nmemset(key, 0, EVP_MAX_KEY_LENGTH);\\r\\nmemset(iv, 0, EVP_MAX_IV_LENGTH);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rc4speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM,sig_done);\\r\\nrun=0;\\r\\n#ifdef LINT\\r\\nsig=sig;\\r\\n#endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart,tend;\\r\\nif (s == START)\\r\\n{\\r\\ntimes(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntimes(&tend);\\r\\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart,tend;\\r\\nlong i;\\r\\nif (s == START)\\r\\n{\\r\\nftime(&tstart);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\n{\\r\\nftime(&tend);\\r\\ni=(long)tend.millitm-(long)tstart.millitm;\\r\\nret=((double)(tend.time-tstart.time))+((double)i)/1e3;\\r\\nreturn((ret == 0.0)?1e-6:ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic unsigned char key[] ={\\r\\n0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0,\\r\\n0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,\\r\\n};\\r\\nRC4_KEY sch;\\r\\ndouble a,b,c,d;\\r\\n#ifndef SIGALRM\\r\\nlong ca,cb,cc;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most acurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nRC4_set_key(&sch,16,key);\\r\\ncount=10;\\r\\ndo {\\r\\nlong i;\\r\\nunsigned long data[2];\\r\\ncount*=2;\\r\\nTime_F(START);\\r\\nfor (i=count; i; i--)\\r\\nRC4(&sch,8,buf,buf);\\r\\nd=Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca=count/512;\\r\\ncc=count*8/BUFSIZE+1;\\r\\nprintf(\"Doing RC4_set_key %ld times\\n\",ca);\\r\\n#define COND(d) (count != (d))\\r\\n#define COUNT(d) (d)\\r\\n#else\\r\\n#define COND(c) (run)\\r\\n#define COUNT(d) (count)\\r\\nsignal(SIGALRM,sig_done);\\r\\nprintf(\"Doing RC4_set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(ca); count+=4)\\r\\n{\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\nRC4_set_key(&sch,16,key);\\r\\n}\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC4_set_key's in %.2f seconds\\n\",count,d);\\r\\na=((double)COUNT(ca))/d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing RC4 on %ld byte blocks for 10 seconds\\n\",BUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing RC4 %ld times on %ld byte blocks\\n\",cc,BUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count=0,run=1; COND(cc); count++)\\r\\nRC4(&sch,BUFSIZE,buf,buf);\\r\\nd=Time_F(STOP);\\r\\nprintf(\"%ld RC4's of %ld byte blocks in %.2f second\\n\",\\r\\ncount,BUFSIZE,d);\\r\\nc=((double)COUNT(cc)*BUFSIZE)/d;\\r\\nprintf(\"RC4 set_key per sec = %12.2f (%9.3fuS)\\n\",a,1.0e6/a);\\r\\nprintf(\"RC4 bytes per sec = %12.2f (%9.3fuS)\\n\",c,8.0e6/c);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(MSDOS)\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_algs_c", "target": 1, "func": "int SSL_library_init(void)\\r\\n{\\r\\n#ifndef NO_DES\\r\\nEVP_add_cipher(EVP_des_cbc());\\r\\nEVP_add_cipher(EVP_des_ede3_cbc());\\r\\n#endif\\r\\n#ifndef NO_IDEA\\r\\nEVP_add_cipher(EVP_idea_cbc());\\r\\n#endif\\r\\n#ifndef NO_RC4\\r\\nEVP_add_cipher(EVP_rc4());\\r\\n#endif\\r\\n#ifndef NO_RC2\\r\\nEVP_add_cipher(EVP_rc2_cbc());\\r\\n#endif\\r\\n#ifndef NO_MD2\\r\\nEVP_add_digest(EVP_md2());\\r\\n#endif\\r\\n#ifndef NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest_alias(SN_md5,\"ssl2-md5\");\\r\\nEVP_add_digest_alias(SN_md5,\"ssl3-md5\");\\r\\n#endif\\r\\n#ifndef NO_SHA\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");\\r\\n#endif\\r\\n#if !defined(NO_SHA) && !defined(NO_DSA)\\r\\nEVP_add_digest(EVP_dss1());\\r\\n#endif\\r\\n#if 0\\r\\nEVP_add_digest(EVP_sha());\\r\\nEVP_add_digest(EVP_dss());\\r\\n#endif\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_v3_enum_c", "target": 0, "func": "static ASN1_ENUMERATED *asn1_enumerated_new(void)\\r\\n{\\r\\nreturn ASN1_ENUMERATED_new();\\r\\n}\\r\\nchar *i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *method,\\r\\nASN1_ENUMERATED *e)\\r\\n{\\r\\nENUMERATED_NAMES *enam;\\r\\nlong strval;\\r\\nstrval = ASN1_ENUMERATED_get(e);\\r\\nfor(enam = method->usr_data; enam->lname; enam++) {\\r\\nif(strval == enam->bitnum) return BUF_strdup(enam->lname);\\r\\n}\\r\\nreturn i2s_ASN1_ENUMERATED(method, e);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rpw_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\ndes_cblock k,k1;\\r\\nint i;\\r\\nprintf(\"read passwd\\n\");\\r\\nif ((i=des_read_password(&k,\"Enter password:\",0)) == 0)\\r\\n{\\r\\nprintf(\"password = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k[i]);\\r\\n}\\r\\nelse\\r\\nprintf(\"error %d\\n\",i);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"read 2passwds and verify\\n\");\\r\\nif ((i=des_read_2passwords(&k,&k1,\\r\\n\"Enter verified password:\",1)) == 0)\\r\\n{\\r\\nprintf(\"password1 = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k[i]);\\r\\nprintf(\"\\n\");\\r\\nprintf(\"password2 = \");\\r\\nfor (i=0; i<8; i++)\\r\\nprintf(\"%02x \",k1[i]);\\r\\nprintf(\"\\n\");\\r\\nexit(1);\\r\\n}\\r\\nelse\\r\\n{\\r\\nprintf(\"error %d\\n\",i);\\r\\nexit(0);\\r\\n}\\r\\n#ifdef LINT\\r\\nreturn(0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_err_c", "target": 0, "func": "void ERR_load_X509_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_X509,X509_str_functs);\\r\\nERR_load_strings(ERR_LIB_X509,X509_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_asn1_err_c", "target": 1, "func": "void ERR_load_ASN1_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_ASN1,ASN1_str_functs);\\r\\nERR_load_strings(ERR_LIB_ASN1,ASN1_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_lu_c", "target": 0, "func": "X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)\\r\\n{\\r\\nX509_LOOKUP *ret;\\r\\nret=(X509_LOOKUP *)Malloc(sizeof(X509_LOOKUP));\\r\\nif (ret == NULL) return(NULL);\\r\\nret->init=0;\\r\\nret->skip=0;\\r\\nret->method=method;\\r\\nret->method_data=NULL;\\r\\nret->store_ctx=NULL;\\r\\nif ((method->new_item != NULL) && !method->new_item(ret))\\r\\n{\\r\\nFree(ret);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nvoid X509_LOOKUP_free(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx == NULL) return;\\r\\nif ( (ctx->method != NULL) &&\\r\\n(ctx->method->free != NULL))\\r\\nctx->method->free(ctx);\\r\\nFree(ctx);\\r\\n}\\r\\nint X509_LOOKUP_init(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL) return(0);\\r\\nif (ctx->method->init != NULL)\\r\\nreturn(ctx->method->init(ctx));\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint X509_LOOKUP_shutdown(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL) return(0);\\r\\nif (ctx->method->shutdown != NULL)\\r\\nreturn(ctx->method->shutdown(ctx));\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,\\r\\nchar **ret)\\r\\n{\\r\\nif (ctx->method == NULL) return(-1);\\r\\nif (ctx->method->ctrl != NULL)\\r\\nreturn(ctx->method->ctrl(ctx,cmd,argc,argl,ret));\\r\\nelse\\r\\nreturn(1);\\r\\n}\\r\\nint X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_subject == NULL))\\r\\nreturn(X509_LU_FAIL);\\r\\nif (ctx->skip) return(0);\\r\\nreturn(ctx->method->get_by_subject(ctx,type,name,ret));\\r\\n}\\r\\nint X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nASN1_INTEGER *serial, X509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) ||\\r\\n(ctx->method->get_by_issuer_serial == NULL))\\r\\nreturn(X509_LU_FAIL);\\r\\nreturn(ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret));\\r\\n}\\r\\nint X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,\\r\\nunsigned char *bytes, int len, X509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_fingerprint == NULL))\\r\\nreturn(X509_LU_FAIL);\\r\\nreturn(ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret));\\r\\n}\\r\\nint X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_alias == NULL))\\r\\nreturn(X509_LU_FAIL);\\r\\nreturn(ctx->method->get_by_alias(ctx,type,str,len,ret));\\r\\n}\\r\\nstatic unsigned long x509_object_hash(X509_OBJECT *a)\\r\\n{\\r\\nunsigned long h;\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nh=X509_NAME_hash(a->data.x509->cert_info->subject);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nh=X509_NAME_hash(a->data.crl->crl->issuer);\\r\\nbreak;\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\nreturn(h);\\r\\n}\\r\\nstatic int x509_object_cmp(X509_OBJECT *a, X509_OBJECT *b)\\r\\n{\\r\\nint ret;\\r\\nret=(a->type - b->type);\\r\\nif (ret) return(ret);\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nret=X509_subject_name_cmp(a->data.x509,b->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nret=X509_CRL_cmp(a->data.crl,b->data.crl);\\r\\nbreak;\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nX509_STORE *X509_STORE_new(void)\\r\\n{\\r\\nX509_STORE *ret;\\r\\nif ((ret=(X509_STORE *)Malloc(sizeof(X509_STORE))) == NULL)\\r\\nreturn(NULL);\\r\\nret->certs=lh_new(x509_object_hash,x509_object_cmp);\\r\\nret->cache=1;\\r\\nret->get_cert_methods=sk_X509_LOOKUP_new_null();\\r\\nret->verify=NULL;\\r\\nret->verify_cb=NULL;\\r\\nmemset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA));\\r\\nret->references=1;\\r\\nret->depth=0;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic void cleanup(X509_OBJECT *a)\\r\\n{\\r\\nif (a->type == X509_LU_X509)\\r\\n{\\r\\nX509_free(a->data.x509);\\r\\n}\\r\\nelse if (a->type == X509_LU_CRL)\\r\\n{\\r\\nX509_CRL_free(a->data.crl);\\r\\n}\\r\\nelse\\r\\nabort();\\r\\nFree(a);\\r\\n}\\r\\nvoid X509_STORE_free(X509_STORE *vfy)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nif(vfy == NULL)\\r\\nreturn;\\r\\nsk=vfy->get_cert_methods;\\r\\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(sk,i);\\r\\nX509_LOOKUP_shutdown(lu);\\r\\nX509_LOOKUP_free(lu);\\r\\n}\\r\\nsk_X509_LOOKUP_free(sk);\\r\\nCRYPTO_free_ex_data(x509_store_meth,(char *)vfy,&vfy->ex_data);\\r\\nlh_doall(vfy->certs,cleanup);\\r\\nlh_free(vfy->certs);\\r\\nFree(vfy);\\r\\n}\\r\\nX509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nsk=v->get_cert_methods;\\r\\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(sk,i);\\r\\nif (m == lu->method)\\r\\n{\\r\\nreturn(lu);\\r\\n}\\r\\n}\\r\\nlu=X509_LOOKUP_new(m);\\r\\nif (lu == NULL)\\r\\nreturn(NULL);\\r\\nelse\\r\\n{\\r\\nlu->store_ctx=v;\\r\\nif (sk_X509_LOOKUP_push(v->get_cert_methods,lu))\\r\\nreturn(lu);\\r\\nelse\\r\\n{\\r\\nX509_LOOKUP_free(lu);\\r\\nreturn(NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nint X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nX509_STORE *ctx=vs->ctx;\\r\\nX509_LOOKUP *lu;\\r\\nX509_OBJECT stmp,*tmp;\\r\\nint i,j;\\r\\ntmp=X509_OBJECT_retrieve_by_subject(ctx->certs,type,name);\\r\\nif (tmp == NULL)\\r\\n{\\r\\nfor (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)\\r\\n{\\r\\nlu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);\\r\\nj=X509_LOOKUP_by_subject(lu,type,name,&stmp);\\r\\nif (j < 0)\\r\\n{\\r\\nvs->current_method=j;\\r\\nreturn(j);\\r\\n}\\r\\nelse if (j)\\r\\n{\\r\\ntmp= &stmp;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvs->current_method=0;\\r\\nif (tmp == NULL)\\r\\nreturn(0);\\r\\n}\\r\\nret->type=tmp->type;\\r\\nret->data.ptr=tmp->data.ptr;\\r\\nX509_OBJECT_up_ref_count(ret);\\r\\nreturn(1);\\r\\n}\\r\\nvoid X509_OBJECT_up_ref_count(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nCRYPTO_add(&a->data.x509->references,1,CRYPTO_LOCK_X509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nCRYPTO_add(&a->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid X509_OBJECT_free_contents(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nX509_free(a->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nX509_CRL_free(a->data.crl);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nX509_OBJECT *X509_OBJECT_retrieve_by_subject(LHASH *h, int type,\\r\\nX509_NAME *name)\\r\\n{\\r\\nX509_OBJECT stmp,*tmp;\\r\\nX509 x509_s;\\r\\nX509_CINF cinf_s;\\r\\nX509_CRL crl_s;\\r\\nX509_CRL_INFO crl_info_s;\\r\\nstmp.type=type;\\r\\nswitch (type)\\r\\n{\\r\\ncase X509_LU_X509:\\r\\nstmp.data.x509= &x509_s;\\r\\nx509_s.cert_info= &cinf_s;\\r\\ncinf_s.subject=name;\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nstmp.data.crl= &crl_s;\\r\\ncrl_s.crl= &crl_info_s;\\r\\ncrl_info_s.issuer=name;\\r\\nbreak;\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\ntmp=(X509_OBJECT *)lh_retrieve(h,(char *)&stmp);\\r\\nreturn(tmp);\\r\\n}\\r\\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\\r\\n{\\r\\nif (ctx->chain != NULL)\\r\\n{\\r\\nsk_X509_pop_free(ctx->chain,X509_free);\\r\\nctx->chain=NULL;\\r\\n}\\r\\nCRYPTO_free_ex_data(x509_store_ctx_meth,(char *)ctx,&(ctx->ex_data));\\r\\nmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p7_signd_c", "target": 0, "func": "int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len_SET_type(X509_ALGOR,a->md_algs,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_len(a->contents,i2d_PKCS7);\\r\\nM_ASN1_I2D_len_IMP_SEQUENCE_opt_type(X509,a->cert,i2d_X509,0);\\r\\nM_ASN1_I2D_len_IMP_SET_opt_type(X509_CRL,a->crl,i2d_X509_CRL,1);\\r\\nM_ASN1_I2D_len_SET_type(PKCS7_SIGNER_INFO,a->signer_info,\\r\\ni2d_PKCS7_SIGNER_INFO);\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->version,i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put_SET_type(X509_ALGOR,a->md_algs,i2d_X509_ALGOR);\\r\\nM_ASN1_I2D_put(a->contents,i2d_PKCS7);\\r\\nM_ASN1_I2D_put_IMP_SEQUENCE_opt_type(X509,a->cert,i2d_X509,0);\\r\\nM_ASN1_I2D_put_IMP_SET_opt_type(X509_CRL,a->crl,i2d_X509_CRL,1);\\r\\nM_ASN1_I2D_put_SET_type(PKCS7_SIGNER_INFO,a->signer_info,\\r\\ni2d_PKCS7_SIGNER_INFO);\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nPKCS7_SIGNED *d2i_PKCS7_SIGNED(PKCS7_SIGNED **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,PKCS7_SIGNED *,PKCS7_SIGNED_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->version,d2i_ASN1_INTEGER);\\r\\nM_ASN1_D2I_get_set_type(X509_ALGOR,ret->md_algs,d2i_X509_ALGOR,\\r\\nX509_ALGOR_free);\\r\\nM_ASN1_D2I_get(ret->contents,d2i_PKCS7);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509,ret->cert,d2i_X509,X509_free,0);\\r\\nM_ASN1_D2I_get_IMP_set_opt_type(X509_CRL,ret->crl,d2i_X509_CRL,\\r\\nX509_CRL_free,1);\\r\\nM_ASN1_D2I_get_set_type(PKCS7_SIGNER_INFO,ret->signer_info,\\r\\nd2i_PKCS7_SIGNER_INFO,PKCS7_SIGNER_INFO_free);\\r\\nM_ASN1_D2I_Finish(a,PKCS7_SIGNED_free,ASN1_F_D2I_PKCS7_SIGNED);\\r\\n}\\r\\nPKCS7_SIGNED *PKCS7_SIGNED_new(void)\\r\\n{\\r\\nPKCS7_SIGNED *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,PKCS7_SIGNED);\\r\\nM_ASN1_New(ret->version,ASN1_INTEGER_new);\\r\\nM_ASN1_New(ret->md_algs,sk_X509_ALGOR_new_null);\\r\\nM_ASN1_New(ret->contents,PKCS7_new);\\r\\nret->cert=NULL;\\r\\nret->crl=NULL;\\r\\nM_ASN1_New(ret->signer_info,sk_PKCS7_SIGNER_INFO_new_null);\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_PKCS7_SIGNED_NEW);\\r\\n}\\r\\nvoid PKCS7_SIGNED_free(PKCS7_SIGNED *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_INTEGER_free(a->version);\\r\\nsk_X509_ALGOR_pop_free(a->md_algs,X509_ALGOR_free);\\r\\nPKCS7_free(a->contents);\\r\\nsk_X509_pop_free(a->cert,X509_free);\\r\\nsk_X509_CRL_pop_free(a->crl,X509_CRL_free);\\r\\nsk_PKCS7_SIGNER_INFO_pop_free(a->signer_info,PKCS7_SIGNER_INFO_free);\\r\\nFree(a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_p_open_c", "target": 0, "func": "int EVP_OpenInit(EVP_CIPHER_CTX *ctx, EVP_CIPHER *type, unsigned char *ek,\\r\\nint ekl, unsigned char *iv, EVP_PKEY *priv)\\r\\n{\\r\\nunsigned char *key=NULL;\\r\\nint i,size=0,ret=0;\\r\\nif (priv->type != EVP_PKEY_RSA)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_OPENINIT,EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\nsize=RSA_size(priv->pkey.rsa);\\r\\nkey=(unsigned char *)Malloc(size+2);\\r\\nif (key == NULL)\\r\\n{\\r\\nEVPerr(EVP_F_EVP_OPENINIT,ERR_R_MALLOC_FAILURE);\\r\\nret= -1;\\r\\ngoto err;\\r\\n}\\r\\ni=EVP_PKEY_decrypt(key,ek,ekl,priv);\\r\\nif (i != type->key_len)\\r\\n{\\r\\ngoto err;\\r\\n}\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nEVP_DecryptInit(ctx,type,key,iv);\\r\\nret=1;\\r\\nerr:\\r\\nif (key != NULL) memset(key,0,size);\\r\\nFree(key);\\r\\nreturn(ret);\\r\\n}\\r\\nint EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\ni=EVP_DecryptFinal(ctx,out,outl);\\r\\nEVP_DecryptInit(ctx,NULL,NULL,NULL);\\r\\nreturn(i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x509_v3_c", "target": 0, "func": "int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit)\\r\\n{\\r\\nif (ex == NULL) return(0);\\r\\nex->critical=(crit)?0xFF:0;\\r\\nreturn(1);\\r\\n}\\r\\nint X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data)\\r\\n{\\r\\nint i;\\r\\nif (ex == NULL) return(0);\\r\\ni=ASN1_OCTET_STRING_set(ex->value,data->data,data->length);\\r\\nif (!i) return(0);\\r\\nreturn(1);\\r\\n}\\r\\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(NULL);\\r\\nreturn(ex->object);\\r\\n}\\r\\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(NULL);\\r\\nreturn(ex->value);\\r\\n}\\r\\nint X509_EXTENSION_get_critical(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL) return(0);\\r\\nreturn(ex->critical);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_example4_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nif ((argc == 1))\\r\\n{\\r\\ndo_encode();\\r\\n}\\r\\nelse if ((argc == 2) && !strcmp(argv[1],\"-d\"))\\r\\n{\\r\\ndo_decode();\\r\\n}\\r\\nelse\\r\\n{\\r\\nfprintf(stderr,\"%s\", usage);\\r\\nexit(1);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid do_encode()\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN+24];\\r\\nunsigned int ebuflen;\\r\\nEVP_ENCODE_CTX ectx;\\r\\nEVP_EncodeInit(&ectx);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nEVP_EncodeUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_EncodeFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nvoid do_decode()\\r\\n{\\r\\nchar buf[BUFLEN];\\r\\nchar ebuf[BUFLEN+24];\\r\\nunsigned int ebuflen;\\r\\nEVP_ENCODE_CTX ectx;\\r\\nEVP_DecodeInit(&ectx);\\r\\nwhile(1)\\r\\n{\\r\\nint readlen = read(STDIN, buf, sizeof(buf));\\r\\nint rc;\\r\\nif (readlen <= 0)\\r\\n{\\r\\nif (!readlen)\\r\\nbreak;\\r\\nelse\\r\\n{\\r\\nperror(\"read\");\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nrc = EVP_DecodeUpdate(&ectx, ebuf, &ebuflen, buf, readlen);\\r\\nif (rc <= 0)\\r\\n{\\r\\nif (!rc)\\r\\n{\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\nbreak;\\r\\n}\\r\\nfprintf(stderr, \"Error: decoding message\\n\");\\r\\nreturn;\\r\\n}\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}\\r\\nEVP_DecodeFinal(&ectx, ebuf, &ebuflen);\\r\\nwrite(STDOUT, ebuf, ebuflen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bio_md_c", "target": 0, "func": "BIO_METHOD *BIO_f_md(void)\\r\\n{\\r\\nreturn(&methods_md);\\r\\n}\\r\\nstatic int md_new(BIO *bi)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nctx=(EVP_MD_CTX *)Malloc(sizeof(EVP_MD_CTX));\\r\\nif (ctx == NULL) return(0);\\r\\nbi->init=0;\\r\\nbi->ptr=(char *)ctx;\\r\\nbi->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int md_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nFree(a->ptr);\\r\\na->ptr=NULL;\\r\\na->init=0;\\r\\na->flags=0;\\r\\nreturn(1);\\r\\n}\\r\\nstatic int md_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret=0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif (out == NULL) return(0);\\r\\nctx=(EVP_MD_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\\r\\nret=BIO_read(b->next_bio,out,outl);\\r\\nif (b->init)\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,(unsigned char *)out,\\r\\n(unsigned int)ret);\\r\\n}\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int md_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret=0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0)) return(0);\\r\\nctx=(EVP_MD_CTX *)b->ptr;\\r\\nif ((ctx != NULL) && (b->next_bio != NULL))\\r\\nret=BIO_write(b->next_bio,in,inl);\\r\\nif (b->init)\\r\\n{\\r\\nif (ret > 0)\\r\\n{\\r\\nEVP_DigestUpdate(ctx,(unsigned char *)in,\\r\\n(unsigned int)ret);\\r\\n}\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long md_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nEVP_MD_CTX *ctx,*dctx,**pctx;\\r\\nconst EVP_MD **ppmd;\\r\\nEVP_MD *md;\\r\\nlong ret=1;\\r\\nBIO *dbio;\\r\\nctx=(EVP_MD_CTX *)b->ptr;\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->init)\\r\\nEVP_DigestInit(ctx,ctx->digest);\\r\\nelse\\r\\nret=0;\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init)\\r\\n{\\r\\nppmd=(const EVP_MD **)ptr;\\r\\n*ppmd=ctx->digest;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD_CTX:\\r\\nif (b->init)\\r\\n{\\r\\npctx=(EVP_MD_CTX **)ptr;\\r\\n*pctx=ctx;\\r\\n}\\r\\nelse\\r\\nret=0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd=(EVP_MD *)ptr;\\r\\nEVP_DigestInit(ctx,md);\\r\\nb->init=1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio=(BIO *)ptr;\\r\\ndctx=(EVP_MD_CTX *)dbio->ptr;\\r\\nmemcpy(dctx,ctx,sizeof(ctx));\\r\\nb->init=1;\\r\\nbreak;\\r\\ndefault:\\r\\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int md_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nunsigned int ret;\\r\\nctx=(EVP_MD_CTX *)bp->ptr;\\r\\nif (size < ctx->digest->md_size)\\r\\nreturn(0);\\r\\nEVP_DigestFinal(ctx,(unsigned char *)buf,&ret);\\r\\nreturn((int)ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_err_c", "target": 0, "func": "static void ERR_STATE_free(ERR_STATE *s)\\r\\n{\\r\\nint i;\\r\\nif(s == NULL)\\r\\nreturn;\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nerr_clear_data(s,i);\\r\\n}\\r\\nFree(s);\\r\\n}\\r\\nvoid ERR_load_ERR_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (init == 0)\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn;\\r\\n}\\r\\ninit=0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(0,ERR_str_libraries);\\r\\nERR_load_strings(0,ERR_str_reasons);\\r\\nERR_load_strings(ERR_LIB_SYS,ERR_str_functs);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nvoid ERR_load_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nif (error_hash == NULL)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);\\r\\nerror_hash=lh_new(err_hash,err_cmp);\\r\\nif (error_hash == NULL)\\r\\n{\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\nreturn;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\nERR_load_ERR_strings();\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR_HASH);\\r\\nwhile (str->error)\\r\\n{\\r\\nstr->error|=ERR_PACK(lib,0,0);\\r\\nlh_insert(error_hash,(char *)str);\\r\\nstr++;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\n}\\r\\nvoid ERR_free_strings(void)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (error_hash != NULL)\\r\\n{\\r\\nlh_free(error_hash);\\r\\nerror_hash=NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nvoid ERR_put_error(int lib, int func, int reason, const char *file,\\r\\nint line)\\r\\n{\\r\\nERR_STATE *es;\\r\\n#ifdef _OSD_POSIX\\r\\nif (strncmp(file,\"*POSIX(\", sizeof(\"*POSIX(\")-1) == 0) {\\r\\nchar *end;\\r\\nfile += sizeof(\"*POSIX(\")-1;\\r\\nend = &file[strlen(file)-1];\\r\\nif (*end == ')')\\r\\n*end = '\\0';\\r\\nif ((end = strrchr(file, '/')) != NULL)\\r\\nfile = &end[1];\\r\\n}\\r\\n#endif\\r\\nes=ERR_get_state();\\r\\nes->top=(es->top+1)%ERR_NUM_ERRORS;\\r\\nif (es->top == es->bottom)\\r\\nes->bottom=(es->bottom+1)%ERR_NUM_ERRORS;\\r\\nes->err_buffer[es->top]=ERR_PACK(lib,func,reason);\\r\\nes->err_file[es->top]=file;\\r\\nes->err_line[es->top]=line;\\r\\nerr_clear_data(es,es->top);\\r\\n}\\r\\nvoid ERR_clear_error(void)\\r\\n{\\r\\nERR_STATE *es;\\r\\nes=ERR_get_state();\\r\\n#if 0\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nes->err_buffer[i]=0;\\r\\nes->err_file[i]=NULL;\\r\\nes->err_line[i]= -1;\\r\\nerr_clear_data(es,i);\\r\\n}\\r\\n#endif\\r\\nes->top=es->bottom=0;\\r\\n}\\r\\nunsigned long ERR_get_error(void)\\r\\n{ return(get_error_values(1,NULL,NULL,NULL,NULL)); }\\r\\nunsigned long ERR_get_error_line(const char **file,\\r\\nint *line)\\r\\n{ return(get_error_values(1,file,line,NULL,NULL)); }\\r\\nunsigned long ERR_get_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{ return(get_error_values(1,file,line,\\r\\ndata,flags)); }\\r\\nunsigned long ERR_peek_error(void)\\r\\n{ return(get_error_values(0,NULL,NULL,NULL,NULL)); }\\r\\nunsigned long ERR_peek_error_line(const char **file,\\r\\nint *line)\\r\\n{ return(get_error_values(0,file,line,NULL,NULL)); }\\r\\nunsigned long ERR_peek_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{ return(get_error_values(0,file,line,\\r\\ndata,flags)); }\\r\\nstatic unsigned long get_error_values(int inc, const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{\\r\\nint i=0;\\r\\nERR_STATE *es;\\r\\nunsigned long ret;\\r\\nes=ERR_get_state();\\r\\nif (es->bottom == es->top) return(0);\\r\\ni=(es->bottom+1)%ERR_NUM_ERRORS;\\r\\nret=es->err_buffer[i];\\r\\nif (inc)\\r\\n{\\r\\nes->bottom=i;\\r\\nes->err_buffer[i]=0;\\r\\n}\\r\\nif ((file != NULL) && (line != NULL))\\r\\n{\\r\\nif (es->err_file[i] == NULL)\\r\\n{\\r\\n*file=\"NA\";\\r\\nif (line != NULL) *line=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*file=es->err_file[i];\\r\\nif (line != NULL) *line=es->err_line[i];\\r\\n}\\r\\n}\\r\\nif (data != NULL)\\r\\n{\\r\\nif (es->err_data[i] == NULL)\\r\\n{\\r\\n*data=\"\";\\r\\nif (flags != NULL) *flags=0;\\r\\n}\\r\\nelse\\r\\n{\\r\\n*data=es->err_data[i];\\r\\nif (flags != NULL) *flags=es->err_data_flags[i];\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nchar *ERR_error_string(unsigned long e, char *ret)\\r\\n{\\r\\nstatic char buf[256];\\r\\nconst char *ls,*fs,*rs;\\r\\nunsigned long l,f,r;\\r\\nint i;\\r\\nl=ERR_GET_LIB(e);\\r\\nf=ERR_GET_FUNC(e);\\r\\nr=ERR_GET_REASON(e);\\r\\nls=ERR_lib_error_string(e);\\r\\nfs=ERR_func_error_string(e);\\r\\nrs=ERR_reason_error_string(e);\\r\\nif (ret == NULL) ret=buf;\\r\\nsprintf(&(ret[0]),\"error:%08lX:\",e);\\r\\ni=strlen(ret);\\r\\nif (ls == NULL)\\r\\nsprintf(&(ret[i]),\":lib(%lu) \",l);\\r\\nelse sprintf(&(ret[i]),\"%s\",ls);\\r\\ni=strlen(ret);\\r\\nif (fs == NULL)\\r\\nsprintf(&(ret[i]),\":func(%lu) \",f);\\r\\nelse sprintf(&(ret[i]),\":%s\",fs);\\r\\ni=strlen(ret);\\r\\nif (rs == NULL)\\r\\nsprintf(&(ret[i]),\":reason(%lu)\",r);\\r\\nelse sprintf(&(ret[i]),\":%s\",rs);\\r\\nreturn(ret);\\r\\n}\\r\\nLHASH *ERR_get_string_table(void)\\r\\n{\\r\\nreturn(error_hash);\\r\\n}\\r\\nLHASH *ERR_get_err_state_table(void)\\r\\n{\\r\\nreturn(thread_hash);\\r\\n}\\r\\nconst char *ERR_lib_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p=NULL;\\r\\nunsigned long l;\\r\\nl=ERR_GET_LIB(e);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);\\r\\nif (error_hash != NULL)\\r\\n{\\r\\nd.error=ERR_PACK(l,0,0);\\r\\np=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nconst char *ERR_func_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p=NULL;\\r\\nunsigned long l,f;\\r\\nl=ERR_GET_LIB(e);\\r\\nf=ERR_GET_FUNC(e);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);\\r\\nif (error_hash != NULL)\\r\\n{\\r\\nd.error=ERR_PACK(l,f,0);\\r\\np=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nconst char *ERR_reason_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d,*p=NULL;\\r\\nunsigned long l,r;\\r\\nl=ERR_GET_LIB(e);\\r\\nr=ERR_GET_REASON(e);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR_HASH);\\r\\nif (error_hash != NULL)\\r\\n{\\r\\nd.error=ERR_PACK(l,0,r);\\r\\np=(ERR_STRING_DATA *)lh_retrieve(error_hash,(char *)&d);\\r\\nif (p == NULL)\\r\\n{\\r\\nd.error=ERR_PACK(0,0,r);\\r\\np=(ERR_STRING_DATA *)lh_retrieve(error_hash,\\r\\n(char *)&d);\\r\\n}\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR_HASH);\\r\\nreturn((p == NULL)?NULL:p->string);\\r\\n}\\r\\nstatic unsigned long err_hash(ERR_STRING_DATA *a)\\r\\n{\\r\\nunsigned long ret,l;\\r\\nl=a->error;\\r\\nret=l^ERR_GET_LIB(l)^ERR_GET_FUNC(l);\\r\\nreturn(ret^ret%19*13);\\r\\n}\\r\\nstatic int err_cmp(ERR_STRING_DATA *a, ERR_STRING_DATA *b)\\r\\n{\\r\\nreturn((int)(a->error-b->error));\\r\\n}\\r\\nstatic unsigned long pid_hash(ERR_STATE *a)\\r\\n{\\r\\nreturn(a->pid*13);\\r\\n}\\r\\nstatic int pid_cmp(ERR_STATE *a, ERR_STATE *b)\\r\\n{\\r\\nreturn((int)((long)a->pid - (long)b->pid));\\r\\n}\\r\\nvoid ERR_remove_state(unsigned long pid)\\r\\n{\\r\\nERR_STATE *p,tmp;\\r\\nif (thread_hash == NULL)\\r\\nreturn;\\r\\nif (pid == 0)\\r\\npid=(unsigned long)CRYPTO_thread_id();\\r\\ntmp.pid=pid;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np=(ERR_STATE *)lh_delete(thread_hash,(char *)&tmp);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nif (p != NULL) ERR_STATE_free(p);\\r\\n}\\r\\nERR_STATE *ERR_get_state(void)\\r\\n{\\r\\nstatic ERR_STATE fallback;\\r\\nERR_STATE *ret=NULL,tmp,*tmpp;\\r\\nint i;\\r\\nunsigned long pid;\\r\\npid=(unsigned long)CRYPTO_thread_id();\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\nif (thread_hash == NULL)\\r\\n{\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (thread_hash == NULL)\\r\\n{\\r\\nMemCheck_off();\\r\\nthread_hash=lh_new(pid_hash,pid_cmp);\\r\\nMemCheck_on();\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nif (thread_hash == NULL) return(&fallback);\\r\\n}\\r\\nelse\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nelse\\r\\n{\\r\\ntmp.pid=pid;\\r\\nret=(ERR_STATE *)lh_retrieve(thread_hash,(char *)&tmp);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nif (ret == NULL)\\r\\n{\\r\\nret=(ERR_STATE *)Malloc(sizeof(ERR_STATE));\\r\\nif (ret == NULL) return(&fallback);\\r\\nret->pid=pid;\\r\\nret->top=0;\\r\\nret->bottom=0;\\r\\nfor (i=0; i<ERR_NUM_ERRORS; i++)\\r\\n{\\r\\nret->err_data[i]=NULL;\\r\\nret->err_data_flags[i]=0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\ntmpp=(ERR_STATE *)lh_insert(thread_hash,(char *)ret);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nif (tmpp != NULL)\\r\\n{\\r\\nERR_STATE_free(tmpp);\\r\\n}\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint ERR_get_next_error_library(void)\\r\\n{\\r\\nstatic int value=ERR_LIB_USER;\\r\\nreturn(value++);\\r\\n}\\r\\nvoid ERR_set_error_data(char *data, int flags)\\r\\n{\\r\\nERR_STATE *es;\\r\\nint i;\\r\\nes=ERR_get_state();\\r\\ni=es->top;\\r\\nif (i == 0)\\r\\ni=ERR_NUM_ERRORS-1;\\r\\nes->err_data[i]=data;\\r\\nes->err_data_flags[es->top]=flags;\\r\\n}\\r\\nvoid ERR_add_error_data(int num, ...)\\r\\n{\\r\\nva_list args;\\r\\nint i,n,s;\\r\\nchar *str,*p,*a;\\r\\ns=64;\\r\\nstr=Malloc(s+1);\\r\\nif (str == NULL) return;\\r\\nstr[0]='\\0';\\r\\nva_start(args, num);\\r\\nn=0;\\r\\nfor (i=0; i<num; i++)\\r\\n{\\r\\na=va_arg(args, char*);\\r\\nif (a != NULL)\\r\\n{\\r\\nn+=strlen(a);\\r\\nif (n > s)\\r\\n{\\r\\ns=n+20;\\r\\np=Realloc(str,s+1);\\r\\nif (p == NULL)\\r\\n{\\r\\nFree(str);\\r\\nreturn;\\r\\n}\\r\\nelse\\r\\nstr=p;\\r\\n}\\r\\nstrcat(str,a);\\r\\n}\\r\\n}\\r\\nERR_set_error_data(str,ERR_TXT_MALLOCED|ERR_TXT_STRING);\\r\\nva_end(args);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_pkey_c", "target": 0, "func": "int i2d_X509_PKEY(X509_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nreturn(0);\\r\\n}\\r\\nX509_PKEY *d2i_X509_PKEY(X509_PKEY **a, unsigned char **pp, long length)\\r\\n{\\r\\nint i;\\r\\nM_ASN1_D2I_vars(a,X509_PKEY *,X509_PKEY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->enc_algor,d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get(ret->enc_pkey,d2i_ASN1_OCTET_STRING);\\r\\nret->cipher.cipher=EVP_get_cipherbyname(\\r\\nOBJ_nid2ln(OBJ_obj2nid(ret->enc_algor->algorithm)));\\r\\nif (ret->cipher.cipher == NULL)\\r\\n{\\r\\nc.error=ASN1_R_UNSUPPORTED_CIPHER;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nif (ret->enc_algor->parameter->type == V_ASN1_OCTET_STRING)\\r\\n{\\r\\ni=ret->enc_algor->parameter->value.octet_string->length;\\r\\nif (i > EVP_MAX_IV_LENGTH)\\r\\n{\\r\\nc.error=ASN1_R_IV_TOO_LARGE;\\r\\nc.line=__LINE__;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(ret->cipher.iv,\\r\\nret->enc_algor->parameter->value.octet_string->data,i);\\r\\n}\\r\\nelse\\r\\nmemset(ret->cipher.iv,0,EVP_MAX_IV_LENGTH);\\r\\nM_ASN1_D2I_Finish(a,X509_PKEY_free,ASN1_F_D2I_X509_PKEY);\\r\\n}\\r\\nX509_PKEY *X509_PKEY_new(void)\\r\\n{\\r\\nX509_PKEY *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_PKEY);\\r\\nret->version=0;\\r\\nM_ASN1_New(ret->enc_algor,X509_ALGOR_new);\\r\\nM_ASN1_New(ret->enc_pkey,ASN1_OCTET_STRING_new);\\r\\nret->dec_pkey=NULL;\\r\\nret->key_length=0;\\r\\nret->key_data=NULL;\\r\\nret->key_free=0;\\r\\nret->cipher.cipher=NULL;\\r\\nmemset(ret->cipher.iv,0,EVP_MAX_IV_LENGTH);\\r\\nret->references=1;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_PKEY_NEW);\\r\\n}\\r\\nvoid X509_PKEY_free(X509_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL) return;\\r\\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_X509_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_PKEY\",x);\\r\\n#endif\\r\\nif (i > 0) return;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0)\\r\\n{\\r\\nfprintf(stderr,\"X509_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->enc_algor != NULL) X509_ALGOR_free(x->enc_algor);\\r\\nif (x->enc_pkey != NULL) ASN1_OCTET_STRING_free(x->enc_pkey);\\r\\nif (x->dec_pkey != NULL)EVP_PKEY_free(x->dec_pkey);\\r\\nif ((x->key_data != NULL) && (x->key_free)) Free((char *)x->key_data);\\r\\nFree((char *)(char *)x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_algor_c", "target": 0, "func": "int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **pp)\\r\\n{\\r\\nM_ASN1_I2D_vars(a);\\r\\nM_ASN1_I2D_len(a->algorithm,i2d_ASN1_OBJECT);\\r\\nif (a->parameter != NULL)\\r\\n{ M_ASN1_I2D_len(a->parameter,i2d_ASN1_TYPE); }\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(a->algorithm,i2d_ASN1_OBJECT);\\r\\nif (a->parameter != NULL)\\r\\n{ M_ASN1_I2D_put(a->parameter,i2d_ASN1_TYPE); }\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nX509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, unsigned char **pp, long length)\\r\\n{\\r\\nM_ASN1_D2I_vars(a,X509_ALGOR *,X509_ALGOR_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->algorithm,d2i_ASN1_OBJECT);\\r\\nif (!M_ASN1_D2I_end_sequence())\\r\\n{ M_ASN1_D2I_get(ret->parameter,d2i_ASN1_TYPE); }\\r\\nelse\\r\\n{\\r\\nASN1_TYPE_free(ret->parameter);\\r\\nret->parameter=NULL;\\r\\n}\\r\\nM_ASN1_D2I_Finish(a,X509_ALGOR_free,ASN1_F_D2I_X509_ALGOR);\\r\\n}\\r\\nX509_ALGOR *X509_ALGOR_new(void)\\r\\n{\\r\\nX509_ALGOR *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_ALGOR);\\r\\nret->algorithm=OBJ_nid2obj(NID_undef);\\r\\nret->parameter=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_ALGOR_NEW);\\r\\n}\\r\\nvoid X509_ALGOR_free(X509_ALGOR *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\nASN1_TYPE_free(a->parameter);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_comp_lib_c", "target": 0, "func": "COMP_CTX *COMP_CTX_new(COMP_METHOD *meth)\\r\\n{\\r\\nCOMP_CTX *ret;\\r\\nif ((ret=(COMP_CTX *)Malloc(sizeof(COMP_CTX))) == NULL)\\r\\n{\\r\\nreturn(NULL);\\r\\n}\\r\\nmemset(ret,0,sizeof(COMP_CTX));\\r\\nret->meth=meth;\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret))\\r\\n{\\r\\nFree(ret);\\r\\nret=NULL;\\r\\n}\\r\\n#if 0\\r\\nelse\\r\\nCRYPTO_new_ex_data(rsa_meth,(char *)ret,&ret->ex_data);\\r\\n#endif\\r\\nreturn(ret);\\r\\n}\\r\\nvoid COMP_CTX_free(COMP_CTX *ctx)\\r\\n{\\r\\nif(ctx == NULL)\\r\\nreturn;\\r\\nif (ctx->meth->finish != NULL)\\r\\nctx->meth->finish(ctx);\\r\\nFree(ctx);\\r\\n}\\r\\nint COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->compress == NULL)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nret=ctx->meth->compress(ctx,out,olen,in,ilen);\\r\\nif (ret > 0)\\r\\n{\\r\\nctx->compress_in+=ilen;\\r\\nctx->compress_out+=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}\\r\\nint COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->expand == NULL)\\r\\n{\\r\\nreturn(-1);\\r\\n}\\r\\nret=ctx->meth->expand(ctx,out,olen,in,ilen);\\r\\nif (ret > 0)\\r\\n{\\r\\nctx->expand_in+=ilen;\\r\\nctx->expand_out+=ret;\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsar_err_c", "target": 0, "func": "void ERR_load_RSAREF_strings(void)\\r\\n{\\r\\nstatic int init=1;\\r\\nif (init)\\r\\n{\\r\\ninit=0;\\r\\n#ifndef NO_ERR\\r\\nERR_load_strings(ERR_LIB_RSAREF,RSAREF_str_functs);\\r\\nERR_load_strings(ERR_LIB_RSAREF,RSAREF_str_reasons);\\r\\n#endif\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_cfb_c_c", "target": 0, "func": "EVP_CIPHER *EVP_cast5_cfb(void)\\r\\n{\\r\\nreturn(&cast5_cfb_cipher);\\r\\n}\\r\\nstatic void cast_cfb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nctx->num=0;\\r\\nif (iv != NULL)\\r\\nmemcpy(&(ctx->oiv[0]),iv,8);\\r\\nmemcpy(&(ctx->iv[0]),&(ctx->oiv[0]),8);\\r\\nif (key != NULL)\\r\\nCAST_set_key(&(ctx->c.cast_ks),EVP_CAST5_KEY_SIZE,key);\\r\\n}\\r\\nstatic void cast_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nCAST_cfb64_encrypt(\\r\\nin,out,\\r\\n(long)inl, &(ctx->c.cast_ks),\\r\\n&(ctx->iv[0]),\\r\\n&ctx->num,ctx->encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_sha_c", "target": 0, "func": "EVP_MD *EVP_sha(void)\\r\\n{\\r\\nreturn(&sha_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_x_exten_c", "target": 0, "func": "int i2d_X509_EXTENSION(X509_EXTENSION *a, unsigned char **pp)\\r\\n{\\r\\nint k=0;\\r\\nint r=0,ret=0;\\r\\nunsigned char **p=NULL;\\r\\nif (a == NULL) return(0);\\r\\np=NULL;\\r\\nfor (;;)\\r\\n{\\r\\nif (k)\\r\\n{\\r\\nr=ASN1_object_size(1,ret,V_ASN1_SEQUENCE);\\r\\nif (pp == NULL) return(r);\\r\\np=pp;\\r\\nASN1_put_object(p,1,ret,V_ASN1_SEQUENCE,\\r\\nV_ASN1_UNIVERSAL);\\r\\n}\\r\\nret+=i2d_ASN1_OBJECT(a->object,p);\\r\\nif ((a->critical) || a->netscape_hack)\\r\\nret+=i2d_ASN1_BOOLEAN(a->critical,p);\\r\\nret+=i2d_ASN1_OCTET_STRING(a->value,p);\\r\\nif (k++) return(r);\\r\\n}\\r\\n}\\r\\nX509_EXTENSION *d2i_X509_EXTENSION(X509_EXTENSION **a, unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint i;\\r\\nM_ASN1_D2I_vars(a,X509_EXTENSION *,X509_EXTENSION_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get(ret->object,d2i_ASN1_OBJECT);\\r\\nif ((ret->argp != NULL) && (ret->ex_free != NULL))\\r\\nret->ex_free(ret);\\r\\nret->argl=0;\\r\\nret->argp=NULL;\\r\\nret->netscape_hack=0;\\r\\nif ((c.slen != 0) &&\\r\\n(M_ASN1_next == (V_ASN1_UNIVERSAL|V_ASN1_BOOLEAN)))\\r\\n{\\r\\nc.q=c.p;\\r\\nif (d2i_ASN1_BOOLEAN(&i,&c.p,c.slen) < 0) goto err;\\r\\nret->critical=i;\\r\\nc.slen-=(c.p-c.q);\\r\\nif (ret->critical == 0) ret->netscape_hack=1;\\r\\n}\\r\\nM_ASN1_D2I_get(ret->value,d2i_ASN1_OCTET_STRING);\\r\\nM_ASN1_D2I_Finish(a,X509_EXTENSION_free,ASN1_F_D2I_X509_EXTENSION);\\r\\n}\\r\\nX509_EXTENSION *X509_EXTENSION_new(void)\\r\\n{\\r\\nX509_EXTENSION *ret=NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret,X509_EXTENSION);\\r\\nret->object=OBJ_nid2obj(NID_undef);\\r\\nM_ASN1_New(ret->value,ASN1_OCTET_STRING_new);\\r\\nret->critical=0;\\r\\nret->netscape_hack=0;\\r\\nret->argl=0L;\\r\\nret->argp=NULL;\\r\\nret->ex_free=NULL;\\r\\nreturn(ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_EXTENSION_NEW);\\r\\n}\\r\\nvoid X509_EXTENSION_free(X509_EXTENSION *a)\\r\\n{\\r\\nif (a == NULL) return;\\r\\nif ((a->argp != NULL) && (a->ex_free != NULL))\\r\\na->ex_free(a);\\r\\nASN1_OBJECT_free(a->object);\\r\\nASN1_OCTET_STRING_free(a->value);\\r\\nFree((char *)a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_e_ecb_i_c", "target": 0, "func": "EVP_CIPHER *EVP_idea_ecb(void)\\r\\n{\\r\\nreturn(&i_ecb_cipher);\\r\\n}\\r\\nstatic void idea_ecb_init_key(EVP_CIPHER_CTX *ctx, unsigned char *key,\\r\\nunsigned char *iv, int enc)\\r\\n{\\r\\nif (key != NULL)\\r\\n{\\r\\nif (enc)\\r\\nidea_set_encrypt_key(key,&(ctx->c.idea_ks));\\r\\nelse\\r\\n{\\r\\nIDEA_KEY_SCHEDULE tmp;\\r\\nidea_set_encrypt_key(key,&tmp);\\r\\nidea_set_decrypt_key(&tmp, &(ctx->c.idea_ks));\\r\\nmemset((unsigned char *)&tmp,0,\\r\\nsizeof(IDEA_KEY_SCHEDULE));\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void idea_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nunsigned char *in, unsigned int inl)\\r\\n{\\r\\nunsigned int i;\\r\\nif (inl < 8) return;\\r\\ninl-=8;\\r\\nfor (i=0; i<=inl; i+=8)\\r\\n{\\r\\nidea_ecb_encrypt(\\r\\n&(in[i]),&(out[i]),&(ctx->c.idea_ks));\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_md5_c", "target": 0, "func": "EVP_MD *EVP_md5(void)\\r\\n{\\r\\nreturn(&md5_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_ssl_ciph_c", "target": 0, "func": "static int cmp_by_name(SSL_CIPHER **a, SSL_CIPHER **b)\\r\\n{\\r\\nreturn(strcmp((*a)->name,(*b)->name));\\r\\n}\\r\\nstatic void load_ciphers(void)\\r\\n{\\r\\ninit_ciphers=0;\\r\\nssl_cipher_methods[SSL_ENC_DES_IDX]=\\r\\nEVP_get_cipherbyname(SN_des_cbc);\\r\\nssl_cipher_methods[SSL_ENC_3DES_IDX]=\\r\\nEVP_get_cipherbyname(SN_des_ede3_cbc);\\r\\nssl_cipher_methods[SSL_ENC_RC4_IDX]=\\r\\nEVP_get_cipherbyname(SN_rc4);\\r\\nssl_cipher_methods[SSL_ENC_RC2_IDX]=\\r\\nEVP_get_cipherbyname(SN_rc2_cbc);\\r\\nssl_cipher_methods[SSL_ENC_IDEA_IDX]=\\r\\nEVP_get_cipherbyname(SN_idea_cbc);\\r\\nssl_digest_methods[SSL_MD_MD5_IDX]=\\r\\nEVP_get_digestbyname(SN_md5);\\r\\nssl_digest_methods[SSL_MD_SHA1_IDX]=\\r\\nEVP_get_digestbyname(SN_sha1);\\r\\n}\\r\\nint ssl_cipher_get_evp(SSL_SESSION *s, const EVP_CIPHER **enc,\\r\\nconst EVP_MD **md, SSL_COMP **comp)\\r\\n{\\r\\nint i;\\r\\nSSL_CIPHER *c;\\r\\nc=s->cipher;\\r\\nif (c == NULL) return(0);\\r\\nif (comp != NULL)\\r\\n{\\r\\nSSL_COMP ctmp;\\r\\nif (s->compress_meth == 0)\\r\\n*comp=NULL;\\r\\nelse if (ssl_comp_methods == NULL)\\r\\n{\\r\\n*comp=NULL;\\r\\n}\\r\\nelse\\r\\n{\\r\\nctmp.id=s->compress_meth;\\r\\ni=sk_SSL_COMP_find(ssl_comp_methods,&ctmp);\\r\\nif (i >= 0)\\r\\n*comp=sk_SSL_COMP_value(ssl_comp_methods,i);\\r\\nelse\\r\\n*comp=NULL;\\r\\n}\\r\\n}\\r\\nif ((enc == NULL) || (md == NULL)) return(0);\\r\\nswitch (c->algorithms & SSL_ENC_MASK)\\r\\n{\\r\\ncase SSL_DES:\\r\\ni=SSL_ENC_DES_IDX;\\r\\nbreak;\\r\\ncase SSL_3DES:\\r\\ni=SSL_ENC_3DES_IDX;\\r\\nbreak;\\r\\ncase SSL_RC4:\\r\\ni=SSL_ENC_RC4_IDX;\\r\\nbreak;\\r\\ncase SSL_RC2:\\r\\ni=SSL_ENC_RC2_IDX;\\r\\nbreak;\\r\\ncase SSL_IDEA:\\r\\ni=SSL_ENC_IDEA_IDX;\\r\\nbreak;\\r\\ncase SSL_eNULL:\\r\\ni=SSL_ENC_NULL_IDX;\\r\\nbreak;\\r\\ndefault:\\r\\ni= -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i > SSL_ENC_NUM_IDX))\\r\\n*enc=NULL;\\r\\nelse\\r\\n{\\r\\nif (i == SSL_ENC_NULL_IDX)\\r\\n*enc=EVP_enc_null();\\r\\nelse\\r\\n*enc=ssl_cipher_methods[i];\\r\\n}\\r\\nswitch (c->algorithms & SSL_MAC_MASK)\\r\\n{\\r\\ncase SSL_MD5:\\r\\ni=SSL_MD_MD5_IDX;\\r\\nbreak;\\r\\ncase SSL_SHA1:\\r\\ni=SSL_MD_SHA1_IDX;\\r\\nbreak;\\r\\ndefault:\\r\\ni= -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i > SSL_MD_NUM_IDX))\\r\\n*md=NULL;\\r\\nelse\\r\\n*md=ssl_digest_methods[i];\\r\\nif ((*enc != NULL) && (*md != NULL))\\r\\nreturn(1);\\r\\nelse\\r\\nreturn(0);\\r\\n}\\r\\nstatic void ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,\\r\\nCIPHER_ORDER **tail)\\r\\n{\\r\\nif (curr == *tail) return;\\r\\nif (curr == *head)\\r\\n*head=curr->next;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next=curr->next;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev=curr->prev;\\r\\n(*tail)->next=curr;\\r\\ncurr->prev= *tail;\\r\\ncurr->next=NULL;\\r\\n*tail=curr;\\r\\n}\\r\\nchar *SSL_CIPHER_get_name(SSL_CIPHER *c)\\r\\n{\\r\\nif (c != NULL)\\r\\nreturn(c->name);\\r\\nreturn(\"(NONE)\");\\r\\n}\\r\\nint SSL_CIPHER_get_bits(SSL_CIPHER *c, int *alg_bits)\\r\\n{\\r\\nint ret=0,a=0;\\r\\nconst EVP_CIPHER *enc;\\r\\nconst EVP_MD *md;\\r\\nSSL_SESSION ss;\\r\\nif (c != NULL)\\r\\n{\\r\\nss.cipher=c;\\r\\nif (!ssl_cipher_get_evp(&ss,&enc,&md,NULL))\\r\\nreturn(0);\\r\\na=EVP_CIPHER_key_length(enc)*8;\\r\\nif (SSL_C_IS_EXPORT(c))\\r\\n{\\r\\nret=SSL_C_EXPORT_KEYLENGTH(c)*8;\\r\\n}\\r\\nelse\\r\\n{\\r\\nif (c->algorithm2 & SSL2_CF_8_BYTE_ENC)\\r\\nret=64;\\r\\nelse\\r\\nret=a;\\r\\n}\\r\\n}\\r\\nif (alg_bits != NULL) *alg_bits=a;\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int sk_comp_cmp(SSL_COMP **a,SSL_COMP **b)\\r\\n{\\r\\nreturn((*a)->id-(*b)->id);\\r\\n}\\r\\nint SSL_COMP_add_compression_method(int id, COMP_METHOD *cm)\\r\\n{\\r\\nSSL_COMP *comp;\\r\\nSTACK_OF(SSL_COMP) *sk;\\r\\ncomp=(SSL_COMP *)Malloc(sizeof(SSL_COMP));\\r\\ncomp->id=id;\\r\\ncomp->method=cm;\\r\\nif (ssl_comp_methods == NULL)\\r\\nsk=ssl_comp_methods=sk_SSL_COMP_new(sk_comp_cmp);\\r\\nelse\\r\\nsk=ssl_comp_methods;\\r\\nif ((sk == NULL) || !sk_SSL_COMP_push(sk,comp))\\r\\n{\\r\\nSSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\nelse\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_gendh_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar buffer[200];\\r\\nDH *dh=NULL;\\r\\nint ret=1,num=DEFBITS;\\r\\nint g=2;\\r\\nchar *outfile=NULL;\\r\\nchar *inrand=NULL,*randfile;\\r\\nBIO *out=NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err=BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;)\\r\\n{\\r\\nif (argc <= 0) break;\\r\\nif (strcmp(*argv,\"-out\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\noutfile= *(++argv);\\r\\n}\\r\\nelse if (strcmp(*argv,\"-2\") == 0)\\r\\ng=2;\\r\\nelse if (strcmp(*argv,\"-5\") == 0)\\r\\ng=5;\\r\\nelse if (strcmp(*argv,\"-rand\") == 0)\\r\\n{\\r\\nif (--argc < 1) goto bad;\\r\\ninrand= *(++argv);\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif ((argc >= 1) && ((sscanf(*argv,\"%d\",&num) == 0) || (num < 0)))\\r\\n{\\r\\nbad:\\r\\nBIO_printf(bio_err,\"usage: gendh [args] [numbits]\\n\");\\r\\nBIO_printf(bio_err,\" -out file - output the key to 'file\\n\");\\r\\nBIO_printf(bio_err,\" -2 use 2 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\" -5 use 5 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\" -rand file:file:...\\n\");\\r\\nBIO_printf(bio_err,\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err,\" the random number generator\\n\");\\r\\ngoto end;\\r\\n}\\r\\nout=BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\n{\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL)\\r\\nBIO_set_fp(out,stdout,BIO_NOCLOSE);\\r\\nelse\\r\\n{\\r\\nif (BIO_write_filename(out,outfile) <= 0)\\r\\n{\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrandfile=RAND_file_name(buffer,200);\\r\\nif ((randfile == NULL)|| !RAND_load_file(randfile,1024L*1024L))\\r\\nBIO_printf(bio_err,\"unable to load 'random state'\\n\");\\r\\nif (inrand == NULL)\\r\\nBIO_printf(bio_err,\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\nelse\\r\\n{\\r\\nBIO_printf(bio_err,\"%ld semi-random bytes loaded\\n\",\\r\\ndh_load_rand(inrand));\\r\\n}\\r\\nBIO_printf(bio_err,\"Generating DH parameters, %d bit long strong prime, generator of %d\\n\",num,g);\\r\\nBIO_printf(bio_err,\"This is going to take a long time\\n\");\\r\\ndh=DH_generate_parameters(num,g,dh_cb,bio_err);\\r\\nif (dh == NULL) goto end;\\r\\nif (randfile == NULL)\\r\\nBIO_printf(bio_err,\"unable to write 'random state'\\n\");\\r\\nelse\\r\\nRAND_write_file(randfile);\\r\\nif (!PEM_write_bio_DHparams(out,dh))\\r\\ngoto end;\\r\\nret=0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (out != NULL) BIO_free(out);\\r\\nif (dh != NULL) DH_free(dh);\\r\\nEXIT(ret);\\r\\n}\\r\\nstatic void MS_CALLBACK dh_cb(int p, int n, void *arg)\\r\\n{\\r\\nchar c='*';\\r\\nif (p == 0) c='.';\\r\\nif (p == 1) c='+';\\r\\nif (p == 2) c='*';\\r\\nif (p == 3) c='\\n';\\r\\nBIO_write((BIO *)arg,&c,1);\\r\\n(void)BIO_flush((BIO *)arg);\\r\\n#ifdef LINT\\r\\np=n;\\r\\n#endif\\r\\n}\\r\\nstatic long dh_load_rand(char *name)\\r\\n{\\r\\nchar *p,*n;\\r\\nint last;\\r\\nlong tot=0;\\r\\nfor (;;)\\r\\n{\\r\\nlast=0;\\r\\nfor (p=name; ((*p != '\\0') && (*p != LIST_SEPARATOR_CHAR)); p++);\\r\\nif (*p == '\\0') last=1;\\r\\n*p='\\0';\\r\\nn=name;\\r\\nname=p+1;\\r\\nif (*n == '\\0') break;\\r\\ntot+=RAND_load_file(n,1);\\r\\nif (last) break;\\r\\n}\\r\\nreturn(tot);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_bss_log_c", "target": 0, "func": "BIO_METHOD *BIO_s_log(void)\\r\\n{\\r\\nreturn(&methods_slg);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_new(BIO *bi)\\r\\n{\\r\\nbi->init=1;\\r\\nbi->num=0;\\r\\nbi->ptr=NULL;\\r\\n#ifndef WIN32\\r\\nxopenlog(bi, \"application\", LOG_DAEMON);\\r\\n#else\\r\\nxopenlog(bi, \"application\", 0);\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_free(BIO *a)\\r\\n{\\r\\nif (a == NULL) return(0);\\r\\nxcloselog(a);\\r\\nreturn(1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_write(BIO *b, char *in, int inl)\\r\\n{\\r\\nint ret= inl;\\r\\nchar* buf= in;\\r\\nchar* pp;\\r\\n#if defined(WIN32)\\r\\nLPTSTR lpszStrings[1];\\r\\nWORD evtype= EVENTLOG_ERROR_TYPE;\\r\\n#else\\r\\nint priority;\\r\\n#endif\\r\\nif((buf= (char *)Malloc(inl+ 1)) == NULL){\\r\\nreturn(0);\\r\\n}\\r\\nstrncpy(buf, in, inl);\\r\\nbuf[inl]= '\\0';\\r\\n#if defined(WIN32)\\r\\nif(strncmp(buf, \"ERR \", 4) == 0){\\r\\nevtype= EVENTLOG_ERROR_TYPE;\\r\\npp= buf+ 4;\\r\\n}else if(strncmp(buf, \"WAR \", 4) == 0){\\r\\nevtype= EVENTLOG_WARNING_TYPE;\\r\\npp= buf+ 4;\\r\\n}else if(strncmp(buf, \"INF \", 4) == 0){\\r\\nevtype= EVENTLOG_INFORMATION_TYPE;\\r\\npp= buf+ 4;\\r\\n}else{\\r\\nevtype= EVENTLOG_ERROR_TYPE;\\r\\npp= buf;\\r\\n}\\r\\nlpszStrings[0]= pp;\\r\\nif(b->ptr)\\r\\nReportEvent(b->ptr, evtype, 0, 1024, NULL, 1, 0,\\r\\nlpszStrings, NULL);\\r\\n#else\\r\\nif(strncmp(buf, \"ERR \", 4) == 0){\\r\\npriority= LOG_ERR;\\r\\npp= buf+ 4;\\r\\n}else if(strncmp(buf, \"WAR \", 4) == 0){\\r\\npriority= LOG_WARNING;\\r\\npp= buf+ 4;\\r\\n}else if(strncmp(buf, \"INF \", 4) == 0){\\r\\npriority= LOG_INFO;\\r\\npp= buf+ 4;\\r\\n}else{\\r\\npriority= LOG_ERR;\\r\\npp= buf;\\r\\n}\\r\\nsyslog(priority, \"%s\", pp);\\r\\n#endif\\r\\nFree(buf);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, char *ptr)\\r\\n{\\r\\nswitch (cmd)\\r\\n{\\r\\ncase BIO_CTRL_SET:\\r\\nxcloselog(b);\\r\\nxopenlog(b, ptr, num);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn(0);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_puts(BIO *bp, char *str)\\r\\n{\\r\\nint n,ret;\\r\\nn=strlen(str);\\r\\nret=slg_write(bp,str,n);\\r\\nreturn(ret);\\r\\n}\\r\\nstatic int xopenlog(BIO* bp, const char* name, int level)\\r\\n{\\r\\n#if defined(WIN32)\\r\\nif((bp->ptr= (char *)RegisterEventSource(NULL, name)) == NULL){\\r\\nreturn(0);\\r\\n}\\r\\n#else\\r\\nopenlog(name, LOG_PID|LOG_CONS, level);\\r\\n#endif\\r\\nreturn(1);\\r\\n}\\r\\nstatic int xcloselog(BIO* bp)\\r\\n{\\r\\n#if defined(WIN32)\\r\\nif(bp->ptr)\\r\\nDeregisterEventSource((HANDLE)(bp->ptr));\\r\\nbp->ptr= NULL;\\r\\n#else\\r\\ncloselog();\\r\\n#endif\\r\\nreturn(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_a_octet_c", "target": 0, "func": "int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *a, unsigned char **pp)\\r\\n{\\r\\nreturn(i2d_ASN1_bytes((ASN1_STRING *)a,pp,\\r\\nV_ASN1_OCTET_STRING,V_ASN1_UNIVERSAL));\\r\\n}\\r\\nASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a,\\r\\nunsigned char **pp, long length)\\r\\n{\\r\\nASN1_OCTET_STRING *ret=NULL;\\r\\nret=(ASN1_OCTET_STRING *)d2i_ASN1_bytes((ASN1_STRING **)a,\\r\\npp,length,V_ASN1_OCTET_STRING,V_ASN1_UNIVERSAL);\\r\\nif (ret == NULL)\\r\\n{\\r\\nASN1err(ASN1_F_D2I_ASN1_OCTET_STRING,ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn(NULL);\\r\\n}\\r\\nreturn(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_m_ripemd_c", "target": 0, "func": "EVP_MD *EVP_ripemd160(void)\\r\\n{\\r\\nreturn(&ripemd160_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_s23_lib_c", "target": 0, "func": "static long ssl23_default_timeout(void)\\r\\n{\\r\\nreturn(300);\\r\\n}\\r\\nSSL_METHOD *sslv23_base_method(void)\\r\\n{\\r\\nreturn(&SSLv23_data);\\r\\n}\\r\\nstatic int ssl23_num_ciphers(void)\\r\\n{\\r\\nreturn(ssl3_num_ciphers()+ssl2_num_ciphers());\\r\\n}\\r\\nstatic SSL_CIPHER *ssl23_get_cipher(unsigned int u)\\r\\n{\\r\\nunsigned int uu=ssl3_num_ciphers();\\r\\nif (u < uu)\\r\\nreturn(ssl3_get_cipher(u));\\r\\nelse\\r\\nreturn(ssl2_get_cipher(u-uu));\\r\\n}\\r\\nstatic SSL_CIPHER *ssl23_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nSSL_CIPHER c,*cp;\\r\\nunsigned long id;\\r\\nint n;\\r\\nn=ssl3_num_ciphers();\\r\\nid=0x03000000|((unsigned long)p[0]<<16L)|\\r\\n((unsigned long)p[1]<<8L)|(unsigned long)p[2];\\r\\nc.id=id;\\r\\ncp=ssl3_get_cipher_by_char(p);\\r\\nif (cp == NULL)\\r\\ncp=ssl2_get_cipher_by_char(p);\\r\\nreturn(cp);\\r\\n}\\r\\nstatic int ssl23_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL)\\r\\n{\\r\\nl=c->id;\\r\\np[0]=((unsigned char)(l>>16L))&0xFF;\\r\\np[1]=((unsigned char)(l>> 8L))&0xFF;\\r\\np[2]=((unsigned char)(l ))&0xFF;\\r\\n}\\r\\nreturn(3);\\r\\n}\\r\\nstatic int ssl23_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nint n;\\r\\n#if 0\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\n#endif\\r\\nclear_sys_error();\\r\\nif (SSL_in_init(s) && (!s->in_handshake))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_READ,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(SSL_read(s,buf,len));\\r\\n}\\r\\nelse\\r\\n{\\r\\nssl_undefined_function(s);\\r\\nreturn(-1);\\r\\n}\\r\\n}\\r\\nstatic int ssl23_write(SSL *s, const void *buf, int len)\\r\\n{\\r\\nint n;\\r\\n#if 0\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN)\\r\\n{\\r\\ns->rwstate=SSL_NOTHING;\\r\\nreturn(0);\\r\\n}\\r\\n#endif\\r\\nclear_sys_error();\\r\\nif (SSL_in_init(s) && (!s->in_handshake))\\r\\n{\\r\\nn=s->handshake_func(s);\\r\\nif (n < 0) return(n);\\r\\nif (n == 0)\\r\\n{\\r\\nSSLerr(SSL_F_SSL23_WRITE,SSL_R_SSL_HANDSHAKE_FAILURE);\\r\\nreturn(-1);\\r\\n}\\r\\nreturn(SSL_write(s,buf,len));\\r\\n}\\r\\nelse\\r\\n{\\r\\nssl_undefined_function(s);\\r\\nreturn(-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_0_9_4_rsa_saos_c", "target": 0, "func": "int RSA_sign_ASN1_OCTET_STRING(int type, unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, RSA *rsa)\\r\\n{\\r\\nASN1_OCTET_STRING sig;\\r\\nint i,j,ret=1;\\r\\nunsigned char *p,*s;\\r\\nsig.type=V_ASN1_OCTET_STRING;\\r\\nsig.length=m_len;\\r\\nsig.data=m;\\r\\ni=i2d_ASN1_OCTET_STRING(&sig,NULL);\\r\\nj=RSA_size(rsa);\\r\\nif ((i-RSA_PKCS1_PADDING) > j)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)Malloc((unsigned int)j+1);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\nreturn(0);\\r\\n}\\r\\np=s;\\r\\ni2d_ASN1_OCTET_STRING(&sig,&p);\\r\\ni=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret=0;\\r\\nelse\\r\\n*siglen=i;\\r\\nmemset(s,0,(unsigned int)j+1);\\r\\nFree(s);\\r\\nreturn(ret);\\r\\n}\\r\\nint RSA_verify_ASN1_OCTET_STRING(int dtype, unsigned char *m,\\r\\nunsigned int m_len, unsigned char *sigbuf, unsigned int siglen,\\r\\nRSA *rsa)\\r\\n{\\r\\nint i,ret=0;\\r\\nunsigned char *p,*s;\\r\\nASN1_OCTET_STRING *sig=NULL;\\r\\nif (siglen != (unsigned int)RSA_size(rsa))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn(0);\\r\\n}\\r\\ns=(unsigned char *)Malloc((unsigned int)siglen);\\r\\nif (s == NULL)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);\\r\\nif (i <= 0) goto err;\\r\\np=s;\\r\\nsig=d2i_ASN1_OCTET_STRING(NULL,&p,(long)i);\\r\\nif (sig == NULL) goto err;\\r\\nif ( ((unsigned int)sig->length != m_len) ||\\r\\n(memcmp(m,sig->data,m_len) != 0))\\r\\n{\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,RSA_R_BAD_SIGNATURE);\\r\\n}\\r\\nelse\\r\\nret=1;\\r\\nerr:\\r\\nif (sig != NULL) ASN1_OCTET_STRING_free(sig);\\r\\nmemset(s,0,(unsigned int)siglen);\\r\\nFree(s);\\r\\nreturn(ret);\\r\\n}"
}
]
