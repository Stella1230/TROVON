static T_1 F_1 ( void )\r\n{\r\nT_1 V_1 = F_2 () ;\r\nF_3 ( V_1 | 0x00010000 ) ;\r\nasm volatile(\r\n" .set push \n"\r\n" .set noat \n"\r\n" .set noreorder \n"\r\n" lw $1, 0(%0) \n"\r\n" sb $0, 0(%1) \n"\r\n" sync \n"\r\n" lb %1, 0(%1) \n"\r\n" b 1f \n"\r\n" ori %1, $1, 2 \n"\r\n" .align 8 \n"\r\n"1: \n"\r\n" nop \n"\r\n" sw %1, 0(%0) \n"\r\n" sync \n"\r\n" li %1, 0x20 \n"\r\n"2: \n"\r\n" nop \n"\r\n" bnez %1,2b \n"\r\n" addiu %1, -1 \n"\r\n" sw $1, 0(%0) \n"\r\n" sync \n"\r\n".set pop \n"\r\n:\r\n: "Jr" (PCIMT_UCONF), "Jr" (0xbc000000));\r\nF_3 ( V_1 ) ;\r\nreturn V_1 ;\r\n}\r\nstatic inline void F_4 ( struct V_2 * V_3 )\r\n{\r\nF_5 ( 0x100 << ( V_3 -> V_4 - V_5 ) ) ;\r\nF_6 () ;\r\n}\r\nstatic inline void F_7 ( struct V_2 * V_3 )\r\n{\r\nF_8 ( 0x100 << ( V_3 -> V_4 - V_5 ) ) ;\r\nF_9 () ;\r\n}\r\nstatic void F_10 ( void )\r\n{\r\nT_1 V_6 , V_1 ;\r\nint V_4 ;\r\nF_8 ( V_7 ) ;\r\nV_1 = F_1 () ;\r\nV_6 = F_11 () ;\r\nV_4 = F_12 ( ( ( V_6 & V_1 ) >> 8 ) & 0xf8 ) ;\r\nif ( F_13 ( V_4 > 0 ) )\r\nF_14 ( V_5 + V_4 - 1 ) ;\r\nF_5 ( V_7 ) ;\r\n}\r\nvoid T_2 F_15 ( void )\r\n{\r\nint V_8 ;\r\nfor ( V_8 = V_5 + 2 ; V_8 < V_5 + 8 ; V_8 ++ )\r\nF_16 ( V_8 , & V_9 , V_10 ) ;\r\nV_11 = F_10 ;\r\nF_17 ( V_12 , V_7 ) ;\r\nF_18 ( V_5 + 3 , & V_13 ) ;\r\n}\r\nvoid F_19 ( void )\r\n{\r\n}\r\nstatic int T_2 F_20 ( void )\r\n{\r\nswitch ( V_14 ) {\r\ncase V_15 :\r\ncase V_16 :\r\nF_21 ( & V_17 ) ;\r\nF_21 ( & V_18 ) ;\r\nF_21 ( & V_19 ) ;\r\nF_21 ( & V_20 ) ;\r\nF_21 ( & V_21 ) ;\r\nF_22 () ;\r\nbreak;\r\n}\r\nreturn 0 ;\r\n}
