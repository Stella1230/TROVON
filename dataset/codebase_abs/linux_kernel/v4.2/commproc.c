void T_1 F_1 ()\r\n{\r\nV_1 = (struct V_2 * ) ( V_3 ) ;\r\nV_1 -> V_4 = ( V_5 | V_6 ) ;\r\nwhile ( V_1 -> V_4 & V_6 ) ;\r\nV_1 -> V_7 = 0x0740 ;\r\nV_8 = V_9 ;\r\nV_10 = V_8 + V_11 ;\r\n}\r\nvoid\r\nF_2 ( void )\r\n{\r\nV_1 -> V_12 =\r\n( V_13 | V_14 | V_15 | V_16 ) |\r\n( V_17 << 13 ) |\r\nV_18 |\r\n( V_19 << 5 ) |\r\nV_20 ;\r\nV_1 -> V_21 = 0 ;\r\n}\r\nstatic void\r\nF_3 ( int V_22 , void * V_23 , struct V_24 * V_25 )\r\n{\r\n#if 0\r\n((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr = 1;\r\nvec = ((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr;\r\nvec >>= 11;\r\nif (cpm_vecs[vec].handler != 0)\r\n(*cpm_vecs[vec].handler)(cpm_vecs[vec].dev_id);\r\nelse\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cimr &= ~(1 << vec);\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cisr |= (1 << vec);\r\n#endif\r\n}\r\nstatic void\r\nF_4 ( void * V_23 )\r\n{\r\n}\r\nvoid\r\nF_5 ( int V_26 , T_2 V_27 , void * V_28 )\r\n{\r\nF_6 ( V_26 , V_27 , 0 , L_1 , V_28 ) ;\r\n}\r\nvoid\r\nF_7 ( int V_26 )\r\n{\r\nV_29 [ V_26 ] . V_27 = NULL ;\r\nV_29 [ V_26 ] . V_28 = NULL ;\r\nV_1 -> V_21 &= ~ ( 1 << V_26 ) ;\r\n}\r\nT_3\r\nF_8 ( T_3 V_30 )\r\n{\r\nT_3 V_31 ;\r\nif ( ( V_8 + V_30 ) >= V_10 )\r\nreturn ( V_32 ) ;\r\nV_31 = V_8 ;\r\nV_8 += V_30 ;\r\nreturn ( V_31 ) ;\r\n}\r\nvoid\r\nF_9 ( T_3 V_33 , T_3 V_34 )\r\n{\r\nvolatile T_3 * V_35 ;\r\nV_35 = ( volatile T_3 * ) ( & V_1 -> V_36 [ 0 ] . V_37 ) ;\r\nV_35 += V_33 ;\r\n* V_35 = ( ( V_38 / V_34 - 1 ) << 1 ) | V_39 ;\r\n}
