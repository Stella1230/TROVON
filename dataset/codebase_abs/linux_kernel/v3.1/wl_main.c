int F_1 ( struct V_1 * V_2 )\r\n{\r\nint V_3 = 0 ;\r\nint V_4 = V_5 ;\r\nint V_6 ;\r\nunsigned long V_7 = 0 ;\r\nstruct V_8 * V_9 = F_2 ( V_2 ) ;\r\nF_3 ( L_1 ) ;\r\nF_4 ( V_10 ) ;\r\nmemset ( & ( V_9 -> V_11 ) , 0 , sizeof( V_12 ) ) ;\r\nF_5 ( & ( V_9 -> V_13 ) ) ;\r\nV_9 -> V_14 = V_15 ;\r\nV_9 -> V_16 = V_17 ;\r\nV_9 -> V_2 = V_2 ;\r\nF_6 ( V_10 , L_2 , L_3 , V_18 & 0x0FFFF ) ;\r\nF_6 ( V_10 , L_4 , L_5 ,\r\nV_19 [ 0 ] & 0x0FF , V_19 [ 1 ] & 0x0FF ,\r\nV_19 [ 2 ] & 0x0FF , V_19 [ 3 ] & 0x0FF ) ;\r\nF_6 ( V_10 , V_20 , L_6 , V_21 ) ;\r\nF_6 ( V_10 , V_22 , L_6 , V_23 ) ;\r\nF_6 ( V_10 , V_24 , L_7 , V_25 ) ;\r\nF_6 ( V_10 , V_26 , L_7 , V_27 ) ;\r\nF_6 ( V_10 , V_28 , L_7 , V_29 ) ;\r\nF_6 ( V_10 , V_30 , L_7 , V_31 ) ;\r\nF_6 ( V_10 , V_32 , L_6 , V_33 ) ;\r\nF_6 ( V_10 , V_34 , L_6 , V_35 ) ;\r\nF_6 ( V_10 , V_36 , L_6 , V_37 ) ;\r\nF_6 ( V_10 , V_38 , L_6 , V_39 ) ;\r\nF_6 ( V_10 , V_40 , L_6 , V_41 ) ;\r\nF_6 ( V_10 , V_42 , L_6 , V_43 ) ;\r\nF_6 ( V_10 , V_44 , L_7 , V_45 ) ;\r\nF_6 ( V_10 , V_46 , L_7 , V_47 ) ;\r\nF_6 ( V_10 , V_48 , L_6 , V_49 ) ;\r\nF_6 ( V_10 , V_50 , L_7 , V_51 ) ;\r\nF_6 ( V_10 , V_52 , L_8 , V_53 ) ;\r\n#if 1\r\nF_6 ( V_10 , V_54 , L_7 , V_55 ) ;\r\nF_6 ( V_10 , V_56 , L_6 , V_57 ) ;\r\nF_6 ( V_10 , V_58 , L_6 , V_59 ) ;\r\nF_6 ( V_10 , V_60 , L_6 , V_61 ) ;\r\nF_6 ( V_10 , V_62 , L_6 , V_63 ) ;\r\n#ifdef F_7\r\nF_6 ( V_10 , V_64 , L_7 , V_65 ) ;\r\nF_6 ( V_10 , V_66 , L_7 , V_67 ) ;\r\nF_6 ( V_10 , V_68 , L_7 , V_69 ) ;\r\nF_6 ( V_10 , V_70 , L_7 , V_71 ) ;\r\nF_6 ( V_10 , V_72 , L_7 , V_73 ) ;\r\nF_6 ( V_10 , V_74 , L_7 , V_75 ) ;\r\nF_6 ( V_10 , V_76 , L_7 , V_77 ) ;\r\nF_6 ( V_10 , V_78 , L_7 , V_79 ) ;\r\nF_6 ( V_10 , V_80 , L_7 , V_81 ) ;\r\nF_6 ( V_10 , V_82 , L_7 , V_83 ) ;\r\nF_6 ( V_10 , V_84 , L_7 , V_85 ) ;\r\nF_6 ( V_10 , V_86 , L_7 , V_87 ) ;\r\nF_6 ( V_10 , V_88 , L_9 ,\r\nV_89 ) ;\r\nF_6 ( V_10 , V_90 , L_9 ,\r\nV_91 ) ;\r\nF_6 ( V_10 , V_92 , L_9 ,\r\nV_93 ) ;\r\nF_6 ( V_10 , V_94 , L_9 ,\r\nV_95 ) ;\r\nF_6 ( V_10 , V_96 , L_9 ,\r\nV_97 ) ;\r\nF_6 ( V_10 , V_98 , L_9 ,\r\nV_99 ) ;\r\n#endif\r\n#endif\r\nF_8 ( ! V_21 || ( strlen ( V_21 ) <= V_100 ) ) ;\r\nF_8 ( ! V_23 || ( strlen ( V_23 ) <= V_100 ) ) ;\r\nF_8 ( ( V_25 <= V_101 ) ) ;\r\nF_8 ( ( V_27 >= V_102 ) && ( V_27 <= V_103 ) ) ;\r\nF_8 ( ( V_29 >= V_104 ) && ( V_29 <= V_105 ) ) ;\r\nF_8 ( ( V_31 <= V_106 ) ) ;\r\nF_8 ( ! V_33 || strchr ( L_10 , V_33 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_35 || ( strlen ( V_34 ) <= V_100 ) ) ;\r\nF_8 ( ( V_107 <= V_108 ) ) ;\r\nF_8 ( F_9 ( V_37 ) ) ;\r\nF_8 ( F_9 ( V_39 ) ) ;\r\nF_8 ( F_9 ( V_41 ) ) ;\r\nF_8 ( F_9 ( V_43 ) ) ;\r\nF_8 ( ( V_45 >= V_109 ) && ( V_45 <= V_110 ) ) ;\r\nF_8 ( ( V_47 >= V_111 ) &&\r\n( V_47 <= V_112 ) ) ;\r\nF_8 ( ! V_49 || ( strlen ( V_49 ) <= 255 ) ) ;\r\nF_8 ( ( V_51 < V_113 ) ) ;\r\nF_8 ( ! V_114 || strchr ( L_10 , V_114 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_115 || strchr ( L_10 , V_115 [ 0 ] ) != NULL ) ;\r\nF_8 ( ( V_116 <= V_117 ) ) ;\r\nF_8 ( ( V_118 >= V_119 ) && ( V_118 <= V_120 ) ) ;\r\nF_8 ( V_53 <= V_121 ||\r\n( V_53 & 0x7FFF ) <= V_121 ) ;\r\nF_8 ( ! V_122 || strchr ( L_10 , V_122 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_123 || strchr ( L_10 , V_123 [ 0 ] ) != NULL ) ;\r\nF_8 ( ( V_124 <= V_125 ) ) ;\r\nF_8 ( ( V_126 <= V_127 ) ) ;\r\nF_8 ( ( V_128 <= V_129 ) ) ;\r\nF_8 ( ( V_130 <= V_131 ) ) ;\r\nF_8 ( ! V_132 || strchr ( L_10 , V_132 [ 0 ] ) != NULL ) ;\r\nF_8 ( ( V_133 <= V_134 ) ) ;\r\nF_8 ( ( V_55 >= V_135 ) ) ;\r\nF_8 ( ! V_57 || strchr ( L_10 , V_57 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_59 || strchr ( L_10 , V_59 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_61 || strchr ( L_10 , V_61 [ 0 ] ) != NULL ) ;\r\nF_8 ( ! V_63 || strchr ( L_10 , V_63 [ 0 ] ) != NULL ) ;\r\n#ifdef F_7\r\nF_8 ( ( V_65 <= V_106 ) ) ;\r\nF_8 ( ( V_67 <= V_106 ) ) ;\r\nF_8 ( ( V_69 <= V_106 ) ) ;\r\nF_8 ( ( V_71 <= V_106 ) ) ;\r\nF_8 ( ( V_73 <= V_106 ) ) ;\r\nF_8 ( ( V_75 <= V_106 ) ) ;\r\nF_8 ( ( V_77 >= V_104 ) && ( V_77 <= V_105 ) ) ;\r\nF_8 ( ( V_79 >= V_104 ) && ( V_79 <= V_105 ) ) ;\r\nF_8 ( ( V_81 >= V_104 ) && ( V_81 <= V_105 ) ) ;\r\nF_8 ( ( V_83 >= V_104 ) && ( V_83 <= V_105 ) ) ;\r\nF_8 ( ( V_85 >= V_104 ) && ( V_85 <= V_105 ) ) ;\r\nF_8 ( ( V_87 >= V_104 ) && ( V_87 <= V_105 ) ) ;\r\n#endif\r\nF_8 ( ( V_136 >= V_137 ) && ( V_136 <= V_138 ) ) ;\r\nF_8 ( ( V_139 <= V_139 ) ) ;\r\nV_9 -> V_140 = V_25 ;\r\nV_9 -> V_141 = V_27 ;\r\nV_9 -> V_142 [ 0 ] = V_143 ;\r\nV_9 -> V_142 [ 1 ] = V_144 ;\r\nV_9 -> V_145 = V_31 ;\r\nV_9 -> V_146 [ 0 ] = V_147 ;\r\nV_9 -> V_146 [ 1 ] = V_148 ;\r\nif ( strchr ( L_11 , V_33 [ 0 ] ) != NULL ) {\r\nV_9 -> V_149 = 1 ;\r\n} else {\r\nV_9 -> V_149 = 0 ;\r\n}\r\nif ( V_21 && ( strlen ( V_21 ) <= V_150 ) ) {\r\nstrcpy ( V_9 -> V_151 , V_21 ) ;\r\n}\r\nif ( V_23 && ( strlen ( V_23 ) <= V_150 ) ) {\r\nstrcpy ( V_9 -> V_151 , V_23 ) ;\r\n}\r\nif ( V_35 && ( strlen ( V_35 ) <= V_150 ) ) {\r\nstrcpy ( V_9 -> V_152 , V_35 ) ;\r\n}\r\nV_9 -> V_153 = V_107 ;\r\nif ( V_37 && ( strlen ( V_37 ) <= V_154 ) ) {\r\nstrcpy ( V_9 -> V_155 , V_37 ) ;\r\n}\r\nif ( V_39 && ( strlen ( V_39 ) <= V_154 ) ) {\r\nstrcpy ( V_9 -> V_156 , V_39 ) ;\r\n}\r\nif ( V_41 && ( strlen ( V_41 ) <= V_154 ) ) {\r\nstrcpy ( V_9 -> V_157 , V_41 ) ;\r\n}\r\nif ( V_43 && ( strlen ( V_43 ) <= V_154 ) ) {\r\nstrcpy ( V_9 -> V_158 , V_43 ) ;\r\n}\r\nV_9 -> V_159 = V_45 ;\r\nF_10 ( V_9 -> V_155 , & ( V_9 -> V_160 . V_161 [ 0 ] ) ) ;\r\nF_10 ( V_9 -> V_156 , & ( V_9 -> V_160 . V_161 [ 1 ] ) ) ;\r\nF_10 ( V_9 -> V_157 , & ( V_9 -> V_160 . V_161 [ 2 ] ) ) ;\r\nF_10 ( V_9 -> V_158 , & ( V_9 -> V_160 . V_161 [ 3 ] ) ) ;\r\nV_9 -> V_162 = 1 ;\r\nV_9 -> V_163 = V_51 ;\r\nif ( strchr ( L_11 , V_114 [ 0 ] ) != NULL ) {\r\nV_9 -> V_164 = 1 ;\r\n} else {\r\nV_9 -> V_164 = 0 ;\r\n}\r\nif ( strchr ( L_11 , V_115 [ 0 ] ) != NULL ) {\r\nV_9 -> V_165 = 1 ;\r\n} else {\r\nV_9 -> V_165 = 0 ;\r\n}\r\nV_9 -> V_166 = V_116 ;\r\nV_9 -> V_167 [ 0 ] = V_168 ;\r\nV_9 -> V_167 [ 1 ] = V_169 ;\r\nV_9 -> V_170 [ 0 ] = V_171 ;\r\nV_9 -> V_170 [ 1 ] = V_172 ;\r\n#if 1\r\nV_9 -> V_173 = V_118 ;\r\nV_9 -> V_174 = V_124 ;\r\nV_9 -> V_175 = V_126 ;\r\nV_9 -> V_176 = V_128 ;\r\nV_9 -> V_177 = V_130 ;\r\nV_9 -> V_178 = V_53 ;\r\nif ( strchr ( L_11 , V_122 [ 0 ] ) != NULL ) {\r\nV_9 -> V_179 = 1 ;\r\n} else {\r\nV_9 -> V_179 = 0 ;\r\n}\r\nif ( strchr ( L_12 , V_123 [ 0 ] ) != NULL ) {\r\nV_9 -> V_180 = 0 ;\r\n} else {\r\nV_9 -> V_180 = 1 ;\r\n}\r\nif ( strchr ( L_11 , V_132 [ 0 ] ) != NULL ) {\r\nV_9 -> V_181 = 1 ;\r\n} else {\r\nV_9 -> V_181 = 0 ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_183 [ V_6 ] = V_184 [ V_6 ] ;\r\n}\r\nV_9 -> V_185 = V_133 ;\r\n#endif\r\n#if 1\r\nV_9 -> V_186 = V_55 ;\r\nif ( strchr ( L_11 , V_57 [ 0 ] ) != NULL ) {\r\nV_9 -> V_187 = 1 ;\r\n} else {\r\nV_9 -> V_187 = 0 ;\r\n}\r\nif ( strchr ( L_12 , V_59 [ 0 ] ) != NULL ) {\r\nV_9 -> V_188 = 0 ;\r\n} else {\r\nV_9 -> V_188 = 1 ;\r\n}\r\nif ( strchr ( L_11 , V_61 [ 0 ] ) != NULL ) {\r\nV_9 -> V_189 = 1 ;\r\n} else {\r\nV_9 -> V_189 = 0 ;\r\n}\r\nif ( strchr ( L_11 , V_63 [ 0 ] ) != NULL ) {\r\nV_9 -> V_190 = 1 ;\r\n} else {\r\nV_9 -> V_190 = 0 ;\r\n}\r\nV_9 -> V_191 = V_136 ;\r\nV_9 -> V_192 = V_139 ;\r\n#ifdef F_7\r\nV_9 -> V_193 [ 0 ] . V_194 = V_65 ;\r\nV_9 -> V_193 [ 1 ] . V_194 = V_67 ;\r\nV_9 -> V_193 [ 2 ] . V_194 = V_69 ;\r\nV_9 -> V_193 [ 3 ] . V_194 = V_71 ;\r\nV_9 -> V_193 [ 4 ] . V_194 = V_73 ;\r\nV_9 -> V_193 [ 5 ] . V_194 = V_75 ;\r\nV_9 -> V_193 [ 0 ] . V_195 = V_77 ;\r\nV_9 -> V_193 [ 1 ] . V_195 = V_79 ;\r\nV_9 -> V_193 [ 2 ] . V_195 = V_81 ;\r\nV_9 -> V_193 [ 3 ] . V_195 = V_83 ;\r\nV_9 -> V_193 [ 4 ] . V_195 = V_85 ;\r\nV_9 -> V_193 [ 5 ] . V_195 = V_87 ;\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 0 ] . V_196 [ V_6 ] = V_89 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 1 ] . V_196 [ V_6 ] = V_91 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 2 ] . V_196 [ V_6 ] = V_93 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 3 ] . V_196 [ V_6 ] = V_95 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 4 ] . V_196 [ V_6 ] = V_97 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 5 ] . V_196 [ V_6 ] = V_99 [ V_6 ] ;\r\n}\r\n#endif\r\n#endif\r\n#ifdef F_11\r\nif ( strchr ( L_11 , V_197 [ 0 ] ) != NULL ) {\r\nV_9 -> V_197 = 1 ;\r\n} else {\r\nV_9 -> V_197 = 0 ;\r\n}\r\n#endif\r\nF_12 ( V_9 , & V_7 ) ;\r\nV_9 -> V_198 = V_199 ;\r\nmemset ( & ( V_9 -> V_200 ) , 0 , sizeof( V_9 -> V_200 ) ) ;\r\nV_9 -> V_200 . V_201 = FALSE ;\r\nmemset ( & ( V_9 -> V_202 ) , 0 , sizeof( V_9 -> V_202 ) ) ;\r\nV_9 -> V_202 . V_201 = FALSE ;\r\nV_9 -> V_203 = 0 ;\r\nmemset ( V_9 -> V_204 , 0 , sizeof( V_9 -> V_204 ) ) ;\r\nF_13 ( & ( V_9 -> V_205 ) ) ;\r\nV_9 -> V_206 . V_207 = NULL ;\r\nV_9 -> V_206 . V_208 = 0 ;\r\nfor( V_6 = 0 ; V_6 < V_209 ; V_6 ++ ) {\r\nF_14 ( & ( V_9 -> V_204 [ V_6 ] . V_210 ) , & ( V_9 -> V_205 ) ) ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_211 ; V_6 ++ ) {\r\nF_13 ( & ( V_9 -> V_212 [ V_6 ] ) ) ;\r\n}\r\nV_9 -> V_213 = TRUE ;\r\nV_9 -> V_214 = 0 ;\r\n#ifdef F_15\r\n#ifdef F_16\r\nF_17 ( V_10 , L_13 ) ;\r\nV_9 -> V_215 = 1 ;\r\n#else\r\nF_17 ( V_10 , L_14 ) ;\r\nV_9 -> V_215 = 0 ;\r\n#endif\r\n#endif\r\nF_18 ( & V_9 -> V_216 , V_217 , ( unsigned long ) V_9 ) ;\r\nF_17 ( V_10 , L_15 ) ;\r\nV_4 = F_19 ( & V_9 -> V_11 , V_2 -> V_218 ) ;\r\nif ( V_4 != V_5 && V_4 != V_219 ) {\r\nF_20 ( V_10 , L_16 , V_4 ) ;\r\nF_21 ( V_9 , & V_7 ) ;\r\ngoto V_220;\r\n}\r\nV_9 -> V_221 . V_222 = V_2 -> V_218 ;\r\nV_9 -> V_221 . V_223 = V_224 ;\r\nV_9 -> V_221 . V_225 = V_2 -> V_226 ;\r\nV_9 -> V_221 . V_227 = V_9 -> V_11 . V_228 ;\r\nV_9 -> V_229 . V_230 = ( sizeof( V_9 -> V_229 ) / sizeof( V_231 ) ) - 1 ;\r\nV_9 -> V_229 . V_232 = V_233 ;\r\nV_9 -> V_229 . V_234 = V_235 ;\r\nV_9 -> V_229 . V_236 = V_237 ;\r\nV_9 -> V_229 . V_238 = V_239 ;\r\nV_9 -> V_229 . V_240 = V_241 ;\r\nF_17 ( V_10 , L_17 ) ;\r\nV_4 = F_22 ( V_9 ) ;\r\nif ( V_4 != V_5 ) {\r\nF_20 ( V_10 , L_18 ) ;\r\nF_21 ( V_9 , & V_7 ) ;\r\ngoto V_220;\r\n}\r\nF_23 ( V_9 ) ;\r\n#if 0\r\nif ( wl_adapter_is_open( lp->dev )) {\r\nDBG_TRACE( DbgInfo, "Enabling Port 0\n" );\r\nhcf_status = wl_enable( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Enable port 0 failed: 0x%x\n", hcf_status );\r\n}\r\n#if ( V_242 ) & V_243\r\nDBG_TRACE( DbgInfo, "Enabling WDS Ports\n" );\r\n#endif\r\n}\r\n#endif\r\nmemcpy ( V_9 -> V_2 -> V_244 , V_9 -> V_183 , V_182 ) ;\r\nV_2 -> V_245 = V_182 ;\r\nV_9 -> V_246 = TRUE ;\r\n#ifdef F_24\r\nF_25 ( V_2 ) ;\r\n#endif\r\nF_26 ( V_9 ) ;\r\nV_9 -> V_162 = V_247 ;\r\n#ifdef F_11\r\nif ( V_9 -> V_197 == 1 ) {\r\nF_17 ( V_10 , L_19 ) ;\r\nF_27 ( V_9 ) ;\r\nV_9 -> V_14 = V_15 ;\r\nF_28 ( V_9 ) ;\r\nF_19 ( & V_9 -> V_11 , V_248 ) ;\r\n}\r\n#endif\r\nF_21 ( V_9 , & V_7 ) ;\r\nF_17 ( DbgInfo, L_20mac_address L_21%02X%cL_22wlagsL_23driver/wlags49L_24driver/wlags49/wlags49_typeL_25wl_insert() FAILED\nL_26wl_resetL_27devL_28%s (0x%p)L_29dev->base_addrL_28(%#03lx)L_30Device Base Address: %#03lx\nL_31hcf_connect() failed, status: 0x%x\nL_32wl_go() failed, status: 0x%x\nL_33Device Base Address INVALID!!!\nL_34wl_goL_35Disable port 0 failed: 0x%x\nL_36Disable port 0 succes : %d retries\nL_37Disable port 0 failed after: %d retries\nL_38Disabling WDS Ports\nL_39F/W image:%s:\nL_40No image file found\nL_41F/W image file found\nL_42error in vmalloc\nL_43buffer too small, %d\nL_44read O.K.: %d bytes %.12s\nL_45no more to read\nL_46file not read in one swoop or other errorL_47 , give up, too complicated, rc = %0X\nL_48still have to change code to get a real download now !!!!!!!!\nL_49before dhf_download_binary\nL_50after dhf_download_binary, before dhf_download_fw\nL_51after dhf_download_fw\nL_52Downloading STA firmware...\nL_53Firmware Download failed\nL_54downloaded station F/W\nL_55downloaded AP F/W\nL_56unknown F/W type\nL_57ComponentID:%04x variant:%04x major:%04x minor:%04x\nL_58Could not retrieve MAC address\nL_59Card MAC Address: %pM\nL_60wl_set_wep_keysL_27lpL_28%s (0x%p)L_61Key 1 len: %d\nL_62Key 2 len: %d\nL_63Key 3 len: %d\nL_64Key 4 len: %d\nL_65encrypt: %d, ID: %d\nL_66set key: %s(%d) [%d]\nL_67wl_applyL_68lpL_28%s (0x%p)L_69Disconnect failed\nL_70Disable failed\nL_71wl_put_ltv() failed\nL_72wl_put_ltv_initL_73lp pointer is NULL\nL_74CFG_CNTL_OPT : 0x%04x\nL_75CFG_CNTL_OPT result : 0x%04x\nL_76CFG_REG_INFO_LOG\nL_77CFG_REG_INFO_LOG result : 0x%04x\nL_78wl_put_ltvL_79lp pointer is NULL\nL_80Create IBSSL_81CFG_CNF_OWN_NAME : %s\nL_82CFG_CNF_OWN_NAME : EMPTY\nL_83CFG_CNF_OWN_NAME result : 0x%04x\nL_84CFG_TX_RATE_CNTL 2.4GHz : 0x%04x\nL_85CFG_TX_RATE_CNTL 5.0GHz : 0x%04x\nL_86CFG_TX_RATE_CNTL result : 0x%04x\nL_87CFG_CNF_PM_ENABLED : 0x%04x\nL_88ANYL_89anyL_90CFG_DESIRED_SSID : %s\nL_91CFG_DESIRED_SSID : ANY\nL_92CFG_DESIRED_SSID result : 0x%04x\nL_93CFG_PROBE_DATA_RATE 2.4GHz : 0x%04x\nL_94CFG_PROBE_DATA_RATE 5.0GHz : 0x%04x\nL_95CFG_PROBE_DATA_RATE result : 0x%04x\nL_96MAC Address : %pM\nL_97CFG_NIC_MAC_ADDR\nL_98CFG_CNF_OWN_MAC_ADDR\nL_99CFG_XXX_MAC_ADDR result : 0x%04x\nL_100ANYL_101anyL_102CFG_CNF_OWN_SSID : %s\nL_103CFG_CNF_OWN_SSID : ANY\nL_104CFG_CNF_OWN_SSID result : 0x%04x\nL_105wl_module_initL_106standardL_107%s\nL_108*** Modified for kernel 2.6 by Henk de Groot <pe1dnn@amsat.org>\nL_109*** Based on 7.18 version by Andrey Borzenkov <arvidjaar@mail.ru> $Revision: 39 $\nL_110Access Point Mode (AP) Support: YES\nL_111Access Point Mode (AP) Support: NO\nL_112wl_module_exitL_113wlagsL_114EXITING ISR, IN RTS MODE...\nL_115NOT OUR INTERRUPT\nL_116wl_isr_handler lp adapter pointer is NULL!!!\nL_117wl_removeL_118devL_28%s (0x%p)L_119wl_suspendL_118devL_28%s (0x%p)L_120wl_resumeL_118devL_28%s (0x%p)L_121wl_releaseL_118devL_28%s (0x%p)L_122Calling unregister_netdev(), as it wasn't called yet\n" );\r\nwl_remove( dev );\r\nlp->is_registered = FALSE;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n} // wl_release\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_mask()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_mask module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_mask module parameter\r\n*\r\n******************************************************************************/\r\np_u16 wl_get_irq_mask( void )\r\n{\r\nreturn irq_mask;\r\n} // wl_get_irq_mask\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_list()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_list module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_list module parameter\r\n*\r\n******************************************************************************/\r\np_s8 * wl_get_irq_list( void )\r\n{\r\nreturn irq_list;\r\n} // wl_get_irq_list\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_enable()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Used to enable MAC ports\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - pointer to the device's private adapter structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nint wl_enable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( L_123 );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState == WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, L_124 );\r\n} else if ( lp->portState == WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, L_125 );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_ENABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n#ifdef F_16\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_supply( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, L_126, hcf_status );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\n#ifdef F_7\r\nvoid wl_enable_wds_ports( struct wl_private * lp )\r\n{\r\nDBG_FUNC( L_127 );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, L_128 );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\nint wl_connect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nDBG_FUNC( L_129 );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState != WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, L_130 );\r\nDBG_LEAVE( DbgInfo );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_CONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_CONNECTED;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nint wl_disconnect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nDBG_FUNC( L_131 );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState != WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, L_132 );\r\nDBG_LEAVE( DbgInfo );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISCONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nint wl_disable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( L_133 );\r\nDBG_ENTER( DbgInfo );\r\nif ( lp->portState == WVLAN_PORT_STATE_DISABLED ) {\r\nDBG_TRACE( DbgInfo, L_134 );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n#ifdef F_16\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_reclaim( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, L_126, hcf_status );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\n#ifdef F_7\r\nvoid wl_disable_wds_ports( struct wl_private * lp )\r\n{\r\nDBG_FUNC( L_135 );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, L_128 );\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#ifndef F_29\r\nint wl_mbx( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_FUNC( L_136 );\r\nDBG_ENTER( DbgInfo );\r\nDBG_TRACE( DbgInfo, L_137,\r\nlp->hcfCtx.IFB_MBInfoLen );\r\nmemset( &( lp->ltvRecord ), 0, sizeof( ltv_t ));\r\nlp->ltvRecord.len = MB_SIZE;\r\nlp->ltvRecord.typ = CFG_MB_INFO;\r\nhcf_status = hcf_get_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, L_138, hcf_status );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nif ( lp->ltvRecord.typ == CFG_MB_INFO ) {\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nwl_endian_translate_mailbox( &( lp->ltvRecord ));\r\nwl_process_mailbox( lp );\r\nDBG_LEAVE( DbgInfo );\r\nreturn hcf_status;\r\n}\r\nvoid wl_endian_translate_mailbox( ltv_t *ltv )\r\n{\r\nDBG_FUNC( L_139 );\r\nDBG_ENTER( DbgInfo );\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nbreak;\r\ncase CFG_SCAN:\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\naps[num_aps].channel_id =\r\nCNV_LITTLE_TO_INT( aps[num_aps].channel_id );\r\naps[num_aps].noise_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].noise_level );\r\naps[num_aps].signal_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].signal_level );\r\naps[num_aps].beacon_interval_time =\r\nCNV_LITTLE_TO_INT( aps[num_aps].beacon_interval_time );\r\naps[num_aps].capability =\r\nCNV_LITTLE_TO_INT( aps[num_aps].capability );\r\naps[num_aps].ssid_len =\r\nCNV_LITTLE_TO_INT( aps[num_aps].ssid_len );\r\naps[num_aps].ssid_val[aps[num_aps].ssid_len] = 0;\r\n}\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\n{\r\nPROBE_RESP *probe_resp = (PROBE_RESP *)ltv;\r\nprobe_resp->frameControl = CNV_LITTLE_TO_INT( probe_resp->frameControl );\r\nprobe_resp->durID = CNV_LITTLE_TO_INT( probe_resp->durID );\r\nprobe_resp->sequence = CNV_LITTLE_TO_INT( probe_resp->sequence );\r\nprobe_resp->dataLength = CNV_LITTLE_TO_INT( probe_resp->dataLength );\r\n#ifndef F_15\r\nprobe_resp->lenType = CNV_LITTLE_TO_INT( probe_resp->lenType );\r\n#endif\r\nprobe_resp->beaconInterval = CNV_LITTLE_TO_INT( probe_resp->beaconInterval );\r\nprobe_resp->capability = CNV_LITTLE_TO_INT( probe_resp->capability );\r\nprobe_resp->flags = CNV_LITTLE_TO_INT( probe_resp->flags );\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define F_30 ((LINK_STATUS_STRCT *)ltv)\r\nls->linkStatus = CNV_LITTLE_TO_INT( ls->linkStatus );\r\nbreak;\r\n#undef F_30\r\ncase CFG_ASSOC_STAT:\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nas->assocStatus = CNV_LITTLE_TO_INT( as->assocStatus );\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nss->securityStatus = CNV_LITTLE_TO_INT( ss->securityStatus );\r\nss->reason = CNV_LITTLE_TO_INT( ss->reason );\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nbreak;\r\ncase CFG_NULL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_process_mailbox( struct wl_private *lp )\r\n{\r\nltv_t *ltv;\r\nhcf_16 ltv_val = 0xFFFF;\r\nDBG_FUNC( L_140 );\r\nDBG_ENTER( DbgInfo );\r\nltv = &( lp->ltvRecord );\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nDBG_TRACE( DbgInfo, L_141 );\r\nbreak;\r\ncase CFG_SCAN:\r\nDBG_TRACE( DbgInfo, L_142 );\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nlp->scan_results.num_aps = num_aps;\r\nDBG_TRACE( DbgInfo, L_143, num_aps );\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\nDBG_TRACE( DbgInfo, L_144, num_aps );\r\nDBG_TRACE( DbgInfo, L_145 );\r\nDBG_TRACE( DbgInfo, L_146,\r\naps[num_aps].channel_id );\r\nDBG_TRACE( DbgInfo, L_147,\r\naps[num_aps].noise_level );\r\nDBG_TRACE( DbgInfo, L_148,\r\naps[num_aps].signal_level );\r\nDBG_TRACE( DbgInfo, L_149,\r\naps[num_aps].beacon_interval_time );\r\nDBG_TRACE( DbgInfo, L_150,\r\naps[num_aps].capability );\r\nDBG_TRACE( DbgInfo, L_151,\r\naps[num_aps].ssid_len );\r\nDBG_TRACE(DbgInfo, L_152,\r\naps[num_aps].bssid);\r\nif ( aps[num_aps].ssid_len != 0 ) {\r\nDBG_TRACE( DbgInfo, L_153,\r\naps[num_aps].ssid_val );\r\n} else {\r\nDBG_TRACE( DbgInfo, L_153, L_154 );\r\n}\r\nDBG_TRACE( DbgInfo, L_155 );\r\nmemcpy( &( lp->scan_results.APTable[num_aps]), &( aps[num_aps] ),\r\nsizeof( SCAN_RS_STRCT ));\r\n}\r\nlp->scan_results.scan_complete = TRUE;\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\nDBG_TRACE( DbgInfo, L_156 );\r\n{\r\nPROBE_RESP *probe_rsp = (PROBE_RESP *)ltv;\r\nhcf_8 *wpa_ie = NULL;\r\nhcf_16 wpa_ie_len = 0;\r\nDBG_TRACE( DbgInfo, L_157,\r\nlp->dev->name );\r\nDBG_TRACE( DbgInfo, L_158,\r\nlp->dev->name, probe_rsp->length );\r\nif ( probe_rsp->length > 1 ) {\r\nDBG_TRACE( DbgInfo, L_159,\r\nlp->dev->name, probe_rsp->infoType );\r\nDBG_TRACE( DbgInfo, L_160,\r\nlp->dev->name, probe_rsp->signal );\r\nDBG_TRACE( DbgInfo, L_161,\r\nlp->dev->name, probe_rsp->silence );\r\nDBG_TRACE( DbgInfo, L_162,\r\nlp->dev->name, probe_rsp->rxFlow );\r\nDBG_TRACE( DbgInfo, L_163,\r\nlp->dev->name, probe_rsp->rate );\r\nDBG_TRACE( DbgInfo, L_164,\r\nlp->dev->name, probe_rsp->frameControl );\r\nDBG_TRACE( DbgInfo, L_165,\r\nlp->dev->name, probe_rsp->durID );\r\nDBG_TRACE(DbgInfo, L_166,\r\nlp->dev->name, probe_rsp->address1);\r\nDBG_TRACE(DbgInfo, L_167,\r\nlp->dev->name, probe_rsp->address2);\r\nDBG_TRACE(DbgInfo, L_168,\r\nlp->dev->name, probe_rsp->BSSID);\r\nDBG_TRACE( DbgInfo, L_169,\r\nlp->dev->name, probe_rsp->sequence );\r\nDBG_TRACE(DbgInfo, L_170,\r\nlp->dev->name, probe_rsp->address4);\r\nDBG_TRACE( DbgInfo, L_171,\r\nlp->dev->name, probe_rsp->dataLength );\r\nDBG_TRACE(DbgInfo, L_172,\r\nlp->dev->name, probe_rsp->DA);\r\nDBG_TRACE(DbgInfo, L_173,\r\nlp->dev->name, probe_rsp->SA);\r\nDBG_TRACE(DbgInfo, L_174\r\nL_175,\r\nlp->dev->name,\r\nprobe_rsp->timeStamp[0],\r\nprobe_rsp->timeStamp[1],\r\nprobe_rsp->timeStamp[2],\r\nprobe_rsp->timeStamp[3],\r\nprobe_rsp->timeStamp[4],\r\nprobe_rsp->timeStamp[5],\r\nprobe_rsp->timeStamp[6],\r\nprobe_rsp->timeStamp[7]);\r\nDBG_TRACE( DbgInfo, L_176,\r\nlp->dev->name, probe_rsp->beaconInterval );\r\nDBG_TRACE( DbgInfo, L_177,\r\nlp->dev->name, probe_rsp->capability );\r\nDBG_TRACE( DbgInfo, L_178,\r\nlp->dev->name, probe_rsp->rawData[1] );\r\nif ( probe_rsp->rawData[1] > 0 ) {\r\nchar ssid[HCF_MAX_NAME_LEN];\r\nmemset( ssid, 0, sizeof( ssid ));\r\nstrncpy( ssid, &probe_rsp->rawData[2],\r\nprobe_rsp->rawData[1] );\r\nDBG_TRACE( DbgInfo, L_179,\r\nlp->dev->name, ssid );\r\n}\r\nwpa_ie = wl_parse_wpa_ie( probe_rsp, &wpa_ie_len );\r\nif ( wpa_ie != NULL ) {\r\nDBG_TRACE( DbgInfo, L_180,\r\nlp->dev->name, wl_print_wpa_ie( wpa_ie, wpa_ie_len ));\r\n}\r\nDBG_TRACE( DbgInfo, L_181,\r\nlp->dev->name, probe_rsp->flags );\r\n}\r\nDBG_TRACE( DbgInfo, L_182 );\r\nif ( probe_rsp->length == 1 ) {\r\nDBG_TRACE( DbgInfo, L_183 );\r\nlp->probe_results.num_aps = lp->probe_num_aps;\r\nlp->probe_results.scan_complete = TRUE;\r\nlp->probe_num_aps = 0;\r\nwl_wext_event_scan_complete( lp->dev );\r\n} else {\r\nif ( lp->probe_num_aps == 0 ) {\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\nlp->probe_num_aps++;\r\n} else {\r\nint count;\r\nint unique = 1;\r\nfor( count = 0; count < lp->probe_num_aps; count++ ) {\r\nif ( memcmp( &( probe_rsp->BSSID ),\r\nlp->probe_results.ProbeTable[count].BSSID,\r\nETH_ALEN ) == 0 ) {\r\nunique = 0;\r\n}\r\n}\r\nif ( unique ) {\r\nif ( lp->probe_num_aps < MAX_NAPS )\r\n{\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\n}\r\nelse\r\n{\r\nDBG_WARNING( DbgInfo, L_184 );\r\n}\r\nlp->probe_num_aps++;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define F_30 ((LINK_STATUS_STRCT *)ltv)\r\nDBG_TRACE( DbgInfo, L_185 );\r\nswitch( ls->linkStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_186 );\r\nwl_wext_event_ap( lp->dev );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_187 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_188 );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, L_189 );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, L_190 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_191,\r\nls->linkStatus );\r\nbreak;\r\n}\r\nbreak;\r\n#undef F_30\r\ncase CFG_ASSOC_STAT:\r\nDBG_TRACE( DbgInfo, L_192 );\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nswitch( as->assocStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_193 );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_194 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_195 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_196,\r\nas->assocStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, L_197,\r\nas->staAddr);\r\nif (( as->assocStatus == 2 ) && ( as->len == 8 )) {\r\nDBG_TRACE(DbgInfo, L_198,\r\nas->oldApAddr);\r\n}\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\nDBG_TRACE( DbgInfo, L_199 );\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nswitch( ss->securityStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_200 );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_201 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_202 );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, L_203 );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, L_204 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_205,\r\nss->securityStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, L_206,\r\nss->staAddr);\r\nDBG_TRACE(DbgInfo, L_207,\r\nss->reason);\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nDBG_TRACE( DbgInfo, L_208, ltv->len );\r\n{\r\nWMP_RSP_STRCT *wmp_rsp = (WMP_RSP_STRCT *)ltv;\r\nDBG_TRACE( DbgInfo, L_209,\r\nwmp_rsp->wmpRsp.wmpHdr.type );\r\nswitch( wmp_rsp->wmpRsp.wmpHdr.type ) {\r\ncase WVLAN_WMP_PDU_TYPE_LT_RSP:\r\n{\r\n#if V_249\r\nLINKTEST_RSP_STRCT *lt_rsp = (LINKTEST_RSP_STRCT *)ltv;\r\n#endif\r\nDBG_TRACE( DbgInfo, L_210 );\r\nDBG_TRACE( DbgInfo, L_211 );\r\nDBG_TRACE( DbgInfo, L_212, lt_rsp->len );\r\nDBG_TRACE( DbgInfo, L_213, lt_rsp->ltRsp.ltRsp.name );\r\nDBG_TRACE( DbgInfo, L_214, lt_rsp->ltRsp.ltRsp.signal );\r\nDBG_TRACE( DbgInfo, L_215, lt_rsp->ltRsp.ltRsp.noise );\r\nDBG_TRACE( DbgInfo, L_216, lt_rsp->ltRsp.ltRsp.rxFlow );\r\nDBG_TRACE( DbgInfo, L_217, lt_rsp->ltRsp.ltRsp.dataRate );\r\nDBG_TRACE( DbgInfo, L_218, lt_rsp->ltRsp.ltRsp.protocol );\r\nDBG_TRACE( DbgInfo, L_219, lt_rsp->ltRsp.ltRsp.station );\r\nDBG_TRACE( DbgInfo, L_220, lt_rsp->ltRsp.ltRsp.dataRateCap );\r\nDBG_TRACE( DbgInfo, L_221,\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[0],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[1],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[2],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[3] );\r\nDBG_TRACE( DbgInfo, L_222,\r\nlt_rsp->ltRsp.ltRsp.robustness[0],\r\nlt_rsp->ltRsp.ltRsp.robustness[1],\r\nlt_rsp->ltRsp.ltRsp.robustness[2],\r\nlt_rsp->ltRsp.ltRsp.robustness[3] );\r\nDBG_TRACE( DbgInfo, L_223, lt_rsp->ltRsp.ltRsp.scaling );\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase CFG_NULL:\r\nDBG_TRACE( DbgInfo, L_224 );\r\nbreak;\r\ncase CFG_UPDATED_INFO_RECORD:\r\nDBG_TRACE( DbgInfo, L_225 );\r\nltv_val = CNV_INT_TO_LITTLE( ltv->u.u16[0] );\r\nswitch( ltv_val ) {\r\ncase CFG_CUR_COUNTRY_INFO:\r\nDBG_TRACE( DbgInfo, L_226 );\r\nwl_connect( lp );\r\nbreak;\r\ncase CFG_PORT_STAT:\r\nbreak;\r\ndefault:\r\nDBG_WARNING( DbgInfo, L_227, ltv_val );\r\n}\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_228, ltv->typ );\r\nbreak;\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#ifdef F_7\r\nvoid wl_wds_netdev_register( struct wl_private *lp )\r\n{\r\nint count;\r\nDBG_FUNC( L_229 );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nif ( register_netdev( lp->wds_port[count].dev ) != 0 ) {\r\nDBG_WARNING( DbgInfo, L_230,\r\n( count + 1 ));\r\n}\r\nlp->wds_port[count].is_registered = TRUE;\r\nmemcpy( lp->wds_port[count].dev->dev_addr, lp->MACAddress, ETH_ALEN );\r\nlp->wds_port[count].dev->addr_len = ETH_ALEN;\r\n}\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\nvoid wl_wds_netdev_deregister( struct wl_private *lp )\r\n{\r\nint count;\r\nDBG_FUNC( L_231 );\r\nDBG_ENTER( DbgInfo );\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nunregister_netdev( lp->wds_port[count].dev );\r\n}\r\nlp->wds_port[count].is_registered = FALSE;\r\n}\r\n}\r\nDBG_LEAVE( DbgInfo );\r\nreturn;\r\n}\r\n#endif\r\n#if 0\r\nint printf_hcf_16( char *s, char *buf, hcf_16* p, int n );\r\nint printf_hcf_16( char *s, char *buf, hcf_16* p, int n ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i < n; i++ ) {\r\nif ( len % 80 > 75 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%04X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint printf_hcf_8( char *s, char *buf, hcf_8* p, int n );\r\nint printf_hcf_8( char *s, char *buf, hcf_8* p, int n ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i <= n; i++ ) {\r\nif ( len % 80 > 77 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%02X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint printf_strct( char *s, char *buf, hcf_16* p );\r\nint printf_strct( char *s, char *buf, hcf_16* p ) {\r\nint i, len;\r\nlen = sprintf(buf, "%s", s );\r\nwhile ( len < 20 ) len += sprintf(buf+len, " " );\r\nlen += sprintf(buf+len,": " );\r\nfor ( i = 0; i <= *p; i++ ) {\r\nif ( len % 80 > 75 ) {\r\nlen += sprintf(buf+len,"\n" );\r\n}\r\nlen += sprintf(buf+len,"%04X ", p[i] );\r\n}\r\nlen += sprintf(buf+len,"\n" );\r\nreturn len;\r\n}\r\nint scull_read_procmem(char *buf, char **start, off_t offset, int len, int *eof, void *data )\r\n{\r\nstruct wl_private *lp = NULL;\r\nIFBP ifbp;\r\nCFG_HERMES_TALLIES_STRCT *p;\r\n#define F_31 (PAGE_SIZE-80)\r\nlen=0;\r\nlp = ((struct net_device *)data)->priv;\r\nif (lp == NULL) {\r\nlen += sprintf(buf+len,"No wl_private in scull_read_procmem\n" );\r\n} else if ( lp->wlags49_type == 0 ){\r\nifbp = &lp->hcfCtx;\r\nlen += sprintf(buf+len,"Magic: 0x%04X\n", ifbp->IFB_Magic );\r\nlen += sprintf(buf+len,"IOBase: 0x%04X\n", ifbp->IFB_IOBase );\r\nlen += sprintf(buf+len,"LinkStat: 0x%04X\n", ifbp->IFB_LinkStat );\r\nlen += sprintf(buf+len,"DSLinkStat: 0x%04X\n", ifbp->IFB_DSLinkStat );\r\nlen += sprintf(buf+len,"TickIni: 0x%08lX\n", ifbp->IFB_TickIni );\r\nlen += sprintf(buf+len,"TickCnt: 0x%04X\n", ifbp->IFB_TickCnt );\r\nlen += sprintf(buf+len,"IntOffCnt: 0x%04X\n", ifbp->IFB_IntOffCnt );\r\nlen += printf_hcf_16( "IFB_FWIdentity", &buf[len],\r\n&ifbp->IFB_FWIdentity.len, ifbp->IFB_FWIdentity.len + 1 );\r\n} else if ( lp->wlags49_type == 1 ) {\r\nlen += sprintf(buf+len,"Channel: 0x%04X\n", lp->Channel );\r\n#ifdef F_32\r\n#endif\r\nlen += sprintf(buf+len,"IFB: 0x%p\n", &lp->hcfCtx );\r\nlen += sprintf(buf+len,"flags: %#.8lX\n", lp->flags );\r\nlen += sprintf(buf+len,"DebugFlag(wl_private) 0x%04X\n", lp->DebugFlag );\r\n#if V_249\r\nlen += sprintf(buf+len,"DebugFlag (DbgInfo): 0x%08lX\n", DbgInfo->DebugFlag );\r\n#endif\r\nlen += sprintf(buf+len,"is_registered: 0x%04X\n", lp->is_registered );\r\nlen += printf_strct( "driverInfo", &buf[len], (hcf_16*)&lp->driverInfo );\r\nlen += printf_strct( "driverIdentity", &buf[len], (hcf_16*)&lp->driverIdentity );\r\nlen += printf_strct( "StationIdentity", &buf[len], (hcf_16*)&lp->StationIdentity );\r\nlen += printf_strct( "PrimaryIdentity", &buf[len], (hcf_16*)&lp->hcfCtx.IFB_PRIIdentity );\r\nlen += printf_strct( "PrimarySupplier", &buf[len], (hcf_16*)&lp->hcfCtx.IFB_PRISup );\r\nlen += printf_strct( "NICIdentity", &buf[len], (hcf_16*)&lp->NICIdentity );\r\nlen += sprintf(buf+len,"txBytes: 0x%08lX\n", lp->txBytes );\r\nlen += sprintf(buf+len,"maxPort: 0x%04X\n", lp->maxPort );\r\nlen += sprintf(buf+len,"PortType: 0x%04X\n", lp->PortType );\r\nlen += sprintf(buf+len,"Channel: 0x%04X\n", lp->Channel );\r\nlen += sprintf(buf+len,"TxRateControl[2]: 0x%04X 0x%04X\n",\r\nlp->TxRateControl[0], lp->TxRateControl[1] );\r\nlen += sprintf(buf+len,"DistanceBetweenAPs: 0x%04X\n", lp->DistanceBetweenAPs );\r\nlen += sprintf(buf+len,"RTSThreshold: 0x%04X\n", lp->RTSThreshold );\r\nlen += sprintf(buf+len,"PMEnabled: 0x%04X\n", lp->PMEnabled );\r\nlen += sprintf(buf+len,"MicrowaveRobustness: 0x%04X\n", lp->MicrowaveRobustness );\r\nlen += sprintf(buf+len,"CreateIBSS: 0x%04X\n", lp->CreateIBSS );\r\nlen += sprintf(buf+len,"MulticastReceive: 0x%04X\n", lp->MulticastReceive );\r\nlen += sprintf(buf+len,"MaxSleepDuration: 0x%04X\n", lp->MaxSleepDuration );\r\nlen += printf_hcf_8( "MACAddress", &buf[len], lp->MACAddress, ETH_ALEN );\r\nlen += sprintf(buf+len,"NetworkName: %.32s\n", lp->NetworkName );\r\nlen += sprintf(buf+len,"EnableEncryption: 0x%04X\n", lp->EnableEncryption );\r\nlen += printf_hcf_8( "Key1", &buf[len], lp->Key1, MAX_KEY_LEN );\r\nlen += sprintf(buf+len,"TransmitKeyID: 0x%04X\n", lp->TransmitKeyID );\r\nlen += sprintf(buf+len,"driverEnable: 0x%04X\n", lp->driverEnable );\r\nlen += sprintf(buf+len,"wolasEnable: 0x%04X\n", lp->wolasEnable );\r\nlen += sprintf(buf+len,"atimWindow: 0x%04X\n", lp->atimWindow );\r\nlen += sprintf(buf+len,"holdoverDuration: 0x%04X\n", lp->holdoverDuration );\r\nlen += sprintf(buf+len,"authentication: 0x%04X\n", lp->authentication );\r\nlen += sprintf(buf+len,"promiscuousMode: 0x%04X\n", lp->promiscuousMode );\r\nlen += sprintf(buf+len,"DownloadFirmware: 0x%04X\n", lp->DownloadFirmware );\r\nlen += sprintf(buf+len,"AuthKeyMgmtSuite: 0x%04X\n", lp->AuthKeyMgmtSuite );\r\nlen += sprintf(buf+len,"loadBalancing: 0x%04X\n", lp->loadBalancing );\r\nlen += sprintf(buf+len,"mediumDistribution: 0x%04X\n", lp->mediumDistribution );\r\nlen += sprintf(buf+len,"txPowLevel: 0x%04X\n", lp->txPowLevel );\r\nlen += sprintf(buf+len,"connectionControl: 0x%04X\n", lp->connectionControl );\r\nlen += sprintf(buf+len,"ownBeaconInterval: 0x%04X\n", lp->ownBeaconInterval );\r\nlen += sprintf(buf+len,"coexistence: 0x%04X\n", lp->coexistence );\r\nlen += sprintf(buf+len,"netif_queue_on: 0x%04X\n", lp->netif_queue_on );\r\nlen += sprintf(buf+len,"txQ_count: 0x%04X\n", lp->txQ_count );\r\nlen += sprintf(buf+len,"probe_num_aps: 0x%04X\n", lp->probe_num_aps );\r\nlen += sprintf(buf+len,"use_dma: 0x%04X\n", lp->use_dma );\r\n#ifdef F_11\r\nlen += sprintf(buf+len,"useRTS: 0x%04X\n", lp->useRTS );\r\n#endif\r\n#if 1\r\nlen += sprintf(buf+len,"DTIMPeriod: 0x%04X\n", lp->DTIMPeriod );\r\nlen += sprintf(buf+len,"multicastPMBuffering: 0x%04X\n", lp->multicastPMBuffering );\r\nlen += sprintf(buf+len,"RejectAny: 0x%04X\n", lp->RejectAny );\r\nlen += sprintf(buf+len,"ExcludeUnencrypted: 0x%04X\n", lp->ExcludeUnencrypted );\r\nlen += sprintf(buf+len,"intraBSSRelay: 0x%04X\n", lp->intraBSSRelay );\r\nlen += sprintf(buf+len,"wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\n#ifdef F_7\r\n#endif\r\n#endif\r\n} else if ( lp->wlags49_type == 2 ){\r\nlen += sprintf(buf+len,"tallies to be added\n" );\r\np = &lp->hcfCtx.IFB_NIC_Tallies;\r\nlen += sprintf(buf+len,"TxUnicastFrames: %08lX\n", p->TxUnicastFrames );\r\nlen += sprintf(buf+len,"TxMulticastFrames: %08lX\n", p->TxMulticastFrames );\r\nlen += sprintf(buf+len,"TxFragments: %08lX\n", p->TxFragments );\r\nlen += sprintf(buf+len,"TxUnicastOctets: %08lX\n", p->TxUnicastOctets );\r\nlen += sprintf(buf+len,"TxMulticastOctets: %08lX\n", p->TxMulticastOctets );\r\nlen += sprintf(buf+len,"TxDeferredTransmissions: %08lX\n", p->TxDeferredTransmissions );\r\nlen += sprintf(buf+len,"TxSingleRetryFrames: %08lX\n", p->TxSingleRetryFrames );\r\nlen += sprintf(buf+len,"TxMultipleRetryFrames: %08lX\n", p->TxMultipleRetryFrames );\r\nlen += sprintf(buf+len,"TxRetryLimitExceeded: %08lX\n", p->TxRetryLimitExceeded );\r\nlen += sprintf(buf+len,"TxDiscards: %08lX\n", p->TxDiscards );\r\nlen += sprintf(buf+len,"RxUnicastFrames: %08lX\n", p->RxUnicastFrames );\r\nlen += sprintf(buf+len,"RxMulticastFrames: %08lX\n", p->RxMulticastFrames );\r\nlen += sprintf(buf+len,"RxFragments: %08lX\n", p->RxFragments );\r\nlen += sprintf(buf+len,"RxUnicastOctets: %08lX\n", p->RxUnicastOctets );\r\nlen += sprintf(buf+len,"RxMulticastOctets: %08lX\n", p->RxMulticastOctets );\r\nlen += sprintf(buf+len,"RxFCSErrors: %08lX\n", p->RxFCSErrors );\r\nlen += sprintf(buf+len,"RxDiscardsNoBuffer: %08lX\n", p->RxDiscardsNoBuffer );\r\nlen += sprintf(buf+len,"TxDiscardsWrongSA: %08lX\n", p->TxDiscardsWrongSA );\r\nlen += sprintf(buf+len,"RxWEPUndecryptable: %08lX\n", p->RxWEPUndecryptable );\r\nlen += sprintf(buf+len,"RxMsgInMsgFragments: %08lX\n", p->RxMsgInMsgFragments );\r\nlen += sprintf(buf+len,"RxMsgInBadMsgFragments: %08lX\n", p->RxMsgInBadMsgFragments );\r\nlen += sprintf(buf+len,"RxDiscardsWEPICVError: %08lX\n", p->RxDiscardsWEPICVError );\r\nlen += sprintf(buf+len,"RxDiscardsWEPExcluded: %08lX\n", p->RxDiscardsWEPExcluded );\r\n#if ( V_250 ) & V_251\r\n#endif\r\n} else if ( lp->wlags49_type & 0x8000 ) {\r\n#if V_249\r\nDbgInfo->DebugFlag = lp->wlags49_type & 0x7FFF;\r\n#endif\r\nlp->wlags49_type = 0;\r\n} else {\r\nlen += sprintf(buf+len,"unknown value for wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\nlen += sprintf(buf+len,"0x0000 - IFB\n" );\r\nlen += sprintf(buf+len,"0x0001 - wl_private\n" );\r\nlen += sprintf(buf+len,"0x0002 - Tallies\n" );\r\nlen += sprintf(buf+len,"0x8xxx - Change debufflag\n" );\r\nlen += sprintf(buf+len,"ERROR 0001\nWARNING 0002\nNOTICE 0004\nTRACE 0008\n" );\r\nlen += sprintf(buf+len,"VERBOSE 0010\nPARAM 0020\nBREAK 0040\nRX 0100\n" );\r\nlen += sprintf(buf+len,"TX 0200\nDS 0400\n" );\r\n}\r\nreturn len;\r\n}\r\nstatic void proc_write(const char *name, write_proc_t *w, void *data)\r\n{\r\nstruct proc_dir_entry * entry = create_proc_entry(name, S_IFREG | S_IWUSR, NULL);\r\nif (entry) {\r\nentry->write_proc = w;\r\nentry->data = data;\r\n}\r\n}\r\nstatic int write_int(struct file *file, const char *buffer, unsigned long count, void *data)\r\n{\r\nstatic char proc_number[11];\r\nunsigned int nr = 0;\r\nDBG_FUNC( "write_int" );\r\nDBG_ENTER( DbgInfo );\r\nif (count > 9) {\r\ncount = -EINVAL;\r\n} else if ( copy_from_user(proc_number, buffer, count) ) {\r\ncount = -EFAULT;\r\n}\r\nif (count > 0 ) {\r\nproc_number[count] = 0;\r\nnr = simple_strtoul(proc_number , NULL, 0);\r\n*(unsigned int *)data = nr;\r\nif ( nr & 0x8000 ) {\r\n#if V_249\r\nDbgInfo->DebugFlag = nr & 0x7FFF;\r\n#endif\r\n}\r\n}\r\nDBG_PRINT( "value: %08X\n", nr );\r\nDBG_LEAVE( DbgInfo );\r\nreturn count;\r\n}\r\n#endif\r\n#ifdef F_33\r\n#define F_34 ( T_1 ) (jiffies+(x))\r\n#define F_35 0x8000\r\nlp->timer_oor_cnt = DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( 3 * HZ );\r\nadd_timer( &lp->timer_oor );\r\nprintk( L_232, jiffies );\r\n#endif\r\n#ifdef F_33\r\nvoid timer_oor( u_long arg )\r\n{\r\nstruct wl_private *lp = (struct wl_private *)arg;\r\nDBG_FUNC( L_233 );\r\nDBG_ENTER( DbgInfo );\r\nDBG_PARAM( DbgInfo, L_234, L_235, arg );\r\nprintk( L_236, jiffies, lp->timer_oor_cnt );\r\nlp->timer_oor_cnt += 10;\r\nif ( (lp->timer_oor_cnt & ~DS_OOR) > 300 ) {\r\nlp->timer_oor_cnt = 300;\r\n}\r\nlp->timer_oor_cnt |= DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( (lp->timer_oor_cnt & ~DS_OOR) * HZ );\r\nadd_timer( &lp->timer_oor );\r\nDBG_LEAVE( DbgInfo );\r\n}\r\n#endif\r\nMODULE_LICENSE(L_237);
