static int F_1 ( struct V_1 * V_2 )\r\n{\r\nstruct V_3 V_4 ;\r\nunsigned int V_5 , V_6 = 0 ;\r\nT_1 V_7 ;\r\nT_2 V_8 [ V_9 ] ;\r\nstruct V_10 * V_11 = & V_2 -> V_12 ;\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nunsigned int V_16 ;\r\nV_2 -> V_17 = V_2 -> V_15 . V_14 -> V_18 ;\r\nV_2 -> V_19 = ( V_20 ) V_2 -> V_15 . V_14 -> V_21 / V_2 -> V_17 ;\r\nV_2 -> V_22 = V_23 ;\r\nV_2 -> V_24 = V_23 ;\r\nfor ( V_5 = 0 ; V_5 < V_2 -> V_19 ; V_5 ++ ) {\r\nint V_25 ;\r\nV_25 = V_14 -> V_26 ( V_14 , V_5 * V_2 -> V_17 , V_9 ,\r\n& V_7 , V_8 ) ;\r\nif ( V_7 != V_9 ) {\r\nstatic int V_27 = 5 ;\r\nif ( V_27 ) {\r\nF_2 ( V_28 L_1 ,\r\nV_5 * V_2 -> V_17 , V_2 -> V_15 . V_14 -> V_29 , V_25 ) ;\r\nif ( ! -- V_27 )\r\nF_2 ( V_28 L_2 ) ;\r\n}\r\ncontinue;\r\n}\r\nif ( V_7 < 6 || memcmp ( V_8 , L_3 , 6 ) ) {\r\n#if 0\r\nprintk(KERN_DEBUG "ANAND header not found at 0x%x in mtd%d\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index);\r\n#endif\r\ncontinue;\r\n}\r\nif ( ( V_25 = F_3 ( V_14 , V_5 * V_2 -> V_17 +\r\nV_9 + 8 , 8 , & V_7 ,\r\n( char * ) & V_4 ) < 0 ) ) {\r\nF_2 ( V_28 L_4 ,\r\nV_5 * V_2 -> V_17 , V_2 -> V_15 . V_14 -> V_29 , V_25 ) ;\r\ncontinue;\r\n}\r\n#if 0\r\nif (le16_to_cpu(h1.EraseMark | h1.EraseMark1) != ERASE_MARK) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but erase mark not present (0x%04x,0x%04x instead)\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index,\r\nle16_to_cpu(h1.EraseMark), le16_to_cpu(h1.EraseMark1));\r\ncontinue;\r\n}\r\nif ((ret = mtd->read(mtd, block * nftl->EraseSize, SECTORSIZE,\r\n&retlen, buf) < 0)) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but ECC read failed (err %d)\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index, ret);\r\ncontinue;\r\n}\r\nif (memcmp(buf, "ANAND", 6)) {\r\nprintk(KERN_NOTICE "ANAND header found at 0x%x in mtd%d, but went away on reread!\n",\r\nblock * nftl->EraseSize, nftl->mbd.mtd->index);\r\nprintk(KERN_NOTICE "New data are: %02x %02x %02x %02x %02x %02x\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);\r\ncontinue;\r\n}\r\n#endif\r\nif ( V_6 ) {\r\nif ( memcmp ( V_11 , V_8 , sizeof( struct V_10 ) ) ) {\r\nF_2 ( V_30 L_5 ,\r\nV_2 -> V_22 * V_2 -> V_17 , V_5 * V_2 -> V_17 ) ;\r\nif ( V_6 < 2 ) {\r\nreturn - 1 ;\r\n}\r\ncontinue;\r\n}\r\nif ( V_6 == 1 )\r\nV_2 -> V_24 = V_5 ;\r\nV_2 -> V_31 [ V_5 ] = V_32 ;\r\nV_6 ++ ;\r\ncontinue;\r\n}\r\nmemcpy ( V_11 , V_8 , sizeof( struct V_10 ) ) ;\r\n#if 0\r\nThe new DiskOnChip driver scans the MediaHeader itself, and presents a virtual\r\nerasesize based on UnitSizeFactor. So the erasesize we read from the mtd\r\ndevice is already correct.\r\nif (mh->UnitSizeFactor == 0) {\r\nprintk(KERN_NOTICE "NFTL: UnitSizeFactor 0x00 detected. This violates the spec but we think we know what it means...\n");\r\n} else if (mh->UnitSizeFactor < 0xfc) {\r\nprintk(KERN_NOTICE "Sorry, we don't support UnitSizeFactor 0x%02x\n",\r\nmh->UnitSizeFactor);\r\nreturn -1;\r\n} else if (mh->UnitSizeFactor != 0xff) {\r\nprintk(KERN_NOTICE "WARNING: Support for NFTL with UnitSizeFactor 0x%02x is experimental\n",\r\nmh->UnitSizeFactor);\r\nnftl->EraseSize = nftl->mbd.mtd->erasesize << (0xff - mh->UnitSizeFactor);\r\nnftl->nb_blocks = (u32)nftl->mbd.mtd->size / nftl->EraseSize;\r\n}\r\n#endif\r\nV_2 -> V_33 = F_4 ( V_11 -> V_34 ) ;\r\nif ( ( V_2 -> V_33 + 2 ) >= V_2 -> V_19 ) {\r\nF_2 ( V_30 L_6 ) ;\r\nF_2 ( V_30 L_7 ,\r\nV_2 -> V_33 , V_2 -> V_19 ) ;\r\nreturn - 1 ;\r\n}\r\nV_2 -> V_35 = F_5 ( V_11 -> V_36 ) / V_2 -> V_17 ;\r\nif ( V_2 -> V_35 > ( V_2 -> V_19 - V_2 -> V_33 - 2 ) ) {\r\nF_2 ( V_30 L_6 ) ;\r\nF_2 ( V_30 L_8 ,\r\nV_2 -> V_35 , V_2 -> V_19 , V_2 -> V_33 ) ;\r\nreturn - 1 ;\r\n}\r\nV_2 -> V_15 . V_21 = V_2 -> V_35 * ( V_2 -> V_17 / V_9 ) ;\r\nV_2 -> V_19 = F_4 ( V_11 -> V_37 ) + F_4 ( V_11 -> V_34 ) ;\r\nV_2 -> V_38 = V_2 -> V_19 - 1 ;\r\nV_2 -> V_39 = F_6 ( V_2 -> V_19 * sizeof( V_40 ) , V_41 ) ;\r\nif ( ! V_2 -> V_39 ) {\r\nF_2 ( V_30 L_9 ) ;\r\nreturn - V_42 ;\r\n}\r\nV_2 -> V_31 = F_6 ( V_2 -> V_19 * sizeof( V_40 ) , V_41 ) ;\r\nif ( ! V_2 -> V_31 ) {\r\nF_7 ( V_2 -> V_39 ) ;\r\nF_2 ( V_30 L_10 ) ;\r\nreturn - V_42 ;\r\n}\r\nfor ( V_16 = 0 ; V_16 < V_2 -> V_33 ; V_16 ++ )\r\nV_2 -> V_31 [ V_16 ] = V_32 ;\r\nfor (; V_16 < V_2 -> V_19 ; V_16 ++ ) {\r\nV_2 -> V_31 [ V_16 ] = V_43 ;\r\n}\r\nV_2 -> V_31 [ V_5 ] = V_32 ;\r\nfor ( V_16 = 0 ; V_16 < V_2 -> V_19 ; V_16 ++ ) {\r\n#if 0\r\nThe new DiskOnChip driver already scanned the bad block table. Just query it.\r\nif ((i & (SECTORSIZE - 1)) == 0) {\r\nif ((ret = mtd->read(nftl->mbd.mtd, block * nftl->EraseSize +\r\ni + SECTORSIZE, SECTORSIZE, &retlen,\r\nbuf)) < 0) {\r\nprintk(KERN_NOTICE "Read of bad sector table failed (err %d)\n",\r\nret);\r\nkfree(nftl->ReplUnitTable);\r\nkfree(nftl->EUNtable);\r\nreturn -1;\r\n}\r\n}\r\nif (buf[i & (SECTORSIZE - 1)] != 0xff)\r\nnftl->ReplUnitTable[i] = BLOCK_RESERVED;\r\n#endif\r\nif ( V_2 -> V_15 . V_14 -> V_44 ( V_2 -> V_15 . V_14 , V_16 * V_2 -> V_17 ) )\r\nV_2 -> V_31 [ V_16 ] = V_32 ;\r\n}\r\nV_2 -> V_22 = V_5 ;\r\nV_6 ++ ;\r\n}\r\nreturn V_6 ? 0 : - 1 ;\r\n}\r\nstatic int F_8 ( void * V_45 , int V_46 , int V_47 )\r\n{\r\nint V_16 ;\r\nfor ( V_16 = 0 ; V_16 < V_47 ; V_16 ++ ) {\r\nif ( V_46 != ( ( unsigned char * ) V_45 ) [ V_16 ] )\r\nreturn 1 ;\r\n}\r\nreturn 0 ;\r\n}\r\nstatic int F_9 ( struct V_1 * V_2 , unsigned int V_48 , int V_49 ,\r\nint V_50 )\r\n{\r\nT_2 V_8 [ V_9 + V_2 -> V_15 . V_14 -> V_51 ] ;\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nT_1 V_7 ;\r\nint V_16 ;\r\nfor ( V_16 = 0 ; V_16 < V_49 ; V_16 += V_9 ) {\r\nif ( V_14 -> V_26 ( V_14 , V_48 , V_9 , & V_7 , V_8 ) )\r\nreturn - 1 ;\r\nif ( F_8 ( V_8 , 0xff , V_9 ) != 0 )\r\nreturn - 1 ;\r\nif ( V_50 ) {\r\nif( F_3 ( V_14 , V_48 , V_14 -> V_51 ,\r\n& V_7 , & V_8 [ V_9 ] ) < 0 )\r\nreturn - 1 ;\r\nif ( F_8 ( V_8 + V_9 , 0xff , V_14 -> V_51 ) != 0 )\r\nreturn - 1 ;\r\n}\r\nV_48 += V_9 ;\r\n}\r\nreturn 0 ;\r\n}\r\nint F_10 ( struct V_1 * V_2 , int V_5 )\r\n{\r\nT_1 V_7 ;\r\nunsigned int V_52 , V_53 ;\r\nstruct V_3 V_54 ;\r\nstruct V_55 * V_56 = & V_2 -> V_56 ;\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nif ( F_3 ( V_14 , V_5 * V_2 -> V_17 + V_9 + 8 ,\r\n8 , & V_7 , ( char * ) & V_54 ) < 0 )\r\ngoto V_57;\r\nV_53 = F_4 ( ( V_54 . V_58 | V_54 . V_59 ) ) ;\r\nif ( V_53 != V_60 ) {\r\nV_57:\r\nV_54 . V_58 = F_11 ( V_60 ) ;\r\nV_54 . V_59 = F_11 ( V_60 ) ;\r\nV_54 . V_61 = F_12 ( 0 ) ;\r\n}\r\nmemset ( V_56 , 0 , sizeof( struct V_55 ) ) ;\r\nV_56 -> V_14 = V_2 -> V_15 . V_14 ;\r\nV_56 -> V_62 = V_5 * V_2 -> V_17 ;\r\nV_56 -> V_49 = V_2 -> V_17 ;\r\nV_14 -> V_63 ( V_14 , V_56 ) ;\r\nif ( V_56 -> V_64 == V_65 ) {\r\nF_2 ( L_11 , V_5 ) ;\r\ngoto V_66;\r\n}\r\nV_52 = F_5 ( V_54 . V_61 ) ;\r\nV_52 ++ ;\r\nif ( V_52 == 0 )\r\nV_52 = 1 ;\r\nif ( F_9 ( V_2 , V_56 -> V_62 , V_2 -> V_17 , 1 ) != 0 )\r\ngoto V_66;\r\nV_54 . V_61 = F_5 ( V_52 ) ;\r\nif ( F_13 ( V_14 , V_5 * V_2 -> V_17 + V_9 +\r\n8 , 8 , & V_7 , ( char * ) & V_54 ) < 0 )\r\ngoto V_66;\r\nreturn 0 ;\r\nV_66:\r\nV_2 -> V_15 . V_14 -> V_67 ( V_2 -> V_15 . V_14 , V_56 -> V_62 ) ;\r\nreturn - 1 ;\r\n}\r\nstatic void F_14 ( struct V_1 * V_2 , unsigned int V_68 )\r\n{\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nunsigned int V_5 , V_16 , V_69 ;\r\nstruct V_70 V_71 ;\r\nint V_72 ;\r\nT_1 V_7 ;\r\nV_72 = V_2 -> V_17 / V_9 ;\r\nV_5 = V_68 ;\r\nfor (; ; ) {\r\nfor ( V_16 = 0 ; V_16 < V_72 ; V_16 ++ ) {\r\nif ( F_3 ( V_14 ,\r\nV_5 * V_2 -> V_17 + V_16 * V_9 ,\r\n8 , & V_7 , ( char * ) & V_71 ) < 0 )\r\nV_69 = V_73 ;\r\nelse\r\nV_69 = V_71 . V_74 | V_71 . V_75 ;\r\nswitch( V_69 ) {\r\ncase V_76 :\r\nif ( F_8 ( & V_71 , 0xff , 8 ) != 0 ||\r\nF_9 ( V_2 , V_5 * V_2 -> V_17 + V_16 * V_9 ,\r\nV_9 , 0 ) != 0 ) {\r\nF_2 ( L_12\r\nL_13 ,\r\nV_16 , V_5 ) ;\r\nV_71 . V_74 = V_73 ;\r\nV_71 . V_75 = V_73 ;\r\nF_13 ( V_14 , V_5 *\r\nV_2 -> V_17 +\r\nV_16 * V_9 , 8 ,\r\n& V_7 , ( char * ) & V_71 ) ;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nV_5 = V_2 -> V_31 [ V_5 ] ;\r\nif ( ! ( V_5 == V_23 || V_5 < V_2 -> V_19 ) )\r\nF_2 ( L_14 , V_5 ) ;\r\nif ( V_5 == V_23 || V_5 >= V_2 -> V_19 )\r\nbreak;\r\n}\r\n}\r\nstatic int F_15 ( struct V_1 * V_2 , unsigned int V_68 )\r\n{\r\nunsigned int V_77 = 0 , V_5 = V_68 ;\r\nfor (; ; ) {\r\nV_77 ++ ;\r\nif ( V_77 >= V_2 -> V_19 ) {\r\nF_2 ( L_15 , V_77 ) ;\r\nbreak;\r\n}\r\nV_5 = V_2 -> V_31 [ V_5 ] ;\r\nif ( ! ( V_5 == V_23 || V_5 < V_2 -> V_19 ) )\r\nF_2 ( L_14 , V_5 ) ;\r\nif ( V_5 == V_23 || V_5 >= V_2 -> V_19 )\r\nbreak;\r\n}\r\nreturn V_77 ;\r\n}\r\nstatic void F_16 ( struct V_1 * V_2 , unsigned int V_68 )\r\n{\r\nunsigned int V_5 = V_68 , V_78 ;\r\nF_2 ( L_16 , V_68 ) ;\r\nfor (; ; ) {\r\nV_78 = V_2 -> V_31 [ V_5 ] ;\r\nF_2 ( L_17 , V_5 ) ;\r\nif ( F_10 ( V_2 , V_5 ) < 0 ) {\r\nV_2 -> V_31 [ V_5 ] = V_32 ;\r\n} else {\r\nV_2 -> V_31 [ V_5 ] = V_79 ;\r\n}\r\nV_5 = V_78 ;\r\nif ( ! ( V_5 == V_23 || V_5 < V_2 -> V_19 ) )\r\nF_2 ( L_14 , V_5 ) ;\r\nif ( V_5 == V_23 || V_5 >= V_2 -> V_19 )\r\nbreak;\r\n}\r\n}\r\nstatic int F_17 ( struct V_1 * V_2 , int V_5 )\r\n{\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nstruct V_3 V_4 ;\r\nunsigned int V_53 ;\r\nT_1 V_7 ;\r\nif ( F_3 ( V_14 , V_5 * V_2 -> V_17 + V_9 + 8 , 8 ,\r\n& V_7 , ( char * ) & V_4 ) < 0 )\r\nreturn - 1 ;\r\nV_53 = F_4 ( ( V_4 . V_58 | V_4 . V_59 ) ) ;\r\nif ( V_53 != V_60 ) {\r\nif ( F_9 ( V_2 , V_5 * V_2 -> V_17 , V_2 -> V_17 , 1 ) != 0 )\r\nreturn - 1 ;\r\nV_4 . V_58 = F_11 ( V_60 ) ;\r\nV_4 . V_59 = F_11 ( V_60 ) ;\r\nV_4 . V_61 = F_12 ( 0 ) ;\r\nif ( F_13 ( V_14 ,\r\nV_5 * V_2 -> V_17 + V_9 + 8 , 8 ,\r\n& V_7 , ( char * ) & V_4 ) < 0 )\r\nreturn - 1 ;\r\n} else {\r\n#if 0\r\nfor (i = 0; i < nftl->EraseSize; i += SECTORSIZE) {\r\nif (check_free_sectors (nftl, block * nftl->EraseSize + i,\r\nSECTORSIZE, 0) != 0)\r\nreturn -1;\r\nif (nftl_read_oob(mtd, block * nftl->EraseSize + i,\r\n16, &retlen, buf) < 0)\r\nreturn -1;\r\nif (i == SECTORSIZE) {\r\nif (memcmpb(buf, 0xff, 8))\r\nreturn -1;\r\n} else {\r\nif (memcmpb(buf, 0xff, 16))\r\nreturn -1;\r\n}\r\n}\r\n#endif\r\n}\r\nreturn 0 ;\r\n}\r\nstatic int F_18 ( struct V_1 * V_2 , unsigned int V_5 )\r\n{\r\nstruct V_13 * V_14 = V_2 -> V_15 . V_14 ;\r\nstruct V_80 V_54 ;\r\nT_1 V_7 ;\r\nif ( F_3 ( V_14 , V_5 * V_2 -> V_17 + 2 * V_9 + 8 ,\r\n8 , & V_7 , ( char * ) & V_54 ) < 0 )\r\nreturn 0 ;\r\nreturn F_4 ( ( V_54 . V_81 | V_54 . V_82 ) ) ;\r\n}\r\nint F_19 ( struct V_1 * V_83 )\r\n{\r\nint V_16 ;\r\nunsigned int V_84 , V_85 , V_86 , V_52 , V_53 ;\r\nunsigned int V_5 , V_68 , V_87 ;\r\nint V_88 , V_89 ;\r\nstruct V_90 V_91 ;\r\nstruct V_3 V_4 ;\r\nstruct V_13 * V_14 = V_83 -> V_15 . V_14 ;\r\nT_1 V_7 ;\r\nif ( F_1 ( V_83 ) < 0 ) {\r\nF_2 ( L_18 ) ;\r\nreturn - 1 ;\r\n}\r\nfor ( V_16 = 0 ; V_16 < V_83 -> V_19 ; V_16 ++ ) {\r\nV_83 -> V_39 [ V_16 ] = V_23 ;\r\n}\r\nV_84 = 0 ;\r\nfor ( V_68 = 0 ; V_68 < V_83 -> V_19 ; V_68 ++ ) {\r\nif ( V_83 -> V_31 [ V_68 ] == V_43 ) {\r\nV_5 = V_68 ;\r\nV_88 = 0 ;\r\nV_89 = 0 ;\r\nfor (; ; ) {\r\nif ( F_3 ( V_14 ,\r\nV_5 * V_83 -> V_17 + 8 , 8 ,\r\n& V_7 , ( char * ) & V_91 ) < 0 ||\r\nF_3 ( V_14 ,\r\nV_5 * V_83 -> V_17 +\r\nV_9 + 8 , 8 ,\r\n& V_7 , ( char * ) & V_4 ) < 0 ) {\r\nV_83 -> V_31 [ V_5 ] = V_23 ;\r\nV_89 = 1 ;\r\nbreak;\r\n}\r\nV_85 = F_4 ( ( V_91 . V_92 | V_91 . V_93 ) ) ;\r\nV_86 = F_4 ( ( V_91 . V_94 | V_91 . V_95 ) ) ;\r\nV_52 = F_5 ( V_4 . V_61 ) ;\r\nV_53 = F_4 ( ( V_4 . V_58 | V_4 . V_59 ) ) ;\r\nV_87 = ! ( V_85 >> 15 ) ;\r\nV_85 = V_85 & 0x7fff ;\r\nif ( V_53 != V_60 || V_85 >= V_83 -> V_19 ) {\r\nif ( V_88 == 0 ) {\r\nif ( F_17 ( V_83 , V_5 ) < 0 ) {\r\nF_2 ( L_17 , V_5 ) ;\r\nif ( F_10 ( V_83 , V_5 ) < 0 ) {\r\nV_83 -> V_31 [ V_5 ] = V_32 ;\r\n} else {\r\nV_83 -> V_31 [ V_5 ] = V_79 ;\r\n}\r\n} else {\r\nV_83 -> V_31 [ V_5 ] = V_79 ;\r\n}\r\ngoto V_96;\r\n} else {\r\nF_2 ( L_19 ,\r\nV_5 , V_68 ) ;\r\nV_83 -> V_31 [ V_5 ] = V_23 ;\r\nV_89 = 1 ;\r\nbreak;\r\n}\r\n}\r\nif ( V_88 == 0 ) {\r\nif ( ! V_87 )\r\ngoto V_96;\r\nV_84 = V_85 ;\r\n} else {\r\nif ( V_85 != V_84 ) {\r\nF_2 ( L_20 ,\r\nV_5 , V_85 , V_84 ) ;\r\nV_89 = 1 ;\r\n}\r\nif ( V_87 ) {\r\nif ( F_18 ( V_83 , V_5 ) != V_97 ||\r\nV_86 != 0xffff ) {\r\nF_2 ( L_21 ,\r\nV_5 ) ;\r\nV_89 = 1 ;\r\n} else {\r\nF_2 ( L_22 ,\r\nV_5 ) ;\r\n}\r\n}\r\n}\r\nV_88 ++ ;\r\nif ( V_86 == 0xffff ) {\r\nV_83 -> V_31 [ V_5 ] = V_23 ;\r\nbreak;\r\n} else if ( V_86 >= V_83 -> V_19 ) {\r\nF_2 ( L_23 ,\r\nV_5 , V_86 ) ;\r\nV_89 = 1 ;\r\nV_83 -> V_31 [ V_5 ] = V_23 ;\r\nbreak;\r\n} else if ( V_83 -> V_31 [ V_86 ] != V_43 ) {\r\nif ( V_83 -> V_31 [ V_86 ] == V_23 &&\r\nV_83 -> V_39 [ V_84 ] == V_86 &&\r\nF_18 ( V_83 , V_68 ) == V_97 ) {\r\nF_2 ( L_22 ,\r\nV_86 ) ;\r\nV_83 -> V_31 [ V_5 ] = V_86 ;\r\nV_83 -> V_39 [ V_84 ] = V_23 ;\r\n} else {\r\nF_2 ( L_24 ,\r\nV_5 , V_86 ) ;\r\nV_89 = 1 ;\r\nV_83 -> V_31 [ V_5 ] = V_23 ;\r\n}\r\nbreak;\r\n} else {\r\nV_83 -> V_31 [ V_5 ] = V_86 ;\r\nV_5 = V_86 ;\r\n}\r\n}\r\nif ( V_89 ) {\r\nF_16 ( V_83 , V_68 ) ;\r\n} else {\r\nunsigned int V_98 , V_99 , V_100 ;\r\nint V_101 ;\r\nV_101 = F_18 ( V_83 , V_68 ) ;\r\nif ( V_101 == 0 ) {\r\nF_2 ( L_25 , V_68 ) ;\r\nF_16 ( V_83 , V_68 ) ;\r\n} else {\r\nif ( V_101 == V_97 )\r\nF_14 ( V_83 , V_68 ) ;\r\nV_98 = V_83 -> V_39 [ V_84 ] ;\r\nif ( V_98 != V_23 ) {\r\nV_100 = F_15 ( V_83 , V_98 ) ;\r\nF_2 ( L_26 ,\r\nV_98 , V_100 , V_68 , V_88 ) ;\r\nif ( V_88 >= V_100 ) {\r\nV_99 = V_98 ;\r\nV_83 -> V_39 [ V_84 ] = V_68 ;\r\n} else {\r\nV_99 = V_68 ;\r\n}\r\nF_16 ( V_83 , V_99 ) ;\r\n} else {\r\nV_83 -> V_39 [ V_84 ] = V_68 ;\r\n}\r\n}\r\n}\r\n}\r\nV_96: ;\r\n}\r\nV_83 -> V_102 = 0 ;\r\nV_83 -> V_103 = F_4 ( V_83 -> V_12 . V_34 ) ;\r\nfor ( V_5 = 0 ; V_5 < V_83 -> V_19 ; V_5 ++ ) {\r\nif ( V_83 -> V_31 [ V_5 ] == V_43 ) {\r\nF_2 ( L_27 , V_5 ) ;\r\nif ( F_10 ( V_83 , V_5 ) < 0 )\r\nV_83 -> V_31 [ V_5 ] = V_32 ;\r\nelse\r\nV_83 -> V_31 [ V_5 ] = V_79 ;\r\n}\r\nif ( V_83 -> V_31 [ V_5 ] == V_79 ) {\r\nV_83 -> V_102 ++ ;\r\nV_83 -> V_103 = V_5 ;\r\n}\r\n}\r\nreturn 0 ;\r\n}
