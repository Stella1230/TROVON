static T_1 F_1 ( int V_1 , int V_2 , void * V_3 )\r\n{\r\nswitch ( V_2 ) {\r\ncase 1 : return * ( V_4 * ) ( V_3 + V_1 ) ;\r\ncase 2 : return F_2 ( ( V_5 * ) ( V_3 + V_1 ) ) ;\r\ncase 4 : return F_3 ( ( V_6 * ) ( V_3 + V_1 ) ) ;\r\ncase 8 : return F_4 ( ( V_7 * ) ( V_3 + V_1 ) ) ;\r\ndefault:\r\nF_5 ( L_1 , V_2 * 8 ) ;\r\nreturn 0 ;\r\n}\r\n}\r\nvoid F_6 ( const struct V_8 * V_9 ,\r\nint V_10 ,\r\nvoid * V_3 ,\r\nvoid * V_11 )\r\n{\r\nint V_12 ;\r\nfor ( V_12 = 0 ; V_12 < V_10 ; ++ V_12 ) {\r\nif ( V_9 [ V_12 ] . V_13 <= 32 ) {\r\nint V_14 ;\r\nT_2 V_15 ;\r\nV_6 V_16 ;\r\nV_6 * V_17 ;\r\nV_14 = 32 - V_9 [ V_12 ] . V_18 - V_9 [ V_12 ] . V_13 ;\r\nif ( V_9 [ V_12 ] . V_19 )\r\nV_15 = F_1 ( V_9 [ V_12 ] . V_20 ,\r\nV_9 [ V_12 ] . V_19 ,\r\nV_3 ) << V_14 ;\r\nelse\r\nV_15 = 0 ;\r\nV_16 = F_7 ( ( ( 1ull << V_9 [ V_12 ] . V_13 ) - 1 ) << V_14 ) ;\r\nV_17 = ( V_6 * ) V_11 + V_9 [ V_12 ] . V_21 ;\r\n* V_17 = ( * V_17 & ~ V_16 ) | ( F_7 ( V_15 ) & V_16 ) ;\r\n} else if ( V_9 [ V_12 ] . V_13 <= 64 ) {\r\nint V_14 ;\r\nT_1 V_15 ;\r\nV_7 V_16 ;\r\nV_7 * V_17 ;\r\nV_14 = 64 - V_9 [ V_12 ] . V_18 - V_9 [ V_12 ] . V_13 ;\r\nif ( V_9 [ V_12 ] . V_19 )\r\nV_15 = F_1 ( V_9 [ V_12 ] . V_20 ,\r\nV_9 [ V_12 ] . V_19 ,\r\nV_3 ) << V_14 ;\r\nelse\r\nV_15 = 0 ;\r\nV_16 = F_8 ( ( ~ 0ull >> ( 64 - V_9 [ V_12 ] . V_13 ) ) << V_14 ) ;\r\nV_17 = ( V_7 * ) ( ( V_6 * ) V_11 + V_9 [ V_12 ] . V_21 ) ;\r\n* V_17 = ( * V_17 & ~ V_16 ) | ( F_8 ( V_15 ) & V_16 ) ;\r\n} else {\r\nif ( V_9 [ V_12 ] . V_18 % 8 ||\r\nV_9 [ V_12 ] . V_13 % 8 ) {\r\nF_5 ( L_2 ,\r\nV_9 [ V_12 ] . V_22 , V_9 [ V_12 ] . V_13 ) ;\r\n}\r\nif ( V_9 [ V_12 ] . V_19 )\r\nmemcpy ( V_11 + V_9 [ V_12 ] . V_21 * 4 +\r\nV_9 [ V_12 ] . V_18 / 8 ,\r\nV_3 + V_9 [ V_12 ] . V_20 ,\r\nV_9 [ V_12 ] . V_13 / 8 ) ;\r\nelse\r\nmemset ( V_11 + V_9 [ V_12 ] . V_21 * 4 +\r\nV_9 [ V_12 ] . V_18 / 8 ,\r\n0 ,\r\nV_9 [ V_12 ] . V_13 / 8 ) ;\r\n}\r\n}\r\n}\r\nstatic void F_9 ( int V_1 , int V_2 , T_1 V_15 , void * V_3 )\r\n{\r\nswitch ( V_2 * 8 ) {\r\ncase 8 : * ( V_4 * ) ( V_3 + V_1 ) = V_15 ; break;\r\ncase 16 : * ( V_5 * ) ( V_3 + V_1 ) = F_10 ( V_15 ) ; break;\r\ncase 32 : * ( V_6 * ) ( V_3 + V_1 ) = F_7 ( V_15 ) ; break;\r\ncase 64 : * ( V_7 * ) ( V_3 + V_1 ) = F_8 ( V_15 ) ; break;\r\ndefault:\r\nF_5 ( L_1 , V_2 * 8 ) ;\r\n}\r\n}\r\nvoid F_11 ( const struct V_8 * V_9 ,\r\nint V_10 ,\r\nvoid * V_11 ,\r\nvoid * V_3 )\r\n{\r\nint V_12 ;\r\nfor ( V_12 = 0 ; V_12 < V_10 ; ++ V_12 ) {\r\nif ( ! V_9 [ V_12 ] . V_19 )\r\ncontinue;\r\nif ( V_9 [ V_12 ] . V_13 <= 32 ) {\r\nint V_14 ;\r\nT_2 V_15 ;\r\nT_2 V_16 ;\r\nV_6 * V_17 ;\r\nV_14 = 32 - V_9 [ V_12 ] . V_18 - V_9 [ V_12 ] . V_13 ;\r\nV_16 = ( ( 1ull << V_9 [ V_12 ] . V_13 ) - 1 ) << V_14 ;\r\nV_17 = ( V_6 * ) V_11 + V_9 [ V_12 ] . V_21 ;\r\nV_15 = ( F_3 ( V_17 ) & V_16 ) >> V_14 ;\r\nF_9 ( V_9 [ V_12 ] . V_20 ,\r\nV_9 [ V_12 ] . V_19 ,\r\nV_15 ,\r\nV_3 ) ;\r\n} else if ( V_9 [ V_12 ] . V_13 <= 64 ) {\r\nint V_14 ;\r\nT_1 V_15 ;\r\nT_1 V_16 ;\r\nV_7 * V_17 ;\r\nV_14 = 64 - V_9 [ V_12 ] . V_18 - V_9 [ V_12 ] . V_13 ;\r\nV_16 = ( ~ 0ull >> ( 64 - V_9 [ V_12 ] . V_13 ) ) << V_14 ;\r\nV_17 = ( V_7 * ) V_11 + V_9 [ V_12 ] . V_21 ;\r\nV_15 = ( F_4 ( V_17 ) & V_16 ) >> V_14 ;\r\nF_9 ( V_9 [ V_12 ] . V_20 ,\r\nV_9 [ V_12 ] . V_19 ,\r\nV_15 ,\r\nV_3 ) ;\r\n} else {\r\nif ( V_9 [ V_12 ] . V_18 % 8 ||\r\nV_9 [ V_12 ] . V_13 % 8 ) {\r\nF_5 ( L_2 ,\r\nV_9 [ V_12 ] . V_22 , V_9 [ V_12 ] . V_13 ) ;\r\n}\r\nmemcpy ( V_3 + V_9 [ V_12 ] . V_20 ,\r\nV_11 + V_9 [ V_12 ] . V_21 * 4 +\r\nV_9 [ V_12 ] . V_18 / 8 ,\r\nV_9 [ V_12 ] . V_13 / 8 ) ;\r\n}\r\n}\r\n}
