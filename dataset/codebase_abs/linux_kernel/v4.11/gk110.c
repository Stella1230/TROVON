void\r\nF_1 ( struct V_1 * V_2 , bool V_3 )\r\n{\r\nstruct V_4 * V_5 = V_2 -> V_6 . V_5 ;\r\nstatic const struct {\r\nT_1 V_7 ;\r\nT_1 V_8 ;\r\n} V_9 [] = {\r\n{ 0x020520 , 0xfffffffc } ,\r\n{ 0x020524 , 0xfffffffe } ,\r\n{ 0x020524 , 0xfffffffc } ,\r\n{ 0x020524 , 0xfffffff8 } ,\r\n{ 0x020524 , 0xffffffe0 } ,\r\n{ 0x020530 , 0xfffffffe } ,\r\n{ 0x02052c , 0xfffffffa } ,\r\n{ 0x02052c , 0xfffffff0 } ,\r\n{ 0x02052c , 0xffffffc0 } ,\r\n{ 0x02052c , 0xffffff00 } ,\r\n{ 0x02052c , 0xfffffc00 } ,\r\n{ 0x02052c , 0xfffcfc00 } ,\r\n{ 0x02052c , 0xfff0fc00 } ,\r\n{ 0x02052c , 0xff80fc00 } ,\r\n{ 0x020528 , 0xfffffffe } ,\r\n{ 0x020528 , 0xfffffffc } ,\r\n} ;\r\nint V_10 ;\r\nF_2 ( V_5 , 0x000200 , 0x00001000 , 0x00000000 ) ;\r\nF_3 ( V_5 , 0x000200 ) ;\r\nF_2 ( V_5 , 0x000200 , 0x08000000 , 0x08000000 ) ;\r\nF_4 ( 50 ) ;\r\nF_2 ( V_5 , 0x10a78c , 0x00000002 , 0x00000002 ) ;\r\nF_2 ( V_5 , 0x10a78c , 0x00000001 , 0x00000001 ) ;\r\nF_2 ( V_5 , 0x10a78c , 0x00000001 , 0x00000000 ) ;\r\nF_2 ( V_5 , 0x0206b4 , 0x00000000 , 0x00000000 ) ;\r\nfor ( V_10 = 0 ; V_10 < F_5 ( V_9 ) ; V_10 ++ ) {\r\nF_6 ( V_5 , V_9 [ V_10 ] . V_7 , V_9 [ V_10 ] . V_8 ) ;\r\nF_7 (device, 2000 ,\r\nif (!(nvkm_rd32(device, magic[i].addr) & 0x80000000))\r\nbreak;\r\n) ;\r\n}\r\nF_2 ( V_5 , 0x10a78c , 0x00000002 , 0x00000000 ) ;\r\nF_2 ( V_5 , 0x10a78c , 0x00000001 , 0x00000001 ) ;\r\nF_2 ( V_5 , 0x10a78c , 0x00000001 , 0x00000000 ) ;\r\nF_2 ( V_5 , 0x000200 , 0x08000000 , 0x00000000 ) ;\r\nF_2 ( V_5 , 0x000200 , 0x00001000 , 0x00001000 ) ;\r\nF_3 ( V_5 , 0x000200 ) ;\r\n}\r\nint\r\nF_8 ( struct V_4 * V_5 , int V_11 , struct V_1 * * V_12 )\r\n{\r\nreturn F_9 ( & V_13 , V_5 , V_11 , V_12 ) ;\r\n}
