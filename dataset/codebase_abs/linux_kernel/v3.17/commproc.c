void T_1 F_1 ()\r\n{\r\nV_1 = (struct V_2 * ) ( V_3 ) ;\r\nV_1 -> V_4 = ( V_5 | V_6 ) ;\r\nwhile ( V_1 -> V_4 & V_6 ) ;\r\nV_1 -> V_7 = 0x0740 ;\r\nV_8 = V_9 ;\r\nV_10 = V_8 + V_11 ;\r\n}\r\nvoid\r\nF_2 ( void )\r\n{\r\nV_1 -> V_12 =\r\n( V_13 | V_14 | V_15 | V_16 ) |\r\n( V_17 << 13 ) |\r\nV_18 |\r\n( V_19 << 5 ) |\r\nV_20 ;\r\nV_1 -> V_21 = 0 ;\r\n}\r\nstatic void\r\nF_3 ( int V_22 , void * V_23 , struct V_24 * V_25 )\r\n{\r\n#if 0\r\n((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr = 1;\r\nvec = ((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr;\r\nvec >>= 11;\r\nif (cpm_vecs[vec].handler != 0)\r\n(*cpm_vecs[vec].handler)(cpm_vecs[vec].dev_id);\r\nelse\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cimr &= ~(1 << vec);\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cisr |= (1 << vec);\r\n#endif\r\n}\r\nstatic void\r\nF_4 ( void * V_23 )\r\n{\r\n}\r\nvoid\r\nF_5 ( int V_26 , void (* F_6)() , void * V_27 )\r\n{\r\nF_7 ( V_26 , F_6 , 0 , L_1 , V_27 ) ;\r\n}\r\nvoid\r\nF_8 ( int V_26 )\r\n{\r\nV_28 [ V_26 ] . F_6 = NULL ;\r\nV_28 [ V_26 ] . V_27 = NULL ;\r\nV_1 -> V_21 &= ~ ( 1 << V_26 ) ;\r\n}\r\nT_2\r\nF_9 ( T_2 V_29 )\r\n{\r\nT_2 V_30 ;\r\nif ( ( V_8 + V_29 ) >= V_10 )\r\nreturn ( V_31 ) ;\r\nV_30 = V_8 ;\r\nV_8 += V_29 ;\r\nreturn ( V_30 ) ;\r\n}\r\nvoid\r\nF_10 ( T_2 V_32 , T_2 V_33 )\r\n{\r\nvolatile T_2 * V_34 ;\r\nV_34 = ( volatile T_2 * ) ( & V_1 -> V_35 [ 0 ] . V_36 ) ;\r\nV_34 += V_32 ;\r\n* V_34 = ( ( V_37 / V_33 - 1 ) << 1 ) | V_38 ;\r\n}
