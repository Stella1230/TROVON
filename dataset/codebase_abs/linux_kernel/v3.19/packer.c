static T_1 F_1 ( int V_1 , int V_2 , void * V_3 )\r\n{\r\nswitch ( V_2 ) {\r\ncase 1 : return * ( V_4 * ) ( V_3 + V_1 ) ;\r\ncase 2 : return F_2 ( ( V_5 * ) ( V_3 + V_1 ) ) ;\r\ncase 4 : return F_3 ( ( V_6 * ) ( V_3 + V_1 ) ) ;\r\ncase 8 : return F_4 ( ( V_7 * ) ( V_3 + V_1 ) ) ;\r\ndefault:\r\nF_5 ( V_8 L_1 , V_2 * 8 ) ;\r\nreturn 0 ;\r\n}\r\n}\r\nvoid F_6 ( const struct V_9 * V_10 ,\r\nint V_11 ,\r\nvoid * V_3 ,\r\nvoid * V_12 )\r\n{\r\nint V_13 ;\r\nfor ( V_13 = 0 ; V_13 < V_11 ; ++ V_13 ) {\r\nif ( V_10 [ V_13 ] . V_14 <= 32 ) {\r\nint V_15 ;\r\nT_2 V_16 ;\r\nV_6 V_17 ;\r\nV_6 * V_18 ;\r\nV_15 = 32 - V_10 [ V_13 ] . V_19 - V_10 [ V_13 ] . V_14 ;\r\nif ( V_10 [ V_13 ] . V_20 )\r\nV_16 = F_1 ( V_10 [ V_13 ] . V_21 ,\r\nV_10 [ V_13 ] . V_20 ,\r\nV_3 ) << V_15 ;\r\nelse\r\nV_16 = 0 ;\r\nV_17 = F_7 ( ( ( 1ull << V_10 [ V_13 ] . V_14 ) - 1 ) << V_15 ) ;\r\nV_18 = ( V_6 * ) V_12 + V_10 [ V_13 ] . V_22 ;\r\n* V_18 = ( * V_18 & ~ V_17 ) | ( F_7 ( V_16 ) & V_17 ) ;\r\n} else if ( V_10 [ V_13 ] . V_14 <= 64 ) {\r\nint V_15 ;\r\nT_1 V_16 ;\r\nV_7 V_17 ;\r\nV_7 * V_18 ;\r\nV_15 = 64 - V_10 [ V_13 ] . V_19 - V_10 [ V_13 ] . V_14 ;\r\nif ( V_10 [ V_13 ] . V_20 )\r\nV_16 = F_1 ( V_10 [ V_13 ] . V_21 ,\r\nV_10 [ V_13 ] . V_20 ,\r\nV_3 ) << V_15 ;\r\nelse\r\nV_16 = 0 ;\r\nV_17 = F_8 ( ( ~ 0ull >> ( 64 - V_10 [ V_13 ] . V_14 ) ) << V_15 ) ;\r\nV_18 = ( V_7 * ) ( ( V_6 * ) V_12 + V_10 [ V_13 ] . V_22 ) ;\r\n* V_18 = ( * V_18 & ~ V_17 ) | ( F_8 ( V_16 ) & V_17 ) ;\r\n} else {\r\nif ( V_10 [ V_13 ] . V_19 % 8 ||\r\nV_10 [ V_13 ] . V_14 % 8 ) {\r\nF_5 ( V_8 L_2\r\nL_3 ,\r\nV_10 [ V_13 ] . V_23 , V_10 [ V_13 ] . V_14 ) ;\r\n}\r\nif ( V_10 [ V_13 ] . V_20 )\r\nmemcpy ( V_12 + V_10 [ V_13 ] . V_22 * 4 +\r\nV_10 [ V_13 ] . V_19 / 8 ,\r\nV_3 + V_10 [ V_13 ] . V_21 ,\r\nV_10 [ V_13 ] . V_14 / 8 ) ;\r\nelse\r\nmemset ( V_12 + V_10 [ V_13 ] . V_22 * 4 +\r\nV_10 [ V_13 ] . V_19 / 8 ,\r\n0 ,\r\nV_10 [ V_13 ] . V_14 / 8 ) ;\r\n}\r\n}\r\n}\r\nstatic void F_9 ( int V_1 , int V_2 , T_1 V_16 , void * V_3 )\r\n{\r\nswitch ( V_2 * 8 ) {\r\ncase 8 : * ( V_4 * ) ( V_3 + V_1 ) = V_16 ; break;\r\ncase 16 : * ( V_5 * ) ( V_3 + V_1 ) = F_10 ( V_16 ) ; break;\r\ncase 32 : * ( V_6 * ) ( V_3 + V_1 ) = F_7 ( V_16 ) ; break;\r\ncase 64 : * ( V_7 * ) ( V_3 + V_1 ) = F_8 ( V_16 ) ; break;\r\ndefault:\r\nF_5 ( V_8 L_1 , V_2 * 8 ) ;\r\n}\r\n}\r\nvoid F_11 ( const struct V_9 * V_10 ,\r\nint V_11 ,\r\nvoid * V_12 ,\r\nvoid * V_3 )\r\n{\r\nint V_13 ;\r\nfor ( V_13 = 0 ; V_13 < V_11 ; ++ V_13 ) {\r\nif ( ! V_10 [ V_13 ] . V_20 )\r\ncontinue;\r\nif ( V_10 [ V_13 ] . V_14 <= 32 ) {\r\nint V_15 ;\r\nT_2 V_16 ;\r\nT_2 V_17 ;\r\nV_6 * V_18 ;\r\nV_15 = 32 - V_10 [ V_13 ] . V_19 - V_10 [ V_13 ] . V_14 ;\r\nV_17 = ( ( 1ull << V_10 [ V_13 ] . V_14 ) - 1 ) << V_15 ;\r\nV_18 = ( V_6 * ) V_12 + V_10 [ V_13 ] . V_22 ;\r\nV_16 = ( F_3 ( V_18 ) & V_17 ) >> V_15 ;\r\nF_9 ( V_10 [ V_13 ] . V_21 ,\r\nV_10 [ V_13 ] . V_20 ,\r\nV_16 ,\r\nV_3 ) ;\r\n} else if ( V_10 [ V_13 ] . V_14 <= 64 ) {\r\nint V_15 ;\r\nT_1 V_16 ;\r\nT_1 V_17 ;\r\nV_7 * V_18 ;\r\nV_15 = 64 - V_10 [ V_13 ] . V_19 - V_10 [ V_13 ] . V_14 ;\r\nV_17 = ( ~ 0ull >> ( 64 - V_10 [ V_13 ] . V_14 ) ) << V_15 ;\r\nV_18 = ( V_7 * ) V_12 + V_10 [ V_13 ] . V_22 ;\r\nV_16 = ( F_4 ( V_18 ) & V_17 ) >> V_15 ;\r\nF_9 ( V_10 [ V_13 ] . V_21 ,\r\nV_10 [ V_13 ] . V_20 ,\r\nV_16 ,\r\nV_3 ) ;\r\n} else {\r\nif ( V_10 [ V_13 ] . V_19 % 8 ||\r\nV_10 [ V_13 ] . V_14 % 8 ) {\r\nF_5 ( V_8 L_2\r\nL_3 ,\r\nV_10 [ V_13 ] . V_23 , V_10 [ V_13 ] . V_14 ) ;\r\n}\r\nmemcpy ( V_3 + V_10 [ V_13 ] . V_21 ,\r\nV_12 + V_10 [ V_13 ] . V_22 * 4 +\r\nV_10 [ V_13 ] . V_19 / 8 ,\r\nV_10 [ V_13 ] . V_14 / 8 ) ;\r\n}\r\n}\r\n}
