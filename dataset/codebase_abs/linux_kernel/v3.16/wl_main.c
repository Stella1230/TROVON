int F_1 ( struct V_1 * V_2 )\r\n{\r\nint V_3 = 0 ;\r\nint V_4 = V_5 ;\r\nint V_6 ;\r\nunsigned long V_7 = 0 ;\r\nstruct V_8 * V_9 = F_2 ( V_2 ) ;\r\nmemset ( & ( V_9 -> V_10 ) , 0 , sizeof( V_11 ) ) ;\r\nF_3 ( & ( V_9 -> V_12 ) ) ;\r\nV_9 -> V_13 = V_14 ;\r\nV_9 -> V_15 = V_16 ;\r\nV_9 -> V_2 = V_2 ;\r\nF_4 ( V_17 , L_1 , L_2 , V_18 & 0x0FFFF ) ;\r\nF_4 ( V_17 , L_3 , L_4 ,\r\nV_19 [ 0 ] & 0x0FF , V_19 [ 1 ] & 0x0FF ,\r\nV_19 [ 2 ] & 0x0FF , V_19 [ 3 ] & 0x0FF ) ;\r\nF_4 ( V_17 , V_20 , L_5 , V_21 ) ;\r\nF_4 ( V_17 , V_22 , L_5 , V_23 ) ;\r\nF_4 ( V_17 , V_24 , L_6 , V_25 ) ;\r\nF_4 ( V_17 , V_26 , L_6 , V_27 ) ;\r\nF_4 ( V_17 , V_28 , L_6 , V_29 ) ;\r\nF_4 ( V_17 , V_30 , L_6 , V_31 ) ;\r\nF_4 ( V_17 , V_32 , L_5 , V_33 ) ;\r\nF_4 ( V_17 , V_34 , L_5 , V_35 ) ;\r\nF_4 ( V_17 , V_36 , L_5 , V_37 ) ;\r\nF_4 ( V_17 , V_38 , L_5 , V_39 ) ;\r\nF_4 ( V_17 , V_40 , L_5 , V_41 ) ;\r\nF_4 ( V_17 , V_42 , L_5 , V_43 ) ;\r\nF_4 ( V_17 , V_44 , L_6 , V_45 ) ;\r\nF_4 ( V_17 , V_46 , L_6 , V_47 ) ;\r\nF_4 ( V_17 , V_48 , L_5 , V_49 ) ;\r\nF_4 ( V_17 , V_50 , L_6 , V_51 ) ;\r\nF_4 ( V_17 , V_52 , L_7 , V_53 ) ;\r\n#if 1\r\nF_4 ( V_17 , V_54 , L_6 , V_55 ) ;\r\nF_4 ( V_17 , V_56 , L_5 , V_57 ) ;\r\nF_4 ( V_17 , V_58 , L_5 , V_59 ) ;\r\nF_4 ( V_17 , V_60 , L_5 , V_61 ) ;\r\nF_4 ( V_17 , V_62 , L_5 , V_63 ) ;\r\n#ifdef F_5\r\nF_4 ( V_17 , V_64 , L_6 , V_65 ) ;\r\nF_4 ( V_17 , V_66 , L_6 , V_67 ) ;\r\nF_4 ( V_17 , V_68 , L_6 , V_69 ) ;\r\nF_4 ( V_17 , V_70 , L_6 , V_71 ) ;\r\nF_4 ( V_17 , V_72 , L_6 , V_73 ) ;\r\nF_4 ( V_17 , V_74 , L_6 , V_75 ) ;\r\nF_4 ( V_17 , V_76 , L_6 , V_77 ) ;\r\nF_4 ( V_17 , V_78 , L_6 , V_79 ) ;\r\nF_4 ( V_17 , V_80 , L_6 , V_81 ) ;\r\nF_4 ( V_17 , V_82 , L_6 , V_83 ) ;\r\nF_4 ( V_17 , V_84 , L_6 , V_85 ) ;\r\nF_4 ( V_17 , V_86 , L_6 , V_87 ) ;\r\nF_4 ( V_17 , V_88 , L_8 ,\r\nV_89 ) ;\r\nF_4 ( V_17 , V_90 , L_8 ,\r\nV_91 ) ;\r\nF_4 ( V_17 , V_92 , L_8 ,\r\nV_93 ) ;\r\nF_4 ( V_17 , V_94 , L_8 ,\r\nV_95 ) ;\r\nF_4 ( V_17 , V_96 , L_8 ,\r\nV_97 ) ;\r\nF_4 ( V_17 , V_98 , L_8 ,\r\nV_99 ) ;\r\n#endif\r\n#endif\r\nF_6 ( ! V_21 || ( strlen ( V_21 ) <= V_100 ) ) ;\r\nF_6 ( ! V_23 || ( strlen ( V_23 ) <= V_100 ) ) ;\r\nF_6 ( ( V_25 <= V_101 ) ) ;\r\nF_6 ( ( V_27 >= V_102 ) && ( V_27 <= V_103 ) ) ;\r\nF_6 ( ( V_29 >= V_104 ) && ( V_29 <= V_105 ) ) ;\r\nF_6 ( ( V_31 <= V_106 ) ) ;\r\nF_6 ( ! V_33 || strchr ( L_9 , V_33 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_35 || ( strlen ( V_34 ) <= V_100 ) ) ;\r\nF_6 ( ( V_107 <= V_108 ) ) ;\r\nF_6 ( F_7 ( V_37 ) ) ;\r\nF_6 ( F_7 ( V_39 ) ) ;\r\nF_6 ( F_7 ( V_41 ) ) ;\r\nF_6 ( F_7 ( V_43 ) ) ;\r\nF_6 ( ( V_45 >= V_109 ) && ( V_45 <= V_110 ) ) ;\r\nF_6 ( ( V_47 >= V_111 ) &&\r\n( V_47 <= V_112 ) ) ;\r\nF_6 ( ! V_49 || ( strlen ( V_49 ) <= 255 ) ) ;\r\nF_6 ( ( V_51 < V_113 ) ) ;\r\nF_6 ( ! V_114 || strchr ( L_9 , V_114 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_115 || strchr ( L_9 , V_115 [ 0 ] ) != NULL ) ;\r\nF_6 ( ( V_116 <= V_117 ) ) ;\r\nF_6 ( ( V_118 >= V_119 ) && ( V_118 <= V_120 ) ) ;\r\nF_6 ( V_53 <= V_121 ||\r\n( V_53 & 0x7FFF ) <= V_121 ) ;\r\nF_6 ( ! V_122 || strchr ( L_9 , V_122 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_123 || strchr ( L_9 , V_123 [ 0 ] ) != NULL ) ;\r\nF_6 ( ( V_124 <= V_125 ) ) ;\r\nF_6 ( ( V_126 <= V_127 ) ) ;\r\nF_6 ( ( V_128 <= V_129 ) ) ;\r\nF_6 ( ( V_130 <= V_131 ) ) ;\r\nF_6 ( ! V_132 || strchr ( L_9 , V_132 [ 0 ] ) != NULL ) ;\r\nF_6 ( ( V_133 <= V_134 ) ) ;\r\nF_6 ( ( V_55 >= V_135 ) ) ;\r\nF_6 ( ! V_57 || strchr ( L_9 , V_57 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_59 || strchr ( L_9 , V_59 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_61 || strchr ( L_9 , V_61 [ 0 ] ) != NULL ) ;\r\nF_6 ( ! V_63 || strchr ( L_9 , V_63 [ 0 ] ) != NULL ) ;\r\n#ifdef F_5\r\nF_6 ( ( V_65 <= V_106 ) ) ;\r\nF_6 ( ( V_67 <= V_106 ) ) ;\r\nF_6 ( ( V_69 <= V_106 ) ) ;\r\nF_6 ( ( V_71 <= V_106 ) ) ;\r\nF_6 ( ( V_73 <= V_106 ) ) ;\r\nF_6 ( ( V_75 <= V_106 ) ) ;\r\nF_6 ( ( V_77 >= V_104 ) && ( V_77 <= V_105 ) ) ;\r\nF_6 ( ( V_79 >= V_104 ) && ( V_79 <= V_105 ) ) ;\r\nF_6 ( ( V_81 >= V_104 ) && ( V_81 <= V_105 ) ) ;\r\nF_6 ( ( V_83 >= V_104 ) && ( V_83 <= V_105 ) ) ;\r\nF_6 ( ( V_85 >= V_104 ) && ( V_85 <= V_105 ) ) ;\r\nF_6 ( ( V_87 >= V_104 ) && ( V_87 <= V_105 ) ) ;\r\n#endif\r\nF_6 ( ( V_136 >= V_137 ) && ( V_136 <= V_138 ) ) ;\r\nF_6 ( ( V_139 <= V_139 ) ) ;\r\nV_9 -> V_140 = V_25 ;\r\nV_9 -> V_141 = V_27 ;\r\nV_9 -> V_142 [ 0 ] = V_143 ;\r\nV_9 -> V_142 [ 1 ] = V_144 ;\r\nV_9 -> V_145 = V_31 ;\r\nV_9 -> V_146 [ 0 ] = V_147 ;\r\nV_9 -> V_146 [ 1 ] = V_148 ;\r\nif ( strchr ( L_10 , V_33 [ 0 ] ) != NULL )\r\nV_9 -> V_149 = 1 ;\r\nelse\r\nV_9 -> V_149 = 0 ;\r\nif ( V_21 && ( strlen ( V_21 ) <= V_150 ) )\r\nstrcpy ( V_9 -> V_151 , V_21 ) ;\r\nif ( V_23 && ( strlen ( V_23 ) <= V_150 ) )\r\nstrcpy ( V_9 -> V_151 , V_23 ) ;\r\nif ( V_35 && ( strlen ( V_35 ) <= V_150 ) )\r\nstrcpy ( V_9 -> V_152 , V_35 ) ;\r\nV_9 -> V_153 = V_107 ;\r\nif ( V_37 && ( strlen ( V_37 ) <= V_154 ) )\r\nstrcpy ( V_9 -> V_155 , V_37 ) ;\r\nif ( V_39 && ( strlen ( V_39 ) <= V_154 ) )\r\nstrcpy ( V_9 -> V_156 , V_39 ) ;\r\nif ( V_41 && ( strlen ( V_41 ) <= V_154 ) )\r\nstrcpy ( V_9 -> V_157 , V_41 ) ;\r\nif ( V_43 && ( strlen ( V_43 ) <= V_154 ) )\r\nstrcpy ( V_9 -> V_158 , V_43 ) ;\r\nV_9 -> V_159 = V_45 ;\r\nF_8 ( V_9 -> V_155 , & ( V_9 -> V_160 . V_161 [ 0 ] ) ) ;\r\nF_8 ( V_9 -> V_156 , & ( V_9 -> V_160 . V_161 [ 1 ] ) ) ;\r\nF_8 ( V_9 -> V_157 , & ( V_9 -> V_160 . V_161 [ 2 ] ) ) ;\r\nF_8 ( V_9 -> V_158 , & ( V_9 -> V_160 . V_161 [ 3 ] ) ) ;\r\nV_9 -> V_162 = 1 ;\r\nV_9 -> V_163 = V_51 ;\r\nif ( strchr ( L_10 , V_114 [ 0 ] ) != NULL )\r\nV_9 -> V_164 = 1 ;\r\nelse\r\nV_9 -> V_164 = 0 ;\r\nif ( strchr ( L_10 , V_115 [ 0 ] ) != NULL )\r\nV_9 -> V_165 = 1 ;\r\nelse\r\nV_9 -> V_165 = 0 ;\r\nV_9 -> V_166 = V_116 ;\r\nV_9 -> V_167 [ 0 ] = V_168 ;\r\nV_9 -> V_167 [ 1 ] = V_169 ;\r\nV_9 -> V_170 [ 0 ] = V_171 ;\r\nV_9 -> V_170 [ 1 ] = V_172 ;\r\n#if 1\r\nV_9 -> V_173 = V_118 ;\r\nV_9 -> V_174 = V_124 ;\r\nV_9 -> V_175 = V_126 ;\r\nV_9 -> V_176 = V_128 ;\r\nV_9 -> V_177 = V_130 ;\r\nV_9 -> V_178 = V_53 ;\r\nif ( strchr ( L_10 , V_122 [ 0 ] ) != NULL )\r\nV_9 -> V_179 = 1 ;\r\nelse\r\nV_9 -> V_179 = 0 ;\r\nif ( strchr ( L_11 , V_123 [ 0 ] ) != NULL )\r\nV_9 -> V_180 = 0 ;\r\nelse\r\nV_9 -> V_180 = 1 ;\r\nif ( strchr ( L_10 , V_132 [ 0 ] ) != NULL )\r\nV_9 -> V_181 = 1 ;\r\nelse\r\nV_9 -> V_181 = 0 ;\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ )\r\nV_9 -> V_183 [ V_6 ] = V_184 [ V_6 ] ;\r\nV_9 -> V_185 = V_133 ;\r\n#endif\r\n#if 1\r\nV_9 -> V_186 = V_55 ;\r\nif ( strchr ( L_10 , V_57 [ 0 ] ) != NULL )\r\nV_9 -> V_187 = 1 ;\r\nelse\r\nV_9 -> V_187 = 0 ;\r\nif ( strchr ( L_11 , V_59 [ 0 ] ) != NULL )\r\nV_9 -> V_188 = 0 ;\r\nelse\r\nV_9 -> V_188 = 1 ;\r\nif ( strchr ( L_10 , V_61 [ 0 ] ) != NULL )\r\nV_9 -> V_189 = 1 ;\r\nelse\r\nV_9 -> V_189 = 0 ;\r\nif ( strchr ( L_10 , V_63 [ 0 ] ) != NULL )\r\nV_9 -> V_190 = 1 ;\r\nelse\r\nV_9 -> V_190 = 0 ;\r\nV_9 -> V_191 = V_136 ;\r\nV_9 -> V_192 = V_139 ;\r\n#ifdef F_5\r\nV_9 -> V_193 [ 0 ] . V_194 = V_65 ;\r\nV_9 -> V_193 [ 1 ] . V_194 = V_67 ;\r\nV_9 -> V_193 [ 2 ] . V_194 = V_69 ;\r\nV_9 -> V_193 [ 3 ] . V_194 = V_71 ;\r\nV_9 -> V_193 [ 4 ] . V_194 = V_73 ;\r\nV_9 -> V_193 [ 5 ] . V_194 = V_75 ;\r\nV_9 -> V_193 [ 0 ] . V_195 = V_77 ;\r\nV_9 -> V_193 [ 1 ] . V_195 = V_79 ;\r\nV_9 -> V_193 [ 2 ] . V_195 = V_81 ;\r\nV_9 -> V_193 [ 3 ] . V_195 = V_83 ;\r\nV_9 -> V_193 [ 4 ] . V_195 = V_85 ;\r\nV_9 -> V_193 [ 5 ] . V_195 = V_87 ;\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 0 ] . V_196 [ V_6 ] = V_89 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 1 ] . V_196 [ V_6 ] = V_91 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 2 ] . V_196 [ V_6 ] = V_93 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 3 ] . V_196 [ V_6 ] = V_95 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 4 ] . V_196 [ V_6 ] = V_97 [ V_6 ] ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_182 ; V_6 ++ ) {\r\nV_9 -> V_193 [ 5 ] . V_196 [ V_6 ] = V_99 [ V_6 ] ;\r\n}\r\n#endif\r\n#endif\r\n#ifdef F_9\r\nif ( strchr ( L_10 , V_197 [ 0 ] ) != NULL )\r\nV_9 -> V_197 = 1 ;\r\nelse\r\nV_9 -> V_197 = 0 ;\r\n#endif\r\nF_10 ( V_9 , & V_7 ) ;\r\nV_9 -> V_198 = V_199 ;\r\nmemset ( & ( V_9 -> V_200 ) , 0 , sizeof( V_9 -> V_200 ) ) ;\r\nV_9 -> V_200 . V_201 = FALSE ;\r\nmemset ( & ( V_9 -> V_202 ) , 0 , sizeof( V_9 -> V_202 ) ) ;\r\nV_9 -> V_202 . V_201 = FALSE ;\r\nV_9 -> V_203 = 0 ;\r\nmemset ( V_9 -> V_204 , 0 , sizeof( V_9 -> V_204 ) ) ;\r\nF_11 ( & ( V_9 -> V_205 ) ) ;\r\nV_9 -> V_206 . V_207 = NULL ;\r\nV_9 -> V_206 . V_208 = 0 ;\r\nfor( V_6 = 0 ; V_6 < V_209 ; V_6 ++ ) {\r\nF_12 ( & ( V_9 -> V_204 [ V_6 ] . V_210 ) , & ( V_9 -> V_205 ) ) ;\r\n}\r\nfor( V_6 = 0 ; V_6 < V_211 ; V_6 ++ ) {\r\nF_11 ( & ( V_9 -> V_212 [ V_6 ] ) ) ;\r\n}\r\nV_9 -> V_213 = TRUE ;\r\nV_9 -> V_214 = 0 ;\r\n#ifdef F_13\r\n#ifdef F_14\r\nF_15 ( V_17 , L_12 ) ;\r\nV_9 -> V_215 = 1 ;\r\n#else\r\nF_15 ( V_17 , L_13 ) ;\r\nV_9 -> V_215 = 0 ;\r\n#endif\r\n#endif\r\nF_16 ( & V_9 -> V_216 , V_217 , ( unsigned long ) V_9 ) ;\r\nF_15 ( V_17 , L_14 ) ;\r\nV_4 = F_17 ( & V_9 -> V_10 , V_2 -> V_218 ) ;\r\nif ( V_4 != V_5 && V_4 != V_219 ) {\r\nF_18 ( V_17 , L_15 , V_4 ) ;\r\nF_19 ( V_9 , & V_7 ) ;\r\ngoto V_220;\r\n}\r\nV_9 -> V_221 . V_222 = V_2 -> V_218 ;\r\nV_9 -> V_221 . V_223 = V_224 ;\r\nV_9 -> V_221 . V_225 = V_2 -> V_226 ;\r\nV_9 -> V_221 . V_227 = V_9 -> V_10 . V_228 ;\r\nV_9 -> V_229 . V_230 = ( sizeof( V_9 -> V_229 ) / sizeof( V_231 ) ) - 1 ;\r\nV_9 -> V_229 . V_232 = V_233 ;\r\nV_9 -> V_229 . V_234 = V_235 ;\r\nV_9 -> V_229 . V_236 = V_237 ;\r\nV_9 -> V_229 . V_238 = V_239 ;\r\nV_9 -> V_229 . V_240 = V_241 ;\r\nF_15 ( V_17 , L_16 ) ;\r\nV_4 = F_20 ( V_9 ) ;\r\nif ( V_4 != V_5 ) {\r\nF_18 ( V_17 , L_17 ) ;\r\nF_19 ( V_9 , & V_7 ) ;\r\ngoto V_220;\r\n}\r\nF_21 ( V_9 ) ;\r\n#if 0\r\nif ( wl_adapter_is_open( lp->dev )) {\r\nDBG_TRACE( DbgInfo, "Enabling Port 0\n" );\r\nhcf_status = wl_enable( lp );\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, "Enable port 0 failed: 0x%x\n", hcf_status );\r\n}\r\n#if ( V_242 ) & V_243\r\nDBG_TRACE( DbgInfo, "Enabling WDS Ports\n" );\r\n#endif\r\n}\r\n#endif\r\nmemcpy ( V_9 -> V_2 -> V_244 , V_9 -> V_183 , V_182 ) ;\r\nV_2 -> V_245 = V_182 ;\r\nV_9 -> V_246 = TRUE ;\r\n#ifdef F_22\r\nF_23 ( V_2 ) ;\r\n#endif\r\nF_24 ( V_9 ) ;\r\nV_9 -> V_162 = V_247 ;\r\n#ifdef F_9\r\nif ( V_9 -> V_197 == 1 ) {\r\nF_15 ( V_17 , L_18 ) ;\r\nF_25 ( V_9 ) ;\r\nV_9 -> V_13 = V_14 ;\r\nF_26 ( V_9 ) ;\r\nF_17 ( & V_9 -> V_10 , V_248 ) ;\r\n}\r\n#endif\r\nF_19 ( V_9 , & V_7 ) ;\r\nF_15 ( DbgInfo, L_19mac_address L_20%02X%cL_21wlagsL_22driver/wlags49L_23wl_insert() FAILED\nL_24devL_25%s (0x%p)L_26dev->base_addrL_25(%#03lx)L_27Device Base Address: %#03lx\nL_28hcf_connect() failed, status: 0x%x\nL_29wl_go() failed, status: 0x%x\nL_30Device Base Address INVALID!!!\nL_31Disable port 0 failed: 0x%x\nL_32Disable port 0 succes : %d retries\nL_33Disable port 0 failed after: %d retries\nL_34Disabling WDS Ports\nL_35F/W image:%s:\nL_36No image file found\nL_37F/W image file found\nL_38error in vmalloc\nL_39buffer too small, %d\nL_40read O.K.: %d bytes %.12s\nL_41no more to read\nL_42file not read in one swoop or other errorL_43 , give up, too complicated, rc = %0X\nL_44still have to change code to get a real download now !!!!!!!!\nL_45before dhf_download_binary\nL_46after dhf_download_binary, before dhf_download_fw\nL_47after dhf_download_fw\nL_48Downloading STA firmware...\nL_49Firmware Download failed\nL_50downloaded station F/W\nL_51downloaded AP F/W\nL_52unknown F/W type\nL_53ComponentID:%04x variant:%04x major:%04x minor:%04x\nL_54Could not retrieve MAC address\nL_55Card MAC Address: %pM\nL_56lpL_25%s (0x%p)L_57Key 1 len: %d\nL_58Key 2 len: %d\nL_59Key 3 len: %d\nL_60Key 4 len: %d\nL_61encrypt: %d, ID: %d\nL_62set key: %s(%d) [%d]\nL_63lpL_25%s (0x%p)L_64Disconnect failed\nL_65Disable failed\nL_66wl_put_ltv() failed\nL_67lp pointer is NULL\nL_68CFG_CNTL_OPT : 0x%04x\nL_69CFG_CNTL_OPT result : 0x%04x\nL_70CFG_REG_INFO_LOG\nL_71CFG_REG_INFO_LOG result : 0x%04x\nL_72lp pointer is NULL\nL_73Create IBSSL_74CFG_CNF_OWN_NAME : %s\nL_75CFG_CNF_OWN_NAME : EMPTY\nL_76CFG_CNF_OWN_NAME result : 0x%04x\nL_77CFG_TX_RATE_CNTL 2.4GHz : 0x%04x\nL_78CFG_TX_RATE_CNTL 5.0GHz : 0x%04x\nL_79CFG_TX_RATE_CNTL result : 0x%04x\nL_80CFG_CNF_PM_ENABLED : 0x%04x\nL_81ANYL_82anyL_83CFG_DESIRED_SSID : %s\nL_84CFG_DESIRED_SSID : ANY\nL_85CFG_DESIRED_SSID result : 0x%04x\nL_86CFG_PROBE_DATA_RATE 2.4GHz : 0x%04x\nL_87CFG_PROBE_DATA_RATE 5.0GHz : 0x%04x\nL_88CFG_PROBE_DATA_RATE result : 0x%04x\nL_89MAC Address : %pM\nL_90CFG_NIC_MAC_ADDR\nL_91CFG_CNF_OWN_MAC_ADDR\nL_92CFG_XXX_MAC_ADDR result : 0x%04x\nL_93ANYL_94anyL_95CFG_CNF_OWN_SSID : %s\nL_96CFG_CNF_OWN_SSID : ANY\nL_97CFG_CNF_OWN_SSID result : 0x%04x\nL_98standardL_99%s\nL_100*** Modified for kernel 2.6 by Henk de Groot <pe1dnn@amsat.org>\nL_101*** Based on 7.18 version by Andrey Borzenkov <arvidjaar@mail.ru> $Revision: 39 $\nL_102Access Point Mode (AP) Support: YES\nL_103Access Point Mode (AP) Support: NO\nL_104wlagsL_105EXITING ISR, IN RTS MODE...\nL_106NOT OUR INTERRUPT\nL_107wl_isr_handler lp adapter pointer is NULL!!!\nL_108devL_25%s (0x%p)L_109devL_25%s (0x%p)L_110devL_25%s (0x%p)L_111devL_25%s (0x%p)L_112Calling unregister_netdev(), as it wasn't called yet\n" );\r\nwl_remove( dev );\r\nlp->is_registered = FALSE;\r\n}\r\n} // wl_release\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_mask()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_mask module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_mask module parameter\r\n*\r\n******************************************************************************/\r\np_u16 wl_get_irq_mask( void )\r\n{\r\nreturn irq_mask;\r\n} // wl_get_irq_mask\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_get_irq_list()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Accessor function to retrieve the irq_list module parameter\r\n*\r\n* PARAMETERS:\r\n*\r\n* N/A\r\n*\r\n* RETURNS:\r\n*\r\n* The irq_list module parameter\r\n*\r\n******************************************************************************/\r\np_s8 * wl_get_irq_list( void )\r\n{\r\nreturn irq_list;\r\n} // wl_get_irq_list\r\n/*============================================================================*/\r\n/*******************************************************************************\r\n* wl_enable()\r\n*******************************************************************************\r\n*\r\n* DESCRIPTION:\r\n*\r\n* Used to enable MAC ports\r\n*\r\n* PARAMETERS:\r\n*\r\n* lp - pointer to the device's private adapter structure\r\n*\r\n* RETURNS:\r\n*\r\n* N/A\r\n*\r\n******************************************************************************/\r\nint wl_enable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nif ( lp->portState == WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, L_113 );\r\n} else if ( lp->portState == WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, L_114 );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_ENABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n#ifdef F_14\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_supply( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, L_115, hcf_status );\r\n}\r\nreturn hcf_status;\r\n}\r\n#ifdef F_5\r\nvoid wl_enable_wds_ports( struct wl_private * lp )\r\n{\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, L_116 );\r\n}\r\n}\r\n#endif\r\nint wl_connect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nif ( lp->portState != WVLAN_PORT_STATE_ENABLED ) {\r\nDBG_TRACE( DbgInfo, L_117 );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_CONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_CONNECTED;\r\n}\r\nreturn hcf_status;\r\n}\r\nint wl_disconnect( struct wl_private *lp )\r\n{\r\nint hcf_status;\r\nif ( lp->portState != WVLAN_PORT_STATE_CONNECTED ) {\r\nDBG_TRACE( DbgInfo, L_118 );\r\nreturn HCF_SUCCESS;\r\n}\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISCONNECT );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_ENABLED;\r\n}\r\nreturn hcf_status;\r\n}\r\nint wl_disable( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nif ( lp->portState == WVLAN_PORT_STATE_DISABLED ) {\r\nDBG_TRACE( DbgInfo, L_119 );\r\n} else {\r\nhcf_status = hcf_cntl( &lp->hcfCtx, HCF_CNTL_DISABLE );\r\nif ( hcf_status == HCF_SUCCESS ) {\r\nlp->portState = WVLAN_PORT_STATE_DISABLED;\r\n#ifdef F_14\r\nif ( lp->use_dma ) {\r\nwl_pci_dma_hcf_reclaim( lp );\r\n}\r\n#endif\r\n}\r\n}\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_TRACE( DbgInfo, L_115, hcf_status );\r\n}\r\nreturn hcf_status;\r\n}\r\n#ifdef F_5\r\nvoid wl_disable_wds_ports( struct wl_private * lp )\r\n{\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ){\r\nDBG_ERROR( DbgInfo, L_116 );\r\n}\r\nreturn;\r\n}\r\n#endif\r\n#ifndef F_27\r\nint wl_mbx( struct wl_private *lp )\r\n{\r\nint hcf_status = HCF_SUCCESS;\r\nDBG_TRACE( DbgInfo, L_120,\r\nlp->hcfCtx.IFB_MBInfoLen );\r\nmemset( &( lp->ltvRecord ), 0, sizeof( ltv_t ));\r\nlp->ltvRecord.len = MB_SIZE;\r\nlp->ltvRecord.typ = CFG_MB_INFO;\r\nhcf_status = hcf_get_info( &lp->hcfCtx, (LTVP)&( lp->ltvRecord ));\r\nif ( hcf_status != HCF_SUCCESS ) {\r\nDBG_ERROR( DbgInfo, L_121, hcf_status );\r\nreturn hcf_status;\r\n}\r\nif ( lp->ltvRecord.typ == CFG_MB_INFO )\r\nreturn hcf_status;\r\nwl_endian_translate_mailbox( &( lp->ltvRecord ));\r\nwl_process_mailbox( lp );\r\nreturn hcf_status;\r\n}\r\nvoid wl_endian_translate_mailbox( ltv_t *ltv )\r\n{\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nbreak;\r\ncase CFG_SCAN:\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\naps[num_aps].channel_id =\r\nCNV_LITTLE_TO_INT( aps[num_aps].channel_id );\r\naps[num_aps].noise_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].noise_level );\r\naps[num_aps].signal_level =\r\nCNV_LITTLE_TO_INT( aps[num_aps].signal_level );\r\naps[num_aps].beacon_interval_time =\r\nCNV_LITTLE_TO_INT( aps[num_aps].beacon_interval_time );\r\naps[num_aps].capability =\r\nCNV_LITTLE_TO_INT( aps[num_aps].capability );\r\naps[num_aps].ssid_len =\r\nCNV_LITTLE_TO_INT( aps[num_aps].ssid_len );\r\naps[num_aps].ssid_val[aps[num_aps].ssid_len] = 0;\r\n}\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\n{\r\nPROBE_RESP *probe_resp = (PROBE_RESP *)ltv;\r\nprobe_resp->frameControl = CNV_LITTLE_TO_INT( probe_resp->frameControl );\r\nprobe_resp->durID = CNV_LITTLE_TO_INT( probe_resp->durID );\r\nprobe_resp->sequence = CNV_LITTLE_TO_INT( probe_resp->sequence );\r\nprobe_resp->dataLength = CNV_LITTLE_TO_INT( probe_resp->dataLength );\r\n#ifndef F_13\r\nprobe_resp->lenType = CNV_LITTLE_TO_INT( probe_resp->lenType );\r\n#endif\r\nprobe_resp->beaconInterval = CNV_LITTLE_TO_INT( probe_resp->beaconInterval );\r\nprobe_resp->capability = CNV_LITTLE_TO_INT( probe_resp->capability );\r\nprobe_resp->flags = CNV_LITTLE_TO_INT( probe_resp->flags );\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define F_28 ((LINK_STATUS_STRCT *)ltv)\r\nls->linkStatus = CNV_LITTLE_TO_INT( ls->linkStatus );\r\nbreak;\r\n#undef F_28\r\ncase CFG_ASSOC_STAT:\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nas->assocStatus = CNV_LITTLE_TO_INT( as->assocStatus );\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nss->securityStatus = CNV_LITTLE_TO_INT( ss->securityStatus );\r\nss->reason = CNV_LITTLE_TO_INT( ss->reason );\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nbreak;\r\ncase CFG_NULL:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid wl_process_mailbox( struct wl_private *lp )\r\n{\r\nltv_t *ltv;\r\nhcf_16 ltv_val = 0xFFFF;\r\nltv = &( lp->ltvRecord );\r\nswitch( ltv->typ ) {\r\ncase CFG_TALLIES:\r\nDBG_TRACE( DbgInfo, L_122 );\r\nbreak;\r\ncase CFG_SCAN:\r\nDBG_TRACE( DbgInfo, L_123 );\r\n{\r\nint num_aps;\r\nSCAN_RS_STRCT *aps = (SCAN_RS_STRCT *)&ltv->u.u8[0];\r\nnum_aps = (hcf_16)(( (size_t)(ltv->len - 1 ) * 2 ) /\r\n( sizeof( SCAN_RS_STRCT )));\r\nlp->scan_results.num_aps = num_aps;\r\nDBG_TRACE( DbgInfo, L_124, num_aps );\r\nwhile( num_aps >= 1 ) {\r\nnum_aps--;\r\nDBG_TRACE( DbgInfo, L_125, num_aps );\r\nDBG_TRACE( DbgInfo, L_126 );\r\nDBG_TRACE( DbgInfo, L_127,\r\naps[num_aps].channel_id );\r\nDBG_TRACE( DbgInfo, L_128,\r\naps[num_aps].noise_level );\r\nDBG_TRACE( DbgInfo, L_129,\r\naps[num_aps].signal_level );\r\nDBG_TRACE( DbgInfo, L_130,\r\naps[num_aps].beacon_interval_time );\r\nDBG_TRACE( DbgInfo, L_131,\r\naps[num_aps].capability );\r\nDBG_TRACE( DbgInfo, L_132,\r\naps[num_aps].ssid_len );\r\nDBG_TRACE(DbgInfo, L_133,\r\naps[num_aps].bssid);\r\nif ( aps[num_aps].ssid_len != 0 ) {\r\nDBG_TRACE( DbgInfo, L_134,\r\naps[num_aps].ssid_val );\r\n} else {\r\nDBG_TRACE( DbgInfo, L_134, L_135 );\r\n}\r\nDBG_TRACE( DbgInfo, L_136 );\r\nmemcpy( &( lp->scan_results.APTable[num_aps]), &( aps[num_aps] ),\r\nsizeof( SCAN_RS_STRCT ));\r\n}\r\nlp->scan_results.scan_complete = TRUE;\r\n}\r\nbreak;\r\ncase CFG_ACS_SCAN:\r\nDBG_TRACE( DbgInfo, L_137 );\r\n{\r\nPROBE_RESP *probe_rsp = (PROBE_RESP *)ltv;\r\nhcf_8 *wpa_ie = NULL;\r\nhcf_16 wpa_ie_len = 0;\r\nDBG_TRACE( DbgInfo, L_138,\r\nlp->dev->name );\r\nDBG_TRACE( DbgInfo, L_139,\r\nlp->dev->name, probe_rsp->length );\r\nif ( probe_rsp->length > 1 ) {\r\nDBG_TRACE( DbgInfo, L_140,\r\nlp->dev->name, probe_rsp->infoType );\r\nDBG_TRACE( DbgInfo, L_141,\r\nlp->dev->name, probe_rsp->signal );\r\nDBG_TRACE( DbgInfo, L_142,\r\nlp->dev->name, probe_rsp->silence );\r\nDBG_TRACE( DbgInfo, L_143,\r\nlp->dev->name, probe_rsp->rxFlow );\r\nDBG_TRACE( DbgInfo, L_144,\r\nlp->dev->name, probe_rsp->rate );\r\nDBG_TRACE( DbgInfo, L_145,\r\nlp->dev->name, probe_rsp->frameControl );\r\nDBG_TRACE( DbgInfo, L_146,\r\nlp->dev->name, probe_rsp->durID );\r\nDBG_TRACE(DbgInfo, L_147,\r\nlp->dev->name, probe_rsp->address1);\r\nDBG_TRACE(DbgInfo, L_148,\r\nlp->dev->name, probe_rsp->address2);\r\nDBG_TRACE(DbgInfo, L_149,\r\nlp->dev->name, probe_rsp->BSSID);\r\nDBG_TRACE( DbgInfo, L_150,\r\nlp->dev->name, probe_rsp->sequence );\r\nDBG_TRACE(DbgInfo, L_151,\r\nlp->dev->name, probe_rsp->address4);\r\nDBG_TRACE( DbgInfo, L_152,\r\nlp->dev->name, probe_rsp->dataLength );\r\nDBG_TRACE(DbgInfo, L_153,\r\nlp->dev->name, probe_rsp->DA);\r\nDBG_TRACE(DbgInfo, L_154,\r\nlp->dev->name, probe_rsp->SA);\r\nDBG_TRACE(DbgInfo, L_155\r\nL_156,\r\nlp->dev->name,\r\nprobe_rsp->timeStamp[0],\r\nprobe_rsp->timeStamp[1],\r\nprobe_rsp->timeStamp[2],\r\nprobe_rsp->timeStamp[3],\r\nprobe_rsp->timeStamp[4],\r\nprobe_rsp->timeStamp[5],\r\nprobe_rsp->timeStamp[6],\r\nprobe_rsp->timeStamp[7]);\r\nDBG_TRACE( DbgInfo, L_157,\r\nlp->dev->name, probe_rsp->beaconInterval );\r\nDBG_TRACE( DbgInfo, L_158,\r\nlp->dev->name, probe_rsp->capability );\r\nDBG_TRACE( DbgInfo, L_159,\r\nlp->dev->name, probe_rsp->rawData[1] );\r\nif ( probe_rsp->rawData[1] > 0 ) {\r\nchar ssid[HCF_MAX_NAME_LEN];\r\nmemset( ssid, 0, sizeof( ssid ));\r\nstrncpy( ssid, &probe_rsp->rawData[2],\r\nmin_t(u8,\r\nprobe_rsp->rawData[1],\r\nHCF_MAX_NAME_LEN - 1));\r\nDBG_TRACE( DbgInfo, L_160,\r\nlp->dev->name, ssid );\r\n}\r\nwpa_ie = wl_parse_wpa_ie( probe_rsp, &wpa_ie_len );\r\nif ( wpa_ie != NULL ) {\r\nDBG_TRACE( DbgInfo, L_161,\r\nlp->dev->name, wl_print_wpa_ie( wpa_ie, wpa_ie_len ));\r\n}\r\nDBG_TRACE( DbgInfo, L_162,\r\nlp->dev->name, probe_rsp->flags );\r\n}\r\nDBG_TRACE( DbgInfo, L_163 );\r\nif ( probe_rsp->length == 1 ) {\r\nDBG_TRACE( DbgInfo, L_164 );\r\nlp->probe_results.num_aps = lp->probe_num_aps;\r\nlp->probe_results.scan_complete = TRUE;\r\nlp->probe_num_aps = 0;\r\nwl_wext_event_scan_complete( lp->dev );\r\n} else {\r\nif ( lp->probe_num_aps == 0 ) {\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\nlp->probe_num_aps++;\r\n} else {\r\nint count;\r\nint unique = 1;\r\nfor( count = 0; count < lp->probe_num_aps; count++ ) {\r\nif ( memcmp( &( probe_rsp->BSSID ),\r\nlp->probe_results.ProbeTable[count].BSSID,\r\nETH_ALEN ) == 0 ) {\r\nunique = 0;\r\n}\r\n}\r\nif ( unique ) {\r\nif ( lp->probe_num_aps < MAX_NAPS )\r\n{\r\nmemcpy( &( lp->probe_results.ProbeTable[lp->probe_num_aps] ),\r\nprobe_rsp, sizeof( PROBE_RESP ));\r\n}\r\nelse\r\n{\r\nDBG_WARNING( DbgInfo, L_165 );\r\n}\r\nlp->probe_num_aps++;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CFG_LINK_STAT:\r\n#define F_28 ((LINK_STATUS_STRCT *)ltv)\r\nDBG_TRACE( DbgInfo, L_166 );\r\nswitch( ls->linkStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_167 );\r\nwl_wext_event_ap( lp->dev );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_168 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_169 );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, L_170 );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, L_171 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_172,\r\nls->linkStatus );\r\nbreak;\r\n}\r\nbreak;\r\n#undef F_28\r\ncase CFG_ASSOC_STAT:\r\nDBG_TRACE( DbgInfo, L_173 );\r\n{\r\nASSOC_STATUS_STRCT *as = (ASSOC_STATUS_STRCT *)ltv;\r\nswitch( as->assocStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_174 );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_175 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_176 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_177,\r\nas->assocStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, L_178,\r\nas->staAddr);\r\nif (( as->assocStatus == 2 ) && ( as->len == 8 )) {\r\nDBG_TRACE(DbgInfo, L_179,\r\nas->oldApAddr);\r\n}\r\n}\r\nbreak;\r\ncase CFG_SECURITY_STAT:\r\nDBG_TRACE( DbgInfo, L_180 );\r\n{\r\nSECURITY_STATUS_STRCT *ss = (SECURITY_STATUS_STRCT *)ltv;\r\nswitch( ss->securityStatus ) {\r\ncase 1:\r\nDBG_TRACE( DbgInfo, L_181 );\r\nbreak;\r\ncase 2:\r\nDBG_TRACE( DbgInfo, L_182 );\r\nbreak;\r\ncase 3:\r\nDBG_TRACE( DbgInfo, L_183 );\r\nbreak;\r\ncase 4:\r\nDBG_TRACE( DbgInfo, L_184 );\r\nbreak;\r\ncase 5:\r\nDBG_TRACE( DbgInfo, L_185 );\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_186,\r\nss->securityStatus );\r\nbreak;\r\n}\r\nDBG_TRACE(DbgInfo, L_187,\r\nss->staAddr);\r\nDBG_TRACE(DbgInfo, L_188,\r\nss->reason);\r\n}\r\nbreak;\r\ncase CFG_WMP:\r\nDBG_TRACE( DbgInfo, L_189, ltv->len );\r\n{\r\nWMP_RSP_STRCT *wmp_rsp = (WMP_RSP_STRCT *)ltv;\r\nDBG_TRACE( DbgInfo, L_190,\r\nwmp_rsp->wmpRsp.wmpHdr.type );\r\nswitch( wmp_rsp->wmpRsp.wmpHdr.type ) {\r\ncase WVLAN_WMP_PDU_TYPE_LT_RSP:\r\n{\r\n#if V_249\r\nLINKTEST_RSP_STRCT *lt_rsp = (LINKTEST_RSP_STRCT *)ltv;\r\n#endif\r\nDBG_TRACE( DbgInfo, L_191 );\r\nDBG_TRACE( DbgInfo, L_192 );\r\nDBG_TRACE( DbgInfo, L_193, lt_rsp->len );\r\nDBG_TRACE( DbgInfo, L_194, lt_rsp->ltRsp.ltRsp.name );\r\nDBG_TRACE( DbgInfo, L_195, lt_rsp->ltRsp.ltRsp.signal );\r\nDBG_TRACE( DbgInfo, L_196, lt_rsp->ltRsp.ltRsp.noise );\r\nDBG_TRACE( DbgInfo, L_197, lt_rsp->ltRsp.ltRsp.rxFlow );\r\nDBG_TRACE( DbgInfo, L_198, lt_rsp->ltRsp.ltRsp.dataRate );\r\nDBG_TRACE( DbgInfo, L_199, lt_rsp->ltRsp.ltRsp.protocol );\r\nDBG_TRACE( DbgInfo, L_200, lt_rsp->ltRsp.ltRsp.station );\r\nDBG_TRACE( DbgInfo, L_201, lt_rsp->ltRsp.ltRsp.dataRateCap );\r\nDBG_TRACE( DbgInfo, L_202,\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[0],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[1],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[2],\r\nlt_rsp->ltRsp.ltRsp.powerMgmt[3] );\r\nDBG_TRACE( DbgInfo, L_203,\r\nlt_rsp->ltRsp.ltRsp.robustness[0],\r\nlt_rsp->ltRsp.ltRsp.robustness[1],\r\nlt_rsp->ltRsp.ltRsp.robustness[2],\r\nlt_rsp->ltRsp.ltRsp.robustness[3] );\r\nDBG_TRACE( DbgInfo, L_204, lt_rsp->ltRsp.ltRsp.scaling );\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase CFG_NULL:\r\nDBG_TRACE( DbgInfo, L_205 );\r\nbreak;\r\ncase CFG_UPDATED_INFO_RECORD:\r\nDBG_TRACE( DbgInfo, L_206 );\r\nltv_val = CNV_INT_TO_LITTLE( ltv->u.u16[0] );\r\nswitch( ltv_val ) {\r\ncase CFG_CUR_COUNTRY_INFO:\r\nDBG_TRACE( DbgInfo, L_207 );\r\nwl_connect( lp );\r\nbreak;\r\ncase CFG_PORT_STAT:\r\nbreak;\r\ndefault:\r\nDBG_WARNING( DbgInfo, L_208, ltv_val );\r\n}\r\nbreak;\r\ndefault:\r\nDBG_TRACE( DbgInfo, L_209, ltv->typ );\r\nbreak;\r\n}\r\n}\r\n#endif\r\n#ifdef F_5\r\nvoid wl_wds_netdev_register( struct wl_private *lp )\r\n{\r\nint count;\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nif ( register_netdev( lp->wds_port[count].dev ) != 0 ) {\r\nDBG_WARNING( DbgInfo, L_210,\r\n( count + 1 ));\r\n}\r\nlp->wds_port[count].is_registered = TRUE;\r\nmemcpy( lp->wds_port[count].dev->dev_addr, lp->MACAddress, ETH_ALEN );\r\nlp->wds_port[count].dev->addr_len = ETH_ALEN;\r\n}\r\n}\r\n}\r\n}\r\nvoid wl_wds_netdev_deregister( struct wl_private *lp )\r\n{\r\nint count;\r\nif ( CNV_INT_TO_LITTLE( lp->hcfCtx.IFB_FWIdentity.comp_id ) == COMP_ID_FW_AP ) {\r\nfor( count = 0; count < NUM_WDS_PORTS; count++ ) {\r\nif ( WVLAN_VALID_MAC_ADDRESS( lp->wds_port[count].wdsAddress )) {\r\nunregister_netdev( lp->wds_port[count].dev );\r\n}\r\nlp->wds_port[count].is_registered = FALSE;\r\n}\r\n}\r\n}\r\n#endif\r\n#if 0\r\nstatic void printf_hcf_16(struct seq_file *m, const char *s, hcf_16 *p, int n)\r\n{\r\nint i, len;\r\nseq_printf(m, "%-20.20s: ", s);\r\nlen = 22;\r\nfor (i = 0; i < n; i++) {\r\nif (len % 80 > 75)\r\nseq_putc(m, '\n');\r\nseq_printf(m, "%04X ", p[i]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void printf_hcf_8(struct seq_file *m, const char *s, hcf_8 *p, int n)\r\n{\r\nint i, len;\r\nseq_printf(m, "%-20.20s: ", s);\r\nlen = 22;\r\nfor (i = 0; i <= n; i++) {\r\nif (len % 80 > 77)\r\nseq_putc(m, '\n');\r\nseq_printf(m, "%02X ", p[i]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void printf_strct(struct seq_file *m, const char *s, hcf_16 *p)\r\n{\r\nint i, len;\r\nseq_printf(m, "%-20.20s: ", s);\r\nlen = 22;\r\nfor ( i = 0; i <= *p; i++ ) {\r\nif (len % 80 > 75)\r\nseq_putc(m, '\n');\r\nseq_printf(m,"%04X ", p[i]);\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nint scull_read_procmem(struct seq_file *m, void *v)\r\n{\r\nstruct wl_private *lp = m->private;\r\nIFBP ifbp;\r\nCFG_HERMES_TALLIES_STRCT *p;\r\nif (lp == NULL) {\r\nseq_puts(m, "No wl_private in scull_read_procmem\n" );\r\n} else if ( lp->wlags49_type == 0 ){\r\nifbp = &lp->hcfCtx;\r\nseq_printf(m, "Magic: 0x%04X\n", ifbp->IFB_Magic );\r\nseq_printf(m, "IOBase: 0x%04X\n", ifbp->IFB_IOBase );\r\nseq_printf(m, "LinkStat: 0x%04X\n", ifbp->IFB_LinkStat );\r\nseq_printf(m, "DSLinkStat: 0x%04X\n", ifbp->IFB_DSLinkStat );\r\nseq_printf(m, "TickIni: 0x%08lX\n", ifbp->IFB_TickIni );\r\nseq_printf(m, "TickCnt: 0x%04X\n", ifbp->IFB_TickCnt );\r\nseq_printf(m, "IntOffCnt: 0x%04X\n", ifbp->IFB_IntOffCnt );\r\nprintf_hcf_16(m, "IFB_FWIdentity",\r\n&ifbp->IFB_FWIdentity.len, ifbp->IFB_FWIdentity.len + 1 );\r\n} else if ( lp->wlags49_type == 1 ) {\r\nseq_printf(m, "Channel: 0x%04X\n", lp->Channel );\r\n#ifdef F_29\r\n#endif\r\nseq_printf(m, "IFB: 0x%p\n", &lp->hcfCtx );\r\nseq_printf(m, "flags: %#.8lX\n", lp->flags );\r\nseq_printf(m, "DebugFlag(wl_private) 0x%04X\n", lp->DebugFlag );\r\n#if V_249\r\nseq_printf(m, "DebugFlag (DbgInfo): 0x%08lX\n", DbgInfo->DebugFlag );\r\n#endif\r\nseq_printf(m, "is_registered: 0x%04X\n", lp->is_registered );\r\nprintf_strct( m, "driverInfo", (hcf_16*)&lp->driverInfo );\r\nprintf_strct( m, "driverIdentity", (hcf_16*)&lp->driverIdentity );\r\nprintf_strct( m, "StationIdentity", (hcf_16*)&lp->StationIdentity );\r\nprintf_strct( m, "PrimaryIdentity", (hcf_16*)&lp->hcfCtx.IFB_PRIIdentity );\r\nprintf_strct( m, "PrimarySupplier", (hcf_16*)&lp->hcfCtx.IFB_PRISup );\r\nprintf_strct( m, "NICIdentity", (hcf_16*)&lp->NICIdentity );\r\nseq_printf(m, "txBytes: 0x%08lX\n", lp->txBytes );\r\nseq_printf(m, "maxPort: 0x%04X\n", lp->maxPort );\r\nseq_printf(m, "PortType: 0x%04X\n", lp->PortType );\r\nseq_printf(m, "Channel: 0x%04X\n", lp->Channel );\r\nseq_printf(m, "TxRateControl[2]: 0x%04X 0x%04X\n",\r\nlp->TxRateControl[0], lp->TxRateControl[1] );\r\nseq_printf(m, "DistanceBetweenAPs: 0x%04X\n", lp->DistanceBetweenAPs );\r\nseq_printf(m, "RTSThreshold: 0x%04X\n", lp->RTSThreshold );\r\nseq_printf(m, "PMEnabled: 0x%04X\n", lp->PMEnabled );\r\nseq_printf(m, "MicrowaveRobustness: 0x%04X\n", lp->MicrowaveRobustness );\r\nseq_printf(m, "CreateIBSS: 0x%04X\n", lp->CreateIBSS );\r\nseq_printf(m, "MulticastReceive: 0x%04X\n", lp->MulticastReceive );\r\nseq_printf(m, "MaxSleepDuration: 0x%04X\n", lp->MaxSleepDuration );\r\nprintf_hcf_8(m, "MACAddress", lp->MACAddress, ETH_ALEN );\r\nseq_printf(m, "NetworkName: %.32s\n", lp->NetworkName );\r\nseq_printf(m, "EnableEncryption: 0x%04X\n", lp->EnableEncryption );\r\nprintf_hcf_8( m, "Key1", lp->Key1, MAX_KEY_LEN );\r\nseq_printf(m, "TransmitKeyID: 0x%04X\n", lp->TransmitKeyID );\r\nseq_printf(m, "driverEnable: 0x%04X\n", lp->driverEnable );\r\nseq_printf(m, "wolasEnable: 0x%04X\n", lp->wolasEnable );\r\nseq_printf(m, "atimWindow: 0x%04X\n", lp->atimWindow );\r\nseq_printf(m, "holdoverDuration: 0x%04X\n", lp->holdoverDuration );\r\nseq_printf(m, "authentication: 0x%04X\n", lp->authentication );\r\nseq_printf(m, "promiscuousMode: 0x%04X\n", lp->promiscuousMode );\r\nseq_printf(m, "DownloadFirmware: 0x%04X\n", lp->DownloadFirmware );\r\nseq_printf(m, "AuthKeyMgmtSuite: 0x%04X\n", lp->AuthKeyMgmtSuite );\r\nseq_printf(m, "loadBalancing: 0x%04X\n", lp->loadBalancing );\r\nseq_printf(m, "mediumDistribution: 0x%04X\n", lp->mediumDistribution );\r\nseq_printf(m, "txPowLevel: 0x%04X\n", lp->txPowLevel );\r\nseq_printf(m, "connectionControl: 0x%04X\n", lp->connectionControl );\r\nseq_printf(m, "ownBeaconInterval: 0x%04X\n", lp->ownBeaconInterval );\r\nseq_printf(m, "coexistence: 0x%04X\n", lp->coexistence );\r\nseq_printf(m, "netif_queue_on: 0x%04X\n", lp->netif_queue_on );\r\nseq_printf(m, "txQ_count: 0x%04X\n", lp->txQ_count );\r\nseq_printf(m, "probe_num_aps: 0x%04X\n", lp->probe_num_aps );\r\nseq_printf(m, "use_dma: 0x%04X\n", lp->use_dma );\r\n#ifdef F_9\r\nseq_printf(m, "useRTS: 0x%04X\n", lp->useRTS );\r\n#endif\r\n#if 1\r\nseq_printf(m, "DTIMPeriod: 0x%04X\n", lp->DTIMPeriod );\r\nseq_printf(m, "multicastPMBuffering: 0x%04X\n", lp->multicastPMBuffering );\r\nseq_printf(m, "RejectAny: 0x%04X\n", lp->RejectAny );\r\nseq_printf(m, "ExcludeUnencrypted: 0x%04X\n", lp->ExcludeUnencrypted );\r\nseq_printf(m, "intraBSSRelay: 0x%04X\n", lp->intraBSSRelay );\r\nseq_printf(m, "wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\n#ifdef F_5\r\n#endif\r\n#endif\r\n} else if ( lp->wlags49_type == 2 ){\r\nseq_printf(m, "tallies to be added\n" );\r\np = &lp->hcfCtx.IFB_NIC_Tallies;\r\nseq_printf(m, "TxUnicastFrames: %08lX\n", p->TxUnicastFrames );\r\nseq_printf(m, "TxMulticastFrames: %08lX\n", p->TxMulticastFrames );\r\nseq_printf(m, "TxFragments: %08lX\n", p->TxFragments );\r\nseq_printf(m, "TxUnicastOctets: %08lX\n", p->TxUnicastOctets );\r\nseq_printf(m, "TxMulticastOctets: %08lX\n", p->TxMulticastOctets );\r\nseq_printf(m, "TxDeferredTransmissions: %08lX\n", p->TxDeferredTransmissions );\r\nseq_printf(m, "TxSingleRetryFrames: %08lX\n", p->TxSingleRetryFrames );\r\nseq_printf(m, "TxMultipleRetryFrames: %08lX\n", p->TxMultipleRetryFrames );\r\nseq_printf(m, "TxRetryLimitExceeded: %08lX\n", p->TxRetryLimitExceeded );\r\nseq_printf(m, "TxDiscards: %08lX\n", p->TxDiscards );\r\nseq_printf(m, "RxUnicastFrames: %08lX\n", p->RxUnicastFrames );\r\nseq_printf(m, "RxMulticastFrames: %08lX\n", p->RxMulticastFrames );\r\nseq_printf(m, "RxFragments: %08lX\n", p->RxFragments );\r\nseq_printf(m, "RxUnicastOctets: %08lX\n", p->RxUnicastOctets );\r\nseq_printf(m, "RxMulticastOctets: %08lX\n", p->RxMulticastOctets );\r\nseq_printf(m, "RxFCSErrors: %08lX\n", p->RxFCSErrors );\r\nseq_printf(m, "RxDiscardsNoBuffer: %08lX\n", p->RxDiscardsNoBuffer );\r\nseq_printf(m, "TxDiscardsWrongSA: %08lX\n", p->TxDiscardsWrongSA );\r\nseq_printf(m, "RxWEPUndecryptable: %08lX\n", p->RxWEPUndecryptable );\r\nseq_printf(m, "RxMsgInMsgFragments: %08lX\n", p->RxMsgInMsgFragments );\r\nseq_printf(m, "RxMsgInBadMsgFragments: %08lX\n", p->RxMsgInBadMsgFragments );\r\nseq_printf(m, "RxDiscardsWEPICVError: %08lX\n", p->RxDiscardsWEPICVError );\r\nseq_printf(m, "RxDiscardsWEPExcluded: %08lX\n", p->RxDiscardsWEPExcluded );\r\n#if ( V_250 ) & V_251\r\n#endif\r\n} else if ( lp->wlags49_type & 0x8000 ) {\r\n#if V_249\r\nDbgInfo->DebugFlag = lp->wlags49_type & 0x7FFF;\r\n#endif\r\nlp->wlags49_type = 0;\r\n} else {\r\nseq_printf(m, "unknown value for wlags49_type: 0x%08lX\n", lp->wlags49_type );\r\nseq_puts(m,\r\n"0x0000 - IFB\n"\r\n"0x0001 - wl_private\n"\r\n"0x0002 - Tallies\n"\r\n"0x8xxx - Change debufflag\n"\r\n"ERROR 0001\nWARNING 0002\nNOTICE 0004\nTRACE 0008\n"\r\n"VERBOSE 0010\nPARAM 0020\nBREAK 0040\nRX 0100\n"\r\n"TX 0200\nDS 0400\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int write_int(struct file *file, const char *buffer, unsigned long count, void *data)\r\n{\r\nstatic char proc_number[11];\r\nunsigned int nr = 0;\r\nif (count > 9) {\r\ncount = -EINVAL;\r\n} else if ( copy_from_user(proc_number, buffer, count) ) {\r\ncount = -EFAULT;\r\n}\r\nif (count > 0 ) {\r\nproc_number[count] = 0;\r\nnr = simple_strtoul(proc_number , NULL, 0);\r\n*(unsigned int *)data = nr;\r\nif ( nr & 0x8000 ) {\r\n#if V_249\r\nDbgInfo->DebugFlag = nr & 0x7FFF;\r\n#endif\r\n}\r\n}\r\nDBG_PRINT( "value: %08X\n", nr );\r\nreturn count;\r\n}\r\n#endif\r\n#ifdef F_30\r\n#define F_31 ( T_1 ) (jiffies+(x))\r\n#define F_32 0x8000\r\nlp->timer_oor_cnt = DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( 3 * HZ );\r\nadd_timer( &lp->timer_oor );\r\nprintk(KERN_NOTICE L_211, jiffies );\r\n#endif\r\n#ifdef F_30\r\nvoid timer_oor( u_long arg )\r\n{\r\nstruct wl_private *lp = (struct wl_private *)arg;\r\nDBG_PARAM( DbgInfo, L_212, L_213, arg );\r\nprintk(KERN_NOTICE L_214, jiffies, lp->timer_oor_cnt );\r\nlp->timer_oor_cnt += 10;\r\nif ( (lp->timer_oor_cnt & ~DS_OOR) > 300 ) {\r\nlp->timer_oor_cnt = 300;\r\n}\r\nlp->timer_oor_cnt |= DS_OOR;\r\ninit_timer( &lp->timer_oor );\r\nlp->timer_oor.function = timer_oor;\r\nlp->timer_oor.data = (unsigned long)lp;\r\nlp->timer_oor.expires = RUN_AT( (lp->timer_oor_cnt & ~DS_OOR) * HZ );\r\nadd_timer( &lp->timer_oor );\r\n}\r\n#endif\r\nMODULE_LICENSE(L_215);
