T_1 F_1 ( void )\r\n{\r\nstatic T_2 V_1 ;\r\nif ( ! F_2 ( & V_1 ) )\r\nF_3 ( & V_1 , ( ( T_1 ) F_4 () ) << 32 ) ;\r\nreturn F_5 ( & V_1 ) ;\r\n}\r\nstatic const char * F_6 ( unsigned int V_2 )\r\n{\r\nreturn V_2 < F_7 ( V_3 ) ?\r\nV_3 [ V_2 ] : L_1 ;\r\n}\r\nvoid F_8 ( const char * V_4 , unsigned int V_5 ,\r\nconst char * V_6 [] , unsigned int V_7 )\r\n{\r\nint V_8 , V_9 = 0 ;\r\nconst char * V_10 ;\r\nchar V_11 [ 84 ] ;\r\nfor ( V_8 = 0 ; V_8 < V_7 ; V_8 ++ ) {\r\nif ( ! ( V_5 & ( 1U << V_8 ) ) )\r\ncontinue;\r\nV_10 = V_6 [ V_8 ] ;\r\nif ( ! V_10 )\r\ncontinue;\r\nif ( V_9 && V_9 + strlen ( V_10 ) + 2 > 80 ) {\r\nF_9 ( L_2 , V_11 ) ;\r\nV_9 = 0 ;\r\n}\r\nif ( ! V_9 )\r\nV_9 = snprintf ( V_11 , sizeof( V_11 ) , L_3 , V_4 , V_10 ) ;\r\nelse\r\nV_9 += snprintf ( V_11 + V_9 , sizeof( V_11 ) - V_9 , L_4 , V_10 ) ;\r\n}\r\nif ( V_9 )\r\nF_9 ( L_2 , V_11 ) ;\r\n}\r\nstatic void F_10 ( const char * V_4 ,\r\nconst struct V_12 * V_13 )\r\n{\r\nif ( V_13 -> V_14 & V_15 )\r\nF_9 ( L_5processor_type: %d, %s\nL_6unknownL_7%sL_8processor_isa: %d, %s\nL_9unknownL_10%sL_8error_type: 0x%02x\nL_11%sL_8operation: %d, %s\nL_12unknownL_13%sL_8flags: 0x%02x\nL_14%sL_8level: %d\nL_15%sL_8version_info: 0x%016llx\nL_16%sL_8processor_id: 0x%016llx\nL_17%sL_8target_address: 0x%016llx\nL_18%sL_8requestor_id: 0x%016llx\nL_19%sL_8responder_id: 0x%016llx\nL_20%sL_8IP: 0x%016llx\nL_21unknownL_22no errorL_22single-bit ECCL_22multi-bit ECCL_22single-symbol chipkill ECCL_22multi-symbol chipkill ECCL_22master abortL_22target abortL_22parity errorL_22watchdog timeoutL_22invalid addressL_22mirror BrokenL_22memory sparingL_22scrub corrected errorL_22scrub uncorrected errorL_23%sL_8error_status: 0x%016llx\nL_24%sL_8physical_address: 0x%016llx\nL_25%sL_8physical_address_mask: 0x%016llx\nL_26%sL_8node: %d\nL_27%sL_8card: %d\nL_28%sL_8module: %d\nL_29%sL_8bank: %d\nL_30%sL_8device: %d\nL_31%sL_8row: %d\nL_32%sL_8column: %d\nL_33%sL_8bit_position: %d\nL_34%sL_8requestor_id: 0x%016llx\nL_35%sL_8responder_id: 0x%016llx\nL_36%sL_8target_id: 0x%016llx\nL_37%sL_8error_type: %d, %s\nL_38unknownL_39PCIe end pointL_22legacy PCI end pointL_22unknownL_22unknownL_22root portL_22upstream switch portL_22downstream switch portL_22PCIe to PCI/PCI-X bridgeL_22PCI/PCI-X to PCIe bridgeL_22root complex integrated endpoint deviceL_22root complex event collectorL_40%sL_8port_type: %d, %s\nL_41unknownL_42%sL_8version: %d.%d\nL_43%sL_8command: 0x%04x , status: 0x%04x\nL_44%sL_8device_id: %04x:%02x:%02x.%x\nL_45%sL_8slot: %d\nL_46%sL_8secondary_bus: 0x%02x\nL_47%sL_8vendor_id: 0x%04x , device_id: 0x%04x\nL_48%sL_8class_code: %02x%02x%02x\nL_49%sL_8serial number: 0x%04x , 0x%04x\nL_50%sL_8bridge: secondary_status: 0x%04x , control: 0x%04x\nL_51primaryL_22containment warningL_22resetL_22threshold exceededL_22resource not accessibleL_22latent errorL_52%sL_8section: %d, severity: %d, %s\nL_53%sL_8flags: 0x%02x\nL_54%sL_8fru_id: %pUl\nL_55%sL_8fru_text: %.20s\nL_56%sL_8section_type: general processor error\nL_57%sL_8section_type: memory error\nL_58%sL_8section_type: PCIe error\nL_59%sL_8section type: unknown, %pUl\nL_60error section length is too small\nL_61%sL_8APEI generic hardware error status\nL_62%sL_8severity: %d, %s\n"
