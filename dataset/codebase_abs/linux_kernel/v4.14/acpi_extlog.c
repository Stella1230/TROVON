static struct V_1 * F_1 ( int V_2 , int V_3 )\r\n{\r\nint V_4 ;\r\nT_1 V_5 ;\r\nstruct V_1 * V_6 ;\r\nF_2 ( V_2 < 0 ) ;\r\nV_4 = F_3 ( V_2 , V_3 ) ;\r\nV_5 = F_4 ( V_4 ) ;\r\nif ( ( V_5 & V_7 ) == 0 )\r\nreturn NULL ;\r\nV_5 &= V_8 ;\r\nV_6 = (struct V_1 * ) F_5 ( V_5 ) ;\r\nif ( V_6 -> V_9 == 0 )\r\nreturn NULL ;\r\nreturn V_6 ;\r\n}\r\nstatic void F_6 ( const char * V_10 ,\r\nstruct V_1 * V_6 , int V_2 )\r\n{\r\nstatic T_2 V_11 ;\r\nunsigned int V_12 ;\r\nchar V_13 [ 64 ] ;\r\nif ( ! V_10 ) {\r\nif ( V_6 -> V_14 <= V_15 )\r\nV_10 = V_16 ;\r\nelse\r\nV_10 = V_17 ;\r\n}\r\nV_12 = F_7 ( & V_11 ) ;\r\nsnprintf ( V_13 , sizeof( V_13 ) , L_1 , V_10 , V_12 ) ;\r\nF_8 ( L_2Hardware error detected on CPU%d\nL_3;\r\nguid_t *sec_type;\r\nstatic u32 err_seq;\r\nestatus = extlog_elog_entry_check(cpu, bank);\r\nif (estatus == NULL)\r\nreturn NOTIFY_DONE;\r\nmemcpy(elog_buf, (void *)estatus, ELOG_ENTRY_LEN);\r\nestatus->block_status = 0;\r\ntmp = (struct acpi_hest_generic_status *)elog_buf;\r\nif (!ras_userspace_consumers()) {\r\nprint_extlog_rcd(NULL, tmp, cpu);\r\ngoto out;\r\n}\r\nerr_seq++;\r\ngdata = (struct acpi_hest_generic_data *)(tmp + 1);\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_ID)\r\nfru_id = (guid_t *)gdata->fru_id;\r\nif (gdata->validation_bits & CPER_SEC_VALID_FRU_TEXT)\r\nfru_text = gdata->fru_text;\r\nsec_type = (guid_t *)gdata->section_type;\r\nif (guid_equal(sec_type, &CPER_SEC_PLATFORM_MEM)) {\r\nstruct cper_sec_mem_err *mem = (void *)(gdata + 1);\r\nif (gdata->error_data_length >= sizeof(*mem))\r\ntrace_extlog_mem_event(mem, err_seq, fru_id, fru_text,\r\n(u8)gdata->error_severity);\r\n}\r\nout:\r\nreturn NOTIFY_STOP;\r\n}\r\nstatic bool __init extlog_get_l1addr(void)\r\n{\r\nguid_t guid;\r\nacpi_handle handle;\r\nunion acpi_object *obj;\r\nif (guid_parse(extlog_dsm_uuid, &guid))\r\nreturn false;\r\nif (ACPI_FAILURE(acpi_get_handle(NULL, L_4, &handle)))\r\nreturn false;\r\nif (!acpi_check_dsm(handle, &guid, EXTLOG_DSM_REV, 1 << EXTLOG_FN_ADDR))\r\nreturn false;\r\nobj = acpi_evaluate_dsm_typed(handle, &guid, EXTLOG_DSM_REV,\r\nEXTLOG_FN_ADDR, NULL, ACPI_TYPE_INTEGER);\r\nif (!obj) {\r\nreturn false;\r\n} else {\r\nl1_dirbase = obj->integer.value;\r\nACPI_FREE(obj);\r\n}\r\nif (l1_dirbase & ((1 << 12) - 1)) {\r\npr_warn(FW_BUG L_5,\r\nl1_dirbase);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic struct notifier_block extlog_mce_dec = {\r\n.notifier_call = extlog_print,\r\n.priority = MCE_PRIO_EXTLOG,\r\n};\r\nstatic int __init extlog_init(void)\r\n{\r\nstruct extlog_l1_head *l1_head;\r\nvoid __iomem *extlog_l1_hdr;\r\nsize_t l1_hdr_size;\r\nstruct resource *r;\r\nu64 cap;\r\nint rc;\r\nrdmsrl(MSR_IA32_MCG_CAP, cap);\r\nif (!(cap & MCG_ELOG_P) || !extlog_get_l1addr())\r\nreturn -ENODEV;\r\nif (edac_get_report_status() == EDAC_REPORTING_FORCE) {\r\npr_warn(L_6);\r\nreturn -EPERM;\r\n}\r\nrc = -EINVAL;\r\nl1_hdr_size = sizeof(struct extlog_l1_head);\r\nr = request_mem_region(l1_dirbase, l1_hdr_size, L_7);\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)l1_dirbase,\r\n(unsigned long long)l1_dirbase + l1_hdr_size);\r\ngoto err;\r\n}\r\nextlog_l1_hdr = acpi_os_map_iomem(l1_dirbase, l1_hdr_size);\r\nl1_head = (struct extlog_l1_head *)extlog_l1_hdr;\r\nl1_size = l1_head->total_len;\r\nl1_percpu_entry = l1_head->entries;\r\nelog_base = l1_head->elog_base;\r\nelog_size = l1_head->elog_len;\r\nacpi_os_unmap_iomem(extlog_l1_hdr, l1_hdr_size);\r\nrelease_mem_region(l1_dirbase, l1_hdr_size);\r\nr = request_mem_region(l1_dirbase, l1_size, L_8);\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)l1_dirbase,\r\n(unsigned long long)l1_dirbase + l1_size);\r\ngoto err;\r\n}\r\nextlog_l1_addr = acpi_os_map_iomem(l1_dirbase, l1_size);\r\nl1_entry_base = (u64 *)((u8 *)extlog_l1_addr + l1_hdr_size);\r\nr = request_mem_region(elog_base, elog_size, L_9);\r\nif (!r) {\r\npr_warn(FW_BUG EMCA_BUG,\r\n(unsigned long long)elog_base,\r\n(unsigned long long)elog_base + elog_size);\r\ngoto err_release_l1_dir;\r\n}\r\nelog_addr = acpi_os_map_iomem(elog_base, elog_size);\r\nrc = -ENOMEM;\r\nelog_buf = kmalloc(ELOG_ENTRY_LEN, GFP_KERNEL);\r\nif (elog_buf == NULL)\r\ngoto err_release_elog;\r\nold_edac_report_status = edac_get_report_status();\r\nedac_set_report_status(EDAC_REPORTING_DISABLED);\r\nmce_register_decode_chain(&extlog_mce_dec);\r\n((struct extlog_l1_head *)extlog_l1_addr)->flags |= FLAG_OS_OPTIN;\r\nreturn 0;\r\nerr_release_elog:\r\nif (elog_addr)\r\nacpi_os_unmap_iomem(elog_addr, elog_size);\r\nrelease_mem_region(elog_base, elog_size);\r\nerr_release_l1_dir:\r\nif (extlog_l1_addr)\r\nacpi_os_unmap_iomem(extlog_l1_addr, l1_size);\r\nrelease_mem_region(l1_dirbase, l1_size);\r\nerr:\r\npr_warn(FW_BUG L_10);\r\nreturn rc;\r\n}\r\nstatic void __exit extlog_exit(void)\r\n{\r\nedac_set_report_status(old_edac_report_status);\r\nmce_unregister_decode_chain(&extlog_mce_dec);\r\n((struct extlog_l1_head *)extlog_l1_addr)->flags &= ~FLAG_OS_OPTIN;\r\nif (extlog_l1_addr)\r\nacpi_os_unmap_iomem(extlog_l1_addr, l1_size);\r\nif (elog_addr)\r\nacpi_os_unmap_iomem(elog_addr, elog_size);\r\nrelease_mem_region(elog_base, elog_size);\r\nrelease_mem_region(l1_dirbase, l1_size);\r\nkfree(elog_buf);\r\n}\r\nmodule_init(extlog_init);\r\nmodule_exit(extlog_exit);\r\nMODULE_AUTHOR(L_11);\r\nMODULE_DESCRIPTION(L_12);\r\nMODULE_LICENSE(L_13);
